; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\timer.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CTimer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimer@@QAE@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimer@@QAE@MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CTimer@@QAENXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@CTimer@@QAEXMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CTimer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Over@CTimer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLeftTime@CTimer@@QAENXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInterval@CTimer@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTimer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTimer@@QAEXN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSunPercent@CGameTimer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoonPercent@CGameTimer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGameTimer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGameTimer@@QAE@N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGameTimer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCurrentTime@CGameTimer@@QAEXN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CGameTimer@@QAENXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCurrentTime@CGameTimer@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compute@CGameTimer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTime@CGameTimer@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@CSkipTimer@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Over@CSkipTimer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNeedSkip@CSkipTimer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@CSkipTimer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMaxSkip@CSkipTimer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDate@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDate@@QAE@HHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDate@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNight@CDate@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDay@CDate@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeShade@CDate@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeColor@CDate@@QAEXPAUtagTIMECOLOR@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Process@CDate@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitFST@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFrameSkip@@YAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFrameSkip@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTime@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDrawTiming@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFST@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSkipTimer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSkipTimer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCSkipTimer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTimer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSkipTimer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTimer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCTimer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?m_lTime@@3KA					; m_lTime
PUBLIC	?m_dwOldTime@@3KA				; m_dwOldTime
_BSS	SEGMENT
?m_lTime@@3KA DD 01H DUP (?)				; m_lTime
?m_dwOldTime@@3KA DD 01H DUP (?)			; m_dwOldTime
_BSS	ENDS
_DATA	SEGMENT
_s_bFrameSkip DD 01H
_DATA	ENDS
PUBLIC	?GetTime@CTimer@@QAENXZ				; CTimer::GetTime
PUBLIC	__real@41f0000000000000
EXTRN	__fltused:NEAR
EXTRN	__imp__timeGetTime@0:NEAR
;	COMDAT __real@41f0000000000000
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\timer.cpp
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetTime@CTimer@@QAENXZ
_TEXT	SEGMENT
tv67 = -4						; size = 4
?GetTime@CTimer@@QAENXZ PROC NEAR			; CTimer::GetTime, COMDAT
; _this$ = ecx

; 24   : {

  00000	51		 push	 ecx

; 25   : 	//LARGE_INTEGER largeTime = { 0, 0 };
; 26   : 	//QueryPerformanceCounter(&largeTime);
; 27   : #ifdef __GLOBAL_COUNT_0705
; 28   : 	return (double)g_tmCurrent; //((double) largeTime.LowPart + (double) largeTime.HighPart * (double) 0xffffffffffffffff);
; 29   : #else // __GLOBAL_COUNT_0705 
; 30   : 	return (double)timeGetTime(); //((double) largeTime.LowPart + (double) largeTime.HighPart * (double) 0xffffffffffffffff);

  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00007	85 c0		 test	 eax, eax
  00009	89 04 24	 mov	 DWORD PTR tv67[esp+4], eax
  0000c	db 04 24	 fild	 DWORD PTR tv67[esp+4]
  0000f	7d 06		 jge	 SHORT $L187121
  00011	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187121:

; 31   : #endif // __GLOBAL_COUNT_0705
; 32   : }

  00017	59		 pop	 ecx
  00018	c3		 ret	 0
?GetTime@CTimer@@QAENXZ ENDP				; CTimer::GetTime
_TEXT	ENDS
PUBLIC	?Set@CTimer@@QAEXMH@Z				; CTimer::Set
; Function compile flags: /Ogty
;	COMDAT ?Set@CTimer@@QAEXMH@Z
_TEXT	SEGMENT
tv147 = -4						; size = 4
_fInterval$ = 8						; size = 4
_bFirstTimeOut$ = 12					; size = 4
?Set@CTimer@@QAEXMH@Z PROC NEAR				; CTimer::Set, COMDAT
; _this$ = ecx

; 35   : {

  00000	51		 push	 ecx

; 36   : 	m_fInterval		= fInterval;

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _fInterval$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 37   : 	m_curTime	= GetTime();

  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00011	85 c0		 test	 eax, eax
  00013	89 44 24 04	 mov	 DWORD PTR tv147[esp+8], eax
  00017	db 44 24 04	 fild	 DWORD PTR tv147[esp+8]
  0001b	7d 06		 jge	 SHORT $L187132
  0001d	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187132:

; 38   : 	m_endTime	= bFirstTimeOut ? m_curTime : m_curTime + fInterval;

  00023	8b 44 24 10	 mov	 eax, DWORD PTR _bFirstTimeOut$[esp+4]
  00027	dd 56 08	 fst	 QWORD PTR [esi+8]
  0002a	85 c0		 test	 eax, eax
  0002c	75 04		 jne	 SHORT $L187133
  0002e	d8 44 24 0c	 fadd	 DWORD PTR _fInterval$[esp+4]
$L187133:
  00032	dd 5e 10	 fstp	 QWORD PTR [esi+16]
  00035	5e		 pop	 esi

; 39   : }

  00036	59		 pop	 ecx
  00037	c2 08 00	 ret	 8
?Set@CTimer@@QAEXMH@Z ENDP				; CTimer::Set
_TEXT	ENDS
PUBLIC	?Reset@CTimer@@UAEXXZ				; CTimer::Reset
; Function compile flags: /Ogty
;	COMDAT ?Reset@CTimer@@UAEXXZ
_TEXT	SEGMENT
$T187148 = -8						; size = 4
tv147 = -4						; size = 4
?Reset@CTimer@@UAEXXZ PROC NEAR				; CTimer::Reset, COMDAT
; _this$ = ecx

; 42   : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 43   : 	Set( m_fInterval );

  00006	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00009	89 44 24 04	 mov	 DWORD PTR $T187148[esp+12], eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00013	85 c0		 test	 eax, eax
  00015	89 44 24 08	 mov	 DWORD PTR tv147[esp+12], eax
  00019	db 44 24 08	 fild	 DWORD PTR tv147[esp+12]
  0001d	7d 06		 jge	 SHORT $L187149
  0001f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187149:
  00025	dd 56 08	 fst	 QWORD PTR [esi+8]
  00028	d9 44 24 04	 fld	 DWORD PTR $T187148[esp+12]
  0002c	d8 c1		 fadd	 ST(0), ST(1)
  0002e	dd 5e 10	 fstp	 QWORD PTR [esi+16]
  00031	5e		 pop	 esi
  00032	dd d8		 fstp	 ST(0)

; 44   : }

  00034	83 c4 08	 add	 esp, 8
  00037	c3		 ret	 0
?Reset@CTimer@@UAEXXZ ENDP				; CTimer::Reset
_TEXT	ENDS
PUBLIC	?Over@CTimer@@UAEHXZ				; CTimer::Over
PUBLIC	__real@41ebffffffa00000
PUBLIC	__real@41bfffffff000000
;	COMDAT __real@41ebffffffa00000
CONST	SEGMENT
__real@41ebffffffa00000 DQ 041ebffffffa00000r	; 3.7581e+009
CONST	ENDS
;	COMDAT __real@41bfffffff000000
CONST	SEGMENT
__real@41bfffffff000000 DQ 041bfffffff000000r	; 5.36871e+008
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?Over@CTimer@@UAEHXZ
_TEXT	SEGMENT
tv138 = -4						; size = 4
?Over@CTimer@@UAEHXZ PROC NEAR				; CTimer::Over, COMDAT
; _this$ = ecx

; 47   : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 48   : 	double dwCurr	= GetTime();

  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000a	85 c0		 test	 eax, eax
  0000c	89 44 24 04	 mov	 DWORD PTR tv138[esp+8], eax
  00010	db 44 24 04	 fild	 DWORD PTR tv138[esp+8]
  00014	7d 06		 jge	 SHORT $L187160
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187160:

; 49   : 
; 50   : 	if( dwCurr >= m_endTime )

  0001c	dc 56 10	 fcom	 QWORD PTR [esi+16]
  0001f	df e0		 fnstsw	 ax
  00021	f6 c4 01	 test	 ah, 1
  00024	75 0a		 jne	 SHORT $L186728
  00026	dd d8		 fstp	 ST(0)

; 51   : 		return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	5e		 pop	 esi

; 57   : }

  0002e	59		 pop	 ecx
  0002f	c3		 ret	 0
$L186728:

; 52   : 
; 53   : 	if( m_endTime > 3758096381 && dwCurr < 536870911 )

  00030	dd 46 10	 fld	 QWORD PTR [esi+16]
  00033	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@41ebffffffa00000
  00039	df e0		 fnstsw	 ax
  0003b	f6 c4 41	 test	 ah, 65			; 00000041H
  0003e	75 15		 jne	 SHORT $L187159
  00040	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@41bfffffff000000
  00046	df e0		 fnstsw	 ax
  00048	f6 c4 05	 test	 ah, 5
  0004b	7a 0a		 jp	 SHORT $L186729

; 54   : 		return TRUE;

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	5e		 pop	 esi

; 57   : }

  00053	59		 pop	 ecx
  00054	c3		 ret	 0
$L187159:

; 52   : 
; 53   : 	if( m_endTime > 3758096381 && dwCurr < 536870911 )

  00055	dd d8		 fstp	 ST(0)
$L186729:

; 55   : 
; 56   : 	return FALSE;

  00057	33 c0		 xor	 eax, eax
  00059	5e		 pop	 esi

; 57   : }

  0005a	59		 pop	 ecx
  0005b	c3		 ret	 0
?Over@CTimer@@UAEHXZ ENDP				; CTimer::Over
_TEXT	ENDS
PUBLIC	?GetLeftTime@CTimer@@QAENXZ			; CTimer::GetLeftTime
; Function compile flags: /Ogty
;	COMDAT ?GetLeftTime@CTimer@@QAENXZ
_TEXT	SEGMENT
tv133 = -4						; size = 4
?GetLeftTime@CTimer@@QAENXZ PROC NEAR			; CTimer::GetLeftTime, COMDAT
; _this$ = ecx

; 60   : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 61   : 	return ( GetTime() - m_curTime );

  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000a	85 c0		 test	 eax, eax
  0000c	89 44 24 04	 mov	 DWORD PTR tv133[esp+8], eax
  00010	db 44 24 04	 fild	 DWORD PTR tv133[esp+8]
  00014	7d 06		 jge	 SHORT $L187167
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187167:
  0001c	dc 66 08	 fsub	 QWORD PTR [esi+8]
  0001f	5e		 pop	 esi

; 62   : }

  00020	59		 pop	 ecx
  00021	c3		 ret	 0
?GetLeftTime@CTimer@@QAENXZ ENDP			; CTimer::GetLeftTime
_TEXT	ENDS
PUBLIC	?GetInterval@CTimer@@QAEMXZ			; CTimer::GetInterval
; Function compile flags: /Ogty
;	COMDAT ?GetInterval@CTimer@@QAEMXZ
_TEXT	SEGMENT
?GetInterval@CTimer@@QAEMXZ PROC NEAR			; CTimer::GetInterval, COMDAT
; _this$ = ecx

; 66   : 	return m_fInterval;

  00000	d9 41 18	 fld	 DWORD PTR [ecx+24]

; 67   : }

  00003	c3		 ret	 0
?GetInterval@CTimer@@QAEMXZ ENDP			; CTimer::GetInterval
_TEXT	ENDS
PUBLIC	??RCTimer@@QAEXXZ				; CTimer::operator()
; Function compile flags: /Ogty
;	COMDAT ??RCTimer@@QAEXXZ
_TEXT	SEGMENT
??RCTimer@@QAEXXZ PROC NEAR				; CTimer::operator(), COMDAT
; _this$ = ecx

; 70   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
$L186743:

; 71   : 	while( !Over() );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b ce		 mov	 ecx, esi
  00007	ff 50 08	 call	 DWORD PTR [eax+8]
  0000a	85 c0		 test	 eax, eax
  0000c	74 f5		 je	 SHORT $L186743
  0000e	5e		 pop	 esi

; 72   : }

  0000f	c3		 ret	 0
??RCTimer@@QAEXXZ ENDP					; CTimer::operator()
_TEXT	ENDS
PUBLIC	??RCTimer@@QAEXN@Z				; CTimer::operator()
; Function compile flags: /Ogty
;	COMDAT ??RCTimer@@QAEXN@Z
_TEXT	SEGMENT
tv150 = -4						; size = 4
$T187187 = 8						; size = 4
_fInterval$ = 8						; size = 8
??RCTimer@@QAEXN@Z PROC NEAR				; CTimer::operator(), COMDAT
; _this$ = ecx

; 75   : {

  00000	51		 push	 ecx

; 76   : 	Set( (float)fInterval );	while( !Over() );

  00001	dd 44 24 08	 fld	 QWORD PTR _fInterval$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	d9 54 24 0c	 fst	 DWORD PTR $T187187[esp+4]
  0000c	d9 5e 18	 fstp	 DWORD PTR [esi+24]
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00015	85 c0		 test	 eax, eax
  00017	89 44 24 04	 mov	 DWORD PTR tv150[esp+8], eax
  0001b	db 44 24 04	 fild	 DWORD PTR tv150[esp+8]
  0001f	7d 06		 jge	 SHORT $L187189
  00021	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187189:
  00027	dd 56 08	 fst	 QWORD PTR [esi+8]
  0002a	d9 44 24 0c	 fld	 DWORD PTR $T187187[esp+4]
  0002e	d8 c1		 fadd	 ST(0), ST(1)
  00030	dd 5e 10	 fstp	 QWORD PTR [esi+16]
  00033	dd d8		 fstp	 ST(0)
$L186751:
  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	8b ce		 mov	 ecx, esi
  00039	ff 50 08	 call	 DWORD PTR [eax+8]
  0003c	85 c0		 test	 eax, eax
  0003e	74 f5		 je	 SHORT $L186751
  00040	5e		 pop	 esi

; 77   : }

  00041	59		 pop	 ecx
  00042	c2 08 00	 ret	 8
??RCTimer@@QAEXN@Z ENDP					; CTimer::operator()
_TEXT	ENDS
PUBLIC	?GetSunPercent@CGameTimer@@QAEHXZ		; CGameTimer::GetSunPercent
; Function compile flags: /Ogty
;	COMDAT ?GetSunPercent@CGameTimer@@QAEHXZ
_TEXT	SEGMENT
?GetSunPercent@CGameTimer@@QAEHXZ PROC NEAR		; CGameTimer::GetSunPercent, COMDAT
; _this$ = ecx

; 89   : 	int nMin, nHour, nResult = 0;
; 90   : 	if( m_nHour >= HOUR_SUNRISE && m_nHour < HOUR_SUNSET )

  00000	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 06	 cmp	 edx, 6
  00008	56		 push	 esi
  00009	7c 28		 jl	 SHORT $L186764
  0000b	83 fa 12	 cmp	 edx, 18			; 00000012H
  0000e	7d 28		 jge	 SHORT $L187195

; 91   : 	{
; 92   : 		nHour = m_nHour - HOUR_SUNRISE;
; 93   : 		nMin = nHour * 60 + m_nMin;	// 60 * 2 : nMin = 100 : x
; 94   : 		nResult = nMin * 100 / ( 60 * SETRISE_VARIABLE );

  00010	8d 72 fa	 lea	 esi, DWORD PTR [edx-6]
  00013	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00016	6b f6 3c	 imul	 esi, 60			; 0000003cH
  00019	03 f2		 add	 esi, edx
  0001b	6b f6 64	 imul	 esi, 100		; 00000064H
  0001e	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00023	f7 ee		 imul	 esi
  00025	03 d6		 add	 edx, esi
  00027	c1 fa 06	 sar	 edx, 6
  0002a	8b c2		 mov	 eax, edx
  0002c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002f	03 c2		 add	 eax, edx

; 95   : 	}
; 96   : 	else

  00031	eb 2c		 jmp	 SHORT $L186766
$L186764:

; 97   : 	if( m_nHour >= HOUR_SUNSET )

  00033	83 fa 12	 cmp	 edx, 18			; 00000012H
  00036	7c 39		 jl	 SHORT $L186768
$L187195:

; 98   : 	{
; 99   : 		nHour = m_nHour - HOUR_SUNSET; 
; 100  : 		nMin =  nHour * 60 + m_nMin;	// 60 * 2 : nMin = 100 : x
; 101  : 		nResult = 100 - ( nMin * 100 / ( 60 * SETRISE_VARIABLE ) );

  00038	be 12 00 00 00	 mov	 esi, 18			; 00000012H
  0003d	2b f2		 sub	 esi, edx
  0003f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00042	6b f6 3c	 imul	 esi, 60			; 0000003cH
  00045	2b f2		 sub	 esi, edx
  00047	6b f6 64	 imul	 esi, 100		; 00000064H
  0004a	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0004f	f7 ee		 imul	 esi
  00051	03 d6		 add	 edx, esi
  00053	c1 fa 06	 sar	 edx, 6
  00056	8b c2		 mov	 eax, edx
  00058	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005b	8d 44 02 64	 lea	 eax, DWORD PTR [edx+eax+100]
$L186766:

; 102  : 	}
; 103  : 	if( nResult < 0 ) nResult = 0;

  0005f	85 c0		 test	 eax, eax
  00061	7d 04		 jge	 SHORT $L186767
  00063	33 c0		 xor	 eax, eax
  00065	5e		 pop	 esi

; 105  : //	if( nResult > 0 && nResult < 100 )
; 106  : //	;//TRACE( "sun %d \n", nResult );
; 107  : 	return nResult;
; 108  : }

  00066	c3		 ret	 0
$L186767:

; 104  : 	if( nResult > 100 ) nResult = 100;

  00067	83 f8 64	 cmp	 eax, 100		; 00000064H
  0006a	7e 05		 jle	 SHORT $L186768
  0006c	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
$L186768:
  00071	5e		 pop	 esi

; 105  : //	if( nResult > 0 && nResult < 100 )
; 106  : //	;//TRACE( "sun %d \n", nResult );
; 107  : 	return nResult;
; 108  : }

  00072	c3		 ret	 0
?GetSunPercent@CGameTimer@@QAEHXZ ENDP			; CGameTimer::GetSunPercent
_TEXT	ENDS
PUBLIC	?GetMoonPercent@CGameTimer@@QAEHXZ		; CGameTimer::GetMoonPercent
; Function compile flags: /Ogty
;	COMDAT ?GetMoonPercent@CGameTimer@@QAEHXZ
_TEXT	SEGMENT
?GetMoonPercent@CGameTimer@@QAEHXZ PROC NEAR		; CGameTimer::GetMoonPercent, COMDAT
; _this$ = ecx

; 114  : 	int nResult = 100 - GetSunPercent();

  00000	e8 00 00 00 00	 call	 ?GetSunPercent@CGameTimer@@QAEHXZ ; CGameTimer::GetSunPercent
  00005	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0000a	2b c8		 sub	 ecx, eax

; 115  : 	/*
; 116  : 	int nMin, nHour, nResult = 100;
; 117  : 	if( m_nHour >= HOUR_MOONSET && m_nHour < HOUR_MOONRISE - SETRISE_VARIABLE ) // / 18 < 20
; 118  : 	{
; 119  : 		nHour = m_nHour - HOUR_MOONSET;
; 120  : 		nMin = nHour * 60 + m_nMin; // 60 * 2 : nMin = 100 : x
; 121  : 		nResult = 100 - ( nMin * 100 / ( 60 * SETRISE_VARIABLE ) );
; 122  : 	}
; 123  : 	else
; 124  : 	if( m_nHour >= HOUR_MOONRISE  )
; 125  : 	{
; 126  : 		nHour = m_nHour - HOUR_MOONRISE; 
; 127  : 		nMin = nHour * 60 + m_nMin; // 60 * 2 : nMin = 100 : x
; 128  : 		nResult = ( nMin * 100 / ( 60 * SETRISE_VARIABLE ) );
; 129  : 	}
; 130  : 	if( nResult < 0 ) nResult = 0;
; 131  : 	if( nResult > 100 ) nResult = 100;
; 132  : 	*/
; 133  : //	if( nResult > 0 && nResult < 100 )
; 134  : //	;//	TRACE( "Moon %d \n", nResult );
; 135  : 	return nResult;

  0000c	8b c1		 mov	 eax, ecx

; 136  : }

  0000e	c3		 ret	 0
?GetMoonPercent@CGameTimer@@QAEHXZ ENDP			; CGameTimer::GetMoonPercent
_TEXT	ENDS
PUBLIC	??1CGameTimer@@QAE@XZ				; CGameTimer::~CGameTimer
; Function compile flags: /Ogty
;	COMDAT ??1CGameTimer@@QAE@XZ
_TEXT	SEGMENT
??1CGameTimer@@QAE@XZ PROC NEAR				; CGameTimer::~CGameTimer, COMDAT
; _this$ = ecx

; 166  : }

  00000	c3		 ret	 0
??1CGameTimer@@QAE@XZ ENDP				; CGameTimer::~CGameTimer
_TEXT	ENDS
PUBLIC	?SetCurrentTime@CGameTimer@@QAEXN@Z		; CGameTimer::SetCurrentTime
; Function compile flags: /Ogty
;	COMDAT ?SetCurrentTime@CGameTimer@@QAEXN@Z
_TEXT	SEGMENT
tv131 = 8						; size = 4
_dCurrentime$ = 8					; size = 8
?SetCurrentTime@CGameTimer@@QAEXN@Z PROC NEAR		; CGameTimer::SetCurrentTime, COMDAT
; _this$ = ecx

; 169  : 	m_dCurrentTime = dCurrentime; 

  00000	dd 44 24 04	 fld	 QWORD PTR _dCurrentime$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	dd 1e		 fstp	 QWORD PTR [esi]

; 170  :     m_dBeginTime = (double)timeGetTime();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000f	85 c0		 test	 eax, eax
  00011	89 44 24 08	 mov	 DWORD PTR tv131[esp], eax
  00015	db 44 24 08	 fild	 DWORD PTR tv131[esp]
  00019	7d 06		 jge	 SHORT $L187202
  0001b	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187202:
  00021	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  00024	5e		 pop	 esi

; 171  : }

  00025	c2 08 00	 ret	 8
?SetCurrentTime@CGameTimer@@QAEXN@Z ENDP		; CGameTimer::SetCurrentTime
_TEXT	ENDS
PUBLIC	?GetTickCount@CGameTimer@@QAENXZ		; CGameTimer::GetTickCount
; Function compile flags: /Ogty
;	COMDAT ?GetTickCount@CGameTimer@@QAENXZ
_TEXT	SEGMENT
tv135 = -4						; size = 4
?GetTickCount@CGameTimer@@QAENXZ PROC NEAR		; CGameTimer::GetTickCount, COMDAT
; _this$ = ecx

; 173  : { 

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 174  : 	double dTime = (double)timeGetTime();

  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000a	85 c0		 test	 eax, eax
  0000c	89 44 24 04	 mov	 DWORD PTR tv135[esp+8], eax
  00010	db 44 24 04	 fild	 DWORD PTR tv135[esp+8]
  00014	7d 06		 jge	 SHORT $L187205
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187205:

; 175  : 	return dTime - m_dBeginTime + m_dCurrentTime;

  0001c	dc 66 08	 fsub	 QWORD PTR [esi+8]
  0001f	dc 06		 fadd	 QWORD PTR [esi]
  00021	5e		 pop	 esi

; 176  : }

  00022	59		 pop	 ecx
  00023	c3		 ret	 0
?GetTickCount@CGameTimer@@QAENXZ ENDP			; CGameTimer::GetTickCount
_TEXT	ENDS
PUBLIC	?SetCurrentTime@CGameTimer@@QAEXHH@Z		; CGameTimer::SetCurrentTime
; Function compile flags: /Ogty
;	COMDAT ?SetCurrentTime@CGameTimer@@QAEXHH@Z
_TEXT	SEGMENT
tv128 = 8						; size = 4
tv71 = 8						; size = 4
_nDay$ = 8						; size = 4
_nHour$ = 12						; size = 4
?SetCurrentTime@CGameTimer@@QAEXHH@Z PROC NEAR		; CGameTimer::SetCurrentTime, COMDAT
; _this$ = ecx

; 179  : 	int nSec = ( ( nDay * 24 ) + nHour ) * 60 * 60;
; 180  : 	SetCurrentTime( nSec * TIMESPEED );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nDay$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nHour$[esp]
  0000b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000e	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00011	69 d2 a0 8c 00
	00		 imul	 edx, 36000		; 00008ca0H
  00017	89 54 24 08	 mov	 DWORD PTR tv128[esp], edx
  0001b	db 44 24 08	 fild	 DWORD PTR tv128[esp]
  0001f	dd 1e		 fstp	 QWORD PTR [esi]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00027	85 c0		 test	 eax, eax
  00029	89 44 24 08	 mov	 DWORD PTR tv71[esp], eax
  0002d	db 44 24 08	 fild	 DWORD PTR tv71[esp]
  00031	7d 06		 jge	 SHORT $L187211
  00033	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187211:
  00039	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  0003c	5e		 pop	 esi

; 181  : }

  0003d	c2 08 00	 ret	 8
?SetCurrentTime@CGameTimer@@QAEXHH@Z ENDP		; CGameTimer::SetCurrentTime
_TEXT	ENDS
PUBLIC	?Compute@CGameTimer@@QAEXXZ			; CGameTimer::Compute
EXTRN	__ftol2:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Compute@CGameTimer@@QAEXXZ
_TEXT	SEGMENT
tv206 = -4						; size = 4
?Compute@CGameTimer@@QAEXXZ PROC NEAR			; CGameTimer::Compute, COMDAT
; _this$ = ecx

; 183  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 184  : 	if( m_bFixed )

  00004	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00007	85 c0		 test	 eax, eax
  00009	75 5e		 jne	 SHORT $L186802

; 185  : 		return;
; 186  : 	long lCurTime = (long)( GetCurrentTime() );

  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00011	85 c0		 test	 eax, eax
  00013	89 44 24 04	 mov	 DWORD PTR tv206[esp+8], eax
  00017	db 44 24 04	 fild	 DWORD PTR tv206[esp+8]
  0001b	7d 06		 jge	 SHORT $L187219
  0001d	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187219:
  00023	dc 66 08	 fsub	 QWORD PTR [esi+8]
  00026	dc 06		 fadd	 QWORD PTR [esi]

; 187  : 	int nSec, nMin, nHour, nDay;
; 188  : 	lCurTime /= TIMESPEED;

  00028	e8 00 00 00 00	 call	 __ftol2
  0002d	8b c8		 mov	 ecx, eax
  0002f	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00034	f7 e9		 imul	 ecx
  00036	c1 fa 02	 sar	 edx, 2
  00039	8b c2		 mov	 eax, edx
  0003b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003e	03 c2		 add	 eax, edx

; 189  : 
; 190  : 	nSec    = lCurTime / 60;

  00040	99		 cdq
  00041	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00046	f7 f9		 idiv	 ecx

; 191  : 	m_nSec  = lCurTime % 60;

  00048	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 192  : 	nMin    = nSec  / 60; // 60초로 나눈다.

  0004b	99		 cdq
  0004c	f7 f9		 idiv	 ecx

; 193  : 	m_nMin  = nSec  % 60; // 60초로 나눈다.
; 194  : 	nHour   = nMin  / 24; // 24시간으로 나눈다.
; 195  : 	m_nHour = nMin  % 24; // 24시간으로 나눈다.

  0004e	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00053	89 56 18	 mov	 DWORD PTR [esi+24], edx
  00056	99		 cdq
  00057	f7 f9		 idiv	 ecx

; 196  : 	nDay    = nHour / 30; // 30일로 나눈다.
; 197  : 	m_nDay  = nHour % 30; // 30일로나눈다.

  00059	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH

; 198  : 	
; 199  : 	m_nHour++; // 1 based

  0005e	42		 inc	 edx
  0005f	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  00062	99		 cdq
  00063	f7 f9		 idiv	 ecx

; 200  : 	m_nDay++; // 1 based

  00065	42		 inc	 edx
  00066	89 56 20	 mov	 DWORD PTR [esi+32], edx
$L186802:
  00069	5e		 pop	 esi

; 201  : 	//m_nHour = 19;
; 202  : 	
; 203  : #ifdef __XUZHU
; 204  : //#ifdef _DEBUG
; 205  : //	m_nHour = 7;		// 언제나 낮이 되도록
; 206  : //#endif
; 207  : #endif	
; 208  : }

  0006a	59		 pop	 ecx
  0006b	c3		 ret	 0
?Compute@CGameTimer@@QAEXXZ ENDP			; CGameTimer::Compute
_TEXT	ENDS
PUBLIC	?SetTime@CGameTimer@@QAEXHHHH@Z			; CGameTimer::SetTime
; Function compile flags: /Ogty
;	COMDAT ?SetTime@CGameTimer@@QAEXHHHH@Z
_TEXT	SEGMENT
_nDay$ = 8						; size = 4
_nHour$ = 12						; size = 4
_nMin$ = 16						; size = 4
_nSec$ = 20						; size = 4
?SetTime@CGameTimer@@QAEXHHHH@Z PROC NEAR		; CGameTimer::SetTime, COMDAT
; _this$ = ecx

; 211  : 	m_nDay = nDay;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nDay$[esp-4]

; 212  : 	m_nHour = nHour;

  00004	8b 54 24 08	 mov	 edx, DWORD PTR _nHour$[esp-4]
  00008	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 213  : 	m_nMin = nMin;

  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _nMin$[esp-4]
  0000f	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 214  : 	m_nSec = nSec;

  00012	8b 54 24 10	 mov	 edx, DWORD PTR _nSec$[esp-4]
  00016	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00019	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 215  : }

  0001c	c2 10 00	 ret	 16			; 00000010H
?SetTime@CGameTimer@@QAEXHHHH@Z ENDP			; CGameTimer::SetTime
_TEXT	ENDS
PUBLIC	?Set@CSkipTimer@@QAEXM@Z			; CSkipTimer::Set
; Function compile flags: /Ogty
;	COMDAT ?Set@CSkipTimer@@QAEXM@Z
_TEXT	SEGMENT
tv136 = -4						; size = 4
_fInterval$ = 8						; size = 4
?Set@CSkipTimer@@QAEXM@Z PROC NEAR			; CSkipTimer::Set, COMDAT
; _this$ = ecx

; 218  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 219  : 	m_curTime	= GetTime();

  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000a	85 c0		 test	 eax, eax
  0000c	89 44 24 04	 mov	 DWORD PTR tv136[esp+8], eax
  00010	db 44 24 04	 fild	 DWORD PTR tv136[esp+8]
  00014	7d 06		 jge	 SHORT $L187227
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187227:

; 220  : 	m_fInterval		= fInterval;

  0001c	8b 44 24 0c	 mov	 eax, DWORD PTR _fInterval$[esp+4]
  00020	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  00023	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 221  : 	m_bMaxSkip	= 0;

  00026	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  0002d	5e		 pop	 esi

; 222  : }

  0002e	59		 pop	 ecx
  0002f	c2 04 00	 ret	 4
?Set@CSkipTimer@@QAEXM@Z ENDP				; CSkipTimer::Set
_TEXT	ENDS
PUBLIC	?Over@CSkipTimer@@UAEHXZ			; CSkipTimer::Over
PUBLIC	__real@00000000
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?Over@CSkipTimer@@UAEHXZ
_TEXT	SEGMENT
tv168 = -4						; size = 4
?Over@CSkipTimer@@UAEHXZ PROC NEAR			; CSkipTimer::Over, COMDAT
; _this$ = ecx

; 224  : {

  00000	51		 push	 ecx

; 225  : 	if( m_fInterval == 0.0f )

  00001	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	d9 46 18	 fld	 DWORD PTR [esi+24]
  0000d	da e9		 fucompp
  0000f	df e0		 fnstsw	 ax
  00011	f6 c4 44	 test	 ah, 68			; 00000044H

; 226  : 		return FALSE;

  00014	7b 4b		 jnp	 SHORT $L186829

; 227  : 
; 228  : 	DWORD dwCurr = (DWORD)GetTime();

  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 229  : 
; 230  : 	if( dwCurr > ( m_curTime + m_fInterval ) )	

  0001c	d9 46 18	 fld	 DWORD PTR [esi+24]
  0001f	dc 46 08	 fadd	 QWORD PTR [esi+8]
  00022	8b c8		 mov	 ecx, eax
  00024	85 c9		 test	 ecx, ecx
  00026	89 4c 24 04	 mov	 DWORD PTR tv168[esp+8], ecx
  0002a	db 44 24 04	 fild	 DWORD PTR tv168[esp+8]
  0002e	7d 06		 jge	 SHORT $L187237
  00030	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187237:
  00036	d8 d9		 fcomp	 ST(1)
  00038	df e0		 fnstsw	 ax
  0003a	f6 c4 41	 test	 ah, 65			; 00000041H

; 231  : 	{
; 232  : 		m_curTime	+= m_fInterval;
; 233  : 		return TRUE;

  0003d	74 15		 je	 SHORT $L187238

; 234  : 	}
; 235  : 
; 236  : 	if( dwCurr < 536870911 && ( m_curTime + m_fInterval ) > 3758096381 )

  0003f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00045	73 18		 jae	 SHORT $L187236
  00047	dc 15 00 00 00
	00		 fcom	 QWORD PTR __real@41ebffffffa00000
  0004d	df e0		 fnstsw	 ax
  0004f	f6 c4 41	 test	 ah, 65			; 00000041H
  00052	75 0b		 jne	 SHORT $L187236
$L187238:

; 237  : 	{
; 238  : 		m_curTime += m_fInterval;

  00054	dd 5e 08	 fstp	 QWORD PTR [esi+8]

; 239  : 		return TRUE;

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	5e		 pop	 esi

; 243  : }

  0005d	59		 pop	 ecx
  0005e	c3		 ret	 0
$L187236:

; 234  : 	}
; 235  : 
; 236  : 	if( dwCurr < 536870911 && ( m_curTime + m_fInterval ) > 3758096381 )

  0005f	dd d8		 fstp	 ST(0)
$L186829:

; 240  : 	}
; 241  : 
; 242  : 	return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	5e		 pop	 esi

; 243  : }

  00064	59		 pop	 ecx
  00065	c3		 ret	 0
?Over@CSkipTimer@@UAEHXZ ENDP				; CSkipTimer::Over
_TEXT	ENDS
PUBLIC	?IsNeedSkip@CSkipTimer@@QAEHXZ			; CSkipTimer::IsNeedSkip
; Function compile flags: /Ogty
;	COMDAT ?IsNeedSkip@CSkipTimer@@QAEHXZ
_TEXT	SEGMENT
tv138 = -4						; size = 4
?IsNeedSkip@CSkipTimer@@QAEHXZ PROC NEAR		; CSkipTimer::IsNeedSkip, COMDAT
; _this$ = ecx

; 246  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 247  : 	if (GetTime() > m_curTime+m_fInterval)

  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000a	85 c0		 test	 eax, eax
  0000c	89 44 24 04	 mov	 DWORD PTR tv138[esp+8], eax
  00010	db 44 24 04	 fild	 DWORD PTR tv138[esp+8]
  00014	7d 06		 jge	 SHORT $L187245
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187245:
  0001c	d9 46 18	 fld	 DWORD PTR [esi+24]
  0001f	dc 46 08	 fadd	 QWORD PTR [esi+8]
  00022	5e		 pop	 esi
  00023	d9 c9		 fxch	 ST(1)
  00025	de d9		 fcompp
  00027	df e0		 fnstsw	 ax
  00029	f6 c4 41	 test	 ah, 65			; 00000041H
  0002c	75 07		 jne	 SHORT $L186834

; 248  : 		return TRUE;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 250  : }

  00033	59		 pop	 ecx
  00034	c3		 ret	 0
$L186834:

; 249  : 	return FALSE;

  00035	33 c0		 xor	 eax, eax

; 250  : }

  00037	59		 pop	 ecx
  00038	c3		 ret	 0
?IsNeedSkip@CSkipTimer@@QAEHXZ ENDP			; CSkipTimer::IsNeedSkip
_TEXT	ENDS
PUBLIC	?Skip@CSkipTimer@@QAEXXZ			; CSkipTimer::Skip
; Function compile flags: /Ogty
;	COMDAT ?Skip@CSkipTimer@@QAEXXZ
_TEXT	SEGMENT
?Skip@CSkipTimer@@QAEXXZ PROC NEAR			; CSkipTimer::Skip, COMDAT
; _this$ = ecx

; 254  : 	m_curTime	+= m_fInterval;

  00000	d9 41 18	 fld	 DWORD PTR [ecx+24]
  00003	dc 41 08	 fadd	 QWORD PTR [ecx+8]
  00006	dd 59 08	 fstp	 QWORD PTR [ecx+8]

; 255  : }

  00009	c3		 ret	 0
?Skip@CSkipTimer@@QAEXXZ ENDP				; CSkipTimer::Skip
_TEXT	ENDS
PUBLIC	?IsMaxSkip@CSkipTimer@@QAEHXZ			; CSkipTimer::IsMaxSkip
PUBLIC	__real@3fc5555555555555
;	COMDAT __real@3fc5555555555555
CONST	SEGMENT
__real@3fc5555555555555 DQ 03fc5555555555555r	; 0.166667
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?IsMaxSkip@CSkipTimer@@QAEHXZ
_TEXT	SEGMENT
tv180 = -4						; size = 4
?IsMaxSkip@CSkipTimer@@QAEHXZ PROC NEAR			; CSkipTimer::IsMaxSkip, COMDAT
; _this$ = ecx

; 258  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 259  : 	double time = GetTime();

  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000a	85 c0		 test	 eax, eax
  0000c	89 44 24 04	 mov	 DWORD PTR tv180[esp+8], eax
  00010	db 44 24 04	 fild	 DWORD PTR tv180[esp+8]
  00014	7d 06		 jge	 SHORT $L187255
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187255:

; 260  : 
; 261  : 	time	= ( time - m_curTime ) / m_fInterval;
; 262  : 	
; 263  : 	if( m_bMaxSkip == 0 )

  0001c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001f	85 c0		 test	 eax, eax
  00021	75 21		 jne	 SHORT $L186844
  00023	dc 66 08	 fsub	 QWORD PTR [esi+8]

; 264  : 	{
; 265  : 		m_bMaxSkip = (int)( time / SKIPPING_PARAM );

  00026	d8 76 18	 fdiv	 DWORD PTR [esi+24]
  00029	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc5555555555555
  0002f	e8 00 00 00 00	 call	 __ftol2

; 266  : 	}
; 267  : 	else
; 268  : 	{
; 269  : 		m_bMaxSkip --;

  00034	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 270  : 	}
; 271  : 
; 272  : 	if( m_bMaxSkip == 0 )

  00037	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0003a	33 c0		 xor	 eax, eax
  0003c	85 c9		 test	 ecx, ecx
  0003e	0f 94 c0	 sete	 al
  00041	5e		 pop	 esi

; 273  : 		return TRUE;
; 274  : 
; 275  : 	return FALSE;
; 276  : }

  00042	59		 pop	 ecx
  00043	c3		 ret	 0
$L186844:

; 266  : 	}
; 267  : 	else
; 268  : 	{
; 269  : 		m_bMaxSkip --;

  00044	48		 dec	 eax
  00045	dd d8		 fstp	 ST(0)
  00047	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 270  : 	}
; 271  : 
; 272  : 	if( m_bMaxSkip == 0 )

  0004a	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c9		 test	 ecx, ecx
  00051	0f 94 c0	 sete	 al
  00054	5e		 pop	 esi

; 273  : 		return TRUE;
; 274  : 
; 275  : 	return FALSE;
; 276  : }

  00055	59		 pop	 ecx
  00056	c3		 ret	 0
?IsMaxSkip@CSkipTimer@@QAEHXZ ENDP			; CSkipTimer::IsMaxSkip
_TEXT	ENDS
PUBLIC	?IsNight@CDate@@QAEHXZ				; CDate::IsNight
; Function compile flags: /Ogty
;	COMDAT ?IsNight@CDate@@QAEHXZ
_TEXT	SEGMENT
?IsNight@CDate@@QAEHXZ PROC NEAR			; CDate::IsNight, COMDAT
; _this$ = ecx

; 316  : 	if(m_nHour < 6 || m_nHour >= 19)

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	83 f8 06	 cmp	 eax, 6
  00006	7c 08		 jl	 SHORT $L186869
  00008	83 f8 13	 cmp	 eax, 19			; 00000013H
  0000b	7d 03		 jge	 SHORT $L186869

; 318  : 	return FALSE;

  0000d	33 c0		 xor	 eax, eax

; 319  : }

  0000f	c3		 ret	 0
$L186869:

; 317  : 		return TRUE;

  00010	b8 01 00 00 00	 mov	 eax, 1

; 319  : }

  00015	c3		 ret	 0
?IsNight@CDate@@QAEHXZ ENDP				; CDate::IsNight
_TEXT	ENDS
PUBLIC	?GetDay@CDate@@QAEHXZ				; CDate::GetDay
; Function compile flags: /Ogty
;	COMDAT ?GetDay@CDate@@QAEHXZ
_TEXT	SEGMENT
?GetDay@CDate@@QAEHXZ PROC NEAR				; CDate::GetDay, COMDAT
; _this$ = ecx

; 324  : 	int		nDay = (m_nYear * 365) + (m_nMonth * 30) + m_nDay;

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00006	69 c0 6d 01 00
	00		 imul	 eax, 365		; 0000016dH
  0000c	6b d2 1e	 imul	 edx, 30			; 0000001eH

; 325  : 
; 326  : 	return	nDay;

  0000f	03 c2		 add	 eax, edx
  00011	03 41 34	 add	 eax, DWORD PTR [ecx+52]

; 327  : }

  00014	c3		 ret	 0
?GetDay@CDate@@QAEHXZ ENDP				; CDate::GetDay
_TEXT	ENDS
PUBLIC	?ComputeShade@CDate@@QAEHH@Z			; CDate::ComputeShade
; Function compile flags: /Ogty
;	COMDAT ?ComputeShade@CDate@@QAEHH@Z
_TEXT	SEGMENT
_nMax$ = 8						; size = 4
?ComputeShade@CDate@@QAEHH@Z PROC NEAR			; CDate::ComputeShade, COMDAT
; _this$ = ecx

; 329  : {

  00000	56		 push	 esi

; 330  : //	int nVal;
; 331  : 	int nResult = 0;
; 332  : 	if(m_nHour >= 21 || m_nHour <= 4)

  00001	8b 71 38	 mov	 esi, DWORD PTR [ecx+56]
  00004	33 c0		 xor	 eax, eax
  00006	83 fe 15	 cmp	 esi, 21			; 00000015H
  00009	7d 46		 jge	 SHORT $L186881
  0000b	83 fe 04	 cmp	 esi, 4
  0000e	7e 41		 jle	 SHORT $L186881

; 334  : 	if(m_nHour >= 19) // 19, 20

  00010	83 fe 13	 cmp	 esi, 19			; 00000013H
  00013	7c 14		 jl	 SHORT $L186882

; 335  : 	{
; 336  : 		nResult = (((m_nHour - 19) * 60) + m_nMinute) / 16;

  00015	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00018	8d 46 ed	 lea	 eax, DWORD PTR [esi-19]
  0001b	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0001e	03 c2		 add	 eax, edx
  00020	99		 cdq
  00021	83 e2 0f	 and	 edx, 15			; 0000000fH
  00024	03 c2		 add	 eax, edx
  00026	c1 f8 04	 sar	 eax, 4
$L186882:

; 337  : 	}
; 338  : 	if(m_nHour <= 6) // 5, 6

  00029	83 fe 06	 cmp	 esi, 6
  0002c	7f 18		 jg	 SHORT $L186883

; 339  : 	{
; 340  : 		nResult = (((6 - m_nHour) * 60) + (60-m_nMinute)) / 16;

  0002e	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00031	b8 07 00 00 00	 mov	 eax, 7
  00036	2b c6		 sub	 eax, esi
  00038	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0003b	2b c2		 sub	 eax, edx
  0003d	99		 cdq
  0003e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00041	03 c2		 add	 eax, edx
  00043	c1 f8 04	 sar	 eax, 4
$L186883:

; 341  : 	}
; 342  : 	if(nResult == nMax) 

  00046	3b 44 24 08	 cmp	 eax, DWORD PTR _nMax$[esp]
  0004a	75 0a		 jne	 SHORT $L186878

; 333  : 		return nMax-1;

  0004c	48		 dec	 eax
  0004d	5e		 pop	 esi

; 343  : 		nResult--;
; 344  : 	return nResult;
; 345  : }

  0004e	c2 04 00	 ret	 4
$L186881:

; 333  : 		return nMax-1;

  00051	8b 44 24 08	 mov	 eax, DWORD PTR _nMax$[esp]
  00055	48		 dec	 eax
$L186878:
  00056	5e		 pop	 esi

; 343  : 		nResult--;
; 344  : 	return nResult;
; 345  : }

  00057	c2 04 00	 ret	 4
?ComputeShade@CDate@@QAEHH@Z ENDP			; CDate::ComputeShade
_TEXT	ENDS
PUBLIC	?GetTimeColor@CDate@@QAEXPAUtagTIMECOLOR@@@Z	; CDate::GetTimeColor
; Function compile flags: /Ogty
;	COMDAT ?GetTimeColor@CDate@@QAEXPAUtagTIMECOLOR@@@Z
_TEXT	SEGMENT
_pTimeColor$ = 8					; size = 4
?GetTimeColor@CDate@@QAEXPAUtagTIMECOLOR@@@Z PROC NEAR	; CDate::GetTimeColor, COMDAT
; _this$ = ecx

; 348  : 	int nTime;
; 349  : 	// 밤이 되고 있음 
; 350  : 	if(m_nHour >= 18)

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	83 f8 12	 cmp	 eax, 18			; 00000012H
  00006	56		 push	 esi
  00007	7c 42		 jl	 SHORT $L186890

; 351  : 	{
; 352  : 		nTime = (m_nHour - 18) * 60 + m_nMinute; // 분단위를 구함 (맥시섬 360 + 59 = 419)
; 353  : 		// 419 : 0x0f = nTime = x
; 354  : 		pTimeColor->m_nDarkAlpha = nTime * 0x0f / 359;

  00009	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0000c	8d 70 ee	 lea	 esi, DWORD PTR [eax-18]
  0000f	6b f6 3c	 imul	 esi, 60			; 0000003cH
  00012	03 f2		 add	 esi, edx
  00014	6b f6 0f	 imul	 esi, 15			; 0000000fH
  00017	8b 4c 24 08	 mov	 ecx, DWORD PTR _pTimeColor$[esp]
  0001b	b8 35 31 8d b6	 mov	 eax, -1232260811	; b68d3135H
  00020	f7 ee		 imul	 esi
  00022	03 d6		 add	 edx, esi
  00024	c1 fa 08	 sar	 edx, 8
  00027	8b c2		 mov	 eax, edx
  00029	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002c	03 c2		 add	 eax, edx

; 355  : 		if(pTimeColor->m_nDarkAlpha > 0x0f) 

  0002e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00031	89 01		 mov	 DWORD PTR [ecx], eax
  00033	7e 06		 jle	 SHORT $L186891

; 356  : 			pTimeColor->m_nDarkAlpha = 0x0f;

  00035	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$L186891:

; 357  : 		pTimeColor->m_nR = -3;

  0003b	b0 fd		 mov	 al, -3			; fffffffdH
  0003d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 358  : 		pTimeColor->m_nG = -3;

  00040	88 41 05	 mov	 BYTE PTR [ecx+5], al

; 359  : 		pTimeColor->m_nB = 0;

  00043	c6 41 06 00	 mov	 BYTE PTR [ecx+6], 0
  00047	5e		 pop	 esi

; 380  : 	}
; 381  : }

  00048	c2 04 00	 ret	 4
$L186890:

; 360  : 	}
; 361  : 	else
; 362  : 	// 아침이 되고 있음 
; 363  : 	if(m_nHour <= 5)

  0004b	83 f8 05	 cmp	 eax, 5
  0004e	7f 45		 jg	 SHORT $L186893

; 364  : 	{
; 365  : 		nTime = (8 - m_nHour) * 60 - m_nMinute; // 420 - 1 = 419) (밤이 끝나는 시각과 일치)
; 366  : 		// 419 : 0x0f = nTime = x
; 367  : 		pTimeColor->m_nDarkAlpha = nTime * 0x0f / 359;

  00050	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00053	be 08 00 00 00	 mov	 esi, 8
  00058	2b f0		 sub	 esi, eax
  0005a	6b f6 3c	 imul	 esi, 60			; 0000003cH
  0005d	2b f2		 sub	 esi, edx
  0005f	6b f6 0f	 imul	 esi, 15			; 0000000fH
  00062	8b 4c 24 08	 mov	 ecx, DWORD PTR _pTimeColor$[esp]
  00066	b8 35 31 8d b6	 mov	 eax, -1232260811	; b68d3135H
  0006b	f7 ee		 imul	 esi
  0006d	03 d6		 add	 edx, esi
  0006f	c1 fa 08	 sar	 edx, 8
  00072	8b c2		 mov	 eax, edx
  00074	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00077	03 c2		 add	 eax, edx

; 368  : 		if(pTimeColor->m_nDarkAlpha > 0x0f) 

  00079	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0007c	89 01		 mov	 DWORD PTR [ecx], eax
  0007e	7e 06		 jle	 SHORT $L186894

; 369  : 			pTimeColor->m_nDarkAlpha = 0x0f;

  00080	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$L186894:

; 370  : 		pTimeColor->m_nR = 0;

  00086	33 d2		 xor	 edx, edx
  00088	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 371  : 		pTimeColor->m_nG = 0;

  0008b	88 51 05	 mov	 BYTE PTR [ecx+5], dl

; 372  : 		pTimeColor->m_nB = 0;

  0008e	88 51 06	 mov	 BYTE PTR [ecx+6], dl
  00091	5e		 pop	 esi

; 380  : 	}
; 381  : }

  00092	c2 04 00	 ret	 4
$L186893:

; 373  : 	}
; 374  : 	else
; 375  : 	{
; 376  : 		pTimeColor->m_nDarkAlpha = 0;

  00095	8b 44 24 08	 mov	 eax, DWORD PTR _pTimeColor$[esp]
  00099	33 d2		 xor	 edx, edx
  0009b	89 10		 mov	 DWORD PTR [eax], edx

; 377  : 		pTimeColor->m_nR = 0;

  0009d	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 378  : 		pTimeColor->m_nG = 0;

  000a0	88 50 05	 mov	 BYTE PTR [eax+5], dl

; 379  : 		pTimeColor->m_nB = 0;

  000a3	88 50 06	 mov	 BYTE PTR [eax+6], dl
  000a6	5e		 pop	 esi

; 380  : 	}
; 381  : }

  000a7	c2 04 00	 ret	 4
?GetTimeColor@CDate@@QAEXPAUtagTIMECOLOR@@@Z ENDP	; CDate::GetTimeColor
_TEXT	ENDS
PUBLIC	?Process@CDate@@QAEXXZ				; CDate::Process
; Function compile flags: /Ogty
;	COMDAT ?Process@CDate@@QAEXXZ
_TEXT	SEGMENT
?Process@CDate@@QAEXXZ PROC NEAR			; CDate::Process, COMDAT
; _this$ = ecx

; 383  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 384  : 	while(m_delay.Over())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 50 08	 call	 DWORD PTR [eax+8]
  00008	85 c0		 test	 eax, eax
  0000a	74 6f		 je	 SHORT $L186901
  0000c	53		 push	 ebx
  0000d	57		 push	 edi
  0000e	bb 3c 00 00 00	 mov	 ebx, 60			; 0000003cH
  00013	bf 01 00 00 00	 mov	 edi, 1
$L186900:

; 385  : 	{
; 386  : 		//m_delay.Set(m_nDelay);//m_nDelay);
; 387  : 		m_nSecond++;

  00018	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0001b	41		 inc	 ecx

; 388  : 		if(m_nSecond >= 60)

  0001c	8b c1		 mov	 eax, ecx
  0001e	3b c3		 cmp	 eax, ebx
  00020	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00023	7c 0a		 jl	 SHORT $L186902

; 389  : 		{
; 390  : 			m_nSecond = 1;
; 391  : 			m_nMinute++;

  00025	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00028	40		 inc	 eax
  00029	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  0002c	89 46 3c	 mov	 DWORD PTR [esi+60], eax
$L186902:

; 392  : 		}
; 393  : 		if(m_nMinute >= 60)

  0002f	39 5e 3c	 cmp	 DWORD PTR [esi+60], ebx
  00032	7c 0a		 jl	 SHORT $L186903

; 394  : 		{
; 395  : 			m_nMinute = 1;
; 396  : 			m_nHour++;

  00034	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00037	40		 inc	 eax
  00038	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  0003b	89 46 38	 mov	 DWORD PTR [esi+56], eax
$L186903:

; 397  : 		}
; 398  : 		if(m_nHour > 24)

  0003e	83 7e 38 18	 cmp	 DWORD PTR [esi+56], 24	; 00000018H
  00042	7e 0a		 jle	 SHORT $L186904

; 399  : 		{
; 400  : 			m_nHour = 1;
; 401  : 			m_nDay++;

  00044	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00047	40		 inc	 eax
  00048	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  0004b	89 46 34	 mov	 DWORD PTR [esi+52], eax
$L186904:

; 402  : 		}
; 403  : 		if(m_nDay > 30)

  0004e	83 7e 34 1e	 cmp	 DWORD PTR [esi+52], 30	; 0000001eH
  00052	7e 0a		 jle	 SHORT $L186905

; 404  : 		{
; 405  : 			m_nDay = 1;
; 406  : 			m_nMonth++;

  00054	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00057	40		 inc	 eax
  00058	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0005b	89 46 30	 mov	 DWORD PTR [esi+48], eax
$L186905:

; 407  : 		}
; 408  : 		if(m_nMonth > 12)

  0005e	83 7e 30 0c	 cmp	 DWORD PTR [esi+48], 12	; 0000000cH
  00062	7e 0a		 jle	 SHORT $L186906

; 409  : 		{ 
; 410  : 			m_nMonth = 1;
; 411  : 			m_nYear++;

  00064	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00067	40		 inc	 eax
  00068	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  0006b	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$L186906:
  0006e	8b 16		 mov	 edx, DWORD PTR [esi]
  00070	8b ce		 mov	 ecx, esi
  00072	ff 52 08	 call	 DWORD PTR [edx+8]
  00075	85 c0		 test	 eax, eax
  00077	75 9f		 jne	 SHORT $L186900
  00079	5f		 pop	 edi
  0007a	5b		 pop	 ebx
$L186901:
  0007b	5e		 pop	 esi

; 412  : 		}
; 413  : 	}
; 414  : }

  0007c	c3		 ret	 0
?Process@CDate@@QAEXXZ ENDP				; CDate::Process
_TEXT	ENDS
PUBLIC	?InitFST@@YAXXZ					; InitFST
; Function compile flags: /Ogty
;	COMDAT ?InitFST@@YAXXZ
_TEXT	SEGMENT
?InitFST@@YAXXZ PROC NEAR				; InitFST, COMDAT

; 471  : 	m_lTime = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_lTime@@3KA, 0 ; m_lTime

; 472  : 	m_dwOldTime = timeGetTime();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwOldTime@@3KA, eax ; m_dwOldTime

; 473  : 	s_bFrameSkip = TRUE;

  00015	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _s_bFrameSkip, 1

; 474  : }

  0001f	c3		 ret	 0
?InitFST@@YAXXZ ENDP					; InitFST
_TEXT	ENDS
PUBLIC	?SetFrameSkip@@YAXH@Z				; SetFrameSkip
; Function compile flags: /Ogty
;	COMDAT ?SetFrameSkip@@YAXH@Z
_TEXT	SEGMENT
_bFlag$ = 8						; size = 4
?SetFrameSkip@@YAXH@Z PROC NEAR				; SetFrameSkip, COMDAT

; 479  : 	s_bFrameSkip = bFlag;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bFlag$[esp-4]

; 480  : 	if( bFlag == TRUE )		InitFST();

  00004	83 f8 01	 cmp	 eax, 1
  00007	a3 00 00 00 00	 mov	 DWORD PTR _s_bFrameSkip, eax
  0000c	75 1f		 jne	 SHORT $L187274
  0000e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_lTime@@3KA, 0 ; m_lTime
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0001e	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwOldTime@@3KA, eax ; m_dwOldTime
  00023	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _s_bFrameSkip, 1
$L187274:

; 481  : }

  0002d	c3		 ret	 0
?SetFrameSkip@@YAXH@Z ENDP				; SetFrameSkip
_TEXT	ENDS
PUBLIC	?GetFrameSkip@@YAHXZ				; GetFrameSkip
; Function compile flags: /Ogty
;	COMDAT ?GetFrameSkip@@YAHXZ
_TEXT	SEGMENT
?GetFrameSkip@@YAHXZ PROC NEAR				; GetFrameSkip, COMDAT

; 486  : 	return s_bFrameSkip;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_bFrameSkip

; 487  : }

  00005	c3		 ret	 0
?GetFrameSkip@@YAHXZ ENDP				; GetFrameSkip
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?UpdateTime@@YAXXZ
_TEXT	SEGMENT
?UpdateTime@@YAXXZ PROC NEAR				; UpdateTime, COMDAT

; 491  : 	DWORD	dwTime = timeGetTime();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 492  : 
; 493  : 	m_lTime += (dwTime - m_dwOldTime);	// 경과된 시간을 더함

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwOldTime@@3KA ; m_dwOldTime
  0000c	8b d0		 mov	 edx, eax
  0000e	2b d1		 sub	 edx, ecx
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_lTime@@3KA ; m_lTime
  00016	03 ca		 add	 ecx, edx

; 494  : 	if( m_lTime > 1000 )	m_lTime = 1000;

  00018	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  0001e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime

; 495  : 
; 496  : #ifdef __BS_EFFECT_LUA
; 497  : 	g_timeMTE += ( dwTime - m_dwOldTime );
; 498  : 	if( g_timeMTE > 20000 )	//20초마다 갱신
; 499  : 		g_timeMTE = 0;
; 500  : #endif //__BS_EFFECT_LUA
; 501  : 	m_dwOldTime = dwTime;

  00024	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwOldTime@@3KA, eax ; m_dwOldTime
  00029	76 0a		 jbe	 SHORT $L186924

; 494  : 	if( m_lTime > 1000 )	m_lTime = 1000;

  0002b	c7 05 00 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?m_lTime@@3KA, 1000 ; m_lTime, 000003e8H
$L186924:

; 502  : }

  00035	c3		 ret	 0
?UpdateTime@@YAXXZ ENDP					; UpdateTime
_TEXT	ENDS
PUBLIC	?IsDrawTiming@@YAHXZ				; IsDrawTiming
; Function compile flags: /Ogty
;	COMDAT ?IsDrawTiming@@YAHXZ
_TEXT	SEGMENT
?IsDrawTiming@@YAHXZ PROC NEAR				; IsDrawTiming, COMDAT

; 506  : 	if( s_bFrameSkip == FALSE )		return TRUE;		// 프레임 스킵이 꺼져있으면 무조건 드로우.

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_bFrameSkip
  00005	85 c0		 test	 eax, eax
  00007	74 48		 je	 SHORT $L187288

; 507  : 	UpdateTime();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwOldTime@@3KA ; m_dwOldTime
  00015	8b d0		 mov	 edx, eax
  00017	2b d1		 sub	 edx, ecx
  00019	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_lTime@@3KA ; m_lTime
  0001f	03 ca		 add	 ecx, edx
  00021	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00027	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime
  0002d	76 0b		 jbe	 SHORT $L187286
  0002f	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00034	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime
$L187286:

; 508  : 	if( m_lTime >= 1000 )	

  0003a	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00040	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwOldTime@@3KA, eax ; m_dwOldTime
  00045	72 10		 jb	 SHORT $L186929

; 509  : 	{
; 510  : 		m_lTime = 0;

  00047	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_lTime@@3KA, 0 ; m_lTime
$L187288:

; 511  : 		return TRUE;

  00051	b8 01 00 00 00	 mov	 eax, 1

; 514  : }

  00056	c3		 ret	 0
$L186929:

; 512  : 	}
; 513  : 	return (m_lTime < (1000 / FRAME_PER_SEC)) ? TRUE : FALSE;

  00057	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0005a	1b c0		 sbb	 eax, eax
  0005c	f7 d8		 neg	 eax

; 514  : }

  0005e	c3		 ret	 0
?IsDrawTiming@@YAHXZ ENDP				; IsDrawTiming
_TEXT	ENDS
PUBLIC	?SetFST@@YAXXZ					; SetFST
; Function compile flags: /Ogty
;	COMDAT ?SetFST@@YAXXZ
_TEXT	SEGMENT
?SetFST@@YAXXZ PROC NEAR				; SetFST, COMDAT

; 518  : 	if( s_bFrameSkip == FALSE )		return;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_bFrameSkip
  00005	85 c0		 test	 eax, eax
  00007	74 7f		 je	 SHORT $L186932
  00009	56		 push	 esi

; 519  : 	UpdateTime();

  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__timeGetTime@0
  00010	ff d6		 call	 esi
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwOldTime@@3KA ; m_dwOldTime
  00018	8b d0		 mov	 edx, eax
  0001a	2b d1		 sub	 edx, ecx
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_lTime@@3KA ; m_lTime
  00022	03 ca		 add	 ecx, edx
  00024	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  0002a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime
  00030	76 0b		 jbe	 SHORT $L187294
  00032	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00037	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime
$L187294:

; 520  : 	while (m_lTime < (1000 / FRAME_PER_SEC))

  0003d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00040	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwOldTime@@3KA, eax ; m_dwOldTime
  00045	73 37		 jae	 SHORT $L186936
$L186935:

; 521  : 		UpdateTime();

  00047	ff d6		 call	 esi
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_dwOldTime@@3KA ; m_dwOldTime
  0004f	8b d0		 mov	 edx, eax
  00051	2b d1		 sub	 edx, ecx
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_lTime@@3KA ; m_lTime
  00059	03 ca		 add	 ecx, edx
  0005b	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00061	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime
  00067	76 0b		 jbe	 SHORT $L187299
  00069	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0006e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime
$L187299:
  00074	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00077	a3 00 00 00 00	 mov	 DWORD PTR ?m_dwOldTime@@3KA, eax ; m_dwOldTime
  0007c	72 c9		 jb	 SHORT $L186935
$L186936:

; 522  : 
; 523  : 	m_lTime -= (1000 / FRAME_PER_SEC);

  0007e	83 e9 10	 sub	 ecx, 16			; 00000010H
  00081	89 0d 00 00 00
	00		 mov	 DWORD PTR ?m_lTime@@3KA, ecx ; m_lTime
  00087	5e		 pop	 esi
$L186932:

; 524  : }

  00088	c3		 ret	 0
?SetFST@@YAXXZ ENDP					; SetFST
_TEXT	ENDS
PUBLIC	??1CTimer@@UAE@XZ				; CTimer::~CTimer
PUBLIC	??_7CTimer@@6B@					; CTimer::`vftable'
PUBLIC	??_GCTimer@@UAEPAXI@Z				; CTimer::`scalar deleting destructor'
EXTRN	??_ECTimer@@UAEPAXI@Z:NEAR			; CTimer::`vector deleting destructor'
;	COMDAT ??_7CTimer@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\timer.h
CONST	SEGMENT
??_7CTimer@@6B@ DD FLAT:??_ECTimer@@UAEPAXI@Z		; CTimer::`vftable'
	DD	FLAT:?Reset@CTimer@@UAEXXZ
	DD	FLAT:?Over@CTimer@@UAEHXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1CTimer@@UAE@XZ
_TEXT	SEGMENT
??1CTimer@@UAE@XZ PROC NEAR				; CTimer::~CTimer, COMDAT
; _this$ = ecx

; 19   : 	virtual ~CTimer()	{}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CTimer@@6B@
  00006	c3		 ret	 0
??1CTimer@@UAE@XZ ENDP					; CTimer::~CTimer
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTimer@@UAEPAXI@Z PROC NEAR				; CTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@
  0000e	74 09		 je	 SHORT $L187309
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$L187309:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_GCTimer@@UAEPAXI@Z ENDP				; CTimer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CSkipTimer@@UAE@XZ				; CSkipTimer::~CSkipTimer
; Function compile flags: /Ogty
;	COMDAT ??1CSkipTimer@@UAE@XZ
_TEXT	SEGMENT
??1CSkipTimer@@UAE@XZ PROC NEAR				; CSkipTimer::~CSkipTimer, COMDAT
; _this$ = ecx

; 49   : 	virtual	~CSkipTimer()	{}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CTimer@@6B@
  00006	c3		 ret	 0
??1CSkipTimer@@UAE@XZ ENDP				; CSkipTimer::~CSkipTimer
_TEXT	ENDS
PUBLIC	??0CTimer@@QAE@XZ				; CTimer::CTimer
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\timer.cpp
;	COMDAT ??0CTimer@@QAE@XZ
_TEXT	SEGMENT
tv143 = -4						; size = 4
??0CTimer@@QAE@XZ PROC NEAR				; CTimer::CTimer, COMDAT
; _this$ = ecx

; 9    : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@

; 10   : 	Set( 0.0f );

  0000a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00017	85 c0		 test	 eax, eax
  00019	89 44 24 04	 mov	 DWORD PTR tv143[esp+8], eax
  0001d	db 44 24 04	 fild	 DWORD PTR tv143[esp+8]
  00021	7d 06		 jge	 SHORT $L187330
  00023	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187330:
  00029	dd 56 08	 fst	 QWORD PTR [esi+8]

; 11   : }

  0002c	8b c6		 mov	 eax, esi
  0002e	dd 5e 10	 fstp	 QWORD PTR [esi+16]
  00031	5e		 pop	 esi
  00032	59		 pop	 ecx
  00033	c3		 ret	 0
??0CTimer@@QAE@XZ ENDP					; CTimer::CTimer
_TEXT	ENDS
PUBLIC	??0CTimer@@QAE@M@Z				; CTimer::CTimer
; Function compile flags: /Ogty
;	COMDAT ??0CTimer@@QAE@M@Z
_TEXT	SEGMENT
tv146 = -4						; size = 4
_fInterval$ = 8						; size = 4
??0CTimer@@QAE@M@Z PROC NEAR				; CTimer::CTimer, COMDAT
; _this$ = ecx

; 14   : {

  00000	51		 push	 ecx

; 15   : 	Set( fInterval );

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _fInterval$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@
  0000e	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00017	85 c0		 test	 eax, eax
  00019	89 44 24 04	 mov	 DWORD PTR tv146[esp+8], eax
  0001d	db 44 24 04	 fild	 DWORD PTR tv146[esp+8]
  00021	7d 06		 jge	 SHORT $L187345
  00023	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187345:
  00029	dd 56 08	 fst	 QWORD PTR [esi+8]

; 16   : }

  0002c	8b c6		 mov	 eax, esi
  0002e	d9 44 24 0c	 fld	 DWORD PTR _fInterval$[esp+4]
  00032	d8 c1		 fadd	 ST(0), ST(1)
  00034	dd 5e 10	 fstp	 QWORD PTR [esi+16]
  00037	5e		 pop	 esi
  00038	dd d8		 fstp	 ST(0)
  0003a	59		 pop	 ecx
  0003b	c2 04 00	 ret	 4
??0CTimer@@QAE@M@Z ENDP					; CTimer::CTimer
_TEXT	ENDS
PUBLIC	??0CTimer@@QAE@MH@Z				; CTimer::CTimer
; Function compile flags: /Ogty
;	COMDAT ??0CTimer@@QAE@MH@Z
_TEXT	SEGMENT
tv149 = -4						; size = 4
_fInterval$ = 8						; size = 4
_bFirstTimeOut$ = 12					; size = 4
??0CTimer@@QAE@MH@Z PROC NEAR				; CTimer::CTimer, COMDAT
; _this$ = ecx

; 19   : {

  00000	51		 push	 ecx

; 20   : 	Set( fInterval, bFirstTimeOut );

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _fInterval$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@
  0000e	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00017	85 c0		 test	 eax, eax
  00019	89 44 24 04	 mov	 DWORD PTR tv149[esp+8], eax
  0001d	db 44 24 04	 fild	 DWORD PTR tv149[esp+8]
  00021	7d 06		 jge	 SHORT $L187360
  00023	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187360:
  00029	8b 44 24 10	 mov	 eax, DWORD PTR _bFirstTimeOut$[esp+4]
  0002d	dd 56 08	 fst	 QWORD PTR [esi+8]
  00030	85 c0		 test	 eax, eax
  00032	75 04		 jne	 SHORT $L187357
  00034	d8 44 24 0c	 fadd	 DWORD PTR _fInterval$[esp+4]
$L187357:
  00038	dd 5e 10	 fstp	 QWORD PTR [esi+16]

; 21   : }

  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	59		 pop	 ecx
  0003f	c2 08 00	 ret	 8
??0CTimer@@QAE@MH@Z ENDP				; CTimer::CTimer
_TEXT	ENDS
PUBLIC	??0CGameTimer@@QAE@XZ				; CGameTimer::CGameTimer
PUBLIC	__real@0000000000000000
PUBLIC	__real@4147e53000000000
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@4147e53000000000
CONST	SEGMENT
__real@4147e53000000000 DQ 04147e53000000000r	; 3.132e+006
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CGameTimer@@QAE@XZ
_TEXT	SEGMENT
tv147 = -4						; size = 4
??0CGameTimer@@QAE@XZ PROC NEAR				; CGameTimer::CGameTimer, COMDAT
; _this$ = ecx

; 143  : {

  00000	51		 push	 ecx

; 144  : 	m_nSec = 0;
; 145  : 	m_nMin = 0;
; 146  : 	m_nHour = 0;
; 147  : 	m_nDay = 0;
; 148  : 	m_dBeginTime = 0;

  00001	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  0000d	57		 push	 edi

; 149  : 	m_dCurrentTime = 0;
; 150  : 	SetCurrentTime( 3, 15 );

  0000e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4147e53000000000
  00014	33 ff		 xor	 edi, edi
  00016	dd 1e		 fstp	 QWORD PTR [esi]
  00018	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0001b	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001e	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00021	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0002a	85 c0		 test	 eax, eax
  0002c	89 44 24 08	 mov	 DWORD PTR tv147[esp+12], eax
  00030	db 44 24 08	 fild	 DWORD PTR tv147[esp+12]
  00034	7d 06		 jge	 SHORT $L187376
  00036	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187376:

; 151  : 	m_bFixed = FALSE;

  0003c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0003f	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  00042	5f		 pop	 edi

; 152  : }

  00043	8b c6		 mov	 eax, esi
  00045	5e		 pop	 esi
  00046	59		 pop	 ecx
  00047	c3		 ret	 0
??0CGameTimer@@QAE@XZ ENDP				; CGameTimer::CGameTimer
_TEXT	ENDS
PUBLIC	??0CGameTimer@@QAE@N@Z				; CGameTimer::CGameTimer
; Function compile flags: /Ogty
;	COMDAT ??0CGameTimer@@QAE@N@Z
_TEXT	SEGMENT
tv147 = 8						; size = 4
_dCurrentime$ = 8					; size = 8
??0CGameTimer@@QAE@N@Z PROC NEAR			; CGameTimer::CGameTimer, COMDAT
; _this$ = ecx

; 155  : 	m_nSec = 0;
; 156  : 	m_nMin = 0;
; 157  : 	m_nHour = 0;
; 158  : 	m_nDay = 0;
; 159  : 	m_dBeginTime = 0;

  00000	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  0000c	57		 push	 edi

; 160  : 	m_dCurrentTime = 0;
; 161  : 	SetCurrentTime( dCurrentime );

  0000d	dd 44 24 0c	 fld	 QWORD PTR _dCurrentime$[esp+4]
  00011	33 ff		 xor	 edi, edi
  00013	dd 1e		 fstp	 QWORD PTR [esi]
  00015	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00018	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001b	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0001e	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00027	85 c0		 test	 eax, eax
  00029	89 44 24 0c	 mov	 DWORD PTR tv147[esp+4], eax
  0002d	db 44 24 0c	 fild	 DWORD PTR tv147[esp+4]
  00031	7d 06		 jge	 SHORT $L187382
  00033	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187382:

; 162  : 	m_bFixed = FALSE;

  00039	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0003c	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  0003f	5f		 pop	 edi

; 163  : }

  00040	8b c6		 mov	 eax, esi
  00042	5e		 pop	 esi
  00043	c2 08 00	 ret	 8
??0CGameTimer@@QAE@N@Z ENDP				; CGameTimer::CGameTimer
_TEXT	ENDS
PUBLIC	??1CDate@@QAE@XZ				; CDate::~CDate
; Function compile flags: /Ogty
;	COMDAT ??1CDate@@QAE@XZ
_TEXT	SEGMENT
??1CDate@@QAE@XZ PROC NEAR				; CDate::~CDate, COMDAT
; _this$ = ecx

; 313  : }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CTimer@@6B@
  00006	c3		 ret	 0
??1CDate@@QAE@XZ ENDP					; CDate::~CDate
_TEXT	ENDS
PUBLIC	??0CSkipTimer@@QAE@XZ				; CSkipTimer::CSkipTimer
PUBLIC	??_7CSkipTimer@@6B@				; CSkipTimer::`vftable'
PUBLIC	??_GCSkipTimer@@UAEPAXI@Z			; CSkipTimer::`scalar deleting destructor'
EXTRN	??_ECSkipTimer@@UAEPAXI@Z:NEAR			; CSkipTimer::`vector deleting destructor'
;	COMDAT ??_7CSkipTimer@@6B@
CONST	SEGMENT
??_7CSkipTimer@@6B@ DD FLAT:??_ECSkipTimer@@UAEPAXI@Z	; CSkipTimer::`vftable'
	DD	FLAT:?Reset@CTimer@@UAEXXZ
	DD	FLAT:?Over@CSkipTimer@@UAEHXZ
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\timer.h
CONST	ENDS
;	COMDAT ??0CSkipTimer@@QAE@XZ
_TEXT	SEGMENT
tv144 = -4						; size = 4
??0CSkipTimer@@QAE@XZ PROC NEAR				; CSkipTimer::CSkipTimer, COMDAT
; _this$ = ecx

; 47   : 	CSkipTimer() : CTimer()		{}

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@
  0000a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00017	85 c0		 test	 eax, eax
  00019	89 44 24 04	 mov	 DWORD PTR tv144[esp+8], eax
  0001d	db 44 24 04	 fild	 DWORD PTR tv144[esp+8]
  00021	7d 06		 jge	 SHORT $L187418
  00023	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187418:
  00029	dd 56 08	 fst	 QWORD PTR [esi+8]
  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CSkipTimer@@6B@
  00032	dd 5e 10	 fstp	 QWORD PTR [esi+16]
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi
  00038	59		 pop	 ecx
  00039	c3		 ret	 0
??0CSkipTimer@@QAE@XZ ENDP				; CSkipTimer::CSkipTimer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCSkipTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSkipTimer@@UAEPAXI@Z PROC NEAR			; CSkipTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CSkipTimer@@UAE@XZ	; CSkipTimer::~CSkipTimer
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L187421
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L187421:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCSkipTimer@@UAEPAXI@Z ENDP				; CSkipTimer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CDate@@QAE@XZ				; CDate::CDate
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\timer.cpp
;	COMDAT ??0CDate@@QAE@XZ
_TEXT	SEGMENT
tv165 = -4						; size = 4
??0CDate@@QAE@XZ PROC NEAR				; CDate::CDate, COMDAT
; _this$ = ecx

; 291  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@
  0000a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00017	85 c0		 test	 eax, eax
  00019	89 44 24 04	 mov	 DWORD PTR tv165[esp+8], eax
  0001d	db 44 24 04	 fild	 DWORD PTR tv165[esp+8]
  00021	7d 06		 jge	 SHORT $L187457
  00023	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187457:

; 292  : 	m_nYear   = 1;

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	dd 56 08	 fst	 QWORD PTR [esi+8]
  00031	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00034	dd 5e 10	 fstp	 QWORD PTR [esi+16]

; 293  : 	m_nMonth  = 1;

  00037	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 294  : 	m_nDay    = 1;

  0003a	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 295  : 	m_nHour   = 1;

  0003d	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 296  : 	m_nMinute = 1;

  00040	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 297  : 	m_nSecond = 1;

  00043	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 298  : 	m_nDelay  = 1;

  00046	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00049	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CSkipTimer@@6B@

; 299  : }

  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi
  00052	59		 pop	 ecx
  00053	c3		 ret	 0
??0CDate@@QAE@XZ ENDP					; CDate::CDate
_TEXT	ENDS
PUBLIC	??0CDate@@QAE@HHHHHHH@Z				; CDate::CDate
; Function compile flags: /Ogty
;	COMDAT ??0CDate@@QAE@HHHHHHH@Z
_TEXT	SEGMENT
tv208 = -4						; size = 4
tv203 = 8						; size = 4
_nYear$ = 8						; size = 4
_nMonth$ = 12						; size = 4
_nDay$ = 16						; size = 4
_nHour$ = 20						; size = 4
_nMinute$ = 24						; size = 4
_nSecond$ = 28						; size = 4
$T187501 = 32						; size = 4
_nDelay$ = 32						; size = 4
??0CDate@@QAE@HHHHHHH@Z PROC NEAR			; CDate::CDate, COMDAT
; _this$ = ecx

; 301  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi
  00005	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__timeGetTime@0
  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@
  00011	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00018	ff d7		 call	 edi
  0001a	85 c0		 test	 eax, eax
  0001c	89 44 24 08	 mov	 DWORD PTR tv208[esp+12], eax
  00020	db 44 24 08	 fild	 DWORD PTR tv208[esp+12]
  00024	7d 06		 jge	 SHORT $L187502
  00026	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187502:

; 302  : 	m_nYear   = nYear  ;

  0002c	8b 44 24 10	 mov	 eax, DWORD PTR _nYear$[esp+8]
  00030	dd 56 08	 fst	 QWORD PTR [esi+8]

; 303  : 	m_nMonth  = nMonth ;

  00033	8b 4c 24 14	 mov	 ecx, DWORD PTR _nMonth$[esp+8]
  00037	dd 5e 10	 fstp	 QWORD PTR [esi+16]

; 304  : 	m_nDay    = nDay   ;

  0003a	8b 54 24 18	 mov	 edx, DWORD PTR _nDay$[esp+8]

; 305  : 	m_nHour   = nHour  ;
; 306  : 	m_nMinute = nMinute;
; 307  : 	m_nSecond = nSecond;
; 308  : 	m_nDelay  = nDelay ;
; 309  : 	m_delay.Set((float)m_nDelay);

  0003e	db 44 24 28	 fild	 DWORD PTR _nDelay$[esp+8]
  00042	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00045	8b 44 24 1c	 mov	 eax, DWORD PTR _nHour$[esp+8]
  00049	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  0004c	8b 4c 24 20	 mov	 ecx, DWORD PTR _nMinute$[esp+8]
  00050	89 56 34	 mov	 DWORD PTR [esi+52], edx
  00053	8b 54 24 24	 mov	 edx, DWORD PTR _nSecond$[esp+8]
  00057	89 46 38	 mov	 DWORD PTR [esi+56], eax
  0005a	8b 44 24 28	 mov	 eax, DWORD PTR _nDelay$[esp+8]
  0005e	d9 5c 24 28	 fstp	 DWORD PTR $T187501[esp+8]
  00062	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CSkipTimer@@6B@
  00068	89 4e 3c	 mov	 DWORD PTR [esi+60], ecx
  0006b	89 56 40	 mov	 DWORD PTR [esi+64], edx
  0006e	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00071	ff d7		 call	 edi
  00073	85 c0		 test	 eax, eax
  00075	89 44 24 10	 mov	 DWORD PTR tv203[esp+8], eax
  00079	db 44 24 10	 fild	 DWORD PTR tv203[esp+8]
  0007d	7d 06		 jge	 SHORT $L187503
  0007f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$L187503:
  00085	8b 4c 24 28	 mov	 ecx, DWORD PTR $T187501[esp+8]
  00089	dd 5e 08	 fstp	 QWORD PTR [esi+8]
  0008c	5f		 pop	 edi
  0008d	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00090	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 310  : }

  00097	8b c6		 mov	 eax, esi
  00099	5e		 pop	 esi
  0009a	59		 pop	 ecx
  0009b	c2 1c 00	 ret	 28			; 0000001cH
??0CDate@@QAE@HHHHHHH@Z ENDP				; CDate::CDate
_TEXT	ENDS
END
