; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\file.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?Close@CFileIO@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Open@CFileIO@@UAEHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CFileIO@@UAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutWideString@CFileIO@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileFinder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFileFinder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WildCmp@CFileFinder@@QAEHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindClose@CFileFinder@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Write@CFileIO@@QAEIPAXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_mbstowcsz@ATL@@YAHPAGPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	?Close@CFileIO@@UAEHXZ				; CFileIO::Close
EXTRN	_fclose:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\file.cpp
;	COMDAT ?Close@CFileIO@@UAEHXZ
_TEXT	SEGMENT
?Close@CFileIO@@UAEHXZ PROC NEAR			; CFileIO::Close, COMDAT
; _this$ = ecx

; 17   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 18   : 	if( fp ) 

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 17		 je	 SHORT $L186716

; 19   : 	{ 
; 20   : 		fclose( fp ); 

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _fclose
  00010	83 c4 04	 add	 esp, 4

; 21   : 		fp = 0; 

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 22   : 		return TRUE; 

  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	5e		 pop	 esi

; 25   : }

  00020	c3		 ret	 0
$L186716:

; 23   : 	}
; 24   : 	return FALSE;

  00021	33 c0		 xor	 eax, eax
  00023	5e		 pop	 esi

; 25   : }

  00024	c3		 ret	 0
?Close@CFileIO@@UAEHXZ ENDP				; CFileIO::Close
_TEXT	ENDS
PUBLIC	?Open@CFileIO@@UAEHPBDPAD@Z			; CFileIO::Open
EXTRN	_fopen:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Open@CFileIO@@UAEHPBDPAD@Z
_TEXT	SEGMENT
_fileName$ = 8						; size = 4
_mode$ = 12						; size = 4
?Open@CFileIO@@UAEHPBDPAD@Z PROC NEAR			; CFileIO::Open, COMDAT
; _this$ = ecx

; 29   : 	fp = _tfopen( fileName, mode );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _mode$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR _fileName$[esp]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _fopen

; 30   : 	if( fp )

  00012	33 d2		 xor	 edx, edx
  00014	83 c4 08	 add	 esp, 8
  00017	85 c0		 test	 eax, eax
  00019	0f 95 c2	 setne	 dl
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001f	5e		 pop	 esi
  00020	8b c2		 mov	 eax, edx

; 31   : 		return TRUE;
; 32   : 	return FALSE;
; 33   : }

  00022	c2 08 00	 ret	 8
?Open@CFileIO@@UAEHPBDPAD@Z ENDP			; CFileIO::Open
_TEXT	ENDS
PUBLIC	?Read@CFileIO@@UAEPAXXZ				; CFileIO::Read
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	_fread:NEAR
EXTRN	_fseek:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Read@CFileIO@@UAEPAXXZ
_TEXT	SEGMENT
?Read@CFileIO@@UAEPAXXZ PROC NEAR			; CFileIO::Read, COMDAT
; _this$ = ecx

; 36   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 37   : 	long size = GetLength();

  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	57		 push	 edi
  00007	ff 50 24	 call	 DWORD PTR [eax+36]
  0000a	8b d8		 mov	 ebx, eax

; 38   : 	LPVOID ptr = new BYTE[ size ];

  0000c	53		 push	 ebx
  0000d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00012	8b f8		 mov	 edi, eax
  00014	83 c4 04	 add	 esp, 4

; 39   : 	if( !ptr ) 

  00017	85 ff		 test	 edi, edi

; 40   : 		return NULL;

  00019	74 30		 je	 SHORT $L186955

; 41   : 
; 42   : 	fseek( fp, 0, SEEK_SET );

  0001b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 _fseek

; 43   : 	if( fread( ptr, size, 1, fp ) ) 

  00028	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002b	52		 push	 edx
  0002c	6a 01		 push	 1
  0002e	53		 push	 ebx
  0002f	57		 push	 edi
  00030	e8 00 00 00 00	 call	 _fread
  00035	83 c4 1c	 add	 esp, 28			; 0000001cH
  00038	85 c0		 test	 eax, eax
  0003a	74 06		 je	 SHORT $L186732

; 44   : 	{ 
; 45   : 		return ptr;

  0003c	8b c7		 mov	 eax, edi
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 49   : }

  00041	c3		 ret	 0
$L186732:

; 46   : 	}
; 47   : 	safe_delete_array( ptr ); 

  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00048	83 c4 04	 add	 esp, 4
$L186955:
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 48   : 	return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	5b		 pop	 ebx

; 49   : }

  00050	c3		 ret	 0
?Read@CFileIO@@UAEPAXXZ ENDP				; CFileIO::Read
_TEXT	ENDS
PUBLIC	??0CFileFinder@@QAE@XZ				; CFileFinder::CFileFinder
; Function compile flags: /Ogty
;	COMDAT ??0CFileFinder@@QAE@XZ
_TEXT	SEGMENT
??0CFileFinder@@QAE@XZ PROC NEAR			; CFileFinder::CFileFinder, COMDAT
; _this$ = ecx

; 670  : {

  00000	8b c1		 mov	 eax, ecx

; 671  : 	m_pos = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 672  : 	m_lHandle = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 673  : 	m_bResFile = FALSE;

  00009	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 674  : }

  0000f	c3		 ret	 0
??0CFileFinder@@QAE@XZ ENDP				; CFileFinder::CFileFinder
_TEXT	ENDS
PUBLIC	??1CFileFinder@@QAE@XZ				; CFileFinder::~CFileFinder
; Function compile flags: /Ogty
;	COMDAT ??1CFileFinder@@QAE@XZ
_TEXT	SEGMENT
??1CFileFinder@@QAE@XZ PROC NEAR			; CFileFinder::~CFileFinder, COMDAT
; _this$ = ecx

; 677  : }

  00000	c3		 ret	 0
??1CFileFinder@@QAE@XZ ENDP				; CFileFinder::~CFileFinder
_TEXT	ENDS
PUBLIC	?WildCmp@CFileFinder@@QAEHPBD0@Z		; CFileFinder::WildCmp
; Function compile flags: /Ogty
;	COMDAT ?WildCmp@CFileFinder@@QAEHPBD0@Z
_TEXT	SEGMENT
_cp$ = 8						; size = 4
_mp$ = 8						; size = 4
_lpszWild$ = 8						; size = 4
_lpszString$ = 12					; size = 4
?WildCmp@CFileFinder@@QAEHPBD0@Z PROC NEAR		; CFileFinder::WildCmp, COMDAT
; _this$ = ecx

; 681  : 	char* wild = (char*)lpszWild;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lpszWild$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 682  :     char* string = (char*)lpszString;

  00006	8b 74 24 10	 mov	 esi, DWORD PTR _lpszString$[esp+4]

; 683  : 	char* cp,* mp;
; 684  : 
; 685  : 	while ((*string) && (*wild != '*')) 

  0000a	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000d	57		 push	 edi
  0000e	74 42		 je	 SHORT $L186963
$L186759:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  00015	74 3b		 je	 SHORT $L186963

; 686  : 	{
; 687  : 		if ((*wild != *string) && (*wild != '?')) 

  00017	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00019	74 05		 je	 SHORT $L186761
  0001b	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  0001e	75 2a		 jne	 SHORT $L186965
$L186761:

; 683  : 	char* cp,* mp;
; 684  : 
; 685  : 	while ((*string) && (*wild != '*')) 

  00020	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]

; 690  : 		}
; 691  : 		wild++;

  00023	40		 inc	 eax

; 692  : 		string++;

  00024	46		 inc	 esi
  00025	84 c9		 test	 cl, cl
  00027	75 e7		 jne	 SHORT $L186759
$L186964:

; 715  : 		}
; 716  : 	}
; 717  : 	while (*wild == '*') 

  00029	80 38 2a	 cmp	 BYTE PTR [eax], 42	; 0000002aH
  0002c	75 0b		 jne	 SHORT $L186773
  0002e	8b ff		 npad	 2
$L186772:
  00030	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 718  : 	{
; 719  : 		wild++;

  00033	40		 inc	 eax
  00034	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  00037	74 f7		 je	 SHORT $L186772
$L186773:

; 720  : 	}
; 721  : 	return !*wild;

  00039	8a 10		 mov	 dl, BYTE PTR [eax]
  0003b	33 c9		 xor	 ecx, ecx
  0003d	84 d2		 test	 dl, dl
  0003f	0f 94 c1	 sete	 cl
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b c1		 mov	 eax, ecx

; 722  : }

  00047	c2 08 00	 ret	 8
$L186965:
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 688  : 		{
; 689  : 			return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	5b		 pop	 ebx

; 722  : }

  0004f	c2 08 00	 ret	 8
$L186963:

; 693  : 	}
; 694  : 	while (*string) 

  00052	8a 16		 mov	 dl, BYTE PTR [esi]
  00054	84 d2		 test	 dl, dl
  00056	74 d1		 je	 SHORT $L186964
  00058	8b 5c 24 10	 mov	 ebx, DWORD PTR _mp$[esp+8]
  0005c	8b 7c 24 10	 mov	 edi, DWORD PTR _cp$[esp+8]
$L186763:

; 695  : 	{
; 696  : 		if (*wild == '*') 

  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  00065	75 0f		 jne	 SHORT $L186765

; 697  : 		{
; 698  : 			if (!*++wild) 

  00067	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0006a	40		 inc	 eax
  0006b	84 c9		 test	 cl, cl
  0006d	74 21		 je	 SHORT $L186966

; 701  : 			}
; 702  : 			mp = wild;

  0006f	8b d8		 mov	 ebx, eax

; 703  : 			cp = string+1;

  00071	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 704  : 		} 
; 705  : 		else 

  00074	eb 12		 jmp	 SHORT $L186770
$L186765:

; 706  : 		if ((*wild == *string) || (*wild == '?')) 

  00076	3a ca		 cmp	 cl, dl
  00078	74 0c		 je	 SHORT $L186769
  0007a	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  0007d	74 07		 je	 SHORT $L186769

; 710  : 		} 
; 711  : 		else 
; 712  : 		{
; 713  : 			wild = mp;
; 714  : 			string = cp++;

  0007f	8b f7		 mov	 esi, edi
  00081	8b c3		 mov	 eax, ebx
  00083	47		 inc	 edi
  00084	eb 02		 jmp	 SHORT $L186770
$L186769:

; 707  : 		{
; 708  : 			wild++;

  00086	40		 inc	 eax

; 709  : 			string++;

  00087	46		 inc	 esi
$L186770:
  00088	8a 16		 mov	 dl, BYTE PTR [esi]
  0008a	84 d2		 test	 dl, dl
  0008c	75 d2		 jne	 SHORT $L186763

; 697  : 		{
; 698  : 			if (!*++wild) 

  0008e	eb 99		 jmp	 SHORT $L186964
$L186966:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 699  : 			{
; 700  : 				return 1;

  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	5b		 pop	 ebx

; 722  : }

  00098	c2 08 00	 ret	 8
?WildCmp@CFileFinder@@QAEHPBD0@Z ENDP			; CFileFinder::WildCmp
_TEXT	ENDS
PUBLIC	?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z ; CFileFinder::FindFirst
EXTRN	__findfirst:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z
_TEXT	SEGMENT
_lpFilespec$ = 8					; size = 4
_fileinfo$ = 12						; size = 4
?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z PROC NEAR ; CFileFinder::FindFirst, COMDAT
; _this$ = ecx

; 726  : #if defined( __CLIENT )
; 727  : 	CHAR filespec[ MAX_PATH ];
; 728  : 	strcpy( filespec, lpFilespec );
; 729  : 	strlwr( filespec );
; 730  : 
; 731  : 	CHAR szPath [ MAX_PATH ];
; 732  : 	CHAR szFile[ MAX_PATH ];
; 733  : 
; 734  : 	TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], name[ _MAX_FNAME ], ext[_MAX_EXT];
; 735  : 	_splitpath( lpFilespec, drive, dir, name, ext );
; 736  : 
; 737  : 	// 드라이브명이 들어 있으면 완전한 path다. 그러므로 그냥 카피 
; 738  : 	if( drive[ 0 ] )
; 739  : 	{
; 740  : 		_tcscpy( m_szFilespec, lpFilespec );
; 741  : 	}
; 742  : 	// 드리이브명이 없으면 현재 path의 연장이다. 
; 743  : 	else
; 744  : 	{
; 745  : 		::GetCurrentDirectory( MAX_PATH, szPath );
; 746  : 		_tcscpy( m_szFilespec, szPath );
; 747  : 		_tcscat( m_szFilespec, "\\" );
; 748  : 		_tcscat( m_szFilespec, lpFilespec );
; 749  : 	}
; 750  : 	strlwr( m_szFilespec );
; 751  : 
; 752  : 	CString strNameName;
; 753  : 	RESOURCE* lpRes;
; 754  : 	m_pos = CResFile::m_mapResource.GetStartPosition();
; 755  : 	while( m_pos )
; 756  : 	{
; 757  : 		CResFile::m_mapResource.GetNextAssoc( m_pos, strNameName, (void*&) lpRes );
; 758  : 		_tcscpy( szFile, szPath );
; 759  : 		_tcscat( szFile, "\\" );
; 760  : 		_tcscat( szFile, strNameName );
; 761  : 		strlwr( szFile );
; 762  : 
; 763  : 		if( WildCmp( m_szFilespec, szFile ) )
; 764  : 		{
; 765  : 			_splitpath( strNameName, drive, dir, name, ext );
; 766  : 			strcpy( fileinfo->name, name );
; 767  : 			strcat( fileinfo->name, ext );
; 768  : 			fileinfo->size = lpRes->dwFileSize;
; 769  : 			fileinfo->attrib = _A_NORMAL;
; 770  : 			m_bResFile = TRUE;
; 771  : 			return TRUE;
; 772  : 		}
; 773  : 	}
; 774  : #endif	// __CLIENT
; 775  : 	m_bResFile = 0;
; 776  : 	m_lHandle = _findfirst( lpFilespec, fileinfo );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _fileinfo$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR _lpFilespec$[esp]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	c7 86 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+268], 0
  00017	e8 00 00 00 00	 call	 __findfirst

; 777  : 	if( m_lHandle == -1 ) 

  0001c	33 d2		 xor	 edx, edx
  0001e	83 c4 08	 add	 esp, 8
  00021	83 f8 ff	 cmp	 eax, -1
  00024	0f 95 c2	 setne	 dl
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002a	5e		 pop	 esi
  0002b	8b c2		 mov	 eax, edx

; 778  : 		return FALSE;
; 779  : 	return TRUE;
; 780  : }

  0002d	c2 08 00	 ret	 8
?FindFirst@CFileFinder@@QAEHPBDPAU_finddata_t@@@Z ENDP	; CFileFinder::FindFirst
_TEXT	ENDS
PUBLIC	?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z	; CFileFinder::FindNext
EXTRN	__findnext:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z
_TEXT	SEGMENT
_fileinfo$ = 8						; size = 4
?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z PROC NEAR	; CFileFinder::FindNext, COMDAT
; _this$ = ecx

; 783  : #if defined( __CLIENT )
; 784  : 	if( m_bResFile == 1 )
; 785  : 	{
; 786  : 		TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], name[ _MAX_FNAME ], ext[_MAX_EXT];
; 787  : 		CHAR szPath [MAX_PATH];
; 788  : 		CHAR szFile[MAX_PATH];
; 789  : 		CString strNameName;
; 790  : 		RESOURCE* lpRes;
; 791  : 		::GetCurrentDirectory( MAX_PATH, szPath );
; 792  : 
; 793  : 		while( m_pos )
; 794  : 		{
; 795  : 			CResFile::m_mapResource.GetNextAssoc( m_pos, strNameName, (void*&) lpRes );
; 796  : 			_tcscpy( szFile, szPath );
; 797  : 			_tcscat( szFile, "\\" );
; 798  : 			_tcscat( szFile, strNameName );
; 799  : 			strlwr( szFile );
; 800  : 
; 801  : 			if( WildCmp( m_szFilespec, szFile ) )
; 802  : 			{
; 803  : 				_splitpath( strNameName, drive, dir, name, ext );
; 804  : 				strcpy( fileinfo->name, name );
; 805  : 				strcat( fileinfo->name, ext );
; 806  : 				fileinfo->size = lpRes->dwFileSize;
; 807  : 				fileinfo->attrib = _A_NORMAL;
; 808  : 				return TRUE;
; 809  : 			}
; 810  : 		}
; 811  : 		return FALSE;
; 812  : 	}
; 813  : #endif	// __CLIENT
; 814  : 	if( _findnext( m_lHandle, fileinfo ) == 0 )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _fileinfo$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 __findnext
  0000e	83 c4 08	 add	 esp, 8
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 815  : 		return TRUE;
; 816  : 	return FALSE;
; 817  : }

  00016	c2 04 00	 ret	 4
?FindNext@CFileFinder@@QAEHPAU_finddata_t@@@Z ENDP	; CFileFinder::FindNext
_TEXT	ENDS
PUBLIC	?FindClose@CFileFinder@@QAEXXZ			; CFileFinder::FindClose
EXTRN	__findclose:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindClose@CFileFinder@@QAEXXZ
_TEXT	SEGMENT
?FindClose@CFileFinder@@QAEXXZ PROC NEAR		; CFileFinder::FindClose, COMDAT
; _this$ = ecx

; 820  : 	if( m_bResFile == 0 && m_lHandle != -1 )

  00000	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  00006	85 c0		 test	 eax, eax
  00008	75 0f		 jne	 SHORT $L186788
  0000a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	74 07		 je	 SHORT $L186788

; 821  : 		_findclose( m_lHandle );

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 __findclose
  00018	59		 pop	 ecx
$L186788:

; 822  : }

  00019	c3		 ret	 0
?FindClose@CFileFinder@@QAEXXZ ENDP			; CFileFinder::FindClose
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__InterlockedExchange@8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
EXTRN	__imp__GetThreadLocale@0:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_szACP$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax

; 102  : 	UINT nACP = 0;

  0000f	33 f6		 xor	 esi, esi

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  00017	6a 07		 push	 7
  00019	8d 4c 24 08	 lea	 ecx, DWORD PTR _szACP$[esp+20]
  0001d	51		 push	 ecx
  0001e	68 04 10 00 00	 push	 4100			; 00001004H
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  0002a	85 c0		 test	 eax, eax
  0002c	74 27		 je	 SHORT $L186983

; 111  : 	{
; 112  : 		char* pch = szACP;
; 113  : 		while (*pch != '\0')

  0002e	8a 44 24 04	 mov	 al, BYTE PTR _szACP$[esp+16]
  00032	84 c0		 test	 al, al
  00034	8d 4c 24 04	 lea	 ecx, DWORD PTR _szACP$[esp+16]
  00038	74 1b		 je	 SHORT $L186983
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L38554:

; 114  : 		{
; 115  : 			nACP *= 10;
; 116  : 			nACP += *pch++ - '0';

  00040	0f be c0	 movsx	 eax, al
  00043	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  00046	41		 inc	 ecx
  00047	8d 74 50 d0	 lea	 esi, DWORD PTR [eax+edx*2-48]
  0004b	8a 01		 mov	 al, BYTE PTR [ecx]
  0004d	84 c0		 test	 al, al
  0004f	75 ef		 jne	 SHORT $L38554

; 117  : 		}
; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  00051	85 f6		 test	 esi, esi
  00053	75 16		 jne	 SHORT $L186984
$L186983:

; 121  : 		nACP = ::GetACP();

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  0005b	5e		 pop	 esi

; 122  : 
; 123  : 	return nACP;
; 124  : }

  0005c	8b 4c 24 08	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+12]
  00060	33 cc		 xor	 ecx, esp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	c3		 ret	 0
$L186984:
  0006b	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16]
  0006f	8b c6		 mov	 eax, esi
  00071	5e		 pop	 esi
  00072	33 cc		 xor	 ecx, esp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 128  : 	return( CP_THREAD_ACP );

  00000	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00005	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_ver$ = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 94 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+152], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );
; 139  : 	::GetVersionEx( &ver );

  00014	8d 04 24	 lea	 eax, DWORD PTR _ver$[esp+152]
  00017	50		 push	 eax
  00018	c7 44 24 04 94
	00 00 00	 mov	 DWORD PTR _ver$[esp+156], 148 ; 00000094H
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00026	83 7c 24 10 02	 cmp	 DWORD PTR _ver$[esp+168], 2
  0002b	75 0c		 jne	 SHORT $L38564
  0002d	83 7c 24 04 05	 cmp	 DWORD PTR _ver$[esp+156], 5

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  00032	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal
  00037	73 05		 jae	 SHORT $L38565
$L38564:

; 144  : 	}
; 145  : 	else
; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L38565:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00050	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  00057	33 cc		 xor	 ecx, esp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00064	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 158  : 	return( g_pfnGetThreadACP() );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?_mbstowcsz@ATL@@YAHPAGPBDK@Z			; ATL::_mbstowcsz
EXTRN	__imp__MultiByteToWideChar@24:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?_mbstowcsz@ATL@@YAHPAGPBDK@Z
_TEXT	SEGMENT
_wcstr$ = 8						; size = 4
_mbstr$ = 12						; size = 4
_count$ = 16						; size = 4
?_mbstowcsz@ATL@@YAHPAGPBDK@Z PROC NEAR			; ATL::_mbstowcsz, COMDAT

; 95   : {

  00000	56		 push	 esi

; 96   : 	// count is number of wchar_t's
; 97   : 	if (count == 0 && wcstr != NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _wcstr$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 14	 mov	 edi, DWORD PTR _count$[esp+4]
  0000a	85 ff		 test	 edi, edi
  0000c	75 09		 jne	 SHORT $L40154
  0000e	85 f6		 test	 esi, esi
  00010	74 05		 je	 SHORT $L40154
  00012	5f		 pop	 edi

; 98   : 		return 0;

  00013	33 c0		 xor	 eax, eax
  00015	5e		 pop	 esi

; 105  : 	return result;
; 106  : }

  00016	c3		 ret	 0
$L40154:

; 99   : 
; 100  : 	int result = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, mbstr, -1,
; 101  : 		wcstr, count);

  00017	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0001d	8b 4c 24 10	 mov	 ecx, DWORD PTR _mbstr$[esp+4]
  00021	57		 push	 edi
  00022	56		 push	 esi
  00023	6a ff		 push	 -1
  00025	51		 push	 ecx
  00026	6a 00		 push	 0
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 102  : 	ATLASSERT(wcstr == NULL || result <= (int)count);
; 103  : 	if ((result > 0) && (wcstr != NULL))

  0002f	85 c0		 test	 eax, eax
  00031	7e 0b		 jle	 SHORT $L40153
  00033	85 f6		 test	 esi, esi
  00035	74 07		 je	 SHORT $L40153

; 104  : 		wcstr[result-1] = 0;

  00037	66 c7 44 46 fe
	00 00		 mov	 WORD PTR [esi+eax*2-2], 0
$L40153:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 105  : 	return result;
; 106  : }

  00040	c3		 ret	 0
?_mbstowcsz@ATL@@YAHPAGPBDK@Z ENDP			; ATL::_mbstowcsz
_TEXT	ENDS
PUBLIC	?Write@CFileIO@@QAEIPAXII@Z			; CFileIO::Write
EXTRN	_fwrite:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\file.h
;	COMDAT ?Write@CFileIO@@QAEIPAXII@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_n$ = 16						; size = 4
?Write@CFileIO@@QAEIPAXII@Z PROC NEAR			; CFileIO::Write, COMDAT
; _this$ = ecx

; 36   : 	size_t Write( LPVOID ptr, size_t size, size_t n = 1 ) { return fwrite( ptr, size, n, fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 0c	 mov	 ecx, DWORD PTR _n$[esp-4]
  00007	8b 54 24 08	 mov	 edx, DWORD PTR _size$[esp-4]
  0000b	50		 push	 eax
  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _ptr$[esp]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _fwrite
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?Write@CFileIO@@QAEIPAXII@Z ENDP			; CFileIO::Write
_TEXT	ENDS
PUBLIC	?PutWideString@CFileIO@@QAEHPBD@Z		; CFileIO::PutWideString
EXTRN	_wcslen:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\file.cpp
;	COMDAT ?PutWideString@CFileIO@@QAEHPBD@Z
_TEXT	SEGMENT
_wszBuff$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpszString$ = 8					; size = 4
?PutWideString@CFileIO@@QAEHPBD@Z PROC NEAR		; CFileIO::PutWideString, COMDAT
; _this$ = ecx

; 51   : {

  00000	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b bc 24 14 08
	00 00		 mov	 edi, DWORD PTR _lpszString$[esp+2060]
  00017	89 84 24 0c 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2064], eax

; 52   : 	wchar_t wszBuff[ 1024 ];
; 53   : 	int nLen = strlen( lpszString );

  0001e	8b c7		 mov	 eax, edi
  00020	8b d9		 mov	 ebx, ecx
  00022	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L187030:
  00025	8a 08		 mov	 cl, BYTE PTR [eax]
  00027	40		 inc	 eax
  00028	84 c9		 test	 cl, cl
  0002a	75 f9		 jne	 SHORT $L187030
  0002c	2b c2		 sub	 eax, edx

; 54   : 
; 55   : 	ATL::_mbstowcsz(wszBuff, lpszString,nLen + 1 );

  0002e	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00031	85 f6		 test	 esi, esi
  00033	74 23		 je	 SHORT $L187019
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0003b	56		 push	 esi
  0003c	8d 4c 24 10	 lea	 ecx, DWORD PTR _wszBuff$[esp+2068]
  00040	51		 push	 ecx
  00041	6a ff		 push	 -1
  00043	57		 push	 edi
  00044	6a 00		 push	 0
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  0004d	85 c0		 test	 eax, eax
  0004f	7e 07		 jle	 SHORT $L187019
  00051	66 c7 44 44 0a
	00 00		 mov	 WORD PTR _wszBuff$[esp+eax*2+2062], 0
$L187019:

; 56   : 
; 57   : 	return Write( wszBuff, wcslen( wszBuff ) * 2 );

  00058	8d 54 24 0c	 lea	 edx, DWORD PTR _wszBuff$[esp+2064]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _wcslen
  00062	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00065	51		 push	 ecx
  00066	d1 e0		 shl	 eax, 1
  00068	6a 01		 push	 1
  0006a	50		 push	 eax
  0006b	8d 54 24 1c	 lea	 edx, DWORD PTR _wszBuff$[esp+2080]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _fwrite

; 58   : }

  00075	8b 8c 24 20 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2084]
  0007c	83 c4 14	 add	 esp, 20			; 00000014H
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	33 cc		 xor	 ecx, esp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	81 c4 04 08 00
	00		 add	 esp, 2052		; 00000804H
  0008f	c2 04 00	 ret	 4
?PutWideString@CFileIO@@QAEHPBD@Z ENDP			; CFileIO::PutWideString
_TEXT	ENDS
END
