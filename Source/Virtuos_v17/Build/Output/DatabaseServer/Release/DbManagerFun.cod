; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Database\DbManagerFun.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DB@BEDINLHB@RANKING?4RANKING_DBF?4dbo?4RANKING_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@HNMEKJGP@CDbManager?3?3UpdateGuildRanking?$LP?$KB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LJMBJH@m_dwLogo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NKFNPOPN@m_szGuild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HDDJDJAG@m_szName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LJIKPPDH@m_nWin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IGCLHJHO@m_nLose?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BBOGLCAO@m_nSurrender?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EKKIFFNL@m_AvgLevel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EMHJODPK@m_nWinPoint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CJGBCKAI@MAKE_RANKING_STR?5?8?$CFd?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@IPKIBOKB@CDbManager?3?3RankingDBUpdate?5?$CI?$CFs?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MOGJFHKK@tr1?3?3bad_weak_ptr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOHNFIBA@SetLOD?5?3?5lv?$DN?$CFd?0?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IEFGPJMF@GetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03BMNKJJEN@?$CF2X?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@KADALJOE@SetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FONFFEJF@m_idPlayer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KIBMFHG@m_dwGoldBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BAMDHIIP@m_Bank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KMLFLAAK@m_apIndex_Bank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HHMCMCCB@m_dwObjIndex_Bank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CHFBCGKD@m_extBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HANLGJJC@m_BankPiercing?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DAKBPAHF@szBankPet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@JMMGLGKB@Join?3?3Bank?5?3?5?$DM?$DM?5Not?5Prop?4?5?$CFd?0?5?$CFd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPGFAEMD@Join?3?3Bank?5?3?5?$DM?$DM?5MAX_BANK?5?$CFd?6Bank@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EFEJAHGE@Bank?5?$DN?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GKPNPIJD@m_GuildBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KBFNBDP@GuildBank?5?$DN?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CLIOIOKN@m_extGuildBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOMLDJLH@m_GuildBankPiercing?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOKIMIMD@szGuildBankPet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DKFLNFEC@szItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07ODPBDBGJ@szIndex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LNBLBPOC@szObjIndex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MNJCPEEI@szExt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MAAIPEIA@szPiercing?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LOKLGDMG@szPet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LCDBAOIB@nPocket?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MECCMHDE@bExpired?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OHENMHDO@tExpirationDate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@BKCBFKFA@Join?3Pocket?3Property?5not?5found?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@EAAOHIMM@Join?3Pocket?3POCKET_SLOT_SIZE_1_2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GIEPEBGM@m_Inventory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@JJEIFMEB@Inventory?5?3?5?$DM?$DM?5?G?A?$LH?N?F?$NL?F?$LM?5?$LO?x?$MA?$LN?4?5?$CFs@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@KLFMFNBG@Join?3?3Inventory?5?3?5?$DM?$DM?5IndexItem?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FEOHFPFP@Inventory?5?$DN?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HGEFOOAJ@m_apIndex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KMOLMNCJ@m_dwObjIndex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CJDMDHFC@m_extInventory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OAKPNEDM@m_InventoryPiercing?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GAFIDLHN@szInventoryPet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JGBJEPOF@nPiercedSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IJJPBAHM@dwItemId?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DNIGFLMJ@nPiercedSize2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MCBMMJCE@m_adwEquipment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GNBKFLOM@m_aSlotApplet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OJJDLIJE@m_aSlotItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CPNBAAIJ@m_aSlotQueue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NJKCPPDJ@m_SkillBar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LGPNILBK@m_vScale_x?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MOMKJNEM@m_dwMotion?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DHJEDBNA@dwWorldID?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FJAEPELD@m_vPos_x?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EABPMFPC@m_vPos_y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GLDCJGDB@m_vPos_z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MNAKGHOO@m_fAngle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJPKIIEM@m_szCharacterKey?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PMKOKNNK@m_nHitPoint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GFDNJNAL@m_nManaPoint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@COGKPMEJ@m_nFatiguePoint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BCEJBJHD@m_dwSkinSet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HFOELFNC@m_dwHairMesh?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ICOGEKE@m_dwHairColor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BHMOBEMJ@m_dwHeadMesh?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KMHLCHEI@m_dwSex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MHMDKNKE@m_dwRideItemIdx?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JIMIMGKM@m_dwGold?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LDMBEDML@m_nJob?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OGJJHMJA@m_idparty?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IFGJAIGP@m_nPKValue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMCDCCD@m_dwPKPropensity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BCFDFPLE@m_dwPKExp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IJMKHCEF@m_nAngelExp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@COEFFCNN@m_nAngelLevel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MHHICKD@m_idMuerderer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07DKPMJIJG@m_nFame?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BFJHKIPJ@m_pActMover?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MEGBAFBO@m_nStr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KFIOEEIM@m_nSta?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OOKEELPF@m_nDex?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LMCODDMF@m_nInt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DBNLLHK@m_nLevel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JKGEFCCA@m_nExp1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07DKFGLCKP@m_nFuel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FGBAAHFN@m_tmAccFuel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGOJBJIH@m_idMarkingWorld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LIDMOLFI@m_vMarkingPos_x?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KBCHNKBJ@m_vMarkingPos_y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@IKAKIJNK@m_vMarkingPos_z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HLGMCMLP@m_nRemainGP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HKFGBBGJ@m_nFlightLv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JIIKDJFF@m_nFxp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MFHALOPE@m_dwMode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MAONGJJI@m_nDeathExp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JALGGJEE@m_nDeathLevel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MFLDFMGF@m_SkillLv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FMKKCMCC@m_SkillPoint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JOEHCELE@m_nHonor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@DBOKEMLK@usp_Master_Select?5?8?$CF02d?8?0?8?$CF07d?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KHPNBODO@sec?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03BFBOJKCM@c01?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DODDMJOP@c02?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CHCIPIKO@c03?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GIGJGOGJ@c04?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HBHCFPCI@c05?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FKFPAMOL@c06?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EDEEDNKK@c07?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MENMCBGF@c08?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NNMHBACE@c09?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NMHMBFK@c10?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03BENMPABL@c11?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DPPBKDNI@c12?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CGOKJCJJ@c13?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GJKLAEFO@c14?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HALADFBP@c15?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FLJNGGNM@c16?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03ECIGFHJN@c17?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MFBOELFC@c18?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NMAFHKBD@c19?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03PIBHPAD@c20?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03BGJKEOEC@c21?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DNLHBNIB@c22?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CEKMCMMA@c23?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GLONLKAH@c24?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HCPGILEG@c25?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FJNLNIIF@c26?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EAMAOJME@c27?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MHFIPFAL@c28?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NOEDMEEK@c29?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03OEDBFDE@c30?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03BHFICEHF@c31?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DMHFHHLG@c32?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CFGOEGPH@c33?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GKCPNADA@c34?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HDDEOBHB@c35?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FIBJLCLC@c36?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EBACIDPD@c37?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MGJKJPDM@c38?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NPIBKOHN@c39?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03LAMADLB@c40?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03BCBHDCPA@c41?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DJDKGBDD@c42?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CACBFAHC@c43?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GPGAMGLF@c44?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HGHLPHPE@c45?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FNFGKEDH@c46?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EEENJFHG@c47?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MDNFIJLJ@c48?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NKMOLIPI@c49?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KMOGJIG@c50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@IGLOLMFD@uspLoadCharacterSkill?5?8?$CF02d?8?0?8?$CF0@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MDJBOIOM@SkillPosition?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CBFCHMIH@SkillID?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MKOJOKBN@SkillLv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KGPDILGI@m_lpQuestCntArray?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNPOCMEF@m_aCompleteQuest?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPOFAGJ@m_aCheckedQuest?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JCPOPMED@m_dwSMTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KFJOMEEC@SkillInfluence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DIMENFA@m_nNo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GAPLKBDN@Item_Name?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IOKBDDFK@Item_count?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@JLNDCIFJ@m_nAbilityOption?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JNKNAC@State?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PJIGDEIK@m_bItemResist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DKIALLAG@m_nResistAbilityOption?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOICAOCF@Remove?5NULL?5Item_Name?5?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DMKMHKMC@Remove?5Not?5Data?5State?5?3?5?$CFc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@EGBCIKAA@Not?5UnEquip?5?3?5?$CFs?0?5?$CFs?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@OFGDADEH@Not?5Inventory?5?3?5?$CFs?0?5?$CFs?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@MKOBOPPN@item?5not?5found?5?9?5bank?3?5?$CFs?0?5?$CFs?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@HEHGABA@item?5not?5found?5?9?5Pocket?3?5?$CFs?0?5?$CFs?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@JKMJFPOD@call?5BOOL?5CDbManager?3?3RemoveQues@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPPBFHPJ@removequest?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@EEGILGJF@fail?5to?5connect?3?5dsn?$DN?$CFs?0?5id?$DN?$CFs?0?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0HG@LPNEKFLC@SELECT?5m_idPlayer?0?5m_lpQuestCntA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GF@KIGMAII@SELECT?5m_idPlayer?0?5m_lpQuestCntA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PHPFGNFH@query?5error?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0JG@EPDAEJAA@UPDATE?5CHARACTER_TBL?5SET?5m_lpQue@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@JHIJALBF@query_removequest?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCBBBMFM@RemoveQuest?5complete?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0_GUILDQUEST@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@bad_weak_ptr@boost@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sp_counted_base@detail@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@sp_counted_base@detail@boost@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_copy@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_lock@sp_counted_base@detail@boost@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_add_ref@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@sp_counted_base@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gsp_counted_base@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@shared_count@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_weak_ptr@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_weak_ptr@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCooltime@CLordSkillComponent@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTick@CLordSkillComponent@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLordSkillComponentExecutable@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CLordSkillComponentExecutable@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Execute@CLordSkillComponentExecutable@@UAEXKKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLordSkillComponentExecutable@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDeposit@CCandidate@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVote@CCandidate@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCreate@CCandidate@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@HonorData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrTime@CDbManager@@AAEXPAVCTime@ATL@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDBFormatStr@CDbManager@@AAEXPADHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrFromDBFormat@CDbManager@@AAEXPADPBDAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPocket@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPiercingInfoFromMail@CDbManager@@QAEXPAVCQuery@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEquipment@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTaskBar@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCardCube@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseCharacter@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHonor@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkill@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetJobLv@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetQuest@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSMMode@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSKillInfluence@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOneSkill@CDbManager@@QAEXPAUtagSKILL@@PADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOneQuest@CDbManager@@QAEXPAUtagQuest@@PADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRemoveItem@CDbManager@@AAEHPAVCQuery@@AAHPAD1111AAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePenya@CDbManager@@AAEHPAVCQuery@@PADPAVCMover@@HHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItem@CDbManager@@AAEKPAVCQuery@@PADHPAVCMover@@1HHHHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItemInventory@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItemBank@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItemPocket@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAbnormalPlayerData@CDbManager@@AAEHPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NormalizePlayerData@CDbManager@@AAEHPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveQuest@CDbManager@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCQuery@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@?$MemPooler@VCGuildMember@@@@QAEPAVCGuildMember@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$MemPooler@VCGuildMember@@@@QAEHPAVCGuildMember@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@?$MemPooler@VCGuild@@@@QAEPAVCGuild@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$MemPooler@VCGuild@@@@QAEHPAVCGuild@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAU_PlayerData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAU_PlayerData@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@PAVsp_counted_base@detail@boost@@@std@@QBE_NABQAVsp_counted_base@detail@boost@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLordSkillComponentExecutable@@V?$allocator@PAVCLordSkillComponentExecutable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$shared_ptr@VCCandidate@@@boost@@V?$allocator@V?$shared_ptr@VCCandidate@@@boost@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$shared_ptr@VCCandidate@@@boost@@QBEPAVCCandidate@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLEComponent@@V?$allocator@PAVCLEComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@M_J@std@@V?$allocator@U?$pair@M_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@?$MemPooler@VCParty@@@@QAEPAVCParty@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$MemPooler@VCParty@@@@QAEHPAVCParty@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildWar@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildWar@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPADPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SafeStringLen@?$ChTraitsCRT@D@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$MemPooler@VCGuildMember@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$MemPooler@VCGuild@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$MemPooler@VCParty@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$throw_exception@Vbad_weak_ptr@boost@@@boost@@YAXABVbad_weak_ptr@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_weak_ptr@boost@@@8??0bad_weak_ptr@boost@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_weak_ptr@boost@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXViterator@12@ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QBEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@QAE@PAU012@0ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAX@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nextnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09PKKCPLIP@bad?5alloc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSerialNumber@CItemBase@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddGold@CMover@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetOption@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSerialNumberPaFromStr@@YAKPADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSerialNumber@CItemBase@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrPaFromStr@@YAXPAD0PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@CBuffMgr@@QAE_NPAVIBuff@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVIBuff@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBKPAVIBuff@@@std@@QAE@ABKABQAVIBuff@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetId@IBuff@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@IBuff@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLevel@IBuff@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetId@IBuff@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHonorCount@CMover@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetTutorialState@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExpInteger@CQuery@@QAE_JPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVisKeepTime@CItemElem@@QAEXHJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVisKeepTimeSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVisKeepTimeSize@CPiercing@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@J@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@J@std@@QAEPAJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@J@std@@YAPAJIPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@J@std@@QAEXPAJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsVisPet@ItemProp@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTransformVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUltimatePiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUltimatePiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsUltimate@ItemProp@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetExpirationDate@CPocket@@QAEXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetExpired@CPocket@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrFromStr@@YAXPAD0PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLife@CPet@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLevel@CPet@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetKind@CPet@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRandomOptItemId@CItemElem@@QAEX_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt64PaFromStr@@YA_JPADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIntPaFromStr@@YAHPADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIntFromStr@@YAHPADPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CLordSkillComponentExecutable@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_weak_ptr@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7sp_counted_base@detail@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __P$[esp-4]
  00004	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogty
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L39166

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L39166:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L211945:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z	; CDbManager::GetDBFormatStr
PUBLIC	??_C@_0CI@IEFGPJMF@GetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@ ; `string'
PUBLIC	??_C@_03BMNKJJEN@?$CF2X?$AA@			; `string'
EXTRN	_sscanf:NEAR
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0CI@IEFGPJMF@GetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	SEGMENT
??_C@_0CI@IEFGPJMF@GetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@ DB 'GetD'
	DB	'BFormatStr: nLen = %d, nMaxLen = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMNKJJEN@?$CF2X?$AA@
CONST	SEGMENT
??_C@_03BMNKJJEN@?$CF2X?$AA@ DB '%2X', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z
_TEXT	SEGMENT
_szDigit$ = -4						; size = 3
_szDst$ = 8						; size = 4
_nMaxLen$ = 12						; size = 4
_ch2$ = 16						; size = 4
_szSrc$ = 16						; size = 4
?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z PROC NEAR	; CDbManager::GetDBFormatStr, COMDAT
; _this$ = ecx

; 79   : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 80   : 	char szDigit[3] = {0, };
; 81   : #ifdef __VS2003
; 82   : 	int ch2;
; 83   : #else	// __VS2003
; 84   : 	char ch;
; 85   : #endif // __VS2003
; 86   : 	char* pCur	= const_cast<char*>( szSrc );

  00002	8b 74 24 14	 mov	 esi, DWORD PTR _szSrc$[esp+4]

; 87   : 	int nLen	= strlen( pCur );

  00006	8b c6		 mov	 eax, esi
  00008	c6 44 24 04 00	 mov	 BYTE PTR _szDigit$[esp+8], 0
  0000d	66 c7 44 24 05
	00 00		 mov	 WORD PTR _szDigit$[esp+9], 0
  00014	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L211950:
  00017	8a 08		 mov	 cl, BYTE PTR [eax]
  00019	40		 inc	 eax
  0001a	84 c9		 test	 cl, cl
  0001c	75 f9		 jne	 SHORT $L211950
  0001e	2b c2		 sub	 eax, edx

; 88   : 	if( nLen % 2 != 0 )

  00020	8b c8		 mov	 ecx, eax
  00022	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  00028	79 05		 jns	 SHORT $L211952
  0002a	49		 dec	 ecx
  0002b	83 c9 fe	 or	 ecx, -2			; fffffffeH
  0002e	41		 inc	 ecx
$L211952:
  0002f	74 06		 je	 SHORT $L208588

; 89   : 	{
; 90   : 		pCur[nLen-1]	= '\0';

  00031	c6 44 30 ff 00	 mov	 BYTE PTR [eax+esi-1], 0

; 91   : 		nLen--;

  00036	48		 dec	 eax
$L208588:

; 92   : 	}
; 93   : 	if( nLen >= nMaxLen * 2 )

  00037	8b 4c 24 10	 mov	 ecx, DWORD PTR _nMaxLen$[esp+4]
  0003b	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  0003e	3b c2		 cmp	 eax, edx
  00040	7c 1b		 jl	 SHORT $L211948

; 94   : 	{
; 95   : 		Error( "GetDBFormatStr: nLen = %d, nMaxLen = %d", nLen, nMaxLen );

  00042	51		 push	 ecx
  00043	50		 push	 eax
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@IEFGPJMF@GetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@
  00049	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 96   : 		*szDst	= '\0';

  0004e	8b 44 24 18	 mov	 eax, DWORD PTR _szDst$[esp+16]
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	c6 00 00	 mov	 BYTE PTR [eax], 0
  00058	5e		 pop	 esi

; 113  : }

  00059	59		 pop	 ecx
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$L211948:

; 97   : 		return;
; 98   : 	}
; 99   : 	while( *pCur )

  0005d	8a 06		 mov	 al, BYTE PTR [esi]
  0005f	84 c0		 test	 al, al
  00061	57		 push	 edi
  00062	8b 7c 24 10	 mov	 edi, DWORD PTR _szDst$[esp+8]
  00066	74 32		 je	 SHORT $L208593
$L208592:

; 100  : 	{
; 101  : 		szDigit[0]	= pCur[0];
; 102  : 		szDigit[1]	= pCur[1];

  00068	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]

; 103  : 		pCur	+= 2;
; 104  : #ifdef __VS2003
; 105  : 		sscanf( szDigit, "%2X", &ch2 );

  0006b	8d 54 24 18	 lea	 edx, DWORD PTR _ch2$[esp+8]
  0006f	52		 push	 edx
  00070	88 44 24 0c	 mov	 BYTE PTR _szDigit$[esp+16], al
  00074	8d 44 24 0c	 lea	 eax, DWORD PTR _szDigit$[esp+16]
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BMNKJJEN@?$CF2X?$AA@
  0007d	50		 push	 eax
  0007e	88 4c 24 15	 mov	 BYTE PTR _szDigit$[esp+25], cl
  00082	83 c6 02	 add	 esi, 2
  00085	e8 00 00 00 00	 call	 _sscanf

; 106  : 		*szDst++	= ch2;

  0008a	8a 4c 24 24	 mov	 cl, BYTE PTR _ch2$[esp+20]
  0008e	88 0f		 mov	 BYTE PTR [edi], cl
  00090	8a 06		 mov	 al, BYTE PTR [esi]
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	47		 inc	 edi
  00096	84 c0		 test	 al, al
  00098	75 ce		 jne	 SHORT $L208592
$L208593:

; 107  : #else // __VS2003
; 108  : 		sscanf( szDigit, "%2X", &ch );
; 109  : 		*szDst++	= ch;
; 110  : #endif // __VS2003
; 111  : 	}
; 112  : 	*szDst	= '\0';

  0009a	c6 07 00	 mov	 BYTE PTR [edi], 0
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi

; 113  : }

  0009f	59		 pop	 ecx
  000a0	c2 0c 00	 ret	 12			; 0000000cH
?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z ENDP		; CDbManager::GetDBFormatStr
_TEXT	ENDS
PUBLIC	?SetDBFormatStr@CDbManager@@AAEXPADHPBD@Z	; CDbManager::SetDBFormatStr
PUBLIC	??_C@_0CI@KADALJOE@SetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@ ; `string'
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_0CI@KADALJOE@SetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@
CONST	SEGMENT
??_C@_0CI@KADALJOE@SetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@ DB 'SetD'
	DB	'BFormatStr: nLen = %d, nMaxLen = %d', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetDBFormatStr@CDbManager@@AAEXPADHPBD@Z
_TEXT	SEGMENT
_szDst$ = 8						; size = 4
_nMaxLen$ = 12						; size = 4
_szSrc$ = 16						; size = 4
?SetDBFormatStr@CDbManager@@AAEXPADHPBD@Z PROC NEAR	; CDbManager::SetDBFormatStr, COMDAT
; _this$ = ecx

; 116  : {

  00000	57		 push	 edi

; 117  : 	int nLen	= strlen( szSrc );

  00001	8b 7c 24 10	 mov	 edi, DWORD PTR _szSrc$[esp]
  00005	8b c7		 mov	 eax, edi
  00007	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000a	8d 9b 00 00 00
	00		 npad	 6
$L211957:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L211957

; 118  : 	if( nMaxLen < nLen * 2 + 1 )

  00017	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMaxLen$[esp]
  0001b	2b c2		 sub	 eax, edx
  0001d	8d 54 00 01	 lea	 edx, DWORD PTR [eax+eax+1]
  00021	3b ca		 cmp	 ecx, edx
  00023	7d 1a		 jge	 SHORT $L208602

; 119  : 	{
; 120  : 		Error( "SetDBFormatStr: nLen = %d, nMaxLen = %d", nLen, nMaxLen );

  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@KADALJOE@SetDBFormatStr?3?5nLen?5?$DN?5?$CFd?0?5nMaxL@
  0002c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 121  : 		*szDst	= '\0';

  00031	8b 44 24 14	 mov	 eax, DWORD PTR _szDst$[esp+12]
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003b	5f		 pop	 edi

; 133  : }

  0003c	c2 0c 00	 ret	 12			; 0000000cH
$L208602:

; 122  : 		return;
; 123  : 	}
; 124  : 
; 125  : 	char* pCur	= szDst;
; 126  : 	while( *szSrc )

  0003f	8a 07		 mov	 al, BYTE PTR [edi]
  00041	84 c0		 test	 al, al
  00043	56		 push	 esi
  00044	8b 74 24 0c	 mov	 esi, DWORD PTR _szDst$[esp+4]
  00048	74 23		 je	 SHORT $L208607
  0004a	8d 9b 00 00 00
	00		 npad	 6
$L208606:

; 127  : 	{
; 128  : 		sprintf( pCur, "%2X",  (BYTE)*szSrc );

  00050	0f b6 c8	 movzx	 ecx, al
  00053	51		 push	 ecx
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BMNKJJEN@?$CF2X?$AA@
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 _sprintf
  0005f	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 129  : 		pCur	+= 2;

  00065	83 c6 02	 add	 esi, 2

; 130  : 		szSrc++;

  00068	47		 inc	 edi
  00069	84 c0		 test	 al, al
  0006b	75 e3		 jne	 SHORT $L208606
$L208607:

; 131  : 	}
; 132  : 	*pCur	= '\0';

  0006d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00070	5e		 pop	 esi
  00071	5f		 pop	 edi

; 133  : }

  00072	c2 0c 00	 ret	 12			; 0000000cH
?SetDBFormatStr@CDbManager@@AAEXPADHPBD@Z ENDP		; CDbManager::SetDBFormatStr
_TEXT	ENDS
PUBLIC	?GetStrFromDBFormat@CDbManager@@AAEXPADPBDAAH@Z	; CDbManager::GetStrFromDBFormat
; Function compile flags: /Ogty
;	COMDAT ?GetStrFromDBFormat@CDbManager@@AAEXPADPBDAAH@Z
_TEXT	SEGMENT
_szDigit$ = -4						; size = 3
_ch2$ = 8						; size = 4
_szDst$ = 8						; size = 4
_szSrc$ = 12						; size = 4
_n$ = 16						; size = 4
?GetStrFromDBFormat@CDbManager@@AAEXPADPBDAAH@Z PROC NEAR ; CDbManager::GetStrFromDBFormat, COMDAT
; _this$ = ecx

; 139  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 140  : 	char szDigit[3] = {0, };
; 141  : 	char ch;
; 142  : #ifdef __VS2003
; 143  : 	int ch2;
; 144  : #endif // __VS2003
; 145  : 	
; 146  : 	const char* pCur = szSrc + n;

  00002	8b 5c 24 10	 mov	 ebx, DWORD PTR _szSrc$[esp+4]
  00006	55		 push	 ebp
  00007	8b 6c 24 18	 mov	 ebp, DWORD PTR _n$[esp+8]
  0000b	56		 push	 esi
  0000c	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  0000f	03 f3		 add	 esi, ebx
  00011	c6 44 24 0c 00	 mov	 BYTE PTR _szDigit$[esp+16], 0
  00016	66 c7 44 24 0d
	00 00		 mov	 WORD PTR _szDigit$[esp+17], 0

; 147  : 	while( *pCur != '/' && *pCur )		//  '/'  .  NULL  

  0001d	8a 06		 mov	 al, BYTE PTR [esi]
  0001f	3c 2f		 cmp	 al, 47			; 0000002fH
  00021	57		 push	 edi
  00022	8b 7c 24 18	 mov	 edi, DWORD PTR _szDst$[esp+16]
  00026	74 36		 je	 SHORT $L208621
$L208620:
  00028	84 c0		 test	 al, al
  0002a	74 32		 je	 SHORT $L208621

; 148  : 	{
; 149  : 		szDigit[0] = pCur[0];
; 150  : 		szDigit[1] = pCur[1];
; 151  : 		pCur += 2;
; 152  : 		
; 153  : #ifdef __VS2003
; 154  : 		sscanf( szDigit, "%2X", &ch2 );

  0002c	8d 4c 24 18	 lea	 ecx, DWORD PTR _ch2$[esp+16]
  00030	51		 push	 ecx
  00031	88 44 24 14	 mov	 BYTE PTR _szDigit$[esp+24], al
  00035	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00038	8d 54 24 14	 lea	 edx, DWORD PTR _szDigit$[esp+24]
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BMNKJJEN@?$CF2X?$AA@
  00041	52		 push	 edx
  00042	88 44 24 1d	 mov	 BYTE PTR _szDigit$[esp+33], al
  00046	83 c6 02	 add	 esi, 2
  00049	e8 00 00 00 00	 call	 _sscanf

; 155  : 		ch = ch2;
; 156  : #else // __VS2003
; 157  : 		sscanf( szDigit, "%2X", &ch );
; 158  : #endif // __VS2003
; 159  : 		*szDst++ = ch;

  0004e	8a 44 24 24	 mov	 al, BYTE PTR _ch2$[esp+28]
  00052	88 07		 mov	 BYTE PTR [edi], al
  00054	8a 06		 mov	 al, BYTE PTR [esi]
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	47		 inc	 edi
  0005a	3c 2f		 cmp	 al, 47			; 0000002fH
  0005c	75 ca		 jne	 SHORT $L208620
$L208621:

; 160  : 	}
; 161  : 	*szDst = '\0';
; 162  : 	n = (pCur - szSrc) + 1;				// +1 '/'   

  0005e	2b f3		 sub	 esi, ebx
  00060	c6 07 00	 mov	 BYTE PTR [edi], 0
  00063	46		 inc	 esi
  00064	5f		 pop	 edi
  00065	89 75 00	 mov	 DWORD PTR [ebp], esi
  00068	5e		 pop	 esi
  00069	5d		 pop	 ebp
  0006a	5b		 pop	 ebx

; 163  : }

  0006b	59		 pop	 ecx
  0006c	c2 0c 00	 ret	 12			; 0000000cH
?GetStrFromDBFormat@CDbManager@@AAEXPADPBDAAH@Z ENDP	; CDbManager::GetStrFromDBFormat
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@HHHHHHH@Z			; ATL::CTime::CTime
EXTRN	__mktime64:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT
_atm$ = -36						; size = 36
_nYear$ = 8						; size = 4
_nMonth$ = 12						; size = 4
_nDay$ = 16						; size = 4
_nHour$ = 20						; size = 4
_nMin$ = 24						; size = 4
_nSec$ = 28						; size = 4
_nDST$ = 32						; size = 4
??0CTime@ATL@@QAE@HHHHHHH@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 172  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H

; 173  : 	struct tm atm;
; 174  : 	atm.tm_sec = nSec;

  00003	8b 44 24 3c	 mov	 eax, DWORD PTR _nSec$[esp+32]

; 175  : 	atm.tm_min = nMin;
; 176  : 	atm.tm_hour = nHour;

  00007	8b 54 24 34	 mov	 edx, DWORD PTR _nHour$[esp+32]
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _nMin$[esp+36]
  00012	89 4c 24 08	 mov	 DWORD PTR _atm$[esp+44], ecx

; 177  : 	ATLASSERT(nDay >= 1 && nDay <= 31);
; 178  : 	atm.tm_mday = nDay;
; 179  : 	ATLASSERT(nMonth >= 1 && nMonth <= 12);
; 180  : 	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based

  00016	8b 4c 24 30	 mov	 ecx, DWORD PTR _nMonth$[esp+36]
  0001a	89 44 24 04	 mov	 DWORD PTR _atm$[esp+40], eax
  0001e	8b 44 24 34	 mov	 eax, DWORD PTR _nDay$[esp+36]
  00022	49		 dec	 ecx
  00023	89 54 24 0c	 mov	 DWORD PTR _atm$[esp+48], edx

; 181  : 	ATLASSERT(nYear >= 1900);
; 182  : 	atm.tm_year = nYear - 1900;     // tm_year is 1900 based

  00027	8b 54 24 2c	 mov	 edx, DWORD PTR _nYear$[esp+36]
  0002b	89 4c 24 14	 mov	 DWORD PTR _atm$[esp+56], ecx
  0002f	89 44 24 10	 mov	 DWORD PTR _atm$[esp+52], eax

; 183  : 	atm.tm_isdst = nDST;

  00033	8b 44 24 44	 mov	 eax, DWORD PTR _nDST$[esp+36]

; 184  : 	m_time = _mktime64(&atm);

  00037	8d 4c 24 04	 lea	 ecx, DWORD PTR _atm$[esp+40]
  0003b	81 c2 94 f8 ff
	ff		 add	 edx, -1900		; fffff894H
  00041	51		 push	 ecx
  00042	89 54 24 1c	 mov	 DWORD PTR _atm$[esp+64], edx
  00046	89 44 24 28	 mov	 DWORD PTR _atm$[esp+76], eax
  0004a	e8 00 00 00 00	 call	 __mktime64
  0004f	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 185  : 	ATLASSERT(m_time != -1);       // indicates an illegal input time
; 186  : 	
; 187  : 	if(m_time == -1)

  00052	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00055	8b d0		 mov	 edx, eax
  00057	23 d1		 and	 edx, ecx
  00059	83 c4 04	 add	 esp, 4
  0005c	83 fa ff	 cmp	 edx, -1
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	75 0a		 jne	 SHORT $L42610

; 188  : 		AtlThrow(E_INVALIDARG);

  00063	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00068	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L42610:

; 189  : }

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	83 c4 24	 add	 esp, 36			; 00000024H
  00073	c2 1c 00	 ret	 28			; 0000001cH
$L211965:
??0CTime@ATL@@QAE@HHHHHHH@Z ENDP			; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	?GetCardCube@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetCardCube
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
;	COMDAT ?GetCardCube@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetCardCube@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetCardCube, COMDAT
; _this$ = ecx

; 1021 : }

  00000	c2 0c 00	 ret	 12			; 0000000cH
?GetCardCube@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetCardCube
_TEXT	ENDS
PUBLIC	??_C@_0CE@IGLOLMFD@uspLoadCharacterSkill?5?8?$CF02d?8?0?8?$CF0@ ; `string'
PUBLIC	??_C@_0O@MDJBOIOM@SkillPosition?$AA@		; `string'
PUBLIC	??_C@_07CBFCHMIH@SkillID?$AA@			; `string'
PUBLIC	??_C@_07MKOJOKBN@SkillLv?$AA@			; `string'
PUBLIC	??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@	; `string'
PUBLIC	??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@ ; `string'
PUBLIC	?GetSkill@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetSkill
EXTRN	__chkstk:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	?Exec@CQuery@@QAEHPBD@Z:NEAR			; CQuery::Exec
EXTRN	?Fetch@CQuery@@QAEHXZ:NEAR			; CQuery::Fetch
EXTRN	?WriteLog@@YAXPBDZZ:NEAR			; WriteLog
EXTRN	?GetInt@CQuery@@QAEHPAD@Z:NEAR			; CQuery::GetInt
EXTRN	?g_appInfo@@3UAppInfo@@A:QWORD			; g_appInfo
;	COMDAT ??_C@_0CE@IGLOLMFD@uspLoadCharacterSkill?5?8?$CF02d?8?0?8?$CF0@
CONST	SEGMENT
??_C@_0CE@IGLOLMFD@uspLoadCharacterSkill?5?8?$CF02d?8?0?8?$CF0@ DB 'uspLo'
	DB	'adCharacterSkill ''%02d'',''%07d''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
CONST	SEGMENT
??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@ DB '\Documents '
	DB	'and Settings\test\Mes documents\Source\Virtuos_v17\Build\Prog'
	DB	'ram\_Database\DbManagerFun.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
CONST	SEGMENT
??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@ DB '%s, %d', 09H, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MDJBOIOM@SkillPosition?$AA@
CONST	SEGMENT
??_C@_0O@MDJBOIOM@SkillPosition?$AA@ DB 'SkillPosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBFCHMIH@SkillID?$AA@
CONST	SEGMENT
??_C@_07CBFCHMIH@SkillID?$AA@ DB 'SkillID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKOJOKBN@SkillLv?$AA@
CONST	SEGMENT
??_C@_07MKOJOKBN@SkillLv?$AA@ DB 'SkillLv', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetSkill@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_BufSkill$209369 = -40976				; size = 8
_szQuery$ = -40968					; size = 40960
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetSkill@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetSkill, COMDAT
; _this$ = ecx

; 1212 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 14 a0 00 00	 mov	 eax, 40980		; 0000a014H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _pMover$[ebp]
  00019	33 c5		 xor	 eax, ebp
  0001b	56		 push	 esi
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _qry$[ebp]
  0001f	57		 push	 edi
  00020	89 84 24 1c a0
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+40992], eax

; 1213 : 	//     
; 1214 : 	char szQuery[QUERY_SIZE]	= { 0,};

  00027	33 c0		 xor	 eax, eax
  00029	c6 44 24 18 00	 mov	 BYTE PTR _szQuery$[esp+40992], 0
  0002e	b9 ff 27 00 00	 mov	 ecx, 10239		; 000027ffH
  00033	8d 7c 24 19	 lea	 edi, DWORD PTR _szQuery$[esp+40993]
  00037	f3 ab		 rep stosd

; 1215 : 	sprintf( szQuery,
; 1216 : 		"uspLoadCharacterSkill '%02d','%07d'",
; 1217 : 		g_appInfo.dwSys, pMover->m_idPlayer );

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  0003f	66 ab		 stosw
  00041	aa		 stosb
  00042	8b 83 90 00 00
	00		 mov	 eax, DWORD PTR [ebx+144]
  00048	50		 push	 eax
  00049	51		 push	 ecx
  0004a	8d 54 24 20	 lea	 edx, DWORD PTR _szQuery$[esp+41000]
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@IGLOLMFD@uspLoadCharacterSkill?5?8?$CF02d?8?0?8?$CF0@
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _sprintf
  00059	83 c4 10	 add	 esp, 16			; 00000010H

; 1218 : 	if( FALSE == qry->Exec( szQuery ) )

  0005c	8d 44 24 18	 lea	 eax, DWORD PTR _szQuery$[esp+40992]
  00060	50		 push	 eax
  00061	8b ce		 mov	 ecx, esi
  00063	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00068	85 c0		 test	 eax, eax
  0006a	75 35		 jne	 SHORT $L211973

; 1219 : 	{
; 1220 : 		WriteLog( "%s, %d\t%s", __FILE__, __LINE__, szQuery );

  0006c	8d 4c 24 18	 lea	 ecx, DWORD PTR _szQuery$[esp+40992]
  00070	51		 push	 ecx
  00071	68 c4 04 00 00	 push	 1220			; 000004c4H
  00076	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  00080	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00085	83 c4 10	 add	 esp, 16			; 00000010H

; 1221 : 		return FALSE;

  00088	33 c0		 xor	 eax, eax

; 1232 : 	}
; 1233 : 	return TRUE;
; 1234 : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b 8c 24 10 a0
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40980]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 0c 00	 ret	 12			; 0000000cH
$L211973:

; 1222 : 	}
; 1223 : 	
; 1224 : 	while( qry->Fetch() )

  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  000a8	85 c0		 test	 eax, eax
  000aa	74 4b		 je	 SHORT $L209368
  000ac	8d 64 24 00	 npad	 4
$L209367:

; 1225 : 	{
; 1226 : 		SKILL BufSkill;
; 1227 : 		DWORD dwSkillPosition;
; 1228 : 		dwSkillPosition = (DWORD)qry->GetInt( "SkillPosition" );

  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@MDJBOIOM@SkillPosition?$AA@
  000b5	8b ce		 mov	 ecx, esi
  000b7	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1229 : 		BufSkill.dwSkill = (DWORD)qry->GetInt( "SkillID" );

  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07CBFCHMIH@SkillID?$AA@
  000c1	8b ce		 mov	 ecx, esi
  000c3	8b f8		 mov	 edi, eax
  000c5	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1230 : 		BufSkill.dwLevel = (DWORD)qry->GetInt( "SkillLv" );

  000ca	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07MKOJOKBN@SkillLv?$AA@
  000cf	8b ce		 mov	 ecx, esi
  000d1	89 44 24 14	 mov	 DWORD PTR _BufSkill$209369[esp+40996], eax
  000d5	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1231 : 		pMover->m_aJobSkill[dwSkillPosition] = BufSkill;

  000da	8b 54 24 10	 mov	 edx, DWORD PTR _BufSkill$209369[esp+40992]
  000de	8b ce		 mov	 ecx, esi
  000e0	89 94 fb 00 01
	00 00		 mov	 DWORD PTR [ebx+edi*8+256], edx
  000e7	89 84 fb 04 01
	00 00		 mov	 DWORD PTR [ebx+edi*8+260], eax
  000ee	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  000f3	85 c0		 test	 eax, eax
  000f5	75 b9		 jne	 SHORT $L209367
$L209368:

; 1232 : 	}
; 1233 : 	return TRUE;
; 1234 : }

  000f7	8b 8c 24 1c a0
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40992]
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	33 cd		 xor	 ecx, ebp
  00102	b8 01 00 00 00	 mov	 eax, 1
  00107	5b		 pop	 ebx
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 0c 00	 ret	 12			; 0000000cH
?GetSkill@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetSkill
_TEXT	ENDS
PUBLIC	?GetJobLv@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetJobLv
; Function compile flags: /Ogty
;	COMDAT ?GetJobLv@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetJobLv@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetJobLv, COMDAT
; _this$ = ecx

; 1238 : }

  00000	c2 0c 00	 ret	 12			; 0000000cH
?GetJobLv@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetJobLv
_TEXT	ENDS
PUBLIC	?GetRemoveItem@CDbManager@@AAEHPAVCQuery@@AAHPAD1111AAD@Z ; CDbManager::GetRemoveItem
PUBLIC	??_C@_04HIBGFPH@NULL?$AA@			; `string'
PUBLIC	??_C@_05DIMENFA@m_nNo?$AA@			; `string'
PUBLIC	??_C@_09GAPLKBDN@Item_Name?$AA@			; `string'
PUBLIC	??_C@_0L@IOKBDDFK@Item_count?$AA@		; `string'
PUBLIC	??_C@_0BB@JLNDCIFJ@m_nAbilityOption?$AA@	; `string'
PUBLIC	??_C@_05JNKNAC@State?$AA@			; `string'
PUBLIC	??_C@_0O@PJIGDEIK@m_bItemResist?$AA@		; `string'
PUBLIC	??_C@_0BH@DKIALLAG@m_nResistAbilityOption?$AA@	; `string'
PUBLIC	??_C@_0BL@GOICAOCF@Remove?5NULL?5Item_Name?5?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BL@DMKMHKMC@Remove?5Not?5Data?5State?5?3?5?$CFc?$AA@ ; `string'
EXTRN	?GetChar@CQuery@@QAEDPAD@Z:NEAR			; CQuery::GetChar
EXTRN	?GetStr@CQuery@@QAEXPAD0@Z:NEAR			; CQuery::GetStr
;	COMDAT ??_C@_05DIMENFA@m_nNo?$AA@
CONST	SEGMENT
??_C@_05DIMENFA@m_nNo?$AA@ DB 'm_nNo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GAPLKBDN@Item_Name?$AA@
CONST	SEGMENT
??_C@_09GAPLKBDN@Item_Name?$AA@ DB 'Item_Name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IOKBDDFK@Item_count?$AA@
CONST	SEGMENT
??_C@_0L@IOKBDDFK@Item_count?$AA@ DB 'Item_count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JLNDCIFJ@m_nAbilityOption?$AA@
CONST	SEGMENT
??_C@_0BB@JLNDCIFJ@m_nAbilityOption?$AA@ DB 'm_nAbilityOption', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JNKNAC@State?$AA@
CONST	SEGMENT
??_C@_05JNKNAC@State?$AA@ DB 'State', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PJIGDEIK@m_bItemResist?$AA@
CONST	SEGMENT
??_C@_0O@PJIGDEIK@m_bItemResist?$AA@ DB 'm_bItemResist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DKIALLAG@m_nResistAbilityOption?$AA@
CONST	SEGMENT
??_C@_0BH@DKIALLAG@m_nResistAbilityOption?$AA@ DB 'm_nResistAbilityOption'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL?$AA@ DB 'NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOICAOCF@Remove?5NULL?5Item_Name?5?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@GOICAOCF@Remove?5NULL?5Item_Name?5?3?5?$CFs?$AA@ DB 'Remove NUL'
	DB	'L Item_Name : %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DMKMHKMC@Remove?5Not?5Data?5State?5?3?5?$CFc?$AA@
CONST	SEGMENT
??_C@_0BL@DMKMHKMC@Remove?5Not?5Data?5State?5?3?5?$CFc?$AA@ DB 'Remove No'
	DB	't Data State : %c', 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetRemoveItem@CDbManager@@AAEHPAVCQuery@@AAHPAD1111AAD@Z
_TEXT	SEGMENT
_pQry$ = 8						; size = 4
_nNo$ = 12						; size = 4
_pOneItem$ = 16						; size = 4
_nItem_Count$ = 20					; size = 4
_nAbilityOption$ = 24					; size = 4
_nItemResist$ = 28					; size = 4
_nResistAbilityOption$ = 32				; size = 4
_chState$ = 36						; size = 4
?GetRemoveItem@CDbManager@@AAEHPAVCQuery@@AAHPAD1111AAD@Z PROC NEAR ; CDbManager::GetRemoveItem, COMDAT
; _this$ = ecx

; 1506 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 1507 : 	nNo = pQry->GetInt( "m_nNo" );									//  

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _pQry$[esp+8]
  00007	57		 push	 edi
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DIMENFA@m_nNo?$AA@
  0000d	8b ce		 mov	 ecx, esi
  0000f	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00014	8b 4c 24 18	 mov	 ecx, DWORD PTR _nNo$[esp+12]

; 1508 : 	pQry->GetStr( "Item_Name", pOneItem );							// 

  00018	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pOneItem$[esp+12]
  0001c	53		 push	 ebx
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GAPLKBDN@Item_Name?$AA@
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1509 : 	
; 1510 : 	nItem_Count	= pQry->GetInt( "Item_count" );						// 

  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@IOKBDDFK@Item_count?$AA@
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00037	8b 6c 24 20	 mov	 ebp, DWORD PTR _nItem_Count$[esp+12]

; 1511 : 	nAbilityOption = pQry->GetInt( "m_nAbilityOption" );			// AbilityOption ( + ) Option

  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@JLNDCIFJ@m_nAbilityOption?$AA@
  00040	8b ce		 mov	 ecx, esi
  00042	89 45 00	 mov	 DWORD PTR [ebp], eax
  00045	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  0004a	8b 54 24 24	 mov	 edx, DWORD PTR _nAbilityOption$[esp+12]

; 1512 : 	chState = pQry->GetChar( "State" );

  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05JNKNAC@State?$AA@
  00053	8b ce		 mov	 ecx, esi
  00055	89 02		 mov	 DWORD PTR [edx], eax
  00057	e8 00 00 00 00	 call	 ?GetChar@CQuery@@QAEDPAD@Z ; CQuery::GetChar
  0005c	8b 4c 24 30	 mov	 ecx, DWORD PTR _chState$[esp+12]
  00060	88 01		 mov	 BYTE PTR [ecx], al

; 1513 : 	nItemResist = pQry->GetInt( "m_bItemResist" );					// 	

  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@PJIGDEIK@m_bItemResist?$AA@
  00067	8b ce		 mov	 ecx, esi
  00069	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  0006e	8b 54 24 28	 mov	 edx, DWORD PTR _nItemResist$[esp+12]

; 1514 : 	nResistAbilityOption = pQry->GetInt( "m_nResistAbilityOption" );//   Option

  00072	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@DKIALLAG@m_nResistAbilityOption?$AA@
  00077	8b ce		 mov	 ecx, esi
  00079	89 02		 mov	 DWORD PTR [edx], eax
  0007b	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00080	8b 54 24 2c	 mov	 edx, DWORD PTR _nResistAbilityOption$[esp+12]
  00084	89 02		 mov	 DWORD PTR [edx], eax

; 1515 : 	
; 1516 : 	if( 0 == strcmp( pOneItem, "NULL") )

  00086	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_04HIBGFPH@NULL?$AA@
  0008b	8b f3		 mov	 esi, ebx
  0008d	b9 05 00 00 00	 mov	 ecx, 5
  00092	33 c0		 xor	 eax, eax
  00094	f3 a6		 repe cmpsb
  00096	74 05		 je	 SHORT $L211982
  00098	1b c0		 sbb	 eax, eax
  0009a	83 d8 ff	 sbb	 eax, -1
$L211982:
  0009d	85 c0		 test	 eax, eax
  0009f	75 17		 jne	 SHORT $L209570

; 1517 : 	{
; 1518 : 		WriteLog( "Remove NULL Item_Name : %s", pOneItem );

  000a1	53		 push	 ebx
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@GOICAOCF@Remove?5NULL?5Item_Name?5?3?5?$CFs?$AA@
  000a7	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  000ac	83 c4 08	 add	 esp, 8
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5d		 pop	 ebp

; 1519 : 		return FALSE;

  000b2	33 c0		 xor	 eax, eax
  000b4	5b		 pop	 ebx

; 1547 : }

  000b5	c2 20 00	 ret	 32			; 00000020H
$L209570:

; 1520 : 	}
; 1521 : 
; 1522 : 	if( chState != 'I' && chState != 'B'
; 1523 : #ifdef __REMOVEITEM_POCKET
; 1524 : 		&& chState != 'P'
; 1525 : #endif // __REMOVEITEM_POCKET
; 1526 : 		)

  000b8	8b 44 24 30	 mov	 eax, DWORD PTR _chState$[esp+12]
  000bc	8a 00		 mov	 al, BYTE PTR [eax]
  000be	3c 49		 cmp	 al, 73			; 00000049H
  000c0	74 22		 je	 SHORT $L209572
  000c2	3c 42		 cmp	 al, 66			; 00000042H
  000c4	74 1e		 je	 SHORT $L209572
  000c6	3c 50		 cmp	 al, 80			; 00000050H
  000c8	74 1a		 je	 SHORT $L209572

; 1527 : 	{
; 1528 : 		WriteLog( "Remove Not Data State : %c", chState );

  000ca	0f be c8	 movsx	 ecx, al
  000cd	51		 push	 ecx
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@DMKMHKMC@Remove?5Not?5Data?5State?5?3?5?$CFc?$AA@
  000d3	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  000d8	83 c4 08	 add	 esp, 8
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5d		 pop	 ebp

; 1529 : 		return FALSE;

  000de	33 c0		 xor	 eax, eax
  000e0	5b		 pop	 ebx

; 1547 : }

  000e1	c2 20 00	 ret	 32			; 00000020H
$L209572:

; 1530 : 	}
; 1531 : 
; 1532 : 	
; 1533 : 	if( nItem_Count == -100 || nItem_Count == 0 )

  000e4	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000e7	83 f8 9c	 cmp	 eax, -100		; ffffff9cH
  000ea	74 04		 je	 SHORT $L209575
  000ec	85 c0		 test	 eax, eax
  000ee	75 07		 jne	 SHORT $L209574
$L209575:

; 1534 : 		nItem_Count = 1;

  000f0	c7 45 00 01 00
	00 00		 mov	 DWORD PTR [ebp], 1
$L209574:

; 1535 : 	
; 1536 : 	if( nAbilityOption == -100 )

  000f7	8b 44 24 24	 mov	 eax, DWORD PTR _nAbilityOption$[esp+12]
  000fb	83 38 9c	 cmp	 DWORD PTR [eax], -100	; ffffff9cH
  000fe	75 06		 jne	 SHORT $L209576

; 1537 : 		nAbilityOption = 0;

  00100	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L209576:

; 1538 : 	
; 1539 : 	if( nItemResist == -100 )

  00106	8b 44 24 28	 mov	 eax, DWORD PTR _nItemResist$[esp+12]
  0010a	83 38 9c	 cmp	 DWORD PTR [eax], -100	; ffffff9cH
  0010d	75 06		 jne	 SHORT $L209577

; 1540 : 		nItemResist = 0;

  0010f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L209577:

; 1541 : 	
; 1542 : 	if( nResistAbilityOption == -100 )

  00115	83 3a 9c	 cmp	 DWORD PTR [edx], -100	; ffffff9cH
  00118	75 06		 jne	 SHORT $L209578

; 1543 : 		nResistAbilityOption = 0;

  0011a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L209578:
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5d		 pop	 ebp

; 1544 : 
; 1545 : 	
; 1546 : 	return TRUE;

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	5b		 pop	 ebx

; 1547 : }

  00129	c2 20 00	 ret	 32			; 00000020H
?GetRemoveItem@CDbManager@@AAEHPAVCQuery@@AAHPAD1111AAD@Z ENDP ; CDbManager::GetRemoveItem
_TEXT	ENDS
PUBLIC	?NormalizePlayerData@CDbManager@@AAEHPAVCMover@@@Z ; CDbManager::NormalizePlayerData
; Function compile flags: /Ogty
;	COMDAT ?NormalizePlayerData@CDbManager@@AAEHPAVCMover@@@Z
_TEXT	SEGMENT
_nNumberofIndex$ = -128					; size = 4
_adwEquipment$ = -124					; size = 124
_pMover$ = 8						; size = 4
?NormalizePlayerData@CDbManager@@AAEHPAVCMover@@@Z PROC NEAR ; CDbManager::NormalizePlayerData, COMDAT
; _this$ = ecx

; 1764 : {

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	53		 push	 ebx
  00007	55		 push	 ebp

; 1765 : 	int nMax	= pMover->m_Inventory.m_dwItemMax;

  00008	8b ac 24 8c 00
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+132]
  0000f	8b 95 24 41 00
	00		 mov	 edx, DWORD PTR [ebp+16676]

; 1766 : 	int nNumberofIndex	= pMover->m_Inventory.m_dwIndexNum;

  00015	8b 85 1c 41 00
	00		 mov	 eax, DWORD PTR [ebp+16668]
  0001b	56		 push	 esi

; 1767 : 	DWORD dwId;
; 1768 : 	for( int i = 0; i < nMax; i++ )

  0001c	33 f6		 xor	 esi, esi
  0001e	85 d2		 test	 edx, edx
  00020	57		 push	 edi
  00021	89 44 24 10	 mov	 DWORD PTR _nNumberofIndex$[esp+144], eax
  00025	0f 8e a9 00 00
	00		 jle	 $L209724
  0002b	eb 03 8d 49 00	 npad	 5
$L209722:
  00030	8b 8d 18 41 00
	00		 mov	 ecx, DWORD PTR [ebp+16664]

; 1769 : 	{
; 1770 : 		dwId	= pMover->m_Inventory.m_apIndex[i];

  00036	8b 04 b1	 mov	 eax, DWORD PTR [ecx+esi*4]

; 1771 : 		if( dwId != NULL_ID )

  00039	83 f8 ff	 cmp	 eax, -1
  0003c	8d 1c b1	 lea	 ebx, DWORD PTR [ecx+esi*4]
  0003f	0f 84 86 00 00
	00		 je	 $L209723

; 1772 : 		{
; 1773 : 			if( pMover->m_Inventory.m_apItem[dwId].m_dwObjIndex != i )

  00045	8b ad 20 41 00
	00		 mov	 ebp, DWORD PTR [ebp+16672]
  0004b	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0004e	c1 e0 05	 shl	 eax, 5
  00051	39 74 28 2c	 cmp	 DWORD PTR [eax+ebp+44], esi
  00055	74 6d		 je	 SHORT $L212000

; 1774 : 			{
; 1775 : 
; 1776 : 				DWORD dwIndex	= NULL_ID;
; 1777 : 				for( int j = 0; j < nMax; j++ )

  00057	8d 7d 2c	 lea	 edi, DWORD PTR [ebp+44]
  0005a	33 c0		 xor	 eax, eax
  0005c	8b cf		 mov	 ecx, edi
  0005e	8b ff		 npad	 2
$L209729:

; 1778 : 				{	
; 1779 : 					if( pMover->m_Inventory.m_apItem[j].m_dwObjIndex == i )

  00060	39 31		 cmp	 DWORD PTR [ecx], esi
  00062	74 19		 je	 SHORT $L211991
  00064	40		 inc	 eax
  00065	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  0006b	3b c2		 cmp	 eax, edx
  0006d	7c f1		 jl	 SHORT $L209729
$L209733:

; 1790 : 				{
; 1791 : 					if( i >= nNumberofIndex )

  0006f	3b 74 24 10	 cmp	 esi, DWORD PTR _nNumberofIndex$[esp+144]
  00073	7c 11		 jl	 SHORT $L209735

; 1792 : 					{
; 1793 : 						pMover->m_Inventory.m_apIndex[i]	= NULL_ID;

  00075	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 1794 : 					}
; 1795 : 					else

  0007b	eb 47		 jmp	 SHORT $L212000
$L211991:

; 1780 : 					{
; 1781 : 						dwIndex	= j;
; 1782 : 						break;
; 1783 : 					}
; 1784 : 				}
; 1785 : 				if( dwIndex != NULL_ID )

  0007d	83 f8 ff	 cmp	 eax, -1
  00080	74 ed		 je	 SHORT $L209733

; 1786 : 				{
; 1787 : 					pMover->m_Inventory.m_apIndex[i]	= dwIndex;

  00082	89 03		 mov	 DWORD PTR [ebx], eax

; 1788 : 				}
; 1789 : 				else

  00084	eb 3e		 jmp	 SHORT $L212000
$L209735:

; 1796 : 					{
; 1797 : 						for( j = 0; j < nMax; j++ )

  00086	33 c0		 xor	 eax, eax
  00088	8b cf		 mov	 ecx, edi
  0008a	8d 9b 00 00 00
	00		 npad	 6
$L209737:

; 1798 : 						{
; 1799 : 							if( pMover->m_Inventory.m_apItem[j].m_dwObjIndex == NULL_ID )

  00090	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00093	74 0d		 je	 SHORT $L211992
  00095	40		 inc	 eax
  00096	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  0009c	3b c2		 cmp	 eax, edx
  0009e	7c f0		 jl	 SHORT $L209737

; 1803 : 								break;
; 1804 : 							}
; 1805 : 						}
; 1806 : 						if( j == nMax ) {

  000a0	eb 1a		 jmp	 SHORT $L209739
$L211992:

; 1800 : 							{
; 1801 : 								pMover->m_Inventory.m_apItem[j].m_dwObjIndex	= i;

  000a2	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000a5	c1 e1 05	 shl	 ecx, 5
  000a8	89 74 29 2c	 mov	 DWORD PTR [ecx+ebp+44], esi

; 1802 : 								pMover->m_Inventory.m_apIndex[i]	= j;

  000ac	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _pMover$[esp+140]
  000b3	8b 89 18 41 00
	00		 mov	 ecx, DWORD PTR [ecx+16664]
  000b9	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
$L209739:

; 1803 : 								break;
; 1804 : 							}
; 1805 : 						}
; 1806 : 						if( j == nMax ) {

  000bc	3b c2		 cmp	 eax, edx
  000be	0f 84 b1 00 00
	00		 je	 $L211993
$L212000:

; 1788 : 				}
; 1789 : 				else

  000c4	8b ac 24 94 00
	00 00		 mov	 ebp, DWORD PTR _pMover$[esp+140]
$L209723:

; 1767 : 	DWORD dwId;
; 1768 : 	for( int i = 0; i < nMax; i++ )

  000cb	46		 inc	 esi
  000cc	3b f2		 cmp	 esi, edx
  000ce	0f 8c 5c ff ff
	ff		 jl	 $L209722
$L209724:

; 1809 : 						}
; 1810 : 					}
; 1811 : 				}
; 1812 : 			}
; 1813 : 		}
; 1814 : 	}
; 1815 : 
; 1816 : 	DWORD dwObjIndex;
; 1817 : 	for( i = 0; i < nMax; i++ )

  000d4	33 f6		 xor	 esi, esi
  000d6	85 d2		 test	 edx, edx
  000d8	7e 33		 jle	 SHORT $L209746
  000da	33 ff		 xor	 edi, edi
  000dc	8d 64 24 00	 npad	 4
$L209744:

; 1818 : 	{
; 1819 : 		dwObjIndex	= pMover->m_Inventory.m_apItem[i].m_dwObjIndex;

  000e0	8b 85 20 41 00
	00		 mov	 eax, DWORD PTR [ebp+16672]
  000e6	8d 4c 38 2c	 lea	 ecx, DWORD PTR [eax+edi+44]
  000ea	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1820 : 		if( dwObjIndex != NULL_ID )

  000ec	83 f8 ff	 cmp	 eax, -1
  000ef	74 11		 je	 SHORT $L209745

; 1821 : 		{
; 1822 : 			if( pMover->m_Inventory.m_apIndex[dwObjIndex] != i )

  000f1	8b 9d 18 41 00
	00		 mov	 ebx, DWORD PTR [ebp+16664]
  000f7	39 34 83	 cmp	 DWORD PTR [ebx+eax*4], esi
  000fa	74 06		 je	 SHORT $L209745

; 1823 : 				pMover->m_Inventory.m_apItem[i].m_dwObjIndex	= NULL_ID;

  000fc	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1
$L209745:

; 1809 : 						}
; 1810 : 					}
; 1811 : 				}
; 1812 : 			}
; 1813 : 		}
; 1814 : 	}
; 1815 : 
; 1816 : 	DWORD dwObjIndex;
; 1817 : 	for( i = 0; i < nMax; i++ )

  00102	46		 inc	 esi
  00103	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H
  00109	3b f2		 cmp	 esi, edx
  0010b	7c d3		 jl	 SHORT $L209744
$L209746:

; 1824 : 		}
; 1825 : 	}
; 1826 : 
; 1827 : 	DWORD adwEquipment[MAX_HUMAN_PARTS];
; 1828 : 	memset( adwEquipment, 0xff, sizeof(DWORD) * MAX_HUMAN_PARTS );

  0010d	83 c8 ff	 or	 eax, -1
  00110	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00115	8d 7c 24 14	 lea	 edi, DWORD PTR _adwEquipment$[esp+144]
  00119	f3 ab		 rep stosd

; 1829 : 	for( i = nNumberofIndex; i < nMax; i++ )

  0011b	8b 4c 24 10	 mov	 ecx, DWORD PTR _nNumberofIndex$[esp+144]
  0011f	3b ca		 cmp	 ecx, edx
  00121	7d 21		 jge	 SHORT $L209753
  00123	8b 85 18 41 00
	00		 mov	 eax, DWORD PTR [ebp+16664]
  00129	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0012c	8d 74 24 14	 lea	 esi, DWORD PTR _adwEquipment$[esp+144]
  00130	2b d1		 sub	 edx, ecx
$L209751:

; 1830 : 	{
; 1831 : 		dwId	= pMover->m_Inventory.m_apIndex[i];

  00132	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1832 : 		if( dwId != NULL_ID )

  00134	83 f9 ff	 cmp	 ecx, -1
  00137	74 02		 je	 SHORT $L209752

; 1833 : 			adwEquipment[i - nNumberofIndex]	= dwId;

  00139	89 0e		 mov	 DWORD PTR [esi], ecx
$L209752:

; 1829 : 	for( i = nNumberofIndex; i < nMax; i++ )

  0013b	83 c0 04	 add	 eax, 4
  0013e	83 c6 04	 add	 esi, 4
  00141	4a		 dec	 edx
  00142	75 ee		 jne	 SHORT $L209751
$L209753:

; 1834 : 	}
; 1835 : 	for( i = 0; i < MAX_HUMAN_PARTS; i++ )

  00144	33 c0		 xor	 eax, eax
  00146	8d 8d 24 45 00
	00		 lea	 ecx, DWORD PTR [ebp+17700]
  0014c	8d 64 24 00	 npad	 4
$L209755:

; 1836 : 	{
; 1837 : 		if( pMover->m_aEquipInfo[i].dwId != adwEquipment[i] )

  00150	8b 54 84 14	 mov	 edx, DWORD PTR _adwEquipment$[esp+eax*4+144]
  00154	39 11		 cmp	 DWORD PTR [ecx], edx
  00156	74 02		 je	 SHORT $L209756

; 1838 : 			pMover->m_aEquipInfo[i].dwId	= adwEquipment[i];			

  00158	89 11		 mov	 DWORD PTR [ecx], edx
$L209756:

; 1834 : 	}
; 1835 : 	for( i = 0; i < MAX_HUMAN_PARTS; i++ )

  0015a	40		 inc	 eax
  0015b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0015e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00161	7c ed		 jl	 SHORT $L209755
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5d		 pop	 ebp

; 1839 : 	}
; 1840 : 	return TRUE;

  00166	b8 01 00 00 00	 mov	 eax, 1
  0016b	5b		 pop	 ebx

; 1841 : }

  0016c	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00172	c2 04 00	 ret	 4
$L211993:
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5d		 pop	 ebp

; 1807 : 							ASSERT( 0 );
; 1808 : 							return FALSE;

  00178	33 c0		 xor	 eax, eax
  0017a	5b		 pop	 ebx

; 1841 : }

  0017b	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00181	c2 04 00	 ret	 4
?NormalizePlayerData@CDbManager@@AAEHPAVCMover@@@Z ENDP	; CDbManager::NormalizePlayerData
_TEXT	ENDS
PUBLIC	??_GCQuery@@QAEPAXI@Z				; CQuery::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??1CQuery@@QAE@XZ:NEAR				; CQuery::~CQuery
; Function compile flags: /Ogty
;	COMDAT ??_GCQuery@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCQuery@@QAEPAXI@Z PROC NEAR				; CQuery::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L212004
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L212004:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCQuery@@QAEPAXI@Z ENDP				; CQuery::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L212007
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L212007:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC NEAR			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L212013
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L212013:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC NEAR	; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC NEAR		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z	; CItemContainer<CItemElem>::IsEquip
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT
_dwObjId$ = 8						; size = 4
?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z PROC NEAR ; CItemContainer<CItemElem>::IsEquip, COMDAT
; _this$ = ecx

; 708  : 	if( m_apItem[ dwObjId ].m_dwObjIndex >= m_dwIndexNum )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwObjId$[esp-4]
  00004	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00007	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0000a	c1 e0 05	 shl	 eax, 5
  0000d	8b 54 10 2c	 mov	 edx, DWORD PTR [eax+edx+44]
  00011	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00014	1b c0		 sbb	 eax, eax
  00016	40		 inc	 eax

; 709  : 		return TRUE;
; 710  : 	return FALSE;
; 711  : }

  00017	c2 04 00	 ret	 4
?IsEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z ENDP	; CItemContainer<CItemElem>::IsEquip
_TEXT	ENDS
PUBLIC	?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAt
; Function compile flags: /Ogty
;	COMDAT ?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z PROC NEAR ; CItemContainer<CItemElem>::RemoveAt, COMDAT
; _this$ = ecx

; 713  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 714  : 	m_apItem[ m_apIndex[ dwIndex ] ].Empty();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR _dwIndex$[esp+4]
  0000e	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00011	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00014	c1 e1 05	 shl	 ecx, 5
  00017	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  0001a	03 ca		 add	 ecx, edx
  0001c	ff 50 04	 call	 DWORD PTR [eax+4]

; 715  : 	if( dwIndex >= m_dwIndexNum )

  0001f	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00022	72 21		 jb	 SHORT $L210797

; 716  : 	{
; 717  : 		m_apItem[ m_apIndex[ dwIndex ] ].m_dwObjIndex = NULL_ID;

  00024	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00027	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  0002a	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	c1 e2 05	 shl	 edx, 5
  00033	c7 44 02 2c ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+44], -1

; 718  : 		m_apIndex[ dwIndex ] = NULL_ID;

  0003b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003e	c7 04 b9 ff ff
	ff ff		 mov	 DWORD PTR [ecx+edi*4], -1
$L210797:
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 719  : 	}
; 720  : 	//for( int i = dwIndex; i < m_dwIndexNum - 1; i++ )
; 721  : 	//	m_apIndex[ i ] = m_apIndex[ i + 1 ];
; 722  : 	//m_dwIndexNum--;
; 723  : }

  00047	c2 04 00	 ret	 4
?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z ENDP	; CItemContainer<CItemElem>::RemoveAt
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<long *,long *>
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<long *,long *>, COMDAT

; 1031 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 1032 : 	return ((_OutIt)::memmove(&*_Dest, &*_First,
; 1033 : 		_Off * sizeof (*_First)) + _Off);

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1034 : 	}

  00027	c3		 ret	 0
??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<long *,long *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<long *,long *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<long *,long *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<long *,long *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<long,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<long,std::allocator<long> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<long,std::allocator<long> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC NEAR		; std::_Allocate<int>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC NEAR		; std::fill<int *,int>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L211053
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L211051:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L211051
  0001c	5e		 pop	 esi
$L211053:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<long,long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<long,long>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<long,long>
_TEXT	ENDS
PUBLIC	??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z		; std::fill_n<long *,unsigned int,long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z PROC NEAR		; std::fill_n<long *,unsigned int,long>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L211132
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L211130:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L211130
  0001b	5e		 pop	 esi
$L211132:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z ENDP			; std::fill_n<long *,unsigned int,long>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<int *,int *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *>
_TEXT	ENDS
PUBLIC	??$fill_n@PAHIH@std@@YAXPAHIABH@Z		; std::fill_n<int *,unsigned int,int>
; Function compile flags: /Ogty
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAHIH@std@@YAXPAHIABH@Z PROC NEAR		; std::fill_n<int *,unsigned int,int>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L211194
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L211192:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L211192
  0001b	5e		 pop	 esi
$L211194:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAHIH@std@@YAXPAHIABH@Z ENDP			; std::fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<int,int>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int,int>
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 331  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl

; 332  : 		}

  0000c	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Ogty
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC NEAR	; std::char_traits<char>::compare, COMDAT

; 347  : 		return (::memcmp(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR __First2$[esp+4]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 a6		 repe cmpsb
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	74 05		 je	 SHORT $L212067
  00016	1b c0		 sbb	 eax, eax
  00018	83 d8 ff	 sbb	 eax, -1
$L212067:

; 348  : 		}

  0001b	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogty
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 352  : 		return (::strlen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L212071:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $L212071
  0000e	2b c2		 sub	 eax, edx

; 353  : 		}

  00010	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Ogty
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __First2$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __First1$[esp+4]
  0000e	8b c1		 mov	 eax, ecx
  00010	8b d7		 mov	 edx, edi
  00012	c1 e9 02	 shr	 ecx, 2
  00015	f3 a5		 rep movsd
  00017	8b c8		 mov	 ecx, eax
  00019	83 e1 03	 and	 ecx, 3
  0001c	f3 a4		 rep movsb
  0001e	5f		 pop	 edi
  0001f	8b c2		 mov	 eax, edx
  00021	5e		 pop	 esi

; 359  : 		}

  00022	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Ogty
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

  00000	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 335  : 	{	// return pointer category from pointer to int arguments

  00000	51		 push	 ecx

; 336  : 	_Scalar_ptr_iterator_tag _Cat;
; 337  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 338  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 359  : 	{	// return pointer category from pointer to long arguments

  00000	51		 push	 ecx

; 360  : 	_Scalar_ptr_iterator_tag _Cat;
; 361  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 362  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	?Enter@CMclCritSec@@QAEXXZ			; CMclCritSec::Enter
EXTRN	__imp__EnterCriticalSection@4:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Enter@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Enter, COMDAT
; _this$ = ecx

; 33   : 		::EnterCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 34   : 	}

  0000a	c3		 ret	 0
?Enter@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Enter
_TEXT	ENDS
PUBLIC	?Leave@CMclCritSec@@QAEXXZ			; CMclCritSec::Leave
EXTRN	__imp__LeaveCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Leave@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Leave, COMDAT
; _this$ = ecx

; 39   : 		::LeaveCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 40   : 	}

  0000a	c3		 ret	 0
?Leave@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Leave
_TEXT	ENDS
PUBLIC	?GetIntFromStr@@YAHPADPAH@Z			; GetIntFromStr
EXTRN	_atoi:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\cmnhdr.h
;	COMDAT ?GetIntFromStr@@YAHPADPAH@Z
_TEXT	SEGMENT
_strTemp$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pBuf$ = 8						; size = 4
_pLocation$ = 12					; size = 4
?GetIntFromStr@@YAHPADPAH@Z PROC NEAR			; GetIntFromStr, COMDAT

; 98   : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 38	 mov	 DWORD PTR __$ArrayPad$[esp+60], eax
  0000f	8b 44 24 44	 mov	 eax, DWORD PTR _pLocation$[esp+56]

; 99   : 	char strTemp[50];
; 100  : 	int count=0;
; 101  : 	while(pBuf[*pLocation]!=',' && pBuf[*pLocation]!='/' && pBuf[*pLocation]!=0) {

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	57		 push	 edi
  00016	8b 7c 24 44	 mov	 edi, DWORD PTR _pBuf$[esp+60]
  0001a	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0001d	33 f6		 xor	 esi, esi
  0001f	80 fa 2c	 cmp	 dl, 44			; 0000002cH
  00022	74 1c		 je	 SHORT $L128290
$L128289:
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  00029	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0002c	74 12		 je	 SHORT $L128290
  0002e	84 c9		 test	 cl, cl
  00030	74 0e		 je	 SHORT $L128290

; 102  : 		strTemp[count]=pBuf[*pLocation];

  00032	88 4c 34 08	 mov	 BYTE PTR _strTemp$[esp+esi+64], cl

; 103  : 		count++; (*pLocation)++;

  00036	46		 inc	 esi
  00037	42		 inc	 edx
  00038	89 10		 mov	 DWORD PTR [eax], edx
  0003a	80 3c 17 2c	 cmp	 BYTE PTR [edi+edx], 44	; 0000002cH
  0003e	75 e4		 jne	 SHORT $L128289
$L128290:

; 104  : 	}
; 105  : 	strTemp[count]=0;(*pLocation)++;

  00040	c6 44 34 08 00	 mov	 BYTE PTR _strTemp$[esp+esi+64], 0
  00045	ff 00		 inc	 DWORD PTR [eax]

; 106  : 	return atoi(strTemp);

  00047	8d 44 24 08	 lea	 eax, DWORD PTR _strTemp$[esp+64]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _atoi

; 107  : }

  00051	8b 4c 24 40	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+68]
  00055	83 c4 04	 add	 esp, 4
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	33 cc		 xor	 ecx, esp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	83 c4 38	 add	 esp, 56			; 00000038H
  00064	c3		 ret	 0
?GetIntFromStr@@YAHPADPAH@Z ENDP			; GetIntFromStr
_TEXT	ENDS
PUBLIC	?GetStrFromStr@@YAXPAD0PAH@Z			; GetStrFromStr
; Function compile flags: /Ogty
;	COMDAT ?GetStrFromStr@@YAXPAD0PAH@Z
_TEXT	SEGMENT
_pBuf$ = 8						; size = 4
_strReturn$ = 12					; size = 4
_pLocation$ = 16					; size = 4
?GetStrFromStr@@YAXPAD0PAH@Z PROC NEAR			; GetStrFromStr, COMDAT

; 111  : 	int count=0;
; 112  : 	while(pBuf[*pLocation]!=',' && pBuf[*pLocation]!='/' && pBuf[*pLocation]!=0) {

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _pLocation$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR _pBuf$[esp+4]
  0000c	8a 1c 17	 mov	 bl, BYTE PTR [edi+edx]
  0000f	33 c9		 xor	 ecx, ecx
  00011	80 fb 2c	 cmp	 bl, 44			; 0000002cH
  00014	74 34		 je	 SHORT $L212096
  00016	56		 push	 esi
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _strReturn$[esp+8]
  0001b	eb 03 8d 49 00	 npad	 5
$L128298:
  00020	8b 10		 mov	 edx, DWORD PTR [eax]
  00022	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]
  00025	80 fa 2f	 cmp	 dl, 47			; 0000002fH
  00028	74 13		 je	 SHORT $L212098
  0002a	84 d2		 test	 dl, dl
  0002c	74 0f		 je	 SHORT $L212098

; 113  : 		strReturn[count]=pBuf[*pLocation];

  0002e	88 14 31	 mov	 BYTE PTR [ecx+esi], dl

; 114  : 		count++; (*pLocation)++;

  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	41		 inc	 ecx
  00034	42		 inc	 edx
  00035	89 10		 mov	 DWORD PTR [eax], edx
  00037	80 3c 17 2c	 cmp	 BYTE PTR [edi+edx], 44	; 0000002cH
  0003b	75 e3		 jne	 SHORT $L128298
$L212098:

; 115  : 	}
; 116  : 	strReturn[count]=0;(*pLocation)++;

  0003d	c6 04 31 00	 mov	 BYTE PTR [ecx+esi], 0
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	5e		 pop	 esi
  00044	41		 inc	 ecx
  00045	5f		 pop	 edi
  00046	89 08		 mov	 DWORD PTR [eax], ecx
  00048	5b		 pop	 ebx

; 117  : }

  00049	c3		 ret	 0
$L212096:

; 115  : 	}
; 116  : 	strReturn[count]=0;(*pLocation)++;

  0004a	8b 54 24 10	 mov	 edx, DWORD PTR _strReturn$[esp+4]
  0004e	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	41		 inc	 ecx
  00055	5f		 pop	 edi
  00056	89 08		 mov	 DWORD PTR [eax], ecx
  00058	5b		 pop	 ebx

; 117  : }

  00059	c3		 ret	 0
?GetStrFromStr@@YAXPAD0PAH@Z ENDP			; GetStrFromStr
_TEXT	ENDS
PUBLIC	?GetInt64PaFromStr@@YA_JPADPAH@Z		; GetInt64PaFromStr
EXTRN	__atoi64:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetInt64PaFromStr@@YA_JPADPAH@Z
_TEXT	SEGMENT
_strTemp$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pBuf$ = 8						; size = 4
_pLocation$ = 12					; size = 4
?GetInt64PaFromStr@@YA_JPADPAH@Z PROC NEAR		; GetInt64PaFromStr, COMDAT

; 121  : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 38	 mov	 DWORD PTR __$ArrayPad$[esp+60], eax
  0000f	8b 44 24 44	 mov	 eax, DWORD PTR _pLocation$[esp+56]

; 122  : 	char strTemp[50];
; 123  : 	int count	=0;
; 124  : 	while( pBuf[*pLocation] != ',' && pBuf[*pLocation] != 0 )

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	57		 push	 edi
  00016	8b 7c 24 44	 mov	 edi, DWORD PTR _pBuf$[esp+60]
  0001a	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0001d	33 f6		 xor	 esi, esi
  0001f	80 fa 2c	 cmp	 dl, 44			; 0000002cH
  00022	74 1c		 je	 SHORT $L128308
$L128307:
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  00029	84 c9		 test	 cl, cl
  0002b	74 13		 je	 SHORT $L128308

; 125  : 	{
; 126  : 		if( pBuf[*pLocation] != '/' )

  0002d	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  00030	74 36		 je	 SHORT $L128309

; 127  : 		{
; 128  : 			strTemp[count]	=pBuf[*pLocation];

  00032	88 4c 34 08	 mov	 BYTE PTR _strTemp$[esp+esi+64], cl

; 129  : 			count++;	( *pLocation )++;

  00036	46		 inc	 esi
  00037	42		 inc	 edx
  00038	89 10		 mov	 DWORD PTR [eax], edx
  0003a	80 3c 17 2c	 cmp	 BYTE PTR [edi+edx], 44	; 0000002cH
  0003e	75 e4		 jne	 SHORT $L128307
$L128308:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 	strTemp[count]	=0;	( *pLocation )++;

  00040	c6 44 34 08 00	 mov	 BYTE PTR _strTemp$[esp+esi+64], 0
  00045	8b 30		 mov	 esi, DWORD PTR [eax]
  00047	46		 inc	 esi

; 145  : 	return _atoi64( strTemp );

  00048	8d 4c 24 08	 lea	 ecx, DWORD PTR _strTemp$[esp+64]
  0004c	89 30		 mov	 DWORD PTR [eax], esi
  0004e	51		 push	 ecx
$L212107:
  0004f	e8 00 00 00 00	 call	 __atoi64
  00054	83 c4 04	 add	 esp, 4
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 146  : }

  00059	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  0005d	33 cc		 xor	 ecx, esp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	83 c4 38	 add	 esp, 56			; 00000038H
  00067	c3		 ret	 0
$L128309:

; 130  : 		}
; 131  : 		else
; 132  : 		{
; 133  : 			if( count == 0 )

  00068	85 f6		 test	 esi, esi
  0006a	75 15		 jne	 SHORT $L128311

; 146  : }

  0006c	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	33 cc		 xor	 ecx, esp
  00074	33 c0		 xor	 eax, eax
  00076	33 d2		 xor	 edx, edx
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	83 c4 38	 add	 esp, 56			; 00000038H
  00080	c3		 ret	 0
$L128311:

; 134  : 			{
; 135  : 				return 0;
; 136  : 			}
; 137  : 			else
; 138  : 			{
; 139  : 				strTemp[count]	=0;
; 140  : 				return _atoi64( strTemp );

  00081	8d 44 24 08	 lea	 eax, DWORD PTR _strTemp$[esp+64]
  00085	c6 44 34 08 00	 mov	 BYTE PTR _strTemp$[esp+esi+64], 0
  0008a	50		 push	 eax
  0008b	eb c2		 jmp	 SHORT $L212107
?GetInt64PaFromStr@@YA_JPADPAH@Z ENDP			; GetInt64PaFromStr
_TEXT	ENDS
PUBLIC	?GetIntPaFromStr@@YAHPADPAH@Z			; GetIntPaFromStr
; Function compile flags: /Ogty
;	COMDAT ?GetIntPaFromStr@@YAHPADPAH@Z
_TEXT	SEGMENT
_strTemp$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pBuf$ = 8						; size = 4
_pLocation$ = 12					; size = 4
?GetIntPaFromStr@@YAHPADPAH@Z PROC NEAR			; GetIntPaFromStr, COMDAT

; 152  : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 38	 mov	 DWORD PTR __$ArrayPad$[esp+60], eax
  0000f	8b 44 24 44	 mov	 eax, DWORD PTR _pLocation$[esp+56]

; 153  : 	char strTemp[50];
; 154  : 	int count=0;
; 155  : 	while(pBuf[*pLocation]!=',' && pBuf[*pLocation]!=0)

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	57		 push	 edi
  00016	8b 7c 24 44	 mov	 edi, DWORD PTR _pBuf$[esp+60]
  0001a	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0001d	33 f6		 xor	 esi, esi
  0001f	80 fa 2c	 cmp	 dl, 44			; 0000002cH
  00022	74 1c		 je	 SHORT $L128321
$L128320:
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  00029	84 c9		 test	 cl, cl
  0002b	74 13		 je	 SHORT $L128321

; 156  : 	{
; 157  : 		if( pBuf[*pLocation]!='/' )

  0002d	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  00030	74 36		 je	 SHORT $L128322

; 158  : 		{
; 159  : 			strTemp[count]=pBuf[*pLocation];

  00032	88 4c 34 08	 mov	 BYTE PTR _strTemp$[esp+esi+64], cl

; 160  : 			count++; (*pLocation)++;

  00036	46		 inc	 esi
  00037	42		 inc	 edx
  00038	89 10		 mov	 DWORD PTR [eax], edx
  0003a	80 3c 17 2c	 cmp	 BYTE PTR [edi+edx], 44	; 0000002cH
  0003e	75 e4		 jne	 SHORT $L128320
$L128321:

; 172  : 			}
; 173  : 		}
; 174  : 	}
; 175  : 	strTemp[count]=0;(*pLocation)++;

  00040	c6 44 34 08 00	 mov	 BYTE PTR _strTemp$[esp+esi+64], 0
  00045	8b 30		 mov	 esi, DWORD PTR [eax]
  00047	46		 inc	 esi

; 176  : 	return atoi(strTemp);

  00048	8d 4c 24 08	 lea	 ecx, DWORD PTR _strTemp$[esp+64]
  0004c	89 30		 mov	 DWORD PTR [eax], esi
  0004e	51		 push	 ecx
$L212114:
  0004f	e8 00 00 00 00	 call	 _atoi
  00054	83 c4 04	 add	 esp, 4
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 177  : }

  00059	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  0005d	33 cc		 xor	 ecx, esp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	83 c4 38	 add	 esp, 56			; 00000038H
  00067	c3		 ret	 0
$L128322:

; 161  : 		}
; 162  : 		else
; 163  : 		{
; 164  : 			if( count == 0 )

  00068	85 f6		 test	 esi, esi
  0006a	75 13		 jne	 SHORT $L128324

; 177  : }

  0006c	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	33 cc		 xor	 ecx, esp
  00074	33 c0		 xor	 eax, eax
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	83 c4 38	 add	 esp, 56			; 00000038H
  0007e	c3		 ret	 0
$L128324:

; 165  : 			{
; 166  : 				return 0;
; 167  : 			}
; 168  : 			else
; 169  : 			{
; 170  : 				strTemp[count]=0;
; 171  : 				return atoi(strTemp);

  0007f	8d 44 24 08	 lea	 eax, DWORD PTR _strTemp$[esp+64]
  00083	c6 44 34 08 00	 mov	 BYTE PTR _strTemp$[esp+esi+64], 0
  00088	50		 push	 eax
  00089	eb c4		 jmp	 SHORT $L212114
?GetIntPaFromStr@@YAHPADPAH@Z ENDP			; GetIntPaFromStr
_TEXT	ENDS
PUBLIC	?GetSerialNumberPaFromStr@@YAKPADPAH@Z		; GetSerialNumberPaFromStr
; Function compile flags: /Ogty
;	COMDAT ?GetSerialNumberPaFromStr@@YAKPADPAH@Z
_TEXT	SEGMENT
_strTemp$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pBuf$ = 8						; size = 4
_pLocation$ = 12					; size = 4
?GetSerialNumberPaFromStr@@YAKPADPAH@Z PROC NEAR	; GetSerialNumberPaFromStr, COMDAT

; 180  : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 38	 mov	 DWORD PTR __$ArrayPad$[esp+60], eax
  0000f	8b 44 24 44	 mov	 eax, DWORD PTR _pLocation$[esp+56]

; 181  : 	char strTemp[50];
; 182  : 	int count=0;
; 183  : 	while(pBuf[*pLocation]!=',' && pBuf[*pLocation]!=0)

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	57		 push	 edi
  00016	8b 7c 24 44	 mov	 edi, DWORD PTR _pBuf$[esp+60]
  0001a	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  0001d	33 f6		 xor	 esi, esi
  0001f	80 fa 2c	 cmp	 dl, 44			; 0000002cH
  00022	74 1c		 je	 SHORT $L128334
$L128333:
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  00029	84 c9		 test	 cl, cl
  0002b	74 13		 je	 SHORT $L128334

; 184  : 	{
; 185  : 		if( pBuf[*pLocation]!='/' )

  0002d	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  00030	74 36		 je	 SHORT $L128335

; 186  : 		{
; 187  : 			strTemp[count]=pBuf[*pLocation];

  00032	88 4c 34 08	 mov	 BYTE PTR _strTemp$[esp+esi+64], cl

; 188  : 			count++; (*pLocation)++;

  00036	46		 inc	 esi
  00037	42		 inc	 edx
  00038	89 10		 mov	 DWORD PTR [eax], edx
  0003a	80 3c 17 2c	 cmp	 BYTE PTR [edi+edx], 44	; 0000002cH
  0003e	75 e4		 jne	 SHORT $L128333
$L128334:

; 200  : 			}
; 201  : 		}
; 202  : 	}
; 203  : 	strTemp[count]=0;(*pLocation)++;

  00040	c6 44 34 08 00	 mov	 BYTE PTR _strTemp$[esp+esi+64], 0
  00045	8b 30		 mov	 esi, DWORD PTR [eax]
  00047	46		 inc	 esi

; 204  : 	return atoi(strTemp);

  00048	8d 4c 24 08	 lea	 ecx, DWORD PTR _strTemp$[esp+64]
  0004c	89 30		 mov	 DWORD PTR [eax], esi
  0004e	51		 push	 ecx
$L212121:
  0004f	e8 00 00 00 00	 call	 _atoi
  00054	83 c4 04	 add	 esp, 4
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 205  : }

  00059	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  0005d	33 cc		 xor	 ecx, esp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	83 c4 38	 add	 esp, 56			; 00000038H
  00067	c3		 ret	 0
$L128335:

; 189  : 		}
; 190  : 		else
; 191  : 		{
; 192  : 			if( count == 0 )

  00068	85 f6		 test	 esi, esi
  0006a	75 13		 jne	 SHORT $L128337

; 205  : }

  0006c	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	33 cc		 xor	 ecx, esp
  00074	33 c0		 xor	 eax, eax
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	83 c4 38	 add	 esp, 56			; 00000038H
  0007e	c3		 ret	 0
$L128337:

; 193  : 			{
; 194  : 				return (SERIALNUMBER)0;
; 195  : 			}
; 196  : 			else
; 197  : 			{
; 198  : 				strTemp[count]=0;
; 199  : 				return atoi(strTemp);

  0007f	8d 44 24 08	 lea	 eax, DWORD PTR _strTemp$[esp+64]
  00083	c6 44 34 08 00	 mov	 BYTE PTR _strTemp$[esp+esi+64], 0
  00088	50		 push	 eax
  00089	eb c4		 jmp	 SHORT $L212121
?GetSerialNumberPaFromStr@@YAKPADPAH@Z ENDP		; GetSerialNumberPaFromStr
_TEXT	ENDS
PUBLIC	?GetStrPaFromStr@@YAXPAD0PAH@Z			; GetStrPaFromStr
; Function compile flags: /Ogty
;	COMDAT ?GetStrPaFromStr@@YAXPAD0PAH@Z
_TEXT	SEGMENT
_pBuf$ = 8						; size = 4
_strReturn$ = 12					; size = 4
_pLocation$ = 16					; size = 4
?GetStrPaFromStr@@YAXPAD0PAH@Z PROC NEAR		; GetStrPaFromStr, COMDAT

; 209  : 	int count=0;
; 210  : 	while(pBuf[*pLocation]!=',' && pBuf[*pLocation]!=0)

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _pLocation$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 74 24 0c	 mov	 esi, DWORD PTR _pBuf$[esp+4]
  0000c	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  0000f	33 c9		 xor	 ecx, ecx
  00011	80 fb 2c	 cmp	 bl, 44			; 0000002cH
  00014	57		 push	 edi
  00015	8b 7c 24 14	 mov	 edi, DWORD PTR _strReturn$[esp+8]
  00019	74 22		 je	 SHORT $L128348
  0001b	eb 03 8d 49 00	 npad	 5
$L128347:
  00020	8b 10		 mov	 edx, DWORD PTR [eax]
  00022	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00025	84 d2		 test	 dl, dl
  00027	74 14		 je	 SHORT $L128348

; 211  : 	{
; 212  : 		if( pBuf[*pLocation]!='/' )

  00029	80 fa 2f	 cmp	 dl, 47			; 0000002fH
  0002c	74 1c		 je	 SHORT $L128349

; 213  : 		{
; 214  : 			strReturn[count]=pBuf[*pLocation];

  0002e	88 14 39	 mov	 BYTE PTR [ecx+edi], dl

; 215  : 			count++; (*pLocation)++;

  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	41		 inc	 ecx
  00034	42		 inc	 edx
  00035	89 10		 mov	 DWORD PTR [eax], edx
  00037	80 3c 16 2c	 cmp	 BYTE PTR [esi+edx], 44	; 0000002cH
  0003b	75 e3		 jne	 SHORT $L128347
$L128348:

; 226  : 			}
; 227  : 			return;
; 228  : 		}
; 229  : 	}
; 230  : 	strReturn[count]=0;(*pLocation)++;

  0003d	c6 04 39 00	 mov	 BYTE PTR [ecx+edi], 0
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	5f		 pop	 edi
  00044	41		 inc	 ecx
  00045	5e		 pop	 esi
  00046	89 08		 mov	 DWORD PTR [eax], ecx
  00048	5b		 pop	 ebx

; 231  : }

  00049	c3		 ret	 0
$L128349:

; 216  : 		}
; 217  : 		else
; 218  : 		{
; 219  : 			if( count == 0 )

  0004a	85 c9		 test	 ecx, ecx
  0004c	75 06		 jne	 SHORT $L128351

; 220  : 			{
; 221  : 				strReturn[0] = '\0';

  0004e	88 0f		 mov	 BYTE PTR [edi], cl
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 231  : }

  00053	c3		 ret	 0
$L128351:

; 222  : 			}
; 223  : 			else
; 224  : 			{
; 225  : 				strReturn[count]=pBuf[*pLocation];

  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  00059	88 14 39	 mov	 BYTE PTR [ecx+edi], dl
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx

; 231  : }

  0005f	c3		 ret	 0
?GetStrPaFromStr@@YAXPAD0PAH@Z ENDP			; GetStrPaFromStr
_TEXT	ENDS
PUBLIC	?IsUltimate@ItemProp@@QAEHXZ			; ItemProp::IsUltimate
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\projectcmn.h
;	COMDAT ?IsUltimate@ItemProp@@QAEHXZ
_TEXT	SEGMENT
?IsUltimate@ItemProp@@QAEHXZ PROC NEAR			; ItemProp::IsUltimate, COMDAT
; _this$ = ecx

; 457  : 			return( 
; 458  : 					(
; 459  : 						dwItemKind2 == IK2_WEAPON_DIRECT
; 460  : 						|| dwItemKind2 == IK2_WEAPON_MAGIC
; 461  : 					)
; 462  : 				&& dwReferStat1 == WEAPON_ULTIMATE
; 463  : 			);

  00000	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00003	83 f8 02	 cmp	 eax, 2
  00006	74 05		 je	 SHORT $L212127
  00008	83 f8 03	 cmp	 eax, 3
  0000b	75 0f		 jne	 SHORT $L212128
$L212127:
  0000d	83 b9 00 02 00
	00 02		 cmp	 DWORD PTR [ecx+512], 2
  00014	75 06		 jne	 SHORT $L212128
  00016	b8 01 00 00 00	 mov	 eax, 1

; 464  : 		}

  0001b	c3		 ret	 0
$L212128:

; 457  : 			return( 
; 458  : 					(
; 459  : 						dwItemKind2 == IK2_WEAPON_DIRECT
; 460  : 						|| dwItemKind2 == IK2_WEAPON_MAGIC
; 461  : 					)
; 462  : 				&& dwReferStat1 == WEAPON_ULTIMATE
; 463  : 			);

  0001c	33 c0		 xor	 eax, eax

; 464  : 		}

  0001e	c3		 ret	 0
?IsUltimate@ItemProp@@QAEHXZ ENDP			; ItemProp::IsUltimate
_TEXT	ENDS
PUBLIC	?IsVisPet@ItemProp@@QAEHXZ			; ItemProp::IsVisPet
; Function compile flags: /Ogty
;	COMDAT ?IsVisPet@ItemProp@@QAEHXZ
_TEXT	SEGMENT
?IsVisPet@ItemProp@@QAEHXZ PROC NEAR			; ItemProp::IsVisPet, COMDAT
; _this$ = ecx

; 509  : 	BOOL	IsVisPet()	{ return (dwItemKind3 == IK3_PET) && (dwReferStat1 == PET_VIS); }

  00000	83 79 78 64	 cmp	 DWORD PTR [ecx+120], 100 ; 00000064H
  00004	75 0f		 jne	 SHORT $L212132
  00006	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	3b d0		 cmp	 edx, eax
  00013	74 02		 je	 SHORT $L212133
$L212132:
  00015	33 c0		 xor	 eax, eax
$L212133:
  00017	c3		 ret	 0
?IsVisPet@ItemProp@@QAEHXZ ENDP				; ItemProp::IsVisPet
_TEXT	ENDS
PUBLIC	?GetExpInteger@CQuery@@QAE_JPAD@Z		; CQuery::GetExpInteger
EXTRN	?GetInt64@CQuery@@QAE_JPAD@Z:NEAR		; CQuery::GetInt64
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\query.h
;	COMDAT ?GetExpInteger@CQuery@@QAE_JPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetExpInteger@CQuery@@QAE_JPAD@Z PROC NEAR		; CQuery::GetExpInteger, COMDAT
; _this$ = ecx

; 62   : 	EXPINTEGER	GetExpInteger(	char* sCol ) { return GetInt64( sCol ); 	}

  00000	e9 00 00 00 00	 jmp	 ?GetInt64@CQuery@@QAE_JPAD@Z ; CQuery::GetInt64
?GetExpInteger@CQuery@@QAE_JPAD@Z ENDP			; CQuery::GetExpInteger
_TEXT	ENDS
PUBLIC	?GetType@IBuff@@QAEGXZ				; IBuff::GetType
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\buff.h
;	COMDAT ?GetType@IBuff@@QAEGXZ
_TEXT	SEGMENT
?GetType@IBuff@@QAEGXZ PROC NEAR			; IBuff::GetType, COMDAT
; _this$ = ecx

; 30   : 	WORD	GetType()	{	return m_wType;		}

  00000	66 8b 41 04	 mov	 ax, WORD PTR [ecx+4]
  00004	c3		 ret	 0
?GetType@IBuff@@QAEGXZ ENDP				; IBuff::GetType
_TEXT	ENDS
PUBLIC	?GetId@IBuff@@QAEGXZ				; IBuff::GetId
; Function compile flags: /Ogty
;	COMDAT ?GetId@IBuff@@QAEGXZ
_TEXT	SEGMENT
?GetId@IBuff@@QAEGXZ PROC NEAR				; IBuff::GetId, COMDAT
; _this$ = ecx

; 31   : 	WORD	GetId()		{	return m_wId;	}

  00000	66 8b 41 06	 mov	 ax, WORD PTR [ecx+6]
  00004	c3		 ret	 0
?GetId@IBuff@@QAEGXZ ENDP				; IBuff::GetId
_TEXT	ENDS
PUBLIC	?SetId@IBuff@@QAEXG@Z				; IBuff::SetId
; Function compile flags: /Ogty
;	COMDAT ?SetId@IBuff@@QAEXG@Z
_TEXT	SEGMENT
_wId$ = 8						; size = 2
?SetId@IBuff@@QAEXG@Z PROC NEAR				; IBuff::SetId, COMDAT
; _this$ = ecx

; 35   : 	void	SetId( WORD wId )	{	m_wId	= wId;	}

  00000	66 8b 44 24 04	 mov	 ax, WORD PTR _wId$[esp-4]
  00005	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  00009	c2 04 00	 ret	 4
?SetId@IBuff@@QAEXG@Z ENDP				; IBuff::SetId
_TEXT	ENDS
PUBLIC	?SetLevel@IBuff@@QAEXK@Z			; IBuff::SetLevel
; Function compile flags: /Ogty
;	COMDAT ?SetLevel@IBuff@@QAEXK@Z
_TEXT	SEGMENT
_dwLevel$ = 8						; size = 4
?SetLevel@IBuff@@QAEXK@Z PROC NEAR			; IBuff::SetLevel, COMDAT
; _this$ = ecx

; 37   : 	void	SetLevel( DWORD dwLevel )	{	m_dwLevel	= dwLevel;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwLevel$[esp-4]
  00004	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00007	c2 04 00	 ret	 4
?SetLevel@IBuff@@QAEXK@Z ENDP				; IBuff::SetLevel
_TEXT	ENDS
PUBLIC	?SetKind@CPet@@QAEXE@Z				; CPet::SetKind
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
;	COMDAT ?SetKind@CPet@@QAEXE@Z
_TEXT	SEGMENT
_nKind$ = 8						; size = 1
?SetKind@CPet@@QAEXE@Z PROC NEAR			; CPet::SetKind, COMDAT
; _this$ = ecx

; 133  : 	void	SetKind( BYTE nKind )	{	m_nKind	= nKind;	}

  00000	8a 44 24 04	 mov	 al, BYTE PTR _nKind$[esp-4]
  00004	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00007	c2 04 00	 ret	 4
?SetKind@CPet@@QAEXE@Z ENDP				; CPet::SetKind
_TEXT	ENDS
PUBLIC	?GetLevel@CPet@@QAEEXZ				; CPet::GetLevel
; Function compile flags: /Ogty
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT
?GetLevel@CPet@@QAEEXZ PROC NEAR			; CPet::GetLevel, COMDAT
; _this$ = ecx

; 134  : 	BYTE	GetLevel( void )	{	return m_nLevel;	}

  00000	8a 41 05	 mov	 al, BYTE PTR [ecx+5]
  00003	c3		 ret	 0
?GetLevel@CPet@@QAEEXZ ENDP				; CPet::GetLevel
_TEXT	ENDS
PUBLIC	?SetLevel@CPet@@QAEXE@Z				; CPet::SetLevel
; Function compile flags: /Ogty
;	COMDAT ?SetLevel@CPet@@QAEXE@Z
_TEXT	SEGMENT
_nLevel$ = 8						; size = 1
?SetLevel@CPet@@QAEXE@Z PROC NEAR			; CPet::SetLevel, COMDAT
; _this$ = ecx

; 136  : 	void	SetLevel( BYTE nLevel )	{	m_nLevel	= nLevel;	}

  00000	8a 44 24 04	 mov	 al, BYTE PTR _nLevel$[esp-4]
  00004	88 41 05	 mov	 BYTE PTR [ecx+5], al
  00007	c2 04 00	 ret	 4
?SetLevel@CPet@@QAEXE@Z ENDP				; CPet::SetLevel
_TEXT	ENDS
PUBLIC	?SetLife@CPet@@QAEXG@Z				; CPet::SetLife
; Function compile flags: /Ogty
;	COMDAT ?SetLife@CPet@@QAEXG@Z
_TEXT	SEGMENT
_wLife$ = 8						; size = 2
?SetLife@CPet@@QAEXG@Z PROC NEAR			; CPet::SetLife, COMDAT
; _this$ = ecx

; 140  : 	void	SetLife( WORD wLife )	{	m_wLife	= wLife;	}

  00000	66 8b 44 24 04	 mov	 ax, WORD PTR _wLife$[esp-4]
  00005	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax
  00009	c2 04 00	 ret	 4
?SetLife@CPet@@QAEXG@Z ENDP				; CPet::SetLife
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 133  : 	BOOL	IsEmpty()	{	return m_dwItemId ? FALSE : TRUE;	}

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	?GetSerialNumber@CItemBase@@QAEKXZ		; CItemBase::GetSerialNumber
; Function compile flags: /Ogty
;	COMDAT ?GetSerialNumber@CItemBase@@QAEKXZ
_TEXT	SEGMENT
?GetSerialNumber@CItemBase@@QAEKXZ PROC NEAR		; CItemBase::GetSerialNumber, COMDAT
; _this$ = ecx

; 142  : 	SERIALNUMBER	GetSerialNumber( void )	{	return m_liSerialNumber;	}

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	c3		 ret	 0
?GetSerialNumber@CItemBase@@QAEKXZ ENDP			; CItemBase::GetSerialNumber
_TEXT	ENDS
PUBLIC	?SetSerialNumber@CItemBase@@QAEXK@Z		; CItemBase::SetSerialNumber
; Function compile flags: /Ogty
;	COMDAT ?SetSerialNumber@CItemBase@@QAEXK@Z
_TEXT	SEGMENT
_liSerialNumber$ = 8					; size = 4
?SetSerialNumber@CItemBase@@QAEXK@Z PROC NEAR		; CItemBase::SetSerialNumber, COMDAT
; _this$ = ecx

; 143  : 	void	SetSerialNumber( SERIALNUMBER liSerialNumber )	{	m_liSerialNumber	= liSerialNumber;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _liSerialNumber$[esp-4]
  00004	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00007	c2 04 00	 ret	 4
?SetSerialNumber@CItemBase@@QAEXK@Z ENDP		; CItemBase::SetSerialNumber
_TEXT	ENDS
PUBLIC	?SetPiercingSize@CItemElem@@QAEXH@Z		; CItemElem::SetPiercingSize
EXTRN	?SetPiercingSize@CPiercing@@QAEXH@Z:NEAR	; CPiercing::SetPiercingSize
; Function compile flags: /Ogty
;	COMDAT ?SetPiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetPiercingSize@CItemElem@@QAEXH@Z PROC NEAR		; CItemElem::SetPiercingSize, COMDAT
; _this$ = ecx

; 152  : 	void	SetPiercingSize( int nSize )	{	m_piercing.SetPiercingSize( nSize ); }

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?SetPiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetPiercingSize
?SetPiercingSize@CItemElem@@QAEXH@Z ENDP		; CItemElem::SetPiercingSize
_TEXT	ENDS
PUBLIC	?GetPiercingSize@CItemElem@@QAEHXZ		; CItemElem::GetPiercingSize
EXTRN	?GetPiercingSize@CPiercing@@QAEHXZ:NEAR		; CPiercing::GetPiercingSize
; Function compile flags: /Ogty
;	COMDAT ?GetPiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetPiercingSize@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::GetPiercingSize, COMDAT
; _this$ = ecx

; 153  : 	int		GetPiercingSize()	{	return m_piercing.GetPiercingSize();		}

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
?GetPiercingSize@CItemElem@@QAEHXZ ENDP			; CItemElem::GetPiercingSize
_TEXT	ENDS
PUBLIC	?SetPiercingItem@CItemElem@@QAEXHK@Z		; CItemElem::SetPiercingItem
EXTRN	?SetPiercingItem@CPiercing@@QAEXHK@Z:NEAR	; CPiercing::SetPiercingItem
; Function compile flags: /Ogty
;	COMDAT ?SetPiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
_dwItem$ = 12						; size = 4
?SetPiercingItem@CItemElem@@QAEXHK@Z PROC NEAR		; CItemElem::SetPiercingItem, COMDAT
; _this$ = ecx

; 154  : 	void	SetPiercingItem( int nth, DWORD dwItem)	{	m_piercing.SetPiercingItem( nth, dwItem );	}

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?SetPiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetPiercingItem
?SetPiercingItem@CItemElem@@QAEXHK@Z ENDP		; CItemElem::SetPiercingItem
_TEXT	ENDS
PUBLIC	?SetUltimatePiercingSize@CItemElem@@QAEXH@Z	; CItemElem::SetUltimatePiercingSize
EXTRN	?SetUltimatePiercingSize@CPiercing@@QAEXH@Z:NEAR ; CPiercing::SetUltimatePiercingSize
; Function compile flags: /Ogty
;	COMDAT ?SetUltimatePiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetUltimatePiercingSize@CItemElem@@QAEXH@Z PROC NEAR	; CItemElem::SetUltimatePiercingSize, COMDAT
; _this$ = ecx

; 161  : 	void	SetUltimatePiercingSize( int nSize )	{	m_piercing.SetUltimatePiercingSize( nSize );	}

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?SetUltimatePiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetUltimatePiercingSize
?SetUltimatePiercingSize@CItemElem@@QAEXH@Z ENDP	; CItemElem::SetUltimatePiercingSize
_TEXT	ENDS
PUBLIC	?GetUltimatePiercingSize@CItemElem@@QAEHXZ	; CItemElem::GetUltimatePiercingSize
EXTRN	?GetUltimatePiercingSize@CPiercing@@QAEHXZ:NEAR	; CPiercing::GetUltimatePiercingSize
; Function compile flags: /Ogty
;	COMDAT ?GetUltimatePiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetUltimatePiercingSize@CItemElem@@QAEHXZ PROC NEAR	; CItemElem::GetUltimatePiercingSize, COMDAT
; _this$ = ecx

; 162  : 	int		GetUltimatePiercingSize()	{	return m_piercing.GetUltimatePiercingSize();		}

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?GetUltimatePiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetUltimatePiercingSize
?GetUltimatePiercingSize@CItemElem@@QAEHXZ ENDP		; CItemElem::GetUltimatePiercingSize
_TEXT	ENDS
PUBLIC	?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z	; CItemElem::SetUltimatePiercingItem
EXTRN	?SetUltimatePiercingItem@CPiercing@@QAEXHK@Z:NEAR ; CPiercing::SetUltimatePiercingItem
; Function compile flags: /Ogty
;	COMDAT ?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
_dwItem$ = 12						; size = 4
?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z PROC NEAR	; CItemElem::SetUltimatePiercingItem, COMDAT
; _this$ = ecx

; 163  : 	void	SetUltimatePiercingItem( int nth, DWORD dwItem )	{	m_piercing.SetUltimatePiercingItem( nth, dwItem );	}

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?SetUltimatePiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetUltimatePiercingItem
?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z ENDP	; CItemElem::SetUltimatePiercingItem
_TEXT	ENDS
PUBLIC	?SetRandomOptItemId@CItemElem@@QAEX_J@Z		; CItemElem::SetRandomOptItemId
; Function compile flags: /Ogty
;	COMDAT ?SetRandomOptItemId@CItemElem@@QAEX_J@Z
_TEXT	SEGMENT
_iRandomOptItemId$ = 8					; size = 8
?SetRandomOptItemId@CItemElem@@QAEX_J@Z PROC NEAR	; CItemElem::SetRandomOptItemId, COMDAT
; _this$ = ecx

; 197  : 	void	SetRandomOptItemId( __int64 iRandomOptItemId )	{	m_iRandomOptItemId	= iRandomOptItemId;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _iRandomOptItemId$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR _iRandomOptItemId$[esp]
  00008	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax
  0000e	89 91 94 00 00
	00		 mov	 DWORD PTR [ecx+148], edx
  00014	c2 08 00	 ret	 8
?SetRandomOptItemId@CItemElem@@QAEX_J@Z ENDP		; CItemElem::SetRandomOptItemId
_TEXT	ENDS
PUBLIC	?GetOption@CItemElem@@QAEHXZ			; CItemElem::GetOption
; Function compile flags: /Ogty
;	COMDAT ?GetOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetOption@CItemElem@@QAEHXZ PROC NEAR			; CItemElem::GetOption, COMDAT
; _this$ = ecx

; 218  : 	int		GetOption( void )			{ return m_nAbilityOption;	}

  00000	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00003	c3		 ret	 0
?GetOption@CItemElem@@QAEHXZ ENDP			; CItemElem::GetOption
_TEXT	ENDS
PUBLIC	?SetOption@CItemElem@@QAEXH@Z			; CItemElem::SetOption
; Function compile flags: /Ogty
;	COMDAT ?SetOption@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nOption$ = 8						; size = 4
?SetOption@CItemElem@@QAEXH@Z PROC NEAR			; CItemElem::SetOption, COMDAT
; _this$ = ecx

; 219  : 	void	SetOption( int nOption )	{ m_nAbilityOption = nOption; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nOption$[esp-4]
  00004	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00007	c2 04 00	 ret	 4
?SetOption@CItemElem@@QAEXH@Z ENDP			; CItemElem::SetOption
_TEXT	ENDS
PUBLIC	?SetVisKeepTime@CItemElem@@QAEXHJ@Z		; CItemElem::SetVisKeepTime
EXTRN	?SetVisKeepTime@CPiercing@@QAEXHJ@Z:NEAR	; CPiercing::SetVisKeepTime
; Function compile flags: /Ogty
;	COMDAT ?SetVisKeepTime@CItemElem@@QAEXHJ@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
_tmKeep$ = 12						; size = 4
?SetVisKeepTime@CItemElem@@QAEXHJ@Z PROC NEAR		; CItemElem::SetVisKeepTime, COMDAT
; _this$ = ecx

; 238  : 	void	SetVisKeepTime( int nth, time_t tmKeep )	{ m_piercing.SetVisKeepTime( nth, tmKeep ); }

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?SetVisKeepTime@CPiercing@@QAEXHJ@Z ; CPiercing::SetVisKeepTime
?SetVisKeepTime@CItemElem@@QAEXHJ@Z ENDP		; CItemElem::SetVisKeepTime
_TEXT	ENDS
PUBLIC	?SetExpired@CPocket@@QAEXH@Z			; CPocket::SetExpired
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pocket.h
;	COMDAT ?SetExpired@CPocket@@QAEXH@Z
_TEXT	SEGMENT
_bExpired$ = 8						; size = 4
?SetExpired@CPocket@@QAEXH@Z PROC NEAR			; CPocket::SetExpired, COMDAT
; _this$ = ecx

; 18   : 	void	SetExpired( BOOL bExpired )	{	m_bExpired	= bExpired;		}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bExpired$[esp-4]
  00004	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00007	c2 04 00	 ret	 4
?SetExpired@CPocket@@QAEXH@Z ENDP			; CPocket::SetExpired
_TEXT	ENDS
PUBLIC	?SetExpirationDate@CPocket@@QAEXJ@Z		; CPocket::SetExpirationDate
; Function compile flags: /Ogty
;	COMDAT ?SetExpirationDate@CPocket@@QAEXJ@Z
_TEXT	SEGMENT
_tExpirationDate$ = 8					; size = 4
?SetExpirationDate@CPocket@@QAEXJ@Z PROC NEAR		; CPocket::SetExpirationDate, COMDAT
; _this$ = ecx

; 20   : 	void	SetExpirationDate( time_t tExpirationDate )	{	m_tExpirationDate	= tExpirationDate;		}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _tExpirationDate$[esp-4]
  00004	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00007	c2 04 00	 ret	 4
?SetExpirationDate@CPocket@@QAEXJ@Z ENDP		; CPocket::SetExpirationDate
_TEXT	ENDS
PUBLIC	?SetTutorialState@CMover@@QAEXH@Z		; CMover::SetTutorialState
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?SetTutorialState@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nTutorialState$ = 8					; size = 4
?SetTutorialState@CMover@@QAEXH@Z PROC NEAR		; CMover::SetTutorialState, COMDAT
; _this$ = ecx

; 978  : 	void	SetTutorialState( int nTutorialState )	{	m_nTutorialState	= nTutorialState;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nTutorialState$[esp-4]
  00004	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax
  0000a	c2 04 00	 ret	 4
?SetTutorialState@CMover@@QAEXH@Z ENDP			; CMover::SetTutorialState
_TEXT	ENDS
PUBLIC	?SetHonorCount@CMover@@QAEXHH@Z			; CMover::SetHonorCount
; Function compile flags: /Ogty
;	COMDAT ?SetHonorCount@CMover@@QAEXHH@Z
_TEXT	SEGMENT
_nIdx$ = 8						; size = 4
_nCount$ = 12						; size = 4
?SetHonorCount@CMover@@QAEXHH@Z PROC NEAR		; CMover::SetHonorCount, COMDAT
; _this$ = ecx

; 1106 : 	void			SetHonorCount(int nIdx , int nCount )	{	m_aHonorTitle[nIdx] = nCount;	}

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nCount$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _nIdx$[esp-4]
  00008	89 84 91 48 42
	00 00		 mov	 DWORD PTR [ecx+edx*4+16968], eax
  0000f	c2 08 00	 ret	 8
?SetHonorCount@CMover@@QAEXHH@Z ENDP			; CMover::SetHonorCount
_TEXT	ENDS
PUBLIC	?SetSex@CMover@@QAEXE@Z				; CMover::SetSex
; Function compile flags: /Ogty
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT
_bySex$ = 8						; size = 1
?SetSex@CMover@@QAEXE@Z PROC NEAR			; CMover::SetSex, COMDAT
; _this$ = ecx

; 1198 : 	void	SetSex( BYTE bySex ) { m_bySex = bySex; }

  00000	8a 44 24 04	 mov	 al, BYTE PTR _bySex$[esp-4]
  00004	88 81 b8 00 00
	00		 mov	 BYTE PTR [ecx+184], al
  0000a	c2 04 00	 ret	 4
?SetSex@CMover@@QAEXE@Z ENDP				; CMover::SetSex
_TEXT	ENDS
PUBLIC	?GetGold@CMover@@QAEHXZ				; CMover::GetGold
; Function compile flags: /Ogty
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetGold@CMover@@QAEHXZ PROC NEAR			; CMover::GetGold, COMDAT
; _this$ = ecx

; 1230 : 	ASSERT( m_dwGold <= INT_MAX );
; 1231 : 	return m_dwGold;

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]

; 1232 : }

  00003	c3		 ret	 0
?GetGold@CMover@@QAEHXZ ENDP				; CMover::GetGold
_TEXT	ENDS
PUBLIC	?SetGold@CMover@@QAEXH@Z			; CMover::SetGold
; Function compile flags: /Ogty
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nGold$ = 8						; size = 4
?SetGold@CMover@@QAEXH@Z PROC NEAR			; CMover::SetGold, COMDAT
; _this$ = ecx

; 1236 : 	ASSERT( nGold >= 0 );
; 1237 : 	m_dwGold = (DWORD)nGold;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nGold$[esp-4]
  00004	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 1238 : }

  00007	c2 04 00	 ret	 4
?SetGold@CMover@@QAEXH@Z ENDP				; CMover::SetGold
_TEXT	ENDS
PUBLIC	__real@4f000000
PUBLIC	__real@00000000
PUBLIC	?AddGold@CMover@@QAEHHH@Z			; CMover::AddGold
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@4f000000
CONST	SEGMENT
__real@4f000000 DD 04f000000r			; 2.14748e+009
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?AddGold@CMover@@QAEHHH@Z
_TEXT	SEGMENT
_nGold$ = 8						; size = 4
_bSend$ = 12						; size = 4
?AddGold@CMover@@QAEHHH@Z PROC NEAR			; CMover::AddGold, COMDAT
; _this$ = ecx

; 1242 : 	if( nGold == 0 )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nGold$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1243 : 		return TRUE;

  00009	74 24		 je	 SHORT $L212209

; 1244 : 
; 1245 : #ifdef __PERIN_BUY_BUG
; 1246 : 	float fTotal = static_cast<float>( GetGold() ) + static_cast<float>( nGold );

  0000b	db 46 34	 fild	 DWORD PTR [esi+52]
  0000e	da 44 24 08	 fiadd	 DWORD PTR _nGold$[esp]

; 1247 : 	if( fTotal > static_cast<float>( INT_MAX ) )

  00012	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@4f000000
  00018	df e0		 fnstsw	 ax
  0001a	f6 c4 41	 test	 ah, 65			; 00000041H
  0001d	75 19		 jne	 SHORT $L177648
  0001f	dd d8		 fstp	 ST(0)

; 1248 : 		fTotal = static_cast<float>( INT_MAX );

  00021	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4f000000
$L177651:

; 1251 : 
; 1252 : 	SetGold( static_cast<int>( fTotal ) );

  00027	e8 00 00 00 00	 call	 __ftol2
  0002c	89 46 34	 mov	 DWORD PTR [esi+52], eax
$L212209:

; 1253 : #else // __PERIN_BUY_BUG
; 1254 : 	int nTotal = GetGold() + nGold;
; 1255 : 
; 1256 : 	if( nGold > 0 )
; 1257 : 	{
; 1258 : 		if( nTotal < 0 )		// overflow?
; 1259 : 			nTotal = INT_MAX;
; 1260 : 	}
; 1261 : 	else
; 1262 : 	{
; 1263 : 		if( nTotal < 0 )		// underflow?
; 1264 : 			return FALSE;
; 1265 : 	}
; 1266 : 
; 1267 : 	SetGold( nTotal );
; 1268 : #endif // __PERIN_BUY_BUG
; 1269 : 	if( bSend )
; 1270 : 	{
; 1271 : 	#ifdef __WORLDSERVER
; 1272 : 		g_UserMng.AddSetPointParam( this, DST_GOLD, nTotal );
; 1273 : 	#endif	// __WORLDSERVER
; 1274 : 	}
; 1275 : 
; 1276 : 	return TRUE;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	5e		 pop	 esi

; 1277 : }

  00035	c2 08 00	 ret	 8
$L177648:

; 1249 : 	else if( fTotal < 0.0f )

  00038	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  0003e	df e0		 fnstsw	 ax
  00040	f6 c4 05	 test	 ah, 5
  00043	7a e2		 jp	 SHORT $L177651
  00045	dd d8		 fstp	 ST(0)

; 1250 : 		return FALSE;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 1277 : }

  0004a	c2 08 00	 ret	 8
?AddGold@CMover@@QAEHHH@Z ENDP				; CMover::AddGold
_TEXT	ENDS
PUBLIC	?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
EXTRN	?FreeRequest@CDbManager@@QAEXPAUtagDB_OVERLAPPED_PLUS@@@Z:NEAR ; CDbManager::FreeRequest
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanager.h
;	COMDAT ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_lpString$ = 8						; size = 4
_lpFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_lpName$ = 20						; size = 4
_lpOverlapped$ = 24					; size = 4
?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::VerifyString, COMDAT
; _this$ = ecx

; 1304 : {

  00000	56		 push	 esi

; 1305 : 	int len		= strlen( lpString );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _lpString$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	8d 49 00	 npad	 3
$L212213:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L212213
  00017	2b c2		 sub	 eax, edx

; 1306 : 	if( len > 0 && lpString[len-1] == '$' )

  00019	85 c0		 test	 eax, eax
  0001b	7e 11		 jle	 SHORT $L182944
  0001d	80 7c 30 ff 24	 cmp	 BYTE PTR [eax+esi-1], 36 ; 00000024H
  00022	75 0a		 jne	 SHORT $L182944
  00024	5f		 pop	 edi

; 1307 : 		return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	5e		 pop	 esi

; 1312 : }

  0002b	c2 14 00	 ret	 20			; 00000014H
$L182944:

; 1308 : 	WriteLog( "%s, %d\t%s", lpFileName, nLine, lpName );

  0002e	8b 44 24 18	 mov	 eax, DWORD PTR _lpName$[esp+4]
  00032	8b 4c 24 14	 mov	 ecx, DWORD PTR _nLine$[esp+4]
  00036	8b 54 24 10	 mov	 edx, DWORD PTR _lpFileName$[esp+4]
  0003a	50		 push	 eax
  0003b	51		 push	 ecx
  0003c	52		 push	 edx
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  00042	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog

; 1309 : 	if( NULL != lpOverlapped )

  00047	8b 44 24 2c	 mov	 eax, DWORD PTR _lpOverlapped$[esp+20]
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	85 c0		 test	 eax, eax
  00050	74 08		 je	 SHORT $L182946

; 1310 : 		FreeRequest( lpOverlapped );

  00052	50		 push	 eax
  00053	8b cf		 mov	 ecx, edi
  00055	e8 00 00 00 00	 call	 ?FreeRequest@CDbManager@@QAEXPAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::FreeRequest
$L182946:
  0005a	5f		 pop	 edi

; 1311 : 	return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 1312 : }

  0005e	c2 14 00	 ret	 20			; 00000014H
?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::VerifyString
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1109 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1110 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBKPAVIBuff@@@std@@QAE@ABKABQAVIBuff@@@Z ; std::pair<unsigned long const ,IBuff *>::pair<unsigned long const ,IBuff *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@$$CBKPAVIBuff@@@std@@QAE@ABKABQAVIBuff@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBKPAVIBuff@@@std@@QAE@ABKABQAVIBuff@@@Z PROC NEAR ; std::pair<unsigned long const ,IBuff *>::pair<unsigned long const ,IBuff *>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@$$CBKPAVIBuff@@@std@@QAE@ABKABQAVIBuff@@@Z ENDP ; std::pair<unsigned long const ,IBuff *>::pair<unsigned long const ,IBuff *>
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L212220
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  00009	c3		 ret	 0
$L212220:

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??R?$less@K@std@@QBE_NABK0@Z			; std::less<unsigned long>::operator()
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@K@std@@QBE_NABK0@Z PROC NEAR			; std::less<unsigned long>::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (_Left < _Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 54 24 08	 mov	 edx, DWORD PTR __Right$[esp-4]
  0000a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000c	1b c0		 sbb	 eax, eax
  0000e	f7 d8		 neg	 eax

; 140  : 		}

  00010	c2 08 00	 ret	 8
??R?$less@K@std@@QBE_NABK0@Z ENDP			; std::less<unsigned long>::operator()
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVIBuff@@@2@@Z ; std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVIBuff@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVIBuff@@@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVIBuff@@@2@@Z ENDP ; std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator,bool>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00010	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ; std::vector<long,std::allocator<long> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ PROC NEAR ; std::vector<long,std::allocator<long> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L212248
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L212248:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ENDP	; std::vector<long,std::allocator<long> >::size
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L212252
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  00009	c3		 ret	 0
$L212252:

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z PROC NEAR ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Color
; Function compile flags: /Ogty
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Color, COMDAT

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00007	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rmost
; Function compile flags: /Ogty
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1049 : 		return (_Right(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ; std::vector<long,std::allocator<long> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ PROC NEAR ; std::vector<long,std::allocator<long> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L212288
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L212288:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ENDP ; std::vector<long,std::allocator<long> >::capacity
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@J@std@@QAEXPAJI@Z	; std::allocator<long>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@J@std@@QAEXPAJI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@J@std@@QAEXPAJI@Z PROC NEAR	; std::allocator<long>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@J@std@@QAEXPAJI@Z ENDP		; std::allocator<long>::deallocate
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z ; std::vector<long,std::allocator<long> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<long,std::allocator<long> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<long,std::allocator<long> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00001	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  00004	83 fe 10	 cmp	 esi, 16			; 00000010H
  00007	57		 push	 edi
  00008	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0000b	72 04		 jb	 SHORT $L212300
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	eb 02		 jmp	 SHORT $L212301
$L212300:
  00011	8b d0		 mov	 edx, eax
$L212301:
  00013	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00017	3b fa		 cmp	 edi, edx
  00019	72 17		 jb	 SHORT $L185560
  0001b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0001e	72 02		 jb	 SHORT $L212308
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L212308:
  00022	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00025	03 c8		 add	 ecx, eax
  00027	3b cf		 cmp	 ecx, edi
  00029	76 07		 jbe	 SHORT $L185560
  0002b	5f		 pop	 edi

; 1497 : 		else
; 1498 : 			return (true);

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi

; 1499 : 		}

  0002f	c2 04 00	 ret	 4
$L185560:
  00032	5f		 pop	 edi

; 1496 : 			return (false);	// don't ask

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 1499 : 		}

  00036	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 2d	 add	 eax, 45			; 0000002dH

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,IBuff *> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<unsigned long const ,IBuff *> >::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,IBuff *> >::max_size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@J@std@@QBEIXZ		; std::allocator<long>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@J@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@J@std@@QBEIXZ PROC NEAR		; std::allocator<long>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@J@std@@QBEIXZ ENDP		; std::allocator<long>::max_size
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ; std::vector<long,std::allocator<long> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ENDP ; std::vector<long,std::allocator<long> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ; std::vector<long,std::allocator<long> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<long,std::allocator<long> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 156  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<long,std::allocator<long> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node::_Node
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 40   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  00010	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00013	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0001f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00022	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00026	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00029	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0002c	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00030	c2 14 00	 ret	 20			; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 159  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Parent
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Max
; Function compile flags: /Ogty
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Max, COMDAT

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0000a	84 d2		 test	 dl, dl
  0000c	75 0e		 jne	 SHORT $L186093
  0000e	8b ff		 npad	 2
$L186092:

; 1036 : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00018	84 d2		 test	 dl, dl
  0001a	74 f4		 je	 SHORT $L186092
$L186093:

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0001c	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ; CFixedArray<ItemProp>::GetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z PROC NEAR ; CFixedArray<ItemProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L186281

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L186281:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ENDP ; CFixedArray<ItemProp>::GetAt
_TEXT	ENDS
PUBLIC	??$copy@PAJPAJ@std@@YAPAJPAJ00@Z		; std::copy<long *,long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAJPAJ@std@@YAPAJPAJ00@Z PROC NEAR		; std::copy<long *,long *>, COMDAT

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1041 : 	}

  00027	c3		 ret	 0
??$copy@PAJPAJ@std@@YAPAJPAJ00@Z ENDP			; std::copy<long *,long *>
_TEXT	ENDS
PUBLIC	??$fill@PAJJ@std@@YAXPAJ0ABJ@Z			; std::fill<long *,long>
; Function compile flags: /Ogty
;	COMDAT ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAJJ@std@@YAXPAJ0ABJ@Z PROC NEAR		; std::fill<long *,long>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L186450
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L186448:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L186448
  0001c	5e		 pop	 esi
$L186450:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAJJ@std@@YAXPAJ0ABJ@Z ENDP			; std::fill<long *,long>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z	; std::copy_backward<long *,long *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z PROC NEAR	; std::copy_backward<long *,long *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z ENDP		; std::copy_backward<long *,long *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z ; std::_Destroy_range<long,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z PROC NEAR ; std::_Destroy_range<long,std::allocator<long> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z ENDP ; std::_Destroy_range<long,std::allocator<long> >
_TEXT	ENDS
PUBLIC	??$_Allocate@J@std@@YAPAJIPAJ@Z			; std::_Allocate<long>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@J@std@@YAPAJIPAJ@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@J@std@@YAPAJIPAJ@Z PROC NEAR		; std::_Allocate<long>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@J@std@@YAPAJIPAJ@Z ENDP			; std::_Allocate<long>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	?GetStrTime@CDbManager@@AAEXPAVCTime@ATL@@PBD@Z	; CDbManager::GetStrTime
EXTRN	_strncpy:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
;	COMDAT ?GetStrTime@CDbManager@@AAEXPAVCTime@ATL@@PBD@Z
_TEXT	SEGMENT
_cDay$ = -36						; size = 3
_cMonth$ = -32						; size = 3
_cHour$ = -28						; size = 3
_cMin$ = -24						; size = 3
_Timebuf$ = -20						; size = 8
_cYear$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_time$ = 8						; size = 4
_strbuf$ = 12						; size = 4
?GetStrTime@CDbManager@@AAEXPAVCTime@ATL@@PBD@Z PROC NEAR ; CDbManager::GetStrTime, COMDAT
; _this$ = ecx

; 60   : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b 74 24 34	 mov	 esi, DWORD PTR _strbuf$[esp+40]

; 61   : 	char cYear[5] = {0,};

  00010	33 db		 xor	 ebx, ebx
  00012	57		 push	 edi
  00013	8b 7c 24 34	 mov	 edi, DWORD PTR _time$[esp+44]

; 62   : 	char cMonth[3] = {0,};
; 63   : 	char cDay[3] = {0,};
; 64   : 	char cHour[3] = {0,};
; 65   : 	char cMin[3] = {0,};
; 66   : 	
; 67   : 	strncpy(cYear, strbuf, 4);

  00017	6a 04		 push	 4
  00019	89 44 24 30	 mov	 DWORD PTR __$ArrayPad$[esp+52], eax
  0001d	8d 44 24 28	 lea	 eax, DWORD PTR _cYear$[esp+52]
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	88 5c 24 30	 mov	 BYTE PTR _cYear$[esp+60], bl
  00027	89 5c 24 31	 mov	 DWORD PTR _cYear$[esp+61], ebx
  0002b	88 5c 24 1c	 mov	 BYTE PTR _cMonth$[esp+60], bl
  0002f	66 89 5c 24 1d	 mov	 WORD PTR _cMonth$[esp+61], bx
  00034	88 5c 24 18	 mov	 BYTE PTR _cDay$[esp+60], bl
  00038	66 89 5c 24 19	 mov	 WORD PTR _cDay$[esp+61], bx
  0003d	88 5c 24 20	 mov	 BYTE PTR _cHour$[esp+60], bl
  00041	66 89 5c 24 21	 mov	 WORD PTR _cHour$[esp+61], bx
  00046	88 5c 24 24	 mov	 BYTE PTR _cMin$[esp+60], bl
  0004a	66 89 5c 24 25	 mov	 WORD PTR _cMin$[esp+61], bx
  0004f	e8 00 00 00 00	 call	 _strncpy

; 68   : 	strncpy(cMonth, strbuf + 4, 2 );

  00054	6a 02		 push	 2
  00056	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00059	51		 push	 ecx
  0005a	8d 54 24 24	 lea	 edx, DWORD PTR _cMonth$[esp+68]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _strncpy

; 69   : 	strncpy(cDay, strbuf + 6, 2 );

  00064	6a 02		 push	 2
  00066	8d 46 06	 lea	 eax, DWORD PTR [esi+6]
  00069	50		 push	 eax
  0006a	8d 4c 24 2c	 lea	 ecx, DWORD PTR _cDay$[esp+80]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _strncpy

; 70   : 	strncpy(cHour, strbuf + 8, 2 );

  00074	6a 02		 push	 2
  00076	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  00079	52		 push	 edx
  0007a	8d 44 24 40	 lea	 eax, DWORD PTR _cHour$[esp+92]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _strncpy

; 71   : 	strncpy(cMin, strbuf + 10, 2 );

  00084	6a 02		 push	 2
  00086	83 c6 0a	 add	 esi, 10			; 0000000aH
  00089	8d 4c 24 4c	 lea	 ecx, DWORD PTR _cMin$[esp+100]
  0008d	56		 push	 esi
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _strncpy
  00094	83 c4 3c	 add	 esp, 60			; 0000003cH

; 72   : 	
; 73   : 	CTime Timebuf( atoi(cYear), atoi(cMonth), atoi(cDay), atoi(cHour), atoi(cMin), 0 );

  00097	6a ff		 push	 -1
  00099	8d 54 24 1c	 lea	 edx, DWORD PTR _cMin$[esp+52]
  0009d	53		 push	 ebx
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 _atoi
  000a4	83 c4 04	 add	 esp, 4
  000a7	50		 push	 eax
  000a8	8d 44 24 20	 lea	 eax, DWORD PTR _cHour$[esp+60]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _atoi
  000b2	83 c4 04	 add	 esp, 4
  000b5	50		 push	 eax
  000b6	8d 4c 24 1c	 lea	 ecx, DWORD PTR _cDay$[esp+64]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _atoi
  000c0	83 c4 04	 add	 esp, 4
  000c3	50		 push	 eax
  000c4	8d 54 24 24	 lea	 edx, DWORD PTR _cMonth$[esp+68]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _atoi
  000ce	83 c4 04	 add	 esp, 4
  000d1	50		 push	 eax
  000d2	8d 44 24 3c	 lea	 eax, DWORD PTR _cYear$[esp+72]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _atoi
  000dc	83 c4 04	 add	 esp, 4
  000df	50		 push	 eax
  000e0	8d 4c 24 38	 lea	 ecx, DWORD PTR _Timebuf$[esp+76]
  000e4	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@HHHHHHH@Z ; ATL::CTime::CTime

; 74   : 	*time = Timebuf;

  000e9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _Timebuf$[esp+48]
  000ed	8b 54 24 20	 mov	 edx, DWORD PTR _Timebuf$[esp+52]
  000f1	89 0f		 mov	 DWORD PTR [edi], ecx

; 75   : }

  000f3	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+48]
  000f7	89 57 04	 mov	 DWORD PTR [edi+4], edx
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	33 cc		 xor	 ecx, esp
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	83 c4 24	 add	 esp, 36			; 00000024H
  00107	c2 08 00	 ret	 8
?GetStrTime@CDbManager@@AAEXPAVCTime@ATL@@PBD@Z ENDP	; CDbManager::GetStrTime
_TEXT	ENDS
PUBLIC	??_C@_0P@MCBMMJCE@m_adwEquipment?$AA@		; `string'
PUBLIC	?GetEquipment@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetEquipment
;	COMDAT ??_C@_0P@MCBMMJCE@m_adwEquipment?$AA@
CONST	SEGMENT
??_C@_0P@MCBMMJCE@m_adwEquipment?$AA@ DB 'm_adwEquipment', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetEquipment@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_CountStr$ = -524					; size = 4
$T212405 = -520						; size = 4
$T212406 = -516						; size = 4
_Equipment$ = -512					; size = 500
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetEquipment@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetEquipment, COMDAT
; _this$ = ecx

; 945  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	8b 55 0c	 mov	 edx, DWORD PTR _qry$[ebp]
  00014	33 c5		 xor	 eax, ebp
  00016	53		 push	 ebx
  00017	89 84 24 0c 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+528], eax
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pMover$[ebp]
  00021	56		 push	 esi
  00022	8b 75 10	 mov	 esi, DWORD PTR _lpDbOverlappedPlus$[ebp]
  00025	57		 push	 edi
  00026	89 4c 24 10	 mov	 DWORD PTR $T212405[esp+536], ecx

; 955  : 		IndexEquipment++;

  0002a	89 44 24 14	 mov	 DWORD PTR $T212406[esp+536], eax
  0002e	33 db		 xor	 ebx, ebx
  00030	88 5c 24 18	 mov	 BYTE PTR _Equipment$[esp+536], bl
  00034	33 c0		 xor	 eax, eax
  00036	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  0003b	8d 7c 24 19	 lea	 edi, DWORD PTR _Equipment$[esp+537]
  0003f	f3 ab		 rep stosd
  00041	8d 4c 24 18	 lea	 ecx, DWORD PTR _Equipment$[esp+536]
  00045	66 ab		 stosw
  00047	51		 push	 ecx
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@MCBMMJCE@m_adwEquipment?$AA@
  0004d	8b ca		 mov	 ecx, edx
  0004f	89 5c 24 14	 mov	 DWORD PTR _CountStr$[esp+544], ebx
  00053	aa		 stosb
  00054	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00059	8b 4c 24 10	 mov	 ecx, DWORD PTR $T212405[esp+536]
  0005d	56		 push	 esi
  0005e	83 c6 74	 add	 esi, 116		; 00000074H
  00061	56		 push	 esi
  00062	68 b6 03 00 00	 push	 950			; 000003b6H
  00067	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0006c	8d 54 24 28	 lea	 edx, DWORD PTR _Equipment$[esp+552]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00076	85 c0		 test	 eax, eax
  00078	75 17		 jne	 SHORT $L212409

; 956  : 	}
; 957  : 	return TRUE;
; 958  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b 8c 24 08 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+524]
  00084	33 cd		 xor	 ecx, ebp
  00086	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 0c 00	 ret	 12			; 0000000cH
$L212409:

; 946  : 	int CountStr	= 0;
; 947  : 	int IndexEquipment	= 0;
; 948  : 	char Equipment[500]		= {0,};
; 949  : 	qry->GetStr( "m_adwEquipment", Equipment );
; 950  : 	VERIFYSTRING_RETURN( Equipment, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 951  : 	while( '$' != Equipment[CountStr] )

  00091	80 7c 24 18 24	 cmp	 BYTE PTR _Equipment$[esp+536], 36 ; 00000024H
  00096	74 33		 je	 SHORT $L209136
  00098	8b 74 24 14	 mov	 esi, DWORD PTR $T212406[esp+536]
  0009c	81 c6 24 45 00
	00		 add	 esi, 17700		; 00004524H
$L209135:

; 952  : 	{
; 953  : 		if( IndexEquipment < MAX_HUMAN_PARTS )

  000a2	83 fb 1f	 cmp	 ebx, 31			; 0000001fH
  000a5	7d 14		 jge	 SHORT $L209137

; 954  : 			pMover->m_aEquipInfo[IndexEquipment].dwId	= (DWORD)GetIntFromStr( Equipment, &CountStr );

  000a7	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+536]
  000ab	50		 push	 eax
  000ac	8d 4c 24 1c	 lea	 ecx, DWORD PTR _Equipment$[esp+540]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  000b6	83 c4 08	 add	 esp, 8
  000b9	89 06		 mov	 DWORD PTR [esi], eax
$L209137:
  000bb	8b 54 24 0c	 mov	 edx, DWORD PTR _CountStr$[esp+536]
  000bf	8a 44 14 18	 mov	 al, BYTE PTR _Equipment$[esp+edx+536]

; 955  : 		IndexEquipment++;

  000c3	43		 inc	 ebx
  000c4	83 c6 0c	 add	 esi, 12			; 0000000cH
  000c7	3c 24		 cmp	 al, 36			; 00000024H
  000c9	75 d7		 jne	 SHORT $L209135
$L209136:

; 956  : 	}
; 957  : 	return TRUE;
; 958  : }

  000cb	8b 8c 24 14 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+536]
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	33 cd		 xor	 ecx, ebp
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	5b		 pop	 ebx
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 0c 00	 ret	 12			; 0000000cH
?GetEquipment@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetEquipment
_TEXT	ENDS
PUBLIC	??_C@_0O@GNBKFLOM@m_aSlotApplet?$AA@		; `string'
PUBLIC	??_C@_0M@OJJDLIJE@m_aSlotItem?$AA@		; `string'
PUBLIC	??_C@_0N@CPNBAAIJ@m_aSlotQueue?$AA@		; `string'
PUBLIC	??_C@_0L@NJKCPPDJ@m_SkillBar?$AA@		; `string'
PUBLIC	?GetTaskBar@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetTaskBar
;	COMDAT ??_C@_0O@GNBKFLOM@m_aSlotApplet?$AA@
CONST	SEGMENT
??_C@_0O@GNBKFLOM@m_aSlotApplet?$AA@ DB 'm_aSlotApplet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OJJDLIJE@m_aSlotItem?$AA@
CONST	SEGMENT
??_C@_0M@OJJDLIJE@m_aSlotItem?$AA@ DB 'm_aSlotItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CPNBAAIJ@m_aSlotQueue?$AA@
CONST	SEGMENT
??_C@_0N@CPNBAAIJ@m_aSlotQueue?$AA@ DB 'm_aSlotQueue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NJKCPPDJ@m_SkillBar?$AA@
CONST	SEGMENT
??_C@_0L@NJKCPPDJ@m_SkillBar?$AA@ DB 'm_SkillBar', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetTaskBar@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_CountStr$ = -30452					; size = 4
$T212414 = -30448					; size = 4
$T212416 = -30444					; size = 4
$T212417 = -30440					; size = 4
tv416 = -30436						; size = 4
_SkillTaskBar$ = -30432					; size = 1024
_AppletTaskBar$ = -29408				; size = 5400
_ItemTaskBar$ = -24008					; size = 24000
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetTaskBar@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetTaskBar, COMDAT
; _this$ = ecx

; 961  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 f4 76 00 00	 mov	 eax, 30452		; 000076f4H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	8b 55 0c	 mov	 edx, DWORD PTR _qry$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _pMover$[ebp]
  0001c	33 c5		 xor	 eax, ebp
  0001e	56		 push	 esi
  0001f	8b 75 10	 mov	 esi, DWORD PTR _lpDbOverlappedPlus$[ebp]
  00022	57		 push	 edi
  00023	89 84 24 fc 76
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+30464], eax
  0002a	89 4c 24 10	 mov	 DWORD PTR $T212414[esp+30464], ecx

; 962  : 	int CountStr	= 0;
; 963  : 	int nIndex	= 0;
; 964  : 	char AppletTaskBar[MAX_APPLETTASKBAR]	= { 0, };

  0002e	33 c0		 xor	 eax, eax
  00030	c6 84 24 20 04
	00 00 00	 mov	 BYTE PTR _AppletTaskBar$[esp+30464], 0
  00038	b9 45 05 00 00	 mov	 ecx, 1349		; 00000545H
  0003d	8d bc 24 21 04
	00 00		 lea	 edi, DWORD PTR _AppletTaskBar$[esp+30465]
  00044	f3 ab		 rep stosd
  00046	66 ab		 stosw
  00048	aa		 stosb

; 965  : 	qry->GetStr( "m_aSlotApplet", AppletTaskBar );

  00049	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR _AppletTaskBar$[esp+30464]
  00050	50		 push	 eax
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@GNBKFLOM@m_aSlotApplet?$AA@
  00056	8b ca		 mov	 ecx, edx

; 966  : 	VERIFYSTRING_RETURN( AppletTaskBar, lpDbOverlappedPlus->AccountInfo.szPlayer );

  00058	89 54 24 1c	 mov	 DWORD PTR $T212416[esp+30472], edx
  0005c	89 74 24 20	 mov	 DWORD PTR $T212417[esp+30472], esi
  00060	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+30472], 0
  00068	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0006d	56		 push	 esi
  0006e	8d 46 74	 lea	 eax, DWORD PTR [esi+116]
  00071	50		 push	 eax
  00072	68 c6 03 00 00	 push	 966			; 000003c6H
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0007c	8d 8c 24 30 04
	00 00		 lea	 ecx, DWORD PTR _AppletTaskBar$[esp+30480]
  00083	51		 push	 ecx
  00084	8b 4c 24 24	 mov	 ecx, DWORD PTR $T212414[esp+30484]
  00088	89 44 24 30	 mov	 DWORD PTR tv416[esp+30484], eax
  0008c	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00091	85 c0		 test	 eax, eax
  00093	0f 84 e7 02 00
	00		 je	 $L212423

; 967  : 	while( '$' != AppletTaskBar[CountStr] )

  00099	80 bc 24 20 04
	00 00 24	 cmp	 BYTE PTR _AppletTaskBar$[esp+30464], 36 ; 00000024H
  000a1	0f 84 ff 00 00
	00		 je	 $L209152
  000a7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L209151:

; 968  : 	{
; 969  : 		nIndex	= GetIntFromStr( AppletTaskBar, &CountStr );

  000b0	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+30464]
  000b4	52		 push	 edx
  000b5	8d 84 24 24 04
	00 00		 lea	 eax, DWORD PTR _AppletTaskBar$[esp+30468]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  000c2	8b f8		 mov	 edi, eax

; 970  : 		pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_dwShortcut	= (DWORD)GetIntFromStr( AppletTaskBar, &CountStr );

  000c4	8b cf		 mov	 ecx, edi
  000c6	69 c9 98 00 00
	00		 imul	 ecx, 152		; 00000098H
  000cc	8d 54 24 14	 lea	 edx, DWORD PTR _CountStr$[esp+30472]
  000d0	52		 push	 edx
  000d1	8d 84 24 2c 04
	00 00		 lea	 eax, DWORD PTR _AppletTaskBar$[esp+30476]
  000d8	50		 push	 eax
  000d9	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
  000dc	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 971  : 		pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_dwId	= (DWORD)GetIntFromStr( AppletTaskBar, &CountStr );

  000e1	8d 4c 24 1c	 lea	 ecx, DWORD PTR _CountStr$[esp+30480]
  000e5	51		 push	 ecx
  000e6	8d 94 24 34 04
	00 00		 lea	 edx, DWORD PTR _AppletTaskBar$[esp+30484]
  000ed	52		 push	 edx
  000ee	89 86 ec 02 00
	00		 mov	 DWORD PTR [esi+748], eax
  000f4	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  000f9	89 86 f0 02 00
	00		 mov	 DWORD PTR [esi+752], eax

; 972  : 		pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_dwType	= (DWORD)GetIntFromStr( AppletTaskBar, &CountStr );

  000ff	8d 44 24 24	 lea	 eax, DWORD PTR _CountStr$[esp+30488]
  00103	50		 push	 eax
  00104	8d 8c 24 3c 04
	00 00		 lea	 ecx, DWORD PTR _AppletTaskBar$[esp+30492]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 973  : 		pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_dwIndex	= (DWORD)GetIntFromStr( AppletTaskBar, &CountStr );

  00111	8d 54 24 2c	 lea	 edx, DWORD PTR _CountStr$[esp+30496]
  00115	89 86 f4 02 00
	00		 mov	 DWORD PTR [esi+756], eax
  0011b	52		 push	 edx
  0011c	8d 84 24 44 04
	00 00		 lea	 eax, DWORD PTR _AppletTaskBar$[esp+30500]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00129	83 c7 05	 add	 edi, 5
  0012c	69 ff 98 00 00
	00		 imul	 edi, 152		; 00000098H

; 974  : 		pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_dwUserId	= (DWORD)GetIntFromStr( AppletTaskBar, &CountStr );

  00132	8d 4c 24 34	 lea	 ecx, DWORD PTR _CountStr$[esp+30504]
  00136	51		 push	 ecx
  00137	8d 94 24 4c 04
	00 00		 lea	 edx, DWORD PTR _AppletTaskBar$[esp+30508]
  0013e	52		 push	 edx
  0013f	89 04 1f	 mov	 DWORD PTR [edi+ebx], eax
  00142	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00147	89 86 fc 02 00
	00		 mov	 DWORD PTR [esi+764], eax

; 975  : 		pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_dwData	= (DWORD)GetIntFromStr( AppletTaskBar, &CountStr );

  0014d	8d 44 24 3c	 lea	 eax, DWORD PTR _CountStr$[esp+30512]
  00151	50		 push	 eax
  00152	8d 8c 24 54 04
	00 00		 lea	 ecx, DWORD PTR _AppletTaskBar$[esp+30516]
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0015f	89 86 00 03 00
	00		 mov	 DWORD PTR [esi+768], eax

; 976  : 		if( pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_dwShortcut == SHORTCUT_CHAT )

  00165	8b 86 ec 02 00
	00		 mov	 eax, DWORD PTR [esi+748]
  0016b	83 c4 38	 add	 esp, 56			; 00000038H
  0016e	83 f8 08	 cmp	 eax, 8
  00171	75 1d		 jne	 SHORT $L209159

; 977  : 			GetStrFromDBFormat( pMover->m_UserTaskBar.m_aSlotApplet[nIndex].m_szString, AppletTaskBar, CountStr );

  00173	8b 4c 24 10	 mov	 ecx, DWORD PTR $T212414[esp+30464]
  00177	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+30464]
  0017b	52		 push	 edx
  0017c	8d 84 24 24 04
	00 00		 lea	 eax, DWORD PTR _AppletTaskBar$[esp+30468]
  00183	50		 push	 eax
  00184	81 c6 04 03 00
	00		 add	 esi, 772		; 00000304H
  0018a	56		 push	 esi
  0018b	e8 00 00 00 00	 call	 ?GetStrFromDBFormat@CDbManager@@AAEXPADPBDAAH@Z ; CDbManager::GetStrFromDBFormat
$L209159:
  00190	8b 4c 24 0c	 mov	 ecx, DWORD PTR _CountStr$[esp+30464]
  00194	80 bc 0c 20 04
	00 00 24	 cmp	 BYTE PTR _AppletTaskBar$[esp+ecx+30464], 36 ; 00000024H
  0019c	0f 85 0e ff ff
	ff		 jne	 $L209151

; 967  : 	while( '$' != AppletTaskBar[CountStr] )

  001a2	8b 74 24 18	 mov	 esi, DWORD PTR $T212417[esp+30464]
$L209152:

; 978  : 	}
; 979  : 	
; 980  : 	CountStr	= 0;
; 981  : 	nIndex	= 0;
; 982  : 	int nSlotIndex	= 0;
; 983  : 	char ItemTaskBar[MAX_ITEMTASKBAR]	= { 0, };

  001a6	c6 84 24 38 19
	00 00 00	 mov	 BYTE PTR _ItemTaskBar$[esp+30464], 0
  001ae	33 c0		 xor	 eax, eax
  001b0	b9 6f 17 00 00	 mov	 ecx, 5999		; 0000176fH
  001b5	8d bc 24 39 19
	00 00		 lea	 edi, DWORD PTR _ItemTaskBar$[esp+30465]
  001bc	f3 ab		 rep stosd

; 984  : 	qry->GetStr( "m_aSlotItem", ItemTaskBar );

  001be	8b 4c 24 14	 mov	 ecx, DWORD PTR $T212416[esp+30464]
  001c2	8d 94 24 38 19
	00 00		 lea	 edx, DWORD PTR _ItemTaskBar$[esp+30464]
  001c9	66 ab		 stosw
  001cb	52		 push	 edx
  001cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@OJJDLIJE@m_aSlotItem?$AA@
  001d1	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+30472], 0
  001d9	aa		 stosb
  001da	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 985  : 	VERIFYSTRING_RETURN( ItemTaskBar, lpDbOverlappedPlus->AccountInfo.szPlayer );

  001df	8b 44 24 1c	 mov	 eax, DWORD PTR tv416[esp+30464]
  001e3	56		 push	 esi
  001e4	50		 push	 eax
  001e5	68 d9 03 00 00	 push	 985			; 000003d9H
  001ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  001ef	8d 8c 24 48 19
	00 00		 lea	 ecx, DWORD PTR _ItemTaskBar$[esp+30480]
  001f6	51		 push	 ecx
  001f7	8b 4c 24 24	 mov	 ecx, DWORD PTR $T212414[esp+30484]
  001fb	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00200	85 c0		 test	 eax, eax
  00202	0f 84 78 01 00
	00		 je	 $L212423

; 986  : 	while( '$' != ItemTaskBar[CountStr] )

  00208	80 bc 24 38 19
	00 00 24	 cmp	 BYTE PTR _ItemTaskBar$[esp+30464], 36 ; 00000024H
  00210	0f 84 18 01 00
	00		 je	 $L209166
  00216	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$L209165:

; 987  : 	{
; 988  : 		nSlotIndex	= GetIntFromStr( ItemTaskBar, &CountStr );

  00220	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+30464]
  00224	52		 push	 edx
  00225	8d 84 24 3c 19
	00 00		 lea	 eax, DWORD PTR _ItemTaskBar$[esp+30468]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 989  : 		nIndex	= GetIntFromStr( ItemTaskBar, &CountStr );

  00232	8d 4c 24 14	 lea	 ecx, DWORD PTR _CountStr$[esp+30472]
  00236	51		 push	 ecx
  00237	8d 94 24 44 19
	00 00		 lea	 edx, DWORD PTR _ItemTaskBar$[esp+30476]
  0023e	52		 push	 edx
  0023f	8b f0		 mov	 esi, eax
  00241	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 990  : 		pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_dwShortcut	= (DWORD)GetIntFromStr( ItemTaskBar, &CountStr );

  00246	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  00249	8d 3c 48	 lea	 edi, DWORD PTR [eax+ecx*2]
  0024c	8b d7		 mov	 edx, edi
  0024e	69 d2 98 00 00
	00		 imul	 edx, 152		; 00000098H
  00254	8d 44 24 1c	 lea	 eax, DWORD PTR _CountStr$[esp+30480]
  00258	50		 push	 eax
  00259	8d 8c 24 4c 19
	00 00		 lea	 ecx, DWORD PTR _ItemTaskBar$[esp+30484]
  00260	51		 push	 ecx
  00261	8d 34 1a	 lea	 esi, DWORD PTR [edx+ebx]
  00264	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 991  : 		pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_dwId	= (DWORD)GetIntFromStr( ItemTaskBar, &CountStr );

  00269	8d 54 24 24	 lea	 edx, DWORD PTR _CountStr$[esp+30488]
  0026d	89 86 9c 0d 00
	00		 mov	 DWORD PTR [esi+3484], eax
  00273	52		 push	 edx
  00274	8d 84 24 54 19
	00 00		 lea	 eax, DWORD PTR _ItemTaskBar$[esp+30492]
  0027b	50		 push	 eax
  0027c	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 992  : 		pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_dwType	= (DWORD)GetIntFromStr( ItemTaskBar, &CountStr );

  00281	8d 4c 24 2c	 lea	 ecx, DWORD PTR _CountStr$[esp+30496]
  00285	51		 push	 ecx
  00286	8d 94 24 5c 19
	00 00		 lea	 edx, DWORD PTR _ItemTaskBar$[esp+30500]
  0028d	52		 push	 edx
  0028e	89 86 a0 0d 00
	00		 mov	 DWORD PTR [esi+3488], eax
  00294	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00299	89 86 a4 0d 00
	00		 mov	 DWORD PTR [esi+3492], eax

; 993  : 		pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_dwIndex	= (DWORD)GetIntFromStr( ItemTaskBar, &CountStr );

  0029f	8d 44 24 34	 lea	 eax, DWORD PTR _CountStr$[esp+30504]
  002a3	50		 push	 eax
  002a4	8d 8c 24 64 19
	00 00		 lea	 ecx, DWORD PTR _ItemTaskBar$[esp+30508]
  002ab	51		 push	 ecx
  002ac	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  002b1	83 c7 17	 add	 edi, 23			; 00000017H
  002b4	69 ff 98 00 00
	00		 imul	 edi, 152		; 00000098H

; 994  : 		pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_dwUserId	= (DWORD)GetIntFromStr( ItemTaskBar, &CountStr );

  002ba	8d 54 24 3c	 lea	 edx, DWORD PTR _CountStr$[esp+30512]
  002be	89 04 1f	 mov	 DWORD PTR [edi+ebx], eax
  002c1	52		 push	 edx
  002c2	8d 84 24 6c 19
	00 00		 lea	 eax, DWORD PTR _ItemTaskBar$[esp+30516]
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 995  : 		pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_dwData	= (DWORD)GetIntFromStr( ItemTaskBar, &CountStr );

  002cf	8d 4c 24 44	 lea	 ecx, DWORD PTR _CountStr$[esp+30520]
  002d3	51		 push	 ecx
  002d4	8d 94 24 74 19
	00 00		 lea	 edx, DWORD PTR _ItemTaskBar$[esp+30524]
  002db	52		 push	 edx
  002dc	89 86 ac 0d 00
	00		 mov	 DWORD PTR [esi+3500], eax
  002e2	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  002e7	89 86 b0 0d 00
	00		 mov	 DWORD PTR [esi+3504], eax

; 996  : 		if( pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_dwShortcut == SHORTCUT_CHAT )

  002ed	8b 86 9c 0d 00
	00		 mov	 eax, DWORD PTR [esi+3484]
  002f3	83 c4 40	 add	 esp, 64			; 00000040H
  002f6	83 f8 08	 cmp	 eax, 8
  002f9	75 1d		 jne	 SHORT $L209173

; 997  : 			GetStrFromDBFormat( pMover->m_UserTaskBar.m_aSlotItem[nSlotIndex][nIndex].m_szString, ItemTaskBar, CountStr );

  002fb	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+30464]
  002ff	50		 push	 eax
  00300	8d 8c 24 3c 19
	00 00		 lea	 ecx, DWORD PTR _ItemTaskBar$[esp+30468]
  00307	51		 push	 ecx
  00308	8b 4c 24 18	 mov	 ecx, DWORD PTR $T212414[esp+30472]
  0030c	81 c6 b4 0d 00
	00		 add	 esi, 3508		; 00000db4H
  00312	56		 push	 esi
  00313	e8 00 00 00 00	 call	 ?GetStrFromDBFormat@CDbManager@@AAEXPADPBDAAH@Z ; CDbManager::GetStrFromDBFormat
$L209173:
  00318	8b 54 24 0c	 mov	 edx, DWORD PTR _CountStr$[esp+30464]
  0031c	80 bc 14 38 19
	00 00 24	 cmp	 BYTE PTR _ItemTaskBar$[esp+edx+30464], 36 ; 00000024H
  00324	0f 85 f6 fe ff
	ff		 jne	 $L209165

; 986  : 	while( '$' != ItemTaskBar[CountStr] )

  0032a	8b 74 24 18	 mov	 esi, DWORD PTR $T212417[esp+30464]
$L209166:

; 998  : 	}
; 999  : 	
; 1000 : 	CountStr	= 0;
; 1001 : 	nIndex	= 0;
; 1002 : 	char SkillTaskBar[1024]		= { 0, };

  0032e	33 c0		 xor	 eax, eax
  00330	c6 44 24 20 00	 mov	 BYTE PTR _SkillTaskBar$[esp+30464], 0
  00335	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0033a	8d 7c 24 21	 lea	 edi, DWORD PTR _SkillTaskBar$[esp+30465]
  0033e	f3 ab		 rep stosd

; 1003 : 	qry->GetStr( "m_aSlotQueue", SkillTaskBar );

  00340	8b 4c 24 14	 mov	 ecx, DWORD PTR $T212416[esp+30464]
  00344	66 ab		 stosw
  00346	aa		 stosb
  00347	8d 44 24 20	 lea	 eax, DWORD PTR _SkillTaskBar$[esp+30464]
  0034b	50		 push	 eax
  0034c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@CPNBAAIJ@m_aSlotQueue?$AA@
  00351	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+30472], 0
  00359	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1004 : 	VERIFYSTRING_RETURN( SkillTaskBar, lpDbOverlappedPlus->AccountInfo.szPlayer );

  0035e	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv416[esp+30464]
  00362	56		 push	 esi
  00363	51		 push	 ecx
  00364	8b 4c 24 18	 mov	 ecx, DWORD PTR $T212414[esp+30472]
  00368	68 ec 03 00 00	 push	 1004			; 000003ecH
  0036d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00372	8d 54 24 30	 lea	 edx, DWORD PTR _SkillTaskBar$[esp+30480]
  00376	52		 push	 edx
  00377	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  0037c	85 c0		 test	 eax, eax
  0037e	75 19		 jne	 SHORT $L212420
$L212423:
  00380	33 c0		 xor	 eax, eax

; 1016 : 	return TRUE;
; 1017 : }

  00382	5f		 pop	 edi
  00383	5e		 pop	 esi
  00384	5b		 pop	 ebx
  00385	8b 8c 24 f0 76
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+30452]
  0038c	33 cd		 xor	 ecx, ebp
  0038e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00393	8b e5		 mov	 esp, ebp
  00395	5d		 pop	 ebp
  00396	c2 0c 00	 ret	 12			; 0000000cH
$L212420:

; 1005 : 	while( '$' != SkillTaskBar[CountStr] )

  00399	80 7c 24 20 24	 cmp	 BYTE PTR _SkillTaskBar$[esp+30464], 36 ; 00000024H
  0039e	0f 84 b4 00 00
	00		 je	 $L209179
$L209178:

; 1006 : 	{
; 1007 : 		nIndex	= GetIntFromStr( SkillTaskBar, &CountStr );

  003a4	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+30464]
  003a8	50		 push	 eax
  003a9	8d 4c 24 24	 lea	 ecx, DWORD PTR _SkillTaskBar$[esp+30468]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  003b3	8b f0		 mov	 esi, eax

; 1008 : 		pMover->m_UserTaskBar.m_aSlotQueue[nIndex].m_dwShortcut	= (DWORD)GetIntFromStr( SkillTaskBar, &CountStr );

  003b5	8b d6		 mov	 edx, esi
  003b7	69 d2 98 00 00
	00		 imul	 edx, 152		; 00000098H
  003bd	8d 44 24 14	 lea	 eax, DWORD PTR _CountStr$[esp+30472]
  003c1	50		 push	 eax
  003c2	8d 4c 24 2c	 lea	 ecx, DWORD PTR _SkillTaskBar$[esp+30476]
  003c6	51		 push	 ecx
  003c7	8d 3c 1a	 lea	 edi, DWORD PTR [edx+ebx]
  003ca	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 1009 : 		pMover->m_UserTaskBar.m_aSlotQueue[nIndex].m_dwId	= (DWORD)GetIntFromStr( SkillTaskBar, &CountStr );

  003cf	8d 54 24 1c	 lea	 edx, DWORD PTR _CountStr$[esp+30480]
  003d3	89 87 1c 3d 00
	00		 mov	 DWORD PTR [edi+15644], eax
  003d9	52		 push	 edx
  003da	8d 44 24 34	 lea	 eax, DWORD PTR _SkillTaskBar$[esp+30484]
  003de	50		 push	 eax
  003df	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 1010 : 		pMover->m_UserTaskBar.m_aSlotQueue[nIndex].m_dwType		= (DWORD)GetIntFromStr( SkillTaskBar, &CountStr );

  003e4	8d 4c 24 24	 lea	 ecx, DWORD PTR _CountStr$[esp+30488]
  003e8	51		 push	 ecx
  003e9	8d 54 24 3c	 lea	 edx, DWORD PTR _SkillTaskBar$[esp+30492]
  003ed	52		 push	 edx
  003ee	89 87 20 3d 00
	00		 mov	 DWORD PTR [edi+15648], eax
  003f4	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  003f9	89 87 24 3d 00
	00		 mov	 DWORD PTR [edi+15652], eax

; 1011 : 		pMover->m_UserTaskBar.m_aSlotQueue[nIndex].m_dwIndex	= (DWORD)GetIntFromStr( SkillTaskBar, &CountStr );

  003ff	8d 44 24 2c	 lea	 eax, DWORD PTR _CountStr$[esp+30496]
  00403	50		 push	 eax
  00404	8d 4c 24 44	 lea	 ecx, DWORD PTR _SkillTaskBar$[esp+30500]
  00408	51		 push	 ecx
  00409	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0040e	83 c6 67	 add	 esi, 103		; 00000067H
  00411	69 f6 98 00 00
	00		 imul	 esi, 152		; 00000098H

; 1012 : 		pMover->m_UserTaskBar.m_aSlotQueue[nIndex].m_dwUserId	= (DWORD)GetIntFromStr( SkillTaskBar, &CountStr );

  00417	8d 54 24 34	 lea	 edx, DWORD PTR _CountStr$[esp+30504]
  0041b	89 04 1e	 mov	 DWORD PTR [esi+ebx], eax
  0041e	52		 push	 edx
  0041f	8d 44 24 4c	 lea	 eax, DWORD PTR _SkillTaskBar$[esp+30508]
  00423	50		 push	 eax
  00424	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 1013 : 		pMover->m_UserTaskBar.m_aSlotQueue[nIndex].m_dwData		= (DWORD)GetIntFromStr( SkillTaskBar, &CountStr );

  00429	8d 4c 24 3c	 lea	 ecx, DWORD PTR _CountStr$[esp+30512]
  0042d	51		 push	 ecx
  0042e	8d 54 24 54	 lea	 edx, DWORD PTR _SkillTaskBar$[esp+30516]
  00432	52		 push	 edx
  00433	89 87 2c 3d 00
	00		 mov	 DWORD PTR [edi+15660], eax
  00439	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0043e	89 87 30 3d 00
	00		 mov	 DWORD PTR [edi+15664], eax
  00444	8b 44 24 44	 mov	 eax, DWORD PTR _CountStr$[esp+30520]
  00448	8a 4c 04 58	 mov	 cl, BYTE PTR _SkillTaskBar$[esp+eax+30520]
  0044c	83 c4 38	 add	 esp, 56			; 00000038H
  0044f	80 f9 24	 cmp	 cl, 36			; 00000024H
  00452	0f 85 4c ff ff
	ff		 jne	 $L209178
$L209179:

; 1014 : 	}
; 1015 : 	pMover->m_UserTaskBar.m_nActionPoint = qry->GetInt( "m_SkillBar" );

  00458	8b 4c 24 14	 mov	 ecx, DWORD PTR $T212416[esp+30464]
  0045c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@NJKCPPDJ@m_SkillBar?$AA@
  00461	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1016 : 	return TRUE;
; 1017 : }

  00466	8b 8c 24 fc 76
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+30464]
  0046d	5f		 pop	 edi
  0046e	89 83 ac 40 00
	00		 mov	 DWORD PTR [ebx+16556], eax
  00474	5e		 pop	 esi
  00475	33 cd		 xor	 ecx, ebp
  00477	b8 01 00 00 00	 mov	 eax, 1
  0047c	5b		 pop	 ebx
  0047d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00482	8b e5		 mov	 esp, ebp
  00484	5d		 pop	 ebp
  00485	c2 0c 00	 ret	 12			; 0000000cH
?GetTaskBar@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetTaskBar
_TEXT	ENDS
PUBLIC	??_C@_0L@LGPNILBK@m_vScale_x?$AA@		; `string'
PUBLIC	??_C@_0L@MOMKJNEM@m_dwMotion?$AA@		; `string'
PUBLIC	??_C@_09DHJEDBNA@dwWorldID?$AA@			; `string'
PUBLIC	??_C@_08FJAEPELD@m_vPos_x?$AA@			; `string'
PUBLIC	??_C@_08EABPMFPC@m_vPos_y?$AA@			; `string'
PUBLIC	??_C@_08GLDCJGDB@m_vPos_z?$AA@			; `string'
PUBLIC	??_C@_08MNAKGHOO@m_fAngle?$AA@			; `string'
PUBLIC	??_C@_0BB@FJPKIIEM@m_szCharacterKey?$AA@	; `string'
PUBLIC	??_C@_0M@PMKOKNNK@m_nHitPoint?$AA@		; `string'
PUBLIC	??_C@_0N@GFDNJNAL@m_nManaPoint?$AA@		; `string'
PUBLIC	??_C@_0BA@COGKPMEJ@m_nFatiguePoint?$AA@		; `string'
PUBLIC	??_C@_0M@BCEJBJHD@m_dwSkinSet?$AA@		; `string'
PUBLIC	??_C@_0N@HFOELFNC@m_dwHairMesh?$AA@		; `string'
PUBLIC	??_C@_0O@ICOGEKE@m_dwHairColor?$AA@		; `string'
PUBLIC	??_C@_0N@BHMOBEMJ@m_dwHeadMesh?$AA@		; `string'
PUBLIC	??_C@_07KMHLCHEI@m_dwSex?$AA@			; `string'
PUBLIC	??_C@_0BA@MHMDKNKE@m_dwRideItemIdx?$AA@		; `string'
PUBLIC	??_C@_08JIMIMGKM@m_dwGold?$AA@			; `string'
PUBLIC	??_C@_06LDMBEDML@m_nJob?$AA@			; `string'
PUBLIC	??_C@_09OGJJHMJA@m_idparty?$AA@			; `string'
PUBLIC	??_C@_0L@IFGJAIGP@m_nPKValue?$AA@		; `string'
PUBLIC	??_C@_0BB@FMCDCCD@m_dwPKPropensity?$AA@		; `string'
PUBLIC	??_C@_09BCFDFPLE@m_dwPKExp?$AA@			; `string'
PUBLIC	??_C@_0M@IJMKHCEF@m_nAngelExp?$AA@		; `string'
PUBLIC	??_C@_0O@COEFFCNN@m_nAngelLevel?$AA@		; `string'
PUBLIC	??_C@_0O@MHHICKD@m_idMuerderer?$AA@		; `string'
PUBLIC	??_C@_07DKPMJIJG@m_nFame?$AA@			; `string'
PUBLIC	??_C@_0M@BFJHKIPJ@m_pActMover?$AA@		; `string'
PUBLIC	??_C@_06MEGBAFBO@m_nStr?$AA@			; `string'
PUBLIC	??_C@_06KFIOEEIM@m_nSta?$AA@			; `string'
PUBLIC	??_C@_06OOKEELPF@m_nDex?$AA@			; `string'
PUBLIC	??_C@_06LMCODDMF@m_nInt?$AA@			; `string'
PUBLIC	??_C@_08DBNLLHK@m_nLevel?$AA@			; `string'
PUBLIC	??_C@_07JKGEFCCA@m_nExp1?$AA@			; `string'
PUBLIC	??_C@_07DKFGLCKP@m_nFuel?$AA@			; `string'
PUBLIC	??_C@_0M@FGBAAHFN@m_tmAccFuel?$AA@		; `string'
PUBLIC	??_C@_0BB@IGOJBJIH@m_idMarkingWorld?$AA@	; `string'
PUBLIC	??_C@_0BA@LIDMOLFI@m_vMarkingPos_x?$AA@		; `string'
PUBLIC	??_C@_0BA@KBCHNKBJ@m_vMarkingPos_y?$AA@		; `string'
PUBLIC	??_C@_0BA@IKAKIJNK@m_vMarkingPos_z?$AA@		; `string'
PUBLIC	??_C@_0M@HLGMCMLP@m_nRemainGP?$AA@		; `string'
PUBLIC	??_C@_0M@HKFGBBGJ@m_nFlightLv?$AA@		; `string'
PUBLIC	??_C@_06JIIKDJFF@m_nFxp?$AA@			; `string'
PUBLIC	??_C@_08MFHALOPE@m_dwMode?$AA@			; `string'
PUBLIC	??_C@_0M@MAONGJJI@m_nDeathExp?$AA@		; `string'
PUBLIC	??_C@_0O@JALGGJEE@m_nDeathLevel?$AA@		; `string'
PUBLIC	??_C@_09MFLDFMGF@m_SkillLv?$AA@			; `string'
PUBLIC	??_C@_0N@FMKKCMCC@m_SkillPoint?$AA@		; `string'
PUBLIC	??_C@_08JOEHCELE@m_nHonor?$AA@			; `string'
PUBLIC	??_C@_08HDDJDJAG@m_szName?$AA@			; `string'
PUBLIC	?GetBaseCharacter@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetBaseCharacter
EXTRN	?GetFloat@CQuery@@QAEMPAD@Z:NEAR		; CQuery::GetFloat
;	COMDAT ??_C@_08HDDJDJAG@m_szName?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\query.h
CONST	SEGMENT
??_C@_08HDDJDJAG@m_szName?$AA@ DB 'm_szName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LGPNILBK@m_vScale_x?$AA@
CONST	SEGMENT
??_C@_0L@LGPNILBK@m_vScale_x?$AA@ DB 'm_vScale_x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOMKJNEM@m_dwMotion?$AA@
CONST	SEGMENT
??_C@_0L@MOMKJNEM@m_dwMotion?$AA@ DB 'm_dwMotion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DHJEDBNA@dwWorldID?$AA@
CONST	SEGMENT
??_C@_09DHJEDBNA@dwWorldID?$AA@ DB 'dwWorldID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJAEPELD@m_vPos_x?$AA@
CONST	SEGMENT
??_C@_08FJAEPELD@m_vPos_x?$AA@ DB 'm_vPos_x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EABPMFPC@m_vPos_y?$AA@
CONST	SEGMENT
??_C@_08EABPMFPC@m_vPos_y?$AA@ DB 'm_vPos_y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GLDCJGDB@m_vPos_z?$AA@
CONST	SEGMENT
??_C@_08GLDCJGDB@m_vPos_z?$AA@ DB 'm_vPos_z', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNAKGHOO@m_fAngle?$AA@
CONST	SEGMENT
??_C@_08MNAKGHOO@m_fAngle?$AA@ DB 'm_fAngle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJPKIIEM@m_szCharacterKey?$AA@
CONST	SEGMENT
??_C@_0BB@FJPKIIEM@m_szCharacterKey?$AA@ DB 'm_szCharacterKey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PMKOKNNK@m_nHitPoint?$AA@
CONST	SEGMENT
??_C@_0M@PMKOKNNK@m_nHitPoint?$AA@ DB 'm_nHitPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GFDNJNAL@m_nManaPoint?$AA@
CONST	SEGMENT
??_C@_0N@GFDNJNAL@m_nManaPoint?$AA@ DB 'm_nManaPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@COGKPMEJ@m_nFatiguePoint?$AA@
CONST	SEGMENT
??_C@_0BA@COGKPMEJ@m_nFatiguePoint?$AA@ DB 'm_nFatiguePoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCEJBJHD@m_dwSkinSet?$AA@
CONST	SEGMENT
??_C@_0M@BCEJBJHD@m_dwSkinSet?$AA@ DB 'm_dwSkinSet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HFOELFNC@m_dwHairMesh?$AA@
CONST	SEGMENT
??_C@_0N@HFOELFNC@m_dwHairMesh?$AA@ DB 'm_dwHairMesh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ICOGEKE@m_dwHairColor?$AA@
CONST	SEGMENT
??_C@_0O@ICOGEKE@m_dwHairColor?$AA@ DB 'm_dwHairColor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BHMOBEMJ@m_dwHeadMesh?$AA@
CONST	SEGMENT
??_C@_0N@BHMOBEMJ@m_dwHeadMesh?$AA@ DB 'm_dwHeadMesh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMHLCHEI@m_dwSex?$AA@
CONST	SEGMENT
??_C@_07KMHLCHEI@m_dwSex?$AA@ DB 'm_dwSex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MHMDKNKE@m_dwRideItemIdx?$AA@
CONST	SEGMENT
??_C@_0BA@MHMDKNKE@m_dwRideItemIdx?$AA@ DB 'm_dwRideItemIdx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JIMIMGKM@m_dwGold?$AA@
CONST	SEGMENT
??_C@_08JIMIMGKM@m_dwGold?$AA@ DB 'm_dwGold', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LDMBEDML@m_nJob?$AA@
CONST	SEGMENT
??_C@_06LDMBEDML@m_nJob?$AA@ DB 'm_nJob', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGJJHMJA@m_idparty?$AA@
CONST	SEGMENT
??_C@_09OGJJHMJA@m_idparty?$AA@ DB 'm_idparty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IFGJAIGP@m_nPKValue?$AA@
CONST	SEGMENT
??_C@_0L@IFGJAIGP@m_nPKValue?$AA@ DB 'm_nPKValue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMCDCCD@m_dwPKPropensity?$AA@
CONST	SEGMENT
??_C@_0BB@FMCDCCD@m_dwPKPropensity?$AA@ DB 'm_dwPKPropensity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCFDFPLE@m_dwPKExp?$AA@
CONST	SEGMENT
??_C@_09BCFDFPLE@m_dwPKExp?$AA@ DB 'm_dwPKExp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJMKHCEF@m_nAngelExp?$AA@
CONST	SEGMENT
??_C@_0M@IJMKHCEF@m_nAngelExp?$AA@ DB 'm_nAngelExp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COEFFCNN@m_nAngelLevel?$AA@
CONST	SEGMENT
??_C@_0O@COEFFCNN@m_nAngelLevel?$AA@ DB 'm_nAngelLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MHHICKD@m_idMuerderer?$AA@
CONST	SEGMENT
??_C@_0O@MHHICKD@m_idMuerderer?$AA@ DB 'm_idMuerderer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DKPMJIJG@m_nFame?$AA@
CONST	SEGMENT
??_C@_07DKPMJIJG@m_nFame?$AA@ DB 'm_nFame', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BFJHKIPJ@m_pActMover?$AA@
CONST	SEGMENT
??_C@_0M@BFJHKIPJ@m_pActMover?$AA@ DB 'm_pActMover', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MEGBAFBO@m_nStr?$AA@
CONST	SEGMENT
??_C@_06MEGBAFBO@m_nStr?$AA@ DB 'm_nStr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KFIOEEIM@m_nSta?$AA@
CONST	SEGMENT
??_C@_06KFIOEEIM@m_nSta?$AA@ DB 'm_nSta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OOKEELPF@m_nDex?$AA@
CONST	SEGMENT
??_C@_06OOKEELPF@m_nDex?$AA@ DB 'm_nDex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LMCODDMF@m_nInt?$AA@
CONST	SEGMENT
??_C@_06LMCODDMF@m_nInt?$AA@ DB 'm_nInt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DBNLLHK@m_nLevel?$AA@
CONST	SEGMENT
??_C@_08DBNLLHK@m_nLevel?$AA@ DB 'm_nLevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKGEFCCA@m_nExp1?$AA@
CONST	SEGMENT
??_C@_07JKGEFCCA@m_nExp1?$AA@ DB 'm_nExp1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DKFGLCKP@m_nFuel?$AA@
CONST	SEGMENT
??_C@_07DKFGLCKP@m_nFuel?$AA@ DB 'm_nFuel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FGBAAHFN@m_tmAccFuel?$AA@
CONST	SEGMENT
??_C@_0M@FGBAAHFN@m_tmAccFuel?$AA@ DB 'm_tmAccFuel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGOJBJIH@m_idMarkingWorld?$AA@
CONST	SEGMENT
??_C@_0BB@IGOJBJIH@m_idMarkingWorld?$AA@ DB 'm_idMarkingWorld', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LIDMOLFI@m_vMarkingPos_x?$AA@
CONST	SEGMENT
??_C@_0BA@LIDMOLFI@m_vMarkingPos_x?$AA@ DB 'm_vMarkingPos_x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KBCHNKBJ@m_vMarkingPos_y?$AA@
CONST	SEGMENT
??_C@_0BA@KBCHNKBJ@m_vMarkingPos_y?$AA@ DB 'm_vMarkingPos_y', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IKAKIJNK@m_vMarkingPos_z?$AA@
CONST	SEGMENT
??_C@_0BA@IKAKIJNK@m_vMarkingPos_z?$AA@ DB 'm_vMarkingPos_z', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HLGMCMLP@m_nRemainGP?$AA@
CONST	SEGMENT
??_C@_0M@HLGMCMLP@m_nRemainGP?$AA@ DB 'm_nRemainGP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKFGBBGJ@m_nFlightLv?$AA@
CONST	SEGMENT
??_C@_0M@HKFGBBGJ@m_nFlightLv?$AA@ DB 'm_nFlightLv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JIIKDJFF@m_nFxp?$AA@
CONST	SEGMENT
??_C@_06JIIKDJFF@m_nFxp?$AA@ DB 'm_nFxp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MFHALOPE@m_dwMode?$AA@
CONST	SEGMENT
??_C@_08MFHALOPE@m_dwMode?$AA@ DB 'm_dwMode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MAONGJJI@m_nDeathExp?$AA@
CONST	SEGMENT
??_C@_0M@MAONGJJI@m_nDeathExp?$AA@ DB 'm_nDeathExp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JALGGJEE@m_nDeathLevel?$AA@
CONST	SEGMENT
??_C@_0O@JALGGJEE@m_nDeathLevel?$AA@ DB 'm_nDeathLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFLDFMGF@m_SkillLv?$AA@
CONST	SEGMENT
??_C@_09MFLDFMGF@m_SkillLv?$AA@ DB 'm_SkillLv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMKKCMCC@m_SkillPoint?$AA@
CONST	SEGMENT
??_C@_0N@FMKKCMCC@m_SkillPoint?$AA@ DB 'm_SkillPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOEHCELE@m_nHonor?$AA@
CONST	SEGMENT
??_C@_08JOEHCELE@m_nHonor?$AA@ DB 'm_nHonor', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetBaseCharacter@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_CountStr$ = -60					; size = 4
_ActMover$ = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetBaseCharacter@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetBaseCharacter, COMDAT
; _this$ = ecx

; 1025 : {

  00000	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	53		 push	 ebx
  0000b	8b 5c 24 48	 mov	 ebx, DWORD PTR _qry$[esp+60]
  0000f	56		 push	 esi
  00010	8b 74 24 48	 mov	 esi, DWORD PTR _pMover$[esp+64]
  00014	89 44 24 40	 mov	 DWORD PTR __$ArrayPad$[esp+68], eax
  00018	57		 push	 edi

; 1026 : 	qry->GetStr( "m_szName", pMover->m_szName );

  00019	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08HDDJDJAG@m_szName?$AA@
  00022	8b cb		 mov	 ecx, ebx
  00024	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1027 : 	pMover->m_vScale.x		= qry->GetFloat( "m_vScale_x" );

  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@LGPNILBK@m_vScale_x?$AA@
  0002e	8b cb		 mov	 ecx, ebx
  00030	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  00035	d9 5e 0c	 fstp	 DWORD PTR [esi+12]

; 1028 : 	pMover->m_dwMotion		= (DWORD)qry->GetInt( "m_dwMotion" );

  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@MOMKJNEM@m_dwMotion?$AA@
  0003d	8b cb		 mov	 ecx, ebx
  0003f	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1029 : 	pMover->m_dwWorldID		= qry->GetInt( "dwWorldID");

  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09DHJEDBNA@dwWorldID?$AA@
  00049	8b cb		 mov	 ecx, ebx
  0004b	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004e	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1030 : 	pMover->m_vPos.x		= qry->GetFloat( "m_vPos_x" );

  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FJAEPELD@m_vPos_x?$AA@
  00058	8b cb		 mov	 ecx, ebx
  0005a	89 86 f4 41 00
	00		 mov	 DWORD PTR [esi+16884], eax
  00060	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  00065	d9 5e 1c	 fstp	 DWORD PTR [esi+28]

; 1031 : 	pMover->m_vPos.y		= qry->GetFloat( "m_vPos_y" );

  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EABPMFPC@m_vPos_y?$AA@
  0006d	8b cb		 mov	 ecx, ebx
  0006f	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  00074	d9 5e 20	 fstp	 DWORD PTR [esi+32]

; 1032 : 	pMover->m_vPos.z		= qry->GetFloat( "m_vPos_z" );

  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GLDCJGDB@m_vPos_z?$AA@
  0007c	8b cb		 mov	 ecx, ebx
  0007e	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  00083	d9 5e 24	 fstp	 DWORD PTR [esi+36]

; 1033 : 	pMover->m_fAngle		= qry->GetFloat( "m_fAngle" );

  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MNAKGHOO@m_fAngle?$AA@
  0008b	8b cb		 mov	 ecx, ebx
  0008d	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  00092	d9 5e 28	 fstp	 DWORD PTR [esi+40]

; 1034 : 	qry->GetStr( "m_szCharacterKey", pMover->m_szCharacterKey );

  00095	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00098	51		 push	 ecx
  00099	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@FJPKIIEM@m_szCharacterKey?$AA@
  0009e	8b cb		 mov	 ecx, ebx
  000a0	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1035 : 	pMover->m_nHitPoint		= (LONG)qry->GetInt( "m_nHitPoint" );

  000a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@PMKOKNNK@m_nHitPoint?$AA@
  000aa	8b cb		 mov	 ecx, ebx
  000ac	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1036 : 	pMover->m_nManaPoint	= (LONG)qry->GetInt( "m_nManaPoint" );

  000b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@GFDNJNAL@m_nManaPoint?$AA@
  000b6	8b cb		 mov	 ecx, ebx
  000b8	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax
  000be	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1037 : 	pMover->m_nFatiguePoint		= (LONG)qry->GetInt( "m_nFatiguePoint" );

  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@COGKPMEJ@m_nFatiguePoint?$AA@
  000c8	8b cb		 mov	 ecx, ebx
  000ca	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  000d0	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1038 : 	pMover->m_dwSkinSet		= (DWORD)qry->GetInt( "m_dwSkinSet" );

  000d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@BCEJBJHD@m_dwSkinSet?$AA@
  000da	8b cb		 mov	 ecx, ebx
  000dc	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  000e2	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1039 : 	pMover->m_dwHairMesh	= (DWORD)qry->GetInt( "m_dwHairMesh" );

  000e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@HFOELFNC@m_dwHairMesh?$AA@
  000ec	8b cb		 mov	 ecx, ebx
  000ee	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  000f4	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1040 : 	pMover->m_dwHairColor	= (DWORD)qry->GetInt( "m_dwHairColor" );

  000f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@ICOGEKE@m_dwHairColor?$AA@
  000fe	8b cb		 mov	 ecx, ebx
  00100	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  00106	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1041 : 	pMover->m_dwHeadMesh	= (DWORD)qry->GetInt( "m_dwHeadMesh" );

  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@BHMOBEMJ@m_dwHeadMesh?$AA@
  00110	8b cb		 mov	 ecx, ebx
  00112	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax
  00118	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1042 : 	pMover->SetSex( (BYTE)qry->GetInt( "m_dwSex" ) );

  0011d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07KMHLCHEI@m_dwSex?$AA@
  00122	8b cb		 mov	 ecx, ebx
  00124	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax
  0012a	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1043 : 	pMover->m_dwRideItemIdx		= (DWORD)qry->GetInt( "m_dwRideItemIdx" );

  0012f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@MHMDKNKE@m_dwRideItemIdx?$AA@
  00134	8b cb		 mov	 ecx, ebx
  00136	88 86 b8 00 00
	00		 mov	 BYTE PTR [esi+184], al
  0013c	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1044 : 	pMover->SetGold( qry->GetInt("m_dwGold") );

  00141	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08JIMIMGKM@m_dwGold?$AA@
  00146	8b cb		 mov	 ecx, ebx
  00148	89 86 bc 00 00
	00		 mov	 DWORD PTR [esi+188], eax
  0014e	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1045 : 	pMover->m_nJob			= (LONG)qry->GetInt( "m_nJob" );

  00153	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06LDMBEDML@m_nJob?$AA@
  00158	8b cb		 mov	 ecx, ebx
  0015a	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0015d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1046 : 	pMover->m_idparty		= (u_long)qry->GetInt( "m_idparty" );

  00162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09OGJJHMJA@m_idparty?$AA@
  00167	8b cb		 mov	 ecx, ebx
  00169	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax
  0016f	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1047 : #if __VER >= 8 // __S8_PK
; 1048 : 	pMover->m_nPKValue			= qry->GetInt( "m_nPKValue" );

  00174	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@IFGJAIGP@m_nPKValue?$AA@
  00179	8b cb		 mov	 ecx, ebx
  0017b	89 86 c8 40 00
	00		 mov	 DWORD PTR [esi+16584], eax
  00181	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1049 : 	pMover->m_dwPKPropensity	= qry->GetInt( "m_dwPKPropensity" );

  00186	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@FMCDCCD@m_dwPKPropensity?$AA@
  0018b	8b cb		 mov	 ecx, ebx
  0018d	89 86 d8 40 00
	00		 mov	 DWORD PTR [esi+16600], eax
  00193	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1050 : 	pMover->m_dwPKExp			= qry->GetInt( "m_dwPKExp" );

  00198	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09BCFDFPLE@m_dwPKExp?$AA@
  0019d	8b cb		 mov	 ecx, ebx
  0019f	89 86 dc 40 00
	00		 mov	 DWORD PTR [esi+16604], eax
  001a5	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1051 : #else // __VER >= 8 // __S8_PK
; 1052 : 	pMover->m_nNumKill		= qry->GetInt( "m_nNumKill" );
; 1053 : 	pMover->m_nSlaughter	= qry->GetInt( "m_nSlaughter" );
; 1054 : #endif // __VER >= 8 // __S8_PK
; 1055 : #if __VER >= 8 // __CSC_VER8_5
; 1056 : 	pMover->m_nAngelExp		= qry->GetExpInteger( "m_nAngelExp" );

  001aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@IJMKHCEF@m_nAngelExp?$AA@
  001af	8b cb		 mov	 ecx, ebx
  001b1	89 86 e0 40 00
	00		 mov	 DWORD PTR [esi+16608], eax
  001b7	e8 00 00 00 00	 call	 ?GetInt64@CQuery@@QAE_JPAD@Z ; CQuery::GetInt64

; 1057 : 	pMover->m_nAngelLevel	= qry->GetInt( "m_nAngelLevel" );

  001bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@COEFFCNN@m_nAngelLevel?$AA@
  001c1	8b cb		 mov	 ecx, ebx
  001c3	89 86 e8 40 00
	00		 mov	 DWORD PTR [esi+16616], eax
  001c9	89 96 ec 40 00
	00		 mov	 DWORD PTR [esi+16620], edx
  001cf	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1058 : #endif // __CSC_VER8_5
; 1059 : 	
; 1060 : 	pMover->m_idMurderer	= (u_long)qry->GetInt( "m_idMuerderer" );

  001d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@MHHICKD@m_idMuerderer?$AA@
  001d9	8b cb		 mov	 ecx, ebx
  001db	89 86 f0 40 00
	00		 mov	 DWORD PTR [esi+16624], eax
  001e1	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1061 : 	pMover->m_nFame			= qry->GetInt( "m_nFame" );

  001e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07DKPMJIJG@m_nFame?$AA@
  001eb	8b cb		 mov	 ecx, ebx
  001ed	89 86 f8 40 00
	00		 mov	 DWORD PTR [esi+16632], eax
  001f3	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  001f8	89 86 f4 40 00
	00		 mov	 DWORD PTR [esi+16628], eax

; 1062 : 	
; 1063 : 	int CountStr	= 0;

  001fe	33 c0		 xor	 eax, eax

; 1064 : 	char ActMover[50]	= {0,};

  00200	88 44 24 10	 mov	 BYTE PTR _ActMover$[esp+72], al
  00204	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+72], eax
  00208	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0020d	8d 7c 24 11	 lea	 edi, DWORD PTR _ActMover$[esp+73]
  00211	f3 ab		 rep stosd

; 1065 : 	qry->GetStr( "m_pActMover", ActMover );

  00213	8d 54 24 10	 lea	 edx, DWORD PTR _ActMover$[esp+72]
  00217	52		 push	 edx
  00218	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@BFJHKIPJ@m_pActMover?$AA@
  0021d	8b cb		 mov	 ecx, ebx
  0021f	aa		 stosb
  00220	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1066 : 	pMover->m_pActMover->m_dwState	= (DWORD)GetIntFromStr( ActMover, &CountStr );

  00225	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+72]
  00229	50		 push	 eax
  0022a	8d 4c 24 14	 lea	 ecx, DWORD PTR _ActMover$[esp+76]
  0022e	51		 push	 ecx
  0022f	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00234	8b 96 10 41 00
	00		 mov	 edx, DWORD PTR [esi+16656]
  0023a	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1067 : 	pMover->m_pActMover->m_dwStateFlag	= (DWORD)GetIntFromStr( ActMover, &CountStr );

  0023d	8d 44 24 14	 lea	 eax, DWORD PTR _CountStr$[esp+80]
  00241	50		 push	 eax
  00242	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ActMover$[esp+84]
  00246	51		 push	 ecx
  00247	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0024c	8b 96 10 41 00
	00		 mov	 edx, DWORD PTR [esi+16656]
  00252	83 c4 10	 add	 esp, 16			; 00000010H

; 1068 : 	
; 1069 : 	CountStr	= 0;
; 1070 : 	pMover->m_nStr	= (LONG)qry->GetInt( "m_nStr" );

  00255	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06MEGBAFBO@m_nStr?$AA@
  0025a	8b cb		 mov	 ecx, ebx
  0025c	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0025f	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1071 : 	pMover->m_nSta	= (LONG)qry->GetInt( "m_nSta" );

  00264	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06KFIOEEIM@m_nSta?$AA@
  00269	8b cb		 mov	 ecx, ebx
  0026b	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  00271	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1072 : 	pMover->m_nDex	= (LONG)qry->GetInt( "m_nDex" );

  00276	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06OOKEELPF@m_nDex?$AA@
  0027b	8b cb		 mov	 ecx, ebx
  0027d	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00283	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00288	89 86 dc 00 00
	00		 mov	 DWORD PTR [esi+220], eax

; 1073 : 	pMover->m_nInt	= (LONG)qry->GetInt( "m_nInt" );

  0028e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06LMCODDMF@m_nInt?$AA@
  00293	8b cb		 mov	 ecx, ebx
  00295	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1074 : 	pMover->m_nLevel	= (LONG)qry->GetInt( "m_nLevel" );

  0029a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DBNLLHK@m_nLevel?$AA@
  0029f	8b cb		 mov	 ecx, ebx
  002a1	89 86 e0 00 00
	00		 mov	 DWORD PTR [esi+224], eax
  002a7	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1075 : 	pMover->m_nExp1		= qry->GetExpInteger( "m_nExp1" );

  002ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07JKGEFCCA@m_nExp1?$AA@
  002b1	8b cb		 mov	 ecx, ebx
  002b3	89 86 e4 00 00
	00		 mov	 DWORD PTR [esi+228], eax
  002b9	e8 00 00 00 00	 call	 ?GetInt64@CQuery@@QAE_JPAD@Z ; CQuery::GetInt64

; 1076 : 	pMover->m_nFuel		= qry->GetInt( "m_nFuel" );

  002be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07DKFGLCKP@m_nFuel?$AA@
  002c3	8b cb		 mov	 ecx, ebx
  002c5	89 86 f0 00 00
	00		 mov	 DWORD PTR [esi+240], eax
  002cb	89 96 f4 00 00
	00		 mov	 DWORD PTR [esi+244], edx
  002d1	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1077 : 	pMover->m_tmAccFuel	= qry->GetInt( "m_tmAccFuel" );

  002d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@FGBAAHFN@m_tmAccFuel?$AA@
  002db	8b cb		 mov	 ecx, ebx
  002dd	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax
  002e3	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1078 : 	
; 1079 : //	pMover->m_dwExpertLv	= (DWORD)qry->GetInt( "m_dwExpertLv");
; 1080 : 	pMover->m_idMarkingWorld	= (DWORD)qry->GetInt( "m_idMarkingWorld");

  002e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@IGOJBJIH@m_idMarkingWorld?$AA@
  002ed	8b cb		 mov	 ecx, ebx
  002ef	89 86 ec 41 00
	00		 mov	 DWORD PTR [esi+16876], eax
  002f5	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1081 : 	pMover->m_vMarkingPos.x		= qry->GetFloat( "m_vMarkingPos_x" );

  002fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@LIDMOLFI@m_vMarkingPos_x?$AA@
  002ff	8b cb		 mov	 ecx, ebx
  00301	89 86 cc 02 00
	00		 mov	 DWORD PTR [esi+716], eax
  00307	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  0030c	d9 9e d0 02 00
	00		 fstp	 DWORD PTR [esi+720]

; 1082 : 	pMover->m_vMarkingPos.y		= qry->GetFloat( "m_vMarkingPos_y" );

  00312	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@KBCHNKBJ@m_vMarkingPos_y?$AA@
  00317	8b cb		 mov	 ecx, ebx
  00319	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  0031e	d9 9e d4 02 00
	00		 fstp	 DWORD PTR [esi+724]

; 1083 : 	pMover->m_vMarkingPos.z		= qry->GetFloat( "m_vMarkingPos_z" );

  00324	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@IKAKIJNK@m_vMarkingPos_z?$AA@
  00329	8b cb		 mov	 ecx, ebx
  0032b	e8 00 00 00 00	 call	 ?GetFloat@CQuery@@QAEMPAD@Z ; CQuery::GetFloat
  00330	d9 9e d8 02 00
	00		 fstp	 DWORD PTR [esi+728]

; 1084 : 	pMover->m_nRemainGP = (long)qry->GetInt( "m_nRemainGP" );

  00336	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@HLGMCMLP@m_nRemainGP?$AA@
  0033b	8b cb		 mov	 ecx, ebx
  0033d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1085 : //	pMover->m_nRemainLP = (long)qry->GetInt( "m_nRemainLP" );
; 1086 : #if __VER >= 12 // __MOD_TUTORIAL
; 1087 : 	int nTutorialState	= qry->GetInt( "m_nFlightLv" );

  00342	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@HKFGBBGJ@m_nFlightLv?$AA@
  00347	8b cb		 mov	 ecx, ebx
  00349	89 86 dc 02 00
	00		 mov	 DWORD PTR [esi+732], eax
  0034f	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1088 : 	pMover->SetTutorialState( nTutorialState );
; 1089 : #else	// __MOD_TUTORIAL
; 1090 : 	pMover->m_nFlightLv		= (long)qry->GetInt( "m_nFlightLv" );
; 1091 : #endif	// __MOD_TUTORIAL
; 1092 : 	pMover->m_nFxp	= (long)qry->GetInt( "m_nFxp" );

  00354	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06JIIKDJFF@m_nFxp?$AA@
  00359	8b cb		 mov	 ecx, ebx
  0035b	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax
  00361	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1093 : //	pMover->m_nTxp	= (long)qry->GetInt( "m_nTxp" );
; 1094 : 	pMover->m_dwMode	= (DWORD)qry->GetInt( "m_dwMode" );

  00366	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MFHALOPE@m_dwMode?$AA@
  0036b	8b cb		 mov	 ecx, ebx
  0036d	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax
  00373	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1095 : 	pMover->m_bPlayer	= 1;
; 1096 : 	pMover->m_nDeathExp	= qry->GetExpInteger( "m_nDeathExp" );

  00378	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@MAONGJJI@m_nDeathExp?$AA@
  0037d	8b cb		 mov	 ecx, ebx
  0037f	89 86 e4 02 00
	00		 mov	 DWORD PTR [esi+740], eax
  00385	c7 86 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+140], 1
  0038f	e8 00 00 00 00	 call	 ?GetInt64@CQuery@@QAE_JPAD@Z ; CQuery::GetInt64

; 1097 : 	pMover->m_nDeathLevel = qry->GetInt( "m_nDeathLevel" );

  00394	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@JALGGJEE@m_nDeathLevel?$AA@
  00399	8b cb		 mov	 ecx, ebx
  0039b	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  003a1	89 96 fc 00 00
	00		 mov	 DWORD PTR [esi+252], edx
  003a7	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1098 : 	pMover->m_nSkillLevel	= qry->GetInt( "m_SkillLv" );

  003ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09MFLDFMGF@m_SkillLv?$AA@
  003b1	8b cb		 mov	 ecx, ebx
  003b3	89 86 e8 00 00
	00		 mov	 DWORD PTR [esi+232], eax
  003b9	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1099 : 	pMover->m_nSkillPoint	= qry->GetInt( "m_SkillPoint" );

  003be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@FMKKCMCC@m_SkillPoint?$AA@
  003c3	8b cb		 mov	 ecx, ebx
  003c5	89 86 08 41 00
	00		 mov	 DWORD PTR [esi+16648], eax
  003cb	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1100 : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 1101 : 	pMover->m_nHonor	= qry->GetInt( "m_nHonor" );

  003d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08JOEHCELE@m_nHonor?$AA@
  003d5	8b cb		 mov	 ecx, ebx
  003d7	89 86 0c 41 00
	00		 mov	 DWORD PTR [esi+16652], eax
  003dd	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1102 : #endif	// __HONORABLE_TITLE			// 
; 1103 : 
; 1104 : }

  003e2	8b 4c 24 44	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+72]
  003e6	5f		 pop	 edi
  003e7	89 86 44 42 00
	00		 mov	 DWORD PTR [esi+16964], eax
  003ed	5e		 pop	 esi
  003ee	5b		 pop	 ebx
  003ef	33 cc		 xor	 ecx, esp
  003f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f6	83 c4 3c	 add	 esp, 60			; 0000003cH
  003f9	c2 0c 00	 ret	 12			; 0000000cH
?GetBaseCharacter@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetBaseCharacter
_TEXT	ENDS
PUBLIC	?GetHonor@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetHonor
PUBLIC	??_C@_0CA@DBOKEMLK@usp_Master_Select?5?8?$CF02d?8?0?8?$CF07d?8?$AA@ ; `string'
PUBLIC	??_C@_03KHPNBODO@sec?$AA@			; `string'
PUBLIC	??_C@_03BFBOJKCM@c01?$AA@			; `string'
PUBLIC	??_C@_03DODDMJOP@c02?$AA@			; `string'
PUBLIC	??_C@_03CHCIPIKO@c03?$AA@			; `string'
PUBLIC	??_C@_03GIGJGOGJ@c04?$AA@			; `string'
PUBLIC	??_C@_03HBHCFPCI@c05?$AA@			; `string'
PUBLIC	??_C@_03FKFPAMOL@c06?$AA@			; `string'
PUBLIC	??_C@_03EDEEDNKK@c07?$AA@			; `string'
PUBLIC	??_C@_03MENMCBGF@c08?$AA@			; `string'
PUBLIC	??_C@_03NNMHBACE@c09?$AA@			; `string'
PUBLIC	??_C@_03NMHMBFK@c10?$AA@			; `string'
PUBLIC	??_C@_03BENMPABL@c11?$AA@			; `string'
PUBLIC	??_C@_03DPPBKDNI@c12?$AA@			; `string'
PUBLIC	??_C@_03CGOKJCJJ@c13?$AA@			; `string'
PUBLIC	??_C@_03GJKLAEFO@c14?$AA@			; `string'
PUBLIC	??_C@_03HALADFBP@c15?$AA@			; `string'
PUBLIC	??_C@_03FLJNGGNM@c16?$AA@			; `string'
PUBLIC	??_C@_03ECIGFHJN@c17?$AA@			; `string'
PUBLIC	??_C@_03MFBOELFC@c18?$AA@			; `string'
PUBLIC	??_C@_03NMAFHKBD@c19?$AA@			; `string'
PUBLIC	??_C@_03PIBHPAD@c20?$AA@			; `string'
PUBLIC	??_C@_03BGJKEOEC@c21?$AA@			; `string'
PUBLIC	??_C@_03DNLHBNIB@c22?$AA@			; `string'
PUBLIC	??_C@_03CEKMCMMA@c23?$AA@			; `string'
PUBLIC	??_C@_03GLONLKAH@c24?$AA@			; `string'
PUBLIC	??_C@_03HCPGILEG@c25?$AA@			; `string'
PUBLIC	??_C@_03FJNLNIIF@c26?$AA@			; `string'
PUBLIC	??_C@_03EAMAOJME@c27?$AA@			; `string'
PUBLIC	??_C@_03MHFIPFAL@c28?$AA@			; `string'
PUBLIC	??_C@_03NOEDMEEK@c29?$AA@			; `string'
PUBLIC	??_C@_03OEDBFDE@c30?$AA@			; `string'
PUBLIC	??_C@_03BHFICEHF@c31?$AA@			; `string'
PUBLIC	??_C@_03DMHFHHLG@c32?$AA@			; `string'
PUBLIC	??_C@_03CFGOEGPH@c33?$AA@			; `string'
PUBLIC	??_C@_03GKCPNADA@c34?$AA@			; `string'
PUBLIC	??_C@_03HDDEOBHB@c35?$AA@			; `string'
PUBLIC	??_C@_03FIBJLCLC@c36?$AA@			; `string'
PUBLIC	??_C@_03EBACIDPD@c37?$AA@			; `string'
PUBLIC	??_C@_03MGJKJPDM@c38?$AA@			; `string'
PUBLIC	??_C@_03NPIBKOHN@c39?$AA@			; `string'
PUBLIC	??_C@_03LAMADLB@c40?$AA@			; `string'
PUBLIC	??_C@_03BCBHDCPA@c41?$AA@			; `string'
PUBLIC	??_C@_03DJDKGBDD@c42?$AA@			; `string'
PUBLIC	??_C@_03CACBFAHC@c43?$AA@			; `string'
PUBLIC	??_C@_03GPGAMGLF@c44?$AA@			; `string'
PUBLIC	??_C@_03HGHLPHPE@c45?$AA@			; `string'
PUBLIC	??_C@_03FNFGKEDH@c46?$AA@			; `string'
PUBLIC	??_C@_03EEENJFHG@c47?$AA@			; `string'
PUBLIC	??_C@_03MDNFIJLJ@c48?$AA@			; `string'
PUBLIC	??_C@_03NKMOLIPI@c49?$AA@			; `string'
PUBLIC	??_C@_03KMOGJIG@c50?$AA@			; `string'
EXTRN	?Instance@CTitleManager@@SAPAV1@XZ:NEAR		; CTitleManager::Instance
EXTRN	?GetIdxType@CTitleManager@@QAEHH@Z:NEAR		; CTitleManager::GetIdxType
;	COMDAT ??_C@_0CA@DBOKEMLK@usp_Master_Select?5?8?$CF02d?8?0?8?$CF07d?8?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_C@_0CA@DBOKEMLK@usp_Master_Select?5?8?$CF02d?8?0?8?$CF07d?8?$AA@ DB 'u'
	DB	'sp_Master_Select ''%02d'',''%07d''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHPNBODO@sec?$AA@
CONST	SEGMENT
??_C@_03KHPNBODO@sec?$AA@ DB 'sec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BFBOJKCM@c01?$AA@
CONST	SEGMENT
??_C@_03BFBOJKCM@c01?$AA@ DB 'c01', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DODDMJOP@c02?$AA@
CONST	SEGMENT
??_C@_03DODDMJOP@c02?$AA@ DB 'c02', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CHCIPIKO@c03?$AA@
CONST	SEGMENT
??_C@_03CHCIPIKO@c03?$AA@ DB 'c03', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GIGJGOGJ@c04?$AA@
CONST	SEGMENT
??_C@_03GIGJGOGJ@c04?$AA@ DB 'c04', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBHCFPCI@c05?$AA@
CONST	SEGMENT
??_C@_03HBHCFPCI@c05?$AA@ DB 'c05', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKFPAMOL@c06?$AA@
CONST	SEGMENT
??_C@_03FKFPAMOL@c06?$AA@ DB 'c06', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EDEEDNKK@c07?$AA@
CONST	SEGMENT
??_C@_03EDEEDNKK@c07?$AA@ DB 'c07', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MENMCBGF@c08?$AA@
CONST	SEGMENT
??_C@_03MENMCBGF@c08?$AA@ DB 'c08', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNMHBACE@c09?$AA@
CONST	SEGMENT
??_C@_03NNMHBACE@c09?$AA@ DB 'c09', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NMHMBFK@c10?$AA@
CONST	SEGMENT
??_C@_03NMHMBFK@c10?$AA@ DB 'c10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BENMPABL@c11?$AA@
CONST	SEGMENT
??_C@_03BENMPABL@c11?$AA@ DB 'c11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DPPBKDNI@c12?$AA@
CONST	SEGMENT
??_C@_03DPPBKDNI@c12?$AA@ DB 'c12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGOKJCJJ@c13?$AA@
CONST	SEGMENT
??_C@_03CGOKJCJJ@c13?$AA@ DB 'c13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJKLAEFO@c14?$AA@
CONST	SEGMENT
??_C@_03GJKLAEFO@c14?$AA@ DB 'c14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HALADFBP@c15?$AA@
CONST	SEGMENT
??_C@_03HALADFBP@c15?$AA@ DB 'c15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FLJNGGNM@c16?$AA@
CONST	SEGMENT
??_C@_03FLJNGGNM@c16?$AA@ DB 'c16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECIGFHJN@c17?$AA@
CONST	SEGMENT
??_C@_03ECIGFHJN@c17?$AA@ DB 'c17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFBOELFC@c18?$AA@
CONST	SEGMENT
??_C@_03MFBOELFC@c18?$AA@ DB 'c18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NMAFHKBD@c19?$AA@
CONST	SEGMENT
??_C@_03NMAFHKBD@c19?$AA@ DB 'c19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PIBHPAD@c20?$AA@
CONST	SEGMENT
??_C@_03PIBHPAD@c20?$AA@ DB 'c20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BGJKEOEC@c21?$AA@
CONST	SEGMENT
??_C@_03BGJKEOEC@c21?$AA@ DB 'c21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNLHBNIB@c22?$AA@
CONST	SEGMENT
??_C@_03DNLHBNIB@c22?$AA@ DB 'c22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CEKMCMMA@c23?$AA@
CONST	SEGMENT
??_C@_03CEKMCMMA@c23?$AA@ DB 'c23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GLONLKAH@c24?$AA@
CONST	SEGMENT
??_C@_03GLONLKAH@c24?$AA@ DB 'c24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HCPGILEG@c25?$AA@
CONST	SEGMENT
??_C@_03HCPGILEG@c25?$AA@ DB 'c25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FJNLNIIF@c26?$AA@
CONST	SEGMENT
??_C@_03FJNLNIIF@c26?$AA@ DB 'c26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EAMAOJME@c27?$AA@
CONST	SEGMENT
??_C@_03EAMAOJME@c27?$AA@ DB 'c27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHFIPFAL@c28?$AA@
CONST	SEGMENT
??_C@_03MHFIPFAL@c28?$AA@ DB 'c28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NOEDMEEK@c29?$AA@
CONST	SEGMENT
??_C@_03NOEDMEEK@c29?$AA@ DB 'c29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEDBFDE@c30?$AA@
CONST	SEGMENT
??_C@_03OEDBFDE@c30?$AA@ DB 'c30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHFICEHF@c31?$AA@
CONST	SEGMENT
??_C@_03BHFICEHF@c31?$AA@ DB 'c31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DMHFHHLG@c32?$AA@
CONST	SEGMENT
??_C@_03DMHFHHLG@c32?$AA@ DB 'c32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFGOEGPH@c33?$AA@
CONST	SEGMENT
??_C@_03CFGOEGPH@c33?$AA@ DB 'c33', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GKCPNADA@c34?$AA@
CONST	SEGMENT
??_C@_03GKCPNADA@c34?$AA@ DB 'c34', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDDEOBHB@c35?$AA@
CONST	SEGMENT
??_C@_03HDDEOBHB@c35?$AA@ DB 'c35', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FIBJLCLC@c36?$AA@
CONST	SEGMENT
??_C@_03FIBJLCLC@c36?$AA@ DB 'c36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EBACIDPD@c37?$AA@
CONST	SEGMENT
??_C@_03EBACIDPD@c37?$AA@ DB 'c37', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGJKJPDM@c38?$AA@
CONST	SEGMENT
??_C@_03MGJKJPDM@c38?$AA@ DB 'c38', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NPIBKOHN@c39?$AA@
CONST	SEGMENT
??_C@_03NPIBKOHN@c39?$AA@ DB 'c39', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LAMADLB@c40?$AA@
CONST	SEGMENT
??_C@_03LAMADLB@c40?$AA@ DB 'c40', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BCBHDCPA@c41?$AA@
CONST	SEGMENT
??_C@_03BCBHDCPA@c41?$AA@ DB 'c41', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DJDKGBDD@c42?$AA@
CONST	SEGMENT
??_C@_03DJDKGBDD@c42?$AA@ DB 'c42', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CACBFAHC@c43?$AA@
CONST	SEGMENT
??_C@_03CACBFAHC@c43?$AA@ DB 'c43', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GPGAMGLF@c44?$AA@
CONST	SEGMENT
??_C@_03GPGAMGLF@c44?$AA@ DB 'c44', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HGHLPHPE@c45?$AA@
CONST	SEGMENT
??_C@_03HGHLPHPE@c45?$AA@ DB 'c45', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FNFGKEDH@c46?$AA@
CONST	SEGMENT
??_C@_03FNFGKEDH@c46?$AA@ DB 'c46', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EEENJFHG@c47?$AA@
CONST	SEGMENT
??_C@_03EEENJFHG@c47?$AA@ DB 'c47', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDNFIJLJ@c48?$AA@
CONST	SEGMENT
??_C@_03MDNFIJLJ@c48?$AA@ DB 'c48', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NKMOLIPI@c49?$AA@
CONST	SEGMENT
??_C@_03NKMOLIPI@c49?$AA@ DB 'c49', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KMOGJIG@c50?$AA@
CONST	SEGMENT
??_C@_03KMOGJIG@c50?$AA@ DB 'c50', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetHonor@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
tv830 = -41580						; size = 4
$T212464 = -41580					; size = 4
tv833 = -41576						; size = 4
_nCurrentTitleCount$ = -41572				; size = 4
_aTempHonor$ = -41568					; size = 600
_szQuery$ = -40968					; size = 40960
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetHonor@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetHonor, COMDAT
; _this$ = ecx

; 1107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 6c a2 00 00	 mov	 eax, 41580		; 0000a26cH
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _qry$[ebp]
  00019	33 c5		 xor	 eax, ebp
  0001b	56		 push	 esi
  0001c	8b 75 08	 mov	 esi, DWORD PTR _pMover$[ebp]
  0001f	57		 push	 edi
  00020	89 84 24 74 a2
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+41592], eax

; 1108 : 	//     
; 1109 : 	char szQuery[QUERY_SIZE]	= { 0,};

  00027	33 c0		 xor	 eax, eax
  00029	c6 84 24 70 02
	00 00 00	 mov	 BYTE PTR _szQuery$[esp+41592], 0
  00031	b9 ff 27 00 00	 mov	 ecx, 10239		; 000027ffH
  00036	8d bc 24 71 02
	00 00		 lea	 edi, DWORD PTR _szQuery$[esp+41593]
  0003d	f3 ab		 rep stosd

; 1110 : 	sprintf( szQuery,
; 1111 : 		"usp_Master_Select '%02d','%07d'",
; 1112 : 		g_appInfo.dwSys, pMover->m_idPlayer );

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00045	66 ab		 stosw
  00047	aa		 stosb
  00048	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  0004e	50		 push	 eax
  0004f	51		 push	 ecx
  00050	8d 94 24 78 02
	00 00		 lea	 edx, DWORD PTR _szQuery$[esp+41600]
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@DBOKEMLK@usp_Master_Select?5?8?$CF02d?8?0?8?$CF07d?8?$AA@
  0005c	52		 push	 edx

; 1126 : 			return;
; 1127 : 
; 1128 : 		aTempHonor[nSec][0] = qry->GetInt( "c01" );

  0005d	89 74 24 1c	 mov	 DWORD PTR $T212464[esp+41608], esi
  00061	e8 00 00 00 00	 call	 _sprintf
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	8d 84 24 70 02
	00 00		 lea	 eax, DWORD PTR _szQuery$[esp+41592]
  00070	50		 push	 eax
  00071	8b cb		 mov	 ecx, ebx
  00073	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00078	85 c0		 test	 eax, eax
  0007a	75 36		 jne	 SHORT $L209283
  0007c	8d 8c 24 70 02
	00 00		 lea	 ecx, DWORD PTR _szQuery$[esp+41592]
  00083	51		 push	 ecx
  00084	68 5b 04 00 00	 push	 1115			; 0000045bH
  00089	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  00093	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 1205 : 		}
; 1206 : 	}
; 1207 : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b 8c 24 68 a2
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+41580]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 0c 00	 ret	 12			; 0000000cH
$L209283:

; 1113 : 	if( FALSE == qry->Exec( szQuery ) )
; 1114 : 	{
; 1115 : 		WriteLog( "%s, %d\t%s", __FILE__, __LINE__, szQuery );
; 1116 : 		return;
; 1117 : 	}
; 1118 : 	
; 1119 : 	int aTempHonor[3][50]={0,};

  000b2	33 c0		 xor	 eax, eax
  000b4	b9 95 00 00 00	 mov	 ecx, 149		; 00000095H
  000b9	8d 7c 24 1c	 lea	 edi, DWORD PTR _aTempHonor$[esp+41596]
  000bd	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _aTempHonor$[esp+41592], 0
  000c5	f3 ab		 rep stosd

; 1120 : 	int nSec = 0;
; 1121 : 	while( qry->Fetch() )

  000c7	8b cb		 mov	 ecx, ebx
  000c9	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  000ce	85 c0		 test	 eax, eax
  000d0	0f 84 ae 03 00
	00		 je	 $L209288
  000d6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$L209287:

; 1122 : 	{
; 1123 : 		int nSec = qry->GetInt( "sec" );

  000e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03KHPNBODO@sec?$AA@
  000e5	8b cb		 mov	 ecx, ebx
  000e7	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1124 : 		nSec--;

  000ec	48		 dec	 eax

; 1125 : 		if(nSec > 2 || nSec < 0 )

  000ed	83 f8 02	 cmp	 eax, 2
  000f0	0f 8f 0c 04 00
	00		 jg	 $L209352
  000f6	85 c0		 test	 eax, eax
  000f8	0f 8c 04 04 00
	00		 jl	 $L209352

; 1126 : 			return;
; 1127 : 
; 1128 : 		aTempHonor[nSec][0] = qry->GetInt( "c01" );

  000fe	8b f0		 mov	 esi, eax
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BFBOJKCM@c01?$AA@
  00105	69 f6 c8 00 00
	00		 imul	 esi, 200		; 000000c8H
  0010b	8b cb		 mov	 ecx, ebx
  0010d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1129 : 		aTempHonor[nSec][1] = qry->GetInt( "c02" );

  00112	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DODDMJOP@c02?$AA@
  00117	8b cb		 mov	 ecx, ebx
  00119	89 44 34 1c	 mov	 DWORD PTR _aTempHonor$[esp+esi+41596], eax
  0011d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1130 : 		aTempHonor[nSec][2] = qry->GetInt( "c03" );

  00122	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03CHCIPIKO@c03?$AA@
  00127	8b cb		 mov	 ecx, ebx
  00129	89 44 34 20	 mov	 DWORD PTR _aTempHonor$[esp+esi+41600], eax
  0012d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1131 : 		aTempHonor[nSec][3] = qry->GetInt( "c04" );

  00132	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03GIGJGOGJ@c04?$AA@
  00137	8b cb		 mov	 ecx, ebx
  00139	89 44 34 24	 mov	 DWORD PTR _aTempHonor$[esp+esi+41604], eax
  0013d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1132 : 		aTempHonor[nSec][4] = qry->GetInt( "c05" );

  00142	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03HBHCFPCI@c05?$AA@
  00147	8b cb		 mov	 ecx, ebx
  00149	89 44 34 28	 mov	 DWORD PTR _aTempHonor$[esp+esi+41608], eax
  0014d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1133 : 		aTempHonor[nSec][5] = qry->GetInt( "c06" );

  00152	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03FKFPAMOL@c06?$AA@
  00157	8b cb		 mov	 ecx, ebx
  00159	89 44 34 2c	 mov	 DWORD PTR _aTempHonor$[esp+esi+41612], eax
  0015d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1134 : 		aTempHonor[nSec][6] = qry->GetInt( "c07" );

  00162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03EDEEDNKK@c07?$AA@
  00167	8b cb		 mov	 ecx, ebx
  00169	89 44 34 30	 mov	 DWORD PTR _aTempHonor$[esp+esi+41616], eax
  0016d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1135 : 		aTempHonor[nSec][7] = qry->GetInt( "c08" );

  00172	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03MENMCBGF@c08?$AA@
  00177	8b cb		 mov	 ecx, ebx
  00179	89 44 34 34	 mov	 DWORD PTR _aTempHonor$[esp+esi+41620], eax
  0017d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1136 : 		aTempHonor[nSec][8] = qry->GetInt( "c09" );

  00182	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NNMHBACE@c09?$AA@
  00187	8b cb		 mov	 ecx, ebx
  00189	89 44 34 38	 mov	 DWORD PTR _aTempHonor$[esp+esi+41624], eax
  0018d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1137 : 		aTempHonor[nSec][9] = qry->GetInt( "c10" );

  00192	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NMHMBFK@c10?$AA@
  00197	8b cb		 mov	 ecx, ebx
  00199	89 44 34 3c	 mov	 DWORD PTR _aTempHonor$[esp+esi+41628], eax
  0019d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1138 : 
; 1139 : 		aTempHonor[nSec][10] = qry->GetInt( "c11" );

  001a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BENMPABL@c11?$AA@
  001a7	8b cb		 mov	 ecx, ebx
  001a9	89 44 34 40	 mov	 DWORD PTR _aTempHonor$[esp+esi+41632], eax
  001ad	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1140 : 		aTempHonor[nSec][11] = qry->GetInt( "c12" );

  001b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DPPBKDNI@c12?$AA@
  001b7	8b cb		 mov	 ecx, ebx
  001b9	89 44 34 44	 mov	 DWORD PTR _aTempHonor$[esp+esi+41636], eax
  001bd	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1141 : 		aTempHonor[nSec][12] = qry->GetInt( "c13" );

  001c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03CGOKJCJJ@c13?$AA@
  001c7	8b cb		 mov	 ecx, ebx
  001c9	89 44 34 48	 mov	 DWORD PTR _aTempHonor$[esp+esi+41640], eax
  001cd	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1142 : 		aTempHonor[nSec][13] = qry->GetInt( "c14" );

  001d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03GJKLAEFO@c14?$AA@
  001d7	8b cb		 mov	 ecx, ebx
  001d9	89 44 34 4c	 mov	 DWORD PTR _aTempHonor$[esp+esi+41644], eax
  001dd	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1143 : 		aTempHonor[nSec][14] = qry->GetInt( "c15" );

  001e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03HALADFBP@c15?$AA@
  001e7	8b cb		 mov	 ecx, ebx
  001e9	89 44 34 50	 mov	 DWORD PTR _aTempHonor$[esp+esi+41648], eax
  001ed	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1144 : 		aTempHonor[nSec][15] = qry->GetInt( "c16" );

  001f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03FLJNGGNM@c16?$AA@
  001f7	8b cb		 mov	 ecx, ebx
  001f9	89 44 34 54	 mov	 DWORD PTR _aTempHonor$[esp+esi+41652], eax
  001fd	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1145 : 		aTempHonor[nSec][16] = qry->GetInt( "c17" );

  00202	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03ECIGFHJN@c17?$AA@
  00207	8b cb		 mov	 ecx, ebx
  00209	89 44 34 58	 mov	 DWORD PTR _aTempHonor$[esp+esi+41656], eax
  0020d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1146 : 		aTempHonor[nSec][17] = qry->GetInt( "c18" );

  00212	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03MFBOELFC@c18?$AA@
  00217	8b cb		 mov	 ecx, ebx
  00219	89 44 34 5c	 mov	 DWORD PTR _aTempHonor$[esp+esi+41660], eax
  0021d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1147 : 		aTempHonor[nSec][18] = qry->GetInt( "c19" );

  00222	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NMAFHKBD@c19?$AA@
  00227	8b cb		 mov	 ecx, ebx
  00229	89 44 34 60	 mov	 DWORD PTR _aTempHonor$[esp+esi+41664], eax
  0022d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1148 : 		aTempHonor[nSec][19] = qry->GetInt( "c20" );

  00232	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03PIBHPAD@c20?$AA@
  00237	8b cb		 mov	 ecx, ebx
  00239	89 44 34 64	 mov	 DWORD PTR _aTempHonor$[esp+esi+41668], eax
  0023d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1149 : 
; 1150 : 		aTempHonor[nSec][20] = qry->GetInt( "c21" );

  00242	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BGJKEOEC@c21?$AA@
  00247	8b cb		 mov	 ecx, ebx
  00249	89 44 34 68	 mov	 DWORD PTR _aTempHonor$[esp+esi+41672], eax
  0024d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1151 : 		aTempHonor[nSec][21] = qry->GetInt( "c22" );

  00252	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DNLHBNIB@c22?$AA@
  00257	8b cb		 mov	 ecx, ebx
  00259	89 44 34 6c	 mov	 DWORD PTR _aTempHonor$[esp+esi+41676], eax
  0025d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1152 : 		aTempHonor[nSec][22] = qry->GetInt( "c23" );

  00262	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03CEKMCMMA@c23?$AA@
  00267	8b cb		 mov	 ecx, ebx
  00269	89 44 34 70	 mov	 DWORD PTR _aTempHonor$[esp+esi+41680], eax
  0026d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1153 : 		aTempHonor[nSec][23] = qry->GetInt( "c24" );

  00272	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03GLONLKAH@c24?$AA@
  00277	8b cb		 mov	 ecx, ebx
  00279	89 44 34 74	 mov	 DWORD PTR _aTempHonor$[esp+esi+41684], eax
  0027d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1154 : 		aTempHonor[nSec][24] = qry->GetInt( "c25" );

  00282	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03HCPGILEG@c25?$AA@
  00287	8b cb		 mov	 ecx, ebx
  00289	89 44 34 78	 mov	 DWORD PTR _aTempHonor$[esp+esi+41688], eax
  0028d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1155 : 		aTempHonor[nSec][25] = qry->GetInt( "c26" );

  00292	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03FJNLNIIF@c26?$AA@
  00297	8b cb		 mov	 ecx, ebx
  00299	89 44 34 7c	 mov	 DWORD PTR _aTempHonor$[esp+esi+41692], eax
  0029d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1156 : 		aTempHonor[nSec][26] = qry->GetInt( "c27" );

  002a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03EAMAOJME@c27?$AA@
  002a7	8b cb		 mov	 ecx, ebx
  002a9	89 84 34 80 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41696], eax
  002b0	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1157 : 		aTempHonor[nSec][27] = qry->GetInt( "c28" );

  002b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03MHFIPFAL@c28?$AA@
  002ba	8b cb		 mov	 ecx, ebx
  002bc	89 84 34 84 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41700], eax
  002c3	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1158 : 		aTempHonor[nSec][28] = qry->GetInt( "c29" );

  002c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NOEDMEEK@c29?$AA@
  002cd	8b cb		 mov	 ecx, ebx
  002cf	89 84 34 88 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41704], eax
  002d6	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1159 : 		aTempHonor[nSec][29] = qry->GetInt( "c30" );

  002db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03OEDBFDE@c30?$AA@
  002e0	8b cb		 mov	 ecx, ebx
  002e2	89 84 34 8c 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41708], eax
  002e9	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1160 : 
; 1161 : 		aTempHonor[nSec][30] = qry->GetInt( "c31" );

  002ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BHFICEHF@c31?$AA@
  002f3	8b cb		 mov	 ecx, ebx
  002f5	89 84 34 90 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41712], eax
  002fc	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1162 : 		aTempHonor[nSec][31] = qry->GetInt( "c32" );

  00301	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DMHFHHLG@c32?$AA@
  00306	8b cb		 mov	 ecx, ebx
  00308	89 84 34 94 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41716], eax
  0030f	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1163 : 		aTempHonor[nSec][32] = qry->GetInt( "c33" );

  00314	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03CFGOEGPH@c33?$AA@
  00319	8b cb		 mov	 ecx, ebx
  0031b	89 84 34 98 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41720], eax
  00322	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1164 : 		aTempHonor[nSec][33] = qry->GetInt( "c34" );

  00327	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03GKCPNADA@c34?$AA@
  0032c	8b cb		 mov	 ecx, ebx
  0032e	89 84 34 9c 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41724], eax
  00335	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1165 : 		aTempHonor[nSec][34] = qry->GetInt( "c35" );

  0033a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03HDDEOBHB@c35?$AA@
  0033f	8b cb		 mov	 ecx, ebx
  00341	89 84 34 a0 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41728], eax
  00348	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1166 : 		aTempHonor[nSec][35] = qry->GetInt( "c36" );

  0034d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03FIBJLCLC@c36?$AA@
  00352	8b cb		 mov	 ecx, ebx
  00354	89 84 34 a4 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41732], eax
  0035b	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1167 : 		aTempHonor[nSec][36] = qry->GetInt( "c37" );

  00360	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03EBACIDPD@c37?$AA@
  00365	8b cb		 mov	 ecx, ebx
  00367	89 84 34 a8 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41736], eax
  0036e	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1168 : 		aTempHonor[nSec][37] = qry->GetInt( "c38" );

  00373	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03MGJKJPDM@c38?$AA@
  00378	8b cb		 mov	 ecx, ebx
  0037a	89 84 34 ac 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41740], eax
  00381	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1169 : 		aTempHonor[nSec][38] = qry->GetInt( "c39" );

  00386	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NPIBKOHN@c39?$AA@
  0038b	8b cb		 mov	 ecx, ebx
  0038d	89 84 34 b0 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41744], eax
  00394	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1170 : 		aTempHonor[nSec][39] = qry->GetInt( "c40" );

  00399	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03LAMADLB@c40?$AA@
  0039e	8b cb		 mov	 ecx, ebx
  003a0	89 84 34 b4 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41748], eax
  003a7	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  003ac	89 84 34 b4 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41748], eax

; 1171 : 
; 1172 : 		aTempHonor[nSec][40] = qry->GetInt( "c41" );

  003b3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03BCBHDCPA@c41?$AA@
  003b8	8b cb		 mov	 ecx, ebx
  003ba	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1173 : 		aTempHonor[nSec][41] = qry->GetInt( "c42" );

  003bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03DJDKGBDD@c42?$AA@
  003c4	8b cb		 mov	 ecx, ebx
  003c6	89 84 34 bc 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41756], eax
  003cd	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1174 : 		aTempHonor[nSec][42] = qry->GetInt( "c43" );

  003d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03CACBFAHC@c43?$AA@
  003d7	8b cb		 mov	 ecx, ebx
  003d9	89 84 34 c0 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41760], eax
  003e0	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1175 : 		aTempHonor[nSec][43] = qry->GetInt( "c44" );

  003e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03GPGAMGLF@c44?$AA@
  003ea	8b cb		 mov	 ecx, ebx
  003ec	89 84 34 c4 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41764], eax
  003f3	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1176 : 		aTempHonor[nSec][44] = qry->GetInt( "c45" );

  003f8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03HGHLPHPE@c45?$AA@
  003fd	8b cb		 mov	 ecx, ebx
  003ff	89 84 34 c8 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41768], eax
  00406	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1177 : 		aTempHonor[nSec][45] = qry->GetInt( "c46" );

  0040b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03FNFGKEDH@c46?$AA@
  00410	8b cb		 mov	 ecx, ebx
  00412	89 84 34 cc 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41772], eax
  00419	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1178 : 		aTempHonor[nSec][46] = qry->GetInt( "c47" );

  0041e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03EEENJFHG@c47?$AA@
  00423	8b cb		 mov	 ecx, ebx
  00425	89 84 34 d0 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41776], eax
  0042c	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1179 : 		aTempHonor[nSec][47] = qry->GetInt( "c48" );

  00431	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03MDNFIJLJ@c48?$AA@
  00436	8b cb		 mov	 ecx, ebx
  00438	89 84 34 d4 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41780], eax
  0043f	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1180 : 		aTempHonor[nSec][48] = qry->GetInt( "c49" );

  00444	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NKMOLIPI@c49?$AA@
  00449	8b cb		 mov	 ecx, ebx
  0044b	89 84 34 d8 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41784], eax
  00452	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1181 : 		aTempHonor[nSec][49] = qry->GetInt( "c50" );

  00457	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03KMOGJIG@c50?$AA@
  0045c	8b cb		 mov	 ecx, ebx
  0045e	89 84 34 dc 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41788], eax
  00465	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  0046a	8b cb		 mov	 ecx, ebx
  0046c	89 84 34 dc 00
	00 00		 mov	 DWORD PTR _aTempHonor$[esp+esi+41788], eax
  00473	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  00478	85 c0		 test	 eax, eax
  0047a	0f 85 60 fc ff
	ff		 jne	 $L209287

; 1120 : 	int nSec = 0;
; 1121 : 	while( qry->Fetch() )

  00480	8b 74 24 0c	 mov	 esi, DWORD PTR $T212464[esp+41592]
$L209288:

; 1182 : 	}
; 1183 : 
; 1184 : 	int nMonster = 0,nItem = 0,nEtc = 0;
; 1185 : 	int nType = 0;
; 1186 : 	int nCurrentTitleCount =  CTitleManager::Instance()->m_nCurrentTitleCount;

  00484	e8 00 00 00 00	 call	 ?Instance@CTitleManager@@SAPAV1@XZ ; CTitleManager::Instance
  00489	8b 40 30	 mov	 eax, DWORD PTR [eax+48]

; 1187 : 	ASSERT( nCurrentTitleCount <= MAX_HONOR_TITLE );
; 1188 : 	for(int i=0;i<nCurrentTitleCount;i++)

  0048c	33 ff		 xor	 edi, edi
  0048e	85 c0		 test	 eax, eax
  00490	89 44 24 14	 mov	 DWORD PTR _nCurrentTitleCount$[esp+41592], eax
  00494	7e 6c		 jle	 SHORT $L209352
  00496	8d 94 24 e0 00
	00 00		 lea	 edx, DWORD PTR _aTempHonor$[esp+41792]
  0049d	8d 84 24 a8 01
	00 00		 lea	 eax, DWORD PTR _aTempHonor$[esp+41992]
  004a4	8d 5c 24 18	 lea	 ebx, DWORD PTR _aTempHonor$[esp+41592]
  004a8	89 54 24 0c	 mov	 DWORD PTR tv830[esp+41592], edx
  004ac	89 44 24 10	 mov	 DWORD PTR tv833[esp+41592], eax
  004b0	81 c6 48 42 00
	00		 add	 esi, 16968		; 00004248H
$L209350:

; 1189 : 	{
; 1190 : 		nType = CTitleManager::Instance()->GetIdxType(i);

  004b6	57		 push	 edi
  004b7	e8 00 00 00 00	 call	 ?Instance@CTitleManager@@SAPAV1@XZ ; CTitleManager::Instance
  004bc	8b c8		 mov	 ecx, eax
  004be	e8 00 00 00 00	 call	 ?GetIdxType@CTitleManager@@QAEHH@Z ; CTitleManager::GetIdxType

; 1191 : 		if( nType == HI_HUNT_MONSTER)

  004c3	83 f8 04	 cmp	 eax, 4
  004c6	75 11		 jne	 SHORT $L209353

; 1192 : 		{
; 1193 : 			pMover->SetHonorCount(i,aTempHonor[2][nMonster]);

  004c8	8b 44 24 10	 mov	 eax, DWORD PTR tv833[esp+41592]
  004cc	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1194 : 			nMonster++;

  004ce	83 c0 04	 add	 eax, 4
  004d1	89 0e		 mov	 DWORD PTR [esi], ecx
  004d3	89 44 24 10	 mov	 DWORD PTR tv833[esp+41592], eax

; 1195 : 		}
; 1196 : 		else if( nType == HI_USE_ITEM)

  004d7	eb 1d		 jmp	 SHORT $L209351
$L209353:
  004d9	83 f8 05	 cmp	 eax, 5
  004dc	75 11		 jne	 SHORT $L209355

; 1197 : 		{
; 1198 : 			pMover->SetHonorCount(i,aTempHonor[1][nItem]);

  004de	8b 44 24 0c	 mov	 eax, DWORD PTR tv830[esp+41592]
  004e2	8b 10		 mov	 edx, DWORD PTR [eax]

; 1199 : 			nItem++;

  004e4	83 c0 04	 add	 eax, 4
  004e7	89 16		 mov	 DWORD PTR [esi], edx
  004e9	89 44 24 0c	 mov	 DWORD PTR tv830[esp+41592], eax

; 1200 : 		}
; 1201 : 		else

  004ed	eb 07		 jmp	 SHORT $L209351
$L209355:

; 1202 : 		{
; 1203 : 			pMover->SetHonorCount(i,aTempHonor[0][nEtc]);

  004ef	8b 03		 mov	 eax, DWORD PTR [ebx]
  004f1	89 06		 mov	 DWORD PTR [esi], eax

; 1204 : 			nEtc++;

  004f3	83 c3 04	 add	 ebx, 4
$L209351:
  004f6	8b 44 24 14	 mov	 eax, DWORD PTR _nCurrentTitleCount$[esp+41592]
  004fa	47		 inc	 edi
  004fb	83 c6 04	 add	 esi, 4
  004fe	3b f8		 cmp	 edi, eax
  00500	7c b4		 jl	 SHORT $L209350
$L209352:

; 1205 : 		}
; 1206 : 	}
; 1207 : }

  00502	8b 8c 24 74 a2
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+41592]
  00509	5f		 pop	 edi
  0050a	5e		 pop	 esi
  0050b	33 cd		 xor	 ecx, ebp
  0050d	5b		 pop	 ebx
  0050e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00513	8b e5		 mov	 esp, ebp
  00515	5d		 pop	 ebp
  00516	c2 0c 00	 ret	 12			; 0000000cH
?GetHonor@CDbManager@@QAEXPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetHonor
_TEXT	ENDS
PUBLIC	?GetSMMode@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetSMMode
PUBLIC	??_C@_0L@JCPOPMED@m_dwSMTime?$AA@		; `string'
;	COMDAT ??_C@_0L@JCPOPMED@m_dwSMTime?$AA@
CONST	SEGMENT
??_C@_0L@JCPOPMED@m_dwSMTime?$AA@ DB 'm_dwSMTime', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetSMMode@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_CountStr$ = -3092					; size = 4
$T212478 = -3088					; size = 4
$T212475 = -3084					; size = 4
_SMCnt$ = -3080						; size = 3072
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetSMMode@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetSMMode, COMDAT
; _this$ = ecx

; 1343 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 14 0c 00
	00		 sub	 esp, 3092		; 00000c14H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	8b 55 0c	 mov	 edx, DWORD PTR _qry$[ebp]
  00014	33 c5		 xor	 eax, ebp
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _pMover$[ebp]
  0001a	89 84 24 14 0c
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+3096], eax
  00021	8b 45 10	 mov	 eax, DWORD PTR _lpDbOverlappedPlus$[ebp]
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	89 4c 24 14	 mov	 DWORD PTR $T212475[esp+3104], ecx

; 1374 : 				}
; 1375 : 				break;
; 1376 : 			}
; 1377 : 			++IndexSM;

  0002a	89 44 24 10	 mov	 DWORD PTR $T212478[esp+3104], eax
  0002e	c6 44 24 18 00	 mov	 BYTE PTR _SMCnt$[esp+3104], 0
  00033	33 c0		 xor	 eax, eax
  00035	b9 ff 02 00 00	 mov	 ecx, 767		; 000002ffH
  0003a	8d 7c 24 19	 lea	 edi, DWORD PTR _SMCnt$[esp+3105]
  0003e	f3 ab		 rep stosd
  00040	8d 4c 24 18	 lea	 ecx, DWORD PTR _SMCnt$[esp+3104]
  00044	66 ab		 stosw
  00046	51		 push	 ecx
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JCPOPMED@m_dwSMTime?$AA@
  0004c	8b ca		 mov	 ecx, edx
  0004e	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+3112], 0
  00056	aa		 stosb
  00057	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0005c	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_04HIBGFPH@NULL?$AA@
  00061	8d 74 24 18	 lea	 esi, DWORD PTR _SMCnt$[esp+3104]
  00065	b9 05 00 00 00	 mov	 ecx, 5
  0006a	33 c0		 xor	 eax, eax
  0006c	f3 a6		 repe cmpsb
  0006e	74 05		 je	 SHORT $L212481
  00070	1b c0		 sbb	 eax, eax
  00072	83 d8 ff	 sbb	 eax, -1
$L212481:

; 1344 : 	int CountStr	= 0;
; 1345 : 	int IndexSM	= 0;
; 1346 : 	char SMCnt[3072]		= {0,};
; 1347 : 	qry->GetStr( "m_dwSMTime", SMCnt );
; 1348 : 	if( 0 != strcmp( SMCnt, "NULL" ) ) 

  00075	85 c0		 test	 eax, eax
  00077	0f 84 eb 00 00
	00		 je	 $L209465

; 1349 : 	{
; 1350 : 		VERIFYSTRING_RETURN( SMCnt, pMover->m_szName );

  0007d	8b 54 24 10	 mov	 edx, DWORD PTR $T212478[esp+3104]
  00081	52		 push	 edx
  00082	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00085	50		 push	 eax
  00086	68 46 05 00 00	 push	 1350			; 00000546H
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00090	8d 4c 24 28	 lea	 ecx, DWORD PTR _SMCnt$[esp+3120]
  00094	51		 push	 ecx
  00095	8b 4c 24 28	 mov	 ecx, DWORD PTR $T212475[esp+3124]
  00099	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  0009e	85 c0		 test	 eax, eax
  000a0	75 17		 jne	 SHORT $L212479

; 1378 : 		}			
; 1379 : 	}
; 1380 : 	return TRUE;
; 1381 : }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b 8c 24 10 0c
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+3092]
  000ac	33 cd		 xor	 ecx, ebp
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
$L212479:

; 1351 : 		while( '$' != SMCnt[CountStr] )

  000b9	80 7c 24 18 24	 cmp	 BYTE PTR _SMCnt$[esp+3104], 36 ; 00000024H
  000be	0f 84 a4 00 00
	00		 je	 $L209465
  000c4	be f7 ff ff ff	 mov	 esi, -9			; fffffff7H
  000c9	8d bb a4 44 00
	00		 lea	 edi, DWORD PTR [ebx+17572]
  000cf	90		 npad	 1
$L209464:

; 1352 : 		{
; 1353 : 			pMover->m_dwSMTime[IndexSM] = (DWORD)GetIntFromStr( SMCnt, &CountStr );

  000d0	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+3104]
  000d4	52		 push	 edx
  000d5	8d 44 24 1c	 lea	 eax, DWORD PTR _SMCnt$[esp+3108]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  000df	83 c4 08	 add	 esp, 8

; 1354 : 			switch( IndexSM )

  000e2	83 fe 09	 cmp	 esi, 9
  000e5	89 07		 mov	 DWORD PTR [edi], eax
  000e7	77 6b		 ja	 SHORT $L209468
  000e9	0f b6 8e 00 00
	00 00		 movzx	 ecx, BYTE PTR $L212482[esi]
  000f0	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L212485[ecx*4]
$L209471:

; 1355 : 			{
; 1356 : 			case SM_MAX_HP50:
; 1357 : 				{
; 1358 : 					pMover->m_nPlusMaxHitPoint = (LONG)GetIntFromStr( SMCnt, &CountStr );

  000f7	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+3104]
  000fb	52		 push	 edx
  000fc	8d 44 24 1c	 lea	 eax, DWORD PTR _SMCnt$[esp+3108]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00106	89 83 a0 44 00
	00		 mov	 DWORD PTR [ebx+17568], eax

; 1359 : 				}
; 1360 : 				break;

  0010c	eb 43		 jmp	 SHORT $L212484
$L209473:

; 1361 : 			case SM_RESIST_ATTACK_LEFT:
; 1362 : 				{
; 1363 : 					pMover->m_nAttackResistLeft = (BYTE)GetIntFromStr( SMCnt, &CountStr );

  0010e	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+3104]
  00112	51		 push	 ecx
  00113	8d 54 24 1c	 lea	 edx, DWORD PTR _SMCnt$[esp+3108]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0011d	88 83 0c 45 00
	00		 mov	 BYTE PTR [ebx+17676], al

; 1364 : 				}
; 1365 : 				break;

  00123	eb 2c		 jmp	 SHORT $L212484
$L209475:

; 1366 : 			case SM_RESIST_ATTACK_RIGHT:
; 1367 : 				{
; 1368 : 					pMover->m_nAttackResistRight = (BYTE)GetIntFromStr( SMCnt, &CountStr );

  00125	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+3104]
  00129	50		 push	 eax
  0012a	8d 4c 24 1c	 lea	 ecx, DWORD PTR _SMCnt$[esp+3108]
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00134	88 83 0d 45 00
	00		 mov	 BYTE PTR [ebx+17677], al

; 1369 : 				}
; 1370 : 				break;

  0013a	eb 15		 jmp	 SHORT $L212484
$L209477:

; 1371 : 			case SM_RESIST_DEFENSE:
; 1372 : 				{
; 1373 : 					pMover->m_nDefenseResist = (BYTE)GetIntFromStr( SMCnt, &CountStr );

  0013c	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+3104]
  00140	52		 push	 edx
  00141	8d 44 24 1c	 lea	 eax, DWORD PTR _SMCnt$[esp+3108]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0014b	88 83 0e 45 00
	00		 mov	 BYTE PTR [ebx+17678], al
$L212484:
  00151	83 c4 08	 add	 esp, 8
$L209468:

; 1351 : 		while( '$' != SMCnt[CountStr] )

  00154	8b 4c 24 0c	 mov	 ecx, DWORD PTR _CountStr$[esp+3104]
  00158	8a 44 0c 18	 mov	 al, BYTE PTR _SMCnt$[esp+ecx+3104]

; 1374 : 				}
; 1375 : 				break;
; 1376 : 			}
; 1377 : 			++IndexSM;

  0015c	83 c7 04	 add	 edi, 4
  0015f	46		 inc	 esi
  00160	3c 24		 cmp	 al, 36			; 00000024H
  00162	0f 85 68 ff ff
	ff		 jne	 $L209464
$L209465:

; 1378 : 		}			
; 1379 : 	}
; 1380 : 	return TRUE;
; 1381 : }

  00168	8b 8c 24 1c 0c
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+3104]
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	33 cd		 xor	 ecx, ebp
  00173	b8 01 00 00 00	 mov	 eax, 1
  00178	5b		 pop	 ebx
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c2 0c 00	 ret	 12			; 0000000cH
$L212485:
  00184	00 00 00 00	 DD	 $L209471
  00188	00 00 00 00	 DD	 $L209473
  0018c	00 00 00 00	 DD	 $L209475
  00190	00 00 00 00	 DD	 $L209477
  00194	00 00 00 00	 DD	 $L209468
$L212482:
  00198	00		 DB	 0
  00199	04		 DB	 4
  0019a	04		 DB	 4
  0019b	04		 DB	 4
  0019c	04		 DB	 4
  0019d	04		 DB	 4
  0019e	04		 DB	 4
  0019f	01		 DB	 1
  001a0	02		 DB	 2
  001a1	03		 DB	 3
?GetSMMode@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetSMMode
_TEXT	ENDS
PUBLIC	?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z ; CDbManager::GetOneItem
EXTRN	?CheckValidItem@@YAHKF@Z:NEAR			; CheckValidItem
EXTRN	?GetInstance@CPlayerDataCenter@@SAPAV1@XZ:NEAR	; CPlayerDataCenter::GetInstance
EXTRN	?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z:NEAR ; CPlayerDataCenter::GetPlayerString
; Function compile flags: /Ogty
;	COMDAT ?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
_pstrItem$ = 12						; size = 4
tv226 = 16						; size = 4
_pLocation$ = 16					; size = 4
?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z PROC NEAR ; CDbManager::GetOneItem, COMDAT
; _this$ = ecx

; 1426 : {

  00000	53		 push	 ebx

; 1427 : 	int IndexItem		= 0;
; 1428 : 	IndexItem	= GetIntPaFromStr( pstrItem, pLocation );

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR _pLocation$[esp]
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	8b 74 24 14	 mov	 esi, DWORD PTR _pstrItem$[esp+8]
  0000b	57		 push	 edi
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1429 : 	pItemElem->m_dwItemId	= (DWORD)GetIntPaFromStr( pstrItem, pLocation );

  00013	8b 7c 24 1c	 mov	 edi, DWORD PTR _pItemElem$[esp+20]
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b e8		 mov	 ebp, eax
  0001b	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1430 : 	BOOL bEquip	= GetIntPaFromStr( pstrItem, pLocation );

  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00025	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1431 : 	int nTrade	= GetIntPaFromStr( pstrItem, pLocation );

  0002a	53		 push	 ebx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1432 : 	GetStrPaFromStr( pstrItem, pItemElem->m_szItemText, pLocation );

  00031	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  00034	53		 push	 ebx
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	89 44 24 48	 mov	 DWORD PTR tv226[esp+56], eax
  0003b	e8 00 00 00 00	 call	 ?GetStrPaFromStr@@YAXPAD0PAH@Z ; GetStrPaFromStr

; 1433 : 	pItemElem->m_nItemNum	= GetIntPaFromStr( pstrItem, pLocation );

  00040	53		 push	 ebx
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1434 : 
; 1435 : 	if( CheckValidItem( pItemElem->m_dwItemId, pItemElem->m_nItemNum ) == FALSE )

  00047	50		 push	 eax
  00048	66 89 47 72	 mov	 WORD PTR [edi+114], ax
  0004c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?CheckValidItem@@YAHKF@Z ; CheckValidItem
  00055	83 c4 3c	 add	 esp, 60			; 0000003cH
  00058	85 c0		 test	 eax, eax
  0005a	75 06		 jne	 SHORT $L209514

; 1436 : 		pItemElem->m_nItemNum	= 1;

  0005c	66 c7 47 72 01
	00		 mov	 WORD PTR [edi+114], 1
$L209514:

; 1437 : 
; 1438 : 	pItemElem->m_nRepairNumber	= (BYTE)GetIntPaFromStr( pstrItem, pLocation );

  00062	53		 push	 ebx
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1439 : 	pItemElem->m_nHitPoint	= GetIntPaFromStr( pstrItem, pLocation );

  00069	53		 push	 ebx
  0006a	56		 push	 esi
  0006b	88 47 70	 mov	 BYTE PTR [edi+112], al
  0006e	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1440 : 	pItemElem->m_nRepair	= GetIntPaFromStr( pstrItem, pLocation );

  00073	53		 push	 ebx
  00074	56		 push	 esi
  00075	89 47 74	 mov	 DWORD PTR [edi+116], eax
  00078	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1441 : 	int nMaterial	= GetIntPaFromStr( pstrItem, pLocation );

  0007d	53		 push	 ebx
  0007e	56		 push	 esi
  0007f	89 47 6c	 mov	 DWORD PTR [edi+108], eax
  00082	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1442 : 	pItemElem->m_byFlag		= (BYTE)GetIntPaFromStr( pstrItem, pLocation );

  00087	53		 push	 ebx
  00088	56		 push	 esi
  00089	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1443 : 	pItemElem->SetSerialNumber( GetSerialNumberPaFromStr( pstrItem, pLocation ) );

  0008e	53		 push	 ebx
  0008f	56		 push	 esi
  00090	88 47 71	 mov	 BYTE PTR [edi+113], al
  00093	e8 00 00 00 00	 call	 ?GetSerialNumberPaFromStr@@YAKPADPAH@Z ; GetSerialNumberPaFromStr

; 1444 : 	pItemElem->SetOption( GetIntPaFromStr( pstrItem, pLocation ) );

  00098	53		 push	 ebx
  00099	56		 push	 esi
  0009a	89 47 30	 mov	 DWORD PTR [edi+48], eax
  0009d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1445 : 	pItemElem->m_bItemResist	= (BYTE)GetIntPaFromStr( pstrItem, pLocation );

  000a2	53		 push	 ebx
  000a3	56		 push	 esi
  000a4	89 47 68	 mov	 DWORD PTR [edi+104], eax
  000a7	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  000ac	83 c4 40	 add	 esp, 64			; 00000040H

; 1446 : 	pItemElem->m_nResistAbilityOption	= GetIntPaFromStr( pstrItem, pLocation );

  000af	53		 push	 ebx
  000b0	56		 push	 esi
  000b1	88 47 7c	 mov	 BYTE PTR [edi+124], al
  000b4	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1447 : 	pItemElem->m_idGuild = (u_long)GetIntPaFromStr( pstrItem, pLocation );

  000b9	53		 push	 ebx
  000ba	56		 push	 esi
  000bb	89 87 80 00 00
	00		 mov	 DWORD PTR [edi+128], eax
  000c1	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1448 : 	pItemElem->m_nResistSMItemId = GetIntPaFromStr( pstrItem, pLocation );

  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	89 47 78	 mov	 DWORD PTR [edi+120], eax
  000cb	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  000d0	89 87 84 00 00
	00		 mov	 DWORD PTR [edi+132], eax

; 1449 : 	pItemElem->m_dwObjId		= IndexItem;
; 1450 : #if __VER >= 11 // __MA_VER11_05	//     world,database,neuz
; 1451 : 	if( pItemElem->m_dwItemId == II_SYS_SYS_SCR_SEALCHARACTER )

  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	83 c4 18	 add	 esp, 24			; 00000018H
  000dc	3d 6c 67 00 00	 cmp	 eax, 26476		; 0000676cH
  000e1	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  000e4	75 3f		 jne	 SHORT $L212503

; 1452 : 	{
; 1453 : 	#if __VER >= 11 // __SYS_PLAYER_DATA
; 1454 : 		CPlayerDataCenter::GetInstance()->m_Access.Enter();

  000e6	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  000eb	83 c0 20	 add	 eax, 32			; 00000020H
  000ee	50		 push	 eax
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1455 : 		const char*	lpszPlayer	= CPlayerDataCenter::GetInstance()->GetPlayerString( pItemElem->m_nHitPoint );

  000f5	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  000f8	51		 push	 ecx
  000f9	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  000fe	8b c8		 mov	 ecx, eax
  00100	e8 00 00 00 00	 call	 ?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z ; CPlayerDataCenter::GetPlayerString

; 1456 : 	#else	// __SYS_PLAYER_DATA
; 1457 : 		LPCSTR lpszPlayer	= prj.GetPlayerString( pItemElem->m_nHitPoint );
; 1458 : 	#endif	// __SYS_PLAYER_DATA
; 1459 : 		if( lpszPlayer != NULL)

  00105	85 c0		 test	 eax, eax
  00107	74 0d		 je	 SHORT $L209522

; 1460 : 			memcpy(pItemElem->m_szItemText,lpszPlayer,sizeof(pItemElem->m_szItemText));

  00109	8b 7c 24 1c	 mov	 edi, DWORD PTR tv226[esp+12]
  0010d	b9 08 00 00 00	 mov	 ecx, 8
  00112	8b f0		 mov	 esi, eax
  00114	f3 a5		 rep movsd
$L209522:

; 1461 : 	#if __VER >= 11 // __SYS_PLAYER_DATA
; 1462 : 		CPlayerDataCenter::GetInstance()->m_Access.Leave();

  00116	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  0011b	83 c0 20	 add	 eax, 32			; 00000020H
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$L212503:

; 1463 : 	#endif	// __SYS_PLAYER_DATA
; 1464 : 	}
; 1465 : #endif // __MA_VER11_05	//     world,database,neuz
; 1466 : 	
; 1467 : 
; 1468 : 	++*pLocation;

  00125	8b 03		 mov	 eax, DWORD PTR [ebx]
  00127	5f		 pop	 edi
  00128	40		 inc	 eax
  00129	89 03		 mov	 DWORD PTR [ebx], eax
  0012b	5e		 pop	 esi

; 1469 : 	return IndexItem;

  0012c	8b c5		 mov	 eax, ebp
  0012e	5d		 pop	 ebp
  0012f	5b		 pop	 ebx

; 1470 : }

  00130	c2 0c 00	 ret	 12			; 0000000cH
?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z ENDP	; CDbManager::GetOneItem
_TEXT	ENDS
PUBLIC	?GetOneSkill@CDbManager@@QAEXPAUtagSKILL@@PADPAH@Z ; CDbManager::GetOneSkill
; Function compile flags: /Ogty
;	COMDAT ?GetOneSkill@CDbManager@@QAEXPAUtagSKILL@@PADPAH@Z
_TEXT	SEGMENT
_pSkill$ = 8						; size = 4
_pstrSkill$ = 12					; size = 4
_pLocation$ = 16					; size = 4
?GetOneSkill@CDbManager@@QAEXPAUtagSKILL@@PADPAH@Z PROC NEAR ; CDbManager::GetOneSkill, COMDAT
; _this$ = ecx

; 1473 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 1474 : 	(DWORD)GetIntPaFromStr( pstrSkill, pLocation );

  00002	8b 74 24 14	 mov	 esi, DWORD PTR _pLocation$[esp+4]
  00006	57		 push	 edi
  00007	8b 7c 24 14	 mov	 edi, DWORD PTR _pstrSkill$[esp+8]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1475 : 	pSkill->dwLevel	= (DWORD)GetIntPaFromStr( pstrSkill, pLocation );

  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00019	8b 5c 24 20	 mov	 ebx, DWORD PTR _pSkill$[esp+24]

; 1476 : 	pSkill->dwSkill	= (DWORD)GetIntPaFromStr( pstrSkill, pLocation );

  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00022	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1477 : 	(BOOL)GetIntPaFromStr( pstrSkill, pLocation );

  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 03		 mov	 DWORD PTR [ebx], eax
  0002b	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1478 : 	
; 1479 : 	++*pLocation;

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	83 c4 20	 add	 esp, 32			; 00000020H
  00035	40		 inc	 eax
  00036	5f		 pop	 edi
  00037	89 06		 mov	 DWORD PTR [esi], eax
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx

; 1480 : }

  0003b	c2 0c 00	 ret	 12			; 0000000cH
?GetOneSkill@CDbManager@@QAEXPAUtagSKILL@@PADPAH@Z ENDP	; CDbManager::GetOneSkill
_TEXT	ENDS
PUBLIC	?GetOneQuest@CDbManager@@QAEXPAUtagQuest@@PADPAH@Z ; CDbManager::GetOneQuest
; Function compile flags: /Ogty
;	COMDAT ?GetOneQuest@CDbManager@@QAEXPAUtagQuest@@PADPAH@Z
_TEXT	SEGMENT
_pQuest$ = 8						; size = 4
_pstrQuest$ = 12					; size = 4
_pLocation$ = 16					; size = 4
?GetOneQuest@CDbManager@@QAEXPAUtagQuest@@PADPAH@Z PROC NEAR ; CDbManager::GetOneQuest, COMDAT
; _this$ = ecx

; 1483 : {

  00000	53		 push	 ebx

; 1484 : 	pQuest->m_wId				= (WORD)GetIntPaFromStr( pstrQuest, pLocation );

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _pstrQuest$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 18	 mov	 edi, DWORD PTR _pLocation$[esp+8]
  0000b	57		 push	 edi
  0000c	53		 push	 ebx
  0000d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00012	8b 74 24 18	 mov	 esi, DWORD PTR _pQuest$[esp+16]

; 1485 : 	pQuest->m_nState			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  00016	57		 push	 edi
  00017	53		 push	 ebx
  00018	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  0001c	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1486 : 	pQuest->m_wTime				= (WORD)GetIntPaFromStr( pstrQuest, pLocation );

  00021	57		 push	 edi
  00022	53		 push	 ebx
  00023	88 06		 mov	 BYTE PTR [esi], al
  00025	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1487 : 
; 1488 : //	pQuest->m_nKillNPCNum[0]	= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );	// chipi_091015 - NPC Kill Quest  ( BYTE -> WORD )
; 1489 : //	pQuest->m_nKillNPCNum[1]	= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );	// chipi_091015 - NPC Kill Quest  ( BYTE -> WORD )
; 1490 : 	pQuest->m_nKillNPCNum[0]	= (WORD)GetIntPaFromStr( pstrQuest, pLocation );	// chipi_091015 - NPC Kill Quest  ( BYTE -> WORD )

  0002a	57		 push	 edi
  0002b	53		 push	 ebx
  0002c	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  00030	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1491 : 	pQuest->m_nKillNPCNum[1]	= (WORD)GetIntPaFromStr( pstrQuest, pLocation );	// chipi_091015 - NPC Kill Quest  ( BYTE -> WORD )

  00035	57		 push	 edi
  00036	53		 push	 ebx
  00037	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  0003b	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 1492 : 	pQuest->m_bPatrol			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  00040	57		 push	 edi
  00041	53		 push	 ebx
  00042	66 89 46 08	 mov	 WORD PTR [esi+8], ax
  00046	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  0004b	8a 4e 0a	 mov	 cl, BYTE PTR [esi+10]
  0004e	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  00051	32 c8		 xor	 cl, al
  00053	80 e1 01	 and	 cl, 1
  00056	32 d1		 xor	 dl, cl

; 1493 : 	pQuest->m_bReserve2			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  00058	57		 push	 edi
  00059	53		 push	 ebx
  0005a	88 56 0a	 mov	 BYTE PTR [esi+10], dl
  0005d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00062	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  00065	d0 e0		 shl	 al, 1
  00067	32 c2		 xor	 al, dl
  00069	24 02		 and	 al, 2
  0006b	32 d0		 xor	 dl, al

; 1494 : 	pQuest->m_bReserve3			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  0006d	57		 push	 edi
  0006e	53		 push	 ebx
  0006f	88 56 0a	 mov	 BYTE PTR [esi+10], dl
  00072	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00077	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  0007a	c0 e0 02	 shl	 al, 2
  0007d	32 c2		 xor	 al, dl
  0007f	83 c4 40	 add	 esp, 64			; 00000040H
  00082	24 04		 and	 al, 4
  00084	32 d0		 xor	 dl, al

; 1495 : 	pQuest->m_bReserve4			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  00086	57		 push	 edi
  00087	53		 push	 ebx
  00088	88 56 0a	 mov	 BYTE PTR [esi+10], dl
  0008b	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00090	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  00093	c0 e0 03	 shl	 al, 3
  00096	32 c2		 xor	 al, dl
  00098	24 08		 and	 al, 8
  0009a	32 d0		 xor	 dl, al

; 1496 : 	pQuest->m_bReserve5			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  0009c	57		 push	 edi
  0009d	53		 push	 ebx
  0009e	88 56 0a	 mov	 BYTE PTR [esi+10], dl
  000a1	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  000a6	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  000a9	c0 e0 04	 shl	 al, 4
  000ac	32 c2		 xor	 al, dl
  000ae	24 10		 and	 al, 16			; 00000010H
  000b0	32 d0		 xor	 dl, al

; 1497 : 	pQuest->m_bReserve6			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  000b2	57		 push	 edi
  000b3	53		 push	 ebx
  000b4	88 56 0a	 mov	 BYTE PTR [esi+10], dl
  000b7	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  000bc	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  000bf	c0 e0 05	 shl	 al, 5
  000c2	32 c2		 xor	 al, dl
  000c4	24 20		 and	 al, 32			; 00000020H
  000c6	32 d0		 xor	 dl, al
  000c8	88 56 0a	 mov	 BYTE PTR [esi+10], dl

; 1498 : 	pQuest->m_bReserve7			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  000cb	57		 push	 edi
  000cc	53		 push	 ebx
  000cd	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  000d2	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  000d5	c0 e0 06	 shl	 al, 6
  000d8	32 c2		 xor	 al, dl
  000da	24 40		 and	 al, 64			; 00000040H
  000dc	32 d0		 xor	 dl, al

; 1499 : 	pQuest->m_bReserve8			= (BYTE)GetIntPaFromStr( pstrQuest, pLocation );

  000de	57		 push	 edi
  000df	53		 push	 ebx
  000e0	88 56 0a	 mov	 BYTE PTR [esi+10], dl
  000e3	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  000e8	8a 56 0a	 mov	 dl, BYTE PTR [esi+10]
  000eb	c0 e0 07	 shl	 al, 7
  000ee	80 e2 7f	 and	 dl, 127			; 0000007fH
  000f1	0a d0		 or	 dl, al
  000f3	88 56 0a	 mov	 BYTE PTR [esi+10], dl

; 1500 : 
; 1501 : 	++*pLocation;

  000f6	8b 07		 mov	 eax, DWORD PTR [edi]
  000f8	83 c4 28	 add	 esp, 40			; 00000028H
  000fb	40		 inc	 eax
  000fc	89 07		 mov	 DWORD PTR [edi], eax
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx

; 1502 : }

  00101	c2 0c 00	 ret	 12			; 0000000cH
?GetOneQuest@CDbManager@@QAEXPAUtagQuest@@PADPAH@Z ENDP	; CDbManager::GetOneQuest
_TEXT	ENDS
PUBLIC	?RemovePenya@CDbManager@@AAEHPAVCQuery@@PADPAVCMover@@HHD@Z ; CDbManager::RemovePenya
EXTRN	?RemoveItemDeleteQuery@CDbManager@@AAEHPAVCQuery@@PADH@Z:NEAR ; CDbManager::RemoveItemDeleteQuery
; Function compile flags: /Ogty
;	COMDAT ?RemovePenya@CDbManager@@AAEHPAVCQuery@@PADPAVCMover@@HHD@Z
_TEXT	SEGMENT
_pQry$ = 8						; size = 4
_szSql$ = 12						; size = 4
_pMover$ = 16						; size = 4
_nItem_Count$ = 20					; size = 4
_nNo$ = 24						; size = 4
_chState$ = 28						; size = 1
?RemovePenya@CDbManager@@AAEHPAVCQuery@@PADPAVCMover@@HHD@Z PROC NEAR ; CDbManager::RemovePenya, COMDAT
; _this$ = ecx

; 1551 : 	if( RemoveItemDeleteQuery( pQry, szSql, nNo ) == FALSE )

  00000	8b 44 24 14	 mov	 eax, DWORD PTR _nNo$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR _szSql$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR _pQry$[esp]
  0000d	52		 push	 edx
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?RemoveItemDeleteQuery@CDbManager@@AAEHPAVCQuery@@PADH@Z ; CDbManager::RemoveItemDeleteQuery
  00014	85 c0		 test	 eax, eax
  00016	75 03		 jne	 SHORT $L209588

; 1567 : }

  00018	c2 18 00	 ret	 24			; 00000018H
$L209588:

; 1552 : 		return FALSE;
; 1553 : 
; 1554 : 	if( chState == 'I' )	// Inventory

  0001b	80 7c 24 18 49	 cmp	 BYTE PTR _chState$[esp-4], 73 ; 00000049H
  00020	75 1a		 jne	 SHORT $L209589

; 1555 : 	{
; 1556 : 		pMover->AddGold( -nItem_Count, FALSE );

  00022	8b 4c 24 10	 mov	 ecx, DWORD PTR _nItem_Count$[esp-4]
  00026	f7 d9		 neg	 ecx
  00028	6a 00		 push	 0
  0002a	51		 push	 ecx
  0002b	8b 4c 24 14	 mov	 ecx, DWORD PTR _pMover$[esp+4]
  0002f	e8 00 00 00 00	 call	 ?AddGold@CMover@@QAEHHH@Z ; CMover::AddGold

; 1564 : 	}
; 1565 : 
; 1566 : 	return TRUE;

  00034	b8 01 00 00 00	 mov	 eax, 1

; 1567 : }

  00039	c2 18 00	 ret	 24			; 00000018H
$L209589:

; 1557 : 	}
; 1558 : 	else	// Bank
; 1559 : 	{
; 1560 : 		DWORD dwGoldBank	= pMover->m_dwGoldBank[pMover->m_nSlot];

  0003c	8b 44 24 0c	 mov	 eax, DWORD PTR _pMover$[esp-4]
  00040	0f b6 90 c8 00
	00 00		 movzx	 edx, BYTE PTR [eax+200]
  00047	56		 push	 esi
  00048	8d 8c 90 d0 41
	00 00		 lea	 ecx, DWORD PTR [eax+edx*4+16848]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	57		 push	 edi

; 1561 : 		pMover->m_dwGoldBank[pMover->m_nSlot]	-= nItem_Count;

  00052	8b 7c 24 18	 mov	 edi, DWORD PTR _nItem_Count$[esp+4]
  00056	8b f2		 mov	 esi, edx
  00058	2b f7		 sub	 esi, edi
  0005a	89 31		 mov	 DWORD PTR [ecx], esi

; 1562 : 		if( dwGoldBank < pMover->m_dwGoldBank[pMover->m_nSlot] )

  0005c	0f b6 88 c8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+200]
  00063	8b b4 88 d0 41
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+16848]
  0006a	5f		 pop	 edi
  0006b	3b d6		 cmp	 edx, esi
  0006d	5e		 pop	 esi
  0006e	73 12		 jae	 SHORT $L209592

; 1563 : 			pMover->m_dwGoldBank[pMover->m_nSlot]	= 0;

  00070	0f b6 90 c8 00
	00 00		 movzx	 edx, BYTE PTR [eax+200]
  00077	c7 84 90 d0 41
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx*4+16848], 0
$L209592:

; 1564 : 	}
; 1565 : 
; 1566 : 	return TRUE;

  00082	b8 01 00 00 00	 mov	 eax, 1

; 1567 : }

  00087	c2 18 00	 ret	 24			; 00000018H
?RemovePenya@CDbManager@@AAEHPAVCQuery@@PADPAVCMover@@HHD@Z ENDP ; CDbManager::RemovePenya
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1412 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 1413 : 		if (_Mysize < _Off)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Off$[esp+4]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000c	73 05		 jae	 SHORT $L210307

; 1414 : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L210307:

; 1415 : 		if (_Mysize - _Off < _N0)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 54 24 14	 mov	 edx, DWORD PTR __N0$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c2		 cmp	 eax, edx
  0001e	73 02		 jae	 SHORT $L210308

; 1416 : 			_N0 = _Mysize - _Off;	// trim _N0 to size

  00020	8b d0		 mov	 edx, eax
$L210308:

; 1417 : 
; 1418 : 		size_type _Ans = _N0 == 0 ? 0
; 1419 : 			: _Traits::compare(_Myptr() + _Off, _Ptr,
; 1420 : 				_N0 < _Count ? _N0 : _Count);

  00022	85 d2		 test	 edx, edx
  00024	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Count$[esp+8]
  00028	74 2e		 je	 SHORT $L212533
  0002a	3b d3		 cmp	 edx, ebx
  0002c	8b ca		 mov	 ecx, edx
  0002e	72 02		 jb	 SHORT $L212513
  00030	8b cb		 mov	 ecx, ebx
$L212513:
  00032	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00036	72 05		 jb	 SHORT $L212525
  00038	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003b	eb 03		 jmp	 SHORT $L212526
$L212525:
  0003d	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L212526:
  00040	57		 push	 edi
  00041	8b 7c 24 1c	 mov	 edi, DWORD PTR __Ptr$[esp+12]
  00045	8d 34 28	 lea	 esi, DWORD PTR [eax+ebp]
  00048	33 c0		 xor	 eax, eax
  0004a	f3 a6		 repe cmpsb
  0004c	5f		 pop	 edi
  0004d	74 05		 je	 SHORT $L212532
  0004f	1b c0		 sbb	 eax, eax
  00051	83 d8 ff	 sbb	 eax, -1
$L212532:

; 1421 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1422 : 			: _N0 == _Count ? 0 : +1);

  00054	85 c0		 test	 eax, eax
  00056	75 14		 jne	 SHORT $L212517
$L212533:
  00058	3b d3		 cmp	 edx, ebx
  0005a	73 09		 jae	 SHORT $L212516
  0005c	5e		 pop	 esi
  0005d	5d		 pop	 ebp
  0005e	83 c8 ff	 or	 eax, -1
  00061	5b		 pop	 ebx

; 1423 : 		}

  00062	c2 10 00	 ret	 16			; 00000010H
$L212516:

; 1421 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1422 : 			: _N0 == _Count ? 0 : +1);

  00065	33 c0		 xor	 eax, eax
  00067	3b d3		 cmp	 edx, ebx
  00069	0f 95 c0	 setne	 al
$L212517:
  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	5b		 pop	 ebx

; 1423 : 		}

  0006f	c2 10 00	 ret	 16			; 00000010H
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC NEAR ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC NEAR	; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<int,std::allocator<int> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator-
_TEXT	ENDS
PUBLIC	?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z ; CItemContainer<CItemElem>::GetItem
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z
_TEXT	SEGMENT
_pItemProp$ = 8						; size = 4
_nAbilityOption$ = 12					; size = 4
_nItemResist$ = 16					; size = 4
_nResistAbilityOption$ = 20				; size = 4
?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z PROC NEAR ; CItemContainer<CItemElem>::GetItem, COMDAT
; _this$ = ecx

; 689  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 698  : 			{
; 699  : 				return pItemElem;
; 700  : 			}
; 701  : 		}
; 702  : 	}
; 703  : 	return NULL;

  00004	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  00007	33 d2		 xor	 edx, edx
  00009	85 ff		 test	 edi, edi
  0000b	76 4b		 jbe	 SHORT $L210782

; 690  : 	int nId;
; 691  : 	for( DWORD i = 0 ; i < m_dwItemMax ; i++ )

  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
$L212591:

; 692  : 	{
; 693  : 		nId		= m_apIndex[i];

  00010	8b 06		 mov	 eax, DWORD PTR [esi]

; 694  : 		if( 0 <= nId && m_apItem[nId].IsEmpty() == FALSE )

  00012	85 c0		 test	 eax, eax
  00014	7c 3a		 jl	 SHORT $L210781
  00016	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
  00019	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0001c	c1 e0 05	 shl	 eax, 5
  0001f	03 c3		 add	 eax, ebx
  00021	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  00024	85 db		 test	 ebx, ebx
  00026	74 28		 je	 SHORT $L210781

; 695  : 		{
; 696  : 			T* pItemElem = &m_apItem[nId];
; 697  : 			if( pItemElem->m_dwItemId == pItemProp->dwID && pItemElem->GetOption() == nAbilityOption && pItemElem->m_bItemResist == nItemResist && pItemElem->m_nResistAbilityOption == nResistAbilityOption )

  00028	8b 6c 24 14	 mov	 ebp, DWORD PTR _pItemProp$[esp+12]
  0002c	3b 5d 00	 cmp	 ebx, DWORD PTR [ebp]
  0002f	75 1f		 jne	 SHORT $L210781
  00031	8b 5c 24 18	 mov	 ebx, DWORD PTR _nAbilityOption$[esp+12]
  00035	39 58 68	 cmp	 DWORD PTR [eax+104], ebx
  00038	75 16		 jne	 SHORT $L210781
  0003a	0f b6 58 7c	 movzx	 ebx, BYTE PTR [eax+124]
  0003e	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _nItemResist$[esp+12]
  00042	75 0c		 jne	 SHORT $L210781
  00044	8b 5c 24 20	 mov	 ebx, DWORD PTR _nResistAbilityOption$[esp+12]
  00048	39 98 80 00 00
	00		 cmp	 DWORD PTR [eax+128], ebx
  0004e	74 0a		 je	 SHORT $L210777
$L210781:

; 690  : 	int nId;
; 691  : 	for( DWORD i = 0 ; i < m_dwItemMax ; i++ )

  00050	42		 inc	 edx
  00051	83 c6 04	 add	 esi, 4
  00054	3b d7		 cmp	 edx, edi
  00056	72 b8		 jb	 SHORT $L212591
$L210782:

; 698  : 			{
; 699  : 				return pItemElem;
; 700  : 			}
; 701  : 		}
; 702  : 	}
; 703  : 	return NULL;

  00058	33 c0		 xor	 eax, eax
$L210777:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	5b		 pop	 ebx

; 704  : }

  0005e	c2 10 00	 ret	 16			; 00000010H
?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z ENDP ; CItemContainer<CItemElem>::GetItem
_TEXT	ENDS
PUBLIC	?UnEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z	; CItemContainer<CItemElem>::UnEquip
; Function compile flags: /Ogty
;	COMDAT ?UnEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?UnEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z PROC NEAR ; CItemContainer<CItemElem>::UnEquip, COMDAT
; _this$ = ecx

; 746  : 	dwIndex		+= m_dwIndexNum;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]

; 747  : 	if( dwIndex >= m_dwItemMax )

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00007	53		 push	 ebx
  00008	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  0000b	03 c3		 add	 eax, ebx
  0000d	3b c2		 cmp	 eax, edx
  0000f	89 44 24 08	 mov	 DWORD PTR _dwIndex$[esp], eax
  00013	72 06		 jb	 SHORT $L210803

; 748  : 		return FALSE;

  00015	33 c0		 xor	 eax, eax
  00017	5b		 pop	 ebx

; 770  : }

  00018	c2 04 00	 ret	 4
$L210803:
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 749  : 
; 750  : 	DWORD dwId	= m_apIndex[dwIndex];

  0001d	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00020	8b 34 87	 mov	 esi, DWORD PTR [edi+eax*4]

; 751  : 
; 752  : 	if( dwId >= m_dwItemMax )
; 753  : 		return FALSE;

  00023	33 c0		 xor	 eax, eax
  00025	3b f2		 cmp	 esi, edx
  00027	73 29		 jae	 SHORT $L212601

; 754  : 
; 755  : 	for( DWORD i = 0; i < m_dwIndexNum; i++ )

  00029	85 db		 test	 ebx, ebx
  0002b	55		 push	 ebp
  0002c	76 21		 jbe	 SHORT $L210809
  0002e	8b ff		 npad	 2
$L210807:

; 756  : 	{
; 757  : 		if( m_apIndex[i] >= m_dwItemMax )

  00030	8b 17		 mov	 edx, DWORD PTR [edi]
  00032	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00035	73 10		 jae	 SHORT $L210808

; 758  : 			continue;
; 759  : 
; 760  : 		if( m_apItem[m_apIndex[i]].IsEmpty() )

  00037	8b 69 0c	 mov	 ebp, DWORD PTR [ecx+12]
  0003a	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  0003d	c1 e2 05	 shl	 edx, 5
  00040	83 7c 2a 08 00	 cmp	 DWORD PTR [edx+ebp+8], 0
  00045	74 11		 je	 SHORT $L212598
$L210808:

; 754  : 
; 755  : 	for( DWORD i = 0; i < m_dwIndexNum; i++ )

  00047	40		 inc	 eax
  00048	83 c7 04	 add	 edi, 4
  0004b	3b c3		 cmp	 eax, ebx
  0004d	72 e1		 jb	 SHORT $L210807
$L210809:

; 767  : 		}
; 768  : 	}
; 769  : 	return FALSE;

  0004f	33 c0		 xor	 eax, eax
  00051	5d		 pop	 ebp
$L212601:
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 770  : }

  00055	c2 04 00	 ret	 4
$L212598:

; 761  : 		{
; 762  : 			m_apItem[m_apIndex[i]].m_dwObjIndex		= NULL_ID;

  00058	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005b	8b 14 82	 mov	 edx, DWORD PTR [edx+eax*4]
  0005e	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
  00061	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  00064	c1 e2 05	 shl	 edx, 5
  00067	c7 44 3a 2c ff
	ff ff ff	 mov	 DWORD PTR [edx+edi+44], -1

; 763  : 			m_apIndex[dwIndex]	= NULL_ID;

  0006f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00072	8b 7c 24 14	 mov	 edi, DWORD PTR _dwIndex$[esp+12]
  00076	c7 04 ba ff ff
	ff ff		 mov	 DWORD PTR [edx+edi*4], -1

; 764  : 			m_apItem[dwId].m_dwObjIndex		= i;

  0007d	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
  00080	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  00083	c1 e2 05	 shl	 edx, 5
  00086	89 44 3a 2c	 mov	 DWORD PTR [edx+edi+44], eax

; 765  : 			m_apIndex[i]	= dwId;

  0008a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0008d	5d		 pop	 ebp
  0008e	5f		 pop	 edi
  0008f	89 34 81	 mov	 DWORD PTR [ecx+eax*4], esi
  00092	5e		 pop	 esi

; 766  : 			return TRUE;

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	5b		 pop	 ebx

; 770  : }

  00099	c2 04 00	 ret	 4
?UnEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z ENDP	; CItemContainer<CItemElem>::UnEquip
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z ; std::_Uninitialized_copy<long *,long *,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z PROC NEAR ; std::_Uninitialized_copy<long *,long *,std::allocator<long> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z ENDP ; std::_Uninitialized_copy<long *,long *,std::allocator<long> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<long,unsigned int,long>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<long,unsigned int,long>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L212621
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L212619:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L212619
  0001b	5e		 pop	 esi
$L212621:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<long,unsigned int,long>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z	; std::copy_backward<int *,int *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z PROC NEAR	; std::copy_backward<int *,int *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::copy_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,unsigned int,int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<int,unsigned int,int>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L212654
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L212652:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L212652
  0001b	5e		 pop	 esi
$L212654:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetItemProp
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\databaseserver\project.h
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 200  : 	ItemProp*	GetItemProp( int nIndex )	{	return m_aPropItem.GetAt( nIndex );	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00007	72 05		 jb	 SHORT $L212676
  00009	33 c0		 xor	 eax, eax
  0000b	c2 04 00	 ret	 4
$L212676:
  0000e	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00014	c2 04 00	 ret	 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ENDP		; CProject::GetItemProp
_TEXT	ENDS
PUBLIC	?GetPropA@CItemElem@@QAEPAUItemProp@@XZ		; CItemElem::GetPropA
EXTRN	?prj@@3VCProject@@A:BYTE			; prj
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ PROC NEAR	; CItemElem::GetPropA, COMDAT
; _this$ = ecx

; 166  : 	ItemProp*	GetProp()	{	return prj.GetItemProp( m_dwItemId );	}

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  00009	72 03		 jb	 SHORT $L212692
  0000b	33 c0		 xor	 eax, eax
  0000d	c3		 ret	 0
$L212692:
  0000e	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+64
  00014	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00017	c3		 ret	 0
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ENDP		; CItemElem::GetPropA
_TEXT	ENDS
PUBLIC	?IsTransformVisPet@CItemElem@@QAEHXZ		; CItemElem::IsTransformVisPet
; Function compile flags: /Ogty
;	COMDAT ?IsTransformVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?IsTransformVisPet@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::IsTransformVisPet, COMDAT
; _this$ = ecx

; 240  : 	BOOL	IsTransformVisPet() { return GetProp() && GetProp()->dwItemKind3 == IK3_PET && m_bTranformVisPet; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	56		 push	 esi
  00004	8b 35 50 00 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+80
  0000a	3b c6		 cmp	 eax, esi
  0000c	73 2e		 jae	 SHORT $L212696
  0000e	8b 15 40 00 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+64
  00014	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  00018	74 22		 je	 SHORT $L212696
  0001a	3b c6		 cmp	 eax, esi
  0001c	72 04		 jb	 SHORT $L212739
  0001e	33 c0		 xor	 eax, eax
  00020	eb 03		 jmp	 SHORT $L212738
$L212739:
  00022	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
$L212738:
  00025	83 78 78 64	 cmp	 DWORD PTR [eax+120], 100 ; 00000064H
  00029	75 11		 jne	 SHORT $L212696
  0002b	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  00031	85 c0		 test	 eax, eax
  00033	74 07		 je	 SHORT $L212696
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	5e		 pop	 esi
  0003b	c3		 ret	 0
$L212696:
  0003c	33 c0		 xor	 eax, eax
  0003e	5e		 pop	 esi
  0003f	c3		 ret	 0
?IsTransformVisPet@CItemElem@@QAEHXZ ENDP		; CItemElem::IsTransformVisPet
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 35   : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Key
; Function compile flags: /Ogty
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Root
; Function compile flags: /Ogty
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z ; std::vector<long,std::allocator<long> >::iterator::operator+
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<long,std::allocator<long> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<long,std::allocator<long> >::iterator::operator+
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00008	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000b	72 0a		 jb	 SHORT $L212804
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1476 : 		}

  00014	c2 04 00	 ret	 4

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$L212804:
  00017	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 1476 : 		}

  0001c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lrotate
; Function compile flags: /Ogty
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  0000e	8b 30		 mov	 esi, DWORD PTR [eax]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L185428

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L185428:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0d		 jne	 SHORT $L185429

; 1023 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00031	5b		 pop	 ebx

; 1031 : 		}

  00032	c2 04 00	 ret	 4
$L185429:

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0c		 jne	 SHORT $L185431

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0003f	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  00041	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00044	5b		 pop	 ebx

; 1031 : 		}

  00045	c2 04 00	 ret	 4
$L185431:

; 1026 : 		else
; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00048	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0004b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0004c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0004e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00051	5b		 pop	 ebx

; 1031 : 		}

  00052	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rrotate
; Function compile flags: /Ogty
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 02		 mov	 eax, DWORD PTR [edx]
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00008	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000b	89 32		 mov	 DWORD PTR [edx], esi

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  0000d	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L185438

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L185438:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0e		 jne	 SHORT $L185439

; 1077 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00032	5b		 pop	 ebx

; 1085 : 		}

  00033	c2 04 00	 ret	 4
$L185439:

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0e		 jne	 SHORT $L185441

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00041	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00042	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00045	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00048	5b		 pop	 ebx

; 1085 : 		}

  00049	c2 04 00	 ret	 4
$L185441:

; 1080 : 		else
; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0004f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00052	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00055	5b		 pop	 ebx

; 1085 : 		}

  00056	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ; std::vector<long,std::allocator<long> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ PROC NEAR ; std::vector<long,std::allocator<long> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ENDP ; std::vector<long,std::allocator<long> >::max_size
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z ; std::vector<long,std::allocator<long> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z ENDP ; std::vector<long,std::allocator<long> >::_Destroy
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@J@std@@QAEPAJI@Z		; std::allocator<long>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@J@std@@QAEPAJI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@J@std@@QAEPAJI@Z PROC NEAR	; std::allocator<long>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@J@std@@QAEPAJI@Z ENDP		; std::allocator<long>::allocate
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ; std::vector<long,std::allocator<long> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ENDP ; std::vector<long,std::allocator<long> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ; std::vector<long,std::allocator<long> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<long,std::allocator<long> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 160  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 161  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<long,std::allocator<long> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1116 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	74 06		 je	 SHORT $L185883

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  00009	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 263  : 				}
; 264  : 			}

  0000e	c3		 ret	 0
$L185883:

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	53		 push	 ebx
  00012	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00015	84 db		 test	 bl, bl
  00017	75 1a		 jne	 SHORT $L213064

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00019	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001c	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0001f	84 db		 test	 bl, bl
  00021	75 0c		 jne	 SHORT $L213049
$L213048:
  00023	8b d0		 mov	 edx, eax
  00025	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00028	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0002b	84 db		 test	 bl, bl
  0002d	74 f4		 je	 SHORT $L213048
$L213049:
  0002f	89 11		 mov	 DWORD PTR [ecx], edx
  00031	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00032	c3		 ret	 0
$L213064:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00039	84 d2		 test	 dl, dl
  0003b	75 1e		 jne	 SHORT $L213067
  0003d	8d 49 00	 npad	 3
$L185889:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 10		 cmp	 edx, DWORD PTR [eax]
  00044	75 0c		 jne	 SHORT $L185890

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 01		 mov	 DWORD PTR [ecx], eax
  00048	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004b	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004e	84 d2		 test	 dl, dl
  00050	74 ee		 je	 SHORT $L185889
$L185890:

; 261  : 				if (!_Isnil(_Pnode))

  00052	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00055	84 d2		 test	 dl, dl
  00057	75 02		 jne	 SHORT $L213067

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  00059	89 01		 mov	 DWORD PTR [ecx], eax
$L213067:
  0005b	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0005c	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 138  : 		}

  0000d	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ; std::vector<long,std::allocator<long> >::_Ucopy<long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Ucopy<long *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ENDP ; std::vector<long,std::allocator<long> >::_Ucopy<long *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z ; std::_Uninitialized_fill_n<long *,unsigned int,long,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<long *,unsigned int,long,std::allocator<long> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L213116
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L213114:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L213114
  0001b	5e		 pop	 esi
$L213116:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z ENDP ; std::_Uninitialized_fill_n<long *,unsigned int,long,std::allocator<long> >
_TEXT	ENDS
PUBLIC	??_C@_0N@JGBJEPOF@nPiercedSize?$AA@		; `string'
PUBLIC	??_C@_0L@IJJPBAHM@dwItemId?$CFd?$AA@		; `string'
PUBLIC	??_C@_0O@DNIGFLMJ@nPiercedSize2?$AA@		; `string'
PUBLIC	?GetPiercingInfoFromMail@CDbManager@@QAEXPAVCQuery@@PAVCItemElem@@@Z ; CDbManager::GetPiercingInfoFromMail
;	COMDAT ??_C@_0N@JGBJEPOF@nPiercedSize?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_C@_0N@JGBJEPOF@nPiercedSize?$AA@ DB 'nPiercedSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IJJPBAHM@dwItemId?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@IJJPBAHM@dwItemId?$CFd?$AA@ DB 'dwItemId%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNIGFLMJ@nPiercedSize2?$AA@
CONST	SEGMENT
??_C@_0O@DNIGFLMJ@nPiercedSize2?$AA@ DB 'nPiercedSize2', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetPiercingInfoFromMail@CDbManager@@QAEXPAVCQuery@@PAVCItemElem@@@Z
_TEXT	SEGMENT
_szItem$209122 = -36					; size = 32
_szItem$209114 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pQuery$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
?GetPiercingInfoFromMail@CDbManager@@QAEXPAVCQuery@@PAVCItemElem@@@Z PROC NEAR ; CDbManager::GetPiercingInfoFromMail, COMDAT
; _this$ = ecx

; 918  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 919  : 	int nAddCount = 1;
; 920  : 	if( pItemElem->GetProp() && pItemElem->GetProp()->IsUltimate() )

  00008	8b 0d 50 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+80
  0000e	33 c4		 xor	 eax, esp
  00010	53		 push	 ebx
  00011	55		 push	 ebp
  00012	8b 6c 24 30	 mov	 ebp, DWORD PTR _pQuery$[esp+40]
  00016	56		 push	 esi
  00017	8b 74 24 38	 mov	 esi, DWORD PTR _pItemElem$[esp+44]
  0001b	89 44 24 2c	 mov	 DWORD PTR __$ArrayPad$[esp+48], eax
  0001f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00022	3b c1		 cmp	 eax, ecx
  00024	57		 push	 edi
  00025	bb 01 00 00 00	 mov	 ebx, 1
  0002a	0f 83 b3 00 00
	00		 jae	 $L213207
  00030	8b 15 40 00 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+64
  00036	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0003a	0f 84 a3 00 00
	00		 je	 $L213207
  00040	3b c1		 cmp	 eax, ecx
  00042	72 04		 jb	 SHORT $L213163
  00044	33 c0		 xor	 eax, eax
  00046	eb 03		 jmp	 SHORT $L213162
$L213163:
  00048	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
$L213162:
  0004b	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0004e	83 f9 02	 cmp	 ecx, 2
  00051	74 09		 je	 SHORT $L213170
  00053	83 f9 03	 cmp	 ecx, 3
  00056	0f 85 87 00 00
	00		 jne	 $L213207
$L213170:
  0005c	83 b8 00 02 00
	00 02		 cmp	 DWORD PTR [eax+512], 2
  00063	75 7e		 jne	 SHORT $L213207

; 921  : 	{
; 922  : 		pItemElem->SetUltimatePiercingSize( pQuery->GetInt( "nPiercedSize" ) );

  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JGBJEPOF@nPiercedSize?$AA@
  0006a	8b cd		 mov	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00071	83 c6 34	 add	 esi, 52			; 00000034H
  00074	50		 push	 eax
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?SetUltimatePiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetUltimatePiercingSize

; 923  : 		for( int i=0; i<pItemElem->GetUltimatePiercingSize(); i++ )

  0007c	8b ce		 mov	 ecx, esi
  0007e	33 ff		 xor	 edi, edi
  00080	e8 00 00 00 00	 call	 ?GetUltimatePiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetUltimatePiercingSize
  00085	85 c0		 test	 eax, eax
  00087	7e 3f		 jle	 SHORT $L209113
  00089	8d a4 24 00 00
	00 00		 npad	 7
$L209111:

; 924  : 		{
; 925  : 			char szItem[32];
; 926  : 			sprintf( szItem, "dwItemId%d", i + nAddCount );

  00090	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00093	53		 push	 ebx
  00094	8d 44 24 14	 lea	 eax, DWORD PTR _szItem$209114[esp+56]
  00098	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@IJJPBAHM@dwItemId?$CFd?$AA@
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _sprintf
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 927  : 			pItemElem->SetUltimatePiercingItem( i, pQuery->GetInt( szItem ) );

  000a6	8d 4c 24 10	 lea	 ecx, DWORD PTR _szItem$209114[esp+52]
  000aa	51		 push	 ecx
  000ab	8b cd		 mov	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  000b2	50		 push	 eax
  000b3	57		 push	 edi
  000b4	8b ce		 mov	 ecx, esi
  000b6	e8 00 00 00 00	 call	 ?SetUltimatePiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetUltimatePiercingItem
  000bb	8b ce		 mov	 ecx, esi
  000bd	8b fb		 mov	 edi, ebx
  000bf	e8 00 00 00 00	 call	 ?GetUltimatePiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetUltimatePiercingSize
  000c4	3b f8		 cmp	 edi, eax
  000c6	7c c8		 jl	 SHORT $L209111
$L209113:

; 928  : 		}
; 929  : 		pItemElem->SetPiercingSize( pQuery->GetInt( "nPiercedSize2" ) );

  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@DNIGFLMJ@nPiercedSize2?$AA@
  000cd	8b cd		 mov	 ecx, ebp
  000cf	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  000d4	50		 push	 eax
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?SetPiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetPiercingSize

; 930  : 		nAddCount = 6;

  000dc	bb 06 00 00 00	 mov	 ebx, 6

; 931  : 	}
; 932  : 	else

  000e1	eb 17		 jmp	 SHORT $L213191
$L213207:

; 933  : 		pItemElem->SetPiercingSize( pQuery->GetInt( "nPiercedSize" ) );

  000e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JGBJEPOF@nPiercedSize?$AA@
  000e8	8b cd		 mov	 ecx, ebp
  000ea	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  000ef	83 c6 34	 add	 esi, 52			; 00000034H
  000f2	50		 push	 eax
  000f3	8b ce		 mov	 ecx, esi
  000f5	e8 00 00 00 00	 call	 ?SetPiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetPiercingSize
$L213191:

; 934  : 
; 935  : 	for( int i=0; i<pItemElem->GetPiercingSize(); i++ )

  000fa	8b ce		 mov	 ecx, esi
  000fc	33 ff		 xor	 edi, edi
  000fe	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00103	85 c0		 test	 eax, eax
  00105	7e 37		 jle	 SHORT $L209121
$L209119:

; 936  : 	{
; 937  : 		char szItem[32];
; 938  : 		sprintf( szItem, "dwItemId%d", i + nAddCount );

  00107	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  0010a	52		 push	 edx
  0010b	8d 44 24 14	 lea	 eax, DWORD PTR _szItem$209122[esp+56]
  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@IJJPBAHM@dwItemId?$CFd?$AA@
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 _sprintf
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 939  : 		pItemElem->SetPiercingItem( i, pQuery->GetInt( szItem ) );

  0011d	8d 4c 24 10	 lea	 ecx, DWORD PTR _szItem$209122[esp+52]
  00121	51		 push	 ecx
  00122	8b cd		 mov	 ecx, ebp
  00124	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00129	50		 push	 eax
  0012a	57		 push	 edi
  0012b	8b ce		 mov	 ecx, esi
  0012d	e8 00 00 00 00	 call	 ?SetPiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetPiercingItem
  00132	8b ce		 mov	 ecx, esi
  00134	47		 inc	 edi
  00135	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  0013a	3b f8		 cmp	 edi, eax
  0013c	7c c9		 jl	 SHORT $L209119
$L209121:

; 940  : 	}
; 941  : }

  0013e	8b 4c 24 30	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+52]
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5d		 pop	 ebp
  00145	5b		 pop	 ebx
  00146	33 cc		 xor	 ecx, esp
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	83 c4 24	 add	 esp, 36			; 00000024H
  00150	c2 08 00	 ret	 8
?GetPiercingInfoFromMail@CDbManager@@QAEXPAVCQuery@@PAVCItemElem@@@Z ENDP ; CDbManager::GetPiercingInfoFromMail
_TEXT	ENDS
PUBLIC	?GetQuest@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetQuest
PUBLIC	??_C@_0BC@KGPDILGI@m_lpQuestCntArray?$AA@	; `string'
PUBLIC	??_C@_0BB@HNPOCMEF@m_aCompleteQuest?$AA@	; `string'
PUBLIC	??_C@_0BA@DPOFAGJ@m_aCheckedQuest?$AA@		; `string'
;	COMDAT ??_C@_0BC@KGPDILGI@m_lpQuestCntArray?$AA@
CONST	SEGMENT
??_C@_0BC@KGPDILGI@m_lpQuestCntArray?$AA@ DB 'm_lpQuestCntArray', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNPOCMEF@m_aCompleteQuest?$AA@
CONST	SEGMENT
??_C@_0BB@HNPOCMEF@m_aCompleteQuest?$AA@ DB 'm_aCompleteQuest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPOFAGJ@m_aCheckedQuest?$AA@
CONST	SEGMENT
??_C@_0BA@DPOFAGJ@m_aCheckedQuest?$AA@ DB 'm_aCheckedQuest', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetQuest@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
tv754 = -4244						; size = 4
_IndexQuest$ = -4244					; size = 4
_i$209413 = -4240					; size = 4
_CountStr$ = -4240					; size = 4
tv454 = -4236						; size = 4
tv434 = -4236						; size = 4
tv305 = -4236						; size = 4
$T213214 = -4236					; size = 4
tv744 = -4232						; size = 4
$T213215 = -4232					; size = 4
$T213212 = -4228					; size = 4
_nQuestSize$ = -4224					; size = 4
_BufQuest$209397 = -4220				; size = 12
_CheckedQuest$ = -4208					; size = 100
_CompleteQuest$ = -4104					; size = 1024
_QuestCnt$ = -3080					; size = 3072
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetQuest@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetQuest, COMDAT
; _this$ = ecx

; 1241 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 94 10 00 00	 mov	 eax, 4244		; 00001094H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	8b 55 0c	 mov	 edx, DWORD PTR _qry$[ebp]
  00018	33 c5		 xor	 eax, ebp
  0001a	53		 push	 ebx
  0001b	89 84 24 94 10
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4248], eax

; 1242 : 	int CountStr	= 0;
; 1243 : 	int IndexQuest	= 0;
; 1244 : 	char QuestCnt[3072]		= {0,};
; 1245 : 	qry->GetStr( "m_lpQuestCntArray", QuestCnt );
; 1246 : 	VERIFYSTRING_RETURN( QuestCnt, pMover->m_szName );
; 1247 : 	while( '$' != QuestCnt[CountStr] )

  00022	8b 45 10	 mov	 eax, DWORD PTR _lpDbOverlappedPlus$[ebp]
  00025	56		 push	 esi
  00026	8b 75 08	 mov	 esi, DWORD PTR _pMover$[ebp]
  00029	57		 push	 edi
  0002a	89 4c 24 1c	 mov	 DWORD PTR $T213212[esp+4256], ecx
  0002e	89 44 24 18	 mov	 DWORD PTR $T213215[esp+4256], eax
  00032	33 db		 xor	 ebx, ebx
  00034	88 9c 24 98 04
	00 00		 mov	 BYTE PTR _QuestCnt$[esp+4256], bl
  0003b	33 c0		 xor	 eax, eax
  0003d	b9 ff 02 00 00	 mov	 ecx, 767		; 000002ffH
  00042	8d bc 24 99 04
	00 00		 lea	 edi, DWORD PTR _QuestCnt$[esp+4257]
  00049	f3 ab		 rep stosd
  0004b	8d 8c 24 98 04
	00 00		 lea	 ecx, DWORD PTR _QuestCnt$[esp+4256]
  00052	66 ab		 stosw
  00054	51		 push	 ecx
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@KGPDILGI@m_lpQuestCntArray?$AA@
  0005a	8b ca		 mov	 ecx, edx

; 1336 : 		}
; 1337 : 	}
; 1338 : 	pMover->m_nQuestSize = nQuestSize;

  0005c	89 54 24 1c	 mov	 DWORD PTR $T213214[esp+4264], edx
  00060	89 5c 24 18	 mov	 DWORD PTR _CountStr$[esp+4264], ebx
  00064	aa		 stosb
  00065	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0006a	8b 54 24 18	 mov	 edx, DWORD PTR $T213215[esp+4256]
  0006e	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T213212[esp+4256]
  00072	52		 push	 edx
  00073	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  00076	50		 push	 eax
  00077	68 de 04 00 00	 push	 1246			; 000004deH
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00081	8d 84 24 a8 04
	00 00		 lea	 eax, DWORD PTR _QuestCnt$[esp+4272]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  0008e	85 c0		 test	 eax, eax
  00090	0f 84 6e 01 00
	00		 je	 $L213257
  00096	80 bc 24 98 04
	00 00 24	 cmp	 BYTE PTR _QuestCnt$[esp+4256], 36 ; 00000024H
  0009e	74 4d		 je	 SHORT $L209396

; 1242 : 	int CountStr	= 0;
; 1243 : 	int IndexQuest	= 0;
; 1244 : 	char QuestCnt[3072]		= {0,};
; 1245 : 	qry->GetStr( "m_lpQuestCntArray", QuestCnt );
; 1246 : 	VERIFYSTRING_RETURN( QuestCnt, pMover->m_szName );
; 1247 : 	while( '$' != QuestCnt[CountStr] )

  000a0	33 ff		 xor	 edi, edi
$L209395:

; 1248 : 	{
; 1249 : 		QUEST BufQuest;
; 1250 : 		GetOneQuest( &BufQuest, QuestCnt, &CountStr );

  000a2	8d 4c 24 10	 lea	 ecx, DWORD PTR _CountStr$[esp+4256]
  000a6	51		 push	 ecx
  000a7	8b 4c 24 20	 mov	 ecx, DWORD PTR $T213212[esp+4260]
  000ab	8d 94 24 9c 04
	00 00		 lea	 edx, DWORD PTR _QuestCnt$[esp+4260]
  000b2	52		 push	 edx
  000b3	8d 44 24 2c	 lea	 eax, DWORD PTR _BufQuest$209397[esp+4264]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?GetOneQuest@CDbManager@@QAEXPAUtagQuest@@PADPAH@Z ; CDbManager::GetOneQuest

; 1251 : 		pMover->m_aQuest[IndexQuest] = BufQuest;

  000bd	8b 8e a0 46 00
	00		 mov	 ecx, DWORD PTR [esi+18080]
  000c3	8b 54 24 24	 mov	 edx, DWORD PTR _BufQuest$209397[esp+4256]
  000c7	8b 44 24 28	 mov	 eax, DWORD PTR _BufQuest$209397[esp+4260]
  000cb	03 cf		 add	 ecx, edi
  000cd	89 11		 mov	 DWORD PTR [ecx], edx
  000cf	8b 54 24 2c	 mov	 edx, DWORD PTR _BufQuest$209397[esp+4264]
  000d3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000d6	8b 44 24 10	 mov	 eax, DWORD PTR _CountStr$[esp+4256]
  000da	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000dd	8a 8c 04 98 04
	00 00		 mov	 cl, BYTE PTR _QuestCnt$[esp+eax+4256]

; 1252 : 		IndexQuest++;

  000e4	43		 inc	 ebx
  000e5	83 c7 0c	 add	 edi, 12			; 0000000cH
  000e8	80 f9 24	 cmp	 cl, 36			; 00000024H
  000eb	75 b5		 jne	 SHORT $L209395
$L209396:

; 1253 : 	}
; 1254 : 	pMover->m_nQuestSize = IndexQuest;
; 1255 : 
; 1256 : 	int nQuestSize = IndexQuest;
; 1257 : 	CountStr	= 0;

  000ed	33 c0		 xor	 eax, eax

; 1258 : 	IndexQuest	= 0;
; 1259 : 	char CompleteQuest[1024]		= {0,};

  000ef	88 84 24 98 00
	00 00		 mov	 BYTE PTR _CompleteQuest$[esp+4256], al
  000f6	89 44 24 10	 mov	 DWORD PTR _CountStr$[esp+4256], eax
  000fa	89 44 24 0c	 mov	 DWORD PTR _IndexQuest$[esp+4256], eax
  000fe	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00103	8d bc 24 99 00
	00 00		 lea	 edi, DWORD PTR _CompleteQuest$[esp+4257]
  0010a	f3 ab		 rep stosd

; 1260 : 	qry->GetStr( "m_aCompleteQuest", CompleteQuest );

  0010c	8d 8c 24 98 00
	00 00		 lea	 ecx, DWORD PTR _CompleteQuest$[esp+4256]
  00113	66 ab		 stosw
  00115	51		 push	 ecx
  00116	8b 4c 24 18	 mov	 ecx, DWORD PTR $T213214[esp+4260]
  0011a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HNPOCMEF@m_aCompleteQuest?$AA@
  0011f	88 9e a8 46 00
	00		 mov	 BYTE PTR [esi+18088], bl
  00125	89 5c 24 28	 mov	 DWORD PTR _nQuestSize$[esp+4264], ebx
  00129	aa		 stosb
  0012a	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1261 : 	VERIFYSTRING_RETURN( CompleteQuest, pMover->m_szName );

  0012f	8b 54 24 18	 mov	 edx, DWORD PTR $T213215[esp+4256]
  00133	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T213212[esp+4256]
  00137	52		 push	 edx
  00138	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  0013b	50		 push	 eax
  0013c	68 ed 04 00 00	 push	 1261			; 000004edH
  00141	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00146	8d 84 24 a8 00
	00 00		 lea	 eax, DWORD PTR _CompleteQuest$[esp+4272]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00153	85 c0		 test	 eax, eax
  00155	0f 84 a9 00 00
	00		 je	 $L213257

; 1262 : 	while( '$' != CompleteQuest[CountStr] )

  0015b	80 bc 24 98 00
	00 00 24	 cmp	 BYTE PTR _CompleteQuest$[esp+4256], 36 ; 00000024H
  00163	74 41		 je	 SHORT $L209404
  00165	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$L209403:

; 1263 : 	{
; 1264 : 		pMover->m_aCompleteQuest[IndexQuest] = (WORD)GetIntFromStr( CompleteQuest, &CountStr ); 

  00170	8d 4c 24 10	 lea	 ecx, DWORD PTR _CountStr$[esp+4256]
  00174	51		 push	 ecx
  00175	8d 94 24 9c 00
	00 00		 lea	 edx, DWORD PTR _CompleteQuest$[esp+4260]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00182	8b 4c 24 14	 mov	 ecx, DWORD PTR _IndexQuest$[esp+4264]
  00186	8b 96 a4 46 00
	00		 mov	 edx, DWORD PTR [esi+18084]
  0018c	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00190	8b 44 24 18	 mov	 eax, DWORD PTR _CountStr$[esp+4264]
  00194	83 c4 08	 add	 esp, 8

; 1265 : 		IndexQuest++;

  00197	41		 inc	 ecx
  00198	89 4c 24 0c	 mov	 DWORD PTR _IndexQuest$[esp+4256], ecx
  0019c	80 bc 04 98 00
	00 00 24	 cmp	 BYTE PTR _CompleteQuest$[esp+eax+4256], 36 ; 00000024H
  001a4	75 ca		 jne	 SHORT $L209403
$L209404:

; 1266 : 	}
; 1267 : 	pMover->m_nCompleteQuestSize = IndexQuest;

  001a6	8a 4c 24 0c	 mov	 cl, BYTE PTR _IndexQuest$[esp+4256]

; 1268 : 
; 1269 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 1270 : 	CountStr = 0;

  001aa	33 c0		 xor	 eax, eax
  001ac	88 8e a9 46 00
	00		 mov	 BYTE PTR [esi+18089], cl

; 1271 : 	IndexQuest = 0;
; 1272 : 	char CheckedQuest[100] = {0, };

  001b2	88 44 24 30	 mov	 BYTE PTR _CheckedQuest$[esp+4256], al
  001b6	89 44 24 10	 mov	 DWORD PTR _CountStr$[esp+4256], eax
  001ba	89 44 24 0c	 mov	 DWORD PTR _IndexQuest$[esp+4256], eax
  001be	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  001c3	8d 7c 24 31	 lea	 edi, DWORD PTR _CheckedQuest$[esp+4257]
  001c7	f3 ab		 rep stosd

; 1273 : 	qry->GetStr( "m_aCheckedQuest", CheckedQuest );

  001c9	8b 4c 24 14	 mov	 ecx, DWORD PTR $T213214[esp+4256]
  001cd	8d 54 24 30	 lea	 edx, DWORD PTR _CheckedQuest$[esp+4256]
  001d1	66 ab		 stosw
  001d3	52		 push	 edx
  001d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@DPOFAGJ@m_aCheckedQuest?$AA@
  001d9	aa		 stosb
  001da	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1274 : 	VERIFYSTRING_RETURN( CheckedQuest, pMover->m_szName );

  001df	8b 44 24 18	 mov	 eax, DWORD PTR $T213215[esp+4256]
  001e3	50		 push	 eax
  001e4	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  001e7	50		 push	 eax
  001e8	68 fa 04 00 00	 push	 1274			; 000004faH
  001ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  001f2	8d 4c 24 40	 lea	 ecx, DWORD PTR _CheckedQuest$[esp+4272]
  001f6	51		 push	 ecx
  001f7	8b 4c 24 30	 mov	 ecx, DWORD PTR $T213212[esp+4276]
  001fb	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00200	85 c0		 test	 eax, eax
  00202	75 19		 jne	 SHORT $L213218
$L213257:
  00204	33 c0		 xor	 eax, eax

; 1339 : 	return TRUE;
; 1340 : }

  00206	5f		 pop	 edi
  00207	5e		 pop	 esi
  00208	5b		 pop	 ebx
  00209	8b 8c 24 90 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4244]
  00210	33 cd		 xor	 ecx, ebp
  00212	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c2 0c 00	 ret	 12			; 0000000cH
$L213218:

; 1275 : 	while( '$' != CheckedQuest[CountStr] )

  0021d	80 7c 24 30 24	 cmp	 BYTE PTR _CheckedQuest$[esp+4256], 36 ; 00000024H
  00222	74 30		 je	 SHORT $L209411
$L209410:

; 1276 : 	{
; 1277 : 		pMover->m_aCheckedQuest[IndexQuest] = (WORD)GetIntFromStr( CheckedQuest, &CountStr ); 

  00224	8d 54 24 10	 lea	 edx, DWORD PTR _CountStr$[esp+4256]
  00228	52		 push	 edx
  00229	8d 44 24 34	 lea	 eax, DWORD PTR _CheckedQuest$[esp+4260]
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00233	8b 4c 24 14	 mov	 ecx, DWORD PTR _IndexQuest$[esp+4264]
  00237	8b 96 bc 46 00
	00		 mov	 edx, DWORD PTR [esi+18108]
  0023d	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00241	8b 44 24 18	 mov	 eax, DWORD PTR _CountStr$[esp+4264]
  00245	83 c4 08	 add	 esp, 8

; 1278 : 		IndexQuest++;

  00248	41		 inc	 ecx
  00249	89 4c 24 0c	 mov	 DWORD PTR _IndexQuest$[esp+4256], ecx
  0024d	80 7c 04 30 24	 cmp	 BYTE PTR _CheckedQuest$[esp+eax+4256], 36 ; 00000024H
  00252	75 d0		 jne	 SHORT $L209410
$L209411:

; 1279 : 	}
; 1280 : 	pMover->m_nCheckedQuestSize = IndexQuest;

  00254	8a 4c 24 0c	 mov	 cl, BYTE PTR _IndexQuest$[esp+4256]

; 1281 : #endif // __IMPROVE_QUEST_INTERFACE
; 1282 : 
; 1283 : 	//      .
; 1284 : 	for( int i = 0; i < nQuestSize; i++ )

  00258	33 d2		 xor	 edx, edx
  0025a	3b da		 cmp	 ebx, edx
  0025c	88 8e c0 46 00
	00		 mov	 BYTE PTR [esi+18112], cl
  00262	89 54 24 10	 mov	 DWORD PTR _i$209413[esp+4256], edx
  00266	0f 8e f3 01 00
	00		 jle	 $L209416

; 1279 : 	}
; 1280 : 	pMover->m_nCheckedQuestSize = IndexQuest;

  0026c	89 54 24 0c	 mov	 DWORD PTR tv754[esp+4256], edx
$L209414:

; 1285 : 	{
; 1286 : 		if( pMover->m_aQuest[ i ].m_nState == QS_END )

  00270	8b 86 a0 46 00
	00		 mov	 eax, DWORD PTR [esi+18080]
  00276	03 d0		 add	 edx, eax
  00278	80 3a 0e	 cmp	 BYTE PTR [edx], 14	; 0000000eH
  0027b	0f 85 2b 01 00
	00		 jne	 $L213246

; 1287 : 		{
; 1288 : 			for( int j = 0; j < pMover->m_nCompleteQuestSize; j++ )

  00281	0f b6 8e a9 46
	00 00		 movzx	 ecx, BYTE PTR [esi+18089]
  00288	33 c0		 xor	 eax, eax
  0028a	85 c9		 test	 ecx, ecx
  0028c	89 4c 24 14	 mov	 DWORD PTR tv434[esp+4256], ecx
  00290	7e 2a		 jle	 SHORT $L213227
  00292	8b 8e a4 46 00
	00		 mov	 ecx, DWORD PTR [esi+18084]
  00298	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L209419:

; 1289 : 			{
; 1290 : 				if( pMover->m_aCompleteQuest[ j ] == pMover->m_aQuest[ i ].m_wId )

  002a0	66 8b 7a 04	 mov	 di, WORD PTR [edx+4]
  002a4	66 39 39	 cmp	 WORD PTR [ecx], di
  002a7	74 0f		 je	 SHORT $L213251
  002a9	0f b6 be a9 46
	00 00		 movzx	 edi, BYTE PTR [esi+18089]
  002b0	40		 inc	 eax
  002b1	83 c1 02	 add	 ecx, 2
  002b4	3b c7		 cmp	 eax, edi
  002b6	7c e8		 jl	 SHORT $L209419
$L213251:

; 1287 : 		{
; 1288 : 			for( int j = 0; j < pMover->m_nCompleteQuestSize; j++ )

  002b8	8b 4c 24 14	 mov	 ecx, DWORD PTR tv434[esp+4256]
$L213227:

; 1291 : 					break;
; 1292 : 			}
; 1293 : 			if( j == pMover->m_nCompleteQuestSize )

  002bc	3b c1		 cmp	 eax, ecx
  002be	75 14		 jne	 SHORT $L209423

; 1294 : 			{
; 1295 : 				pMover->m_aCompleteQuest[ pMover->m_nCompleteQuestSize ] = pMover->m_aQuest[ i ].m_wId;

  002c0	8b 86 a4 46 00
	00		 mov	 eax, DWORD PTR [esi+18084]
  002c6	66 8b 52 04	 mov	 dx, WORD PTR [edx+4]
  002ca	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1296 : 				pMover->m_nCompleteQuestSize++;

  002ce	fe 86 a9 46 00
	00		 inc	 BYTE PTR [esi+18089]
$L209423:

; 1297 : 			}
; 1298 : 			for( j = i; j < nQuestSize - 1; j++ )

  002d4	8b 44 24 10	 mov	 eax, DWORD PTR _i$209413[esp+4256]
  002d8	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  002db	3b c2		 cmp	 eax, edx
  002dd	89 54 24 14	 mov	 DWORD PTR tv454[esp+4256], edx
  002e1	7d 2e		 jge	 SHORT $L209426
  002e3	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv754[esp+4256]
  002e7	2b d0		 sub	 edx, eax
  002e9	8d a4 24 00 00
	00 00		 npad	 7
$L209424:

; 1299 : 			{
; 1300 : 				pMover->m_aQuest[ j ] = pMover->m_aQuest[ j + 1 ];

  002f0	8b 86 a0 46 00
	00		 mov	 eax, DWORD PTR [esi+18080]
  002f6	03 c1		 add	 eax, ecx
  002f8	8d 78 0c	 lea	 edi, DWORD PTR [eax+12]
  002fb	8b 1f		 mov	 ebx, DWORD PTR [edi]
  002fd	89 18		 mov	 DWORD PTR [eax], ebx
  002ff	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00302	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00305	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  00308	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0030b	4a		 dec	 edx
  0030c	89 78 08	 mov	 DWORD PTR [eax+8], edi
  0030f	75 df		 jne	 SHORT $L209424
$L209426:

; 1301 : 			}
; 1302 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 1303 : 			for( int k = 0; k < pMover->m_nCheckedQuestSize; ++k )

  00311	0f b6 be c0 46
	00 00		 movzx	 edi, BYTE PTR [esi+18112]
  00318	33 c0		 xor	 eax, eax
  0031a	85 ff		 test	 edi, edi
  0031c	7e 6d		 jle	 SHORT $L209430
  0031e	8b 8e a0 46 00
	00		 mov	 ecx, DWORD PTR [esi+18080]
  00324	8b 54 24 0c	 mov	 edx, DWORD PTR tv754[esp+4256]
  00328	66 8b 54 0a 04	 mov	 dx, WORD PTR [edx+ecx+4]
  0032d	8b 8e bc 46 00
	00		 mov	 ecx, DWORD PTR [esi+18108]
$L209428:

; 1304 : 			{
; 1305 : 				if( pMover->m_aCheckedQuest[ k ] == pMover->m_aQuest[ i ].m_wId )

  00333	66 39 11	 cmp	 WORD PTR [ecx], dx
  00336	74 11		 je	 SHORT $L213228
  00338	0f b6 9e c0 46
	00 00		 movzx	 ebx, BYTE PTR [esi+18112]
  0033f	40		 inc	 eax
  00340	83 c1 02	 add	 ecx, 2
  00343	3b c3		 cmp	 eax, ebx
  00345	7c ec		 jl	 SHORT $L209428

; 1318 : 		{
; 1319 : 			int j = 0;
; 1320 : 			do
; 1321 : 			{
; 1322 : 				for( j = i + 1; j < nQuestSize; j++ )
; 1323 : 				{
; 1324 : 					if( pMover->m_aQuest[ j ].m_wId == pMover->m_aQuest[ i ].m_wId )

  00347	eb 42		 jmp	 SHORT $L209430
$L213228:

; 1306 : 				{
; 1307 : 					for( int l = k; l < pMover->m_nCheckedQuestSize - 1; ++l )

  00349	4f		 dec	 edi
  0034a	3b c7		 cmp	 eax, edi
  0034c	8b d0		 mov	 edx, eax
  0034e	7d 1e		 jge	 SHORT $L209435
$L209433:

; 1308 : 						pMover->m_aCheckedQuest[ k ] = pMover->m_aCheckedQuest[ k + 1 ];

  00350	8b 8e bc 46 00
	00		 mov	 ecx, DWORD PTR [esi+18108]
  00356	66 8b 7c 41 02	 mov	 di, WORD PTR [ecx+eax*2+2]
  0035b	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  0035e	66 89 39	 mov	 WORD PTR [ecx], di
  00361	0f b6 8e c0 46
	00 00		 movzx	 ecx, BYTE PTR [esi+18112]
  00368	42		 inc	 edx
  00369	49		 dec	 ecx
  0036a	3b d1		 cmp	 edx, ecx
  0036c	7c e2		 jl	 SHORT $L209433
$L209435:

; 1309 : 					pMover->m_aCheckedQuest[ --pMover->m_nCheckedQuestSize ] = 0;

  0036e	8a 86 c0 46 00
	00		 mov	 al, BYTE PTR [esi+18112]
  00374	fe c8		 dec	 al
  00376	0f b6 d0	 movzx	 edx, al
  00379	88 86 c0 46 00
	00		 mov	 BYTE PTR [esi+18112], al
  0037f	8b 86 bc 46 00
	00		 mov	 eax, DWORD PTR [esi+18108]
  00385	66 c7 04 50 00
	00		 mov	 WORD PTR [eax+edx*2], 0
$L209430:

; 1310 : 					break;
; 1311 : 				}
; 1312 : 			}
; 1313 : #endif // __IMPROVE_QUEST_INTERFACE
; 1314 : 			nQuestSize--;
; 1315 : 			i--;

  0038b	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$209413[esp+4256]
  0038f	8b 44 24 0c	 mov	 eax, DWORD PTR tv754[esp+4256]
  00393	8b 5c 24 14	 mov	 ebx, DWORD PTR tv454[esp+4256]
  00397	49		 dec	 ecx
  00398	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0039b	89 5c 24 20	 mov	 DWORD PTR _nQuestSize$[esp+4256], ebx
  0039f	89 4c 24 10	 mov	 DWORD PTR _i$209413[esp+4256], ecx
  003a3	89 44 24 0c	 mov	 DWORD PTR tv754[esp+4256], eax

; 1316 : 		}
; 1317 : 		else

  003a7	e9 97 00 00 00	 jmp	 $L209440
$L213246:

; 1328 : 				{
; 1329 : 					for( int k = j; k < nQuestSize - 1; k++ )

  003ac	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  003af	89 4c 24 18	 mov	 DWORD PTR tv744[esp+4256], ecx
$L209438:
  003b3	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$209413[esp+4256]
  003b7	41		 inc	 ecx
  003b8	3b cb		 cmp	 ecx, ebx
  003ba	7d 25		 jge	 SHORT $L213256
  003bc	8b 86 a0 46 00
	00		 mov	 eax, DWORD PTR [esi+18080]
  003c2	8b 54 24 0c	 mov	 edx, DWORD PTR tv754[esp+4256]
  003c6	66 8b 54 02 04	 mov	 dx, WORD PTR [edx+eax+4]
  003cb	8d 3c 49	 lea	 edi, DWORD PTR [ecx+ecx*2]
  003ce	8d 44 b8 04	 lea	 eax, DWORD PTR [eax+edi*4+4]
$L209441:

; 1318 : 		{
; 1319 : 			int j = 0;
; 1320 : 			do
; 1321 : 			{
; 1322 : 				for( j = i + 1; j < nQuestSize; j++ )
; 1323 : 				{
; 1324 : 					if( pMover->m_aQuest[ j ].m_wId == pMover->m_aQuest[ i ].m_wId )

  003d2	66 39 10	 cmp	 WORD PTR [eax], dx
  003d5	74 08		 je	 SHORT $L213229
  003d7	41		 inc	 ecx
  003d8	83 c0 0c	 add	 eax, 12			; 0000000cH
  003db	3b cb		 cmp	 ecx, ebx
  003dd	7c f3		 jl	 SHORT $L209441
$L213229:

; 1325 : 						break;
; 1326 : 				}
; 1327 : 				if( j != nQuestSize )

  003df	3b cb		 cmp	 ecx, ebx
$L213256:
  003e1	74 60		 je	 SHORT $L209440

; 1328 : 				{
; 1329 : 					for( int k = j; k < nQuestSize - 1; k++ )

  003e3	8b 44 24 18	 mov	 eax, DWORD PTR tv744[esp+4256]
  003e7	3b c8		 cmp	 ecx, eax
  003e9	7d 42		 jge	 SHORT $L209449
  003eb	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  003ee	c1 e2 02	 shl	 edx, 2
  003f1	2b c1		 sub	 eax, ecx
  003f3	89 44 24 14	 mov	 DWORD PTR tv305[esp+4256], eax
  003f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L209447:

; 1330 : 					{
; 1331 : 						pMover->m_aQuest[ k ] = pMover->m_aQuest[ k + 1 ];

  00400	8b 86 a0 46 00
	00		 mov	 eax, DWORD PTR [esi+18080]
  00406	03 c2		 add	 eax, edx
  00408	8d 78 0c	 lea	 edi, DWORD PTR [eax+12]
  0040b	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0040d	89 18		 mov	 DWORD PTR [eax], ebx
  0040f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00412	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00415	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  00418	89 78 08	 mov	 DWORD PTR [eax+8], edi
  0041b	8b 44 24 14	 mov	 eax, DWORD PTR tv305[esp+4256]
  0041f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00422	48		 dec	 eax
  00423	89 44 24 14	 mov	 DWORD PTR tv305[esp+4256], eax
  00427	75 d7		 jne	 SHORT $L209447

; 1328 : 				{
; 1329 : 					for( int k = j; k < nQuestSize - 1; k++ )

  00429	8b 5c 24 20	 mov	 ebx, DWORD PTR _nQuestSize$[esp+4256]
$L209449:

; 1332 : 					}
; 1333 : 					nQuestSize--;

  0042d	8b 54 24 18	 mov	 edx, DWORD PTR tv744[esp+4256]
  00431	4b		 dec	 ebx
  00432	4a		 dec	 edx

; 1334 : 				}
; 1335 : 			} while( j != nQuestSize );

  00433	3b cb		 cmp	 ecx, ebx
  00435	89 5c 24 20	 mov	 DWORD PTR _nQuestSize$[esp+4256], ebx
  00439	89 54 24 18	 mov	 DWORD PTR tv744[esp+4256], edx
  0043d	0f 85 70 ff ff
	ff		 jne	 $L209438
$L209440:

; 1281 : #endif // __IMPROVE_QUEST_INTERFACE
; 1282 : 
; 1283 : 	//      .
; 1284 : 	for( int i = 0; i < nQuestSize; i++ )

  00443	8b 44 24 10	 mov	 eax, DWORD PTR _i$209413[esp+4256]
  00447	8b 54 24 0c	 mov	 edx, DWORD PTR tv754[esp+4256]
  0044b	40		 inc	 eax
  0044c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0044f	3b c3		 cmp	 eax, ebx
  00451	89 44 24 10	 mov	 DWORD PTR _i$209413[esp+4256], eax
  00455	89 54 24 0c	 mov	 DWORD PTR tv754[esp+4256], edx
  00459	0f 8c 11 fe ff
	ff		 jl	 $L209414
$L209416:

; 1339 : 	return TRUE;
; 1340 : }

  0045f	8b 8c 24 9c 10
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4256]
  00466	5f		 pop	 edi
  00467	88 9e a8 46 00
	00		 mov	 BYTE PTR [esi+18088], bl
  0046d	5e		 pop	 esi
  0046e	33 cd		 xor	 ecx, ebp
  00470	b8 01 00 00 00	 mov	 eax, 1
  00475	5b		 pop	 ebx
  00476	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047b	8b e5		 mov	 esp, ebp
  0047d	5d		 pop	 ebp
  0047e	c2 0c 00	 ret	 12			; 0000000cH
?GetQuest@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetQuest
_TEXT	ENDS
PUBLIC	?RemoveItemInventory@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ; CDbManager::RemoveItemInventory
PUBLIC	??_C@_0BG@EGBCIKAA@Not?5UnEquip?5?3?5?$CFs?0?5?$CFs?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@OFGDADEH@Not?5Inventory?5?3?5?$CFs?0?5?$CFs?5?$AA@ ; `string'
;	COMDAT ??_C@_0BG@EGBCIKAA@Not?5UnEquip?5?3?5?$CFs?0?5?$CFs?5?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_C@_0BG@EGBCIKAA@Not?5UnEquip?5?3?5?$CFs?0?5?$CFs?5?$AA@ DB 'Not UnEqui'
	DB	'p : %s, %s ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OFGDADEH@Not?5Inventory?5?3?5?$CFs?0?5?$CFs?5?$AA@
CONST	SEGMENT
??_C@_0BI@OFGDADEH@Not?5Inventory?5?3?5?$CFs?0?5?$CFs?5?$AA@ DB 'Not Inve'
	DB	'ntory : %s, %s ', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?RemoveItemInventory@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z
_TEXT	SEGMENT
_pItemProp$ = 8						; size = 4
_iSerialNumber$ = 12					; size = 4
_pMover$ = 12						; size = 4
_nAbilityOption$ = 16					; size = 4
_nItemResist$ = 20					; size = 4
_nResistAbilityOption$ = 24				; size = 4
_nItemCount$ = 28					; size = 4
?RemoveItemInventory@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z PROC NEAR ; CDbManager::RemoveItemInventory, COMDAT
; _this$ = ecx

; 1626 : 	SERIALNUMBER iSerialNumber = 0;
; 1627 : 	CItemElem *pItemElem = pMover->m_Inventory.GetItem( pItemProp, nAbilityOption, nItemResist, nResistAbilityOption );

  00000	8b 44 24 14	 mov	 eax, DWORD PTR _nResistAbilityOption$[esp-4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR _nItemResist$[esp-4]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR _nAbilityOption$[esp-4]
  0000c	53		 push	 ebx
  0000d	8b 5c 24 08	 mov	 ebx, DWORD PTR _pItemProp$[esp]
  00011	55		 push	 ebp
  00012	8b 6c 24 10	 mov	 ebp, DWORD PTR _pMover$[esp+4]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	52		 push	 edx
  0001b	8d bd 14 41 00
	00		 lea	 edi, DWORD PTR [ebp+16660]
  00021	53		 push	 ebx
  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z ; CItemContainer<CItemElem>::GetItem
  00029	8b f0		 mov	 esi, eax

; 1628 : 	
; 1629 : 	if( pItemElem != NULL ) //    .

  0002b	85 f6		 test	 esi, esi
  0002d	0f 84 98 00 00
	00		 je	 $L209634

; 1630 : 	{
; 1631 : 		iSerialNumber = pItemElem->GetSerialNumber();

  00033	8b 46 30	 mov	 eax, DWORD PTR [esi+48]

; 1632 : 		if( pMover->m_Inventory.IsEquip( pItemElem->m_dwObjId ) )	//    

  00036	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00039	89 44 24 18	 mov	 DWORD PTR _iSerialNumber$[esp+12], eax
  0003d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00040	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00043	c1 e1 05	 shl	 ecx, 5
  00046	8b 44 11 2c	 mov	 eax, DWORD PTR [ecx+edx+44]
  0004a	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0004d	72 46		 jb	 SHORT $L209639

; 1633 : 		{
; 1634 : 			if( !pMover->m_Inventory.UnEquip( pItemProp->dwParts ) ) //  

  0004f	8b 8b a8 00 00
	00		 mov	 ecx, DWORD PTR [ebx+168]
  00055	51		 push	 ecx
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?UnEquip@?$CItemContainer@VCItemElem@@@@QAEHK@Z ; CItemContainer<CItemElem>::UnEquip
  0005d	85 c0		 test	 eax, eax
  0005f	75 1e		 jne	 SHORT $L209636

; 1635 : 			{
; 1636 : 				WriteLog( "Not UnEquip : %s, %s ", pMover->m_szName, pItemProp->szName );

  00061	83 c3 04	 add	 ebx, 4
  00064	53		 push	 ebx
  00065	83 c5 6c	 add	 ebp, 108		; 0000006cH
  00068	55		 push	 ebp
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@EGBCIKAA@Not?5UnEquip?5?3?5?$CFs?0?5?$CFs?5?$AA@

; 1649 : 	}
; 1650 : 	else
; 1651 : 	{
; 1652 : 		WriteLog( "Not Inventory : %s, %s ", pMover->m_szName, pItemProp->szName );

  0006e	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5d		 pop	 ebp

; 1653 : 		return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	5b		 pop	 ebx

; 1654 : 	}
; 1655 : 	return 0;
; 1656 : }

  0007c	c2 18 00	 ret	 24			; 00000018H
$L209636:

; 1637 : 				return (SERIALNUMBER)0;
; 1638 : 			}
; 1639 : 			else
; 1640 : 				pMover->m_aEquipInfo[pItemProp->dwParts].dwId	= NULL_ID;

  0007f	8b 83 a8 00 00
	00		 mov	 eax, DWORD PTR [ebx+168]
  00085	05 c3 05 00 00	 add	 eax, 1475		; 000005c3H
  0008a	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0008d	c7 44 95 00 ff
	ff ff ff	 mov	 DWORD PTR [ebp+edx*4], -1
$L209639:

; 1641 : 		}
; 1642 : 
; 1643 : 		if( pItemElem->m_nItemNum <= nItemCount )

  00095	66 8b 46 72	 mov	 ax, WORD PTR [esi+114]
  00099	8b 4c 24 28	 mov	 ecx, DWORD PTR _nItemCount$[esp+12]
  0009d	0f bf d0	 movsx	 edx, ax
  000a0	3b d1		 cmp	 edx, ecx
  000a2	7f 16		 jg	 SHORT $L209640

; 1644 : 			pMover->m_Inventory.RemoveAt( pItemElem->m_dwObjIndex );

  000a4	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a7	50		 push	 eax
  000a8	8b cf		 mov	 ecx, edi
  000aa	e8 00 00 00 00	 call	 ?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAt

; 1647 : 		
; 1648 : 		return iSerialNumber;

  000af	8b 44 24 18	 mov	 eax, DWORD PTR _iSerialNumber$[esp+12]
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5d		 pop	 ebp
  000b6	5b		 pop	 ebx

; 1654 : 	}
; 1655 : 	return 0;
; 1656 : }

  000b7	c2 18 00	 ret	 24			; 00000018H
$L209640:

; 1645 : 		else
; 1646 : 			pItemElem->m_nItemNum -= nItemCount;

  000ba	2b c1		 sub	 eax, ecx
  000bc	5f		 pop	 edi
  000bd	66 89 46 72	 mov	 WORD PTR [esi+114], ax

; 1647 : 		
; 1648 : 		return iSerialNumber;

  000c1	8b 44 24 14	 mov	 eax, DWORD PTR _iSerialNumber$[esp+8]
  000c5	5e		 pop	 esi
  000c6	5d		 pop	 ebp
  000c7	5b		 pop	 ebx

; 1654 : 	}
; 1655 : 	return 0;
; 1656 : }

  000c8	c2 18 00	 ret	 24			; 00000018H
$L209634:

; 1649 : 	}
; 1650 : 	else
; 1651 : 	{
; 1652 : 		WriteLog( "Not Inventory : %s, %s ", pMover->m_szName, pItemProp->szName );

  000cb	83 c3 04	 add	 ebx, 4
  000ce	53		 push	 ebx
  000cf	83 c5 6c	 add	 ebp, 108		; 0000006cH
  000d2	55		 push	 ebp
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@OFGDADEH@Not?5Inventory?5?3?5?$CFs?0?5?$CFs?5?$AA@
  000d8	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5d		 pop	 ebp

; 1653 : 		return 0;

  000e3	33 c0		 xor	 eax, eax
  000e5	5b		 pop	 ebx

; 1654 : 	}
; 1655 : 	return 0;
; 1656 : }

  000e6	c2 18 00	 ret	 24			; 00000018H
?RemoveItemInventory@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ENDP ; CDbManager::RemoveItemInventory
_TEXT	ENDS
PUBLIC	?RemoveItemBank@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ; CDbManager::RemoveItemBank
PUBLIC	??_C@_0BP@MKOBOPPN@item?5not?5found?5?9?5bank?3?5?$CFs?0?5?$CFs?5?$AA@ ; `string'
;	COMDAT ??_C@_0BP@MKOBOPPN@item?5not?5found?5?9?5bank?3?5?$CFs?0?5?$CFs?5?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_C@_0BP@MKOBOPPN@item?5not?5found?5?9?5bank?3?5?$CFs?0?5?$CFs?5?$AA@ DB 'i'
	DB	'tem not found - bank: %s, %s ', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?RemoveItemBank@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z
_TEXT	SEGMENT
_pItemProp$ = 8						; size = 4
_pMover$ = 12						; size = 4
_nAbilityOption$ = 16					; size = 4
_nItemResist$ = 20					; size = 4
_nResistAbilityOption$ = 24				; size = 4
_nItemCount$ = 28					; size = 4
?RemoveItemBank@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z PROC NEAR ; CDbManager::RemoveItemBank, COMDAT
; _this$ = ecx

; 1660 : 	SERIALNUMBER iSerialNumber = 0;
; 1661 : 	CItemElem *pItemElem	= pMover->m_Bank[pMover->m_nSlot].GetItem( pItemProp, nAbilityOption, nItemResist, nResistAbilityOption );

  00000	8b 4c 24 14	 mov	 ecx, DWORD PTR _nResistAbilityOption$[esp-4]
  00004	8b 54 24 10	 mov	 edx, DWORD PTR _nItemResist$[esp-4]
  00008	53		 push	 ebx
  00009	8b 5c 24 08	 mov	 ebx, DWORD PTR _pItemProp$[esp]
  0000d	56		 push	 esi
  0000e	8b 74 24 10	 mov	 esi, DWORD PTR _pMover$[esp+4]
  00012	0f b6 86 c8 00
	00 00		 movzx	 eax, BYTE PTR [esi+200]
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0001e	8d bc 86 94 41
	00 00		 lea	 edi, DWORD PTR [esi+eax*4+16788]
  00025	8b 44 24 1c	 mov	 eax, DWORD PTR _nAbilityOption$[esp+12]
  00029	52		 push	 edx
  0002a	50		 push	 eax
  0002b	53		 push	 ebx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z ; CItemContainer<CItemElem>::GetItem

; 1662 : 
; 1663 : 	if( pItemElem != NULL )

  00033	85 c0		 test	 eax, eax
  00035	74 33		 je	 SHORT $L209655

; 1664 : 	{
; 1665 : 		iSerialNumber	= pItemElem->GetSerialNumber();
; 1666 : 
; 1667 : 		if( pItemElem->m_nItemNum <= nItemCount )

  00037	66 8b 48 72	 mov	 cx, WORD PTR [eax+114]
  0003b	8b 54 24 24	 mov	 edx, DWORD PTR _nItemCount$[esp+8]
  0003f	8b 70 30	 mov	 esi, DWORD PTR [eax+48]
  00042	0f bf d9	 movsx	 ebx, cx
  00045	3b da		 cmp	 ebx, edx
  00047	7f 13		 jg	 SHORT $L209656

; 1668 : 			pMover->m_Bank[pMover->m_nSlot].RemoveAt( pItemElem->m_dwObjIndex );

  00049	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0004c	51		 push	 ecx
  0004d	8b cf		 mov	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAt
  00054	5f		 pop	 edi

; 1671 : 
; 1672 : 		return iSerialNumber;

  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx

; 1678 : 	}
; 1679 : 	return 0;
; 1680 : }

  00059	c2 18 00	 ret	 24			; 00000018H
$L209656:

; 1669 : 		else
; 1670 : 			pItemElem->m_nItemNum -= nItemCount;

  0005c	2b ca		 sub	 ecx, edx
  0005e	5f		 pop	 edi
  0005f	66 89 48 72	 mov	 WORD PTR [eax+114], cx

; 1671 : 
; 1672 : 		return iSerialNumber;

  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx

; 1678 : 	}
; 1679 : 	return 0;
; 1680 : }

  00067	c2 18 00	 ret	 24			; 00000018H
$L209655:

; 1673 : 	}
; 1674 : 	else
; 1675 : 	{
; 1676 : 		WriteLog( "item not found - bank: %s, %s ", pMover->m_szName, pItemProp->szName );

  0006a	83 c3 04	 add	 ebx, 4
  0006d	53		 push	 ebx
  0006e	83 c6 6c	 add	 esi, 108		; 0000006cH
  00071	56		 push	 esi
  00072	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@MKOBOPPN@item?5not?5found?5?9?5bank?3?5?$CFs?0?5?$CFs?5?$AA@
  00077	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi

; 1677 : 		return 0;

  00081	33 c0		 xor	 eax, eax
  00083	5b		 pop	 ebx

; 1678 : 	}
; 1679 : 	return 0;
; 1680 : }

  00084	c2 18 00	 ret	 24			; 00000018H
?RemoveItemBank@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ENDP ; CDbManager::RemoveItemBank
_TEXT	ENDS
PUBLIC	?RemoveItemPocket@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ; CDbManager::RemoveItemPocket
PUBLIC	??_C@_0CB@HEHGABA@item?5not?5found?5?9?5Pocket?3?5?$CFs?0?5?$CFs?5@ ; `string'
EXTRN	?GetPocket@CPocketController@@QAEPAVCPocket@@H@Z:NEAR ; CPocketController::GetPocket
;	COMDAT ??_C@_0CB@HEHGABA@item?5not?5found?5?9?5Pocket?3?5?$CFs?0?5?$CFs?5@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_C@_0CB@HEHGABA@item?5not?5found?5?9?5Pocket?3?5?$CFs?0?5?$CFs?5@ DB 'i'
	DB	'tem not found - Pocket: %s, %s ', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?RemoveItemPocket@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z
_TEXT	SEGMENT
_pItemProp$ = 8						; size = 4
_pMover$ = 12						; size = 4
_nAbilityOption$ = 16					; size = 4
_nItemResist$ = 20					; size = 4
_nResistAbilityOption$ = 24				; size = 4
_nItemCount$ = 28					; size = 4
?RemoveItemPocket@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z PROC NEAR ; CDbManager::RemoveItemPocket, COMDAT
; _this$ = ecx

; 1684 : {

  00000	53		 push	 ebx

; 1685 : 	SERIALNUMBER iSerialNumber = 0;
; 1686 : 	for( int i=0; i<MAX_POCKET; i++ )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _pItemProp$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 1c	 mov	 ebp, DWORD PTR _nResistAbilityOption$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	8b ff		 npad	 2
$L213283:

; 1687 : 	{
; 1688 : 		CPocket* pPocket = pMover->m_Pocket.GetPocket( i );

  00010	8b 4c 24 18	 mov	 ecx, DWORD PTR _pMover$[esp+12]
  00014	57		 push	 edi
  00015	81 c1 78 41 00
	00		 add	 ecx, 16760		; 00004178H
  0001b	e8 00 00 00 00	 call	 ?GetPocket@CPocketController@@QAEPAVCPocket@@H@Z ; CPocketController::GetPocket
  00020	8b f0		 mov	 esi, eax

; 1689 : 		if( pPocket )

  00022	85 f6		 test	 esi, esi
  00024	74 17		 je	 SHORT $L209672

; 1690 : 		{
; 1691 : 			CItemElem* pItemElem = pPocket->GetItem( pItemProp, nAbilityOption, nItemResist, nResistAbilityOption );

  00026	8b 44 24 20	 mov	 eax, DWORD PTR _nItemResist$[esp+12]
  0002a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nAbilityOption$[esp+12]
  0002e	55		 push	 ebp
  0002f	50		 push	 eax
  00030	51		 push	 ecx
  00031	53		 push	 ebx
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?GetItem@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@PAUItemProp@@HHH@Z ; CItemContainer<CItemElem>::GetItem

; 1692 : 			if( pItemElem != NULL )

  00039	85 c0		 test	 eax, eax
  0003b	75 28		 jne	 SHORT $L213281
$L209672:

; 1685 : 	SERIALNUMBER iSerialNumber = 0;
; 1686 : 	for( int i=0; i<MAX_POCKET; i++ )

  0003d	47		 inc	 edi
  0003e	83 ff 03	 cmp	 edi, 3
  00041	7c cd		 jl	 SHORT $L213283

; 1702 : 			}
; 1703 : 		}
; 1704 : 	}
; 1705 : 
; 1706 : 	WriteLog( "item not found - Pocket: %s, %s ", pMover->m_szName, pItemProp->szName );

  00043	8b 44 24 18	 mov	 eax, DWORD PTR _pMover$[esp+12]
  00047	83 c3 04	 add	 ebx, 4
  0004a	53		 push	 ebx
  0004b	83 c0 6c	 add	 eax, 108		; 0000006cH
  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@HEHGABA@item?5not?5found?5?9?5Pocket?3?5?$CFs?0?5?$CFs?5@
  00054	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp

; 1707 : 	return 0;

  0005f	33 c0		 xor	 eax, eax
  00061	5b		 pop	 ebx

; 1708 : }

  00062	c2 18 00	 ret	 24			; 00000018H
$L213281:

; 1693 : 			{
; 1694 : 				iSerialNumber	= pItemElem->GetSerialNumber();
; 1695 : 
; 1696 : 				if( pItemElem->m_nItemNum <= nItemCount )

  00065	66 8b 48 72	 mov	 cx, WORD PTR [eax+114]
  00069	8b 54 24 28	 mov	 edx, DWORD PTR _nItemCount$[esp+12]
  0006d	8b 78 30	 mov	 edi, DWORD PTR [eax+48]
  00070	0f bf d9	 movsx	 ebx, cx
  00073	3b da		 cmp	 ebx, edx
  00075	7f 14		 jg	 SHORT $L209678

; 1697 : 					pPocket->RemoveAt( pItemElem->m_dwObjIndex );

  00077	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  0007a	52		 push	 edx
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?RemoveAt@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAt

; 1700 : 
; 1701 : 				return iSerialNumber;

  00082	8b c7		 mov	 eax, edi
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5d		 pop	 ebp
  00087	5b		 pop	 ebx

; 1708 : }

  00088	c2 18 00	 ret	 24			; 00000018H
$L209678:

; 1698 : 				else
; 1699 : 					pItemElem->m_nItemNum -= nItemCount;

  0008b	2b ca		 sub	 ecx, edx
  0008d	66 89 48 72	 mov	 WORD PTR [eax+114], cx

; 1700 : 
; 1701 : 				return iSerialNumber;

  00091	8b c7		 mov	 eax, edi
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5d		 pop	 ebp
  00096	5b		 pop	 ebx

; 1708 : }

  00097	c2 18 00	 ret	 24			; 00000018H
?RemoveItemPocket@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ENDP ; CDbManager::RemoveItemPocket
_TEXT	ENDS
PUBLIC	?IsAbnormalPlayerData@CDbManager@@AAEHPAVCMover@@@Z ; CDbManager::IsAbnormalPlayerData
; Function compile flags: /Ogty
;	COMDAT ?IsAbnormalPlayerData@CDbManager@@AAEHPAVCMover@@@Z
_TEXT	SEGMENT
_nNumberofIndex$ = -128					; size = 4
_adwEquipment$ = -124					; size = 124
_pMover$ = 8						; size = 4
?IsAbnormalPlayerData@CDbManager@@AAEHPAVCMover@@@Z PROC NEAR ; CDbManager::IsAbnormalPlayerData, COMDAT
; _this$ = ecx

; 1712 : {

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	53		 push	 ebx

; 1713 : 	DWORD dwId;
; 1714 : 	int nMax	= pMover->m_Inventory.m_dwItemMax;

  00007	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR _pMover$[esp+128]
  0000e	8b 93 24 41 00
	00		 mov	 edx, DWORD PTR [ebx+16676]
  00014	55		 push	 ebp

; 1715 : 	int nNumberofIndex	= pMover->m_Inventory.m_dwIndexNum;

  00015	8b ab 1c 41 00
	00		 mov	 ebp, DWORD PTR [ebx+16668]
  0001b	56		 push	 esi

; 1716 : 
; 1717 : 	for( int i = 0; i < nMax; i++ )

  0001c	33 c0		 xor	 eax, eax
  0001e	85 d2		 test	 edx, edx
  00020	57		 push	 edi
  00021	89 6c 24 10	 mov	 DWORD PTR _nNumberofIndex$[esp+144], ebp
  00025	7e 2e		 jle	 SHORT $L213316

; 1713 : 	DWORD dwId;
; 1714 : 	int nMax	= pMover->m_Inventory.m_dwItemMax;

  00027	8b b3 18 41 00
	00		 mov	 esi, DWORD PTR [ebx+16664]
  0002d	8d 49 00	 npad	 3
$L209689:

; 1718 : 	{
; 1719 : 		dwId	= pMover->m_Inventory.m_apIndex[i];

  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1720 : 		if( dwId != NULL_ID )

  00032	83 f9 ff	 cmp	 ecx, -1
  00035	74 16		 je	 SHORT $L209690

; 1721 : 		{
; 1722 : 			if( pMover->m_Inventory.m_apItem[dwId].m_dwObjIndex != i )

  00037	8b bb 20 41 00
	00		 mov	 edi, DWORD PTR [ebx+16672]
  0003d	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00040	c1 e1 05	 shl	 ecx, 5
  00043	39 44 0f 2c	 cmp	 DWORD PTR [edi+ecx+44], eax
  00047	0f 85 c3 00 00
	00		 jne	 $L213308
$L209690:

; 1716 : 
; 1717 : 	for( int i = 0; i < nMax; i++ )

  0004d	40		 inc	 eax
  0004e	83 c6 04	 add	 esi, 4
  00051	3b c2		 cmp	 eax, edx
  00053	7c db		 jl	 SHORT $L209689
$L213316:

; 1723 : 				return TRUE;
; 1724 : 		}
; 1725 : 	}
; 1726 : 
; 1727 : 	DWORD dwObjIndex;
; 1728 : 	for( i = 0; i < nMax; i++ )

  00055	33 f6		 xor	 esi, esi
  00057	85 d2		 test	 edx, edx
  00059	7e 57		 jle	 SHORT $L209697
  0005b	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]
  00061	8b 3d 40 00 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+64
  00067	83 c1 08	 add	 ecx, 8
  0006a	8d 9b 00 00 00
	00		 npad	 6
$L209695:

; 1729 : 	{
; 1730 : 		dwObjIndex	= pMover->m_Inventory.m_apItem[i].m_dwObjIndex;

  00070	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]

; 1731 : 		if( dwObjIndex != NULL_ID )

  00073	83 f8 ff	 cmp	 eax, -1
  00076	74 10		 je	 SHORT $L209699

; 1732 : 		{
; 1733 : 			if( pMover->m_Inventory.m_apIndex[dwObjIndex] != i )

  00078	8b ab 18 41 00
	00		 mov	 ebp, DWORD PTR [ebx+16664]
  0007e	39 74 85 00	 cmp	 DWORD PTR [ebp+eax*4], esi
  00082	0f 85 88 00 00
	00		 jne	 $L213308
$L209699:

; 1734 : 				return TRUE;
; 1735 : 		}
; 1736 : 		if( FALSE == pMover->m_Inventory.m_apItem[i].IsEmpty() )

  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	85 c0		 test	 eax, eax
  0008c	74 15		 je	 SHORT $L209696

; 1737 : 		{
; 1738 : 			ItemProp* pItemProp
; 1739 : 				= prj.GetItemProp( pMover->m_Inventory.m_apItem[i].m_dwItemId );

  0008e	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  00094	73 7a		 jae	 SHORT $L213308
  00096	8b 04 87	 mov	 eax, DWORD PTR [edi+eax*4]

; 1740 : 			if( !pItemProp	/*It have not property*/
; 1741 : 				|| pItemProp->dwItemKind3 == IK3_VIRTUAL/*It is monster's virtual weapon*/ )

  00099	85 c0		 test	 eax, eax
  0009b	74 73		 je	 SHORT $L213308
  0009d	83 78 78 0a	 cmp	 DWORD PTR [eax+120], 10	; 0000000aH
  000a1	74 6d		 je	 SHORT $L213308
$L209696:

; 1723 : 				return TRUE;
; 1724 : 		}
; 1725 : 	}
; 1726 : 
; 1727 : 	DWORD dwObjIndex;
; 1728 : 	for( i = 0; i < nMax; i++ )

  000a3	46		 inc	 esi
  000a4	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  000aa	3b f2		 cmp	 esi, edx
  000ac	7c c2		 jl	 SHORT $L209695
  000ae	8b 6c 24 10	 mov	 ebp, DWORD PTR _nNumberofIndex$[esp+144]
$L209697:

; 1742 : 				return TRUE;
; 1743 : 		}
; 1744 : 	}
; 1745 : 
; 1746 : 	DWORD adwEquipment[MAX_HUMAN_PARTS];
; 1747 : 	memset( adwEquipment, 0xff, sizeof(DWORD) * MAX_HUMAN_PARTS );

  000b2	83 c8 ff	 or	 eax, -1

; 1748 : 	for( i = nNumberofIndex; i < nMax; i++ )

  000b5	3b ea		 cmp	 ebp, edx
  000b7	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  000bc	8d 7c 24 14	 lea	 edi, DWORD PTR _adwEquipment$[esp+144]
  000c0	f3 ab		 rep stosd
  000c2	7d 21		 jge	 SHORT $L209708
  000c4	8b 83 18 41 00
	00		 mov	 eax, DWORD PTR [ebx+16664]
  000ca	8d 04 a8	 lea	 eax, DWORD PTR [eax+ebp*4]
  000cd	8d 74 24 14	 lea	 esi, DWORD PTR _adwEquipment$[esp+144]
  000d1	2b d5		 sub	 edx, ebp
$L209706:

; 1749 : 	{
; 1750 : 		dwId	= pMover->m_Inventory.m_apIndex[i];

  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1751 : 		if( dwId != NULL_ID )

  000d5	83 f9 ff	 cmp	 ecx, -1
  000d8	74 02		 je	 SHORT $L209707

; 1752 : 			adwEquipment[i - nNumberofIndex]	= dwId;

  000da	89 0e		 mov	 DWORD PTR [esi], ecx
$L209707:

; 1748 : 	for( i = nNumberofIndex; i < nMax; i++ )

  000dc	83 c0 04	 add	 eax, 4
  000df	83 c6 04	 add	 esi, 4
  000e2	4a		 dec	 edx
  000e3	75 ee		 jne	 SHORT $L209706
$L209708:

; 1753 : 	}
; 1754 : 	for( i = 0; i < MAX_HUMAN_PARTS; i++ )

  000e5	33 c0		 xor	 eax, eax
  000e7	8d 8b 24 45 00
	00		 lea	 ecx, DWORD PTR [ebx+17700]
  000ed	8d 49 00	 npad	 3
$L209710:

; 1755 : 	{
; 1756 : 		if( adwEquipment[i] != pMover->m_aEquipInfo[i].dwId )

  000f0	8b 54 84 14	 mov	 edx, DWORD PTR _adwEquipment$[esp+eax*4+144]
  000f4	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000f6	75 18		 jne	 SHORT $L213308
  000f8	40		 inc	 eax
  000f9	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000fc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ff	7c ef		 jl	 SHORT $L209710
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5d		 pop	 ebp

; 1758 : 	}
; 1759 : 
; 1760 : 	return FALSE;

  00104	33 c0		 xor	 eax, eax
  00106	5b		 pop	 ebx

; 1761 : }

  00107	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  0010d	c2 04 00	 ret	 4
$L213308:
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5d		 pop	 ebp

; 1757 : 			return TRUE;

  00113	b8 01 00 00 00	 mov	 eax, 1
  00118	5b		 pop	 ebx

; 1761 : }

  00119	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  0011f	c2 04 00	 ret	 4
?IsAbnormalPlayerData@CDbManager@@AAEHPAVCMover@@@Z ENDP ; CDbManager::IsAbnormalPlayerData
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1380 : 		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00007	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0000b	72 13		 jb	 SHORT $L213328
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	52		 push	 edx
  00011	50		 push	 eax
  00012	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00015	50		 push	 eax
  00016	6a 00		 push	 0
  00018	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 1381 : 		}

  0001d	c2 04 00	 ret	 4

; 1380 : 		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));

$L213328:
  00020	52		 push	 edx
  00021	83 c0 04	 add	 eax, 4
  00024	50		 push	 eax
  00025	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 1381 : 		}

  00030	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L213375
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L213373:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L213373
  0001b	5e		 pop	 esi
$L213375:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
PUBLIC	?IsVisPet@CItemElem@@QAEHXZ			; CItemElem::IsVisPet
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?IsVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?IsVisPet@CItemElem@@QAEHXZ PROC NEAR			; CItemElem::IsVisPet, COMDAT
; _this$ = ecx

; 236  : 	BOOL	IsVisPet()	{ return ( GetProp() && GetProp()->IsVisPet() ) || IsTransformVisPet() ; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	56		 push	 esi
  00004	8b 35 40 00 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+64
  0000a	57		 push	 edi
  0000b	8b 3d 50 00 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+80
  00011	3b c7		 cmp	 eax, edi
  00013	73 45		 jae	 SHORT $L213500
  00015	83 3c 86 00	 cmp	 DWORD PTR [esi+eax*4], 0
  00019	74 1a		 je	 SHORT $L213451
  0001b	3b c7		 cmp	 eax, edi
  0001d	72 04		 jb	 SHORT $L213445
  0001f	33 d2		 xor	 edx, edx
  00021	eb 03		 jmp	 SHORT $L213444
$L213445:
  00023	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]
$L213444:
  00026	83 7a 78 64	 cmp	 DWORD PTR [edx+120], 100 ; 00000064H
  0002a	75 09		 jne	 SHORT $L213451
  0002c	83 ba 00 02 00
	00 01		 cmp	 DWORD PTR [edx+512], 1
  00033	74 2a		 je	 SHORT $L213403
$L213451:
  00035	3b c7		 cmp	 eax, edi
  00037	73 21		 jae	 SHORT $L213500
  00039	83 3c 86 00	 cmp	 DWORD PTR [esi+eax*4], 0
  0003d	74 1b		 je	 SHORT $L213500
  0003f	3b c7		 cmp	 eax, edi
  00041	72 04		 jb	 SHORT $L213514
  00043	33 c0		 xor	 eax, eax
  00045	eb 03		 jmp	 SHORT $L213513
$L213514:
  00047	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
$L213513:
  0004a	83 78 78 64	 cmp	 DWORD PTR [eax+120], 100 ; 00000064H
  0004e	75 0a		 jne	 SHORT $L213500
  00050	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]
  00056	85 c0		 test	 eax, eax
  00058	75 05		 jne	 SHORT $L213403
$L213500:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	33 c0		 xor	 eax, eax
  0005e	c3		 ret	 0
$L213403:
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	c3		 ret	 0
?IsVisPet@CItemElem@@QAEHXZ ENDP			; CItemElem::IsVisPet
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1510 : 		if (!_Built)

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Built$[esp-4]
  00004	84 c0		 test	 al, al
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Newsize$[esp+4]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	74 2f		 je	 SHORT $L213554

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00010	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00014	72 29		 jb	 SHORT $L213554

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;
; 1515 : 			if (0 < _Newsize)

  00016	85 ed		 test	 ebp, ebp
  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	57		 push	 edi
  0001c	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  0001f	76 14		 jbe	 SHORT $L213551
  00021	56		 push	 esi

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  00022	8b cd		 mov	 ecx, ebp
  00024	8b d1		 mov	 edx, ecx
  00026	c1 e9 02	 shr	 ecx, 2
  00029	8b f0		 mov	 esi, eax
  0002b	f3 a5		 rep movsd
  0002d	8b ca		 mov	 ecx, edx
  0002f	83 e1 03	 and	 ecx, 3
  00032	f3 a4		 rep movsb
  00034	5e		 pop	 esi
$L213551:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
  0003e	5f		 pop	 edi
$L213554:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;
; 1520 : 		_Eos(_Newsize);

  0003f	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00042	c7 43 18 0f 00
	00 00		 mov	 DWORD PTR [ebx+24], 15	; 0000000fH
  00049	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0004e	5d		 pop	 ebp
  0004f	5b		 pop	 ebx

; 1521 : 		}

  00050	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ; std::vector<long,std::allocator<long> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<long,std::allocator<long> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<long,std::allocator<long> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ; std::vector<long,std::allocator<long> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<long,std::allocator<long> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<long,std::allocator<long> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::vector<long,std::allocator<long> >::erase
; Function compile flags: /Ogty
;	COMDAT ?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::vector<long,std::allocator<long> >::erase, COMDAT
; _this$ = ecx

; 731  : 		{	// erase [_First, _Last)

  00000	53		 push	 ebx
  00001	57		 push	 edi

; 732  : 		if (_First != _Last)

  00002	8b 7c 24 10	 mov	 edi, DWORD PTR __First$[esp+4]
  00006	8b d9		 mov	 ebx, ecx
  00008	8b 4c 24 14	 mov	 ecx, DWORD PTR __Last$[esp+4]
  0000c	3b f9		 cmp	 edi, ecx
  0000e	74 21		 je	 SHORT $L213651

; 733  : 			{	// worth doing, copy down over hole
; 734  : 			pointer _Ptr = copy(_ITER_BASE(_Last), _Mylast,
; 735  : 				_ITER_BASE(_First));

  00010	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00013	2b c1		 sub	 eax, ecx
  00015	56		 push	 esi
  00016	c1 f8 02	 sar	 eax, 2
  00019	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00020	56		 push	 esi
  00021	51		 push	 ecx
  00022	57		 push	 edi
  00023	e8 00 00 00 00	 call	 _memmove
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	03 c6		 add	 eax, esi

; 736  : 			_Destroy(_Ptr, _Mylast);
; 737  : 			_Mylast = _Ptr;

  0002d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00030	5e		 pop	 esi
$L213651:

; 738  : 			}
; 739  : 		return (_First);

  00031	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00035	89 38		 mov	 DWORD PTR [eax], edi
  00037	5f		 pop	 edi
  00038	5b		 pop	 ebx

; 740  : 		}

  00039	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::vector<long,std::allocator<long> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp

; 793  : 		if (_Mysize < _Off)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000b	57		 push	 edi
  0000c	73 05		 jae	 SHORT $L184993

; 794  : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L184993:

; 795  : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $L184994

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$L184994:

; 797  : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 47		 jbe	 SHORT $L213693

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002c	53		 push	 ebx
  0002d	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00030	72 04		 jb	 SHORT $L213658
  00032	8b 13		 mov	 edx, DWORD PTR [ebx]
  00034	eb 02		 jmp	 SHORT $L213659
$L213658:
  00036	8b d3		 mov	 edx, ebx
$L213659:
  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	72 04		 jb	 SHORT $L213665
  0003d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0003f	eb 02		 jmp	 SHORT $L213666
$L213665:
  00041	8b cb		 mov	 ecx, ebx
$L213666:
  00043	2b c7		 sub	 eax, edi

; 803  : 			}
; 804  : 		return (*this);

  00045	03 d5		 add	 edx, ebp
  00047	50		 push	 eax
  00048	03 d7		 add	 edx, edi
  0004a	52		 push	 edx
  0004b	03 cd		 add	 ecx, ebp
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _memmove
  00053	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00056	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00059	2b c7		 sub	 eax, edi
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00061	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00064	72 02		 jb	 SHORT $L213689

; 801  : 			size_type _Newsize = _Mysize - _Count;
; 802  : 			_Eos(_Newsize);

  00066	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$L213689:
  00068	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  0006c	5b		 pop	 ebx
$L213693:
  0006d	5f		 pop	 edi

; 803  : 			}
; 804  : 		return (*this);

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp

; 805  : 		}

  00072	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Buynode
EXTRN	__CxxThrowException@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000a	85 c0		 test	 eax, eax
  0000c	74 2e		 je	 SHORT $L213698
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  0001c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001f	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00023	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0002b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002e	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00032	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00035	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00038	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0
$L213698:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);
; 1139 : 		}

  0003c	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogty
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 227  : 			{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 228  : 			_Dec();

  00003	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 230  : 			}

  0000b	c3		 ret	 0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ; std::vector<long,std::allocator<long> >::_Ufill
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L213767
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L213760:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L213760
  00021	5b		 pop	 ebx
$L213767:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ENDP ; std::vector<long,std::allocator<long> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T213971 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T213973 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L213773
$T213974 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L213771
$T213972 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T213973
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T213974
$T213965 DD	019930520H
	DD	04H
	DD	FLAT:$T213971
	DD	02H
	DD	FLAT:$T213972
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b d8		 mov	 ebx, eax
  00022	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 1446 : 		if (max_size() < _Newres)

  00025	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00028	57		 push	 edi
  00029	8b f1		 mov	 esi, ecx
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00031	76 04		 jbe	 SHORT $L185550

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  00033	8b d8		 mov	 ebx, eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00035	eb 22		 jmp	 SHORT $L185552
$L185550:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00037	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  0003a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0003f	f7 e3		 mul	 ebx
  00041	8b cf		 mov	 ecx, edi
  00043	d1 e9		 shr	 ecx, 1
  00045	d1 ea		 shr	 edx, 1
  00047	3b d1		 cmp	 edx, ecx
  00049	73 0e		 jae	 SHORT $L185552
  0004b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00050	2b c1		 sub	 eax, ecx
  00052	3b f8		 cmp	 edi, eax
  00054	77 03		 ja	 SHORT $L185552

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00056	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
$L185552:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN
; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00059	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0005c	51		 push	 ecx
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00064	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00069	8b d0		 mov	 edx, eax
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
  00071	eb 29		 jmp	 SHORT $L185554
$L213771:

; 1455 : 		_CATCH_ALL
; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN
; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00079	40		 inc	 eax
  0007a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0007d	50		 push	 eax
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00087	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0008a	83 c4 04	 add	 esp, 4

; 1462 : 			_CATCH_END
; 1463 : 		_CATCH_END

  0008d	b8 00 00 00 00	 mov	 eax, $L213966
  00092	c3		 ret	 0
$L213966:
  00093	8b 5d e8	 mov	 ebx, DWORD PTR __Newres$[ebp]
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$L185554:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  0009f	85 c9		 test	 ecx, ecx
  000a1	76 24		 jbe	 SHORT $L213891

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000a3	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000a7	72 05		 jb	 SHORT $L213887
  000a9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000ac	eb 03		 jmp	 SHORT $L213888
$L213887:
  000ae	83 c6 04	 add	 esi, 4
$L213888:
  000b1	8b c1		 mov	 eax, ecx
  000b3	c1 e9 02	 shr	 ecx, 2
  000b6	8b fa		 mov	 edi, edx
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb
  000c1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
$L213891:

; 1467 : 		_Tidy(true);

  000c7	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000cb	72 12		 jb	 SHORT $L213932
  000cd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000dc	83 c4 04	 add	 esp, 4
$L213932:

; 1468 : 		_Bx._Ptr = _Ptr;
; 1469 : 		_Myres = _Newres;
; 1470 : 		_Eos(_Oldlen);

  000df	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000e5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e8	89 10		 mov	 DWORD PTR [eax], edx
  000ea	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000ed	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000f0	72 02		 jb	 SHORT $L213961
  000f2	8b c2		 mov	 eax, edx
$L213961:

; 1471 : 		}

  000f4	5f		 pop	 edi
  000f5	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fc	5e		 pop	 esi
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 08 00	 ret	 8
$L213773:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  0010b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0010e	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00112	72 0c		 jb	 SHORT $L213871
  00114	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011d	83 c4 04	 add	 esp, 4
$L213871:

; 1461 : 			_RERAISE;

  00120	6a 00		 push	 0
  00122	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00129	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00130	6a 00		 push	 0
  00132	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$L213970:
  0013b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T213965
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\string
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 132  : 	return (_Left.compare(_Right) < 0);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00008	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000b	72 05		 jb	 SHORT $L213997
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	eb 03		 jmp	 SHORT $L213998
$L213997:
  00012	83 c0 04	 add	 eax, 4
$L213998:
  00015	51		 push	 ecx
  00016	8b 4c 24 08	 mov	 ecx, DWORD PTR __Left$[esp]
  0001a	50		 push	 eax
  0001b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00026	33 c9		 xor	 ecx, ecx
  00028	85 c0		 test	 eax, eax
  0002a	0f 9c c1	 setl	 cl
  0002d	8a c1		 mov	 al, cl

; 133  : 	}

  0002f	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L214040

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L214040:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L214082
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L214075:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L214075
  00021	5b		 pop	 ebx
$L214082:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 457  : 		_Tidy(true);

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $L214119
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$L214119:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi

; 458  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC NEAR ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (_Left < _Right);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00008	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000b	72 05		 jb	 SHORT $L214165
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	eb 03		 jmp	 SHORT $L214166
$L214165:
  00012	83 c0 04	 add	 eax, 4
$L214166:
  00015	51		 push	 ecx
  00016	8b 4c 24 08	 mov	 ecx, DWORD PTR __Left$[esp]
  0001a	50		 push	 eax
  0001b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00026	33 c9		 xor	 ecx, ecx
  00028	85 c0		 test	 eax, eax
  0002a	0f 9c c1	 setl	 cl
  0002d	8a c1		 mov	 al, cl

; 140  : 		}

  0002f	c2 08 00	 ret	 8
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator--
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 339  : 			{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 340  : 			--(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 342  : 			}

  0000b	c3		 ret	 0
??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 1481 : 		if (max_size() < _Newsize)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR __Newsize$[esp+4]
  00006	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00009	8b e9		 mov	 ebp, ecx
  0000b	76 05		 jbe	 SHORT $L185002

; 1482 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L185002:

; 1483 : 		if (_Myres < _Newsize)

  00012	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00015	3b c6		 cmp	 eax, esi
  00017	73 19		 jae	 SHORT $L185003

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  00019	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	8b cd		 mov	 ecx, ebp
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  00025	33 c0		 xor	 eax, eax
  00027	3b c6		 cmp	 eax, esi
  00029	1b c0		 sbb	 eax, eax
  0002b	5e		 pop	 esi
  0002c	f7 d8		 neg	 eax
  0002e	5d		 pop	 ebp

; 1491 : 		}

  0002f	c2 08 00	 ret	 8
$L185003:

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00032	8a 4c 24 10	 mov	 cl, BYTE PTR __Trim$[esp+4]
  00036	84 c9		 test	 cl, cl
  00038	74 5c		 je	 SHORT $L185005
  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0003d	73 57		 jae	 SHORT $L185005
  0003f	53		 push	 ebx

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00040	8b 5d 14	 mov	 ebx, DWORD PTR [ebp+20]
  00043	3b f3		 cmp	 esi, ebx
  00045	73 02		 jae	 SHORT $L214176
  00047	8b de		 mov	 ebx, esi
$L214176:
  00049	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004c	72 2b		 jb	 SHORT $L214237
  0004e	85 db		 test	 ebx, ebx
  00050	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00053	57		 push	 edi
  00054	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  00057	76 16		 jbe	 SHORT $L214235
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b d1		 mov	 edx, ecx
  0005d	c1 e9 02	 shr	 ecx, 2
  00060	8b f0		 mov	 esi, eax
  00062	f3 a5		 rep movsd
  00064	8b ca		 mov	 ecx, edx
  00066	83 e1 03	 and	 ecx, 3
  00069	f3 a4		 rep movsb
  0006b	8b 74 24 14	 mov	 esi, DWORD PTR __Newsize$[esp+12]
$L214235:
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00075	83 c4 04	 add	 esp, 4
  00078	5f		 pop	 edi
$L214237:
  00079	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0007c	33 c0		 xor	 eax, eax
  0007e	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00085	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0008a	3b c6		 cmp	 eax, esi
  0008c	5b		 pop	 ebx
  0008d	1b c0		 sbb	 eax, eax
  0008f	5e		 pop	 esi
  00090	f7 d8		 neg	 eax
  00092	5d		 pop	 ebp

; 1491 : 		}

  00093	c2 08 00	 ret	 8
$L185005:

; 1488 : 		else if (_Newsize == 0)

  00096	85 f6		 test	 esi, esi
  00098	75 23		 jne	 SHORT $L214267

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  0009a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009d	89 75 14	 mov	 DWORD PTR [ebp+20], esi
  000a0	72 14		 jb	 SHORT $L214263
  000a2	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000a5	33 c0		 xor	 eax, eax
  000a7	3b c6		 cmp	 eax, esi
  000a9	1b c0		 sbb	 eax, eax
  000ab	5e		 pop	 esi
  000ac	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  000b0	f7 d8		 neg	 eax
  000b2	5d		 pop	 ebp

; 1491 : 		}

  000b3	c2 08 00	 ret	 8

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

$L214263:
  000b6	83 c5 04	 add	 ebp, 4
  000b9	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
$L214267:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000bd	33 c0		 xor	 eax, eax
  000bf	3b c6		 cmp	 eax, esi
  000c1	1b c0		 sbb	 eax, eax
  000c3	5e		 pop	 esi
  000c4	f7 d8		 neg	 eax
  000c6	5d		 pop	 ebp

; 1491 : 		}

  000c7	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
tv208 = -4						; size = 4
tv210 = 8						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 987  : 		{	// find leftmost node not less than _Keyval

  00000	83 ec 08	 sub	 esp, 8

; 988  : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	55		 push	 ebp
  00007	8b 68 04	 mov	 ebp, DWORD PTR [eax+4]

; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0000a	8a 4d 2d	 mov	 cl, BYTE PTR [ebp+45]
  0000d	84 c9		 test	 cl, cl
  0000f	89 44 24 04	 mov	 DWORD PTR __Wherenode$[esp+12], eax
  00013	0f 85 94 00 00
	00		 jne	 $L185107

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00019	8b 4c 24 10	 mov	 ecx, DWORD PTR __Keyval$[esp+8]
  0001d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00020	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00023	53		 push	 ebx
  00024	56		 push	 esi
  00025	83 c1 04	 add	 ecx, 4
  00028	57		 push	 edi
  00029	89 54 24 14	 mov	 DWORD PTR tv208[esp+24], edx
  0002d	89 4c 24 1c	 mov	 DWORD PTR tv210[esp+20], ecx
  00031	eb 0d		 jmp	 SHORT $L185106
$L214451:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

  00033	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv210[esp+20]
  00037	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L185106:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00040	8b 74 24 14	 mov	 esi, DWORD PTR tv208[esp+24]
  00044	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00049	3b f2		 cmp	 esi, edx
  0004b	72 04		 jb	 SHORT $L214417
  0004d	8b 39		 mov	 edi, DWORD PTR [ecx]
  0004f	eb 02		 jmp	 SHORT $L214418
$L214417:
  00051	8b f9		 mov	 edi, ecx
$L214418:
  00053	8b 5d 20	 mov	 ebx, DWORD PTR [ebp+32]
  00056	8b cb		 mov	 ecx, ebx
  00058	3b cb		 cmp	 ecx, ebx
  0005a	73 00		 jae	 SHORT $L214436
$L214436:
  0005c	85 db		 test	 ebx, ebx
  0005e	74 24		 je	 SHORT $L214450
  00060	3b d8		 cmp	 ebx, eax
  00062	8b cb		 mov	 ecx, ebx
  00064	72 02		 jb	 SHORT $L214421
  00066	8b c8		 mov	 ecx, eax
$L214421:
  00068	39 55 24	 cmp	 DWORD PTR [ebp+36], edx
  0006b	72 05		 jb	 SHORT $L214430
  0006d	8b 75 10	 mov	 esi, DWORD PTR [ebp+16]
  00070	eb 03		 jmp	 SHORT $L214431
$L214430:
  00072	8d 75 10	 lea	 esi, DWORD PTR [ebp+16]
$L214431:
  00075	33 d2		 xor	 edx, edx
  00077	f3 a6		 repe cmpsb
  00079	74 05		 je	 SHORT $L214448
  0007b	1b d2		 sbb	 edx, edx
  0007d	83 da ff	 sbb	 edx, -1
$L214448:
  00080	85 d2		 test	 edx, edx
  00082	75 0d		 jne	 SHORT $L214452
$L214450:
  00084	3b d8		 cmp	 ebx, eax
  00086	72 0b		 jb	 SHORT $L214447
  00088	33 d2		 xor	 edx, edx
  0008a	3b d8		 cmp	 ebx, eax
  0008c	0f 95 c2	 setne	 dl
  0008f	85 d2		 test	 edx, edx
$L214452:
  00091	7d 05		 jge	 SHORT $L185108
$L214447:

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00093	8b 6d 08	 mov	 ebp, DWORD PTR [ebp+8]

; 994  : 			else

  00096	eb 07		 jmp	 SHORT $L185109
$L185108:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00098	89 6c 24 10	 mov	 DWORD PTR __Wherenode$[esp+24], ebp

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0009c	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$L185109:
  0009f	8a 4d 2d	 mov	 cl, BYTE PTR [ebp+45]
  000a2	84 c9		 test	 cl, cl
  000a4	74 8d		 je	 SHORT $L214451

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate

  000a6	8b 44 24 10	 mov	 eax, DWORD PTR __Wherenode$[esp+24]
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
$L185107:
  000ad	5d		 pop	 ebp

; 1001 : 		}

  000ae	83 c4 08	 add	 esp, 8
  000b1	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L214463
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L214463:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L214532
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L214532:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 27   : 		return (_Str.c_str());

  00000	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L214558
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  00009	c3		 ret	 0

; 27   : 		return (_Str.c_str());

$L214558:
  0000a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  0000d	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L214564
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L214564:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 591  : 		if (_Right.size() < _Roff)

  00003	8b 74 24 14	 mov	 esi, DWORD PTR __Roff$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 14	 mov	 edi, DWORD PTR __Right$[esp+12]
  0000c	39 77 14	 cmp	 DWORD PTR [edi+20], esi
  0000f	8b d9		 mov	 ebx, ecx
  00011	73 05		 jae	 SHORT $L184271

; 592  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L184271:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 6f 14	 mov	 ebp, DWORD PTR [edi+20]

; 594  : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b ee		 sub	 ebp, esi
  00021	3b c5		 cmp	 eax, ebp
  00023	73 02		 jae	 SHORT $L184273

; 595  : 			_Num = _Count;	// trim _Num to size

  00025	8b e8		 mov	 ebp, eax
$L184273:

; 596  : 
; 597  : 		if (this == &_Right)

  00027	3b df		 cmp	 ebx, edi
  00029	75 1f		 jne	 SHORT $L184274

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 ee		 add	 ebp, esi
  0002f	55		 push	 ebp
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00037	56		 push	 esi
  00038	6a 00		 push	 0
  0003a	8b cb		 mov	 ecx, ebx
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00044	8b c3		 mov	 eax, ebx
  00046	5b		 pop	 ebx

; 605  : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$L184274:

; 599  : 		else if (_Grow(_Num))

  0004a	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  0004d	76 07		 jbe	 SHORT $L214714
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L214714:
  00056	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00059	3b c5		 cmp	 eax, ebp
  0005b	73 21		 jae	 SHORT $L214715
  0005d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00060	50		 push	 eax
  00061	55		 push	 ebp
  00062	8b cb		 mov	 ecx, ebx
  00064	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00069	85 ed		 test	 ebp, ebp
$L214760:
  0006b	76 6d		 jbe	 SHORT $L214759

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0006d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00070	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00075	3b c8		 cmp	 ecx, eax
  00077	72 2f		 jb	 SHORT $L214725
  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	eb 2d		 jmp	 SHORT $L214726

; 599  : 		else if (_Grow(_Num))

$L214715:
  0007e	85 ed		 test	 ebp, ebp
  00080	75 e9		 jne	 SHORT $L214760
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00088	72 0f		 jb	 SHORT $L214707
  0008a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00093	8b c3		 mov	 eax, ebx
  00095	5b		 pop	 ebx

; 605  : 		}

  00096	c2 0c 00	 ret	 12			; 0000000cH

; 599  : 		else if (_Grow(_Num))

$L214707:
  00099	5f		 pop	 edi
  0009a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009d	5e		 pop	 esi
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a1	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000a2	8b c3		 mov	 eax, ebx
  000a4	5b		 pop	 ebx

; 605  : 		}

  000a5	c2 0c 00	 ret	 12			; 0000000cH

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$L214725:
  000a8	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
$L214726:
  000ab	39 43 18	 cmp	 DWORD PTR [ebx+24], eax
  000ae	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000b1	72 04		 jb	 SHORT $L214732
  000b3	8b 38		 mov	 edi, DWORD PTR [eax]
  000b5	eb 02		 jmp	 SHORT $L214733
$L214732:
  000b7	8b f8		 mov	 edi, eax
$L214733:
  000b9	03 f2		 add	 esi, edx
  000bb	8b cd		 mov	 ecx, ebp
  000bd	8b d1		 mov	 edx, ecx
  000bf	c1 e9 02	 shr	 ecx, 2
  000c2	f3 a5		 rep movsd
  000c4	8b ca		 mov	 ecx, edx
  000c6	83 e1 03	 and	 ecx, 3
  000c9	f3 a4		 rep movsb

; 602  : 			_Eos(_Num);

  000cb	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000cf	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000d2	72 02		 jb	 SHORT $L214756
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
$L214756:
  000d6	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L214759:
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000dd	8b c3		 mov	 eax, ebx
  000df	5b		 pop	 ebx

; 605  : 		}

  000e0	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::lower_bound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Keyval$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound
  0000a	8b 4c 24 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp-4]
  0000e	89 01		 mov	 DWORD PTR [ecx], eax
  00010	8b c1		 mov	 eax, ecx

; 811  : 		}

  00012	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 609  : 		if (_Inside(_Ptr))

  00003	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	72 05		 jb	 SHORT $L214796
  0000d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00010	eb 03		 jmp	 SHORT $L214797
$L214796:
  00012	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$L214797:
  00015	8b 74 24 10	 mov	 esi, DWORD PTR __Ptr$[esp+8]
  00019	3b f0		 cmp	 esi, eax
  0001b	72 34		 jb	 SHORT $L184989
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00023	72 04		 jb	 SHORT $L214800
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $L214801
$L214800:
  00029	8b c8		 mov	 ecx, eax
$L214801:
  0002b	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  0002e	03 f9		 add	 edi, ecx
  00030	3b fe		 cmp	 edi, esi
  00032	76 1d		 jbe	 SHORT $L184989

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  00034	83 fa 10	 cmp	 edx, 16			; 00000010H
  00037	72 02		 jb	 SHORT $L214809
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$L214809:
  0003b	8b 4c 24 14	 mov	 ecx, DWORD PTR __Num$[esp+8]
  0003f	51		 push	 ecx
  00040	2b f0		 sub	 esi, eax
  00042	56		 push	 esi
  00043	53		 push	 ebx
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 618  : 		}

  0004e	c2 08 00	 ret	 8
$L184989:
  00051	55		 push	 ebp

; 611  : 
; 612  : 		if (_Grow(_Num))

  00052	8b 6c 24 18	 mov	 ebp, DWORD PTR __Num$[esp+12]
  00056	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  00059	76 07		 jbe	 SHORT $L214907
  0005b	8b cb		 mov	 ecx, ebx
  0005d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L214907:
  00062	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00065	3b c5		 cmp	 eax, ebp
  00067	73 1b		 jae	 SHORT $L214908
  00069	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  0006c	52		 push	 edx
  0006d	55		 push	 ebp
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00075	85 ed		 test	 ebp, ebp
$L214988:
  00077	76 68		 jbe	 SHORT $L214986

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00079	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0007d	72 2f		 jb	 SHORT $L214960
  0007f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00082	eb 2d		 jmp	 SHORT $L214961

; 611  : 
; 612  : 		if (_Grow(_Num))

$L214908:
  00084	85 ed		 test	 ebp, ebp
  00086	75 ef		 jne	 SHORT $L214988
  00088	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008b	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  0008e	72 0f		 jb	 SHORT $L214951
  00090	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00093	5d		 pop	 ebp
  00094	5f		 pop	 edi
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0
  00098	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  00099	8b c3		 mov	 eax, ebx
  0009b	5b		 pop	 ebx

; 618  : 		}

  0009c	c2 08 00	 ret	 8

; 611  : 
; 612  : 		if (_Grow(_Num))

$L214951:
  0009f	5d		 pop	 ebp
  000a0	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000a3	5f		 pop	 edi
  000a4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a7	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx

; 618  : 		}

  000ab	c2 08 00	 ret	 8

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

$L214960:
  000ae	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
$L214961:
  000b1	8b cd		 mov	 ecx, ebp
  000b3	8b c1		 mov	 eax, ecx
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb

; 615  : 			_Eos(_Num);

  000c1	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000c5	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000c8	72 10		 jb	 SHORT $L214983
  000ca	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000cd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  000d1	5d		 pop	 ebp
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000d4	8b c3		 mov	 eax, ebx
  000d6	5b		 pop	 ebx

; 618  : 		}

  000d7	c2 08 00	 ret	 8

; 615  : 			_Eos(_Num);

$L214983:
  000da	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000dd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L214986:
  000e1	5d		 pop	 ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000e4	8b c3		 mov	 eax, ebx
  000e6	5b		 pop	 ebx

; 618  : 		}

  000e7	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

  00000	56		 push	 esi

; 324  : 		_Tidy();

  00001	33 c0		 xor	 eax, eax
  00003	8b f1		 mov	 esi, ecx

; 325  : 		assign(_Right, 0, npos);

  00005	6a ff		 push	 -1
  00007	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	50		 push	 eax
  00012	88 46 04	 mov	 BYTE PTR [esi+4], al
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Right$[esp+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T215060 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00003	8b 7c 24 14	 mov	 edi, DWORD PTR __Keyval$[esp+8]
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0000f	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00012	89 44 24 14	 mov	 DWORD PTR __Where$[esp+8], eax
  00016	74 36		 je	 SHORT $L215059
  00018	83 78 24 10	 cmp	 DWORD PTR [eax+36], 16	; 00000010H
  0001c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001f	72 05		 jb	 SHORT $L215153
  00021	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00024	eb 03		 jmp	 SHORT $L215154
$L215153:
  00026	83 c0 10	 add	 eax, 16			; 00000010H
$L215154:
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	8b cf		 mov	 ecx, edi
  00033	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00038	85 c0		 test	 eax, eax
  0003a	7c 12		 jl	 SHORT $L215059
  0003c	8d 44 24 14	 lea	 eax, DWORD PTR __Where$[esp+8]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00046	5f		 pop	 edi
  00047	89 10		 mov	 DWORD PTR [eax], edx
  00049	5e		 pop	 esi

; 791  : 		}

  0004a	59		 pop	 ecx
  0004b	c2 08 00	 ret	 8
$L215059:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0004e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00051	8d 44 24 08	 lea	 eax, DWORD PTR $T215060[esp+12]
  00055	89 4c 24 08	 mov	 DWORD PTR $T215060[esp+12], ecx
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  0005f	5f		 pop	 edi
  00060	89 10		 mov	 DWORD PTR [eax], edx
  00062	5e		 pop	 esi

; 791  : 		}

  00063	59		 pop	 ecx
  00064	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L215179:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L215179
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 623  : 		}

  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T215282 DD	0ffffffffH
	DD	FLAT:$L215182
$T215280 DD	019930520H
	DD	01H
	DD	FLAT:$T215282
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	e8 00 00 00 00	 call	 ??0exception@@QAE@XZ	; exception::exception
  00022	33 c0		 xor	 eax, eax
  00024	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	6a ff		 push	 -1
  0002f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00032	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00039	50		 push	 eax
  0003a	89 44 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], eax
  0003e	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00041	8b 44 24 20	 mov	 eax, DWORD PTR __Message$[esp+24]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 20   : 		}

  0004b	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L215182:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T215280
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogty
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L215290
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L215290:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L215384
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L215384:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 361  : 		_Tidy();
; 362  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b c2		 mov	 eax, edx
  00009	57		 push	 edi
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$L215470:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L215470
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 363  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Insert
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T215845 DD	0ffffffffH
	DD	FLAT:$L215475
$T215840 DD	019930520H
	DD	01H
	DD	FLAT:$T215845
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z
_TEXT	SEGMENT
$T215474 = -80						; size = 28
$T215473 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b f9		 mov	 edi, ecx

; 912  : 		if (max_size() - 1 <= _Mysize)

  0001c	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00023	72 4c		 jb	 SHORT $L184758

; 913  : 			_THROW(length_error, "map/set<T> too long");

  00025	6a 13		 push	 19			; 00000013H
  00027	33 f6		 xor	 esi, esi
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	8d 4c 24 10	 lea	 ecx, DWORD PTR $T215474[esp+96]
  00032	c7 44 24 28 0f
	00 00 00	 mov	 DWORD PTR $T215474[esp+120], 15 ; 0000000fH
  0003a	89 74 24 24	 mov	 DWORD PTR $T215474[esp+116], esi
  0003e	c6 44 24 14 00	 mov	 BYTE PTR $T215474[esp+100], 0
  00043	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00048	8d 44 24 08	 lea	 eax, DWORD PTR $T215474[esp+88]
  0004c	50		 push	 eax
  0004d	8d 4c 24 28	 lea	 ecx, DWORD PTR $T215473[esp+92]
  00051	89 74 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], esi
  00055	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0005f	8d 4c 24 28	 lea	 ecx, DWORD PTR $T215473[esp+92]
  00063	51		 push	 ecx
  00064	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T215473[esp+96], OFFSET FLAT:??_7length_error@std@@6B@
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$L184758:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  00071	8b 54 24 68	 mov	 edx, DWORD PTR __Val$[esp+84]
  00075	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00078	8b 74 24 64	 mov	 esi, DWORD PTR __Wherenode$[esp+84]
  0007c	53		 push	 ebx
  0007d	6a 00		 push	 0
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	56		 push	 esi
  00082	50		 push	 eax
  00083	8b cf		 mov	 ecx, edi
  00085	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVIBuff@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0008a	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0008d	8b c8		 mov	 ecx, eax

; 918  : 		if (_Wherenode == _Myhead)

  0008f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00092	43		 inc	 ebx
  00093	3b f0		 cmp	 esi, eax
  00095	89 4c 24 6c	 mov	 DWORD PTR __Newnode$[esp+88], ecx
  00099	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0009c	75 10		 jne	 SHORT $L184768

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  0009e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  000a1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
  000a6	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000a9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 922  : 			}
; 923  : 		else if (_Addleft)

  000ac	eb 23		 jmp	 SHORT $L184773
$L184768:
  000ae	8a 44 24 64	 mov	 al, BYTE PTR __Addleft$[esp+88]
  000b2	84 c0		 test	 al, al
  000b4	74 0d		 je	 SHORT $L184770

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  000b6	89 0e		 mov	 DWORD PTR [esi], ecx

; 926  : 			if (_Wherenode == _Lmost())

  000b8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000bb	3b 30		 cmp	 esi, DWORD PTR [eax]
  000bd	75 12		 jne	 SHORT $L184773

; 927  : 				_Lmost() = _Newnode;

  000bf	89 08		 mov	 DWORD PTR [eax], ecx

; 928  : 			}
; 929  : 		else

  000c1	eb 0e		 jmp	 SHORT $L184773
$L184770:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  000c3	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 932  : 			if (_Wherenode == _Rmost())

  000c6	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c9	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  000cc	75 03		 jne	 SHORT $L184773

; 933  : 				_Rmost() = _Newnode;

  000ce	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L184773:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  000d1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d4	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000d8	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  000db	8b f1		 mov	 esi, ecx
  000dd	b3 01		 mov	 bl, 1
  000df	0f 85 a5 00 00
	00		 jne	 $L184777
  000e5	55		 push	 ebp
$L184776:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  000eb	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  000ee	3b ca		 cmp	 ecx, edx
  000f0	75 50		 jne	 SHORT $L184778

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000f2	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000f5	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000f9	75 18		 jne	 SHORT $L184779
$L215844:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fd	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 943  : 					_Color(_Wherenode) = _Black;

  00100	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00103	8b 10		 mov	 edx, DWORD PTR [eax]
  00105	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00108	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
  0010e	8b 72 04	 mov	 esi, DWORD PTR [edx+4]

; 946  : 					}
; 947  : 				else

  00111	eb 61		 jmp	 SHORT $L184784
$L184779:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  00113	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  00116	75 0a		 jne	 SHORT $L184781

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);

  00118	8b f1		 mov	 esi, ecx

; 952  : 						_Lrotate(_Pnode);

  0011a	56		 push	 esi
  0011b	8b cf		 mov	 ecx, edi
  0011d	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lrotate
$L184781:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  00122	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00125	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00128	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	c6 42 14 00	 mov	 BYTE PTR [edx+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  00132	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00135	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00138	51		 push	 ecx
  00139	8b cf		 mov	 ecx, edi
  0013b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  00140	eb 32		 jmp	 SHORT $L184784
$L184778:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  00142	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00146	74 b3		 je	 SHORT $L215844

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00148	3b 31		 cmp	 esi, DWORD PTR [ecx]
  0014a	75 0a		 jne	 SHORT $L184785

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);

  0014c	8b f1		 mov	 esi, ecx

; 974  : 						_Rrotate(_Pnode);

  0014e	56		 push	 esi
  0014f	8b cf		 mov	 ecx, edi
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Rrotate
$L184785:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  00156	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00159	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  0015c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0015f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00162	c6 42 14 00	 mov	 BYTE PTR [edx+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00166	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00169	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016c	51		 push	 ecx
  0016d	8b cf		 mov	 ecx, edi
  0016f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lrotate
$L184784:
  00174	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00177	8a 4a 14	 mov	 cl, BYTE PTR [edx+20]
  0017a	84 c9		 test	 cl, cl
  0017c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0017f	0f 84 61 ff ff
	ff		 je	 $L184776
  00185	8b 4c 24 70	 mov	 ecx, DWORD PTR __Newnode$[esp+92]
  00189	5d		 pop	 ebp
$L184777:

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0018a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0018d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));

  00190	8b 44 24 60	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+88]
  00194	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  00197	5b		 pop	 ebx
  00198	89 08		 mov	 DWORD PTR [eax], ecx

; 984  : 		}

  0019a	8b 4c 24 4c	 mov	 ecx, DWORD PTR __$EHRec$[esp+88]
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a7	83 c4 50	 add	 esp, 80			; 00000050H
  001aa	c2 10 00	 ret	 16			; 00000010H
$L215843:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L215475:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T215474[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T215840
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Insert
;	COMDAT xdata$x
xdata$x	SEGMENT
$T215950 DD	0ffffffffH
	DD	FLAT:$L215850
$T215948 DD	019930520H
	DD	01H
	DD	FLAT:$T215950
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	e8 00 00 00 00	 call	 ??0exception@@QAE@ABV0@@Z ; exception::exception
  00028	33 c0		 xor	 eax, eax
  0002a	6a ff		 push	 -1
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	50		 push	 eax
  00036	83 c7 0c	 add	 edi, 12			; 0000000cH
  00039	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00040	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00043	57		 push	 edi
  00044	89 44 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], eax
  00048	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00054	5f		 pop	 edi
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L215850:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T215948
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogty
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ ; std::vector<long,std::allocator<long> >::_Xlen
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T216075 DD	0ffffffffH
	DD	FLAT:$L215960
$T216072 DD	019930520H
	DD	01H
	DD	FLAT:$T216075
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T215959 = -80						; size = 28
$T215958 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ PROC NEAR ; std::vector<long,std::allocator<long> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T215959[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T215959[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T215959[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T215959[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T215959[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T215958[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T215958[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T215958[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L216074:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L215960:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T215959[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T216072
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ ENDP	; std::vector<long,std::allocator<long> >::_Xlen
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T216197 DD	0ffffffffH
	DD	FLAT:$L216082
$T216194 DD	019930520H
	DD	01H
	DD	FLAT:$T216197
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T216081 = -80						; size = 28
$T216080 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T216081[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T216081[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T216081[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T216081[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T216081[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T216080[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T216080[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T216080[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L216196:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L216082:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T216081[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T216194
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z	; CProject::GetItemProp
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
xdata$x	SEGMENT
$T216449 DD	0ffffffffH
	DD	FLAT:$L216204
$T216446 DD	019930520H
	DD	01H
	DD	FLAT:$T216449
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\databaseserver\project.h
xdata$x	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z
_TEXT	SEGMENT
$T216202 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_i$ = 8							; size = 4
_lpszItem$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 255  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 256  : 	map<string, DWORD>::iterator i	= m_mapII.find( lpszItem );

  00018	8b 54 24 2c	 mov	 edx, DWORD PTR _lpszItem$[esp+36]
  0001c	56		 push	 esi
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8b f1		 mov	 esi, ecx
  00022	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T216202[esp+72], 15 ; 0000000fH
  0002a	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T216202[esp+68], 0
  00032	c6 44 24 0c 00	 mov	 BYTE PTR $T216202[esp+52], 0
  00037	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L216447:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $L216447
  00047	2b c7		 sub	 eax, edi
  00049	50		 push	 eax
  0004a	52		 push	 edx
  0004b	8d 4c 24 10	 lea	 ecx, DWORD PTR $T216202[esp+56]
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00054	8d 44 24 08	 lea	 eax, DWORD PTR $T216202[esp+48]
  00058	50		 push	 eax
  00059	8d 4c 24 38	 lea	 ecx, DWORD PTR _i$[esp+48]
  0005d	51		 push	 ecx
  0005e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00061	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+64], 0
  00069	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
  0006e	83 7c 24 20 10	 cmp	 DWORD PTR $T216202[esp+72], 16 ; 00000010H
  00073	72 0d		 jb	 SHORT $L216373
  00075	8b 54 24 0c	 mov	 edx, DWORD PTR $T216202[esp+52]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007f	83 c4 04	 add	 esp, 4
$L216373:

; 257  : 	if( i != m_mapII.end() )

  00082	8b 44 24 34	 mov	 eax, DWORD PTR _i$[esp+44]
  00086	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00089	74 21		 je	 SHORT $L156841

; 258  : 		return GetItemProp( i->second );

  0008b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0008e	3b 46 50	 cmp	 eax, DWORD PTR [esi+80]
  00091	73 19		 jae	 SHORT $L156841
  00093	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00096	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi

; 259  : 	return NULL;
; 260  : }

  0009b	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a6	83 c4 28	 add	 esp, 40			; 00000028H
  000a9	c2 04 00	 ret	 4
$L156841:
  000ac	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000b0	5f		 pop	 edi
  000b1	33 c0		 xor	 eax, eax
  000b3	5e		 pop	 esi
  000b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000bb	83 c4 28	 add	 esp, 40			; 00000028H
  000be	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L216204:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T216202[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T216446
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z ENDP	; CProject::GetItemProp
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T216462 = 12						; size = 4
$T216460 = 12						; size = 4
__Where$183819 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::insert, COMDAT
; _this$ = ecx

; 477  : 		{	// try to insert node with value _Val

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 478  : 		_Nodeptr _Trynode = _Root();
; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00002	8b 6c 24 10	 mov	 ebp, DWORD PTR __Val$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00013	84 d2		 test	 dl, dl
  00015	b1 01		 mov	 cl, 1
  00017	88 4c 24 0c	 mov	 BYTE PTR __Addleft$[esp+16], cl
  0001b	75 20		 jne	 SHORT $L183809
  0001d	8b 55 00	 mov	 edx, DWORD PTR [ebp]
$L183808:

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));

  00020	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  00023	0f 92 c1	 setb	 cl

; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  00026	84 c9		 test	 cl, cl
  00028	8b f0		 mov	 esi, eax
  0002a	88 4c 24 0c	 mov	 BYTE PTR __Addleft$[esp+16], cl
  0002e	74 04		 je	 SHORT $L216454
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	eb 03		 jmp	 SHORT $L216455
$L216454:
  00034	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L216455:

; 478  : 		_Nodeptr _Trynode = _Root();
; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00037	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003b	74 e3		 je	 SHORT $L183808
$L183809:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  0003d	84 c9		 test	 cl, cl
  0003f	8b d6		 mov	 edx, esi
  00041	89 54 24 18	 mov	 DWORD PTR __Where$183819[esp+12], edx
  00045	74 33		 je	 SHORT $L216554

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00047	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004a	3b 30		 cmp	 esi, DWORD PTR [eax]

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004c	8d 4c 24 18	 lea	 ecx, DWORD PTR $T216460[esp+12]
  00050	75 1f		 jne	 SHORT $L183824
  00052	55		 push	 ebp
  00053	56		 push	 esi
  00054	6a 01		 push	 1
  00056	51		 push	 ecx
  00057	8b cf		 mov	 ecx, edi
  00059	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Insert
  0005e	8b 10		 mov	 edx, DWORD PTR [eax]
  00060	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  0006a	89 10		 mov	 DWORD PTR [eax], edx
  0006c	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  0006d	59		 pop	 ecx
  0006e	c2 08 00	 ret	 8
$L183824:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00071	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Dec
  00076	8b 54 24 18	 mov	 edx, DWORD PTR __Where$183819[esp+12]
$L216554:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0007a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007d	3b 45 00	 cmp	 eax, DWORD PTR [ebp]
  00080	73 26		 jae	 SHORT $L183829

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00082	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Addleft$[esp+16]
  00086	55		 push	 ebp
  00087	56		 push	 esi
  00088	51		 push	 ecx
  00089	8d 54 24 24	 lea	 edx, DWORD PTR $T216462[esp+24]
  0008d	52		 push	 edx
  0008e	8b cf		 mov	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Insert
  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
  0009f	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000a3	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  000a4	59		 pop	 ecx
  000a5	c2 08 00	 ret	 8
$L183829:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  000a8	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000b2	89 10		 mov	 DWORD PTR [eax], edx
  000b4	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  000b5	59		 pop	 ecx
  000b6	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z ; std::vector<long,std::allocator<long> >::_Insert_n
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z
_TEXT	SEGMENT
__Newvec$184837 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L216601
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L216602
$L216601:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L216602:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L184857

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L216624
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L216625
$L216624:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L216625:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L184833

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ ; std::vector<long,std::allocator<long> >::_Xlen
$L184833:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L216631
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L216632
$L216631:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L216632:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L184835

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L216590
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L216591
$L216590:
  0007f	03 c1		 add	 eax, ecx
$L216591:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L216654
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L216655
$L216654:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L216655:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L184836

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L216661
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L216662
$L216661:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L216662:
  000a7	03 c7		 add	 eax, edi
$L184836:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$184837[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ; std::vector<long,std::allocator<long> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L216743
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L216744
$L216743:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L216744:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L216746

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L216746:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$184837[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L184835:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L184848
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ; std::vector<long,std::allocator<long> >::_Ucopy<long *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ; std::vector<long,std::allocator<long> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z ; std::fill<long *,long>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L184848:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ; std::vector<long,std::allocator<long> >::_Ucopy<long *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z ; std::copy_backward<long *,long *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z ; std::fill<long *,long>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L184857:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L216754:
?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z ENDP ; std::vector<long,std::allocator<long> >::_Insert_n
_TEXT	ENDS
PUBLIC	?RemoveItem@CDbManager@@AAEKPAVCQuery@@PADHPAVCMover@@1HHHHD@Z ; CDbManager::RemoveItem
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
;	COMDAT ?RemoveItem@CDbManager@@AAEKPAVCQuery@@PADHPAVCMover@@1HHHHD@Z
_TEXT	SEGMENT
_pQry$ = 8						; size = 4
_szSql$ = 12						; size = 4
_nNo$ = 16						; size = 4
_pMover$ = 20						; size = 4
_szItemName$ = 24					; size = 4
_nItemCount$ = 28					; size = 4
_nAbilityOption$ = 32					; size = 4
_nItemResist$ = 36					; size = 4
_nResistAbilityOption$ = 40				; size = 4
_chState$ = 44						; size = 1
?RemoveItem@CDbManager@@AAEKPAVCQuery@@PADHPAVCMover@@1HHHHD@Z PROC NEAR ; CDbManager::RemoveItem, COMDAT
; _this$ = ecx

; 1570 : {

  00000	56		 push	 esi

; 1571 : 	SERIALNUMBER iSerialNumber = 0;
; 1572 : 
; 1573 : 	int nIndex = atoi( szItemName );

  00001	8b 74 24 18	 mov	 esi, DWORD PTR _szItemName$[esp]
  00005	57		 push	 edi
  00006	56		 push	 esi
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 _atoi
  0000e	83 c4 04	 add	 esp, 4

; 1574 : 	ItemProp* pItemProp = NULL;
; 1575 : 	if( nIndex > 0 )

  00011	85 c0		 test	 eax, eax
  00013	7e 17		 jle	 SHORT $L209609

; 1576 : 		pItemProp = prj.GetItemProp( nIndex );	

  00015	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  0001b	72 04		 jb	 SHORT $L216768
  0001d	33 c0		 xor	 eax, eax
  0001f	eb 16		 jmp	 SHORT $L216767
$L216768:
  00021	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+64
  00027	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1577 : 	else

  0002a	eb 0b		 jmp	 SHORT $L216767
$L209609:

; 1578 : 		pItemProp = prj.GetItemProp( szItemName );	

  0002c	56		 push	 esi
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00032	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z ; CProject::GetItemProp
$L216767:
  00037	8b f0		 mov	 esi, eax

; 1579 : 
; 1580 : 	if( pItemProp )

  00039	85 f6		 test	 esi, esi
  0003b	0f 84 95 00 00
	00		 je	 $L209611

; 1581 : 	{
; 1582 : 		if( RemoveItemDeleteQuery( pQry, szSql, nNo ) == FALSE )

  00041	8b 54 24 14	 mov	 edx, DWORD PTR _nNo$[esp+4]
  00045	8b 44 24 10	 mov	 eax, DWORD PTR _szSql$[esp+4]
  00049	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pQry$[esp+4]
  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	51		 push	 ecx
  00050	8b cf		 mov	 ecx, edi
  00052	e8 00 00 00 00	 call	 ?RemoveItemDeleteQuery@CDbManager@@AAEHPAVCQuery@@PADH@Z ; CDbManager::RemoveItemDeleteQuery
  00057	85 c0		 test	 eax, eax

; 1583 : 			return 0;

  00059	74 7b		 je	 SHORT $L209611

; 1584 : 
; 1585 : #ifdef __REMOVEITEM_POCKET
; 1586 : 		switch( chState )

  0005b	8a 44 24 30	 mov	 al, BYTE PTR _chState$[esp+4]
  0005f	3c 42		 cmp	 al, 66			; 00000042H
  00061	74 4e		 je	 SHORT $L209618
  00063	3c 49		 cmp	 al, 73			; 00000049H
  00065	74 27		 je	 SHORT $L209617
  00067	3c 50		 cmp	 al, 80			; 00000050H
  00069	75 6b		 jne	 SHORT $L209611

; 1594 : 				break;
; 1595 : 
; 1596 : 			case 'P' :
; 1597 : 				iSerialNumber	= RemoveItemPocket( pItemProp, pMover, nAbilityOption, nItemResist, nResistAbilityOption, nItemCount );

  0006b	8b 54 24 20	 mov	 edx, DWORD PTR _nItemCount$[esp+4]
  0006f	8b 44 24 2c	 mov	 eax, DWORD PTR _nResistAbilityOption$[esp+4]
  00073	8b 4c 24 28	 mov	 ecx, DWORD PTR _nItemResist$[esp+4]
  00077	52		 push	 edx
  00078	8b 54 24 28	 mov	 edx, DWORD PTR _nAbilityOption$[esp+8]
  0007c	50		 push	 eax
  0007d	8b 44 24 20	 mov	 eax, DWORD PTR _pMover$[esp+12]
  00081	51		 push	 ecx
  00082	52		 push	 edx
  00083	50		 push	 eax
  00084	56		 push	 esi
  00085	8b cf		 mov	 ecx, edi
  00087	e8 00 00 00 00	 call	 ?RemoveItemPocket@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ; CDbManager::RemoveItemPocket

; 1598 : 				break;

  0008c	eb 44		 jmp	 SHORT $L209614
$L209617:

; 1587 : 		{
; 1588 : 			case 'I' :
; 1589 : 				iSerialNumber	= RemoveItemInventory( pItemProp, pMover, nAbilityOption, nItemResist, nResistAbilityOption, nItemCount );

  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR _nItemCount$[esp+4]
  00092	8b 54 24 2c	 mov	 edx, DWORD PTR _nResistAbilityOption$[esp+4]
  00096	8b 44 24 28	 mov	 eax, DWORD PTR _nItemResist$[esp+4]
  0009a	51		 push	 ecx
  0009b	8b 4c 24 28	 mov	 ecx, DWORD PTR _nAbilityOption$[esp+8]
  0009f	52		 push	 edx
  000a0	8b 54 24 20	 mov	 edx, DWORD PTR _pMover$[esp+12]
  000a4	50		 push	 eax
  000a5	51		 push	 ecx
  000a6	52		 push	 edx
  000a7	56		 push	 esi
  000a8	8b cf		 mov	 ecx, edi
  000aa	e8 00 00 00 00	 call	 ?RemoveItemInventory@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ; CDbManager::RemoveItemInventory

; 1590 : 				break;

  000af	eb 21		 jmp	 SHORT $L209614
$L209618:

; 1591 : 			
; 1592 : 			case 'B' :
; 1593 : 				iSerialNumber	= RemoveItemBank( pItemProp, pMover, nAbilityOption, nItemResist, nResistAbilityOption, nItemCount );

  000b1	8b 44 24 20	 mov	 eax, DWORD PTR _nItemCount$[esp+4]
  000b5	8b 4c 24 2c	 mov	 ecx, DWORD PTR _nResistAbilityOption$[esp+4]
  000b9	8b 54 24 28	 mov	 edx, DWORD PTR _nItemResist$[esp+4]
  000bd	50		 push	 eax
  000be	8b 44 24 28	 mov	 eax, DWORD PTR _nAbilityOption$[esp+8]
  000c2	51		 push	 ecx
  000c3	8b 4c 24 20	 mov	 ecx, DWORD PTR _pMover$[esp+12]
  000c7	52		 push	 edx
  000c8	50		 push	 eax
  000c9	51		 push	 ecx
  000ca	56		 push	 esi
  000cb	8b cf		 mov	 ecx, edi
  000cd	e8 00 00 00 00	 call	 ?RemoveItemBank@CDbManager@@AAEKPAUItemProp@@PAVCMover@@HHHH@Z ; CDbManager::RemoveItemBank
$L209614:

; 1599 : 		}
; 1600 : #else // __REMOVEITEM_POCKET
; 1601 : 		if( chState == 'I' )
; 1602 : 		{
; 1603 : 			iSerialNumber	= RemoveItemInventory( pItemProp, pMover, nAbilityOption, nItemResist, nResistAbilityOption, nItemCount );
; 1604 : 		}
; 1605 : 		else
; 1606 : 		{
; 1607 : 			iSerialNumber	= RemoveItemBank( pItemProp, pMover, nAbilityOption, nItemResist, nResistAbilityOption, nItemCount );
; 1608 : 		}
; 1609 : #endif // __REMOVEITEM_POCKET
; 1610 : 
; 1611 : 		
; 1612 : 		if( iSerialNumber == 0 )

  000d2	85 c0		 test	 eax, eax

; 1613 : 			return 0;
; 1614 : 		else
; 1615 : 			return iSerialNumber;

  000d4	75 02		 jne	 SHORT $L209605
$L209611:

; 1616 : 	}
; 1617 : 	else
; 1618 : 	{	// no propItem		
; 1619 : 		return 0;

  000d6	33 c0		 xor	 eax, eax
$L209605:
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi

; 1620 : 	}
; 1621 : 	return 0;
; 1622 : }

  000da	c2 28 00	 ret	 40			; 00000028H
?RemoveItem@CDbManager@@AAEKPAVCQuery@@PADHPAVCMover@@1HHHHD@Z ENDP ; CDbManager::RemoveItem
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L210408

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L210408:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00021	76 07		 jbe	 SHORT $L210410

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$L210410:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L216796:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogty
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT
__Newvec$210630 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L216810
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L216811
$L216810:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L216811:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L210650

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L216833
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L216834
$L216833:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L216834:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L210626

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$L210626:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L216840
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L216841
$L216840:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L216841:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L210628

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L216799
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L216800
$L216799:
  0007f	03 c1		 add	 eax, ecx
$L216800:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L216863
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L216864
$L216863:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L216864:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L210629

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L216870
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L216871
$L216870:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L216871:
  000a7	03 c7		 add	 eax, edi
$L210629:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$210630[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L216952
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L216953
$L216952:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L216953:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L216955

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L216955:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$210630[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L210628:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L210641
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L210641:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::copy_backward<int *,int *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L210650:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L216963:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?Add@CBuffMgr@@QAE_NPAVIBuff@@@Z		; CBuffMgr::Add
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\buff.h
;	COMDAT ?Add@CBuffMgr@@QAE_NPAVIBuff@@@Z
_TEXT	SEGMENT
$T216966 = -16						; size = 8
$T216968 = -8						; size = 8
_pBuff$ = 8						; size = 4
?Add@CBuffMgr@@QAE_NPAVIBuff@@@Z PROC NEAR		; CBuffMgr::Add, COMDAT
; _this$ = ecx

; 212  : 	bool	Add( IBuff* pBuff )	{	return m_mapBuffs.insert( MAPBUFF::value_type( MAKELONG( pBuff->GetId(), pBuff->GetType() ), pBuff ) ).second;	}

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	8b 44 24 14	 mov	 eax, DWORD PTR _pBuff$[esp+12]
  00007	0f b7 50 04	 movzx	 edx, WORD PTR [eax+4]
  0000b	56		 push	 esi
  0000c	0f b7 70 06	 movzx	 esi, WORD PTR [eax+6]
  00010	c1 e2 10	 shl	 edx, 16			; 00000010H
  00013	0b d6		 or	 edx, esi
  00015	89 44 24 08	 mov	 DWORD PTR $T216966[esp+24], eax
  00019	8d 44 24 04	 lea	 eax, DWORD PTR $T216966[esp+20]
  0001d	89 54 24 04	 mov	 DWORD PTR $T216966[esp+20], edx
  00021	50		 push	 eax
  00022	8d 54 24 10	 lea	 edx, DWORD PTR $T216968[esp+24]
  00026	52		 push	 edx
  00027	83 c1 04	 add	 ecx, 4
  0002a	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::insert
  0002f	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00032	5e		 pop	 esi
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	c2 04 00	 ret	 4
?Add@CBuffMgr@@QAE_NPAVIBuff@@@Z ENDP			; CBuffMgr::Add
_TEXT	ENDS
PUBLIC	?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ; std::vector<long,std::allocator<long> >::resize
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::resize, COMDAT
; _this$ = ecx

; 507  : 		{	// determine new length, padding with _Val elements as needed

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 508  : 		if (size() < _Newsize)

  00003	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00006	85 d2		 test	 edx, edx
  00008	57		 push	 edi
  00009	75 04		 jne	 SHORT $L216992
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 08		 jmp	 SHORT $L216993
$L216992:
  0000f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00012	2b c2		 sub	 eax, edx
  00014	c1 f8 02	 sar	 eax, 2
$L216993:
  00017	8b 7c 24 0c	 mov	 edi, DWORD PTR __Newsize$[esp+4]
  0001b	3b c7		 cmp	 eax, edi
  0001d	73 28		 jae	 SHORT $L183962

; 509  : 			_Insert_n(end(), _Newsize - size(), _Val);

  0001f	85 d2		 test	 edx, edx
  00021	75 04		 jne	 SHORT $L216999
  00023	33 c0		 xor	 eax, eax
  00025	eb 08		 jmp	 SHORT $L217000
$L216999:
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	2b c2		 sub	 eax, edx
  0002c	c1 f8 02	 sar	 eax, 2
$L217000:
  0002f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00032	8d 54 24 10	 lea	 edx, DWORD PTR __Val$[esp+4]
  00036	52		 push	 edx
  00037	2b f8		 sub	 edi, eax
  00039	57		 push	 edi
  0003a	51		 push	 ecx
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z ; std::vector<long,std::allocator<long> >::_Insert_n
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 512  : 		}

  00044	c2 08 00	 ret	 8
$L183962:

; 510  : 		else if (_Newsize < size())

  00047	85 d2		 test	 edx, edx
  00049	74 33		 je	 SHORT $L217102
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	8b c8		 mov	 ecx, eax
  00050	2b ca		 sub	 ecx, edx
  00052	c1 f9 02	 sar	 ecx, 2
  00055	3b f9		 cmp	 edi, ecx
  00057	73 25		 jae	 SHORT $L217102

; 511  : 			erase(begin() + _Newsize, end());

  00059	8d 14 ba	 lea	 edx, DWORD PTR [edx+edi*4]
  0005c	3b d0		 cmp	 edx, eax
  0005e	74 1e		 je	 SHORT $L217102
  00060	8b c8		 mov	 ecx, eax
  00062	2b c8		 sub	 ecx, eax
  00064	c1 f9 02	 sar	 ecx, 2
  00067	8d 3c 8d 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*4]
  0006e	57		 push	 edi
  0006f	50		 push	 eax
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _memmove
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	03 c7		 add	 eax, edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L217102:
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 512  : 		}

  00080	c2 08 00	 ret	 8
?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ENDP ; std::vector<long,std::allocator<long> >::resize
_TEXT	ENDS
PUBLIC	?GetSKillInfluence@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetSKillInfluence
PUBLIC	??_C@_0P@KFJOMEEC@SkillInfluence?$AA@		; `string'
EXTRN	?SetTotal@IBuff@@QAEXK@Z:NEAR			; IBuff::SetTotal
;	COMDAT ??_C@_0P@KFJOMEEC@SkillInfluence?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
CONST	SEGMENT
??_C@_0P@KFJOMEEC@SkillInfluence?$AA@ DB 'SkillInfluence', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetSKillInfluence@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_CountStr$ = -7540					; size = 4
$T217154 = -7536					; size = 4
_dwLevel$209497 = -7536					; size = 4
_tmTotal$209499 = -7532					; size = 4
$T217140 = -7528					; size = 8
$T217142 = -7520					; size = 8
_szSKillInfluence$ = -7512				; size = 7500
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetSKillInfluence@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetSKillInfluence, COMDAT
; _this$ = ecx

; 1384 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 74 1d 00 00	 mov	 eax, 7540		; 00001d74H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	8b 55 0c	 mov	 edx, DWORD PTR _qry$[ebp]
  00018	33 c5		 xor	 eax, ebp
  0001a	53		 push	 ebx
  0001b	8b 5d 08	 mov	 ebx, DWORD PTR _pMover$[ebp]
  0001e	89 84 24 74 1d
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+7544], eax
  00025	8b 45 10	 mov	 eax, DWORD PTR _lpDbOverlappedPlus$[ebp]
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 44 24 10	 mov	 DWORD PTR $T217154[esp+7552], eax

; 1385 : 	int CountStr	= 0;
; 1386 : 	int iSkillIndex = 0;
; 1387 : 	char szSKillInfluence[7500]		= {0,};

  00030	c6 44 24 28 00	 mov	 BYTE PTR _szSKillInfluence$[esp+7552], 0
  00035	33 c0		 xor	 eax, eax
  00037	b9 52 07 00 00	 mov	 ecx, 1874		; 00000752H
  0003c	8d 7c 24 29	 lea	 edi, DWORD PTR _szSKillInfluence$[esp+7553]
  00040	f3 ab		 rep stosd

; 1388 : 	qry->GetStr( "SkillInfluence", szSKillInfluence );

  00042	8d 4c 24 28	 lea	 ecx, DWORD PTR _szSKillInfluence$[esp+7552]
  00046	66 ab		 stosw
  00048	51		 push	 ecx
  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KFJOMEEC@SkillInfluence?$AA@
  0004e	8b ca		 mov	 ecx, edx
  00050	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+7560], 0
  00058	aa		 stosb
  00059	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 1389 : 	VERIFYSTRING_RETURN( szSKillInfluence, pMover->m_szName );

  0005e	8b 54 24 10	 mov	 edx, DWORD PTR $T217154[esp+7552]
  00062	52		 push	 edx
  00063	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00066	50		 push	 eax
  00067	68 6d 05 00 00	 push	 1389			; 0000056dH
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00071	8d 4c 24 38	 lea	 ecx, DWORD PTR _szSKillInfluence$[esp+7568]
  00075	51		 push	 ecx
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  0007d	85 c0		 test	 eax, eax
  0007f	75 17		 jne	 SHORT $L217155

; 1406 : 		ASSERT( bResult );
; 1407 : #else	// __BUFF_1107
; 1408 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].wType = (WORD)GetIntFromStr( szSKillInfluence, &CountStr );
; 1409 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].wID = (WORD)GetIntFromStr( szSKillInfluence, &CountStr );
; 1410 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].dwLevel = (DWORD)GetIntFromStr( szSKillInfluence, &CountStr );
; 1411 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].tmCount = GetIntFromStr( szSKillInfluence, &CountStr );
; 1412 : #if __VER >= 13 // __HOUSING
; 1413 : 		SKILLINFLUENCE* pSkillInfluenece = &pMover->m_SkillState.m_aSkillInfluence[iSkillIndex];
; 1414 : 		if( pSkillInfluenece->wType == 0 && pSkillInfluenece->wID == 0
; 1415 : 			&& pSkillInfluenece->dwLevel == 0 && pSkillInfluenece->tmCount == 0 )
; 1416 : 			break;
; 1417 : #endif // __HOUSING
; 1418 : #endif	// __BUFF_1107
; 1419 : 		
; 1420 : 		++iSkillIndex;
; 1421 : 	}
; 1422 : 	return TRUE;
; 1423 : }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b 8c 24 70 1d
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+7540]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$L217155:

; 1390 : 	while( '$' != szSKillInfluence[CountStr] )

  00098	80 7c 24 28 24	 cmp	 BYTE PTR _szSKillInfluence$[esp+7552], 36 ; 00000024H
  0009d	0f 84 c3 00 00
	00		 je	 $L217156
$L209491:

; 1391 : 	{
; 1392 : #ifdef __BUFF_1107
; 1393 : 		WORD wType	= (WORD)GetIntFromStr( szSKillInfluence, &CountStr );

  000a3	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+7552]
  000a7	52		 push	 edx
  000a8	8d 44 24 2c	 lea	 eax, DWORD PTR _szSKillInfluence$[esp+7556]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 1394 : 		WORD wId	= (WORD)GetIntFromStr( szSKillInfluence, &CountStr );

  000b2	8d 4c 24 14	 lea	 ecx, DWORD PTR _CountStr$[esp+7560]
  000b6	51		 push	 ecx
  000b7	8d 54 24 34	 lea	 edx, DWORD PTR _szSKillInfluence$[esp+7564]
  000bb	52		 push	 edx
  000bc	8b f0		 mov	 esi, eax
  000be	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  000c3	8b f8		 mov	 edi, eax

; 1395 : 		DWORD dwLevel	= (DWORD)GetIntFromStr( szSKillInfluence, &CountStr );

  000c5	8d 44 24 1c	 lea	 eax, DWORD PTR _CountStr$[esp+7568]
  000c9	50		 push	 eax
  000ca	8d 4c 24 3c	 lea	 ecx, DWORD PTR _szSKillInfluence$[esp+7572]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 1396 : 		DWORD tmTotal	= GetIntFromStr( szSKillInfluence, &CountStr );

  000d4	8d 54 24 24	 lea	 edx, DWORD PTR _CountStr$[esp+7576]
  000d8	89 44 24 28	 mov	 DWORD PTR _dwLevel$209497[esp+7576], eax
  000dc	52		 push	 edx
  000dd	8d 44 24 44	 lea	 eax, DWORD PTR _szSKillInfluence$[esp+7580]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  000e7	83 c4 20	 add	 esp, 32			; 00000020H

; 1397 : #if __VER >= 13 // __HOUSING
; 1398 : 		if( wType == 0 && wId == 0 && dwLevel == 0 && tmTotal == 0 )

  000ea	66 85 f6	 test	 si, si
  000ed	89 44 24 14	 mov	 DWORD PTR _tmTotal$209499[esp+7552], eax
  000f1	75 11		 jne	 SHORT $L209500
  000f3	66 85 ff	 test	 di, di
  000f6	75 0c		 jne	 SHORT $L209500
  000f8	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwLevel$209497[esp+7552]
  000fc	85 c9		 test	 ecx, ecx
  000fe	75 04		 jne	 SHORT $L209500
  00100	85 c0		 test	 eax, eax
  00102	74 62		 je	 SHORT $L217156
$L209500:

; 1399 : 			break;
; 1400 : #endif // __HOUSING
; 1401 : 		IBuff* pBuff	= pMover->m_buffs.CreateBuff( wType );

  00104	8b 93 10 45 00
	00		 mov	 edx, DWORD PTR [ebx+17680]
  0010a	8d 8b 10 45 00
	00		 lea	 ecx, DWORD PTR [ebx+17680]
  00110	56		 push	 esi
  00111	ff 52 04	 call	 DWORD PTR [edx+4]

; 1402 : 		pBuff->SetId( wId );
; 1403 : 		pBuff->SetLevel( dwLevel );
; 1404 : 		pBuff->SetTotal( tmTotal );

  00114	8b 4c 24 14	 mov	 ecx, DWORD PTR _tmTotal$209499[esp+7552]
  00118	8b f0		 mov	 esi, eax
  0011a	8b 44 24 10	 mov	 eax, DWORD PTR _dwLevel$209497[esp+7552]
  0011e	51		 push	 ecx
  0011f	8b ce		 mov	 ecx, esi
  00121	66 89 7e 06	 mov	 WORD PTR [esi+6], di
  00125	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00128	e8 00 00 00 00	 call	 ?SetTotal@IBuff@@QAEXK@Z ; IBuff::SetTotal

; 1405 : 		bool bResult	= pMover->m_buffs.Add( pBuff );

  0012d	0f b7 56 04	 movzx	 edx, WORD PTR [esi+4]
  00131	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  00135	c1 e2 10	 shl	 edx, 16			; 00000010H
  00138	0b d0		 or	 edx, eax
  0013a	8d 4c 24 18	 lea	 ecx, DWORD PTR $T217140[esp+7552]
  0013e	89 54 24 18	 mov	 DWORD PTR $T217140[esp+7552], edx
  00142	51		 push	 ecx
  00143	8d 54 24 24	 lea	 edx, DWORD PTR $T217142[esp+7556]
  00147	52		 push	 edx
  00148	8d 8b 14 45 00
	00		 lea	 ecx, DWORD PTR [ebx+17684]
  0014e	89 74 24 24	 mov	 DWORD PTR $T217140[esp+7564], esi
  00152	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVIBuff@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::insert
  00157	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+7552]
  0015b	80 7c 04 28 24	 cmp	 BYTE PTR _szSKillInfluence$[esp+eax+7552], 36 ; 00000024H
  00160	0f 85 3d ff ff
	ff		 jne	 $L209491
$L217156:

; 1406 : 		ASSERT( bResult );
; 1407 : #else	// __BUFF_1107
; 1408 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].wType = (WORD)GetIntFromStr( szSKillInfluence, &CountStr );
; 1409 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].wID = (WORD)GetIntFromStr( szSKillInfluence, &CountStr );
; 1410 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].dwLevel = (DWORD)GetIntFromStr( szSKillInfluence, &CountStr );
; 1411 : 		pMover->m_SkillState.m_aSkillInfluence[iSkillIndex].tmCount = GetIntFromStr( szSKillInfluence, &CountStr );
; 1412 : #if __VER >= 13 // __HOUSING
; 1413 : 		SKILLINFLUENCE* pSkillInfluenece = &pMover->m_SkillState.m_aSkillInfluence[iSkillIndex];
; 1414 : 		if( pSkillInfluenece->wType == 0 && pSkillInfluenece->wID == 0
; 1415 : 			&& pSkillInfluenece->dwLevel == 0 && pSkillInfluenece->tmCount == 0 )
; 1416 : 			break;
; 1417 : #endif // __HOUSING
; 1418 : #endif	// __BUFF_1107
; 1419 : 		
; 1420 : 		++iSkillIndex;
; 1421 : 	}
; 1422 : 	return TRUE;
; 1423 : }

  00166	8b 8c 24 7c 1d
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+7552]
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	33 cd		 xor	 ecx, ebp
  00171	b8 01 00 00 00	 mov	 eax, 1
  00176	5b		 pop	 ebx
  00177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c2 0c 00	 ret	 12			; 0000000cH
?GetSKillInfluence@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetSKillInfluence
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L217282
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 02	 sar	 eax, 2
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L217221
$L217282:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L217222
$L217221:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 02	 sar	 esi, 2
$L217222:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?SetVisKeepTimeSize@CPiercing@@QAEXH@Z		; CPiercing::SetVisKeepTimeSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\piercing.h
;	COMDAT ?SetVisKeepTimeSize@CPiercing@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetVisKeepTimeSize@CPiercing@@QAEXH@Z PROC NEAR	; CPiercing::SetVisKeepTimeSize, COMDAT
; _this$ = ecx

; 40   : 	void	SetVisKeepTimeSize( int nSize )	{ m_vtmPetVis.resize( min( nSize, MAX_VIS ), 0 ); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nSize$[esp-4]
  00004	83 f8 09	 cmp	 eax, 9
  00007	7c 05		 jl	 SHORT $L217286
  00009	b8 09 00 00 00	 mov	 eax, 9
$L217286:
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	83 c1 24	 add	 ecx, 36			; 00000024H
  00014	e8 00 00 00 00	 call	 ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ; std::vector<long,std::allocator<long> >::resize
  00019	c2 04 00	 ret	 4
?SetVisKeepTimeSize@CPiercing@@QAEXH@Z ENDP		; CPiercing::SetVisKeepTimeSize
_TEXT	ENDS
PUBLIC	?SetVisKeepTimeSize@CItemElem@@QAEXH@Z		; CItemElem::SetVisKeepTimeSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?SetVisKeepTimeSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetVisKeepTimeSize@CItemElem@@QAEXH@Z PROC NEAR	; CItemElem::SetVisKeepTimeSize, COMDAT
; _this$ = ecx

; 237  : 	void	SetVisKeepTimeSize( int nSize )				{ m_piercing.SetVisKeepTimeSize( nSize ); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nSize$[esp-4]
  00004	83 f8 09	 cmp	 eax, 9
  00007	7c 05		 jl	 SHORT $L217294
  00009	b8 09 00 00 00	 mov	 eax, 9
$L217294:
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	83 c1 58	 add	 ecx, 88			; 00000058H
  00014	e8 00 00 00 00	 call	 ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ; std::vector<long,std::allocator<long> >::resize
  00019	c2 04 00	 ret	 4
?SetVisKeepTimeSize@CItemElem@@QAEXH@Z ENDP		; CItemElem::SetVisKeepTimeSize
_TEXT	ENDS
PUBLIC	?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z ; CDbManager::LoadPiercingInfo
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
;	COMDAT ?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z
_TEXT	SEGMENT
_itemElem$ = 8						; size = 4
_szPirecingInven$ = 12					; size = 4
_pLocation$ = 16					; size = 4
?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z PROC NEAR ; CDbManager::LoadPiercingInfo, COMDAT
; _this$ = ecx

; 893  : 	ItemProp* itemProp = itemElem.GetProp();

  00000	8b 0d 50 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+80
  00006	53		 push	 ebx
  00007	8b 5c 24 10	 mov	 ebx, DWORD PTR _pLocation$[esp]
  0000b	55		 push	 ebp
  0000c	8b 6c 24 10	 mov	 ebp, DWORD PTR _szPirecingInven$[esp+4]
  00010	56		 push	 esi
  00011	8b 74 24 10	 mov	 esi, DWORD PTR _itemElem$[esp+8]
  00015	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00018	3b c1		 cmp	 eax, ecx
  0001a	57		 push	 edi
  0001b	73 64		 jae	 SHORT $L217541
  0001d	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+64
  00023	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 894  : 	if( itemProp && itemProp->IsUltimate() )

  00026	85 c0		 test	 eax, eax
  00028	74 57		 je	 SHORT $L217541
  0002a	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0002d	83 f9 02	 cmp	 ecx, 2
  00030	74 05		 je	 SHORT $L217324
  00032	83 f9 03	 cmp	 ecx, 3
  00035	75 4a		 jne	 SHORT $L217541
$L217324:
  00037	83 b8 00 02 00
	00 02		 cmp	 DWORD PTR [eax+512], 2
  0003e	75 41		 jne	 SHORT $L217541

; 895  : 	{
; 896  : 		itemElem.SetUltimatePiercingSize( GetIntPaFromStr( szPirecingInven, pLocation ) );

  00040	53		 push	 ebx
  00041	55		 push	 ebp
  00042	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00047	83 c4 08	 add	 esp, 8
  0004a	83 c6 34	 add	 esi, 52			; 00000034H
  0004d	50		 push	 eax
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?SetUltimatePiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetUltimatePiercingSize

; 897  : 		for( int i = 0 ; i < itemElem.GetUltimatePiercingSize(); ++i )

  00055	8b ce		 mov	 ecx, esi
  00057	33 ff		 xor	 edi, edi
  00059	e8 00 00 00 00	 call	 ?GetUltimatePiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetUltimatePiercingSize
  0005e	85 c0		 test	 eax, eax
  00060	7e 1f		 jle	 SHORT $L217541
$L209088:

; 898  : 			itemElem.SetUltimatePiercingItem( i, (DWORD)GetIntPaFromStr( szPirecingInven, pLocation ) );

  00062	53		 push	 ebx
  00063	55		 push	 ebp
  00064	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00069	83 c4 08	 add	 esp, 8
  0006c	50		 push	 eax
  0006d	57		 push	 edi
  0006e	8b ce		 mov	 ecx, esi
  00070	e8 00 00 00 00	 call	 ?SetUltimatePiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetUltimatePiercingItem
  00075	8b ce		 mov	 ecx, esi
  00077	47		 inc	 edi
  00078	e8 00 00 00 00	 call	 ?GetUltimatePiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetUltimatePiercingSize
  0007d	3b f8		 cmp	 edi, eax
  0007f	7c e1		 jl	 SHORT $L209088
$L217541:

; 899  : 	}
; 900  : 	itemElem.SetPiercingSize( GetIntFromStr( szPirecingInven, pLocation ) );

  00081	53		 push	 ebx
  00082	55		 push	 ebp
  00083	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00088	8b 74 24 1c	 mov	 esi, DWORD PTR _itemElem$[esp+20]
  0008c	83 c4 08	 add	 esp, 8
  0008f	83 c6 34	 add	 esi, 52			; 00000034H
  00092	50		 push	 eax
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?SetPiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetPiercingSize

; 901  : 	for( int i = 0 ; i < itemElem.GetPiercingSize(); ++i )

  0009a	8b ce		 mov	 ecx, esi
  0009c	33 ff		 xor	 edi, edi
  0009e	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000a3	85 c0		 test	 eax, eax
  000a5	7e 1f		 jle	 SHORT $L209095
$L209093:

; 902  : 		itemElem.SetPiercingItem( i, (DWORD)GetIntFromStr( szPirecingInven, pLocation ) );

  000a7	53		 push	 ebx
  000a8	55		 push	 ebp
  000a9	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  000ae	83 c4 08	 add	 esp, 8
  000b1	50		 push	 eax
  000b2	57		 push	 edi
  000b3	8b ce		 mov	 ecx, esi
  000b5	e8 00 00 00 00	 call	 ?SetPiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetPiercingItem
  000ba	8b ce		 mov	 ecx, esi
  000bc	47		 inc	 edi
  000bd	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000c2	3b f8		 cmp	 edi, eax
  000c4	7c e1		 jl	 SHORT $L209093
$L209095:

; 903  : #if __VER >= 15 // __PETVIS
; 904  : 	if( itemElem.IsVisPet() )

  000c6	8b 54 24 14	 mov	 edx, DWORD PTR _itemElem$[esp+12]
  000ca	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000cd	8b 3d 50 00 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+80
  000d3	3b c7		 cmp	 eax, edi
  000d5	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+64
  000db	0f 83 95 00 00
	00		 jae	 $L209100
  000e1	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  000e5	74 1a		 je	 SHORT $L217543
  000e7	3b c7		 cmp	 eax, edi
  000e9	72 04		 jb	 SHORT $L217482
  000eb	33 d2		 xor	 edx, edx
  000ed	eb 03		 jmp	 SHORT $L217481
$L217482:
  000ef	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
$L217481:
  000f2	83 7a 78 64	 cmp	 DWORD PTR [edx+120], 100 ; 00000064H
  000f6	75 09		 jne	 SHORT $L217543
  000f8	83 ba 00 02 00
	00 01		 cmp	 DWORD PTR [edx+512], 1
  000ff	74 29		 je	 SHORT $L217468
$L217543:
  00101	3b c7		 cmp	 eax, edi
  00103	73 71		 jae	 SHORT $L209100
  00105	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00109	74 6b		 je	 SHORT $L209100
  0010b	3b c7		 cmp	 eax, edi
  0010d	72 04		 jb	 SHORT $L217503
  0010f	33 c0		 xor	 eax, eax
  00111	eb 03		 jmp	 SHORT $L217502
$L217503:
  00113	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
$L217502:
  00116	83 78 78 64	 cmp	 DWORD PTR [eax+120], 100 ; 00000064H
  0011a	75 5a		 jne	 SHORT $L209100
  0011c	8b 44 24 14	 mov	 eax, DWORD PTR _itemElem$[esp+12]
  00120	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  00126	85 c9		 test	 ecx, ecx
  00128	74 4c		 je	 SHORT $L209100
$L217468:

; 905  : 	{
; 906  : 		itemElem.SetVisKeepTimeSize( itemElem.GetPiercingSize() );

  0012a	8b ce		 mov	 ecx, esi
  0012c	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00131	83 f8 09	 cmp	 eax, 9
  00134	7c 05		 jl	 SHORT $L217521
  00136	b8 09 00 00 00	 mov	 eax, 9
$L217521:
  0013b	8b 4c 24 14	 mov	 ecx, DWORD PTR _itemElem$[esp+12]
  0013f	6a 00		 push	 0
  00141	50		 push	 eax
  00142	83 c1 58	 add	 ecx, 88			; 00000058H
  00145	e8 00 00 00 00	 call	 ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ; std::vector<long,std::allocator<long> >::resize

; 907  : 		for( i=0; i<itemElem.GetPiercingSize(); i++ )

  0014a	8b ce		 mov	 ecx, esi
  0014c	33 ff		 xor	 edi, edi
  0014e	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00153	85 c0		 test	 eax, eax
  00155	7e 1f		 jle	 SHORT $L209100
$L209098:

; 908  : 			itemElem.SetVisKeepTime( i, (time_t)GetIntFromStr( szPirecingInven, pLocation ) );

  00157	53		 push	 ebx
  00158	55		 push	 ebp
  00159	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0015e	83 c4 08	 add	 esp, 8
  00161	50		 push	 eax
  00162	57		 push	 edi
  00163	8b ce		 mov	 ecx, esi
  00165	e8 00 00 00 00	 call	 ?SetVisKeepTime@CPiercing@@QAEXHJ@Z ; CPiercing::SetVisKeepTime
  0016a	8b ce		 mov	 ecx, esi
  0016c	47		 inc	 edi
  0016d	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00172	3b f8		 cmp	 edi, eax
  00174	7c e1		 jl	 SHORT $L209098
$L209100:
  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	5d		 pop	 ebp
  00179	5b		 pop	 ebx

; 909  : 	}
; 910  : #endif // __PETVIS
; 911  : }

  0017a	c2 0c 00	 ret	 12			; 0000000cH
?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z ENDP ; CDbManager::LoadPiercingInfo
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi

; 580  : 		if (size() < capacity())

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	75 04		 jne	 SHORT $L217555
  00008	33 d2		 xor	 edx, edx
  0000a	eb 08		 jmp	 SHORT $L217556
$L217555:
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	2b d6		 sub	 edx, esi
  00011	c1 fa 02	 sar	 edx, 2
$L217556:
  00014	85 f6		 test	 esi, esi
  00016	74 21		 je	 SHORT $L210100
  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	2b c6		 sub	 eax, esi
  0001d	c1 f8 02	 sar	 eax, 2
  00020	3b d0		 cmp	 edx, eax
  00022	73 15		 jae	 SHORT $L210100

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0002b	8b 12		 mov	 edx, DWORD PTR [edx]
  0002d	89 10		 mov	 DWORD PTR [eax], edx
  0002f	83 c0 04	 add	 eax, 4
  00032	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00035	5e		 pop	 esi

; 584  : 		}

  00036	c2 04 00	 ret	 4
$L210100:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00039	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0003d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00040	52		 push	 edx
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
  00049	5e		 pop	 esi

; 584  : 		}

  0004a	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??_C@_0L@FONFFEJF@m_idPlayer?$AA@		; `string'
PUBLIC	??_C@_0N@KIBMFHG@m_dwGoldBank?$AA@		; `string'
PUBLIC	??_C@_06BAMDHIIP@m_Bank?$AA@			; `string'
PUBLIC	??_C@_0P@KMLFLAAK@m_apIndex_Bank?$AA@		; `string'
PUBLIC	??_C@_0BC@HHMCMCCB@m_dwObjIndex_Bank?$AA@	; `string'
PUBLIC	??_C@_09CHFBCGKD@m_extBank?$AA@			; `string'
PUBLIC	??_C@_0P@HANLGJJC@m_BankPiercing?$AA@		; `string'
PUBLIC	??_C@_09DAKBPAHF@szBankPet?$AA@			; `string'
PUBLIC	??_C@_0CM@JMMGLGKB@Join?3?3Bank?5?3?5?$DM?$DM?5Not?5Prop?4?5?$CFd?0?5?$CFd@ ; `string'
PUBLIC	??_C@_0CG@GPGFAEMD@Join?3?3Bank?5?3?5?$DM?$DM?5MAX_BANK?5?$CFd?6Bank@ ; `string'
PUBLIC	?GetBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@H@Z ; CDbManager::GetBank
EXTRN	??0CItemElem@@QAE@XZ:NEAR			; CItemElem::CItemElem
EXTRN	??1CItemElem@@UAE@XZ:NEAR			; CItemElem::~CItemElem
EXTRN	??0CPet@@QAE@XZ:NEAR				; CPet::CPet
EXTRN	?SetAvailLevel@CPet@@QAEXEE@Z:NEAR		; CPet::SetAvailLevel
EXTRN	?SetExp@CPet@@QAEXK@Z:NEAR			; CPet::SetExp
EXTRN	?SetEnergy@CPet@@QAEXG@Z:NEAR			; CPet::SetEnergy
EXTRN	?SetName@CPet@@QAEXPBD@Z:NEAR			; CPet::SetName
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
xdata$x	SEGMENT
$T217789 DD	0ffffffffH
	DD	FLAT:$L217743
	DD	0ffffffffH
	DD	FLAT:$L217744
$T217767 DD	019930520H
	DD	02H
	DD	FLAT:$T217789
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0L@FONFFEJF@m_idPlayer?$AA@
CONST	SEGMENT
??_C@_0L@FONFFEJF@m_idPlayer?$AA@ DB 'm_idPlayer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KIBMFHG@m_dwGoldBank?$AA@
CONST	SEGMENT
??_C@_0N@KIBMFHG@m_dwGoldBank?$AA@ DB 'm_dwGoldBank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAMDHIIP@m_Bank?$AA@
CONST	SEGMENT
??_C@_06BAMDHIIP@m_Bank?$AA@ DB 'm_Bank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KMLFLAAK@m_apIndex_Bank?$AA@
CONST	SEGMENT
??_C@_0P@KMLFLAAK@m_apIndex_Bank?$AA@ DB 'm_apIndex_Bank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HHMCMCCB@m_dwObjIndex_Bank?$AA@
CONST	SEGMENT
??_C@_0BC@HHMCMCCB@m_dwObjIndex_Bank?$AA@ DB 'm_dwObjIndex_Bank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CHFBCGKD@m_extBank?$AA@
CONST	SEGMENT
??_C@_09CHFBCGKD@m_extBank?$AA@ DB 'm_extBank', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HANLGJJC@m_BankPiercing?$AA@
CONST	SEGMENT
??_C@_0P@HANLGJJC@m_BankPiercing?$AA@ DB 'm_BankPiercing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAKBPAHF@szBankPet?$AA@
CONST	SEGMENT
??_C@_09DAKBPAHF@szBankPet?$AA@ DB 'szBankPet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JMMGLGKB@Join?3?3Bank?5?3?5?$DM?$DM?5Not?5Prop?4?5?$CFd?0?5?$CFd@
CONST	SEGMENT
??_C@_0CM@JMMGLGKB@Join?3?3Bank?5?3?5?$DM?$DM?5Not?5Prop?4?5?$CFd?0?5?$CFd@ DB 'J'
	DB	'oin::Bank : << Not Prop. %d, %d ', 0aH, 'Bank = %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPGFAEMD@Join?3?3Bank?5?3?5?$DM?$DM?5MAX_BANK?5?$CFd?6Bank@
CONST	SEGMENT
??_C@_0CG@GPGFAEMD@Join?3?3Bank?5?3?5?$DM?$DM?5MAX_BANK?5?$CFd?6Bank@ DB 'J'
	DB	'oin::Bank : << MAX_BANK %d', 0aH, 'Bank = %s', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@H@Z
_TEXT	SEGMENT
_dwGold$ = -18988					; size = 4
_CountStr$ = -18988					; size = 4
tv831 = -18984						; size = 4
$T217740 = -18984					; size = 4
_uPlayerid$ = -18984					; size = 4
tv616 = -18980						; size = 4
tv599 = -18980						; size = 4
_nAvailLevel$208719 = -18980				; size = 1
$T217762 = -18976					; size = 4
$T217763 = -18972					; size = 4
_BufItemElem$208662 = -18968				; size = 160
_szName$208722 = -18808					; size = 17
_szFmt$208721 = -18788					; size = 33
_m_apIndexBank$ = -18752				; size = 512
_ObjIndexBank$ = -18240					; size = 512
_ExtBank$ = -17728					; size = 2000
_szPet$ = -15728					; size = 4200
_PirecingBank$ = -11528					; size = 4000
_Bank$ = -7528						; size = 7500
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
_nSlot$ = 20						; size = 4
?GetBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@H@Z PROC NEAR ; CDbManager::GetBank, COMDAT
; _this$ = ecx

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GetBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@H@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	51		 push	 ecx
  0001c	b8 1c 4a 00 00	 mov	 eax, 18972		; 00004a1cH
  00021	e8 00 00 00 00	 call	 __chkstk
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 84 24 18 4a
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+18988], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR _pMover$[ebp]

; 167  : 	int CountStr				= 0;
; 168  : 	int itemCount				= 0;
; 169  : 	int	IndexItem				= 0;
; 170  : 	int IndexObjIndex			= 0;
; 171  : 	int nExtBankCount			= 0;
; 172  : 	int nPirecingBankCount		= 0;
; 173  : 	char Bank[7500]				= { 0, };
; 174  : 	char m_apIndexBank[512]		= { 0, };
; 175  : 	char ObjIndexBank[512]		= { 0, };
; 176  : 	char ExtBank[2000]			= {0,};	
; 177  : 	char PirecingBank[4000]		= {0,};
; 178  : #ifdef __PET_1024
; 179  : 	char szPet[4200]	= { 0,};
; 180  : #else	// __PET_1024
; 181  : 	char szPet[2688]	= { 0,};
; 182  : #endif	// __PET_1024
; 183  : 
; 184  : 	u_long uPlayerid	= (u_long)qry->GetInt( "m_idPlayer" );
; 185  : 	DWORD dwGold = qry->GetInt( "m_dwGoldBank" );
; 186  : 
; 187  : 	qry->GetStr( "m_Bank", Bank );
; 188  : 	qry->GetStr( "m_apIndex_Bank", m_apIndexBank );
; 189  : 	qry->GetStr( "m_dwObjIndex_Bank", ObjIndexBank );
; 190  : 	qry->GetStr( "m_extBank", ExtBank );
; 191  : 	qry->GetStr( "m_BankPiercing", PirecingBank );
; 192  : 	qry->GetStr( "szBankPet", szPet );
; 193  : 
; 194  : 	VERIFYSTRING_RETURN( Bank, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 195  : 	VERIFYSTRING_RETURN( m_apIndexBank, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 196  : 	VERIFYSTRING_RETURN( ObjIndexBank, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 197  : 	VERIFYSTRING_RETURN( ExtBank, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 198  : 	VERIFYSTRING_RETURN( PirecingBank, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 199  : 	VERIFYSTRING_RETURN( szPet, lpDbOverlappedPlus->AccountInfo.szPlayer );

  00037	89 44 24 10	 mov	 DWORD PTR $T217763[esp+18988], eax
  0003b	33 c0		 xor	 eax, eax
  0003d	89 4c 24 0c	 mov	 DWORD PTR $T217762[esp+18988], ecx
  00041	53		 push	 ebx
  00042	56		 push	 esi
  00043	57		 push	 edi
  00044	c6 84 24 d0 2c
	00 00 00	 mov	 BYTE PTR _Bank$[esp+19000], 0
  0004c	b9 52 07 00 00	 mov	 ecx, 1874		; 00000752H
  00051	8d bc 24 d1 2c
	00 00		 lea	 edi, DWORD PTR _Bank$[esp+19001]
  00058	f3 ab		 rep stosd
  0005a	66 ab		 stosw
  0005c	aa		 stosb
  0005d	33 c0		 xor	 eax, eax
  0005f	c6 84 24 f8 00
	00 00 00	 mov	 BYTE PTR _m_apIndexBank$[esp+19000], 0
  00067	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0006c	8d bc 24 f9 00
	00 00		 lea	 edi, DWORD PTR _m_apIndexBank$[esp+19001]
  00073	f3 ab		 rep stosd
  00075	66 ab		 stosw
  00077	aa		 stosb
  00078	33 c0		 xor	 eax, eax
  0007a	c6 84 24 f8 02
	00 00 00	 mov	 BYTE PTR _ObjIndexBank$[esp+19000], 0
  00082	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00087	8d bc 24 f9 02
	00 00		 lea	 edi, DWORD PTR _ObjIndexBank$[esp+19001]
  0008e	f3 ab		 rep stosd
  00090	66 ab		 stosw
  00092	aa		 stosb
  00093	33 c0		 xor	 eax, eax
  00095	c6 84 24 f8 04
	00 00 00	 mov	 BYTE PTR _ExtBank$[esp+19000], 0
  0009d	b9 f3 01 00 00	 mov	 ecx, 499		; 000001f3H
  000a2	8d bc 24 f9 04
	00 00		 lea	 edi, DWORD PTR _ExtBank$[esp+19001]
  000a9	f3 ab		 rep stosd
  000ab	66 ab		 stosw
  000ad	aa		 stosb
  000ae	8b 75 0c	 mov	 esi, DWORD PTR _qry$[ebp]
  000b1	8b 5d 10	 mov	 ebx, DWORD PTR _lpDbOverlappedPlus$[ebp]
  000b4	33 c0		 xor	 eax, eax
  000b6	c6 84 24 30 1d
	00 00 00	 mov	 BYTE PTR _PirecingBank$[esp+19000], 0
  000be	b9 e7 03 00 00	 mov	 ecx, 999		; 000003e7H
  000c3	8d bc 24 31 1d
	00 00		 lea	 edi, DWORD PTR _PirecingBank$[esp+19001]
  000ca	f3 ab		 rep stosd
  000cc	66 ab		 stosw
  000ce	aa		 stosb
  000cf	c6 84 24 c8 0c
	00 00 00	 mov	 BYTE PTR _szPet$[esp+19000], 0
  000d7	33 c0		 xor	 eax, eax
  000d9	b9 19 04 00 00	 mov	 ecx, 1049		; 00000419H
  000de	8d bc 24 c9 0c
	00 00		 lea	 edi, DWORD PTR _szPet$[esp+19001]
  000e5	f3 ab		 rep stosd
  000e7	66 ab		 stosw
  000e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@FONFFEJF@m_idPlayer?$AA@
  000ee	8b ce		 mov	 ecx, esi
  000f0	aa		 stosb
  000f1	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KIBMFHG@m_dwGoldBank?$AA@
  000fb	8b ce		 mov	 ecx, esi
  000fd	89 44 24 14	 mov	 DWORD PTR _uPlayerid$[esp+19004], eax
  00101	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00106	8d 8c 24 d0 2c
	00 00		 lea	 ecx, DWORD PTR _Bank$[esp+19000]
  0010d	51		 push	 ecx
  0010e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06BAMDHIIP@m_Bank?$AA@
  00113	8b ce		 mov	 ecx, esi
  00115	89 44 24 14	 mov	 DWORD PTR _dwGold$[esp+19008], eax
  00119	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0011e	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _m_apIndexBank$[esp+19000]
  00125	52		 push	 edx
  00126	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KMLFLAAK@m_apIndex_Bank?$AA@
  0012b	8b ce		 mov	 ecx, esi
  0012d	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00132	8d 84 24 f8 02
	00 00		 lea	 eax, DWORD PTR _ObjIndexBank$[esp+19000]
  00139	50		 push	 eax
  0013a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@HHMCMCCB@m_dwObjIndex_Bank?$AA@
  0013f	8b ce		 mov	 ecx, esi
  00141	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00146	8d 8c 24 f8 04
	00 00		 lea	 ecx, DWORD PTR _ExtBank$[esp+19000]
  0014d	51		 push	 ecx
  0014e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09CHFBCGKD@m_extBank?$AA@
  00153	8b ce		 mov	 ecx, esi
  00155	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0015a	8d 94 24 30 1d
	00 00		 lea	 edx, DWORD PTR _PirecingBank$[esp+19000]
  00161	52		 push	 edx
  00162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HANLGJJC@m_BankPiercing?$AA@
  00167	8b ce		 mov	 ecx, esi
  00169	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0016e	8d 84 24 c8 0c
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19000]
  00175	50		 push	 eax
  00176	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09DAKBPAHF@szBankPet?$AA@
  0017b	8b ce		 mov	 ecx, esi
  0017d	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00182	8b 7c 24 18	 mov	 edi, DWORD PTR $T217762[esp+19000]
  00186	53		 push	 ebx
  00187	8d 73 74	 lea	 esi, DWORD PTR [ebx+116]
  0018a	56		 push	 esi
  0018b	68 c2 00 00 00	 push	 194			; 000000c2H
  00190	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00195	8d 8c 24 e0 2c
	00 00		 lea	 ecx, DWORD PTR _Bank$[esp+19016]
  0019c	51		 push	 ecx
  0019d	8b cf		 mov	 ecx, edi
  0019f	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  001a4	85 c0		 test	 eax, eax
  001a6	0f 84 f3 05 00
	00		 je	 $L217788
  001ac	53		 push	 ebx
  001ad	56		 push	 esi
  001ae	68 c3 00 00 00	 push	 195			; 000000c3H
  001b3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  001b8	8d 94 24 08 01
	00 00		 lea	 edx, DWORD PTR _m_apIndexBank$[esp+19016]
  001bf	52		 push	 edx
  001c0	8b cf		 mov	 ecx, edi
  001c2	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  001c7	85 c0		 test	 eax, eax
  001c9	0f 84 d0 05 00
	00		 je	 $L217788
  001cf	53		 push	 ebx
  001d0	56		 push	 esi
  001d1	68 c4 00 00 00	 push	 196			; 000000c4H
  001d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  001db	8d 84 24 08 03
	00 00		 lea	 eax, DWORD PTR _ObjIndexBank$[esp+19016]
  001e2	50		 push	 eax
  001e3	8b cf		 mov	 ecx, edi
  001e5	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  001ea	85 c0		 test	 eax, eax
  001ec	0f 84 ad 05 00
	00		 je	 $L217788
  001f2	53		 push	 ebx
  001f3	56		 push	 esi
  001f4	68 c5 00 00 00	 push	 197			; 000000c5H
  001f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  001fe	8d 8c 24 08 05
	00 00		 lea	 ecx, DWORD PTR _ExtBank$[esp+19016]
  00205	51		 push	 ecx
  00206	8b cf		 mov	 ecx, edi
  00208	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  0020d	85 c0		 test	 eax, eax
  0020f	0f 84 8a 05 00
	00		 je	 $L217788
  00215	53		 push	 ebx
  00216	56		 push	 esi
  00217	68 c6 00 00 00	 push	 198			; 000000c6H
  0021c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00221	8d 94 24 40 1d
	00 00		 lea	 edx, DWORD PTR _PirecingBank$[esp+19016]
  00228	52		 push	 edx
  00229	8b cf		 mov	 ecx, edi
  0022b	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00230	85 c0		 test	 eax, eax
  00232	0f 84 67 05 00
	00		 je	 $L217788
  00238	53		 push	 ebx
  00239	56		 push	 esi
  0023a	68 c7 00 00 00	 push	 199			; 000000c7H
  0023f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00244	8d 84 24 d8 0c
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19016]
  0024b	50		 push	 eax
  0024c	8b cf		 mov	 ecx, edi
  0024e	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00253	85 c0		 test	 eax, eax
  00255	0f 84 44 05 00
	00		 je	 $L217788

; 200  : 	
; 201  : 	pMover->m_idPlayerBank[nSlot] = uPlayerid;

  0025b	8b 5d 14	 mov	 ebx, DWORD PTR _nSlot$[ebp]
  0025e	8b 74 24 1c	 mov	 esi, DWORD PTR $T217763[esp+19000]
  00262	8b 4c 24 10	 mov	 ecx, DWORD PTR _uPlayerid$[esp+19000]

; 202  : 	pMover->m_dwGoldBank[nSlot]	= dwGold;

  00266	8b 54 24 0c	 mov	 edx, DWORD PTR _dwGold$[esp+19000]
  0026a	89 8c 9e 88 41
	00 00		 mov	 DWORD PTR [esi+ebx*4+16776], ecx

; 203  : 	
; 204  : 	CountStr	= 0;	IndexItem	= 0;			
; 205  : 	while( '$' != Bank[CountStr] )

  00271	8a 8c 24 d0 2c
	00 00		 mov	 cl, BYTE PTR _Bank$[esp+19000]
  00278	33 c0		 xor	 eax, eax
  0027a	80 f9 24	 cmp	 cl, 36			; 00000024H
  0027d	89 94 9e d0 41
	00 00		 mov	 DWORD PTR [esi+ebx*4+16848], edx
  00284	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  00288	0f 84 a3 00 00
	00		 je	 $L208661
  0028e	8b ff		 npad	 2
$L208660:

; 206  : 	{
; 207  : 		CItemElem BufItemElem;

  00290	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208662[esp+19000]
  00294	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 208  : 		IndexItem = GetOneItem( &BufItemElem, Bank, &CountStr );

  00299	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  0029d	50		 push	 eax
  0029e	8d 8c 24 d4 2c
	00 00		 lea	 ecx, DWORD PTR _Bank$[esp+19004]
  002a5	51		 push	 ecx
  002a6	8d 54 24 28	 lea	 edx, DWORD PTR _BufItemElem$208662[esp+19008]
  002aa	52		 push	 edx
  002ab	8b cf		 mov	 ecx, edi
  002ad	c7 84 24 40 4a
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+19020], 0
  002b8	e8 00 00 00 00	 call	 ?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z ; CDbManager::GetOneItem

; 209  : 		if( IndexItem == -1 )

  002bd	83 f8 ff	 cmp	 eax, -1
  002c0	75 21		 jne	 SHORT $L208663

; 210  : 		{
; 211  : 			Error( "Join::Bank : << Not Prop. %d, %d \nBank = %s", uPlayerid, BufItemElem.m_dwItemId, Bank );

  002c2	8b 4c 24 28	 mov	 ecx, DWORD PTR _BufItemElem$208662[esp+19008]
  002c6	8b 54 24 10	 mov	 edx, DWORD PTR _uPlayerid$[esp+19000]
  002ca	8d 84 24 d0 2c
	00 00		 lea	 eax, DWORD PTR _Bank$[esp+19000]
  002d1	50		 push	 eax
  002d2	51		 push	 ecx
  002d3	52		 push	 edx
  002d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@JMMGLGKB@Join?3?3Bank?5?3?5?$DM?$DM?5Not?5Prop?4?5?$CFd?0?5?$CFd@
  002d9	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  002de	83 c4 10	 add	 esp, 16			; 00000010H

; 212  : 		}
; 213  : 		else

  002e1	eb 26		 jmp	 SHORT $L208665
$L208663:

; 214  : 		{
; 215  : 			if( IndexItem >= MAX_BANK )

  002e3	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  002e6	0f 8d 85 04 00
	00		 jge	 $L217775

; 219  : 			}
; 220  : 			pMover->m_Bank[nSlot].m_apItem[IndexItem] = BufItemElem;

  002ec	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  002ef	8d 8c 9b 68 10
	00 00		 lea	 ecx, DWORD PTR [ebx+ebx*4+4200]
  002f6	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  002f9	c1 e2 05	 shl	 edx, 5
  002fc	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  002ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00301	8d 44 24 20	 lea	 eax, DWORD PTR _BufItemElem$208662[esp+19000]
  00305	50		 push	 eax
  00306	ff 52 10	 call	 DWORD PTR [edx+16]
$L208665:

; 221  : 		}
; 222  : 	}

  00309	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208662[esp+19000]
  0030d	c7 84 24 34 4a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+19008], -1
  00318	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  0031d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _CountStr$[esp+19000]
  00321	80 bc 0c d0 2c
	00 00 24	 cmp	 BYTE PTR _Bank$[esp+ecx+19000], 36 ; 00000024H
  00329	0f 85 61 ff ff
	ff		 jne	 $L208660

; 214  : 		{
; 215  : 			if( IndexItem >= MAX_BANK )

  0032f	33 c0		 xor	 eax, eax
$L208661:

; 223  : 	
; 224  : 	CountStr	= 0;	itemCount	= 0;
; 225  : 	while( '$' != m_apIndexBank[CountStr] )

  00331	80 bc 24 f8 00
	00 00 24	 cmp	 BYTE PTR _m_apIndexBank$[esp+19000], 36 ; 00000024H
  00339	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  0033d	74 4d		 je	 SHORT $L208671
  0033f	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  00342	8d 94 8e 98 41
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+16792]
  00349	89 54 24 14	 mov	 DWORD PTR tv616[esp+19000], edx
  0034d	89 44 24 10	 mov	 DWORD PTR tv831[esp+19000], eax
$L208670:

; 226  : 	{
; 227  : 		pMover->m_Bank[nSlot].m_apIndex[itemCount]						= (DWORD)GetIntFromStr( m_apIndexBank, &CountStr );

  00351	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  00355	50		 push	 eax
  00356	8d 8c 24 fc 00
	00 00		 lea	 ecx, DWORD PTR _m_apIndexBank$[esp+19004]
  0035d	51		 push	 ecx
  0035e	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00363	8b 54 24 1c	 mov	 edx, DWORD PTR tv616[esp+19008]
  00367	8b 4c 24 18	 mov	 ecx, DWORD PTR tv831[esp+19008]
  0036b	8b 12		 mov	 edx, DWORD PTR [edx]
  0036d	89 04 11	 mov	 DWORD PTR [ecx+edx], eax
  00370	8b 44 24 14	 mov	 eax, DWORD PTR _CountStr$[esp+19008]

; 228  : 		itemCount++;

  00374	83 c1 04	 add	 ecx, 4
  00377	89 4c 24 18	 mov	 DWORD PTR tv831[esp+19008], ecx
  0037b	8a 8c 04 00 01
	00 00		 mov	 cl, BYTE PTR _m_apIndexBank$[esp+eax+19008]
  00382	83 c4 08	 add	 esp, 8
  00385	80 f9 24	 cmp	 cl, 36			; 00000024H
  00388	75 c7		 jne	 SHORT $L208670

; 223  : 	
; 224  : 	CountStr	= 0;	itemCount	= 0;
; 225  : 	while( '$' != m_apIndexBank[CountStr] )

  0038a	33 c0		 xor	 eax, eax
$L208671:

; 229  : 	}
; 230  : 	
; 231  : 	CountStr	= 0;	IndexObjIndex	= 0;
; 232  : 	while( '$' != ObjIndexBank[CountStr] )

  0038c	80 bc 24 f8 02
	00 00 24	 cmp	 BYTE PTR _ObjIndexBank$[esp+19000], 36 ; 00000024H
  00394	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  00398	74 50		 je	 SHORT $L208675
  0039a	8d 8c 9b 68 10
	00 00		 lea	 ecx, DWORD PTR [ebx+ebx*4+4200]
  003a1	8d 14 8e	 lea	 edx, DWORD PTR [esi+ecx*4]

; 233  : 	{
; 234  : 		pMover->m_Bank[nSlot].m_apItem[IndexObjIndex].m_dwObjIndex		= (DWORD)GetIntFromStr( ObjIndexBank, &CountStr );

  003a4	89 54 24 14	 mov	 DWORD PTR tv599[esp+19000], edx
  003a8	33 ff		 xor	 edi, edi
  003aa	8d 9b 00 00 00
	00		 npad	 6
$L208674:
  003b0	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  003b4	50		 push	 eax
  003b5	8d 8c 24 fc 02
	00 00		 lea	 ecx, DWORD PTR _ObjIndexBank$[esp+19004]
  003bc	51		 push	 ecx
  003bd	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  003c2	8b 54 24 1c	 mov	 edx, DWORD PTR tv599[esp+19008]
  003c6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003c8	8b 54 24 14	 mov	 edx, DWORD PTR _CountStr$[esp+19008]
  003cc	89 44 0f 2c	 mov	 DWORD PTR [edi+ecx+44], eax
  003d0	8a 84 14 00 03
	00 00		 mov	 al, BYTE PTR _ObjIndexBank$[esp+edx+19008]
  003d7	83 c4 08	 add	 esp, 8

; 235  : 		IndexObjIndex++;

  003da	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H
  003e0	3c 24		 cmp	 al, 36			; 00000024H
  003e2	75 cc		 jne	 SHORT $L208674
  003e4	8b 7c 24 18	 mov	 edi, DWORD PTR $T217762[esp+19000]
  003e8	33 c0		 xor	 eax, eax
$L208675:

; 236  : 	}
; 237  : 
; 238  : 	CountStr	= 0;	nExtBankCount	= 0;
; 239  : 	while( '$' != ExtBank[CountStr] )

  003ea	80 bc 24 f8 04
	00 00 24	 cmp	 BYTE PTR _ExtBank$[esp+19000], 36 ; 00000024H
  003f2	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  003f6	0f 84 e2 00 00
	00		 je	 $L208679
  003fc	8d 84 9b 68 10
	00 00		 lea	 eax, DWORD PTR [ebx+ebx*4+4200]
  00403	8d 3c 86	 lea	 edi, DWORD PTR [esi+eax*4]
  00406	33 f6		 xor	 esi, esi
  00408	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L208678:

; 240  : 	{
; 241  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bCharged			= (BOOL)GetIntPaFromStr( ExtBank, &CountStr );

  00410	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+19000]
  00414	51		 push	 ecx
  00415	8d 94 24 fc 04
	00 00		 lea	 edx, DWORD PTR _ExtBank$[esp+19004]
  0041c	52		 push	 edx
  0041d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00422	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00424	89 84 0e 88 00
	00 00		 mov	 DWORD PTR [esi+ecx+136], eax

; 242  : 		if( pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bCharged != 1 )

  0042b	8b 17		 mov	 edx, DWORD PTR [edi]
  0042d	8b 8c 16 88 00
	00 00		 mov	 ecx, DWORD PTR [esi+edx+136]
  00434	8d 84 16 88 00
	00 00		 lea	 eax, DWORD PTR [esi+edx+136]
  0043b	83 c4 08	 add	 esp, 8
  0043e	83 f9 01	 cmp	 ecx, 1
  00441	74 06		 je	 SHORT $L208681

; 243  : 			pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bCharged	= 0;

  00443	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L208681:

; 244  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_dwKeepTime		= (DWORD)GetIntPaFromStr( ExtBank, &CountStr );

  00449	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  0044d	50		 push	 eax
  0044e	8d 8c 24 fc 04
	00 00		 lea	 ecx, DWORD PTR _ExtBank$[esp+19004]
  00455	51		 push	 ecx
  00456	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  0045b	8b 17		 mov	 edx, DWORD PTR [edi]
  0045d	89 84 16 8c 00
	00 00		 mov	 DWORD PTR [esi+edx+140], eax

; 245  : #if __VER >= 11 // __SYS_IDENTIFY
; 246  : 		__int64 iRandomOptItemId	= GetInt64PaFromStr( ExtBank, &CountStr );

  00464	8d 44 24 14	 lea	 eax, DWORD PTR _CountStr$[esp+19008]
  00468	50		 push	 eax
  00469	8d 8c 24 04 05
	00 00		 lea	 ecx, DWORD PTR _ExtBank$[esp+19012]
  00470	51		 push	 ecx
  00471	e8 00 00 00 00	 call	 ?GetInt64PaFromStr@@YA_JPADPAH@Z ; GetInt64PaFromStr
  00476	83 c4 10	 add	 esp, 16			; 00000010H

; 247  : 		if( iRandomOptItemId == -102 )

  00479	83 f8 9a	 cmp	 eax, -102		; ffffff9aH
  0047c	75 09		 jne	 SHORT $L208684
  0047e	83 fa ff	 cmp	 edx, -1
  00481	75 04		 jne	 SHORT $L208684

; 248  : 			iRandomOptItemId	= 0;

  00483	33 c0		 xor	 eax, eax
  00485	33 d2		 xor	 edx, edx
$L208684:

; 249  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].SetRandomOptItemId( iRandomOptItemId );

  00487	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00489	03 ce		 add	 ecx, esi
  0048b	89 91 94 00 00
	00		 mov	 DWORD PTR [ecx+148], edx

; 250  : #else	// __SYS_IDENTIFY
; 251  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].SetRandomOptItemId( (DWORD)GetIntPaFromStr( ExtBank, &CountStr ) );
; 252  : #endif	// __SYS_IDENTIFY
; 253  : #if __VER >= 15 // __PETVIS
; 254  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bTranformVisPet = static_cast<BOOL>( GetIntPaFromStr( ExtBank, &CountStr ) );

  00491	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+19000]
  00495	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax
  0049b	52		 push	 edx
  0049c	8d 84 24 fc 04
	00 00		 lea	 eax, DWORD PTR _ExtBank$[esp+19004]
  004a3	50		 push	 eax
  004a4	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  004a9	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004ab	89 84 0e 9c 00
	00 00		 mov	 DWORD PTR [esi+ecx+156], eax

; 255  : #endif // __PETVIS
; 256  : 		++CountStr;

  004b2	8b 44 24 14	 mov	 eax, DWORD PTR _CountStr$[esp+19008]
  004b6	8a 8c 04 01 05
	00 00		 mov	 cl, BYTE PTR _ExtBank$[esp+eax+19009]
  004bd	83 c4 08	 add	 esp, 8
  004c0	40		 inc	 eax

; 257  : 
; 258  : 		++nExtBankCount;

  004c1	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  004c7	80 f9 24	 cmp	 cl, 36			; 00000024H
  004ca	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  004ce	0f 85 3c ff ff
	ff		 jne	 $L208678
  004d4	8b 74 24 1c	 mov	 esi, DWORD PTR $T217763[esp+19000]
  004d8	8b 7c 24 18	 mov	 edi, DWORD PTR $T217762[esp+19000]
  004dc	33 c0		 xor	 eax, eax
$L208679:

; 259  : 	}
; 260  : 
; 261  : 	CountStr	= 0;	nPirecingBankCount = 0;
; 262  : 	while( '$' != PirecingBank[CountStr] )

  004de	80 bc 24 30 1d
	00 00 24	 cmp	 BYTE PTR _PirecingBank$[esp+19000], 36 ; 00000024H
  004e6	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  004ea	74 3d		 je	 SHORT $L208688
  004ec	8d 94 9b 68 10
	00 00		 lea	 edx, DWORD PTR [ebx+ebx*4+4200]
  004f3	8d 34 96	 lea	 esi, DWORD PTR [esi+edx*4]
  004f6	33 db		 xor	 ebx, ebx
$L208687:

; 263  : 	{
; 264  : #if __VER >= 12 // __EXT_PIERCING
; 265  : 		LoadPiercingInfo( pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount], PirecingBank, &CountStr );

  004f8	8b 16		 mov	 edx, DWORD PTR [esi]
  004fa	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  004fe	50		 push	 eax
  004ff	8d 8c 24 34 1d
	00 00		 lea	 ecx, DWORD PTR _PirecingBank$[esp+19004]
  00506	51		 push	 ecx
  00507	03 d3		 add	 edx, ebx
  00509	52		 push	 edx
  0050a	8b cf		 mov	 ecx, edi
  0050c	e8 00 00 00 00	 call	 ?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z ; CDbManager::LoadPiercingInfo
  00511	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+19000]
  00515	8a 8c 04 30 1d
	00 00		 mov	 cl, BYTE PTR _PirecingBank$[esp+eax+19000]

; 266  : #else // __EXT_PIERCING
; 267  : 		int nItemIdCount = 0;
; 268  : 		pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount].SetPiercingSize( GetIntFromStr( PirecingBank, &CountStr ) );
; 269  : 		for( int i = 0 ; i < pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount].GetPiercingSize() ; ++i )
; 270  : 		{
; 271  : 			pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount].SetPiercingItem( nItemIdCount, (DWORD)GetIntFromStr( PirecingBank, &CountStr ) );
; 272  : 			++nItemIdCount;
; 273  : 		}
; 274  : #endif // __EXT_PIERCING
; 275  : 		++nPirecingBankCount;

  0051c	81 c3 a0 00 00
	00		 add	 ebx, 160		; 000000a0H
  00522	80 f9 24	 cmp	 cl, 36			; 00000024H
  00525	75 d1		 jne	 SHORT $L208687

; 259  : 	}
; 260  : 
; 261  : 	CountStr	= 0;	nPirecingBankCount = 0;
; 262  : 	while( '$' != PirecingBank[CountStr] )

  00527	33 c0		 xor	 eax, eax
$L208688:

; 279  : 	int	nId	= 0;
; 280  : 	while( '$' != szPet[CountStr] )

  00529	80 bc 24 c8 0c
	00 00 24	 cmp	 BYTE PTR _szPet$[esp+19000], 36 ; 00000024H
  00531	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  00535	0f 84 0c 02 00
	00		 je	 $L208692

; 276  : 	}
; 277  : 
; 278  : 	CountStr	= 0;

  0053b	33 db		 xor	 ebx, ebx
  0053d	8d 49 00	 npad	 3
$L208691:

; 281  : 	{
; 282  : 		BOOL bPet	= (BOOL)GetIntFromStr( szPet, &CountStr );

  00540	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+19000]
  00544	51		 push	 ecx
  00545	8d 94 24 cc 0c
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19004]
  0054c	52		 push	 edx
  0054d	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 283  : 		if( bPet )

  00552	33 f6		 xor	 esi, esi
  00554	83 c4 08	 add	 esp, 8
  00557	3b c6		 cmp	 eax, esi
  00559	0f 84 cf 01 00
	00		 je	 $L208695

; 284  : 		{
; 285  : 			SAFE_DELETE( pMover->m_Bank[nSlot].m_apItem[nId].m_pPet );

  0055f	8b 45 14	 mov	 eax, DWORD PTR _nSlot$[ebp]
  00562	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T217763[esp+19000]
  00566	8d 84 80 68 10
	00 00		 lea	 eax, DWORD PTR [eax+eax*4+4200]
  0056d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00570	8d 3c 81	 lea	 edi, DWORD PTR [ecx+eax*4]
  00573	8b 8c 13 98 00
	00 00		 mov	 ecx, DWORD PTR [ebx+edx+152]
  0057a	3b ce		 cmp	 ecx, esi
  0057c	74 0f		 je	 SHORT $L208696
  0057e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00580	6a 01		 push	 1
  00582	ff 10		 call	 DWORD PTR [eax]
  00584	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00586	89 b4 0b 98 00
	00 00		 mov	 DWORD PTR [ebx+ecx+152], esi
$L208696:

; 286  : 			CPet* pPet	= pMover->m_Bank[nSlot].m_apItem[nId].m_pPet		= new CPet;

  0058d	6a 28		 push	 40			; 00000028H
  0058f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00594	83 c4 04	 add	 esp, 4
  00597	89 44 24 10	 mov	 DWORD PTR $T217740[esp+19000], eax
  0059b	3b c6		 cmp	 eax, esi
  0059d	c7 84 24 34 4a
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+19008], 1
  005a8	74 09		 je	 SHORT $L217742
  005aa	8b c8		 mov	 ecx, eax
  005ac	e8 00 00 00 00	 call	 ??0CPet@@QAE@XZ		; CPet::CPet
  005b1	8b f0		 mov	 esi, eax
$L217742:
  005b3	8b 17		 mov	 edx, DWORD PTR [edi]

; 287  : 			BYTE nKind	= (BYTE)GetIntFromStr( szPet, &CountStr );

  005b5	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  005b9	50		 push	 eax
  005ba	8d 8c 24 cc 0c
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19004]
  005c1	51		 push	 ecx
  005c2	c7 84 24 3c 4a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+19016], -1
  005cd	89 b4 13 98 00
	00 00		 mov	 DWORD PTR [ebx+edx+152], esi
  005d4	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 288  : 			pPet->SetKind( nKind );
; 289  : 			BYTE nLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );

  005d9	8d 54 24 14	 lea	 edx, DWORD PTR _CountStr$[esp+19008]
  005dd	88 46 04	 mov	 BYTE PTR [esi+4], al
  005e0	52		 push	 edx
  005e1	8d 84 24 d4 0c
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19012]
  005e8	50		 push	 eax
  005e9	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 290  : 			pPet->SetLevel( nLevel );
; 291  : 			DWORD dwExp	= (DWORD)GetIntFromStr( szPet, &CountStr );

  005ee	8d 4c 24 1c	 lea	 ecx, DWORD PTR _CountStr$[esp+19016]
  005f2	51		 push	 ecx
  005f3	8d 94 24 dc 0c
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19020]
  005fa	52		 push	 edx
  005fb	88 46 05	 mov	 BYTE PTR [esi+5], al
  005fe	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00603	83 c4 18	 add	 esp, 24			; 00000018H

; 292  : 			pPet->SetExp( dwExp );

  00606	50		 push	 eax
  00607	8b ce		 mov	 ecx, esi
  00609	e8 00 00 00 00	 call	 ?SetExp@CPet@@QAEXK@Z	; CPet::SetExp

; 293  : 			WORD wEnergy	= (WORD)GetIntFromStr( szPet, &CountStr );

  0060e	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  00612	50		 push	 eax
  00613	8d 8c 24 cc 0c
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19004]
  0061a	51		 push	 ecx
  0061b	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00620	83 c4 08	 add	 esp, 8

; 294  : 			pPet->SetEnergy( wEnergy );

  00623	50		 push	 eax
  00624	8b ce		 mov	 ecx, esi
  00626	e8 00 00 00 00	 call	 ?SetEnergy@CPet@@QAEXG@Z ; CPet::SetEnergy

; 295  : #ifdef __PET_1024
; 296  : 			WORD wLife	= (WORD)GetIntPaFromStr( szPet, &CountStr );

  0062b	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+19000]
  0062f	52		 push	 edx
  00630	8d 84 24 cc 0c
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19004]
  00637	50		 push	 eax
  00638	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 297  : 			pPet->SetLife( wLife );

  0063d	66 89 46 0e	 mov	 WORD PTR [esi+14], ax

; 298  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )

  00641	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00644	83 c4 08	 add	 esp, 8
  00647	3c 01		 cmp	 al, 1
  00649	bf 01 00 00 00	 mov	 edi, 1
  0064e	72 2f		 jb	 SHORT $L208718
$L208716:

; 299  : 			{
; 300  : 				BYTE nAvailLevel	= (BYTE)GetIntPaFromStr( szPet, &CountStr );

  00650	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+19000]
  00654	51		 push	 ecx
  00655	8d 94 24 cc 0c
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19004]
  0065c	52		 push	 edx
  0065d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00662	88 44 24 1c	 mov	 BYTE PTR _nAvailLevel$208719[esp+19008], al

; 301  : 				pPet->SetAvailLevel( i, nAvailLevel );

  00666	8b 44 24 1c	 mov	 eax, DWORD PTR _nAvailLevel$208719[esp+19008]
  0066a	83 c4 08	 add	 esp, 8
  0066d	50		 push	 eax
  0066e	57		 push	 edi
  0066f	8b ce		 mov	 ecx, esi
  00671	e8 00 00 00 00	 call	 ?SetAvailLevel@CPet@@QAEXEE@Z ; CPet::SetAvailLevel
  00676	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  0067a	47		 inc	 edi
  0067b	3b f9		 cmp	 edi, ecx
  0067d	7e d1		 jle	 SHORT $L208716
$L208718:

; 302  : 			}
; 303  : 			char szFmt[MAX_PET_NAME_FMT]	= { 0,};

  0067f	33 d2		 xor	 edx, edx
  00681	89 94 24 d5 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19001], edx
  00688	89 94 24 d9 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19005], edx
  0068f	89 94 24 dd 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19009], edx
  00696	89 94 24 e1 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19013], edx
  0069d	89 94 24 e5 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19017], edx
  006a4	89 94 24 e9 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19021], edx
  006ab	89 94 24 ed 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19025], edx

; 304  : 			GetStrFromStr( szPet, szFmt, &CountStr );

  006b2	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  006b6	50		 push	 eax
  006b7	8d 8c 24 d8 00
	00 00		 lea	 ecx, DWORD PTR _szFmt$208721[esp+19004]
  006be	89 94 24 f5 00
	00 00		 mov	 DWORD PTR _szFmt$208721[esp+19033], edx
  006c5	51		 push	 ecx
  006c6	8d 94 24 d0 0c
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19008]
  006cd	52		 push	 edx
  006ce	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR _szFmt$208721[esp+19012], 0
  006d6	e8 00 00 00 00	 call	 ?GetStrFromStr@@YAXPAD0PAH@Z ; GetStrFromStr

; 305  : 			char szName[MAX_PET_NAME]	= { 0,};

  006db	33 c0		 xor	 eax, eax
  006dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  006e0	89 84 24 c1 00
	00 00		 mov	 DWORD PTR _szName$208722[esp+19001], eax

; 306  : 			GetDBFormatStr( szName, MAX_PET_NAME, szFmt );

  006e7	8d 8c 24 d4 00
	00 00		 lea	 ecx, DWORD PTR _szFmt$208721[esp+19000]
  006ee	51		 push	 ecx
  006ef	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T217762[esp+19004]
  006f3	89 84 24 c9 00
	00 00		 mov	 DWORD PTR _szName$208722[esp+19009], eax
  006fa	6a 11		 push	 17			; 00000011H
  006fc	8d 94 24 c8 00
	00 00		 lea	 edx, DWORD PTR _szName$208722[esp+19008]
  00703	89 84 24 d1 00
	00 00		 mov	 DWORD PTR _szName$208722[esp+19017], eax
  0070a	52		 push	 edx
  0070b	c6 84 24 cc 00
	00 00 00	 mov	 BYTE PTR _szName$208722[esp+19012], 0
  00713	89 84 24 d9 00
	00 00		 mov	 DWORD PTR _szName$208722[esp+19025], eax
  0071a	e8 00 00 00 00	 call	 ?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z ; CDbManager::GetDBFormatStr

; 307  : 			pPet->SetName( szName );

  0071f	8d 84 24 c0 00
	00 00		 lea	 eax, DWORD PTR _szName$208722[esp+19000]
  00726	50		 push	 eax
  00727	8b ce		 mov	 ecx, esi
  00729	e8 00 00 00 00	 call	 ?SetName@CPet@@QAEXPBD@Z ; CPet::SetName
$L208695:
  0072e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _CountStr$[esp+19000]
  00732	8a 84 0c c8 0c
	00 00		 mov	 al, BYTE PTR _szPet$[esp+ecx+19000]

; 308  : #else	// __PET_1024
; 309  : 			WORD wLife	= (WORD)GetIntFromStr( szPet, &CountStr );
; 310  : 			pPet->SetLife( wLife );
; 311  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )
; 312  : 			{
; 313  : 				BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );
; 314  : 				pPet->SetAvailLevel( i, nAvailLevel );
; 315  : 			}
; 316  : #endif	// __PET_1024
; 317  : 		}
; 318  : 		nId++;

  00739	81 c3 a0 00 00
	00		 add	 ebx, 160		; 000000a0H
  0073f	3c 24		 cmp	 al, 36			; 00000024H
  00741	0f 85 f9 fd ff
	ff		 jne	 $L208691
$L208692:

; 319  : 	}
; 320  : 	return TRUE;

  00747	b8 01 00 00 00	 mov	 eax, 1
$L208628:

; 321  : }

  0074c	8b 8c 24 2c 4a
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+19000]
  00753	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0075a	8b 8c 24 24 4a
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+19000]
  00761	5f		 pop	 edi
  00762	5e		 pop	 esi
  00763	33 cd		 xor	 ecx, ebp
  00765	5b		 pop	 ebx
  00766	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0076b	8b e5		 mov	 esp, ebp
  0076d	5d		 pop	 ebp
  0076e	c2 10 00	 ret	 16			; 00000010H
$L217775:

; 216  : 			{
; 217  : 				Error( "Join::Bank : << MAX_BANK %d\nBank = %s", uPlayerid, Bank );

  00771	8b 44 24 10	 mov	 eax, DWORD PTR _uPlayerid$[esp+19000]
  00775	8d 94 24 d0 2c
	00 00		 lea	 edx, DWORD PTR _Bank$[esp+19000]
  0077c	52		 push	 edx
  0077d	50		 push	 eax
  0077e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@GPGFAEMD@Join?3?3Bank?5?3?5?$DM?$DM?5MAX_BANK?5?$CFd?6Bank@
  00783	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00788	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 				return FALSE;

  0078b	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208662[esp+19000]
  0078f	c7 84 24 34 4a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+19008], -1
  0079a	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L217788:
  0079f	33 c0		 xor	 eax, eax
  007a1	eb a9		 jmp	 SHORT $L208628
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L217743:
  00000	8d 8d e8 b5 ff
	ff		 lea	 ecx, DWORD PTR _BufItemElem$208662[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L217744:
  0000b	8b 85 d8 b5 ff
	ff		 mov	 eax, DWORD PTR $T217740[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
  00018	c3		 ret	 0
__ehhandler$?GetBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@H@Z:
  00019	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T217767
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@H@Z ENDP ; CDbManager::GetBank
PUBLIC	?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z ; CDbManager::GetBankMover
PUBLIC	??_C@_09EFEJAHGE@Bank?5?$DN?5?$CFs?$AA@		; `string'
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
xdata$x	SEGMENT
$T217879 DD	0ffffffffH
	DD	FLAT:$L217803
	DD	0ffffffffH
	DD	FLAT:$L217804
$T217851 DD	019930520H
	DD	02H
	DD	FLAT:$T217879
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_09EFEJAHGE@Bank?5?$DN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_09EFEJAHGE@Bank?5?$DN?5?$CFs?$AA@ DB 'Bank = %s', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z
_TEXT	SEGMENT
_CountStr$ = -18988					; size = 4
$T217848 = -18984					; size = 4
tv618 = -18980						; size = 4
tv582 = -18980						; size = 4
_nAvailLevel$208804 = -18980				; size = 1
$T217847 = -18976					; size = 4
$T217800 = -18972					; size = 4
_BufItemElem$208745 = -18968				; size = 160
_szName$208807 = -18808					; size = 17
_szFmt$208806 = -18788					; size = 33
_m_apIndexBank$ = -18752				; size = 512
_ObjIndexBank$ = -18240					; size = 512
_ExtBank$ = -17728					; size = 2000
_szPet$ = -15728					; size = 4200
_PirecingBank$ = -11528					; size = 4000
_Bank$ = -7528						; size = 7500
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_nSlot$ = 16						; size = 4
?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z PROC NEAR ; CDbManager::GetBankMover, COMDAT
; _this$ = ecx

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	51		 push	 ecx
  0001c	b8 1c 4a 00 00	 mov	 eax, 18972		; 00004a1cH
  00021	e8 00 00 00 00	 call	 __chkstk
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 84 24 18 4a
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+18988], eax

; 369  : 	
; 370  : 	CountStr	= 0;	itemCount	= 0;
; 371  : 	VERIFYSTRING_BANK( m_apIndexBank, pMover->m_szName );

  00034	8b 45 08	 mov	 eax, DWORD PTR _pMover$[ebp]
  00037	89 44 24 04	 mov	 DWORD PTR $T217848[esp+18988], eax
  0003b	33 c0		 xor	 eax, eax
  0003d	53		 push	 ebx
  0003e	8b d9		 mov	 ebx, ecx
  00040	56		 push	 esi
  00041	57		 push	 edi
  00042	c6 84 24 d0 2c
	00 00 00	 mov	 BYTE PTR _Bank$[esp+19000], 0
  0004a	b9 52 07 00 00	 mov	 ecx, 1874		; 00000752H
  0004f	8d bc 24 d1 2c
	00 00		 lea	 edi, DWORD PTR _Bank$[esp+19001]
  00056	f3 ab		 rep stosd
  00058	66 ab		 stosw
  0005a	aa		 stosb
  0005b	33 c0		 xor	 eax, eax
  0005d	c6 84 24 f8 00
	00 00 00	 mov	 BYTE PTR _m_apIndexBank$[esp+19000], 0
  00065	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0006a	8d bc 24 f9 00
	00 00		 lea	 edi, DWORD PTR _m_apIndexBank$[esp+19001]
  00071	f3 ab		 rep stosd
  00073	66 ab		 stosw
  00075	aa		 stosb
  00076	33 c0		 xor	 eax, eax
  00078	c6 84 24 f8 02
	00 00 00	 mov	 BYTE PTR _ObjIndexBank$[esp+19000], 0
  00080	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00085	8d bc 24 f9 02
	00 00		 lea	 edi, DWORD PTR _ObjIndexBank$[esp+19001]
  0008c	f3 ab		 rep stosd
  0008e	66 ab		 stosw
  00090	aa		 stosb
  00091	33 c0		 xor	 eax, eax
  00093	c6 84 24 f8 04
	00 00 00	 mov	 BYTE PTR _ExtBank$[esp+19000], 0
  0009b	b9 f3 01 00 00	 mov	 ecx, 499		; 000001f3H
  000a0	8d bc 24 f9 04
	00 00		 lea	 edi, DWORD PTR _ExtBank$[esp+19001]
  000a7	f3 ab		 rep stosd
  000a9	66 ab		 stosw
  000ab	aa		 stosb
  000ac	8b 75 0c	 mov	 esi, DWORD PTR _qry$[ebp]
  000af	33 c0		 xor	 eax, eax
  000b1	c6 84 24 30 1d
	00 00 00	 mov	 BYTE PTR _PirecingBank$[esp+19000], 0
  000b9	b9 e7 03 00 00	 mov	 ecx, 999		; 000003e7H
  000be	8d bc 24 31 1d
	00 00		 lea	 edi, DWORD PTR _PirecingBank$[esp+19001]
  000c5	f3 ab		 rep stosd
  000c7	66 ab		 stosw
  000c9	aa		 stosb
  000ca	c6 84 24 c8 0c
	00 00 00	 mov	 BYTE PTR _szPet$[esp+19000], 0
  000d2	33 c0		 xor	 eax, eax
  000d4	b9 19 04 00 00	 mov	 ecx, 1049		; 00000419H
  000d9	8d bc 24 c9 0c
	00 00		 lea	 edi, DWORD PTR _szPet$[esp+19001]
  000e0	f3 ab		 rep stosd
  000e2	8d 8c 24 d0 2c
	00 00		 lea	 ecx, DWORD PTR _Bank$[esp+19000]
  000e9	66 ab		 stosw
  000eb	51		 push	 ecx
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06BAMDHIIP@m_Bank?$AA@
  000f1	8b ce		 mov	 ecx, esi

; 456  : #else	// __PET_1024
; 457  : 			WORD wLife	= (WORD)GetIntFromStr( szPet, &CountStr );
; 458  : 			pPet->SetLife( wLife );
; 459  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )
; 460  : 			{
; 461  : 				BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );
; 462  : 				pPet->SetAvailLevel( i, nAvailLevel );
; 463  : 			}
; 464  : #endif	// __PET_1024
; 465  : 		}
; 466  : 		nId++;

  000f3	89 5c 24 20	 mov	 DWORD PTR $T217847[esp+19008], ebx
  000f7	aa		 stosb
  000f8	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  000fd	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _m_apIndexBank$[esp+19000]
  00104	52		 push	 edx
  00105	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KMLFLAAK@m_apIndex_Bank?$AA@
  0010a	8b ce		 mov	 ecx, esi
  0010c	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00111	8d 84 24 f8 02
	00 00		 lea	 eax, DWORD PTR _ObjIndexBank$[esp+19000]
  00118	50		 push	 eax
  00119	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@HHMCMCCB@m_dwObjIndex_Bank?$AA@
  0011e	8b ce		 mov	 ecx, esi
  00120	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00125	8d 8c 24 f8 04
	00 00		 lea	 ecx, DWORD PTR _ExtBank$[esp+19000]
  0012c	51		 push	 ecx
  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09CHFBCGKD@m_extBank?$AA@
  00132	8b ce		 mov	 ecx, esi
  00134	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00139	8d 94 24 30 1d
	00 00		 lea	 edx, DWORD PTR _PirecingBank$[esp+19000]
  00140	52		 push	 edx
  00141	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HANLGJJC@m_BankPiercing?$AA@
  00146	8b ce		 mov	 ecx, esi
  00148	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0014d	8d 84 24 c8 0c
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19000]
  00154	50		 push	 eax
  00155	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09DAKBPAHF@szBankPet?$AA@
  0015a	8b ce		 mov	 ecx, esi
  0015c	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00161	33 f6		 xor	 esi, esi
  00163	8d 84 24 d0 2c
	00 00		 lea	 eax, DWORD PTR _Bank$[esp+19000]
  0016a	89 74 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], esi
  0016e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L217870:
  00171	8a 08		 mov	 cl, BYTE PTR [eax]
  00173	40		 inc	 eax
  00174	84 c9		 test	 cl, cl
  00176	75 f9		 jne	 SHORT $L217870
  00178	2b c2		 sub	 eax, edx
  0017a	3b c6		 cmp	 eax, esi
  0017c	7e 0a		 jle	 SHORT $L217808
  0017e	80 bc 04 cf 2c
	00 00 24	 cmp	 BYTE PTR _Bank$[esp+eax+18999], 36 ; 00000024H
  00186	74 26		 je	 SHORT $L217852

; 325  : 	int CountStr	= 0;
; 326  : 	int itemCount	= 0;
; 327  : 	int	IndexItem	= 0;
; 328  : 	int IndexObjIndex	= 0;
; 329  : 	int nExtBankCount = 0;
; 330  : 	int nPirecingBankCount = 0;
; 331  : 	char Bank[7500]		= { 0, };
; 332  : 	char m_apIndexBank[512]		= { 0, };
; 333  : 	char ObjIndexBank[512]	= { 0, };
; 334  : 	char ExtBank[2000] = {0,};	
; 335  : 	char PirecingBank[4000] = {0,};
; 336  : #ifdef __PET_1024
; 337  : 	char szPet[4200]	= { 0,};
; 338  : #else	// __PET_1024
; 339  : 	char szPet[2688]	= { 0,};
; 340  : #endif	// __PET_1024
; 341  : 	
; 342  : 	qry->GetStr( "m_Bank", Bank );
; 343  : 	qry->GetStr( "m_apIndex_Bank", m_apIndexBank );
; 344  : 	qry->GetStr("m_dwObjIndex_Bank", ObjIndexBank );
; 345  : 	qry->GetStr( "m_extBank", ExtBank );
; 346  : 	qry->GetStr( "m_BankPiercing", PirecingBank );
; 347  : 	qry->GetStr( "szBankPet", szPet );
; 348  : 
; 349  : 	CountStr	= 0;	IndexItem	= 0;			
; 350  : 	VERIFYSTRING_BANK( Bank, pMover->m_szName );

$L217808:
  00188	8b 4c 24 10	 mov	 ecx, DWORD PTR $T217848[esp+19000]
  0018c	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0018f	51		 push	 ecx
  00190	68 5e 01 00 00	 push	 350			; 0000015eH
  00195	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0019a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  0019f	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  001a4	83 c4 10	 add	 esp, 16			; 00000010H
  001a7	33 c0		 xor	 eax, eax
  001a9	e9 cf 05 00 00	 jmp	 $L208728
$L217852:

; 351  : 	while( '$' != Bank[CountStr] )

  001ae	80 bc 24 d0 2c
	00 00 24	 cmp	 BYTE PTR _Bank$[esp+19000], 36 ; 00000024H
  001b6	0f 84 99 00 00
	00		 je	 $L208744
  001bc	8d 64 24 00	 npad	 4
$L208743:

; 352  : 	{
; 353  : 		CItemElem BufItemElem;

  001c0	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208745[esp+19000]
  001c4	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 354  : 		IndexItem = GetOneItem( &BufItemElem, Bank, &CountStr );

  001c9	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+19000]
  001cd	52		 push	 edx
  001ce	8d 84 24 d4 2c
	00 00		 lea	 eax, DWORD PTR _Bank$[esp+19004]
  001d5	50		 push	 eax
  001d6	8d 4c 24 28	 lea	 ecx, DWORD PTR _BufItemElem$208745[esp+19008]
  001da	51		 push	 ecx
  001db	8b cb		 mov	 ecx, ebx
  001dd	89 b4 24 40 4a
	00 00		 mov	 DWORD PTR __$EHRec$[esp+19020], esi
  001e4	e8 00 00 00 00	 call	 ?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z ; CDbManager::GetOneItem

; 355  : 		if( IndexItem == -1 )

  001e9	83 cf ff	 or	 edi, -1
  001ec	3b c7		 cmp	 eax, edi
  001ee	75 17		 jne	 SHORT $L208746

; 356  : 		{
; 357  : 			Error( "Bank = %s", Bank );

  001f0	8d 94 24 d0 2c
	00 00		 lea	 edx, DWORD PTR _Bank$[esp+19000]
  001f7	52		 push	 edx
  001f8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09EFEJAHGE@Bank?5?$DN?5?$CFs?$AA@
  001fd	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00202	83 c4 08	 add	 esp, 8

; 358  : 		}
; 359  : 		else

  00205	eb 2c		 jmp	 SHORT $L208748
$L208746:

; 360  : 		{
; 361  : 			if( IndexItem >= MAX_BANK )

  00207	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0020a	0f 8d 90 00 00
	00		 jge	 $L217859

; 365  : 			}
; 366  : 			pMover->m_Bank[nSlot].m_apItem[IndexItem] = BufItemElem;

  00210	8b 4d 10	 mov	 ecx, DWORD PTR _nSlot$[ebp]
  00213	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00216	8b 44 24 10	 mov	 eax, DWORD PTR $T217848[esp+19000]
  0021a	8d 8c 89 68 10
	00 00		 lea	 ecx, DWORD PTR [ecx+ecx*4+4200]
  00221	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00224	c1 e2 05	 shl	 edx, 5
  00227	03 ca		 add	 ecx, edx
  00229	8b 11		 mov	 edx, DWORD PTR [ecx]
  0022b	8d 44 24 20	 lea	 eax, DWORD PTR _BufItemElem$208745[esp+19000]
  0022f	50		 push	 eax
  00230	ff 52 10	 call	 DWORD PTR [edx+16]
$L208748:

; 367  : 		}
; 368  : 	}

  00233	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208745[esp+19000]
  00237	89 bc 24 34 4a
	00 00		 mov	 DWORD PTR __$EHRec$[esp+19008], edi
  0023e	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  00243	8b 4c 24 0c	 mov	 ecx, DWORD PTR _CountStr$[esp+19000]
  00247	80 bc 0c d0 2c
	00 00 24	 cmp	 BYTE PTR _Bank$[esp+ecx+19000], 36 ; 00000024H
  0024f	0f 85 6b ff ff
	ff		 jne	 $L208743
$L208744:

; 369  : 	
; 370  : 	CountStr	= 0;	itemCount	= 0;
; 371  : 	VERIFYSTRING_BANK( m_apIndexBank, pMover->m_szName );

  00255	8d 84 24 f8 00
	00 00		 lea	 eax, DWORD PTR _m_apIndexBank$[esp+19000]
  0025c	89 74 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], esi
  00260	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L217871:
  00263	8a 08		 mov	 cl, BYTE PTR [eax]
  00265	40		 inc	 eax
  00266	84 c9		 test	 cl, cl
  00268	75 f9		 jne	 SHORT $L217871
  0026a	2b c2		 sub	 eax, edx
  0026c	3b c6		 cmp	 eax, esi
  0026e	7e 0a		 jle	 SHORT $L217816
  00270	80 bc 04 f7 00
	00 00 24	 cmp	 BYTE PTR _m_apIndexBank$[esp+eax+18999], 36 ; 00000024H
  00278	74 52		 je	 SHORT $L217853
$L217816:
  0027a	8b 44 24 10	 mov	 eax, DWORD PTR $T217848[esp+19000]
  0027e	83 c0 6c	 add	 eax, 108		; 0000006cH
  00281	50		 push	 eax
  00282	68 73 01 00 00	 push	 371			; 00000173H
  00287	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0028c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  00291	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00296	83 c4 10	 add	 esp, 16			; 00000010H
  00299	33 c0		 xor	 eax, eax
  0029b	e9 dd 04 00 00	 jmp	 $L208728
$L217859:

; 362  : 			{
; 363  : 				Error( "Bank = %s", Bank );

  002a0	8d 94 24 d0 2c
	00 00		 lea	 edx, DWORD PTR _Bank$[esp+19000]
  002a7	52		 push	 edx
  002a8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09EFEJAHGE@Bank?5?$DN?5?$CFs?$AA@
  002ad	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  002b2	83 c4 08	 add	 esp, 8

; 364  : 				return FALSE;

  002b5	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208745[esp+19000]
  002b9	89 bc 24 34 4a
	00 00		 mov	 DWORD PTR __$EHRec$[esp+19008], edi
  002c0	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  002c5	33 c0		 xor	 eax, eax
  002c7	e9 b1 04 00 00	 jmp	 $L208728
$L217853:

; 372  : 	while( '$' != m_apIndexBank[CountStr] )

  002cc	80 bc 24 f8 00
	00 00 24	 cmp	 BYTE PTR _m_apIndexBank$[esp+19000], 36 ; 00000024H
  002d4	8b 7c 24 10	 mov	 edi, DWORD PTR $T217848[esp+19000]
  002d8	8b 5d 10	 mov	 ebx, DWORD PTR _nSlot$[ebp]
  002db	74 45		 je	 SHORT $L208754
  002dd	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  002e0	8d 94 8f 98 41
	00 00		 lea	 edx, DWORD PTR [edi+ecx*4+16792]
  002e7	89 54 24 14	 mov	 DWORD PTR tv618[esp+19000], edx
  002eb	eb 03 8d 49 00	 npad	 5
$L208753:

; 373  : 	{
; 374  : 		pMover->m_Bank[nSlot].m_apIndex[itemCount]		= (DWORD)GetIntFromStr( m_apIndexBank, &CountStr );

  002f0	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  002f4	50		 push	 eax
  002f5	8d 8c 24 fc 00
	00 00		 lea	 ecx, DWORD PTR _m_apIndexBank$[esp+19004]
  002fc	51		 push	 ecx
  002fd	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00302	8b 54 24 1c	 mov	 edx, DWORD PTR tv618[esp+19008]
  00306	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00308	8b 54 24 14	 mov	 edx, DWORD PTR _CountStr$[esp+19008]
  0030c	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax
  0030f	8a 84 14 00 01
	00 00		 mov	 al, BYTE PTR _m_apIndexBank$[esp+edx+19008]
  00316	83 c4 08	 add	 esp, 8

; 375  : 		itemCount++;

  00319	83 c6 04	 add	 esi, 4
  0031c	3c 24		 cmp	 al, 36			; 00000024H
  0031e	75 d0		 jne	 SHORT $L208753

; 372  : 	while( '$' != m_apIndexBank[CountStr] )

  00320	33 f6		 xor	 esi, esi
$L208754:

; 376  : 	}
; 377  : 	
; 378  : 	CountStr	= 0;	IndexObjIndex	= 0;
; 379  : 	VERIFYSTRING_BANK( ObjIndexBank, pMover->m_szName );

  00322	8d 84 24 f8 02
	00 00		 lea	 eax, DWORD PTR _ObjIndexBank$[esp+19000]
  00329	89 74 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], esi
  0032d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L217872:
  00330	8a 08		 mov	 cl, BYTE PTR [eax]
  00332	40		 inc	 eax
  00333	84 c9		 test	 cl, cl
  00335	75 f9		 jne	 SHORT $L217872
  00337	2b c2		 sub	 eax, edx
  00339	3b c6		 cmp	 eax, esi
  0033b	7e 0a		 jle	 SHORT $L217824
  0033d	80 bc 04 f7 02
	00 00 24	 cmp	 BYTE PTR _ObjIndexBank$[esp+eax+18999], 36 ; 00000024H
  00345	74 22		 je	 SHORT $L217854
$L217824:
  00347	83 c7 6c	 add	 edi, 108		; 0000006cH
  0034a	57		 push	 edi
  0034b	68 7b 01 00 00	 push	 379			; 0000017bH
  00350	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00355	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  0035a	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  0035f	83 c4 10	 add	 esp, 16			; 00000010H
$L217878:
  00362	33 c0		 xor	 eax, eax
  00364	e9 14 04 00 00	 jmp	 $L208728
$L217854:

; 380  : 	while( '$' != ObjIndexBank[CountStr] )

  00369	80 bc 24 f8 02
	00 00 24	 cmp	 BYTE PTR _ObjIndexBank$[esp+19000], 36 ; 00000024H
  00371	74 43		 je	 SHORT $L208759
  00373	8d 84 9b 68 10
	00 00		 lea	 eax, DWORD PTR [ebx+ebx*4+4200]
  0037a	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  0037d	33 f6		 xor	 esi, esi
  0037f	90		 npad	 1
$L208758:

; 381  : 	{
; 382  : 		pMover->m_Bank[nSlot].m_apItem[IndexObjIndex].m_dwObjIndex		= (DWORD)GetIntFromStr( ObjIndexBank, &CountStr );

  00380	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+19000]
  00384	51		 push	 ecx
  00385	8d 94 24 fc 02
	00 00		 lea	 edx, DWORD PTR _ObjIndexBank$[esp+19004]
  0038c	52		 push	 edx
  0038d	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00392	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00394	8b 54 24 14	 mov	 edx, DWORD PTR _CountStr$[esp+19008]
  00398	89 44 0e 2c	 mov	 DWORD PTR [esi+ecx+44], eax
  0039c	8a 84 14 00 03
	00 00		 mov	 al, BYTE PTR _ObjIndexBank$[esp+edx+19008]
  003a3	83 c4 08	 add	 esp, 8

; 383  : 		IndexObjIndex++;

  003a6	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  003ac	3c 24		 cmp	 al, 36			; 00000024H
  003ae	75 d0		 jne	 SHORT $L208758
  003b0	8b 7c 24 10	 mov	 edi, DWORD PTR $T217848[esp+19000]
  003b4	33 f6		 xor	 esi, esi
$L208759:

; 384  : 	}
; 385  : 	
; 386  : 	CountStr	= 0; 	nExtBankCount	= 0;
; 387  : 	VERIFYSTRING_BANK( ExtBank, pMover->m_szName );

  003b6	8b 4c 24 18	 mov	 ecx, DWORD PTR $T217847[esp+19000]
  003ba	6a 00		 push	 0
  003bc	89 74 24 10	 mov	 DWORD PTR _CountStr$[esp+19004], esi
  003c0	8d 77 6c	 lea	 esi, DWORD PTR [edi+108]
  003c3	56		 push	 esi
  003c4	68 83 01 00 00	 push	 387			; 00000183H
  003c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  003ce	8d 84 24 08 05
	00 00		 lea	 eax, DWORD PTR _ExtBank$[esp+19016]
  003d5	50		 push	 eax
  003d6	89 74 24 28	 mov	 DWORD PTR tv582[esp+19020], esi
  003da	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  003df	85 c0		 test	 eax, eax
  003e1	0f 84 7b ff ff
	ff		 je	 $L217878

; 388  : 	while( '$' != ExtBank[CountStr] )

  003e7	80 bc 24 f8 04
	00 00 24	 cmp	 BYTE PTR _ExtBank$[esp+19000], 36 ; 00000024H
  003ef	0f 84 c7 00 00
	00		 je	 $L208764
  003f5	8d 8c 9b 68 10
	00 00		 lea	 ecx, DWORD PTR [ebx+ebx*4+4200]
  003fc	8d 3c 8f	 lea	 edi, DWORD PTR [edi+ecx*4]
  003ff	33 f6		 xor	 esi, esi
$L208763:

; 389  : 	{
; 390  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bCharged			= (BOOL)GetIntPaFromStr( ExtBank, &CountStr );

  00401	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+19000]
  00405	52		 push	 edx
  00406	8d 84 24 fc 04
	00 00		 lea	 eax, DWORD PTR _ExtBank$[esp+19004]
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00413	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00415	89 84 0e 88 00
	00 00		 mov	 DWORD PTR [esi+ecx+136], eax

; 391  : 		if( pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bCharged != 1 )

  0041c	8b 17		 mov	 edx, DWORD PTR [edi]
  0041e	8b 84 16 88 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+136]
  00425	83 c4 08	 add	 esp, 8
  00428	83 f8 01	 cmp	 eax, 1
  0042b	74 0d		 je	 SHORT $L208766

; 392  : 			pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bCharged	= 0;

  0042d	8b c2		 mov	 eax, edx
  0042f	c7 84 06 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+136], 0
$L208766:

; 393  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_dwKeepTime		= (DWORD)GetIntPaFromStr( ExtBank, &CountStr );

  0043a	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+19000]
  0043e	51		 push	 ecx
  0043f	8d 94 24 fc 04
	00 00		 lea	 edx, DWORD PTR _ExtBank$[esp+19004]
  00446	52		 push	 edx
  00447	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  0044c	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 394  : #if __VER >= 11 // __SYS_IDENTIFY
; 395  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].SetRandomOptItemId( GetInt64PaFromStr( ExtBank, &CountStr ) );

  0044e	8d 54 24 14	 lea	 edx, DWORD PTR _CountStr$[esp+19008]
  00452	89 84 0e 8c 00
	00 00		 mov	 DWORD PTR [esi+ecx+140], eax
  00459	52		 push	 edx
  0045a	8d 84 24 04 05
	00 00		 lea	 eax, DWORD PTR _ExtBank$[esp+19012]
  00461	50		 push	 eax
  00462	e8 00 00 00 00	 call	 ?GetInt64PaFromStr@@YA_JPADPAH@Z ; GetInt64PaFromStr
  00467	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00469	03 ce		 add	 ecx, esi
  0046b	89 91 94 00 00
	00		 mov	 DWORD PTR [ecx+148], edx
  00471	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 396  : #else	// __SYS_IDENTIFY
; 397  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].SetRandomOptItemId( (DWORD)GetIntPaFromStr( ExtBank, &CountStr ) );
; 398  : #endif	// __SYS_IDENTIFY
; 399  : #if __VER >= 15 // __PETVIS
; 400  : 		pMover->m_Bank[nSlot].m_apItem[nExtBankCount].m_bTranformVisPet = static_cast<BOOL>( GetIntPaFromStr( ExtBank, &CountStr ) );

  00477	8d 4c 24 1c	 lea	 ecx, DWORD PTR _CountStr$[esp+19016]
  0047b	51		 push	 ecx
  0047c	8d 94 24 0c 05
	00 00		 lea	 edx, DWORD PTR _ExtBank$[esp+19020]
  00483	52		 push	 edx
  00484	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00489	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0048b	89 84 0e 9c 00
	00 00		 mov	 DWORD PTR [esi+ecx+156], eax

; 401  : #endif // __PETVIS
; 402  : 		++CountStr;

  00492	8b 44 24 24	 mov	 eax, DWORD PTR _CountStr$[esp+19024]
  00496	8a 8c 04 11 05
	00 00		 mov	 cl, BYTE PTR _ExtBank$[esp+eax+19025]
  0049d	83 c4 18	 add	 esp, 24			; 00000018H
  004a0	40		 inc	 eax

; 403  : 		++nExtBankCount;

  004a1	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  004a7	80 f9 24	 cmp	 cl, 36			; 00000024H
  004aa	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+19000], eax
  004ae	0f 85 4d ff ff
	ff		 jne	 $L208763
  004b4	8b 74 24 14	 mov	 esi, DWORD PTR tv582[esp+19000]
  004b8	8b 7c 24 10	 mov	 edi, DWORD PTR $T217848[esp+19000]
$L208764:

; 404  : 	}
; 405  : 	
; 406  : 	CountStr	= 0;
; 407  : 	nPirecingBankCount = 0;
; 408  : 	VERIFYSTRING_BANK( PirecingBank, pMover->m_szName );

  004bc	8b 4c 24 18	 mov	 ecx, DWORD PTR $T217847[esp+19000]
  004c0	6a 00		 push	 0
  004c2	56		 push	 esi
  004c3	68 98 01 00 00	 push	 408			; 00000198H
  004c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  004cd	8d 94 24 40 1d
	00 00		 lea	 edx, DWORD PTR _PirecingBank$[esp+19016]
  004d4	52		 push	 edx
  004d5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+19020], 0
  004dd	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  004e2	85 c0		 test	 eax, eax
  004e4	0f 84 78 fe ff
	ff		 je	 $L217878

; 409  : 	while( '$' != PirecingBank[CountStr] )

  004ea	80 bc 24 30 1d
	00 00 24	 cmp	 BYTE PTR _PirecingBank$[esp+19000], 36 ; 00000024H
  004f2	74 40		 je	 SHORT $L208772
  004f4	8d 84 9b 68 10
	00 00		 lea	 eax, DWORD PTR [ebx+ebx*4+4200]
  004fb	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  004fe	33 f6		 xor	 esi, esi
$L208771:

; 410  : 	{
; 411  : #if __VER >= 12 // __EXT_PIERCING
; 412  : 		LoadPiercingInfo( pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount], PirecingBank, &CountStr );

  00500	8b 07		 mov	 eax, DWORD PTR [edi]
  00502	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+19000]
  00506	51		 push	 ecx
  00507	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T217847[esp+19004]
  0050b	8d 94 24 34 1d
	00 00		 lea	 edx, DWORD PTR _PirecingBank$[esp+19004]
  00512	52		 push	 edx
  00513	03 c6		 add	 eax, esi
  00515	50		 push	 eax
  00516	e8 00 00 00 00	 call	 ?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z ; CDbManager::LoadPiercingInfo
  0051b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _CountStr$[esp+19000]
  0051f	8a 84 0c 30 1d
	00 00		 mov	 al, BYTE PTR _PirecingBank$[esp+ecx+19000]

; 413  : #else // __EXT_PIERCING
; 414  : 		int nItemIdCount = 0;
; 415  : 		pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount].SetPiercingSize( GetIntFromStr( PirecingBank, &CountStr ) );
; 416  : 		for( int i = 0 ; i < pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount].GetPiercingSize(); ++i )
; 417  : 		{
; 418  : 			pMover->m_Bank[nSlot].m_apItem[nPirecingBankCount].SetPiercingItem( nItemIdCount, (DWORD)GetIntFromStr( PirecingBank, &CountStr ) );
; 419  : 			++nItemIdCount;
; 420  : 		}
; 421  : #endif // __EXT_PIERCING
; 422  : 		++nPirecingBankCount;

  00526	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  0052c	3c 24		 cmp	 al, 36			; 00000024H
  0052e	75 d0		 jne	 SHORT $L208771

; 409  : 	while( '$' != PirecingBank[CountStr] )

  00530	8b 74 24 14	 mov	 esi, DWORD PTR tv582[esp+19000]
$L208772:

; 423  : 	}
; 424  : 
; 425  : 	CountStr	= 0;
; 426  : 	int	nId	= 0;
; 427  : 	VERIFYSTRING_BANK( szPet, pMover->m_szName );

  00534	8b 4c 24 18	 mov	 ecx, DWORD PTR $T217847[esp+19000]
  00538	33 db		 xor	 ebx, ebx
  0053a	53		 push	 ebx
  0053b	56		 push	 esi
  0053c	68 ab 01 00 00	 push	 427			; 000001abH
  00541	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00546	8d 94 24 d8 0c
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19016]
  0054d	52		 push	 edx
  0054e	89 5c 24 20	 mov	 DWORD PTR _CountStr$[esp+19020], ebx
  00552	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00557	85 c0		 test	 eax, eax
  00559	0f 84 03 fe ff
	ff		 je	 $L217878

; 428  : 	while( '$' != szPet[CountStr] )

  0055f	80 bc 24 c8 0c
	00 00 24	 cmp	 BYTE PTR _szPet$[esp+19000], 36 ; 00000024H
  00567	0f 84 0b 02 00
	00		 je	 $L208777
  0056d	8d 49 00	 npad	 3
$L208776:

; 429  : 	{
; 430  : 		BOOL bPet	= (BOOL)GetIntFromStr( szPet, &CountStr );

  00570	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  00574	50		 push	 eax
  00575	8d 8c 24 cc 0c
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19004]
  0057c	51		 push	 ecx
  0057d	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 431  : 		if( bPet )

  00582	33 f6		 xor	 esi, esi
  00584	83 c4 08	 add	 esp, 8
  00587	3b c6		 cmp	 eax, esi
  00589	0f 84 cf 01 00
	00		 je	 $L208780

; 432  : 		{
; 433  : 			SAFE_DELETE( pMover->m_Bank[nSlot].m_apItem[nId].m_pPet );

  0058f	8b 45 10	 mov	 eax, DWORD PTR _nSlot$[ebp]
  00592	8d 94 80 68 10
	00 00		 lea	 edx, DWORD PTR [eax+eax*4+4200]
  00599	8b 44 24 10	 mov	 eax, DWORD PTR $T217848[esp+19000]
  0059d	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  005a0	8b 8c 0b 98 00
	00 00		 mov	 ecx, DWORD PTR [ebx+ecx+152]
  005a7	3b ce		 cmp	 ecx, esi
  005a9	8d 3c 90	 lea	 edi, DWORD PTR [eax+edx*4]
  005ac	74 0f		 je	 SHORT $L208781
  005ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  005b0	6a 01		 push	 1
  005b2	ff 12		 call	 DWORD PTR [edx]
  005b4	8b 07		 mov	 eax, DWORD PTR [edi]
  005b6	89 b4 03 98 00
	00 00		 mov	 DWORD PTR [ebx+eax+152], esi
$L208781:

; 434  : 			CPet* pPet	= pMover->m_Bank[nSlot].m_apItem[nId].m_pPet		= new CPet;

  005bd	6a 28		 push	 40			; 00000028H
  005bf	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  005c4	83 c4 04	 add	 esp, 4
  005c7	89 44 24 1c	 mov	 DWORD PTR $T217800[esp+19000], eax
  005cb	3b c6		 cmp	 eax, esi
  005cd	c7 84 24 34 4a
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+19008], 1
  005d8	74 09		 je	 SHORT $L217802
  005da	8b c8		 mov	 ecx, eax
  005dc	e8 00 00 00 00	 call	 ??0CPet@@QAE@XZ		; CPet::CPet
  005e1	8b f0		 mov	 esi, eax
$L217802:
  005e3	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 435  : 			BYTE nKind	= (BYTE)GetIntFromStr( szPet, &CountStr );

  005e5	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+19000]
  005e9	52		 push	 edx
  005ea	8d 84 24 cc 0c
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19004]
  005f1	50		 push	 eax
  005f2	c7 84 24 3c 4a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+19016], -1
  005fd	89 b4 0b 98 00
	00 00		 mov	 DWORD PTR [ebx+ecx+152], esi
  00604	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 436  : 			pPet->SetKind( nKind );
; 437  : 			BYTE nLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );

  00609	8d 4c 24 14	 lea	 ecx, DWORD PTR _CountStr$[esp+19008]
  0060d	51		 push	 ecx
  0060e	8d 94 24 d4 0c
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19012]
  00615	52		 push	 edx
  00616	88 46 04	 mov	 BYTE PTR [esi+4], al
  00619	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 438  : 			pPet->SetLevel( nLevel );

  0061e	88 46 05	 mov	 BYTE PTR [esi+5], al

; 439  : 			DWORD dwExp	= (DWORD)GetIntFromStr( szPet, &CountStr );

  00621	8d 44 24 1c	 lea	 eax, DWORD PTR _CountStr$[esp+19016]
  00625	50		 push	 eax
  00626	8d 8c 24 dc 0c
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19020]
  0062d	51		 push	 ecx
  0062e	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00633	83 c4 18	 add	 esp, 24			; 00000018H

; 440  : 			pPet->SetExp( dwExp );

  00636	50		 push	 eax
  00637	8b ce		 mov	 ecx, esi
  00639	e8 00 00 00 00	 call	 ?SetExp@CPet@@QAEXK@Z	; CPet::SetExp

; 441  : 			WORD wEnergy	= (WORD)GetIntFromStr( szPet, &CountStr );

  0063e	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+19000]
  00642	52		 push	 edx
  00643	8d 84 24 cc 0c
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19004]
  0064a	50		 push	 eax
  0064b	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00650	83 c4 08	 add	 esp, 8

; 442  : 			pPet->SetEnergy( wEnergy );

  00653	50		 push	 eax
  00654	8b ce		 mov	 ecx, esi
  00656	e8 00 00 00 00	 call	 ?SetEnergy@CPet@@QAEXG@Z ; CPet::SetEnergy

; 443  : #ifdef __PET_1024
; 444  : 			WORD wLife	= (WORD)GetIntPaFromStr( szPet, &CountStr );

  0065b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+19000]
  0065f	51		 push	 ecx
  00660	8d 94 24 cc 0c
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19004]
  00667	52		 push	 edx
  00668	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 445  : 			pPet->SetLife( wLife );

  0066d	66 89 46 0e	 mov	 WORD PTR [esi+14], ax

; 446  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )

  00671	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00674	83 c4 08	 add	 esp, 8
  00677	3c 01		 cmp	 al, 1
  00679	bf 01 00 00 00	 mov	 edi, 1
  0067e	72 2f		 jb	 SHORT $L208803
$L208801:

; 447  : 			{
; 448  : 				BYTE nAvailLevel	= (BYTE)GetIntPaFromStr( szPet, &CountStr );

  00680	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+19000]
  00684	50		 push	 eax
  00685	8d 8c 24 cc 0c
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19004]
  0068c	51		 push	 ecx
  0068d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00692	88 44 24 1c	 mov	 BYTE PTR _nAvailLevel$208804[esp+19008], al

; 449  : 				pPet->SetAvailLevel( i, nAvailLevel );

  00696	8b 54 24 1c	 mov	 edx, DWORD PTR _nAvailLevel$208804[esp+19008]
  0069a	83 c4 08	 add	 esp, 8
  0069d	52		 push	 edx
  0069e	57		 push	 edi
  0069f	8b ce		 mov	 ecx, esi
  006a1	e8 00 00 00 00	 call	 ?SetAvailLevel@CPet@@QAEXEE@Z ; CPet::SetAvailLevel
  006a6	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  006aa	47		 inc	 edi
  006ab	3b f8		 cmp	 edi, eax
  006ad	7e d1		 jle	 SHORT $L208801
$L208803:

; 450  : 			}
; 451  : 			char szFmt[MAX_PET_NAME_FMT]	= { 0,};

  006af	33 c9		 xor	 ecx, ecx
  006b1	89 8c 24 d5 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19001], ecx
  006b8	89 8c 24 d9 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19005], ecx
  006bf	89 8c 24 dd 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19009], ecx
  006c6	89 8c 24 e1 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19013], ecx
  006cd	89 8c 24 e5 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19017], ecx
  006d4	89 8c 24 e9 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19021], ecx
  006db	89 8c 24 ed 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19025], ecx

; 452  : 			GetStrFromStr( szPet, szFmt, &CountStr );

  006e2	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+19000]
  006e6	52		 push	 edx
  006e7	8d 84 24 d8 00
	00 00		 lea	 eax, DWORD PTR _szFmt$208806[esp+19004]
  006ee	89 8c 24 f5 00
	00 00		 mov	 DWORD PTR _szFmt$208806[esp+19033], ecx
  006f5	50		 push	 eax
  006f6	8d 8c 24 d0 0c
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19008]
  006fd	51		 push	 ecx
  006fe	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR _szFmt$208806[esp+19012], 0
  00706	e8 00 00 00 00	 call	 ?GetStrFromStr@@YAXPAD0PAH@Z ; GetStrFromStr
  0070b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 453  : 			char szName[MAX_PET_NAME]	= { 0,};

  0070e	33 d2		 xor	 edx, edx

; 454  : 			GetDBFormatStr( szName, MAX_PET_NAME, szFmt );

  00710	8d 84 24 d4 00
	00 00		 lea	 eax, DWORD PTR _szFmt$208806[esp+19000]
  00717	89 94 24 c1 00
	00 00		 mov	 DWORD PTR _szName$208807[esp+19001], edx
  0071e	50		 push	 eax
  0071f	89 94 24 c9 00
	00 00		 mov	 DWORD PTR _szName$208807[esp+19009], edx
  00726	6a 11		 push	 17			; 00000011H
  00728	8d 8c 24 c8 00
	00 00		 lea	 ecx, DWORD PTR _szName$208807[esp+19008]
  0072f	89 94 24 d1 00
	00 00		 mov	 DWORD PTR _szName$208807[esp+19017], edx
  00736	51		 push	 ecx
  00737	8b 4c 24 24	 mov	 ecx, DWORD PTR $T217847[esp+19012]
  0073b	c6 84 24 cc 00
	00 00 00	 mov	 BYTE PTR _szName$208807[esp+19012], 0
  00743	89 94 24 d9 00
	00 00		 mov	 DWORD PTR _szName$208807[esp+19025], edx
  0074a	e8 00 00 00 00	 call	 ?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z ; CDbManager::GetDBFormatStr

; 455  : 			pPet->SetName( szName );

  0074f	8d 94 24 c0 00
	00 00		 lea	 edx, DWORD PTR _szName$208807[esp+19000]
  00756	52		 push	 edx
  00757	8b ce		 mov	 ecx, esi
  00759	e8 00 00 00 00	 call	 ?SetName@CPet@@QAEXPBD@Z ; CPet::SetName
$L208780:
  0075e	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+19000]
  00762	8a 8c 04 c8 0c
	00 00		 mov	 cl, BYTE PTR _szPet$[esp+eax+19000]

; 456  : #else	// __PET_1024
; 457  : 			WORD wLife	= (WORD)GetIntFromStr( szPet, &CountStr );
; 458  : 			pPet->SetLife( wLife );
; 459  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )
; 460  : 			{
; 461  : 				BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );
; 462  : 				pPet->SetAvailLevel( i, nAvailLevel );
; 463  : 			}
; 464  : #endif	// __PET_1024
; 465  : 		}
; 466  : 		nId++;

  00769	81 c3 a0 00 00
	00		 add	 ebx, 160		; 000000a0H
  0076f	80 f9 24	 cmp	 cl, 36			; 00000024H
  00772	0f 85 f8 fd ff
	ff		 jne	 $L208776
$L208777:

; 467  : 	}
; 468  : 	return TRUE;

  00778	b8 01 00 00 00	 mov	 eax, 1
$L208728:

; 469  : }

  0077d	8b 8c 24 2c 4a
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+19000]
  00784	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0078b	8b 8c 24 24 4a
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+19000]
  00792	5f		 pop	 edi
  00793	5e		 pop	 esi
  00794	33 cd		 xor	 ecx, ebp
  00796	5b		 pop	 ebx
  00797	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0079c	8b e5		 mov	 esp, ebp
  0079e	5d		 pop	 ebp
  0079f	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L217803:
  00000	8d 8d e8 b5 ff
	ff		 lea	 ecx, DWORD PTR _BufItemElem$208745[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L217804:
  0000b	8b 85 e4 b5 ff
	ff		 mov	 eax, DWORD PTR $T217800[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
  00018	c3		 ret	 0
__ehhandler$?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z:
  00019	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T217851
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z ENDP ; CDbManager::GetBankMover
PUBLIC	?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z ; CDbManager::GetGuildBank
PUBLIC	??_C@_0M@GKPNPIJD@m_GuildBank?$AA@		; `string'
PUBLIC	??_C@_0P@KBFNBDP@GuildBank?5?$DN?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0P@CLIOIOKN@m_extGuildBank?$AA@		; `string'
PUBLIC	??_C@_0BE@FOMLDJLH@m_GuildBankPiercing?$AA@	; `string'
PUBLIC	??_C@_0P@MOKIMIMD@szGuildBankPet?$AA@		; `string'
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
xdata$x	SEGMENT
$T217933 DD	0ffffffffH
	DD	FLAT:$L217892
	DD	0ffffffffH
	DD	FLAT:$L217893
$T217915 DD	019930520H
	DD	02H
	DD	FLAT:$T217933
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0M@GKPNPIJD@m_GuildBank?$AA@
CONST	SEGMENT
??_C@_0M@GKPNPIJD@m_GuildBank?$AA@ DB 'm_GuildBank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CLIOIOKN@m_extGuildBank?$AA@
CONST	SEGMENT
??_C@_0P@CLIOIOKN@m_extGuildBank?$AA@ DB 'm_extGuildBank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOMLDJLH@m_GuildBankPiercing?$AA@
CONST	SEGMENT
??_C@_0BE@FOMLDJLH@m_GuildBankPiercing?$AA@ DB 'm_GuildBankPiercing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOKIMIMD@szGuildBankPet?$AA@
CONST	SEGMENT
??_C@_0P@MOKIMIMD@szGuildBankPet?$AA@ DB 'szGuildBankPet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBFNBDP@GuildBank?5?$DN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@KBFNBDP@GuildBank?5?$DN?5?$CFs?$AA@ DB 'GuildBank = %s', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z
_TEXT	SEGMENT
_CountStr$ = -17964					; size = 4
tv621 = -17960						; size = 4
$T217913 = -17960					; size = 4
$T217911 = -17956					; size = 4
_nAvailLevel$208875 = -17952				; size = 1
$T217889 = -17948					; size = 4
_BufItemElem$208820 = -17944				; size = 160
_szName$208878 = -17784					; size = 17
_szFmt$208877 = -17764					; size = 33
_ExtBank$ = -17728					; size = 2000
_szPet$ = -15728					; size = 4200
_PirecingBank$ = -11528					; size = 4000
_Bank$ = -7528						; size = 7500
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_GuildBank$ = 8						; size = 4
_qry$ = 12						; size = 4
?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z PROC NEAR ; CDbManager::GetGuildBank, COMDAT
; _this$ = ecx

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	51		 push	 ecx
  0001c	b8 1c 46 00 00	 mov	 eax, 17948		; 0000461cH
  00021	e8 00 00 00 00	 call	 __chkstk
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _qry$[ebp]
  0002e	53		 push	 ebx
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR _GuildBank$[ebp]
  00032	33 c5		 xor	 eax, ebp
  00034	56		 push	 esi
  00035	57		 push	 edi
  00036	89 84 24 24 46
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+17976], eax
  0003d	8b f1		 mov	 esi, ecx

; 473  : 	int CountStr		= 0;
; 474  : 	int IndexItem		= 0;
; 475  : 	char	Bank[7500]		= { 0, };

  0003f	33 c0		 xor	 eax, eax
  00041	c6 84 24 d0 28
	00 00 00	 mov	 BYTE PTR _Bank$[esp+17976], 0
  00049	b9 52 07 00 00	 mov	 ecx, 1874		; 00000752H
  0004e	8d bc 24 d1 28
	00 00		 lea	 edi, DWORD PTR _Bank$[esp+17977]
  00055	f3 ab		 rep stosd
  00057	66 ab		 stosw
  00059	aa		 stosb

; 476  : 	qry->GetStr( "m_GuildBank", Bank );

  0005a	8d 84 24 d0 28
	00 00		 lea	 eax, DWORD PTR _Bank$[esp+17976]
  00061	50		 push	 eax
  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@GKPNPIJD@m_GuildBank?$AA@
  00067	8b ca		 mov	 ecx, edx

; 575  : #else	// __PET_1024
; 576  : 			WORD wLife	= (WORD)GetIntFromStr( szPet, &CountStr );
; 577  : 			pPet->SetLife( wLife );
; 578  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )
; 579  : 			{
; 580  : 				BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );
; 581  : 				pPet->SetAvailLevel( i, nAvailLevel );
; 582  : 			}
; 583  : #endif	// __PET_1024
; 584  : 		}
; 585  : 		nId++;

  00069	89 74 24 1c	 mov	 DWORD PTR $T217911[esp+17984], esi
  0006d	89 54 24 18	 mov	 DWORD PTR $T217913[esp+17984], edx
  00071	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17984], 0
  00079	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0007e	80 bc 24 d0 28
	00 00 24	 cmp	 BYTE PTR _Bank$[esp+17976], 36 ; 00000024H
  00086	74 79		 je	 SHORT $L208819
  00088	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L208818:

; 477  : 	while( '$' != Bank[CountStr] )
; 478  : 	{
; 479  : 		CItemElem BufItemElem;

  00090	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208820[esp+17976]
  00094	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 480  : 		IndexItem = GetOneItem( &BufItemElem, Bank, &CountStr );

  00099	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17976]
  0009d	51		 push	 ecx
  0009e	8d 94 24 d4 28
	00 00		 lea	 edx, DWORD PTR _Bank$[esp+17980]
  000a5	52		 push	 edx
  000a6	8d 44 24 28	 lea	 eax, DWORD PTR _BufItemElem$208820[esp+17984]
  000aa	50		 push	 eax
  000ab	8b ce		 mov	 ecx, esi
  000ad	c7 84 24 40 46
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+17996], 0
  000b8	e8 00 00 00 00	 call	 ?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z ; CDbManager::GetOneItem

; 481  : 		if( IndexItem == -1 )

  000bd	83 cf ff	 or	 edi, -1
  000c0	3b c7		 cmp	 eax, edi
  000c2	74 1f		 je	 SHORT $L208822

; 482  : 		{
; 483  : 			
; 484  : 		}
; 485  : 		else
; 486  : 		{
; 487  : 			if( IndexItem >= MAX_GUILDBANK )

  000c4	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  000c7	0f 8d 39 04 00
	00		 jge	 $L217921

; 491  : 			}
; 492  : 			GuildBank->m_apItem[IndexItem] = BufItemElem;

  000cd	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  000d0	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000d3	c1 e1 05	 shl	 ecx, 5
  000d6	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  000d9	03 ca		 add	 ecx, edx
  000db	8d 54 24 20	 lea	 edx, DWORD PTR _BufItemElem$208820[esp+17976]
  000df	52		 push	 edx
  000e0	ff 50 10	 call	 DWORD PTR [eax+16]
$L208822:

; 493  : 		}
; 494  : 	}

  000e3	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208820[esp+17976]
  000e7	89 bc 24 34 46
	00 00		 mov	 DWORD PTR __$EHRec$[esp+17984], edi
  000ee	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  000f3	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+17976]
  000f7	80 bc 04 d0 28
	00 00 24	 cmp	 BYTE PTR _Bank$[esp+eax+17976], 36 ; 00000024H
  000ff	75 8f		 jne	 SHORT $L208818
$L208819:

; 496  : 	int nExtBank = 0;
; 497  : 	char ExtBank[2000] = {0,};

  00101	c6 84 24 f8 00
	00 00 00	 mov	 BYTE PTR _ExtBank$[esp+17976], 0
  00109	33 c0		 xor	 eax, eax
  0010b	b9 f3 01 00 00	 mov	 ecx, 499		; 000001f3H
  00110	8d bc 24 f9 00
	00 00		 lea	 edi, DWORD PTR _ExtBank$[esp+17977]
  00117	f3 ab		 rep stosd

; 498  : 	qry->GetStr( "m_extGuildBank", ExtBank );

  00119	8b 4c 24 10	 mov	 ecx, DWORD PTR $T217913[esp+17976]
  0011d	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _ExtBank$[esp+17976]
  00124	66 ab		 stosw
  00126	52		 push	 edx
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@CLIOIOKN@m_extGuildBank?$AA@
  0012c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17984], 0
  00134	aa		 stosb
  00135	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 499  : 	while( '$' != ExtBank[CountStr] )

  0013a	80 bc 24 f8 00
	00 00 24	 cmp	 BYTE PTR _ExtBank$[esp+17976], 36 ; 00000024H
  00142	0f 84 d5 00 00
	00		 je	 $L208830

; 495  : 	CountStr	= 0;

  00148	33 f6		 xor	 esi, esi
  0014a	8d 9b 00 00 00
	00		 npad	 6
$L208829:

; 500  : 	{
; 501  : 		GuildBank->m_apItem[nExtBank].m_bCharged				= (BOOL)GetIntPaFromStr( ExtBank, &CountStr );

  00150	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+17976]
  00154	50		 push	 eax
  00155	8d 8c 24 fc 00
	00 00		 lea	 ecx, DWORD PTR _ExtBank$[esp+17980]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00162	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00165	89 84 16 88 00
	00 00		 mov	 DWORD PTR [esi+edx+136], eax

; 502  : 		if( GuildBank->m_apItem[nExtBank].m_bCharged != 1 )

  0016c	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0016f	8b 8c 06 88 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+136]
  00176	83 c4 08	 add	 esp, 8
  00179	83 f9 01	 cmp	 ecx, 1
  0017c	74 0d		 je	 SHORT $L208832

; 503  : 			GuildBank->m_apItem[nExtBank].m_bCharged	= 0;

  0017e	8b c8		 mov	 ecx, eax
  00180	c7 84 0e 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+ecx+136], 0
$L208832:

; 504  : 		GuildBank->m_apItem[nExtBank].m_dwKeepTime				= (DWORD)GetIntPaFromStr( ExtBank, &CountStr );

  0018b	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17976]
  0018f	52		 push	 edx
  00190	8d 84 24 fc 00
	00 00		 lea	 eax, DWORD PTR _ExtBank$[esp+17980]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  0019d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 505  : #if __VER >= 11 // __SYS_IDENTIFY
; 506  : 		__int64 iRandomOptItemId	= GetInt64PaFromStr( ExtBank, &CountStr );

  001a0	8d 54 24 14	 lea	 edx, DWORD PTR _CountStr$[esp+17984]
  001a4	89 84 0e 8c 00
	00 00		 mov	 DWORD PTR [esi+ecx+140], eax
  001ab	52		 push	 edx
  001ac	8d 84 24 04 01
	00 00		 lea	 eax, DWORD PTR _ExtBank$[esp+17988]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?GetInt64PaFromStr@@YA_JPADPAH@Z ; GetInt64PaFromStr
  001b9	83 c4 10	 add	 esp, 16			; 00000010H

; 507  : 		if( iRandomOptItemId == -102 )

  001bc	83 f8 9a	 cmp	 eax, -102		; ffffff9aH
  001bf	75 09		 jne	 SHORT $L208835
  001c1	83 fa ff	 cmp	 edx, -1
  001c4	75 04		 jne	 SHORT $L208835

; 508  : 			iRandomOptItemId	= 0;

  001c6	33 c0		 xor	 eax, eax
  001c8	33 d2		 xor	 edx, edx
$L208835:

; 509  : 		GuildBank->m_apItem[nExtBank].SetRandomOptItemId( iRandomOptItemId );

  001ca	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  001cd	03 ce		 add	 ecx, esi
  001cf	89 91 94 00 00
	00		 mov	 DWORD PTR [ecx+148], edx
  001d5	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 510  : #else	// __SYS_IDENTIFY
; 511  : 		GuildBank->m_apItem[nExtBank].SetRandomOptItemId( (DWORD)GetIntPaFromStr( ExtBank, &CountStr ) );
; 512  : #endif	// __SYS_IDENTIFY
; 513  : #if __VER >= 15 // __PETVIS
; 514  : 		GuildBank->m_apItem[nExtBank].m_bTranformVisPet = static_cast<BOOL>( GetIntPaFromStr( ExtBank, &CountStr ) );

  001db	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17976]
  001df	51		 push	 ecx
  001e0	8d 94 24 fc 00
	00 00		 lea	 edx, DWORD PTR _ExtBank$[esp+17980]
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  001ed	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  001f0	89 84 0e 9c 00
	00 00		 mov	 DWORD PTR [esi+ecx+156], eax

; 515  : #endif // __PETVIS
; 516  : 		++CountStr; 		++nExtBank;

  001f7	8b 44 24 14	 mov	 eax, DWORD PTR _CountStr$[esp+17984]
  001fb	8a 8c 04 01 01
	00 00		 mov	 cl, BYTE PTR _ExtBank$[esp+eax+17985]
  00202	83 c4 08	 add	 esp, 8
  00205	40		 inc	 eax
  00206	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  0020c	80 f9 24	 cmp	 cl, 36			; 00000024H
  0020f	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+17976], eax
  00213	0f 85 37 ff ff
	ff		 jne	 $L208829

; 499  : 	while( '$' != ExtBank[CountStr] )

  00219	8b 74 24 14	 mov	 esi, DWORD PTR $T217911[esp+17976]
$L208830:

; 520  : 	int nPirecingBank = 0;
; 521  : 	char PirecingBank[4000] = {0,};

  0021d	c6 84 24 30 19
	00 00 00	 mov	 BYTE PTR _PirecingBank$[esp+17976], 0
  00225	33 c0		 xor	 eax, eax
  00227	b9 e7 03 00 00	 mov	 ecx, 999		; 000003e7H
  0022c	8d bc 24 31 19
	00 00		 lea	 edi, DWORD PTR _PirecingBank$[esp+17977]
  00233	f3 ab		 rep stosd

; 522  : 	qry->GetStr( "m_GuildBankPiercing", PirecingBank );

  00235	8b 4c 24 10	 mov	 ecx, DWORD PTR $T217913[esp+17976]
  00239	8d 94 24 30 19
	00 00		 lea	 edx, DWORD PTR _PirecingBank$[esp+17976]
  00240	66 ab		 stosw
  00242	52		 push	 edx
  00243	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@FOMLDJLH@m_GuildBankPiercing?$AA@
  00248	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17984], 0
  00250	aa		 stosb
  00251	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 523  : 	while( '$' != PirecingBank[CountStr] )

  00256	80 bc 24 30 19
	00 00 24	 cmp	 BYTE PTR _PirecingBank$[esp+17976], 36 ; 00000024H
  0025e	74 32		 je	 SHORT $L208842

; 517  : 	}
; 518  : 	
; 519  : 	CountStr	= 0;

  00260	33 ff		 xor	 edi, edi
$L208841:

; 524  : 	{
; 525  : #if __VER >= 12 // __EXT_PIERCING
; 526  : 		LoadPiercingInfo( GuildBank->m_apItem[nPirecingBank], PirecingBank, &CountStr );

  00262	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00265	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+17976]
  00269	50		 push	 eax
  0026a	8d 8c 24 34 19
	00 00		 lea	 ecx, DWORD PTR _PirecingBank$[esp+17980]
  00271	51		 push	 ecx
  00272	03 d7		 add	 edx, edi
  00274	52		 push	 edx
  00275	8b ce		 mov	 ecx, esi
  00277	e8 00 00 00 00	 call	 ?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z ; CDbManager::LoadPiercingInfo
  0027c	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+17976]
  00280	8a 8c 04 30 19
	00 00		 mov	 cl, BYTE PTR _PirecingBank$[esp+eax+17976]

; 527  : #else // __EXT_PIERCING
; 528  : 		int nItemIdCount = 0;
; 529  : 		GuildBank->m_apItem[nPirecingBank].SetPiercingSize( GetIntFromStr( PirecingBank, &CountStr ) );
; 530  : 		for( int i = 0 ; i < GuildBank->m_apItem[nPirecingBank].GetPiercingSize() ; ++i )
; 531  : 		{
; 532  : 			GuildBank->m_apItem[nPirecingBank].SetPiercingItem( nItemIdCount, (DWORD)GetIntFromStr( PirecingBank, &CountStr ) );
; 533  : 			++nItemIdCount;
; 534  : 		}
; 535  : #endif // __EXT_PIERCING
; 536  : 		++nPirecingBank;

  00287	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H
  0028d	80 f9 24	 cmp	 cl, 36			; 00000024H
  00290	75 d0		 jne	 SHORT $L208841
$L208842:

; 537  : 	}
; 538  : 
; 539  : 	CountStr	= 0;
; 540  : 	int	nId	= 0;
; 541  : #ifdef __PET_1024
; 542  : 	char szPet[4200]	= { 0, };

  00292	c6 84 24 c8 08
	00 00 00	 mov	 BYTE PTR _szPet$[esp+17976], 0
  0029a	33 c0		 xor	 eax, eax
  0029c	b9 19 04 00 00	 mov	 ecx, 1049		; 00000419H
  002a1	8d bc 24 c9 08
	00 00		 lea	 edi, DWORD PTR _szPet$[esp+17977]
  002a8	f3 ab		 rep stosd

; 543  : #else	// __PET_1024
; 544  : 	char szPet[2688]	= { 0, };
; 545  : #endif	// __PET_1024
; 546  : 	qry->GetStr( "szGuildBankPet", szPet );

  002aa	8d 8c 24 c8 08
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17976]
  002b1	66 ab		 stosw
  002b3	51		 push	 ecx
  002b4	8b 4c 24 14	 mov	 ecx, DWORD PTR $T217913[esp+17980]
  002b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@MOKIMIMD@szGuildBankPet?$AA@
  002bd	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17984], 0
  002c5	aa		 stosb
  002c6	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 547  : 	while( '$' != szPet[CountStr] )

  002cb	80 bc 24 c8 08
	00 00 24	 cmp	 BYTE PTR _szPet$[esp+17976], 36 ; 00000024H
  002d3	0f 84 08 02 00
	00		 je	 $L208848
  002d9	33 ff		 xor	 edi, edi
  002db	89 7c 24 10	 mov	 DWORD PTR tv621[esp+17976], edi
  002df	90		 npad	 1
$L208847:

; 548  : 	{
; 549  : 		BOOL bPet	= (BOOL)GetIntFromStr( szPet, &CountStr );

  002e0	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17976]
  002e4	52		 push	 edx
  002e5	8d 84 24 cc 08
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+17980]
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 550  : 		if( bPet )

  002f2	33 f6		 xor	 esi, esi
  002f4	83 c4 08	 add	 esp, 8
  002f7	3b c6		 cmp	 eax, esi
  002f9	0f 84 c4 01 00
	00		 je	 $L208851

; 551  : 		{
; 552  : 			SAFE_DELETE( GuildBank->m_apItem[nId].m_pPet );

  002ff	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00302	8b 8c 0f 98 00
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+152]
  00309	3b ce		 cmp	 ecx, esi
  0030b	74 10		 je	 SHORT $L208852
  0030d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0030f	6a 01		 push	 1
  00311	ff 12		 call	 DWORD PTR [edx]
  00313	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00316	89 b4 07 98 00
	00 00		 mov	 DWORD PTR [edi+eax+152], esi
$L208852:

; 553  : 			CPet* pPet	= GuildBank->m_apItem[nId].m_pPet		= new CPet;

  0031d	6a 28		 push	 40			; 00000028H
  0031f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00324	83 c4 04	 add	 esp, 4
  00327	89 44 24 1c	 mov	 DWORD PTR $T217889[esp+17976], eax
  0032b	3b c6		 cmp	 eax, esi
  0032d	c7 84 24 34 46
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+17984], 1
  00338	74 09		 je	 SHORT $L217891
  0033a	8b c8		 mov	 ecx, eax
  0033c	e8 00 00 00 00	 call	 ??0CPet@@QAE@XZ		; CPet::CPet
  00341	8b f0		 mov	 esi, eax
$L217891:
  00343	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 554  : 			BYTE nKind	= (BYTE)GetIntFromStr( szPet, &CountStr );

  00346	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17976]
  0034a	52		 push	 edx
  0034b	8d 84 24 cc 08
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+17980]
  00352	50		 push	 eax
  00353	c7 84 24 3c 46
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+17992], -1
  0035e	89 b4 0f 98 00
	00 00		 mov	 DWORD PTR [edi+ecx+152], esi
  00365	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 555  : 			pPet->SetKind( nKind );
; 556  : 			BYTE nLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );

  0036a	8d 4c 24 14	 lea	 ecx, DWORD PTR _CountStr$[esp+17984]
  0036e	51		 push	 ecx
  0036f	8d 94 24 d4 08
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+17988]
  00376	52		 push	 edx
  00377	88 46 04	 mov	 BYTE PTR [esi+4], al
  0037a	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 557  : 			pPet->SetLevel( nLevel );

  0037f	88 46 05	 mov	 BYTE PTR [esi+5], al

; 558  : 			DWORD dwExp	= (DWORD)GetIntFromStr( szPet, &CountStr );

  00382	8d 44 24 1c	 lea	 eax, DWORD PTR _CountStr$[esp+17992]
  00386	50		 push	 eax
  00387	8d 8c 24 dc 08
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17996]
  0038e	51		 push	 ecx
  0038f	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00394	83 c4 18	 add	 esp, 24			; 00000018H

; 559  : 			pPet->SetExp( dwExp );

  00397	50		 push	 eax
  00398	8b ce		 mov	 ecx, esi
  0039a	e8 00 00 00 00	 call	 ?SetExp@CPet@@QAEXK@Z	; CPet::SetExp

; 560  : 			WORD wEnergy	= (WORD)GetIntFromStr( szPet, &CountStr );

  0039f	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17976]
  003a3	52		 push	 edx
  003a4	8d 84 24 cc 08
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+17980]
  003ab	50		 push	 eax
  003ac	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  003b1	83 c4 08	 add	 esp, 8

; 561  : 			pPet->SetEnergy( wEnergy );

  003b4	50		 push	 eax
  003b5	8b ce		 mov	 ecx, esi
  003b7	e8 00 00 00 00	 call	 ?SetEnergy@CPet@@QAEXG@Z ; CPet::SetEnergy

; 562  : #ifdef __PET_1024
; 563  : 			WORD wLife	= (WORD)GetIntPaFromStr( szPet, &CountStr );

  003bc	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17976]
  003c0	51		 push	 ecx
  003c1	8d 94 24 cc 08
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+17980]
  003c8	52		 push	 edx
  003c9	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 564  : 			pPet->SetLife( wLife );

  003ce	66 89 46 0e	 mov	 WORD PTR [esi+14], ax

; 565  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )

  003d2	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  003d5	83 c4 08	 add	 esp, 8
  003d8	3c 01		 cmp	 al, 1
  003da	bf 01 00 00 00	 mov	 edi, 1
  003df	72 2f		 jb	 SHORT $L208874
$L208872:

; 566  : 			{
; 567  : 				BYTE nAvailLevel	= (BYTE)GetIntPaFromStr( szPet, &CountStr );

  003e1	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+17976]
  003e5	50		 push	 eax
  003e6	8d 8c 24 cc 08
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17980]
  003ed	51		 push	 ecx
  003ee	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  003f3	88 44 24 20	 mov	 BYTE PTR _nAvailLevel$208875[esp+17984], al

; 568  : 				pPet->SetAvailLevel( i, nAvailLevel );

  003f7	8b 54 24 20	 mov	 edx, DWORD PTR _nAvailLevel$208875[esp+17984]
  003fb	83 c4 08	 add	 esp, 8
  003fe	52		 push	 edx
  003ff	57		 push	 edi
  00400	8b ce		 mov	 ecx, esi
  00402	e8 00 00 00 00	 call	 ?SetAvailLevel@CPet@@QAEXEE@Z ; CPet::SetAvailLevel
  00407	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0040b	47		 inc	 edi
  0040c	3b f8		 cmp	 edi, eax
  0040e	7e d1		 jle	 SHORT $L208872
$L208874:

; 569  : 			}
; 570  : 			char szFmt[MAX_PET_NAME_FMT]	= { 0,};

  00410	33 c9		 xor	 ecx, ecx
  00412	89 8c 24 d5 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+17977], ecx
  00419	89 8c 24 d9 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+17981], ecx
  00420	89 8c 24 dd 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+17985], ecx
  00427	89 8c 24 e1 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+17989], ecx
  0042e	89 8c 24 e5 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+17993], ecx
  00435	89 8c 24 e9 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+17997], ecx
  0043c	89 8c 24 ed 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+18001], ecx

; 571  : 			GetStrFromStr( szPet, szFmt, &CountStr );

  00443	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17976]
  00447	52		 push	 edx
  00448	8d 84 24 d8 00
	00 00		 lea	 eax, DWORD PTR _szFmt$208877[esp+17980]
  0044f	89 8c 24 f5 00
	00 00		 mov	 DWORD PTR _szFmt$208877[esp+18009], ecx
  00456	50		 push	 eax
  00457	8d 8c 24 d0 08
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17984]
  0045e	51		 push	 ecx
  0045f	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR _szFmt$208877[esp+17988], 0
  00467	e8 00 00 00 00	 call	 ?GetStrFromStr@@YAXPAD0PAH@Z ; GetStrFromStr
  0046c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 572  : 			char szName[MAX_PET_NAME]	= { 0,};

  0046f	33 d2		 xor	 edx, edx

; 573  : 			GetDBFormatStr( szName, MAX_PET_NAME, szFmt );

  00471	8d 84 24 d4 00
	00 00		 lea	 eax, DWORD PTR _szFmt$208877[esp+17976]
  00478	89 94 24 c1 00
	00 00		 mov	 DWORD PTR _szName$208878[esp+17977], edx
  0047f	50		 push	 eax
  00480	89 94 24 c9 00
	00 00		 mov	 DWORD PTR _szName$208878[esp+17985], edx
  00487	6a 11		 push	 17			; 00000011H
  00489	8d 8c 24 c8 00
	00 00		 lea	 ecx, DWORD PTR _szName$208878[esp+17984]
  00490	89 94 24 d1 00
	00 00		 mov	 DWORD PTR _szName$208878[esp+17993], edx
  00497	51		 push	 ecx
  00498	8b 4c 24 20	 mov	 ecx, DWORD PTR $T217911[esp+17988]
  0049c	c6 84 24 cc 00
	00 00 00	 mov	 BYTE PTR _szName$208878[esp+17988], 0
  004a4	89 94 24 d9 00
	00 00		 mov	 DWORD PTR _szName$208878[esp+18001], edx
  004ab	e8 00 00 00 00	 call	 ?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z ; CDbManager::GetDBFormatStr

; 574  : 			pPet->SetName( szName );

  004b0	8d 94 24 c0 00
	00 00		 lea	 edx, DWORD PTR _szName$208878[esp+17976]
  004b7	52		 push	 edx
  004b8	8b ce		 mov	 ecx, esi
  004ba	e8 00 00 00 00	 call	 ?SetName@CPet@@QAEXPBD@Z ; CPet::SetName
  004bf	8b 7c 24 10	 mov	 edi, DWORD PTR tv621[esp+17976]
$L208851:
  004c3	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+17976]
  004c7	8a 8c 04 c8 08
	00 00		 mov	 cl, BYTE PTR _szPet$[esp+eax+17976]

; 575  : #else	// __PET_1024
; 576  : 			WORD wLife	= (WORD)GetIntFromStr( szPet, &CountStr );
; 577  : 			pPet->SetLife( wLife );
; 578  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )
; 579  : 			{
; 580  : 				BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );
; 581  : 				pPet->SetAvailLevel( i, nAvailLevel );
; 582  : 			}
; 583  : #endif	// __PET_1024
; 584  : 		}
; 585  : 		nId++;

  004ce	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H
  004d4	80 f9 24	 cmp	 cl, 36			; 00000024H
  004d7	89 7c 24 10	 mov	 DWORD PTR tv621[esp+17976], edi
  004db	0f 85 ff fd ff
	ff		 jne	 $L208847
$L208848:

; 586  : 	}
; 587  : }

  004e1	8b 8c 24 2c 46
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+17976]
  004e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  004ef	8b 8c 24 24 46
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+17976]
  004f6	5f		 pop	 edi
  004f7	5e		 pop	 esi
  004f8	33 cd		 xor	 ecx, ebp
  004fa	5b		 pop	 ebx
  004fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00500	8b e5		 mov	 esp, ebp
  00502	5d		 pop	 ebp
  00503	c2 08 00	 ret	 8
$L217921:

; 488  : 			{
; 489  : 				Error( "GuildBank = %s", Bank );

  00506	8d 8c 24 d0 28
	00 00		 lea	 ecx, DWORD PTR _Bank$[esp+17976]
  0050d	51		 push	 ecx
  0050e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@KBFNBDP@GuildBank?5?$DN?5?$CFs?$AA@
  00513	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00518	83 c4 08	 add	 esp, 8

; 490  : 				return;

  0051b	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208820[esp+17976]
  0051f	89 bc 24 34 46
	00 00		 mov	 DWORD PTR __$EHRec$[esp+17984], edi
  00526	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  0052b	eb b4		 jmp	 SHORT $L208848
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L217892:
  00000	8d 8d e8 b9 ff
	ff		 lea	 ecx, DWORD PTR _BufItemElem$208820[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L217893:
  0000b	8b 85 e4 b9 ff
	ff		 mov	 eax, DWORD PTR $T217889[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
  00018	c3		 ret	 0
__ehhandler$?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z:
  00019	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T217915
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z ENDP ; CDbManager::GetGuildBank
PUBLIC	??_C@_05LOKLGDMG@szPet?$AA@			; `string'
PUBLIC	??_C@_07LCDBAOIB@nPocket?$AA@			; `string'
PUBLIC	??_C@_08MECCMHDE@bExpired?$AA@			; `string'
PUBLIC	??_C@_0BA@OHENMHDO@tExpirationDate?$AA@		; `string'
PUBLIC	??_C@_0BP@BKCBFKFA@Join?3Pocket?3Property?5not?5found?$AA@ ; `string'
PUBLIC	??_C@_0CB@EAAOHIMM@Join?3Pocket?3POCKET_SLOT_SIZE_1_2@ ; `string'
PUBLIC	?GetPocket@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetPocket
PUBLIC	??_C@_06DKFLNFEC@szItem?$AA@			; `string'
PUBLIC	??_C@_07ODPBDBGJ@szIndex?$AA@			; `string'
PUBLIC	??_C@_0L@LNBLBPOC@szObjIndex?$AA@		; `string'
PUBLIC	??_C@_05MNJCPEEI@szExt?$AA@			; `string'
PUBLIC	??_C@_0L@MAAIPEIA@szPiercing?$AA@		; `string'
EXTRN	?Avail@CPocketController@@QAEXHJ@Z:NEAR		; CPocketController::Avail
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
xdata$x	SEGMENT
$T218016 DD	0ffffffffH
	DD	FLAT:$L217949
	DD	0ffffffffH
	DD	FLAT:$L217950
$T217987 DD	019930520H
	DD	02H
	DD	FLAT:$T218016
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_06DKFLNFEC@szItem?$AA@
CONST	SEGMENT
??_C@_06DKFLNFEC@szItem?$AA@ DB 'szItem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODPBDBGJ@szIndex?$AA@
CONST	SEGMENT
??_C@_07ODPBDBGJ@szIndex?$AA@ DB 'szIndex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNBLBPOC@szObjIndex?$AA@
CONST	SEGMENT
??_C@_0L@LNBLBPOC@szObjIndex?$AA@ DB 'szObjIndex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNJCPEEI@szExt?$AA@
CONST	SEGMENT
??_C@_05MNJCPEEI@szExt?$AA@ DB 'szExt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MAAIPEIA@szPiercing?$AA@
CONST	SEGMENT
??_C@_0L@MAAIPEIA@szPiercing?$AA@ DB 'szPiercing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOKLGDMG@szPet?$AA@
CONST	SEGMENT
??_C@_05LOKLGDMG@szPet?$AA@ DB 'szPet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCDBAOIB@nPocket?$AA@
CONST	SEGMENT
??_C@_07LCDBAOIB@nPocket?$AA@ DB 'nPocket', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MECCMHDE@bExpired?$AA@
CONST	SEGMENT
??_C@_08MECCMHDE@bExpired?$AA@ DB 'bExpired', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OHENMHDO@tExpirationDate?$AA@
CONST	SEGMENT
??_C@_0BA@OHENMHDO@tExpirationDate?$AA@ DB 'tExpirationDate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BKCBFKFA@Join?3Pocket?3Property?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BP@BKCBFKFA@Join?3Pocket?3Property?5not?5found?$AA@ DB 'Join:Pocke'
	DB	't:Property not found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EAAOHIMM@Join?3Pocket?3POCKET_SLOT_SIZE_1_2@
CONST	SEGMENT
??_C@_0CB@EAAOHIMM@Join?3Pocket?3POCKET_SLOT_SIZE_1_2@ DB 'Join:Pocket:PO'
	DB	'CKET_SLOT_SIZE_1_2', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetPocket@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
$T217983 = -19060					; size = 4
_nOffset$208916 = -19060				; size = 4
$T217982 = -19056					; size = 4
tv908 = -19052						; size = 4
_bExpired$ = -19052					; size = 4
$T217946 = -19048					; size = 4
_iRandomOptItemId$208942 = -19048			; size = 8
_nAvailLevel$208977 = -19036				; size = 1
_itemElem$208921 = -19032				; size = 160
_szName$208980 = -18872					; size = 17
_szFmt$208979 = -18852					; size = 33
_szPlayerName$ = -18816					; size = 64
_szIndex$ = -18752					; size = 512
_szObjIndex$ = -18240					; size = 512
_szExt$ = -17728					; size = 2000
_szPet$ = -15728					; size = 4200
_szPiercing$ = -11528					; size = 4000
_szItem$ = -7528					; size = 7500
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_pQuery$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetPocket@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetPocket, COMDAT
; _this$ = ecx

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GetPocket@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	51		 push	 ecx
  0001c	b8 64 4a 00 00	 mov	 eax, 19044		; 00004a64H
  00021	e8 00 00 00 00	 call	 __chkstk
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 84 24 60 4a
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+19060], eax

; 624  : 	VERIFYSTRING_RETURN( szPet, szPlayerName );

  00034	8b 45 08	 mov	 eax, DWORD PTR _pMover$[ebp]
  00037	89 04 24	 mov	 DWORD PTR $T217983[esp+19060], eax
  0003a	33 c0		 xor	 eax, eax
  0003c	89 4c 24 04	 mov	 DWORD PTR $T217982[esp+19060], ecx
  00040	53		 push	 ebx
  00041	56		 push	 esi
  00042	57		 push	 edi
  00043	c6 84 24 18 2d
	00 00 00	 mov	 BYTE PTR _szItem$[esp+19072], 0
  0004b	b9 52 07 00 00	 mov	 ecx, 1874		; 00000752H
  00050	8d bc 24 19 2d
	00 00		 lea	 edi, DWORD PTR _szItem$[esp+19073]
  00057	f3 ab		 rep stosd
  00059	66 ab		 stosw
  0005b	aa		 stosb
  0005c	33 c0		 xor	 eax, eax
  0005e	c6 84 24 40 01
	00 00 00	 mov	 BYTE PTR _szIndex$[esp+19072], 0
  00066	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0006b	8d bc 24 41 01
	00 00		 lea	 edi, DWORD PTR _szIndex$[esp+19073]
  00072	f3 ab		 rep stosd
  00074	66 ab		 stosw
  00076	aa		 stosb
  00077	33 c0		 xor	 eax, eax
  00079	c6 84 24 40 03
	00 00 00	 mov	 BYTE PTR _szObjIndex$[esp+19072], 0
  00081	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00086	8d bc 24 41 03
	00 00		 lea	 edi, DWORD PTR _szObjIndex$[esp+19073]
  0008d	f3 ab		 rep stosd
  0008f	66 ab		 stosw
  00091	aa		 stosb
  00092	33 c0		 xor	 eax, eax
  00094	c6 84 24 40 05
	00 00 00	 mov	 BYTE PTR _szExt$[esp+19072], 0
  0009c	b9 f3 01 00 00	 mov	 ecx, 499		; 000001f3H
  000a1	8d bc 24 41 05
	00 00		 lea	 edi, DWORD PTR _szExt$[esp+19073]
  000a8	f3 ab		 rep stosd
  000aa	66 ab		 stosw
  000ac	aa		 stosb
  000ad	8b 75 0c	 mov	 esi, DWORD PTR _pQuery$[ebp]
  000b0	8b 5d 10	 mov	 ebx, DWORD PTR _lpDbOverlappedPlus$[ebp]
  000b3	33 c0		 xor	 eax, eax
  000b5	c6 84 24 78 1d
	00 00 00	 mov	 BYTE PTR _szPiercing$[esp+19072], 0
  000bd	b9 e7 03 00 00	 mov	 ecx, 999		; 000003e7H
  000c2	8d bc 24 79 1d
	00 00		 lea	 edi, DWORD PTR _szPiercing$[esp+19073]
  000c9	f3 ab		 rep stosd
  000cb	66 ab		 stosw
  000cd	aa		 stosb
  000ce	c6 84 24 10 0d
	00 00 00	 mov	 BYTE PTR _szPet$[esp+19072], 0
  000d6	33 c0		 xor	 eax, eax
  000d8	b9 19 04 00 00	 mov	 ecx, 1049		; 00000419H
  000dd	8d bc 24 11 0d
	00 00		 lea	 edi, DWORD PTR _szPet$[esp+19073]
  000e4	f3 ab		 rep stosd
  000e6	8d 8c 24 18 2d
	00 00		 lea	 ecx, DWORD PTR _szItem$[esp+19072]
  000ed	66 ab		 stosw
  000ef	51		 push	 ecx
  000f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06DKFLNFEC@szItem?$AA@
  000f5	8b ce		 mov	 ecx, esi
  000f7	aa		 stosb
  000f8	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  000fd	8d 94 24 40 01
	00 00		 lea	 edx, DWORD PTR _szIndex$[esp+19072]
  00104	52		 push	 edx
  00105	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07ODPBDBGJ@szIndex?$AA@
  0010a	8b ce		 mov	 ecx, esi
  0010c	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00111	8d 84 24 40 03
	00 00		 lea	 eax, DWORD PTR _szObjIndex$[esp+19072]
  00118	50		 push	 eax
  00119	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@LNBLBPOC@szObjIndex?$AA@
  0011e	8b ce		 mov	 ecx, esi
  00120	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00125	8d 8c 24 40 05
	00 00		 lea	 ecx, DWORD PTR _szExt$[esp+19072]
  0012c	51		 push	 ecx
  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MNJCPEEI@szExt?$AA@
  00132	8b ce		 mov	 ecx, esi
  00134	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00139	8d 94 24 78 1d
	00 00		 lea	 edx, DWORD PTR _szPiercing$[esp+19072]
  00140	52		 push	 edx
  00141	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@MAAIPEIA@szPiercing?$AA@
  00146	8b ce		 mov	 ecx, esi
  00148	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  0014d	8d 84 24 10 0d
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19072]
  00154	50		 push	 eax
  00155	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05LOKLGDMG@szPet?$AA@
  0015a	8b ce		 mov	 ecx, esi
  0015c	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr
  00161	33 c0		 xor	 eax, eax
  00163	85 db		 test	 ebx, ebx
  00165	c6 84 24 00 01
	00 00 00	 mov	 BYTE PTR _szPlayerName$[esp+19072], 0
  0016d	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00172	8d bc 24 01 01
	00 00		 lea	 edi, DWORD PTR _szPlayerName$[esp+19073]
  00179	f3 ab		 rep stosd
  0017b	66 ab		 stosw
  0017d	aa		 stosb
  0017e	8d 94 24 00 01
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+19072]
  00185	74 15		 je	 SHORT $L208898
  00187	8d 43 74	 lea	 eax, DWORD PTR [ebx+116]
  0018a	2b d0		 sub	 edx, eax
  0018c	8d 64 24 00	 npad	 4
$L217938:
  00190	8a 08		 mov	 cl, BYTE PTR [eax]
  00192	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00195	40		 inc	 eax
  00196	84 c9		 test	 cl, cl
  00198	75 f6		 jne	 SHORT $L217938

; 592  : 	char	szItem[7500]	= { 0,};
; 593  : 	char	szIndex[512]	= { 0,};
; 594  : 	char	szObjIndex[512]	= { 0,};
; 595  : 	char	szExt[2000]		= { 0,};
; 596  : 	char	szPiercing[4000]	= { 0,};
; 597  : #ifdef __PET_1024
; 598  : 	char	szPet[4200]	= { 0,};
; 599  : #else	// __PET_1024
; 600  : 	char	szPet[2688]	= { 0,};
; 601  : #endif	// __PET_1024
; 602  : 
; 603  : 	pQuery->GetStr( "szItem", szItem );
; 604  : 	pQuery->GetStr( "szIndex", szIndex );
; 605  : 	pQuery->GetStr( "szObjIndex", szObjIndex );
; 606  : 	pQuery->GetStr( "szExt", szExt );
; 607  : 	pQuery->GetStr( "szPiercing", szPiercing );
; 608  : 	pQuery->GetStr( "szPet", szPet );
; 609  : 
; 610  : 	char szPlayerName[64] = {0, };
; 611  : 	if( lpDbOverlappedPlus != NULL )
; 612  : 	{
; 613  : 		_tcscpy( szPlayerName, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 614  : 	}
; 615  : 	else

  0019a	eb 13		 jmp	 SHORT $L208899
$L208898:

; 616  : 	{
; 617  : 		_tcscpy( szPlayerName, pMover->m_szName );

  0019c	8b 44 24 0c	 mov	 eax, DWORD PTR $T217983[esp+19072]
  001a0	83 c0 6c	 add	 eax, 108		; 0000006cH
  001a3	2b d0		 sub	 edx, eax
$L217939:
  001a5	8a 08		 mov	 cl, BYTE PTR [eax]
  001a7	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  001aa	40		 inc	 eax
  001ab	84 c9		 test	 cl, cl
  001ad	75 f6		 jne	 SHORT $L217939
$L208899:

; 618  : 	}
; 619  : 	VERIFYSTRING_RETURN( szItem, szPlayerName );

  001af	8d 84 24 18 2d
	00 00		 lea	 eax, DWORD PTR _szItem$[esp+19072]
  001b6	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  001b9	8d a4 24 00 00
	00 00		 npad	 7
$L218006:
  001c0	8a 08		 mov	 cl, BYTE PTR [eax]
  001c2	40		 inc	 eax
  001c3	84 c9		 test	 cl, cl
  001c5	75 f9		 jne	 SHORT $L218006
  001c7	2b c2		 sub	 eax, edx
  001c9	85 c0		 test	 eax, eax
  001cb	7e 0a		 jle	 SHORT $L217954
  001cd	80 bc 04 17 2d
	00 00 24	 cmp	 BYTE PTR _szItem$[esp+eax+19071], 36 ; 00000024H
  001d5	74 34		 je	 SHORT $L208900
$L217954:
  001d7	8d 8c 24 00 01
	00 00		 lea	 ecx, DWORD PTR _szPlayerName$[esp+19072]
  001de	51		 push	 ecx
  001df	68 6b 02 00 00	 push	 619			; 0000026bH
  001e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  001e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  001ee	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  001f3	83 c4 10	 add	 esp, 16			; 00000010H
  001f6	85 db		 test	 ebx, ebx
  001f8	74 0a		 je	 SHORT $L217955
  001fa	8b 4c 24 10	 mov	 ecx, DWORD PTR $T217982[esp+19072]
  001fe	53		 push	 ebx
  001ff	e8 00 00 00 00	 call	 ?FreeRequest@CDbManager@@QAEXPAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::FreeRequest
$L217955:
  00204	33 c0		 xor	 eax, eax
  00206	e9 9b 05 00 00	 jmp	 $L208884
$L208900:

; 620  : 	VERIFYSTRING_RETURN( szIndex, szPlayerName );

  0020b	8b 7c 24 10	 mov	 edi, DWORD PTR $T217982[esp+19072]
  0020f	53		 push	 ebx
  00210	8d 94 24 04 01
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+19076]
  00217	52		 push	 edx
  00218	68 6c 02 00 00	 push	 620			; 0000026cH
  0021d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00222	8d 84 24 50 01
	00 00		 lea	 eax, DWORD PTR _szIndex$[esp+19088]
  00229	50		 push	 eax
  0022a	8b cf		 mov	 ecx, edi
  0022c	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00231	85 c0		 test	 eax, eax
  00233	0f 84 af 05 00
	00		 je	 $L218015

; 621  : 	VERIFYSTRING_RETURN( szObjIndex, szPlayerName );

  00239	53		 push	 ebx
  0023a	8d 8c 24 04 01
	00 00		 lea	 ecx, DWORD PTR _szPlayerName$[esp+19076]
  00241	51		 push	 ecx
  00242	68 6d 02 00 00	 push	 621			; 0000026dH
  00247	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0024c	8d 94 24 50 03
	00 00		 lea	 edx, DWORD PTR _szObjIndex$[esp+19088]
  00253	52		 push	 edx
  00254	8b cf		 mov	 ecx, edi
  00256	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  0025b	85 c0		 test	 eax, eax
  0025d	0f 84 85 05 00
	00		 je	 $L218015

; 622  : 	VERIFYSTRING_RETURN( szExt, szPlayerName );

  00263	53		 push	 ebx
  00264	8d 84 24 04 01
	00 00		 lea	 eax, DWORD PTR _szPlayerName$[esp+19076]
  0026b	50		 push	 eax
  0026c	68 6e 02 00 00	 push	 622			; 0000026eH
  00271	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00276	8d 8c 24 50 05
	00 00		 lea	 ecx, DWORD PTR _szExt$[esp+19088]
  0027d	51		 push	 ecx
  0027e	8b cf		 mov	 ecx, edi
  00280	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00285	85 c0		 test	 eax, eax
  00287	0f 84 5b 05 00
	00		 je	 $L218015

; 623  : 	VERIFYSTRING_RETURN( szPiercing, szPlayerName );

  0028d	53		 push	 ebx
  0028e	8d 94 24 04 01
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+19076]
  00295	52		 push	 edx
  00296	68 6f 02 00 00	 push	 623			; 0000026fH
  0029b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  002a0	8d 84 24 88 1d
	00 00		 lea	 eax, DWORD PTR _szPiercing$[esp+19088]
  002a7	50		 push	 eax
  002a8	8b cf		 mov	 ecx, edi
  002aa	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  002af	85 c0		 test	 eax, eax
  002b1	0f 84 31 05 00
	00		 je	 $L218015

; 624  : 	VERIFYSTRING_RETURN( szPet, szPlayerName );

  002b7	53		 push	 ebx
  002b8	8d 8c 24 04 01
	00 00		 lea	 ecx, DWORD PTR _szPlayerName$[esp+19076]
  002bf	51		 push	 ecx
  002c0	68 70 02 00 00	 push	 624			; 00000270H
  002c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  002ca	8d 94 24 20 0d
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19088]
  002d1	52		 push	 edx
  002d2	8b cf		 mov	 ecx, edi
  002d4	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  002d9	85 c0		 test	 eax, eax
  002db	0f 84 07 05 00
	00		 je	 $L218015

; 625  : 
; 626  : 	int nPocket	= pQuery->GetInt( "nPocket" );

  002e1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07LCDBAOIB@nPocket?$AA@
  002e6	8b ce		 mov	 ecx, esi
  002e8	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 627  : 	BOOL bExpired	= (BOOL)pQuery->GetInt( "bExpired" );

  002ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MECCMHDE@bExpired?$AA@
  002f2	8b ce		 mov	 ecx, esi
  002f4	8b d8		 mov	 ebx, eax
  002f6	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 628  : 
; 629  : 	if( szItem[0] != '$' || !bExpired )

  002fb	80 bc 24 18 2d
	00 00 24	 cmp	 BYTE PTR _szItem$[esp+19072], 36 ; 00000024H
  00303	89 44 24 14	 mov	 DWORD PTR _bExpired$[esp+19072], eax
  00307	75 08		 jne	 SHORT $L208912
  00309	85 c0		 test	 eax, eax
  0030b	0f 85 90 04 00
	00		 jne	 $L208950
$L208912:

; 630  : 	{
; 631  : 		pMover->m_Pocket.Avail( nPocket );

  00311	8b 7c 24 0c	 mov	 edi, DWORD PTR $T217983[esp+19072]
  00315	6a 00		 push	 0
  00317	81 c7 78 41 00
	00		 add	 edi, 16760		; 00004178H
  0031d	53		 push	 ebx
  0031e	8b cf		 mov	 ecx, edi
  00320	e8 00 00 00 00	 call	 ?Avail@CPocketController@@QAEXHJ@Z ; CPocketController::Avail

; 632  : 		CPocket* pPocket	= pMover->m_Pocket.GetPocket( nPocket );

  00325	53		 push	 ebx
  00326	8b cf		 mov	 ecx, edi
  00328	e8 00 00 00 00	 call	 ?GetPocket@CPocketController@@QAEPAVCPocket@@H@Z ; CPocketController::GetPocket
  0032d	8b f8		 mov	 edi, eax

; 633  : 		pPocket->SetExpired( bExpired );

  0032f	8b 44 24 14	 mov	 eax, DWORD PTR _bExpired$[esp+19072]

; 634  : 		pPocket->SetExpirationDate( (time_t)pQuery->GetInt( "tExpirationDate" ) );

  00333	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@OHENMHDO@tExpirationDate?$AA@
  00338	8b ce		 mov	 ecx, esi
  0033a	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0033d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00342	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 635  : 		int nOffset	= 0, i	= 0;
; 636  : 		while( '$' != szItem[nOffset] )

  00345	8a 84 24 18 2d
	00 00		 mov	 al, BYTE PTR _szItem$[esp+19072]
  0034c	33 db		 xor	 ebx, ebx
  0034e	3c 24		 cmp	 al, 36			; 00000024H
  00350	89 5c 24 0c	 mov	 DWORD PTR _nOffset$208916[esp+19072], ebx
  00354	74 7e		 je	 SHORT $L208920
$L208919:

; 637  : 		{
; 638  : 			CItemElem itemElem;

  00356	8d 4c 24 28	 lea	 ecx, DWORD PTR _itemElem$208921[esp+19072]
  0035a	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 639  : 			i	= GetOneItem( &itemElem, szItem, &nOffset );

  0035f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nOffset$208916[esp+19072]
  00363	51		 push	 ecx
  00364	8b 4c 24 14	 mov	 ecx, DWORD PTR $T217982[esp+19076]
  00368	8d 94 24 1c 2d
	00 00		 lea	 edx, DWORD PTR _szItem$[esp+19076]
  0036f	52		 push	 edx
  00370	8d 44 24 30	 lea	 eax, DWORD PTR _itemElem$208921[esp+19080]
  00374	50		 push	 eax
  00375	89 9c 24 88 4a
	00 00		 mov	 DWORD PTR __$EHRec$[esp+19092], ebx
  0037c	e8 00 00 00 00	 call	 ?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z ; CDbManager::GetOneItem

; 640  : 			if( i == -1 )

  00381	83 ce ff	 or	 esi, -1
  00384	3b c6		 cmp	 eax, esi
  00386	75 0f		 jne	 SHORT $L208922

; 641  : 			{
; 642  : 				Error( "Join:Pocket:Property not found" );

  00388	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@BKCBFKFA@Join?3Pocket?3Property?5not?5found?$AA@
  0038d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00392	83 c4 04	 add	 esp, 4

; 643  : 			}
; 644  : 			else

  00395	eb 1f		 jmp	 SHORT $L208924
$L208922:

; 645  : 			{
; 646  : 				if( i >= POCKET_SLOT_SIZE_1_2 )

  00397	83 f8 18	 cmp	 eax, 24			; 00000018H
  0039a	0f 8d 2b 04 00
	00		 jge	 $L217997

; 650  : 				}
; 651  : 				pPocket->m_apItem[i]	= itemElem;

  003a0	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  003a3	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  003a6	c1 e1 05	 shl	 ecx, 5
  003a9	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  003ac	03 ca		 add	 ecx, edx
  003ae	8d 54 24 28	 lea	 edx, DWORD PTR _itemElem$208921[esp+19072]
  003b2	52		 push	 edx
  003b3	ff 50 10	 call	 DWORD PTR [eax+16]
$L208924:

; 652  : 			}
; 653  : 		}

  003b6	8d 4c 24 28	 lea	 ecx, DWORD PTR _itemElem$208921[esp+19072]
  003ba	89 b4 24 7c 4a
	00 00		 mov	 DWORD PTR __$EHRec$[esp+19080], esi
  003c1	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  003c6	8b 44 24 0c	 mov	 eax, DWORD PTR _nOffset$208916[esp+19072]
  003ca	80 bc 04 18 2d
	00 00 24	 cmp	 BYTE PTR _szItem$[esp+eax+19072], 36 ; 00000024H
  003d2	75 82		 jne	 SHORT $L208919
$L208920:

; 655  : 		while( '$' != szIndex[nOffset] )

  003d4	80 bc 24 40 01
	00 00 24	 cmp	 BYTE PTR _szIndex$[esp+19072], 36 ; 00000024H
  003dc	89 5c 24 0c	 mov	 DWORD PTR _nOffset$208916[esp+19072], ebx
  003e0	74 2f		 je	 SHORT $L208930

; 654  : 		nOffset		= i	= 0;

  003e2	33 f6		 xor	 esi, esi
$L208929:

; 656  : 			pPocket->m_apIndex[i++]		= (DWORD)GetIntFromStr( szIndex, &nOffset );

  003e4	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nOffset$208916[esp+19072]
  003e8	51		 push	 ecx
  003e9	8d 94 24 44 01
	00 00		 lea	 edx, DWORD PTR _szIndex$[esp+19076]
  003f0	52		 push	 edx
  003f1	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  003f6	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  003f9	8b 54 24 14	 mov	 edx, DWORD PTR _nOffset$208916[esp+19080]
  003fd	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax
  00400	8a 84 14 48 01
	00 00		 mov	 al, BYTE PTR _szIndex$[esp+edx+19080]
  00407	83 c4 08	 add	 esp, 8
  0040a	83 c6 04	 add	 esi, 4
  0040d	3c 24		 cmp	 al, 36			; 00000024H
  0040f	75 d3		 jne	 SHORT $L208929
$L208930:

; 658  : 		while( '$' != szObjIndex[nOffset] )

  00411	80 bc 24 40 03
	00 00 24	 cmp	 BYTE PTR _szObjIndex$[esp+19072], 36 ; 00000024H
  00419	89 5c 24 0c	 mov	 DWORD PTR _nOffset$208916[esp+19072], ebx
  0041d	74 34		 je	 SHORT $L208934

; 657  : 		nOffset		= i	= 0;

  0041f	33 f6		 xor	 esi, esi
$L208933:

; 659  : 			pPocket->m_apItem[i++].m_dwObjIndex	= (DWORD)GetIntFromStr( szObjIndex, &nOffset );

  00421	8d 44 24 0c	 lea	 eax, DWORD PTR _nOffset$208916[esp+19072]
  00425	50		 push	 eax
  00426	8d 8c 24 44 03
	00 00		 lea	 ecx, DWORD PTR _szObjIndex$[esp+19076]
  0042d	51		 push	 ecx
  0042e	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00433	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00436	89 44 16 2c	 mov	 DWORD PTR [esi+edx+44], eax
  0043a	8b 44 24 14	 mov	 eax, DWORD PTR _nOffset$208916[esp+19080]
  0043e	8a 8c 04 48 03
	00 00		 mov	 cl, BYTE PTR _szObjIndex$[esp+eax+19080]
  00445	83 c4 08	 add	 esp, 8
  00448	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  0044e	80 f9 24	 cmp	 cl, 36			; 00000024H
  00451	75 ce		 jne	 SHORT $L208933
$L208934:

; 661  : 		while( '$' != szExt[nOffset] )

  00453	80 bc 24 40 05
	00 00 24	 cmp	 BYTE PTR _szExt$[esp+19072], 36 ; 00000024H
  0045b	89 5c 24 0c	 mov	 DWORD PTR _nOffset$208916[esp+19072], ebx
  0045f	0f 84 dd 00 00
	00		 je	 $L208938

; 660  : 		nOffset		= i	= 0;

  00465	33 f6		 xor	 esi, esi
  00467	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L208937:

; 662  : 		{
; 663  : 			pPocket->m_apItem[i].m_bCharged		= (BOOL)GetIntPaFromStr( szExt, &nOffset );

  00470	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nOffset$208916[esp+19072]
  00474	51		 push	 ecx
  00475	8d 94 24 44 05
	00 00		 lea	 edx, DWORD PTR _szExt$[esp+19076]
  0047c	52		 push	 edx
  0047d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00482	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00485	89 84 0e 88 00
	00 00		 mov	 DWORD PTR [esi+ecx+136], eax

; 664  : 			if( pPocket->m_apItem[i].m_bCharged != 1 )

  0048c	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0048f	8b 8c 16 88 00
	00 00		 mov	 ecx, DWORD PTR [esi+edx+136]
  00496	8d 84 16 88 00
	00 00		 lea	 eax, DWORD PTR [esi+edx+136]
  0049d	83 c4 08	 add	 esp, 8
  004a0	83 f9 01	 cmp	 ecx, 1
  004a3	74 02		 je	 SHORT $L208940

; 665  : 				pPocket->m_apItem[i].m_bCharged		= 0;

  004a5	89 18		 mov	 DWORD PTR [eax], ebx
$L208940:

; 666  : 			pPocket->m_apItem[i].m_dwKeepTime	= (DWORD)GetIntPaFromStr( szExt, &nOffset );

  004a7	8d 44 24 0c	 lea	 eax, DWORD PTR _nOffset$208916[esp+19072]
  004ab	50		 push	 eax
  004ac	8d 8c 24 44 05
	00 00		 lea	 ecx, DWORD PTR _szExt$[esp+19076]
  004b3	51		 push	 ecx
  004b4	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  004b9	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  004bc	89 84 16 8c 00
	00 00		 mov	 DWORD PTR [esi+edx+140], eax

; 667  : 			__int64 iRandomOptItemId	= GetInt64PaFromStr( szExt, &nOffset );

  004c3	8d 44 24 14	 lea	 eax, DWORD PTR _nOffset$208916[esp+19080]
  004c7	50		 push	 eax
  004c8	8d 8c 24 4c 05
	00 00		 lea	 ecx, DWORD PTR _szExt$[esp+19084]
  004cf	51		 push	 ecx
  004d0	e8 00 00 00 00	 call	 ?GetInt64PaFromStr@@YA_JPADPAH@Z ; GetInt64PaFromStr
  004d5	89 54 24 2c	 mov	 DWORD PTR _iRandomOptItemId$208942[esp+19092], edx

; 668  : #if __VER >= 15 // __PETVIS
; 669  : 			pPocket->m_apItem[i].m_bTranformVisPet = static_cast<BOOL>( GetIntPaFromStr( szExt, &nOffset ) );

  004d9	8d 54 24 1c	 lea	 edx, DWORD PTR _nOffset$208916[esp+19088]
  004dd	8b d8		 mov	 ebx, eax
  004df	52		 push	 edx
  004e0	8d 84 24 54 05
	00 00		 lea	 eax, DWORD PTR _szExt$[esp+19092]
  004e7	50		 push	 eax
  004e8	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  004ed	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  004f0	83 c4 18	 add	 esp, 24			; 00000018H

; 670  : #endif // __PETVIS
; 671  : 			if( iRandomOptItemId == -102 )

  004f3	83 fb 9a	 cmp	 ebx, -102		; ffffff9aH
  004f6	89 84 0e 9c 00
	00 00		 mov	 DWORD PTR [esi+ecx+156], eax
  004fd	75 0d		 jne	 SHORT $L208944
  004ff	83 7c 24 1c ff	 cmp	 DWORD PTR _iRandomOptItemId$208942[esp+19076], -1
  00504	75 06		 jne	 SHORT $L208944

; 672  : 				iRandomOptItemId	= 0;

  00506	33 db		 xor	 ebx, ebx
  00508	89 5c 24 1c	 mov	 DWORD PTR _iRandomOptItemId$208942[esp+19076], ebx
$L208944:

; 673  : 			pPocket->m_apItem[i++].SetRandomOptItemId( iRandomOptItemId );

  0050c	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0050f	8b 54 24 1c	 mov	 edx, DWORD PTR _iRandomOptItemId$208942[esp+19076]
  00513	03 c6		 add	 eax, esi
  00515	89 98 90 00 00
	00		 mov	 DWORD PTR [eax+144], ebx
  0051b	89 90 94 00 00
	00		 mov	 DWORD PTR [eax+148], edx

; 674  : 			nOffset++;

  00521	8b 44 24 0c	 mov	 eax, DWORD PTR _nOffset$208916[esp+19072]
  00525	8a 8c 04 41 05
	00 00		 mov	 cl, BYTE PTR _szExt$[esp+eax+19073]
  0052c	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  00532	40		 inc	 eax
  00533	33 db		 xor	 ebx, ebx
  00535	80 f9 24	 cmp	 cl, 36			; 00000024H
  00538	89 44 24 0c	 mov	 DWORD PTR _nOffset$208916[esp+19072], eax
  0053c	0f 85 2e ff ff
	ff		 jne	 $L208937
$L208938:

; 677  : 		while( '$' != szPiercing[nOffset] )

  00542	80 bc 24 78 1d
	00 00 24	 cmp	 BYTE PTR _szPiercing$[esp+19072], 36 ; 00000024H
  0054a	89 5c 24 0c	 mov	 DWORD PTR _nOffset$208916[esp+19072], ebx
  0054e	74 34		 je	 SHORT $L208947

; 675  : 		}
; 676  : 		nOffset		= i	= 0;

  00550	33 f6		 xor	 esi, esi
$L208946:

; 678  : 		{
; 679  : #if __VER >= 12 // __EXT_PIERCING
; 680  : 			LoadPiercingInfo( pPocket->m_apItem[i], szPiercing, &nOffset );

  00552	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00555	8d 44 24 0c	 lea	 eax, DWORD PTR _nOffset$208916[esp+19072]
  00559	50		 push	 eax
  0055a	8d 8c 24 7c 1d
	00 00		 lea	 ecx, DWORD PTR _szPiercing$[esp+19076]
  00561	51		 push	 ecx
  00562	8b 4c 24 18	 mov	 ecx, DWORD PTR $T217982[esp+19080]
  00566	03 d6		 add	 edx, esi
  00568	52		 push	 edx
  00569	e8 00 00 00 00	 call	 ?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z ; CDbManager::LoadPiercingInfo
  0056e	8b 44 24 0c	 mov	 eax, DWORD PTR _nOffset$208916[esp+19072]
  00572	8a 8c 04 78 1d
	00 00		 mov	 cl, BYTE PTR _szPiercing$[esp+eax+19072]

; 681  : #else // __EXT_PIERCING
; 682  : 			pPocket->m_apItem[i].SetPiercingSize( GetIntFromStr( szPiercing, &nOffset ) );
; 683  : 			for( int j = 0; j < pPocket->m_apItem[i].GetPiercingSize(); j++ )
; 684  : 				pPocket->m_apItem[i].SetPiercingItem( j, (DWORD)GetIntFromStr( szPiercing, &nOffset ) );
; 685  : #endif // __EXT_PIERCING
; 686  : 			i++;

  00579	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  0057f	80 f9 24	 cmp	 cl, 36			; 00000024H
  00582	75 ce		 jne	 SHORT $L208946
$L208947:

; 689  : 		while( '$' != szPet[nOffset] )

  00584	80 bc 24 10 0d
	00 00 24	 cmp	 BYTE PTR _szPet$[esp+19072], 36 ; 00000024H
  0058c	89 5c 24 0c	 mov	 DWORD PTR _nOffset$208916[esp+19072], ebx
  00590	0f 84 0b 02 00
	00		 je	 $L208950

; 687  : 		}
; 688  : 		nOffset		= i	= 0;

  00596	89 5c 24 14	 mov	 DWORD PTR tv908[esp+19072], ebx
  0059a	8d 9b 00 00 00
	00		 npad	 6
$L208949:

; 690  : 		{
; 691  : 			BOOL bPet	= (BOOL)GetIntFromStr( szPet, &nOffset );

  005a0	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nOffset$208916[esp+19072]
  005a4	51		 push	 ecx
  005a5	8d 94 24 14 0d
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19076]
  005ac	52		 push	 edx
  005ad	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 692  : 			if( bPet )

  005b2	33 f6		 xor	 esi, esi
  005b4	83 c4 08	 add	 esp, 8
  005b7	3b c6		 cmp	 eax, esi
  005b9	0f 84 c4 01 00
	00		 je	 $L208953

; 693  : 			{
; 694  : 				SAFE_DELETE( pPocket->m_apItem[i].m_pPet );

  005bf	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  005c2	8b 8c 03 98 00
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+152]
  005c9	3b ce		 cmp	 ecx, esi
  005cb	74 10		 je	 SHORT $L208954
  005cd	8b 11		 mov	 edx, DWORD PTR [ecx]
  005cf	6a 01		 push	 1
  005d1	ff 12		 call	 DWORD PTR [edx]
  005d3	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  005d6	89 b4 03 98 00
	00 00		 mov	 DWORD PTR [ebx+eax+152], esi
$L208954:

; 695  : 				CPet* pPet	= pPocket->m_apItem[i].m_pPet	= new CPet;

  005dd	6a 28		 push	 40			; 00000028H
  005df	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  005e4	83 c4 04	 add	 esp, 4
  005e7	89 44 24 18	 mov	 DWORD PTR $T217946[esp+19072], eax
  005eb	3b c6		 cmp	 eax, esi
  005ed	c7 84 24 7c 4a
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+19080], 1
  005f8	74 09		 je	 SHORT $L217948
  005fa	8b c8		 mov	 ecx, eax
  005fc	e8 00 00 00 00	 call	 ??0CPet@@QAE@XZ		; CPet::CPet
  00601	8b f0		 mov	 esi, eax
$L217948:
  00603	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]

; 696  : 				BYTE nKind	= (BYTE)GetIntFromStr( szPet, &nOffset );

  00606	8d 54 24 0c	 lea	 edx, DWORD PTR _nOffset$208916[esp+19072]
  0060a	52		 push	 edx
  0060b	8d 84 24 14 0d
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19076]
  00612	50		 push	 eax
  00613	c7 84 24 84 4a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+19088], -1
  0061e	89 b4 0b 98 00
	00 00		 mov	 DWORD PTR [ebx+ecx+152], esi
  00625	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 697  : 				pPet->SetKind( nKind );
; 698  : 				BYTE nLevel	= (BYTE)GetIntFromStr( szPet, &nOffset );

  0062a	8d 4c 24 14	 lea	 ecx, DWORD PTR _nOffset$208916[esp+19080]
  0062e	51		 push	 ecx
  0062f	8d 94 24 1c 0d
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19084]
  00636	52		 push	 edx
  00637	88 46 04	 mov	 BYTE PTR [esi+4], al
  0063a	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 699  : 				pPet->SetLevel( nLevel );

  0063f	88 46 05	 mov	 BYTE PTR [esi+5], al

; 700  : 				DWORD dwExp	= (DWORD)GetIntFromStr( szPet, &nOffset );

  00642	8d 44 24 1c	 lea	 eax, DWORD PTR _nOffset$208916[esp+19088]
  00646	50		 push	 eax
  00647	8d 8c 24 24 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19092]
  0064e	51		 push	 ecx
  0064f	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00654	83 c4 18	 add	 esp, 24			; 00000018H

; 701  : 				pPet->SetExp( dwExp );

  00657	50		 push	 eax
  00658	8b ce		 mov	 ecx, esi
  0065a	e8 00 00 00 00	 call	 ?SetExp@CPet@@QAEXK@Z	; CPet::SetExp

; 702  : 				WORD wEnergy	= (WORD)GetIntFromStr( szPet, &nOffset );

  0065f	8d 54 24 0c	 lea	 edx, DWORD PTR _nOffset$208916[esp+19072]
  00663	52		 push	 edx
  00664	8d 84 24 14 0d
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+19076]
  0066b	50		 push	 eax
  0066c	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00671	83 c4 08	 add	 esp, 8

; 703  : 				pPet->SetEnergy( wEnergy );

  00674	50		 push	 eax
  00675	8b ce		 mov	 ecx, esi
  00677	e8 00 00 00 00	 call	 ?SetEnergy@CPet@@QAEXG@Z ; CPet::SetEnergy

; 704  : #ifdef __PET_1024
; 705  : 				WORD wLife	= (WORD)GetIntPaFromStr( szPet, &nOffset );

  0067c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _nOffset$208916[esp+19072]
  00680	51		 push	 ecx
  00681	8d 94 24 14 0d
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+19076]
  00688	52		 push	 edx
  00689	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 706  : 				pPet->SetLife( wLife );

  0068e	66 89 46 0e	 mov	 WORD PTR [esi+14], ax

; 707  : 				for( int j = PL_D; j <= pPet->GetLevel(); j++ )

  00692	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00695	bb 01 00 00 00	 mov	 ebx, 1
  0069a	83 c4 08	 add	 esp, 8
  0069d	3a c3		 cmp	 al, bl
  0069f	72 2f		 jb	 SHORT $L208976
$L208974:

; 708  : 				{
; 709  : 					BYTE nAvailLevel	= (BYTE)GetIntPaFromStr( szPet, &nOffset );

  006a1	8d 44 24 0c	 lea	 eax, DWORD PTR _nOffset$208916[esp+19072]
  006a5	50		 push	 eax
  006a6	8d 8c 24 14 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19076]
  006ad	51		 push	 ecx
  006ae	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  006b3	88 44 24 2c	 mov	 BYTE PTR _nAvailLevel$208977[esp+19080], al

; 710  : 					pPet->SetAvailLevel( j, nAvailLevel );

  006b7	8b 54 24 2c	 mov	 edx, DWORD PTR _nAvailLevel$208977[esp+19080]
  006bb	83 c4 08	 add	 esp, 8
  006be	52		 push	 edx
  006bf	53		 push	 ebx
  006c0	8b ce		 mov	 ecx, esi
  006c2	e8 00 00 00 00	 call	 ?SetAvailLevel@CPet@@QAEXEE@Z ; CPet::SetAvailLevel
  006c7	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  006cb	43		 inc	 ebx
  006cc	3b d8		 cmp	 ebx, eax
  006ce	7e d1		 jle	 SHORT $L208974
$L208976:

; 711  : 				}
; 712  : 				char szFmt[MAX_PET_NAME_FMT]	= { 0,};

  006d0	33 c9		 xor	 ecx, ecx
  006d2	89 8c 24 dd 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19073], ecx
  006d9	89 8c 24 e1 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19077], ecx
  006e0	89 8c 24 e5 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19081], ecx
  006e7	89 8c 24 e9 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19085], ecx
  006ee	89 8c 24 ed 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19089], ecx
  006f5	89 8c 24 f1 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19093], ecx
  006fc	89 8c 24 f5 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19097], ecx

; 713  : 				GetStrFromStr( szPet, szFmt, &nOffset );

  00703	8d 54 24 0c	 lea	 edx, DWORD PTR _nOffset$208916[esp+19072]
  00707	52		 push	 edx
  00708	8d 84 24 e0 00
	00 00		 lea	 eax, DWORD PTR _szFmt$208979[esp+19076]
  0070f	89 8c 24 fd 00
	00 00		 mov	 DWORD PTR _szFmt$208979[esp+19105], ecx
  00716	50		 push	 eax
  00717	8d 8c 24 18 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+19080]
  0071e	51		 push	 ecx
  0071f	c6 84 24 e8 00
	00 00 00	 mov	 BYTE PTR _szFmt$208979[esp+19084], 0
  00727	e8 00 00 00 00	 call	 ?GetStrFromStr@@YAXPAD0PAH@Z ; GetStrFromStr
  0072c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 714  : 				char szName[MAX_PET_NAME]	= { 0,};

  0072f	33 d2		 xor	 edx, edx

; 715  : 				GetDBFormatStr( szName, MAX_PET_NAME, szFmt );

  00731	8d 84 24 dc 00
	00 00		 lea	 eax, DWORD PTR _szFmt$208979[esp+19072]
  00738	89 94 24 c9 00
	00 00		 mov	 DWORD PTR _szName$208980[esp+19073], edx
  0073f	50		 push	 eax
  00740	89 94 24 d1 00
	00 00		 mov	 DWORD PTR _szName$208980[esp+19081], edx
  00747	6a 11		 push	 17			; 00000011H
  00749	8d 8c 24 d0 00
	00 00		 lea	 ecx, DWORD PTR _szName$208980[esp+19080]
  00750	89 94 24 d9 00
	00 00		 mov	 DWORD PTR _szName$208980[esp+19089], edx
  00757	51		 push	 ecx
  00758	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T217982[esp+19084]
  0075c	c6 84 24 d4 00
	00 00 00	 mov	 BYTE PTR _szName$208980[esp+19084], 0
  00764	89 94 24 e1 00
	00 00		 mov	 DWORD PTR _szName$208980[esp+19097], edx
  0076b	e8 00 00 00 00	 call	 ?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z ; CDbManager::GetDBFormatStr

; 716  : 				pPet->SetName( szName );

  00770	8d 94 24 c8 00
	00 00		 lea	 edx, DWORD PTR _szName$208980[esp+19072]
  00777	52		 push	 edx
  00778	8b ce		 mov	 ecx, esi
  0077a	e8 00 00 00 00	 call	 ?SetName@CPet@@QAEXPBD@Z ; CPet::SetName
  0077f	8b 5c 24 14	 mov	 ebx, DWORD PTR tv908[esp+19072]
$L208953:
  00783	8b 44 24 0c	 mov	 eax, DWORD PTR _nOffset$208916[esp+19072]
  00787	8a 8c 04 10 0d
	00 00		 mov	 cl, BYTE PTR _szPet$[esp+eax+19072]

; 717  : #else	// __PET_1024
; 718  : 				WORD wLife	= (WORD)GetIntFromStr( szPet, &nOffset );
; 719  : 				pPet->SetLife( wLife );
; 720  : 				for( int j = PL_D; j <= pPet->GetLevel(); j++ )
; 721  : 				{
; 722  : 					BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &nOffset );
; 723  : 					pPet->SetAvailLevel( j, nAvailLevel );
; 724  : 				}
; 725  : #endif	// __PET_1024
; 726  : 			}
; 727  : 			i++;

  0078e	81 c3 a0 00 00
	00		 add	 ebx, 160		; 000000a0H
  00794	80 f9 24	 cmp	 cl, 36			; 00000024H
  00797	89 5c 24 14	 mov	 DWORD PTR tv908[esp+19072], ebx
  0079b	0f 85 ff fd ff
	ff		 jne	 $L208949
$L208950:

; 728  : 		}
; 729  : 	}
; 730  : 	return TRUE;

  007a1	b8 01 00 00 00	 mov	 eax, 1
$L208884:

; 731  : }

  007a6	8b 8c 24 74 4a
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+19072]
  007ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  007b4	8b 8c 24 6c 4a
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+19072]
  007bb	5f		 pop	 edi
  007bc	5e		 pop	 esi
  007bd	33 cd		 xor	 ecx, ebp
  007bf	5b		 pop	 ebx
  007c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007c5	8b e5		 mov	 esp, ebp
  007c7	5d		 pop	 ebp
  007c8	c2 0c 00	 ret	 12			; 0000000cH
$L217997:

; 647  : 				{
; 648  : 					Error( "Join:Pocket:POCKET_SLOT_SIZE_1_2" );

  007cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@EAAOHIMM@Join?3Pocket?3POCKET_SLOT_SIZE_1_2@
  007d0	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  007d5	83 c4 04	 add	 esp, 4

; 649  : 					return FALSE;

  007d8	8d 4c 24 28	 lea	 ecx, DWORD PTR _itemElem$208921[esp+19072]
  007dc	89 b4 24 7c 4a
	00 00		 mov	 DWORD PTR __$EHRec$[esp+19080], esi
  007e3	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L218015:
  007e8	33 c0		 xor	 eax, eax
  007ea	eb ba		 jmp	 SHORT $L208884
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L217949:
  00000	8d 8d a8 b5 ff
	ff		 lea	 ecx, DWORD PTR _itemElem$208921[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L217950:
  0000b	8b 85 98 b5 ff
	ff		 mov	 eax, DWORD PTR $T217946[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
  00018	c3		 ret	 0
__ehhandler$?GetPocket@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z:
  00019	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T217987
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetPocket@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetPocket
PUBLIC	??_C@_0M@GIEPEBGM@m_Inventory?$AA@		; `string'
PUBLIC	??_C@_0CF@JJEIFMEB@Inventory?5?3?5?$DM?$DM?5?G?A?$LH?N?F?$NL?F?$LM?5?$LO?x?$MA?$LN?4?5?$CFs@ ; `string'
PUBLIC	??_C@_0CG@KLFMFNBG@Join?3?3Inventory?5?3?5?$DM?$DM?5IndexItem?5?$CF@ ; `string'
PUBLIC	??_C@_0P@FEOHFPFP@Inventory?5?$DN?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_09HGEFOOAJ@m_apIndex?$AA@			; `string'
PUBLIC	??_C@_0N@KMOLMNCJ@m_dwObjIndex?$AA@		; `string'
PUBLIC	??_C@_0P@CJDMDHFC@m_extInventory?$AA@		; `string'
PUBLIC	??_C@_0BE@OAKPNEDM@m_InventoryPiercing?$AA@	; `string'
PUBLIC	??_C@_0P@GAFIDLHN@szInventoryPet?$AA@		; `string'
PUBLIC	?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetInventory
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
xdata$x	SEGMENT
$T218091 DD	0ffffffffH
	DD	FLAT:$L218032
	DD	0ffffffffH
	DD	FLAT:$L218033
$T218063 DD	019930520H
	DD	02H
	DD	FLAT:$T218091
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0M@GIEPEBGM@m_Inventory?$AA@
CONST	SEGMENT
??_C@_0M@GIEPEBGM@m_Inventory?$AA@ DB 'm_Inventory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JJEIFMEB@Inventory?5?3?5?$DM?$DM?5?G?A?$LH?N?F?$NL?F?$LM?5?$LO?x?$MA?$LN?4?5?$CFs@
CONST	SEGMENT
??_C@_0CF@JJEIFMEB@Inventory?5?3?5?$DM?$DM?5?G?A?$LH?N?F?$NL?F?$LM?5?$LO?x?$MA?$LN?4?5?$CFs@ DB 'I'
	DB	'nventory : << ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH, 0c6H, 0bcH
	DB	' ', 0beH, 0f8H, 0c0H, 0bdH, '. %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HGEFOOAJ@m_apIndex?$AA@
CONST	SEGMENT
??_C@_09HGEFOOAJ@m_apIndex?$AA@ DB 'm_apIndex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMOLMNCJ@m_dwObjIndex?$AA@
CONST	SEGMENT
??_C@_0N@KMOLMNCJ@m_dwObjIndex?$AA@ DB 'm_dwObjIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CJDMDHFC@m_extInventory?$AA@
CONST	SEGMENT
??_C@_0P@CJDMDHFC@m_extInventory?$AA@ DB 'm_extInventory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OAKPNEDM@m_InventoryPiercing?$AA@
CONST	SEGMENT
??_C@_0BE@OAKPNEDM@m_InventoryPiercing?$AA@ DB 'm_InventoryPiercing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAFIDLHN@szInventoryPet?$AA@
CONST	SEGMENT
??_C@_0P@GAFIDLHN@szInventoryPet?$AA@ DB 'szInventoryPet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KLFMFNBG@Join?3?3Inventory?5?3?5?$DM?$DM?5IndexItem?5?$CF@
CONST	SEGMENT
??_C@_0CG@KLFMFNBG@Join?3?3Inventory?5?3?5?$DM?$DM?5IndexItem?5?$CF@ DB 'J'
	DB	'oin::Inventory : << IndexItem %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FEOHFPFP@Inventory?5?$DN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@FEOHFPFP@Inventory?5?$DN?5?$CFs?$AA@ DB 'Inventory = %s', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
_TEXT	SEGMENT
_CountStr$ = -17548					; size = 4
tv926 = -17544						; size = 4
$T218061 = -17544					; size = 4
_nAvailLevel$209075 = -17540				; size = 1
$T218060 = -17540					; size = 4
$T218058 = -17536					; size = 4
$T218029 = -17532					; size = 4
_BufItemElem$208998 = -17528				; size = 160
_szName$209078 = -17368					; size = 17
_szFmt$209077 = -17348					; size = 33
_szPlayerName$ = -17312					; size = 64
_m_apIndex$ = -17248					; size = 512
_ObjIndex$ = -16736					; size = 512
_ExtInven$ = -16224					; size = 2000
_szPet$ = -14224					; size = 4200
_PirecingInven$ = -10024				; size = 4000
_Inven$ = -6024						; size = 6000
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pMover$ = 8						; size = 4
_qry$ = 12						; size = 4
_lpDbOverlappedPlus$ = 16				; size = 4
?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z PROC NEAR ; CDbManager::GetInventory, COMDAT
; _this$ = ecx

; 735  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	51		 push	 ecx
  0001c	b8 7c 44 00 00	 mov	 eax, 17532		; 0000447cH
  00021	e8 00 00 00 00	 call	 __chkstk
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 84 24 78 44
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+17548], eax

; 749  : 	VERIFYSTRING_RETURN( Inven, szPlayerName );	// if false, return

  00034	8b 45 0c	 mov	 eax, DWORD PTR _qry$[ebp]
  00037	8b 55 10	 mov	 edx, DWORD PTR _lpDbOverlappedPlus$[ebp]
  0003a	53		 push	 ebx
  0003b	89 44 24 0c	 mov	 DWORD PTR $T218060[esp+17552], eax
  0003f	8b 5d 08	 mov	 ebx, DWORD PTR _pMover$[ebp]
  00042	33 c0		 xor	 eax, eax
  00044	56		 push	 esi
  00045	57		 push	 edi
  00046	8b f1		 mov	 esi, ecx
  00048	c6 84 24 10 2d
	00 00 00	 mov	 BYTE PTR _Inven$[esp+17560], 0
  00050	b9 db 05 00 00	 mov	 ecx, 1499		; 000005dbH
  00055	8d bc 24 11 2d
	00 00		 lea	 edi, DWORD PTR _Inven$[esp+17561]
  0005c	f3 ab		 rep stosd
  0005e	66 ab		 stosw
  00060	aa		 stosb
  00061	33 c0		 xor	 eax, eax
  00063	85 d2		 test	 edx, edx
  00065	c6 84 24 f8 00
	00 00 00	 mov	 BYTE PTR _szPlayerName$[esp+17560], 0
  0006d	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00072	8d bc 24 f9 00
	00 00		 lea	 edi, DWORD PTR _szPlayerName$[esp+17561]
  00079	f3 ab		 rep stosd
  0007b	66 ab		 stosw

; 875  : #else	// __PET_1024
; 876  : 			WORD wLife	= (WORD)GetIntFromStr( szPet, &CountStr );
; 877  : 			pPet->SetLife( wLife );
; 878  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )
; 879  : 			{
; 880  : 				BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );
; 881  : 				pPet->SetAvailLevel( i, nAvailLevel );
; 882  : 			}
; 883  : #endif	// __PET_1024
; 884  : 		}
; 885  : 		nId++;

  0007d	89 74 24 18	 mov	 DWORD PTR $T218058[esp+17560], esi
  00081	89 54 24 10	 mov	 DWORD PTR $T218061[esp+17560], edx
  00085	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17560], 0
  0008d	aa		 stosb
  0008e	74 1c		 je	 SHORT $L208991
  00090	8d 42 74	 lea	 eax, DWORD PTR [edx+116]
  00093	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+17560]
  0009a	2b d0		 sub	 edx, eax
  0009c	8d 64 24 00	 npad	 4
$L218021:
  000a0	8a 08		 mov	 cl, BYTE PTR [eax]
  000a2	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000a5	40		 inc	 eax
  000a6	84 c9		 test	 cl, cl
  000a8	75 f6		 jne	 SHORT $L218021

; 736  : 	int CountStr	= 0;
; 737  : 	int IndexItem	= 0;
; 738  : 	char Inven[6000]	= { 0, };
; 739  : 	char szPlayerName[64] = {0, };
; 740  : 	if( lpDbOverlappedPlus != NULL )
; 741  : 	{
; 742  : 		_tcscpy( szPlayerName, lpDbOverlappedPlus->AccountInfo.szPlayer );
; 743  : 	}
; 744  : 	else

  000aa	eb 16		 jmp	 SHORT $L208992
$L208991:

; 745  : 	{
; 746  : 		_tcscpy( szPlayerName, pMover->m_szName );

  000ac	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  000af	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+17560]
  000b6	2b d0		 sub	 edx, eax
$L218022:
  000b8	8a 08		 mov	 cl, BYTE PTR [eax]
  000ba	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000bd	40		 inc	 eax
  000be	84 c9		 test	 cl, cl
  000c0	75 f6		 jne	 SHORT $L218022
$L208992:

; 747  : 	}
; 748  : 	qry->GetStr("m_Inventory", Inven);

  000c2	8d 8c 24 10 2d
	00 00		 lea	 ecx, DWORD PTR _Inven$[esp+17560]
  000c9	51		 push	 ecx
  000ca	8b 4c 24 18	 mov	 ecx, DWORD PTR $T218060[esp+17564]
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@GIEPEBGM@m_Inventory?$AA@
  000d3	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 749  : 	VERIFYSTRING_RETURN( Inven, szPlayerName );	// if false, return

  000d8	8d 84 24 10 2d
	00 00		 lea	 eax, DWORD PTR _Inven$[esp+17560]
  000df	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L218082:
  000e2	8a 08		 mov	 cl, BYTE PTR [eax]
  000e4	40		 inc	 eax
  000e5	84 c9		 test	 cl, cl
  000e7	75 f9		 jne	 SHORT $L218082
  000e9	2b c2		 sub	 eax, edx
  000eb	33 ff		 xor	 edi, edi
  000ed	3b c7		 cmp	 eax, edi
  000ef	7e 0a		 jle	 SHORT $L218037
  000f1	80 bc 04 0f 2d
	00 00 24	 cmp	 BYTE PTR _Inven$[esp+eax+17559], 36 ; 00000024H
  000f9	74 36		 je	 SHORT $L218066
$L218037:
  000fb	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+17560]
  00102	52		 push	 edx
  00103	68 ed 02 00 00	 push	 749			; 000002edH
  00108	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0010d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09GBAEEKDE@?$CFs?0?5?$CFd?7?$CFs?$AA@
  00112	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00117	8b 44 24 20	 mov	 eax, DWORD PTR $T218061[esp+17576]
  0011b	83 c4 10	 add	 esp, 16			; 00000010H
  0011e	3b c7		 cmp	 eax, edi
  00120	74 08		 je	 SHORT $L218038
  00122	50		 push	 eax
  00123	8b ce		 mov	 ecx, esi
  00125	e8 00 00 00 00	 call	 ?FreeRequest@CDbManager@@QAEXPAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::FreeRequest
$L218038:
  0012a	33 c0		 xor	 eax, eax
  0012c	e9 74 06 00 00	 jmp	 $L208986
$L218066:

; 750  : 	while('$' != Inven[CountStr])

  00131	80 bc 24 10 2d
	00 00 24	 cmp	 BYTE PTR _Inven$[esp+17560], 36 ; 00000024H
  00139	0f 84 8f 00 00
	00		 je	 $L208997
  0013f	90		 npad	 1
$L208996:

; 751  : 	{
; 752  : 		CItemElem BufItemElem;

  00140	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208998[esp+17560]
  00144	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 753  : 		IndexItem = GetOneItem( &BufItemElem, Inven, &CountStr );

  00149	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+17560]
  0014d	50		 push	 eax
  0014e	8d 8c 24 14 2d
	00 00		 lea	 ecx, DWORD PTR _Inven$[esp+17564]
  00155	51		 push	 ecx
  00156	8d 54 24 28	 lea	 edx, DWORD PTR _BufItemElem$208998[esp+17568]
  0015a	52		 push	 edx
  0015b	8b ce		 mov	 ecx, esi
  0015d	89 bc 24 a0 44
	00 00		 mov	 DWORD PTR __$EHRec$[esp+17580], edi
  00164	e8 00 00 00 00	 call	 ?GetOneItem@CDbManager@@QAEHPAVCItemElem@@PADPAH@Z ; CDbManager::GetOneItem

; 754  : 		if( IndexItem == -1 )

  00169	83 f8 ff	 cmp	 eax, -1
  0016c	75 18		 jne	 SHORT $L208999

; 755  : 		{
; 756  : 			Error( "Inventory : <<  . %s, %d", pMover->m_szName, BufItemElem.m_dwItemId );

  0016e	8b 44 24 28	 mov	 eax, DWORD PTR _BufItemElem$208998[esp+17568]
  00172	50		 push	 eax
  00173	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  00176	51		 push	 ecx
  00177	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@JJEIFMEB@Inventory?5?3?5?$DM?$DM?5?G?A?$LH?N?F?$NL?F?$LM?5?$LO?x?$MA?$LN?4?5?$CFs@
  0017c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH

; 757  : 		}
; 758  : 		else

  00184	eb 22		 jmp	 SHORT $L209001
$L208999:

; 759  : 		{
; 760  : 			if( IndexItem >= MAX_INVENTORY + MAX_HUMAN_PARTS)

  00186	83 f8 49	 cmp	 eax, 73			; 00000049H
  00189	0f 8d 3b 06 00
	00		 jge	 $L218073

; 765  : 			}
; 766  : 			pMover->m_Inventory.m_apItem[IndexItem] = BufItemElem;

  0018f	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00192	8b 83 20 41 00
	00		 mov	 eax, DWORD PTR [ebx+16672]
  00198	c1 e2 05	 shl	 edx, 5
  0019b	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  0019e	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a0	8d 44 24 20	 lea	 eax, DWORD PTR _BufItemElem$208998[esp+17560]
  001a4	50		 push	 eax
  001a5	ff 52 10	 call	 DWORD PTR [edx+16]
$L209001:

; 767  : 		}
; 768  : 	}

  001a8	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208998[esp+17560]
  001ac	c7 84 24 94 44
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+17568], -1
  001b7	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  001bc	8b 4c 24 0c	 mov	 ecx, DWORD PTR _CountStr$[esp+17560]
  001c0	80 bc 0c 10 2d
	00 00 24	 cmp	 BYTE PTR _Inven$[esp+ecx+17560], 36 ; 00000024H
  001c8	0f 85 72 ff ff
	ff		 jne	 $L208996
$L208997:

; 769  : 	
; 770  : 	CountStr	= 0;

  001ce	89 7c 24 0c	 mov	 DWORD PTR _CountStr$[esp+17560], edi

; 771  : 	int itemCount	= 0;
; 772  : 	char m_apIndex[512]		= { 0, };

  001d2	33 c0		 xor	 eax, eax
  001d4	c6 84 24 38 01
	00 00 00	 mov	 BYTE PTR _m_apIndex$[esp+17560], 0
  001dc	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  001e1	8d bc 24 39 01
	00 00		 lea	 edi, DWORD PTR _m_apIndex$[esp+17561]
  001e8	f3 ab		 rep stosd

; 773  : 	qry->GetStr( "m_apIndex", m_apIndex );

  001ea	8b 4c 24 14	 mov	 ecx, DWORD PTR $T218060[esp+17560]
  001ee	66 ab		 stosw
  001f0	aa		 stosb
  001f1	8d 84 24 38 01
	00 00		 lea	 eax, DWORD PTR _m_apIndex$[esp+17560]
  001f8	50		 push	 eax
  001f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09HGEFOOAJ@m_apIndex?$AA@
  001fe	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 774  : 	VERIFYSTRING_RETURN( m_apIndex, szPlayerName );

  00203	8b 4c 24 10	 mov	 ecx, DWORD PTR $T218061[esp+17560]
  00207	51		 push	 ecx
  00208	8d 94 24 fc 00
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+17564]
  0020f	52		 push	 edx
  00210	68 06 03 00 00	 push	 774			; 00000306H
  00215	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  0021a	8d 84 24 48 01
	00 00		 lea	 eax, DWORD PTR _m_apIndex$[esp+17576]
  00221	50		 push	 eax
  00222	8b ce		 mov	 ecx, esi
  00224	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00229	85 c0		 test	 eax, eax
  0022b	0f 84 d1 05 00
	00		 je	 $L218090

; 775  : 	while( '$' != m_apIndex[CountStr] )

  00231	80 bc 24 38 01
	00 00 24	 cmp	 BYTE PTR _m_apIndex$[esp+17560], 36 ; 00000024H
  00239	74 35		 je	 SHORT $L209012
  0023b	33 ff		 xor	 edi, edi
  0023d	8d 49 00	 npad	 3
$L209011:

; 776  : 	{
; 777  : 		pMover->m_Inventory.m_apIndex[itemCount]	= (DWORD)GetIntFromStr( m_apIndex, &CountStr );

  00240	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17560]
  00244	51		 push	 ecx
  00245	8d 94 24 3c 01
	00 00		 lea	 edx, DWORD PTR _m_apIndex$[esp+17564]
  0024c	52		 push	 edx
  0024d	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  00252	8b 8b 18 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16664]
  00258	8b 54 24 14	 mov	 edx, DWORD PTR _CountStr$[esp+17568]
  0025c	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax
  0025f	8a 84 14 40 01
	00 00		 mov	 al, BYTE PTR _m_apIndex$[esp+edx+17568]
  00266	83 c4 08	 add	 esp, 8

; 778  : 		itemCount++;

  00269	83 c7 04	 add	 edi, 4
  0026c	3c 24		 cmp	 al, 36			; 00000024H
  0026e	75 d0		 jne	 SHORT $L209011
$L209012:

; 779  : 	}
; 780  : 	
; 781  : 	CountStr	= 0;
; 782  : 	int IndexObjIndex	= 0;
; 783  : 	char ObjIndex[512]	= {0,};

  00270	33 c0		 xor	 eax, eax
  00272	c6 84 24 38 03
	00 00 00	 mov	 BYTE PTR _ObjIndex$[esp+17560], 0
  0027a	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0027f	8d bc 24 39 03
	00 00		 lea	 edi, DWORD PTR _ObjIndex$[esp+17561]
  00286	f3 ab		 rep stosd

; 784  : 	qry->GetStr( "m_dwObjIndex", ObjIndex );

  00288	8b 4c 24 14	 mov	 ecx, DWORD PTR $T218060[esp+17560]
  0028c	66 ab		 stosw
  0028e	aa		 stosb
  0028f	8d 84 24 38 03
	00 00		 lea	 eax, DWORD PTR _ObjIndex$[esp+17560]
  00296	50		 push	 eax
  00297	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KMOLMNCJ@m_dwObjIndex?$AA@
  0029c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17568], 0
  002a4	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 785  : 	VERIFYSTRING_RETURN( ObjIndex, szPlayerName );

  002a9	8b 4c 24 10	 mov	 ecx, DWORD PTR $T218061[esp+17560]
  002ad	51		 push	 ecx
  002ae	8d 94 24 fc 00
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+17564]
  002b5	52		 push	 edx
  002b6	68 11 03 00 00	 push	 785			; 00000311H
  002bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  002c0	8d 84 24 48 03
	00 00		 lea	 eax, DWORD PTR _ObjIndex$[esp+17576]
  002c7	50		 push	 eax
  002c8	8b ce		 mov	 ecx, esi
  002ca	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  002cf	85 c0		 test	 eax, eax
  002d1	0f 84 2b 05 00
	00		 je	 $L218090

; 786  : 	while( '$' != ObjIndex[CountStr] )

  002d7	80 bc 24 38 03
	00 00 24	 cmp	 BYTE PTR _ObjIndex$[esp+17560], 36 ; 00000024H
  002df	74 36		 je	 SHORT $L209020
  002e1	33 ff		 xor	 edi, edi
$L209019:

; 787  : 	{
; 788  : 		pMover->m_Inventory.m_apItem[IndexObjIndex].m_dwObjIndex	= (DWORD)GetIntFromStr( ObjIndex, &CountStr );

  002e3	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17560]
  002e7	51		 push	 ecx
  002e8	8d 94 24 3c 03
	00 00		 lea	 edx, DWORD PTR _ObjIndex$[esp+17564]
  002ef	52		 push	 edx
  002f0	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  002f5	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]
  002fb	8b 54 24 14	 mov	 edx, DWORD PTR _CountStr$[esp+17568]
  002ff	89 44 0f 2c	 mov	 DWORD PTR [edi+ecx+44], eax
  00303	8a 84 14 40 03
	00 00		 mov	 al, BYTE PTR _ObjIndex$[esp+edx+17568]
  0030a	83 c4 08	 add	 esp, 8

; 789  : 		IndexObjIndex++;

  0030d	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H
  00313	3c 24		 cmp	 al, 36			; 00000024H
  00315	75 cc		 jne	 SHORT $L209019
$L209020:

; 790  : 	}
; 791  : 
; 792  : 	CountStr	= 0;
; 793  : 	int nExtInven = 0;
; 794  : 	char ExtInven[2000] = {0,};

  00317	33 c0		 xor	 eax, eax
  00319	c6 84 24 38 05
	00 00 00	 mov	 BYTE PTR _ExtInven$[esp+17560], 0
  00321	b9 f3 01 00 00	 mov	 ecx, 499		; 000001f3H
  00326	8d bc 24 39 05
	00 00		 lea	 edi, DWORD PTR _ExtInven$[esp+17561]
  0032d	f3 ab		 rep stosd

; 795  : 	qry->GetStr( "m_extInventory", ExtInven );

  0032f	8b 4c 24 14	 mov	 ecx, DWORD PTR $T218060[esp+17560]
  00333	66 ab		 stosw
  00335	aa		 stosb
  00336	8d 84 24 38 05
	00 00		 lea	 eax, DWORD PTR _ExtInven$[esp+17560]
  0033d	50		 push	 eax
  0033e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@CJDMDHFC@m_extInventory?$AA@
  00343	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17568], 0
  0034b	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 796  : 	VERIFYSTRING_RETURN( ExtInven, szPlayerName );

  00350	8b 4c 24 10	 mov	 ecx, DWORD PTR $T218061[esp+17560]
  00354	51		 push	 ecx
  00355	8d 94 24 fc 00
	00 00		 lea	 edx, DWORD PTR _szPlayerName$[esp+17564]
  0035c	52		 push	 edx
  0035d	68 1c 03 00 00	 push	 796			; 0000031cH
  00362	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00367	8d 84 24 48 05
	00 00		 lea	 eax, DWORD PTR _ExtInven$[esp+17576]
  0036e	50		 push	 eax
  0036f	8b ce		 mov	 ecx, esi
  00371	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00376	85 c0		 test	 eax, eax
  00378	0f 84 84 04 00
	00		 je	 $L218090

; 797  : 	while( '$' != ExtInven[CountStr] )

  0037e	80 bc 24 38 05
	00 00 24	 cmp	 BYTE PTR _ExtInven$[esp+17560], 36 ; 00000024H
  00386	0f 84 e0 00 00
	00		 je	 $L209028
  0038c	33 f6		 xor	 esi, esi
  0038e	8b ff		 npad	 2
$L209027:

; 798  : 	{
; 799  : 		pMover->m_Inventory.m_apItem[nExtInven].m_bCharged					= (BOOL)GetIntPaFromStr( ExtInven, &CountStr );

  00390	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17560]
  00394	51		 push	 ecx
  00395	8d 94 24 3c 05
	00 00		 lea	 edx, DWORD PTR _ExtInven$[esp+17564]
  0039c	52		 push	 edx
  0039d	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  003a2	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]
  003a8	89 84 0e 88 00
	00 00		 mov	 DWORD PTR [esi+ecx+136], eax

; 800  : 		if( pMover->m_Inventory.m_apItem[nExtInven].m_bCharged != 1 )

  003af	8b 93 20 41 00
	00		 mov	 edx, DWORD PTR [ebx+16672]
  003b5	8b 84 16 88 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+136]
  003bc	83 c4 08	 add	 esp, 8
  003bf	83 f8 01	 cmp	 eax, 1
  003c2	74 0d		 je	 SHORT $L209030

; 801  : 			pMover->m_Inventory.m_apItem[nExtInven].m_bCharged	= 0;

  003c4	8b c2		 mov	 eax, edx
  003c6	c7 84 06 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+136], 0
$L209030:

; 802  : 		pMover->m_Inventory.m_apItem[nExtInven].m_dwKeepTime				= (DWORD)GetIntPaFromStr( ExtInven, &CountStr );

  003d1	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17560]
  003d5	51		 push	 ecx
  003d6	8d 94 24 3c 05
	00 00		 lea	 edx, DWORD PTR _ExtInven$[esp+17564]
  003dd	52		 push	 edx
  003de	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  003e3	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]

; 803  : #if __VER >= 11 // __SYS_IDENTIFY
; 804  : 		__int64 iRandomOptItemId	= GetInt64PaFromStr( ExtInven, &CountStr );

  003e9	8d 54 24 14	 lea	 edx, DWORD PTR _CountStr$[esp+17568]
  003ed	89 84 0e 8c 00
	00 00		 mov	 DWORD PTR [esi+ecx+140], eax
  003f4	52		 push	 edx
  003f5	8d 84 24 44 05
	00 00		 lea	 eax, DWORD PTR _ExtInven$[esp+17572]
  003fc	50		 push	 eax
  003fd	e8 00 00 00 00	 call	 ?GetInt64PaFromStr@@YA_JPADPAH@Z ; GetInt64PaFromStr
  00402	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		if( iRandomOptItemId == -102 )

  00405	83 f8 9a	 cmp	 eax, -102		; ffffff9aH
  00408	75 09		 jne	 SHORT $L209033
  0040a	83 fa ff	 cmp	 edx, -1
  0040d	75 04		 jne	 SHORT $L209033

; 806  : 			iRandomOptItemId	= 0;

  0040f	33 c0		 xor	 eax, eax
  00411	33 d2		 xor	 edx, edx
$L209033:

; 807  : 		pMover->m_Inventory.m_apItem[nExtInven].SetRandomOptItemId( iRandomOptItemId );

  00413	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]
  00419	03 ce		 add	 ecx, esi
  0041b	89 91 94 00 00
	00		 mov	 DWORD PTR [ecx+148], edx
  00421	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 808  : #if __VER >= 15 // __PETVIS
; 809  : 		pMover->m_Inventory.m_apItem[nExtInven].m_bTranformVisPet = static_cast<BOOL>( GetIntPaFromStr( ExtInven, &CountStr ) );

  00427	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17560]
  0042b	51		 push	 ecx
  0042c	8d 94 24 3c 05
	00 00		 lea	 edx, DWORD PTR _ExtInven$[esp+17564]
  00433	52		 push	 edx
  00434	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  00439	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]
  0043f	89 84 0e 9c 00
	00 00		 mov	 DWORD PTR [esi+ecx+156], eax

; 810  : #endif // __PETVIS
; 811  : #else	// __SYS_IDENTIFY
; 812  : 		pMover->m_Inventory.m_apItem[nExtInven].SetRandomOptItemId( (DWORD)GetIntPaFromStr( ExtInven, &CountStr ) );
; 813  : #endif	// __SYS_IDENTIFY
; 814  : 		++CountStr; 	++nExtInven;

  00446	8b 44 24 14	 mov	 eax, DWORD PTR _CountStr$[esp+17568]
  0044a	8a 8c 04 41 05
	00 00		 mov	 cl, BYTE PTR _ExtInven$[esp+eax+17569]
  00451	83 c4 08	 add	 esp, 8
  00454	40		 inc	 eax
  00455	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  0045b	80 f9 24	 cmp	 cl, 36			; 00000024H
  0045e	89 44 24 0c	 mov	 DWORD PTR _CountStr$[esp+17560], eax
  00462	0f 85 28 ff ff
	ff		 jne	 $L209027

; 797  : 	while( '$' != ExtInven[CountStr] )

  00468	8b 74 24 18	 mov	 esi, DWORD PTR $T218058[esp+17560]
$L209028:

; 815  : 	}
; 816  : 
; 817  : 	CountStr	= 0;
; 818  : 	int nPirecingInven = 0;
; 819  : 	char PirecingInven[4000] = {0,};

  0046c	c6 84 24 70 1d
	00 00 00	 mov	 BYTE PTR _PirecingInven$[esp+17560], 0
  00474	33 c0		 xor	 eax, eax
  00476	b9 e7 03 00 00	 mov	 ecx, 999		; 000003e7H
  0047b	8d bc 24 71 1d
	00 00		 lea	 edi, DWORD PTR _PirecingInven$[esp+17561]
  00482	f3 ab		 rep stosd

; 820  : 	qry->GetStr( "m_InventoryPiercing", PirecingInven );

  00484	8b 4c 24 14	 mov	 ecx, DWORD PTR $T218060[esp+17560]
  00488	8d 94 24 70 1d
	00 00		 lea	 edx, DWORD PTR _PirecingInven$[esp+17560]
  0048f	66 ab		 stosw
  00491	52		 push	 edx
  00492	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OAKPNEDM@m_InventoryPiercing?$AA@
  00497	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17568], 0
  0049f	aa		 stosb
  004a0	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 821  : 	VERIFYSTRING_RETURN( PirecingInven, szPlayerName );

  004a5	8b 44 24 10	 mov	 eax, DWORD PTR $T218061[esp+17560]
  004a9	50		 push	 eax
  004aa	8d 8c 24 fc 00
	00 00		 lea	 ecx, DWORD PTR _szPlayerName$[esp+17564]
  004b1	51		 push	 ecx
  004b2	68 35 03 00 00	 push	 821			; 00000335H
  004b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  004bc	8d 94 24 80 1d
	00 00		 lea	 edx, DWORD PTR _PirecingInven$[esp+17576]
  004c3	52		 push	 edx
  004c4	8b ce		 mov	 ecx, esi
  004c6	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  004cb	85 c0		 test	 eax, eax
  004cd	0f 84 2f 03 00
	00		 je	 $L218090

; 822  : 	while( '$' != PirecingInven[CountStr] )

  004d3	80 bc 24 70 1d
	00 00 24	 cmp	 BYTE PTR _PirecingInven$[esp+17560], 36 ; 00000024H
  004db	74 36		 je	 SHORT $L209041
  004dd	33 ff		 xor	 edi, edi
  004df	90		 npad	 1
$L209040:

; 823  : 	{
; 824  : #if __VER >= 12 // __EXT_PIERCING
; 825  : 		LoadPiercingInfo( pMover->m_Inventory.m_apItem[nPirecingInven], PirecingInven, &CountStr );

  004e0	8b 93 20 41 00
	00		 mov	 edx, DWORD PTR [ebx+16672]
  004e6	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+17560]
  004ea	50		 push	 eax
  004eb	8d 8c 24 74 1d
	00 00		 lea	 ecx, DWORD PTR _PirecingInven$[esp+17564]
  004f2	51		 push	 ecx
  004f3	03 d7		 add	 edx, edi
  004f5	52		 push	 edx
  004f6	8b ce		 mov	 ecx, esi
  004f8	e8 00 00 00 00	 call	 ?LoadPiercingInfo@CDbManager@@QAEXAAVCItemElem@@PADPAH@Z ; CDbManager::LoadPiercingInfo
  004fd	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+17560]
  00501	8a 8c 04 70 1d
	00 00		 mov	 cl, BYTE PTR _PirecingInven$[esp+eax+17560]

; 826  : #else // __EXT_PIERCING
; 827  : 		int nItemIdCount = 0;
; 828  : 		pMover->m_Inventory.m_apItem[nPirecingInven].SetPiercingSize( GetIntFromStr( PirecingInven, &CountStr ) );
; 829  : 		for( int i = 0 ; i < pMover->m_Inventory.m_apItem[nPirecingInven].GetPiercingSize(); ++i )
; 830  : 		{
; 831  : 			pMover->m_Inventory.m_apItem[nPirecingInven].SetPiercingItem( nItemIdCount, (DWORD)GetIntFromStr( PirecingInven, &CountStr ) );
; 832  : 			++nItemIdCount;
; 833  : 		}
; 834  : #endif // __EXT_PIERCING
; 835  : 		++nPirecingInven;

  00508	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H
  0050e	80 f9 24	 cmp	 cl, 36			; 00000024H
  00511	75 cd		 jne	 SHORT $L209040
$L209041:

; 836  : 	}
; 837  : 
; 838  : 	CountStr	= 0;
; 839  : 	int	nId	= 0;
; 840  : #ifdef __PET_1024
; 841  : 	char szPet[4200]	= { 0, };

  00513	c6 84 24 08 0d
	00 00 00	 mov	 BYTE PTR _szPet$[esp+17560], 0
  0051b	33 c0		 xor	 eax, eax
  0051d	b9 19 04 00 00	 mov	 ecx, 1049		; 00000419H
  00522	8d bc 24 09 0d
	00 00		 lea	 edi, DWORD PTR _szPet$[esp+17561]
  00529	f3 ab		 rep stosd

; 842  : #else	// __PET_1024
; 843  : 	char szPet[2688]	= { 0, };
; 844  : #endif	// __PET_1024
; 845  : 	qry->GetStr( "szInventoryPet", szPet );

  0052b	8d 8c 24 08 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17560]
  00532	66 ab		 stosw
  00534	51		 push	 ecx
  00535	8b 4c 24 18	 mov	 ecx, DWORD PTR $T218060[esp+17564]
  00539	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GAFIDLHN@szInventoryPet?$AA@
  0053e	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _CountStr$[esp+17568], 0
  00546	aa		 stosb
  00547	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXPAD0@Z ; CQuery::GetStr

; 846  : 	VERIFYSTRING_RETURN( szPet, szPlayerName );

  0054c	8b 54 24 10	 mov	 edx, DWORD PTR $T218061[esp+17560]
  00550	52		 push	 edx
  00551	8d 84 24 fc 00
	00 00		 lea	 eax, DWORD PTR _szPlayerName$[esp+17564]
  00558	50		 push	 eax
  00559	68 4e 03 00 00	 push	 846			; 0000034eH
  0055e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GH@MCJMNKHP@?2Documents?5and?5Settings?2test?2Mes@
  00563	8d 8c 24 18 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17576]
  0056a	51		 push	 ecx
  0056b	8b ce		 mov	 ecx, esi
  0056d	e8 00 00 00 00	 call	 ?VerifyString@CDbManager@@AAEHPBD0H0PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::VerifyString
  00572	85 c0		 test	 eax, eax
  00574	0f 84 88 02 00
	00		 je	 $L218090

; 847  : 	while( '$' != szPet[CountStr] )

  0057a	80 bc 24 08 0d
	00 00 24	 cmp	 BYTE PTR _szPet$[esp+17560], 36 ; 00000024H
  00582	0f 84 18 02 00
	00		 je	 $L209048
  00588	33 ff		 xor	 edi, edi
  0058a	89 7c 24 10	 mov	 DWORD PTR tv926[esp+17560], edi
  0058e	8b ff		 npad	 2
$L209047:

; 848  : 	{
; 849  : 		BOOL bPet	= (BOOL)GetIntFromStr( szPet, &CountStr );

  00590	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17560]
  00594	52		 push	 edx
  00595	8d 84 24 0c 0d
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+17564]
  0059c	50		 push	 eax
  0059d	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 850  : 		if( bPet )

  005a2	33 f6		 xor	 esi, esi
  005a4	83 c4 08	 add	 esp, 8
  005a7	3b c6		 cmp	 eax, esi
  005a9	0f 84 d3 01 00
	00		 je	 $L209051

; 851  : 		{
; 852  : 			SAFE_DELETE( pMover->m_Inventory.m_apItem[nId].m_pPet );

  005af	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]
  005b5	8b 8c 0f 98 00
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+152]
  005bc	3b ce		 cmp	 ecx, esi
  005be	74 13		 je	 SHORT $L209052
  005c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  005c2	6a 01		 push	 1
  005c4	ff 12		 call	 DWORD PTR [edx]
  005c6	8b 83 20 41 00
	00		 mov	 eax, DWORD PTR [ebx+16672]
  005cc	89 b4 07 98 00
	00 00		 mov	 DWORD PTR [edi+eax+152], esi
$L209052:

; 853  : 			CPet* pPet	= pMover->m_Inventory.m_apItem[nId].m_pPet		= new CPet;

  005d3	6a 28		 push	 40			; 00000028H
  005d5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  005da	83 c4 04	 add	 esp, 4
  005dd	89 44 24 1c	 mov	 DWORD PTR $T218029[esp+17560], eax
  005e1	3b c6		 cmp	 eax, esi
  005e3	c7 84 24 94 44
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+17568], 1
  005ee	74 09		 je	 SHORT $L218031
  005f0	8b c8		 mov	 ecx, eax
  005f2	e8 00 00 00 00	 call	 ??0CPet@@QAE@XZ		; CPet::CPet
  005f7	8b f0		 mov	 esi, eax
$L218031:
  005f9	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]

; 854  : 			BYTE nKind	= (BYTE)GetIntFromStr( szPet, &CountStr );

  005ff	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17560]
  00603	52		 push	 edx
  00604	8d 84 24 0c 0d
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+17564]
  0060b	50		 push	 eax
  0060c	c7 84 24 9c 44
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+17576], -1
  00617	89 b4 0f 98 00
	00 00		 mov	 DWORD PTR [edi+ecx+152], esi
  0061e	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 855  : 			pPet->SetKind( nKind );
; 856  : 			BYTE nLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );

  00623	8d 4c 24 14	 lea	 ecx, DWORD PTR _CountStr$[esp+17568]
  00627	51		 push	 ecx
  00628	8d 94 24 14 0d
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+17572]
  0062f	52		 push	 edx
  00630	88 46 04	 mov	 BYTE PTR [esi+4], al
  00633	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr

; 857  : 			pPet->SetLevel( nLevel );

  00638	88 46 05	 mov	 BYTE PTR [esi+5], al

; 858  : 			DWORD dwExp	= (DWORD)GetIntFromStr( szPet, &CountStr );

  0063b	8d 44 24 1c	 lea	 eax, DWORD PTR _CountStr$[esp+17576]
  0063f	50		 push	 eax
  00640	8d 8c 24 1c 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17580]
  00647	51		 push	 ecx
  00648	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0064d	83 c4 18	 add	 esp, 24			; 00000018H

; 859  : 			pPet->SetExp( dwExp );

  00650	50		 push	 eax
  00651	8b ce		 mov	 ecx, esi
  00653	e8 00 00 00 00	 call	 ?SetExp@CPet@@QAEXK@Z	; CPet::SetExp

; 860  : 			WORD wEnergy	= (WORD)GetIntFromStr( szPet, &CountStr );

  00658	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17560]
  0065c	52		 push	 edx
  0065d	8d 84 24 0c 0d
	00 00		 lea	 eax, DWORD PTR _szPet$[esp+17564]
  00664	50		 push	 eax
  00665	e8 00 00 00 00	 call	 ?GetIntFromStr@@YAHPADPAH@Z ; GetIntFromStr
  0066a	83 c4 08	 add	 esp, 8

; 861  : 			pPet->SetEnergy( wEnergy );

  0066d	50		 push	 eax
  0066e	8b ce		 mov	 ecx, esi
  00670	e8 00 00 00 00	 call	 ?SetEnergy@CPet@@QAEXG@Z ; CPet::SetEnergy

; 862  : #ifdef __PET_1024
; 863  : 			WORD wLife	= (WORD)GetIntPaFromStr( szPet, &CountStr );

  00675	8d 4c 24 0c	 lea	 ecx, DWORD PTR _CountStr$[esp+17560]
  00679	51		 push	 ecx
  0067a	8d 94 24 0c 0d
	00 00		 lea	 edx, DWORD PTR _szPet$[esp+17564]
  00681	52		 push	 edx
  00682	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr

; 864  : 			pPet->SetLife( wLife );

  00687	66 89 46 0e	 mov	 WORD PTR [esi+14], ax

; 865  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )

  0068b	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  0068e	83 c4 08	 add	 esp, 8
  00691	3c 01		 cmp	 al, 1
  00693	bf 01 00 00 00	 mov	 edi, 1
  00698	72 35		 jb	 SHORT $L209074
  0069a	8d 9b 00 00 00
	00		 npad	 6
$L209072:

; 866  : 			{
; 867  : 				BYTE nAvailLevel	= (BYTE)GetIntPaFromStr( szPet, &CountStr );

  006a0	8d 44 24 0c	 lea	 eax, DWORD PTR _CountStr$[esp+17560]
  006a4	50		 push	 eax
  006a5	8d 8c 24 0c 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17564]
  006ac	51		 push	 ecx
  006ad	e8 00 00 00 00	 call	 ?GetIntPaFromStr@@YAHPADPAH@Z ; GetIntPaFromStr
  006b2	88 44 24 1c	 mov	 BYTE PTR _nAvailLevel$209075[esp+17568], al

; 868  : 				pPet->SetAvailLevel( i, nAvailLevel );

  006b6	8b 54 24 1c	 mov	 edx, DWORD PTR _nAvailLevel$209075[esp+17568]
  006ba	83 c4 08	 add	 esp, 8
  006bd	52		 push	 edx
  006be	57		 push	 edi
  006bf	8b ce		 mov	 ecx, esi
  006c1	e8 00 00 00 00	 call	 ?SetAvailLevel@CPet@@QAEXEE@Z ; CPet::SetAvailLevel
  006c6	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  006ca	47		 inc	 edi
  006cb	3b f8		 cmp	 edi, eax
  006cd	7e d1		 jle	 SHORT $L209072
$L209074:

; 869  : 			}
; 870  : 			char szFmt[MAX_PET_NAME_FMT]	= { 0,};

  006cf	33 c9		 xor	 ecx, ecx
  006d1	89 8c 24 d5 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17561], ecx
  006d8	89 8c 24 d9 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17565], ecx
  006df	89 8c 24 dd 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17569], ecx
  006e6	89 8c 24 e1 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17573], ecx
  006ed	89 8c 24 e5 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17577], ecx
  006f4	89 8c 24 e9 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17581], ecx
  006fb	89 8c 24 ed 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17585], ecx

; 871  : 			GetStrFromStr( szPet, szFmt, &CountStr );

  00702	8d 54 24 0c	 lea	 edx, DWORD PTR _CountStr$[esp+17560]
  00706	52		 push	 edx
  00707	8d 84 24 d8 00
	00 00		 lea	 eax, DWORD PTR _szFmt$209077[esp+17564]
  0070e	89 8c 24 f5 00
	00 00		 mov	 DWORD PTR _szFmt$209077[esp+17593], ecx
  00715	50		 push	 eax
  00716	8d 8c 24 10 0d
	00 00		 lea	 ecx, DWORD PTR _szPet$[esp+17568]
  0071d	51		 push	 ecx
  0071e	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR _szFmt$209077[esp+17572], 0
  00726	e8 00 00 00 00	 call	 ?GetStrFromStr@@YAXPAD0PAH@Z ; GetStrFromStr
  0072b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 872  : 			char szName[MAX_PET_NAME]	= { 0,};

  0072e	33 d2		 xor	 edx, edx

; 873  : 			GetDBFormatStr( szName, MAX_PET_NAME, szFmt );

  00730	8d 84 24 d4 00
	00 00		 lea	 eax, DWORD PTR _szFmt$209077[esp+17560]
  00737	89 94 24 c1 00
	00 00		 mov	 DWORD PTR _szName$209078[esp+17561], edx
  0073e	50		 push	 eax
  0073f	89 94 24 c9 00
	00 00		 mov	 DWORD PTR _szName$209078[esp+17569], edx
  00746	6a 11		 push	 17			; 00000011H
  00748	8d 8c 24 c8 00
	00 00		 lea	 ecx, DWORD PTR _szName$209078[esp+17568]
  0074f	89 94 24 d1 00
	00 00		 mov	 DWORD PTR _szName$209078[esp+17577], edx
  00756	51		 push	 ecx
  00757	8b 4c 24 24	 mov	 ecx, DWORD PTR $T218058[esp+17572]
  0075b	c6 84 24 cc 00
	00 00 00	 mov	 BYTE PTR _szName$209078[esp+17572], 0
  00763	89 94 24 d9 00
	00 00		 mov	 DWORD PTR _szName$209078[esp+17585], edx
  0076a	e8 00 00 00 00	 call	 ?GetDBFormatStr@CDbManager@@AAEXPADHPBD@Z ; CDbManager::GetDBFormatStr

; 874  : 			pPet->SetName( szName );

  0076f	8d 94 24 c0 00
	00 00		 lea	 edx, DWORD PTR _szName$209078[esp+17560]
  00776	52		 push	 edx
  00777	8b ce		 mov	 ecx, esi
  00779	e8 00 00 00 00	 call	 ?SetName@CPet@@QAEXPBD@Z ; CPet::SetName
  0077e	8b 7c 24 10	 mov	 edi, DWORD PTR tv926[esp+17560]
$L209051:
  00782	8b 44 24 0c	 mov	 eax, DWORD PTR _CountStr$[esp+17560]
  00786	8a 8c 04 08 0d
	00 00		 mov	 cl, BYTE PTR _szPet$[esp+eax+17560]

; 875  : #else	// __PET_1024
; 876  : 			WORD wLife	= (WORD)GetIntFromStr( szPet, &CountStr );
; 877  : 			pPet->SetLife( wLife );
; 878  : 			for( int i = PL_D; i <= pPet->GetLevel(); i++ )
; 879  : 			{
; 880  : 				BYTE nAvailLevel	= (BYTE)GetIntFromStr( szPet, &CountStr );
; 881  : 				pPet->SetAvailLevel( i, nAvailLevel );
; 882  : 			}
; 883  : #endif	// __PET_1024
; 884  : 		}
; 885  : 		nId++;

  0078d	81 c7 a0 00 00
	00		 add	 edi, 160		; 000000a0H
  00793	80 f9 24	 cmp	 cl, 36			; 00000024H
  00796	89 7c 24 10	 mov	 DWORD PTR tv926[esp+17560], edi
  0079a	0f 85 f0 fd ff
	ff		 jne	 $L209047
$L209048:

; 886  : 	}
; 887  : 	return TRUE;

  007a0	b8 01 00 00 00	 mov	 eax, 1
$L208986:

; 888  : }

  007a5	8b 8c 24 8c 44
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+17560]
  007ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  007b3	8b 8c 24 84 44
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+17560]
  007ba	5f		 pop	 edi
  007bb	5e		 pop	 esi
  007bc	33 cd		 xor	 ecx, ebp
  007be	5b		 pop	 ebx
  007bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007c4	8b e5		 mov	 esp, ebp
  007c6	5d		 pop	 ebp
  007c7	c2 0c 00	 ret	 12			; 0000000cH
$L218073:

; 761  : 			{
; 762  : 				Error( "Join::Inventory : << IndexItem %s, %d", pMover->m_szName, IndexItem );

  007ca	50		 push	 eax
  007cb	83 c3 6c	 add	 ebx, 108		; 0000006cH
  007ce	53		 push	 ebx
  007cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@KLFMFNBG@Join?3?3Inventory?5?3?5?$DM?$DM?5IndexItem?5?$CF@
  007d4	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 763  : 				Error( "Inventory = %s", Inven );

  007d9	8d 94 24 1c 2d
	00 00		 lea	 edx, DWORD PTR _Inven$[esp+17572]
  007e0	52		 push	 edx
  007e1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@FEOHFPFP@Inventory?5?$DN?5?$CFs?$AA@
  007e6	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  007eb	83 c4 14	 add	 esp, 20			; 00000014H

; 764  : 				return FALSE;

  007ee	8d 4c 24 20	 lea	 ecx, DWORD PTR _BufItemElem$208998[esp+17560]
  007f2	c7 84 24 94 44
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+17568], -1
  007fd	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L218090:
  00802	33 c0		 xor	 eax, eax
  00804	eb 9f		 jmp	 SHORT $L208986
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L218032:
  00000	8d 8d 88 bb ff
	ff		 lea	 ecx, DWORD PTR _BufItemElem$208998[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L218033:
  0000b	8b 85 84 bb ff
	ff		 mov	 eax, DWORD PTR $T218029[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
  00018	c3		 ret	 0
__ehhandler$?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z:
  00019	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T218063
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ENDP ; CDbManager::GetInventory
PUBLIC	?RemoveQuest@CDbManager@@QAEHXZ			; CDbManager::RemoveQuest
PUBLIC	??_C@_0CC@JKMJFPOD@call?5BOOL?5CDbManager?3?3RemoveQues@ ; `string'
PUBLIC	??_C@_0BA@DPPBFHPJ@removequest?4txt?$AA@	; `string'
PUBLIC	??_C@_0CH@EEGILGJF@fail?5to?5connect?3?5dsn?$DN?$CFs?0?5id?$DN?$CFs?0?5@ ; `string'
PUBLIC	??_C@_0HG@LPNEKFLC@SELECT?5m_idPlayer?0?5m_lpQuestCntA@ ; `string'
PUBLIC	??_C@_0GF@KIGMAII@SELECT?5m_idPlayer?0?5m_lpQuestCntA@ ; `string'
PUBLIC	??_C@_0BA@PHPFGNFH@query?5error?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0JG@EPDAEJAA@UPDATE?5CHARACTER_TBL?5SET?5m_lpQue@ ; `string'
PUBLIC	??_C@_0BG@JHIJALBF@query_removequest?4txt?$AA@	; `string'
PUBLIC	??_C@_0BF@KCBBBMFM@RemoveQuest?5complete?$AA@	; `string'
EXTRN	__imp__OutputDebugStringA@4:NEAR
EXTRN	??0CQuery@@QAE@XZ:NEAR				; CQuery::CQuery
EXTRN	?Connect@CQuery@@QAEHHPAD0PBD@Z:NEAR		; CQuery::Connect
EXTRN	?FILEOUT@@YAXPBD0ZZ:NEAR			; FILEOUT
EXTRN	?GetNumber@CScanner@@QAEHH@Z:NEAR		; CScanner::GetNumber
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??0CMover@@QAE@XZ:NEAR				; CMover::CMover
EXTRN	??1CMover@@UAE@XZ:NEAR				; CMover::~CMover
EXTRN	?RemoveQuest@CMover@@QAEHH@Z:NEAR		; CMover::RemoveQuest
EXTRN	??0CScript@@QAE@H@Z:NEAR			; CScript::CScript
EXTRN	??1CScript@@UAE@XZ:NEAR				; CScript::~CScript
EXTRN	?Load@CScript@@QAEHPBDHH@Z:NEAR			; CScript::Load
EXTRN	?SaveQuest@CDbManager@@QAEXPAVCMover@@PAD11@Z:NEAR ; CDbManager::SaveQuest
EXTRN	?DSN_NAME_CHARACTER01@@3PADA:BYTE		; DSN_NAME_CHARACTER01
EXTRN	?DB_ADMIN_ID_CHARACTER01@@3PADA:BYTE		; DB_ADMIN_ID_CHARACTER01
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T218634 DD	0ffffffffH
	DD	FLAT:$L218125
	DD	00H
	DD	FLAT:$L218126
	DD	01H
	DD	FLAT:$L218127
	DD	01H
	DD	FLAT:$L218128
$T218620 DD	019930520H
	DD	04H
	DD	FLAT:$T218634
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0CC@JKMJFPOD@call?5BOOL?5CDbManager?3?3RemoveQues@
CONST	SEGMENT
??_C@_0CC@JKMJFPOD@call?5BOOL?5CDbManager?3?3RemoveQues@ DB 'call BOOL CD'
	DB	'bManager::RemoveQuest', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPPBFHPJ@removequest?4txt?$AA@
CONST	SEGMENT
??_C@_0BA@DPPBFHPJ@removequest?4txt?$AA@ DB 'removequest.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EEGILGJF@fail?5to?5connect?3?5dsn?$DN?$CFs?0?5id?$DN?$CFs?0?5@
CONST	SEGMENT
??_C@_0CH@EEGILGJF@fail?5to?5connect?3?5dsn?$DN?$CFs?0?5id?$DN?$CFs?0?5@ DB 'f'
	DB	'ail to connect: dsn=%s, id=%s, pwd=%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@LPNEKFLC@SELECT?5m_idPlayer?0?5m_lpQuestCntA@
CONST	SEGMENT
??_C@_0HG@LPNEKFLC@SELECT?5m_idPlayer?0?5m_lpQuestCntA@ DB 'SELECT m_idPl'
	DB	'ayer, m_lpQuestCntArray, m_aCompleteQuest, m_aCheckedQuest FR'
	DB	'OM CHARACTER_TBL WHERE serverindex = ''%02d''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@KIGMAII@SELECT?5m_idPlayer?0?5m_lpQuestCntA@
CONST	SEGMENT
??_C@_0GF@KIGMAII@SELECT?5m_idPlayer?0?5m_lpQuestCntA@ DB 'SELECT m_idPla'
	DB	'yer, m_lpQuestCntArray, m_aCompleteQuest FROM CHARACTER_TBL W'
	DB	'HERE serverindex = ''%02d''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PHPFGNFH@query?5error?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@PHPFGNFH@query?5error?3?5?$CFs?$AA@ DB 'query error: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JG@EPDAEJAA@UPDATE?5CHARACTER_TBL?5SET?5m_lpQue@
CONST	SEGMENT
??_C@_0JG@EPDAEJAA@UPDATE?5CHARACTER_TBL?5SET?5m_lpQue@ DB 'UPDATE CHARAC'
	DB	'TER_TBL SET m_lpQuestCntArray = ''%s'', m_aCompleteQuest = '''
	DB	'%s'', m_aCheckedQuest = ''%s'' WHERE m_idPlayer = ''%07d'' an'
	DB	'd serverindex = ''%02d''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JHIJALBF@query_removequest?4txt?$AA@
CONST	SEGMENT
??_C@_0BG@JHIJALBF@query_removequest?4txt?$AA@ DB 'query_removequest.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCBBBMFM@RemoveQuest?5complete?$AA@
CONST	SEGMENT
??_C@_0BF@KCBBBMFM@RemoveQuest?5complete?$AA@ DB 'RemoveQuest complete', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanagerfun.cpp
CONST	ENDS
;	COMDAT ?RemoveQuest@CDbManager@@QAEHXZ
_TEXT	SEGMENT
$T218097 = -30456					; size = 4
_nQuestId$ = -30456					; size = 4
_pSql$ = -30452						; size = 4
$T218098 = -30452					; size = 4
$T218618 = -30448					; size = 4
_bRemove$209818 = -30444				; size = 4
_vecRemoveQuestId$ = -30440				; size = 16
_s$ = -30424						; size = 7760
_mover$209808 = -22664					; size = 18184
_aCheckedQuest$ = -4480					; size = 100
_lpOutputString$ = -4376				; size = 256
_aCompleteQuest$ = -4120				; size = 1024
_aQuest$ = -3096					; size = 3072
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?RemoveQuest@CDbManager@@QAEHXZ PROC NEAR		; CDbManager::RemoveQuest, COMDAT
; _this$ = ecx

; 1844 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?RemoveQuest@CDbManager@@QAEHXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	51		 push	 ecx
  0001c	b8 ec 76 00 00	 mov	 eax, 30444		; 000076ecH
  00021	e8 00 00 00 00	 call	 __chkstk
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	53		 push	 ebx
  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	33 c5		 xor	 eax, ebp
  00030	89 4c 24 18	 mov	 DWORD PTR $T218618[esp+30472], ecx

; 1845 : 	// load - removequest.txt
; 1846 : 	CScript s;

  00034	33 f6		 xor	 esi, esi
  00036	56		 push	 esi
  00037	8d 4c 24 34	 lea	 ecx, DWORD PTR _s$[esp+30476]
  0003b	89 84 24 f8 76
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+30476], eax
  00042	e8 00 00 00 00	 call	 ??0CScript@@QAE@H@Z	; CScript::CScript

; 1847 : 	OutputDebugString( "call BOOL CDbManager::RemoveQuest" );

  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@JKMJFPOD@call?5BOOL?5CDbManager?3?3RemoveQues@
  0004c	89 b4 24 08 77
	00 00		 mov	 DWORD PTR __$EHRec$[esp+30484], esi
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 1848 : 	if( FALSE == s.Load( "removequest.txt" ) )

  00059	56		 push	 esi
  0005a	6a 01		 push	 1
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@DPPBFHPJ@removequest?4txt?$AA@
  00061	8d 4c 24 3c	 lea	 ecx, DWORD PTR _s$[esp+30484]
  00065	e8 00 00 00 00	 call	 ?Load@CScript@@QAEHPBDHH@Z ; CScript::Load
  0006a	85 c0		 test	 eax, eax

; 1849 : 		return FALSE;

  0006c	0f 84 47 04 00
	00		 je	 $L218530

; 1850 : 	vector<int>	vecRemoveQuestId;

  00072	33 db		 xor	 ebx, ebx
  00074	33 ff		 xor	 edi, edi
  00076	89 5c 24 24	 mov	 DWORD PTR _vecRemoveQuestId$[esp+30476], ebx
  0007a	89 7c 24 28	 mov	 DWORD PTR _vecRemoveQuestId$[esp+30480], edi
  0007e	89 74 24 2c	 mov	 DWORD PTR _vecRemoveQuestId$[esp+30484], esi

; 1851 : 	int	nQuestId	= s.GetNumber();

  00082	56		 push	 esi
  00083	8d 4c 24 34	 lea	 ecx, DWORD PTR _s$[esp+30476]
  00087	c6 84 24 08 77
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+30484], 1
  0008f	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 1852 : 	while( s.tok != FINISHED )

  00094	83 bc 24 5c 08
	00 00 15	 cmp	 DWORD PTR _s$[esp+32564], 21 ; 00000015H
  0009c	89 44 24 10	 mov	 DWORD PTR _nQuestId$[esp+30472], eax
  000a0	74 54		 je	 SHORT $L209773
$L209772:

; 1853 : 	{
; 1854 : 		vecRemoveQuestId.push_back( nQuestId );

  000a2	3b de		 cmp	 ebx, esi
  000a4	74 1f		 je	 SHORT $L218423
  000a6	8b 54 24 2c	 mov	 edx, DWORD PTR _vecRemoveQuestId$[esp+30484]
  000aa	8b cf		 mov	 ecx, edi
  000ac	2b cb		 sub	 ecx, ebx
  000ae	2b d3		 sub	 edx, ebx
  000b0	c1 f9 02	 sar	 ecx, 2
  000b3	c1 fa 02	 sar	 edx, 2
  000b6	3b ca		 cmp	 ecx, edx
  000b8	73 0b		 jae	 SHORT $L218423
  000ba	89 07		 mov	 DWORD PTR [edi], eax
  000bc	83 c7 04	 add	 edi, 4
  000bf	89 7c 24 28	 mov	 DWORD PTR _vecRemoveQuestId$[esp+30480], edi
  000c3	eb 19		 jmp	 SHORT $L218460
$L218423:
  000c5	8d 44 24 10	 lea	 eax, DWORD PTR _nQuestId$[esp+30472]
  000c9	50		 push	 eax
  000ca	6a 01		 push	 1
  000cc	57		 push	 edi
  000cd	8d 4c 24 2c	 lea	 ecx, DWORD PTR _vecRemoveQuestId$[esp+30484]
  000d1	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
  000d6	8b 7c 24 28	 mov	 edi, DWORD PTR _vecRemoveQuestId$[esp+30480]
  000da	8b 5c 24 24	 mov	 ebx, DWORD PTR _vecRemoveQuestId$[esp+30476]
$L218460:

; 1855 : 		nQuestId	= s.GetNumber();

  000de	56		 push	 esi
  000df	8d 4c 24 34	 lea	 ecx, DWORD PTR _s$[esp+30476]
  000e3	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  000e8	83 bc 24 5c 08
	00 00 15	 cmp	 DWORD PTR _s$[esp+32564], 21 ; 00000015H
  000f0	89 44 24 10	 mov	 DWORD PTR _nQuestId$[esp+30472], eax
  000f4	75 ac		 jne	 SHORT $L209772
$L209773:

; 1856 : 	}
; 1857 : 
; 1858 : 	char lpOutputString[256];
; 1859 : 	char aQuest[3072]	= { 0,};

  000f6	33 c0		 xor	 eax, eax
  000f8	c6 84 24 f0 6a
	00 00 00	 mov	 BYTE PTR _aQuest$[esp+30472], 0
  00100	b9 ff 02 00 00	 mov	 ecx, 767		; 000002ffH
  00105	8d bc 24 f1 6a
	00 00		 lea	 edi, DWORD PTR _aQuest$[esp+30473]
  0010c	f3 ab		 rep stosd
  0010e	66 ab		 stosw
  00110	aa		 stosb

; 1860 : 	char aCompleteQuest[1024]	= { 0,};

  00111	33 c0		 xor	 eax, eax
  00113	c6 84 24 f0 66
	00 00 00	 mov	 BYTE PTR _aCompleteQuest$[esp+30472], 0
  0011b	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00120	8d bc 24 f1 66
	00 00		 lea	 edi, DWORD PTR _aCompleteQuest$[esp+30473]
  00127	f3 ab		 rep stosd
  00129	66 ab		 stosw
  0012b	aa		 stosb

; 1861 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 1862 : 	char aCheckedQuest[100]	= {0, };

  0012c	c6 84 24 88 65
	00 00 00	 mov	 BYTE PTR _aCheckedQuest$[esp+30472], 0
  00134	33 c0		 xor	 eax, eax
  00136	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0013b	8d bc 24 89 65
	00 00		 lea	 edi, DWORD PTR _aCheckedQuest$[esp+30473]
  00142	f3 ab		 rep stosd
  00144	66 ab		 stosw

; 1863 : #endif // __IMPROVE_QUEST_INTERFACE
; 1864 : 
; 1865 : 	CQuery* pQuery	= new CQuery;

  00146	68 10 3d 00 00	 push	 15632			; 00003d10H
  0014b	aa		 stosb
  0014c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00151	83 c4 04	 add	 esp, 4
  00154	89 44 24 14	 mov	 DWORD PTR $T218098[esp+30472], eax
  00158	3b c6		 cmp	 eax, esi
  0015a	c6 84 24 04 77
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+30480], 2
  00162	74 0f		 je	 SHORT $L218099
  00164	8b c8		 mov	 ecx, eax
  00166	e8 00 00 00 00	 call	 ??0CQuery@@QAE@XZ	; CQuery::CQuery
  0016b	8b f8		 mov	 edi, eax
  0016d	89 7c 24 10	 mov	 DWORD PTR $T218097[esp+30472], edi
  00171	eb 06		 jmp	 SHORT $L218100
$L218099:
  00173	89 74 24 10	 mov	 DWORD PTR $T218097[esp+30472], esi
  00177	8b fe		 mov	 edi, esi
$L218100:

; 1866 : 	if( FALSE == pQuery->Connect( 3, DSN_NAME_CHARACTER01, DB_ADMIN_ID_CHARACTER01, DB_ADMIN_PASS_CHARACTER01 ) )

  00179	8b 74 24 18	 mov	 esi, DWORD PTR $T218618[esp+30472]
  0017d	81 c6 c0 04 00
	00		 add	 esi, 1216		; 000004c0H
  00183	56		 push	 esi
  00184	68 00 00 00 00	 push	 OFFSET FLAT:?DB_ADMIN_ID_CHARACTER01@@3PADA ; DB_ADMIN_ID_CHARACTER01
  00189	68 00 00 00 00	 push	 OFFSET FLAT:?DSN_NAME_CHARACTER01@@3PADA ; DSN_NAME_CHARACTER01
  0018e	6a 03		 push	 3
  00190	8b cf		 mov	 ecx, edi
  00192	c6 84 24 14 77
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+30496], 1
  0019a	e8 00 00 00 00	 call	 ?Connect@CQuery@@QAEHHPAD0PBD@Z ; CQuery::Connect
  0019f	85 c0		 test	 eax, eax
  001a1	75 6a		 jne	 SHORT $L209783

; 1867 : 	{
; 1868 : 		sprintf( lpOutputString, "fail to connect: dsn=%s, id=%s, pwd=%s", DSN_NAME_CHARACTER01, DB_ADMIN_ID_CHARACTER01, DB_ADMIN_PASS_CHARACTER01 );

  001a3	56		 push	 esi
  001a4	68 00 00 00 00	 push	 OFFSET FLAT:?DB_ADMIN_ID_CHARACTER01@@3PADA ; DB_ADMIN_ID_CHARACTER01
  001a9	68 00 00 00 00	 push	 OFFSET FLAT:?DSN_NAME_CHARACTER01@@3PADA ; DSN_NAME_CHARACTER01
  001ae	8d 8c 24 fc 65
	00 00		 lea	 ecx, DWORD PTR _lpOutputString$[esp+30484]
  001b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@EEGILGJF@fail?5to?5connect?3?5dsn?$DN?$CFs?0?5id?$DN?$CFs?0?5@
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _sprintf
  001c0	83 c4 14	 add	 esp, 20			; 00000014H

; 1869 : 		OutputDebugString( lpOutputString );

  001c3	8d 94 24 f0 65
	00 00		 lea	 edx, DWORD PTR _lpOutputString$[esp+30472]
  001ca	52		 push	 edx
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 1870 : 		SAFE_DELETE( pQuery );

  001d1	85 ff		 test	 edi, edi
  001d3	74 10		 je	 SHORT $L218103
  001d5	8b cf		 mov	 ecx, edi
  001d7	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  001dc	57		 push	 edi
  001dd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001e2	83 c4 04	 add	 esp, 4
$L218103:

; 1871 : 		return FALSE;

  001e5	85 db		 test	 ebx, ebx
  001e7	74 09		 je	 SHORT $L218484
  001e9	53		 push	 ebx
  001ea	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ef	83 c4 04	 add	 esp, 4
$L218484:
  001f2	8d 4c 24 30	 lea	 ecx, DWORD PTR _s$[esp+30472]
  001f6	c7 84 24 04 77
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+30480], -1
  00201	e8 00 00 00 00	 call	 ??1CScript@@UAE@XZ	; CScript::~CScript
  00206	33 c0		 xor	 eax, eax
  00208	e9 47 02 00 00	 jmp	 $L209762
$L209783:

; 1872 : 	}
; 1873 : 	
; 1874 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 1875 : 	char* pSql	=  new char[4296];	// aQuest + aCompleteQuest + aCheckedQuest + 100

  0020d	68 c8 10 00 00	 push	 4296			; 000010c8H
  00212	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00217	8b f0		 mov	 esi, eax

; 1876 : #else // __IMPROVE_QUEST_INTERFACE
; 1877 : 	char* pSql	=  new char[4196];	// aQuest + aCompleteQuest + 100
; 1878 : #endif // __IMPROVE_QUEST_INTERFACE
; 1879 : 
; 1880 : 
; 1881 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 1882 : 	sprintf( pSql, "SELECT m_idPlayer, m_lpQuestCntArray, m_aCompleteQuest, m_aCheckedQuest FROM CHARACTER_TBL WHERE serverindex = '%02d'",
; 1883 : 		g_appInfo.dwSys );

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  0021e	50		 push	 eax
  0021f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0HG@LPNEKFLC@SELECT?5m_idPlayer?0?5m_lpQuestCntA@
  00224	56		 push	 esi
  00225	89 74 24 24	 mov	 DWORD PTR _pSql$[esp+30488], esi
  00229	e8 00 00 00 00	 call	 _sprintf

; 1884 : #else // __IMPROVE_QUEST_INTERFACE
; 1885 : 	sprintf( pSql, "SELECT m_idPlayer, m_lpQuestCntArray, m_aCompleteQuest FROM CHARACTER_TBL WHERE serverindex = '%02d'",
; 1886 : 		g_appInfo.dwSys );
; 1887 : #endif // __IMPROVE_QUEST_INTERFACE
; 1888 : 
; 1889 : 	sprintf( pSql, "SELECT m_idPlayer, m_lpQuestCntArray, m_aCompleteQuest FROM CHARACTER_TBL WHERE serverindex = '%02d'",
; 1890 : 		g_appInfo.dwSys );

  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00234	51		 push	 ecx
  00235	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GF@KIGMAII@SELECT?5m_idPlayer?0?5m_lpQuestCntA@
  0023a	56		 push	 esi
  0023b	e8 00 00 00 00	 call	 _sprintf
  00240	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1891 : 	if( FALSE == pQuery->Exec( pSql ) )

  00243	56		 push	 esi
  00244	8b cf		 mov	 ecx, edi
  00246	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  0024b	85 c0		 test	 eax, eax
  0024d	75 5f		 jne	 SHORT $L218623

; 1892 : 	{
; 1893 : 		sprintf( lpOutputString, "query error: %s", pSql );

  0024f	56		 push	 esi
  00250	8d 94 24 f4 65
	00 00		 lea	 edx, DWORD PTR _lpOutputString$[esp+30476]
  00257	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@PHPFGNFH@query?5error?3?5?$CFs?$AA@
  0025c	52		 push	 edx
  0025d	e8 00 00 00 00	 call	 _sprintf
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1894 : 		SAFE_DELETE_ARRAY( pSql );

  00265	85 f6		 test	 esi, esi
  00267	74 09		 je	 SHORT $L209797
  00269	56		 push	 esi
  0026a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0026f	83 c4 04	 add	 esp, 4
$L209797:

; 1895 : 		SAFE_DELETE( pQuery );

  00272	85 ff		 test	 edi, edi
  00274	74 10		 je	 SHORT $L218110
  00276	8b cf		 mov	 ecx, edi
  00278	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0027d	57		 push	 edi
  0027e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00283	83 c4 04	 add	 esp, 4
$L218110:

; 1896 : 		return FALSE;

  00286	85 db		 test	 ebx, ebx
  00288	74 09		 je	 SHORT $L218507
  0028a	53		 push	 ebx
  0028b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00290	83 c4 04	 add	 esp, 4
$L218507:
  00293	8d 4c 24 30	 lea	 ecx, DWORD PTR _s$[esp+30472]
  00297	c7 84 24 04 77
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+30480], -1
  002a2	e8 00 00 00 00	 call	 ??1CScript@@UAE@XZ	; CScript::~CScript
  002a7	33 c0		 xor	 eax, eax
  002a9	e9 a6 01 00 00	 jmp	 $L209762
$L218623:

; 1897 : 	}
; 1898 : 	while( pQuery->Fetch() )

  002ae	8b cf		 mov	 ecx, edi
  002b0	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  002b5	85 c0		 test	 eax, eax
  002b7	0f 84 45 01 00
	00		 je	 $L209807
  002bd	8d 49 00	 npad	 3
$L209806:

; 1899 : 	{
; 1900 : 		CMover	mover;

  002c0	8d 8c 24 80 1e
	00 00		 lea	 ecx, DWORD PTR _mover$209808[esp+30472]
  002c7	e8 00 00 00 00	 call	 ??0CMover@@QAE@XZ	; CMover::CMover

; 1901 : 		mover.m_idPlayer	= pQuery->GetInt( "m_idPlayer" );

  002cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@FONFFEJF@m_idPlayer?$AA@
  002d1	8b cf		 mov	 ecx, edi
  002d3	c6 84 24 08 77
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+30484], 3
  002db	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 1902 : 		//GetQuest( &mover, pQuery, NULL );
; 1903 : 		// mirchang_100416 VERIFYSTRING use return value
; 1904 : 		if( GetQuest( &mover, pQuery, NULL ) == FALSE )

  002e0	8b 4c 24 18	 mov	 ecx, DWORD PTR $T218618[esp+30472]
  002e4	6a 00		 push	 0
  002e6	89 84 24 14 1f
	00 00		 mov	 DWORD PTR _mover$209808[esp+30620], eax
  002ed	57		 push	 edi
  002ee	8d 84 24 88 1e
	00 00		 lea	 eax, DWORD PTR _mover$209808[esp+30480]
  002f5	50		 push	 eax
  002f6	e8 00 00 00 00	 call	 ?GetQuest@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetQuest
  002fb	85 c0		 test	 eax, eax
  002fd	0f 84 74 01 00
	00		 je	 $L218625

; 1909 : 		}
; 1910 : 		// mirchang_100416
; 1911 : 
; 1912 : 		BOOL bRemove	= FALSE;

  00303	33 f6		 xor	 esi, esi
  00305	89 74 24 1c	 mov	 DWORD PTR _bRemove$209818[esp+30472], esi
  00309	8d a4 24 00 00
	00 00		 npad	 7
$L209820:

; 1913 : 		for( DWORD i = 0; i < vecRemoveQuestId.size(); i++ )

  00310	85 db		 test	 ebx, ebx
  00312	74 2c		 je	 SHORT $L218630
  00314	8b 44 24 28	 mov	 eax, DWORD PTR _vecRemoveQuestId$[esp+30480]
  00318	2b c3		 sub	 eax, ebx
  0031a	c1 f8 02	 sar	 eax, 2
  0031d	3b f0		 cmp	 esi, eax
  0031f	73 1f		 jae	 SHORT $L218630

; 1914 : 		{
; 1915 : 			if( mover.RemoveQuest( vecRemoveQuestId[i] ) )

  00321	8b 0c b3	 mov	 ecx, DWORD PTR [ebx+esi*4]
  00324	51		 push	 ecx
  00325	8d 8c 24 84 1e
	00 00		 lea	 ecx, DWORD PTR _mover$209808[esp+30476]
  0032c	e8 00 00 00 00	 call	 ?RemoveQuest@CMover@@QAEHH@Z ; CMover::RemoveQuest
  00331	85 c0		 test	 eax, eax
  00333	74 08		 je	 SHORT $L209821

; 1916 : 				bRemove	= TRUE;

  00335	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bRemove$209818[esp+30472], 1
$L209821:

; 1913 : 		for( DWORD i = 0; i < vecRemoveQuestId.size(); i++ )

  0033d	46		 inc	 esi
  0033e	eb d0		 jmp	 SHORT $L209820
$L218630:

; 1917 : 		}
; 1918 : 		memset( aQuest, 0, sizeof(aQuest) );

  00340	33 c0		 xor	 eax, eax
  00342	b9 00 03 00 00	 mov	 ecx, 768		; 00000300H
  00347	8d bc 24 f0 6a
	00 00		 lea	 edi, DWORD PTR _aQuest$[esp+30472]
  0034e	f3 ab		 rep stosd

; 1919 : 		memset( aCompleteQuest, 0, sizeof(aCompleteQuest) );

  00350	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00355	8d bc 24 f0 66
	00 00		 lea	 edi, DWORD PTR _aCompleteQuest$[esp+30472]
  0035c	f3 ab		 rep stosd

; 1920 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 1921 : 		memset( aCheckedQuest, 0, sizeof(aCheckedQuest) );

  0035e	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00363	8d bc 24 88 65
	00 00		 lea	 edi, DWORD PTR _aCheckedQuest$[esp+30472]
  0036a	f3 ab		 rep stosd

; 1922 : #endif // __IMPROVE_QUEST_INTERFACE
; 1923 : 		if( bRemove )

  0036c	8b 44 24 1c	 mov	 eax, DWORD PTR _bRemove$209818[esp+30472]
  00370	85 c0		 test	 eax, eax
  00372	74 61		 je	 SHORT $L209824

; 1924 : 		{
; 1925 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 1926 : 			SaveQuest( &mover, aQuest, aCompleteQuest, aCheckedQuest );

  00374	8d 94 24 88 65
	00 00		 lea	 edx, DWORD PTR _aCheckedQuest$[esp+30472]
  0037b	52		 push	 edx
  0037c	8d 84 24 f4 66
	00 00		 lea	 eax, DWORD PTR _aCompleteQuest$[esp+30476]
  00383	50		 push	 eax
  00384	8d 8c 24 f8 6a
	00 00		 lea	 ecx, DWORD PTR _aQuest$[esp+30480]
  0038b	51		 push	 ecx
  0038c	8b 4c 24 24	 mov	 ecx, DWORD PTR $T218618[esp+30484]
  00390	8d 94 24 8c 1e
	00 00		 lea	 edx, DWORD PTR _mover$209808[esp+30484]
  00397	52		 push	 edx
  00398	e8 00 00 00 00	 call	 ?SaveQuest@CDbManager@@QAEXPAVCMover@@PAD11@Z ; CDbManager::SaveQuest

; 1927 : 			FILEOUT( "query_removequest.txt", "UPDATE CHARACTER_TBL SET m_lpQuestCntArray = '%s', m_aCompleteQuest = '%s', m_aCheckedQuest = '%s' WHERE m_idPlayer = '%07d' and serverindex = '%02d'",
; 1928 : 				aQuest, aCompleteQuest, aCheckedQuest, mover.m_idPlayer, g_appInfo.dwSys );

  0039d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  003a2	8b 8c 24 10 1f
	00 00		 mov	 ecx, DWORD PTR _mover$209808[esp+30616]
  003a9	50		 push	 eax
  003aa	51		 push	 ecx
  003ab	8d 94 24 90 65
	00 00		 lea	 edx, DWORD PTR _aCheckedQuest$[esp+30480]
  003b2	52		 push	 edx
  003b3	8d 84 24 fc 66
	00 00		 lea	 eax, DWORD PTR _aCompleteQuest$[esp+30484]
  003ba	50		 push	 eax
  003bb	8d 8c 24 00 6b
	00 00		 lea	 ecx, DWORD PTR _aQuest$[esp+30488]
  003c2	51		 push	 ecx
  003c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0JG@EPDAEJAA@UPDATE?5CHARACTER_TBL?5SET?5m_lpQue@
  003c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@JHIJALBF@query_removequest?4txt?$AA@
  003cd	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT
  003d2	83 c4 1c	 add	 esp, 28			; 0000001cH
$L209824:

; 1929 : #else // __IMPROVE_QUEST_INTERFACE
; 1930 : 			SaveQuest( &mover, aQuest, aCompleteQuest );
; 1931 : 			FILEOUT( "query_removequest.txt", "UPDATE CHARACTER_TBL SET m_lpQuestCntArray = '%s', m_aCompleteQuest = '%s' WHERE m_idPlayer = '%07d' and serverindex = '%02d'",
; 1932 : 				aQuest, aCompleteQuest, mover.m_idPlayer, g_appInfo.dwSys );
; 1933 : #endif // __IMPROVE_QUEST_INTERFACE
; 1934 : 		}
; 1935 : 	}

  003d5	8d 8c 24 80 1e
	00 00		 lea	 ecx, DWORD PTR _mover$209808[esp+30472]
  003dc	c6 84 24 04 77
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+30480], 1
  003e4	e8 00 00 00 00	 call	 ??1CMover@@UAE@XZ	; CMover::~CMover
  003e9	8b 4c 24 10	 mov	 ecx, DWORD PTR $T218097[esp+30472]
  003ed	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  003f2	85 c0		 test	 eax, eax
  003f4	8b 74 24 14	 mov	 esi, DWORD PTR _pSql$[esp+30472]
  003f8	8b 7c 24 10	 mov	 edi, DWORD PTR $T218097[esp+30472]
  003fc	0f 85 be fe ff
	ff		 jne	 $L209806
$L209807:

; 1936 : 	OutputDebugString( "RemoveQuest complete" );

  00402	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@KCBBBMFM@RemoveQuest?5complete?$AA@
  00407	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 1937 : 	SAFE_DELETE_ARRAY( pSql );

  0040d	85 f6		 test	 esi, esi
  0040f	74 09		 je	 SHORT $L209828
  00411	56		 push	 esi
  00412	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00417	83 c4 04	 add	 esp, 4
$L209828:

; 1938 : 	SAFE_DELETE( pQuery );

  0041a	85 ff		 test	 edi, edi
  0041c	74 10		 je	 SHORT $L218122
  0041e	8b cf		 mov	 ecx, edi
  00420	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00425	57		 push	 edi
  00426	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0042b	83 c4 04	 add	 esp, 4
$L218122:

; 1939 : 	return TRUE;

  0042e	85 db		 test	 ebx, ebx
  00430	74 09		 je	 SHORT $L218615
  00432	53		 push	 ebx
  00433	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00438	83 c4 04	 add	 esp, 4
$L218615:
  0043b	8d 4c 24 30	 lea	 ecx, DWORD PTR _s$[esp+30472]
  0043f	c7 84 24 04 77
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+30480], -1
  0044a	e8 00 00 00 00	 call	 ??1CScript@@UAE@XZ	; CScript::~CScript
  0044f	b8 01 00 00 00	 mov	 eax, 1
$L209762:

; 1940 : }

  00454	8b 8c 24 fc 76
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+30472]
  0045b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00462	8b 8c 24 f4 76
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+30472]
  00469	5f		 pop	 edi
  0046a	5e		 pop	 esi
  0046b	33 cd		 xor	 ecx, ebp
  0046d	5b		 pop	 ebx
  0046e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00473	8b e5		 mov	 esp, ebp
  00475	5d		 pop	 ebp
  00476	c3		 ret	 0
$L218625:

; 1905 : 		{
; 1906 : 			SAFE_DELETE_ARRAY( pSql );

  00477	85 f6		 test	 esi, esi
  00479	74 09		 je	 SHORT $L209810
  0047b	56		 push	 esi
  0047c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00481	83 c4 04	 add	 esp, 4
$L209810:

; 1907 : 			SAFE_DELETE( pQuery );

  00484	85 ff		 test	 edi, edi
  00486	74 10		 je	 SHORT $L218116
  00488	8b cf		 mov	 ecx, edi
  0048a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0048f	57		 push	 edi
  00490	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00495	83 c4 04	 add	 esp, 4
$L218116:

; 1908 : 			return FALSE;

  00498	8d 8c 24 80 1e
	00 00		 lea	 ecx, DWORD PTR _mover$209808[esp+30472]
  0049f	c6 84 24 04 77
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+30480], 1
  004a7	e8 00 00 00 00	 call	 ??1CMover@@UAE@XZ	; CMover::~CMover
  004ac	85 db		 test	 ebx, ebx
  004ae	74 09		 je	 SHORT $L218530
  004b0	53		 push	 ebx
  004b1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004b6	83 c4 04	 add	 esp, 4
$L218530:
  004b9	8d 4c 24 30	 lea	 ecx, DWORD PTR _s$[esp+30472]
  004bd	c7 84 24 04 77
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+30480], -1
  004c8	e8 00 00 00 00	 call	 ??1CScript@@UAE@XZ	; CScript::~CScript
  004cd	33 c0		 xor	 eax, eax
  004cf	eb 83		 jmp	 SHORT $L209762
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L218125:
  00000	8d 8d 28 89 ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CScript@@UAE@XZ	; CScript::~CScript
$L218126:
  0000b	8d 8d 18 89 ff
	ff		 lea	 ecx, DWORD PTR _vecRemoveQuestId$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L218127:
  00016	8b 85 0c 89 ff
	ff		 mov	 eax, DWORD PTR $T218098[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	59		 pop	 ecx
  00023	c3		 ret	 0
$L218128:
  00024	8d 8d 78 a7 ff
	ff		 lea	 ecx, DWORD PTR _mover$209808[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1CMover@@UAE@XZ	; CMover::~CMover
__ehhandler$?RemoveQuest@CDbManager@@QAEHXZ:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T218620
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?RemoveQuest@CDbManager@@QAEHXZ ENDP			; CDbManager::RemoveQuest
END
