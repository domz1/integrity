; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\vutil.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?GetCharLen@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrCut@@YAHPBDPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrLen@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChar@@YAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMultiByte@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNative@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsHangul@@YAHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStrNull@@YAXPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isdigit2@@YAHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetCharLen@@YAHPBD@Z				; GetCharLen
EXTRN	__imp__CharNextA@4:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
;	COMDAT ?GetCharLen@@YAHPBD@Z
_TEXT	SEGMENT
_pStr$ = 8						; size = 4
?GetCharLen@@YAHPBD@Z PROC NEAR				; GetCharLen, COMDAT

; 13   : {

  00000	56		 push	 esi

; 14   : 	char* pNext = CharNext( pStr );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pStr$[esp]
  00005	56		 push	 esi
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4

; 15   : 	return (int) (pNext - pStr );

  0000c	2b c6		 sub	 eax, esi
  0000e	5e		 pop	 esi

; 16   : }

  0000f	c3		 ret	 0
?GetCharLen@@YAHPBD@Z ENDP				; GetCharLen
_TEXT	ENDS
PUBLIC	?GetStrCut@@YAHPBDPADH@Z			; GetStrCut
; Function compile flags: /Ogty
;	COMDAT ?GetStrCut@@YAHPBDPADH@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_pDest$ = 12						; size = 4
_nCount$ = 16						; size = 4
?GetStrCut@@YAHPBDPADH@Z PROC NEAR			; GetStrCut, COMDAT

; 20   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 21   : 	int nOffset = 0;
; 22   : 	int nLen;
; 23   : 	
; 24   : 	while( nCount )

  00002	8b 6c 24 14	 mov	 ebp, DWORD PTR _nCount$[esp+4]
  00006	56		 push	 esi
  00007	8b 74 24 10	 mov	 esi, DWORD PTR _pSrc$[esp+8]
  0000b	33 db		 xor	 ebx, ebx
  0000d	85 ed		 test	 ebp, ebp
  0000f	57		 push	 edi
  00010	74 11		 je	 SHORT $L186712
$L186711:

; 25   : 	{
; 26   : 		nLen = GetCharLen( &pSrc[ nOffset ]  );

  00012	8d 3c 33	 lea	 edi, DWORD PTR [ebx+esi]
  00015	57		 push	 edi
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4

; 27   : 		nOffset += nLen;

  0001c	2b c7		 sub	 eax, edi
  0001e	03 d8		 add	 ebx, eax
  00020	4d		 dec	 ebp
  00021	75 ef		 jne	 SHORT $L186711
$L186712:

; 28   : 		nCount--;
; 29   : 	}
; 30   : 	
; 31   : 	memcpy( pDest, pSrc, sizeof(char)*nOffset);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR _pDest$[esp+12]
  00027	8b cb		 mov	 ecx, ebx
  00029	8b c1		 mov	 eax, ecx
  0002b	c1 e9 02	 shr	 ecx, 2
  0002e	f3 a5		 rep movsd
  00030	8b c8		 mov	 ecx, eax
  00032	83 e1 03	 and	 ecx, 3
  00035	f3 a4		 rep movsb
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp

; 32   : 	
; 33   : 	return 1;

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	5b		 pop	 ebx

; 34   : }	

  00040	c3		 ret	 0
?GetStrCut@@YAHPBDPADH@Z ENDP				; GetStrCut
_TEXT	ENDS
PUBLIC	?GetStrLen@@YAHPBD@Z				; GetStrLen
; Function compile flags: /Ogty
;	COMDAT ?GetStrLen@@YAHPBD@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
?GetStrLen@@YAHPBD@Z PROC NEAR				; GetStrLen, COMDAT

; 38   : {

  00000	53		 push	 ebx

; 39   : 	int nCount = 0;
; 40   : 	int nOffset = 0;
; 41   : 	int nLen;
; 42   : 	
; 43   : 	while( pSrc[ nOffset ] != NULL )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _pSrc$[esp]
  00005	8a 03		 mov	 al, BYTE PTR [ebx]
  00007	55		 push	 ebp
  00008	57		 push	 edi
  00009	33 ed		 xor	 ebp, ebp
  0000b	33 ff		 xor	 edi, edi
  0000d	84 c0		 test	 al, al
  0000f	74 1a		 je	 SHORT $L187029
  00011	56		 push	 esi
  00012	8b f3		 mov	 esi, ebx
$L186721:

; 44   : 	{
; 45   : 		nLen = GetCharLen( &pSrc[ nOffset ]  );

  00014	56		 push	 esi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4

; 46   : 		nOffset += nLen;

  0001b	2b c6		 sub	 eax, esi
  0001d	03 f8		 add	 edi, eax
  0001f	8a 04 1f	 mov	 al, BYTE PTR [edi+ebx]
  00022	8d 34 1f	 lea	 esi, DWORD PTR [edi+ebx]

; 47   : 		nCount++;

  00025	45		 inc	 ebp
  00026	84 c0		 test	 al, al
  00028	75 ea		 jne	 SHORT $L186721
  0002a	5e		 pop	 esi
$L187029:
  0002b	5f		 pop	 edi

; 48   : 	}
; 49   : 	
; 50   : 	return nCount;

  0002c	8b c5		 mov	 eax, ebp
  0002e	5d		 pop	 ebp
  0002f	5b		 pop	 ebx

; 51   : }	

  00030	c3		 ret	 0
?GetStrLen@@YAHPBD@Z ENDP				; GetStrLen
_TEXT	ENDS
PUBLIC	?CopyChar@@YAHPBDPAD@Z				; CopyChar
EXTRN	?g_codePage@@3GA:WORD				; g_codePage
EXTRN	?CharNextEx@@YAPBDPBDG@Z:NEAR			; CharNextEx
; Function compile flags: /Ogty
;	COMDAT ?CopyChar@@YAHPBDPAD@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_pDest$ = 12						; size = 4
?CopyChar@@YAHPBDPAD@Z PROC NEAR			; CopyChar, COMDAT

; 56   : 	const char* pNext = CharNextEx(pSrc);

  00000	33 c0		 xor	 eax, eax
  00002	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g_codePage@@3GA ; g_codePage
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR _pSrc$[esp]
  0000d	57		 push	 edi
  0000e	50		 push	 eax
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?CharNextEx@@YAPBDPBDG@Z ; CharNextEx

; 57   : 
; 58   : 	memcpy(pDest, pSrc, pNext - pSrc);

  00015	8b 7c 24 18	 mov	 edi, DWORD PTR _pDest$[esp+12]
  00019	2b c6		 sub	 eax, esi
  0001b	8b c8		 mov	 ecx, eax
  0001d	8b d1		 mov	 edx, ecx
  0001f	c1 e9 02	 shr	 ecx, 2
  00022	f3 a5		 rep movsd
  00024	8b ca		 mov	 ecx, edx
  00026	83 c4 08	 add	 esp, 8
  00029	83 e1 03	 and	 ecx, 3
  0002c	f3 a4		 rep movsb
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 59   : 
; 60   : 	return pNext - pSrc;
; 61   : }

  00030	c3		 ret	 0
?CopyChar@@YAHPBDPAD@Z ENDP				; CopyChar
_TEXT	ENDS
PUBLIC	?IsMultiByte@@YAHPBD@Z				; IsMultiByte
; Function compile flags: /Ogty
;	COMDAT ?IsMultiByte@@YAHPBD@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
?IsMultiByte@@YAHPBD@Z PROC NEAR			; IsMultiByte, COMDAT

; 65   : 	return ( CharNextEx(pSrc) - pSrc ) > 1;

  00000	33 c0		 xor	 eax, eax
  00002	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g_codePage@@3GA ; g_codePage
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR _pSrc$[esp]
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ?CharNextEx@@YAPBDPBDG@Z ; CharNextEx
  00014	2b c6		 sub	 eax, esi
  00016	33 c9		 xor	 ecx, ecx
  00018	83 c4 08	 add	 esp, 8
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	0f 9f c1	 setg	 cl
  00021	5e		 pop	 esi
  00022	8b c1		 mov	 eax, ecx

; 66   : }

  00024	c3		 ret	 0
?IsMultiByte@@YAHPBD@Z ENDP				; IsMultiByte
_TEXT	ENDS
PUBLIC	?IsHangul@@YAHG@Z				; IsHangul
; Function compile flags: /Ogty
;	COMDAT ?IsHangul@@YAHG@Z
_TEXT	SEGMENT
_word$ = 8						; size = 2
?IsHangul@@YAHG@Z PROC NEAR				; IsHangul, COMDAT

; 119  : 	BYTE l = word & 0xff;
; 120  : 	BYTE h = word >> 8;

  00000	66 8b 44 24 04	 mov	 ax, WORD PTR _word$[esp-4]

; 121  : 
; 122  : 	// 특수 문자, 일어 기타 언어 FALSE
; 123  : 	if( h >= 0xa1 && h <= 0xac && l >= 0xa0 && l <= 0xff )

  00005	80 fc a1	 cmp	 ah, 161			; 000000a1H
  00008	72 0d		 jb	 SHORT $L186771
  0000a	80 fc ac	 cmp	 ah, 172			; 000000acH
  0000d	77 08		 ja	 SHORT $L186771
  0000f	3c a0		 cmp	 al, 160			; 000000a0H
  00011	72 04		 jb	 SHORT $L186771
  00013	3c ff		 cmp	 al, 255			; 000000ffH

; 124  : 		return FALSE;

  00015	76 2a		 jbe	 SHORT $L186773
$L186771:

; 125  : 	// 확장 완성형  
; 126  : 	if( h >= 0x81 && h <= 0xc6 && l >= 0x41 && l <= 0xfe )

  00017	80 fc 81	 cmp	 ah, 129			; 00000081H
  0001a	72 0d		 jb	 SHORT $L186772
  0001c	80 fc c6	 cmp	 ah, 198			; 000000c6H
  0001f	77 08		 ja	 SHORT $L186772
  00021	3c 41		 cmp	 al, 65			; 00000041H
  00023	72 04		 jb	 SHORT $L186772
  00025	3c fe		 cmp	 al, 254			; 000000feH

; 127  : 		return TRUE;

  00027	76 12		 jbe	 SHORT $L187036
$L186772:

; 128  : 	// 완성형 코드 
; 129  : 	if( h >= 0xb0 && h <= 0xc8 && l >= 0xa1 && l <= 0xfe )

  00029	80 fc b0	 cmp	 ah, 176			; 000000b0H
  0002c	72 13		 jb	 SHORT $L186773
  0002e	80 fc c8	 cmp	 ah, 200			; 000000c8H
  00031	77 0e		 ja	 SHORT $L186773
  00033	3c a1		 cmp	 al, 161			; 000000a1H
  00035	72 0a		 jb	 SHORT $L186773
  00037	3c fe		 cmp	 al, 254			; 000000feH
  00039	77 06		 ja	 SHORT $L186773
$L187036:

; 130  : 		return TRUE;

  0003b	b8 01 00 00 00	 mov	 eax, 1

; 132  : } 

  00040	c3		 ret	 0
$L186773:

; 131  : 	return FALSE;

  00041	33 c0		 xor	 eax, eax

; 132  : } 

  00043	c3		 ret	 0
?IsHangul@@YAHG@Z ENDP					; IsHangul
_TEXT	ENDS
PUBLIC	?SetStrNull@@YAXPADH@Z				; SetStrNull
EXTRN	__imp__IsDBCSLeadByte@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?SetStrNull@@YAXPADH@Z
_TEXT	SEGMENT
_lpStr$ = 8						; size = 4
_nNullLength$ = 12					; size = 4
?SetStrNull@@YAXPADH@Z PROC NEAR			; SetStrNull, COMDAT

; 135  : {

  00000	55		 push	 ebp

; 136  : 	int nLength = strlen( lpStr );

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR _lpStr$[esp]
  00005	8b c5		 mov	 eax, ebp
  00007	56		 push	 esi
  00008	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L187040:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L187040
  00017	57		 push	 edi

; 137  : 	// 0을 넣을 포지션이 실제 스트링 길이보다 길면 실제 스트링 길이로 맞출 필요가 있음
; 138  : 	if( nNullLength > nLength )

  00018	8b 7c 24 14	 mov	 edi, DWORD PTR _nNullLength$[esp+8]
  0001c	2b c2		 sub	 eax, edx
  0001e	3b f8		 cmp	 edi, eax
  00020	7e 02		 jle	 SHORT $L186779

; 139  : 		nNullLength = nLength;

  00022	8b f8		 mov	 edi, eax
$L186779:

; 140  : 	for( int i = 0; i < nNullLength; )

  00024	33 f6		 xor	 esi, esi
  00026	85 ff		 test	 edi, edi
  00028	7e 1e		 jle	 SHORT $L186783
  0002a	53		 push	 ebx
  0002b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__IsDBCSLeadByte@4
$L186782:

; 141  : 	{
; 142  : #ifdef __CLIENT
; 143  : 		if( ::GetLanguage() == LANG_THA && g_codePage == 874 ) // 타이 
; 144  : 			i++;
; 145  : 		else if(::GetLanguage() == LANG_VTN && g_codePage == 1258)
; 146  : 			i++;
; 147  : 		else
; 148  : #endif//__CLIENT
; 149  : 		if( IsDBCSLeadByte( lpStr[ i ] ) )

  00031	33 c0		 xor	 eax, eax
  00033	8a 04 2e	 mov	 al, BYTE PTR [esi+ebp]
  00036	50		 push	 eax
  00037	ff d3		 call	 ebx
  00039	85 c0		 test	 eax, eax
  0003b	74 05		 je	 SHORT $L186784

; 150  : 			i+=2;

  0003d	83 c6 02	 add	 esi, 2

; 151  : 		else

  00040	eb 01		 jmp	 SHORT $L186785
$L186784:

; 152  : 			i++;

  00042	46		 inc	 esi
$L186785:

; 140  : 	for( int i = 0; i < nNullLength; )

  00043	3b f7		 cmp	 esi, edi
  00045	7c ea		 jl	 SHORT $L186782
  00047	5b		 pop	 ebx
$L186783:

; 153  : 	}
; 154  : 	// i가 nLength 보다 크다면 Word캐릭터일 것이고, 끝부분이 깨져서 오차가 생긴 것이다.
; 155  : 	if( i > nNullLength )

  00048	3b f7		 cmp	 esi, edi
  0004a	5f		 pop	 edi
  0004b	7e 08		 jle	 SHORT $L186786

; 156  : 		lpStr[ i - 2 ] = 0;

  0004d	c6 44 2e fe 00	 mov	 BYTE PTR [esi+ebp-2], 0
  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp

; 159  : }

  00054	c3		 ret	 0
$L186786:

; 157  : 	else
; 158  : 		lpStr[ i ] = 0;

  00055	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  00059	5e		 pop	 esi
  0005a	5d		 pop	 ebp

; 159  : }

  0005b	c3		 ret	 0
?SetStrNull@@YAXPADH@Z ENDP				; SetStrNull
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L39166

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L39166:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L187043:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 66   : 		return (this+1);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 67   : 	}

  00003	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
; Function compile flags: /Ogty
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?AddRef@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 71   : 		ATLASSERT(nRefs > 0);
; 72   : 		_InterlockedIncrement(&nRefs);

  00000	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 73   : 	}

  0000c	c3		 ret	 0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 76   : 		return nRefs < 0;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 9c c0	 setl	 al

; 77   : 	}

  0000a	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Ogty
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 80   : 		return( nRefs > 1 ); 

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 01	 cmp	 edx, 1
  00008	0f 9f c0	 setg	 al

; 81   : 	}

  0000b	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Ogty
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	4a		 dec	 edx
  0000b	85 d2		 test	 edx, edx
  0000d	7f 0a		 jg	 SHORT $L39883

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b c8		 mov	 ecx, eax
  00016	ff 52 04	 call	 DWORD PTR [edx+4]
$L39883:

; 98   : 		}
; 99   : 	}

  00019	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	?isdigit2@@YAHD@Z				; isdigit2
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.h
;	COMDAT ?isdigit2@@YAHD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?isdigit2@@YAHD@Z PROC NEAR				; isdigit2, COMDAT

; 105  : 	if( c >= '0' && c <= '9' )

  00000	8a 44 24 04	 mov	 al, BYTE PTR _c$[esp-4]
  00004	3c 30		 cmp	 al, 48			; 00000030H
  00006	7c 0a		 jl	 SHORT $L140120
  00008	3c 39		 cmp	 al, 57			; 00000039H
  0000a	7f 06		 jg	 SHORT $L140120

; 106  : 		return TRUE;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 109  : }

  00011	c3		 ret	 0
$L140120:

; 107  : 	else
; 108  : 		return FALSE;

  00012	33 c0		 xor	 eax, eax

; 109  : }

  00014	c3		 ret	 0
?isdigit2@@YAHD@Z ENDP					; isdigit2
_TEXT	ENDS
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 510  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 511  : 	}

  00002	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
; Function compile flags: /Ogty
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  00005	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Ogty
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L184241
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L184241

; 794  : 			AtlThrow(E_INVALIDARG);
; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 797  : 		m_pszData[nLength] = 0;

  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 798  : 	}

  00018	c2 04 00	 ret	 4
$L184241:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187068:
  00025	cc		 int	 3
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Ogty
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pData$[esp-4]
  00004	83 c0 10	 add	 eax, 16			; 00000010H
  00007	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00009	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Ogty
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nChars$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp]
  00009	8b c1		 mov	 eax, ecx
  0000b	57		 push	 edi
  0000c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pchDest$[esp+4]
  00010	c1 e9 02	 shr	 ecx, 2
  00013	f3 a5		 rep movsd
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	f3 a4		 rep movsb
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 654  : 	}

  0001e	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	e9 00 00 00 00	 jmp	 _memmove
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Ogty
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00000	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00005	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187080:
  0000a	cc		 int	 3
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Ogty
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv181 = 8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 716  : 		CStringData* pOldData = GetData();

  00002	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00004	83 eb 10	 sub	 ebx, 16			; 00000010H
  00007	55		 push	 ebp

; 717  : 		int nOldLength = pOldData->nDataLength;

  00008	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$[esp+12], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0000f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 10	 call	 DWORD PTR [eax+16]
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _nLength$[esp+12]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	6a 01		 push	 1
  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	ff 12		 call	 DWORD PTR [edx]

; 719  : 		if( pNewData == NULL )

  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $L185534

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00028	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L185534:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0002d	3b ee		 cmp	 ebp, esi
  0002f	7d 02		 jge	 SHORT $L187084
  00031	8b f5		 mov	 esi, ebp
$L187084:
  00033	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  00036	8b d1		 mov	 edx, ecx
  00038	57		 push	 edi
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	89 7c 24 18	 mov	 DWORD PTR tv181[esp+16], edi
  00043	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00046	f3 a5		 rep movsd
  00048	8b ca		 mov	 ecx, edx
  0004a	83 e1 03	 and	 ecx, 3
  0004d	f3 a4		 rep movsb

; 725  : 		pNewData->nDataLength = nOldLength;

  0004f	89 68 04	 mov	 DWORD PTR [eax+4], ebp

; 726  : 		pOldData->Release();

  00052	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00055	83 c9 ff	 or	 ecx, -1
  00058	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0005c	49		 dec	 ecx
  0005d	85 c9		 test	 ecx, ecx
  0005f	5f		 pop	 edi
  00060	7f 08		 jg	 SHORT $L187100
  00062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	53		 push	 ebx
  00067	ff 52 04	 call	 DWORD PTR [edx+4]
$L187100:

; 727  : 		Attach( pNewData );

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR tv181[esp+12]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	5b		 pop	 ebx

; 728  : 	}

  00077	59		 pop	 ecx
  00078	c2 04 00	 ret	 4
$L187109:
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Ogty
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 777  : 		CStringData* pOldData = GetData();
; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nLength$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	83 e8 10	 sub	 eax, 16			; 00000010H
  00012	6a 01		 push	 1
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	ff 52 08	 call	 DWORD PTR [edx+8]

; 781  : 		if( pNewData == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L185543

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0001d	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L185543:

; 784  : 		}
; 785  : 		Attach( pNewData );

  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	5f		 pop	 edi
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	5e		 pop	 esi

; 786  : 	}

  00029	c2 04 00	 ret	 4
$L187123:
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?IsNative@@YAHPBD@Z				; IsNative
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
;	COMDAT ?IsNative@@YAHPBD@Z
_TEXT	SEGMENT
_lpszStr$ = 8						; size = 4
?IsNative@@YAHPBD@Z PROC NEAR				; IsNative, COMDAT

; 70   : 	ASSERT( g_codePage != 0 );
; 71   : 
; 72   : 	LPCWSTR pwSrc = (LPCWSTR) lpszStr;
; 73   : 
; 74   : 	if( g_codePage == 874 ) // 타이 

  00000	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g_codePage@@3GA ; g_codePage
  00006	66 3d 6a 03	 cmp	 ax, 874			; 0000036aH
  0000a	75 15		 jne	 SHORT $L186737

; 75   : 	{
; 76   : 		return (BYTE)*lpszStr >= 0xa1 && (BYTE)*lpszStr <= 0xfb;

  0000c	8b 44 24 04	 mov	 eax, DWORD PTR _lpszStr$[esp-4]
  00010	8a 00		 mov	 al, BYTE PTR [eax]
  00012	3c a1		 cmp	 al, 161			; 000000a1H
  00014	72 08		 jb	 SHORT $L186765
  00016	3c fb		 cmp	 al, 251			; 000000fbH
  00018	0f 86 90 00 00
	00		 jbe	 $L187128
$L186765:

; 112  : 		
; 113  : 	}
; 114  : 	return FALSE;

  0001e	33 c0		 xor	 eax, eax

; 115  : }

  00020	c3		 ret	 0
$L186737:

; 77   : 	}
; 78   : 	else
; 79   : 	if( g_codePage == 949 ) // 한글 

  00021	66 3d b5 03	 cmp	 ax, 949			; 000003b5H
  00025	75 12		 jne	 SHORT $L186741

; 80   : 	{
; 81   : 		return IsHangul( *pwSrc );

  00027	8b 4c 24 04	 mov	 ecx, DWORD PTR _lpszStr$[esp-4]
  0002b	33 d2		 xor	 edx, edx
  0002d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00030	89 54 24 04	 mov	 DWORD PTR _lpszStr$[esp-4], edx
  00034	e9 00 00 00 00	 jmp	 ?IsHangul@@YAHG@Z	; IsHangul
$L186741:

; 82   : 	}
; 83   : 	else
; 84   : 	if( g_codePage == 932 ) // 일본 

  00039	66 3d a4 03	 cmp	 ax, 932			; 000003a4H
  0003d	75 10		 jne	 SHORT $L186743

; 85   : 	{
; 86   : 		return IsDBCSLeadByte( (BYTE)( *pwSrc ) );

  0003f	8b 44 24 04	 mov	 eax, DWORD PTR _lpszStr$[esp-4]
  00043	33 c9		 xor	 ecx, ecx
  00045	8a 08		 mov	 cl, BYTE PTR [eax]
  00047	51		 push	 ecx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4

; 115  : }

  0004e	c3		 ret	 0
$L186743:

; 87   : 	}
; 88   : 	else
; 89   : 	if( g_codePage == 936 ) // 한자 : 중국

  0004f	66 3d a8 03	 cmp	 ax, 936			; 000003a8H
  00053	75 10		 jne	 SHORT $L186746

; 90   : 	{
; 91   : 		return IsDBCSLeadByte( (BYTE)( *pwSrc ) );

  00055	8b 54 24 04	 mov	 edx, DWORD PTR _lpszStr$[esp-4]
  00059	33 c0		 xor	 eax, eax
  0005b	8a 02		 mov	 al, BYTE PTR [edx]
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4

; 115  : }

  00064	c3		 ret	 0
$L186746:

; 92   : 	}
; 93   : 	else
; 94   : 	if( g_codePage == 950 ) // 한자 : 대만 

  00065	66 3d b6 03	 cmp	 ax, 950			; 000003b6H
  00069	75 b3		 jne	 SHORT $L186765

; 95   : 	{
; 96   : //		return IsDBCSLeadByte( *pwSrc );
; 97   : 
; 98   : 		if( ((BYTE)*lpszStr >= 0xCA && (BYTE)*lpszStr <= 0xFD) && ( (BYTE)*lpszStr+1 >= 0xA1 ) && ( (BYTE)*lpszStr+1 <= 0xFE) )

  0006b	8b 4c 24 04	 mov	 ecx, DWORD PTR _lpszStr$[esp-4]
  0006f	8a 01		 mov	 al, BYTE PTR [ecx]
  00071	3c ca		 cmp	 al, 202			; 000000caH
  00073	72 18		 jb	 SHORT $L186754
  00075	3c fd		 cmp	 al, 253			; 000000fdH
  00077	77 14		 ja	 SHORT $L186754
  00079	0f b6 c8	 movzx	 ecx, al
  0007c	41		 inc	 ecx
  0007d	81 f9 a1 00 00
	00		 cmp	 ecx, 161		; 000000a1H
  00083	7c 08		 jl	 SHORT $L186754
  00085	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH

; 99   : 		{
; 100  : 			return TRUE;

  0008b	7e 21		 jle	 SHORT $L187128
$L186754:

; 101  : 		}
; 102  : 		else
; 103  : 		if ( ( ( (BYTE)*lpszStr >= 0x41 ) && 
; 104  : 		 	 ( (BYTE)*lpszStr <= 0x5A ) ) || 
; 105  : 		   	( ( (BYTE)*lpszStr >= 0x61 ) && ( (BYTE)*lpszStr <= 0x7A) ) ) 	

  0008d	3c 41		 cmp	 al, 65			; 00000041H
  0008f	72 04		 jb	 SHORT $L186762
  00091	3c 5a		 cmp	 al, 90			; 0000005aH
  00093	76 19		 jbe	 SHORT $L187128
$L186762:
  00095	3c 61		 cmp	 al, 97			; 00000061H
  00097	72 04		 jb	 SHORT $L186760
  00099	3c 7a		 cmp	 al, 122			; 0000007aH

; 106  : 		{ 
; 107  : 			return TRUE;			

  0009b	76 11		 jbe	 SHORT $L187128
$L186760:

; 108  : 		} 
; 109  : 		else
; 110  : 		if( isdigit2( (BYTE)*lpszStr ) )

  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ?isdigit2@@YAHD@Z	; isdigit2
  000a3	83 c4 04	 add	 esp, 4
  000a6	85 c0		 test	 eax, eax
  000a8	0f 84 70 ff ff
	ff		 je	 $L186765
$L187128:

; 111  : 			return TRUE;

  000ae	b8 01 00 00 00	 mov	 eax, 1

; 115  : }

  000b3	c3		 ret	 0
?IsNative@@YAHPBD@Z ENDP				; IsNative
_TEXT	ENDS
PUBLIC	?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ; ATL::CSimpleStringT<char,0>::GetManager
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetManager, COMDAT
; _this$ = ecx

; 505  : 		return( GetData()->pStringMgr->Clone() );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00005	8b 11		 mov	 edx, DWORD PTR [ecx]
  00007	ff 62 10	 jmp	 DWORD PTR [edx+16]
?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetManager
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pchSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pStringMgr$ = 16					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 245  : 	CSimpleStringT( const XCHAR* pchSrc, int nLength, IAtlStringMgr* pStringMgr )

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 246  : 	{
; 247  : 		ATLASSERT( pStringMgr != NULL );
; 248  : 		
; 249  : 		if(pchSrc == NULL && nLength != 0)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	57		 push	 edi
  00009	8b 7c 24 14	 mov	 edi, DWORD PTR _nLength$[esp+8]
  0000d	8b d9		 mov	 ebx, ecx
  0000f	75 0e		 jne	 SHORT $L186832
  00011	85 ff		 test	 edi, edi
  00013	74 0a		 je	 SHORT $L186832

; 258  : 		SetLength( nLength );

$L187159:
  00015	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0001a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L186832:

; 250  : 			AtlThrow(E_INVALIDARG);
; 251  : 
; 252  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );

  0001f	8b 4c 24 18	 mov	 ecx, DWORD PTR _pStringMgr$[esp+8]
  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	ff 10		 call	 DWORD PTR [eax]

; 253  : 		if( pData == NULL )

  0002a	85 c0		 test	 eax, eax
  0002c	75 05		 jne	 SHORT $L186836

; 254  : 		{
; 255  : 			ThrowMemoryException();

  0002e	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L186836:

; 256  : 		}
; 257  : 		Attach( pData );

  00033	83 c0 10	 add	 eax, 16			; 00000010H

; 258  : 		SetLength( nLength );

  00036	85 ff		 test	 edi, edi
  00038	89 03		 mov	 DWORD PTR [ebx], eax
  0003a	7c d9		 jl	 SHORT $L187159
  0003c	3b 78 f8	 cmp	 edi, DWORD PTR [eax-8]
  0003f	7f d4		 jg	 SHORT $L187159
  00041	89 78 f4	 mov	 DWORD PTR [eax-12], edi
  00044	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00046	c6 04 0f 00	 mov	 BYTE PTR [edi+ecx], 0

; 259  : 		CopyChars( m_pszData, pchSrc, nLength );

  0004a	8b cf		 mov	 ecx, edi
  0004c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0004e	8b d1		 mov	 edx, ecx
  00050	c1 e9 02	 shr	 ecx, 2
  00053	f3 a5		 rep movsd
  00055	8b ca		 mov	 ecx, edx
  00057	83 e1 03	 and	 ecx, 3
  0005a	f3 a4		 rep movsb
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 260  : 	}

  0005e	8b c3		 mov	 eax, ebx
  00060	5b		 pop	 ebx
  00061	c2 0c 00	 ret	 12			; 0000000cH
$L187165:
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
; Function compile flags: /Ogty
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 501  : 		return( GetData()->nDataLength );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]

; 502  : 	}

  00005	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 263  : 		CStringData* pData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 264  : 		pData->Release();

  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L187179
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L187179:

; 265  : 	}

  0001c	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
; Function compile flags: /Ogty
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nNewLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L187196
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L187196
  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 549  : 	}

  00018	c2 04 00	 ret	 4
$L187196:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187198:
  00025	cc		 int	 3
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
; Function compile flags: /Ogty
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 422  : 		CStringData* pOldData = GetData();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 424  : 		if( pOldData->nDataLength == 0 )

  00005	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  00008	85 d2		 test	 edx, edx
  0000a	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	74 4c		 je	 SHORT $L187231
  00012	53		 push	 ebx

; 425  : 		{
; 426  : 			return;
; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

  00013	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00016	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  00019	85 db		 test	 ebx, ebx
  0001b	5b		 pop	 ebx
  0001c	7d 20		 jge	 SHORT $L184939

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

  0001e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00021	85 c0		 test	 eax, eax
  00023	7d 0a		 jge	 SHORT $L187220
  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187220:
  0002f	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	5f		 pop	 edi
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003c	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  0003d	c3		 ret	 0
$L184939:

; 433  : 		}
; 434  : 		else
; 435  : 		{
; 436  : 			pOldData->Release();

  0003e	83 c9 ff	 or	 ecx, -1
  00041	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00045	49		 dec	 ecx
  00046	85 c9		 test	 ecx, ecx
  00048	7f 08		 jg	 SHORT $L187226
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	50		 push	 eax
  0004f	ff 52 04	 call	 DWORD PTR [edx+4]
$L187226:

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b cf		 mov	 ecx, edi
  00056	ff 50 0c	 call	 DWORD PTR [eax+12]

; 438  : 			Attach( pNewData );

  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 06		 mov	 DWORD PTR [esi], eax
$L187231:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  00060	c3		 ret	 0
$L187235:
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 747  : 		CStringData* pOldData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 748  : 		if( pOldData->nDataLength > nLength )

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _nLength$[esp-4]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7e 02		 jle	 SHORT $L184961

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  00011	8b d6		 mov	 edx, esi
$L184961:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00013	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00017	5e		 pop	 esi
  00018	7e 09		 jle	 SHORT $L184962

; 753  : 		{
; 754  : 			Fork( nLength );

  0001a	89 54 24 04	 mov	 DWORD PTR _nLength$[esp-4], edx
  0001e	e9 00 00 00 00	 jmp	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L184962:

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00023	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00026	3b c2		 cmp	 eax, edx
  00028	7d 1f		 jge	 SHORT $L184964

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;
; 760  : 			if( nNewLength > 1024 )

  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7e 07		 jle	 SHORT $L184966

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00031	05 00 04 00 00	 add	 eax, 1024		; 00000400H

; 763  : 			}
; 764  : 			else

  00036	eb 02		 jmp	 SHORT $L184967
$L184966:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00038	03 c0		 add	 eax, eax
$L184967:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 02		 jge	 SHORT $L184968

; 769  : 			{
; 770  : 				nNewLength = nLength;

  0003e	8b c2		 mov	 eax, edx
$L184968:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00040	89 44 24 04	 mov	 DWORD PTR _nLength$[esp-4], eax
  00044	e9 00 00 00 00	 jmp	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L184964:

; 773  : 		}
; 774  : 	}

  00049	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
PUBLIC	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
; Function compile flags: /Ogty
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CloneData, COMDAT

; 801  : 	{

  00000	56		 push	 esi

; 802  : 		CStringData* pNewData = NULL;
; 803  : 
; 804  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pData$[esp]
  00005	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 10	 call	 DWORD PTR [eax+16]

; 805  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

  0000c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0000f	85 d2		 test	 edx, edx
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	7c 11		 jl	 SHORT $L184972
  00016	3b 06		 cmp	 eax, DWORD PTR [esi]
  00018	75 0d		 jne	 SHORT $L184972

; 806  : 		{
; 807  : 			pNewData = pData;

  0001a	8b c6		 mov	 eax, esi

; 808  : 			pNewData->AddRef();

  0001c	ba 01 00 00 00	 mov	 edx, 1
  00021	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00025	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  00026	c3		 ret	 0
$L184972:

; 809  : 		}
; 810  : 		else
; 811  : 		{
; 812  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	6a 01		 push	 1
  0002e	51		 push	 ecx
  0002f	8b c8		 mov	 ecx, eax
  00031	ff 12		 call	 DWORD PTR [edx]

; 813  : 			if( pNewData == NULL )

  00033	85 c0		 test	 eax, eax
  00035	75 05		 jne	 SHORT $L184975

; 814  : 			{
; 815  : 				ThrowMemoryException();

  00037	e9 00 00 00 00	 jmp	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L184975:

; 816  : 			}
; 817  : 			pNewData->nDataLength = pData->nDataLength;

  0003c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 818  : 			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'

  00042	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00045	41		 inc	 ecx
  00046	8b d1		 mov	 edx, ecx
  00048	57		 push	 edi
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	83 c6 10	 add	 esi, 16			; 00000010H
  0004f	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  00052	f3 a5		 rep movsd
  00054	8b ca		 mov	 ecx, edx
  00056	83 e1 03	 and	 ecx, 3
  00059	f3 a4		 rep movsb
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  0005d	c3		 ret	 0
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ENDP ; ATL::CSimpleStringT<char,0>::CloneData
_TEXT	ENDS
PUBLIC	??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z		; ATL::CSimpleStringT<char,0>::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z
_TEXT	SEGMENT
_iChar$ = 8						; size = 4
??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator[], COMDAT
; _this$ = ecx

; 369  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 370  : 		
; 371  : 		if( (iChar < 0) || (iChar > GetLength()) )

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _iChar$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	7c 0d		 jl	 SHORT $L186815
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	3b 50 f4	 cmp	 edx, DWORD PTR [eax-12]
  0000d	7f 06		 jg	 SHORT $L186815

; 372  : 			AtlThrow(E_INVALIDARG);
; 373  : 			
; 374  : 		return( m_pszData[iChar] );

  0000f	8a 04 10	 mov	 al, BYTE PTR [eax+edx]

; 375  : 	}

  00012	c2 04 00	 ret	 4
$L186815:
  00015	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0001a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187274:
  0001f	cc		 int	 3
??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z ENDP		; ATL::CSimpleStringT<char,0>::operator[]
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pch$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pStringMgr$ = 16					; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 923  : 	{

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _pStringMgr$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _pch$[esp-4]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nLength$[esp]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 924  : 	}

  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 0c 00	 ret	 12			; 0000000cH
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 963  : 	}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H
  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L187295
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L187295:
  0001c	c3		 ret	 0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H

; 220  : 		CStringData* pNewData = CloneData( pSrcData );

  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData

; 221  : 		Attach( pNewData );

  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 222  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 735  : 		CStringData* pOldData = GetData();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nLength$[esp]
  00019	2b d0		 sub	 edx, eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L187314

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L187314:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 744  : 	}

  0002a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 814  : 	{

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 815  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nMinBufferLength$[esp]
  00019	2b d0		 sub	 edx, eax
  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L187355
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L187355:
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 491  : 	}

  0002a	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	53		 push	 ebx

; 584  : 		if( nLength == 0 )

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nLength$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	8b e9		 mov	 ebp, ecx
  0000a	75 0a		 jne	 SHORT $L184946

; 585  : 		{
; 586  : 			Empty();

  0000c	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty
  00011	5d		 pop	 ebp
  00012	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00013	c2 08 00	 ret	 8
$L184946:

; 587  : 		}
; 588  : 		else
; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

  00016	8b 54 24 0c	 mov	 edx, DWORD PTR _pszSrc$[esp+4]
  0001a	85 d2		 test	 edx, edx
  0001c	75 0a		 jne	 SHORT $L184948

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

$L187426:
  0001e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L184948:

; 597  : 				AtlThrow(E_INVALIDARG);			
; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

  00028	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0002b	56		 push	 esi

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

  0002c	8b f2		 mov	 esi, edx
  0002e	2b f0		 sub	 esi, eax

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  00038	57		 push	 edi
  00039	8b 78 f4	 mov	 edi, DWORD PTR [eax-12]
  0003c	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0003f	2b c3		 sub	 eax, ebx
  00041	0b c8		 or	 ecx, eax
  00043	7d 0c		 jge	 SHORT $L187391
  00045	53		 push	 ebx
  00046	8b cd		 mov	 ecx, ebp
  00048	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  0004d	8b 54 24 14	 mov	 edx, DWORD PTR _pszSrc$[esp+12]
$L187391:

; 605  : 			if( nOffset <= nOldLength )

  00051	3b f7		 cmp	 esi, edi
  00053	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00056	77 10		 ja	 SHORT $L184953

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

  00058	53		 push	 ebx
  00059	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0005c	51		 push	 ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memmove
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 			}
; 609  : 			else

  00066	eb 14		 jmp	 SHORT $L187400
$L184953:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

  00068	8b cb		 mov	 ecx, ebx
  0006a	8b f2		 mov	 esi, edx
  0006c	8b d1		 mov	 edx, ecx
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	8b f8		 mov	 edi, eax
  00073	f3 a5		 rep movsd
  00075	8b ca		 mov	 ecx, edx
  00077	83 e1 03	 and	 ecx, 3
  0007a	f3 a4		 rep movsb
$L187400:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

  0007c	85 db		 test	 ebx, ebx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	7c 9c		 jl	 SHORT $L187426
  00082	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00085	3b 58 f8	 cmp	 ebx, DWORD PTR [eax-8]
  00088	7f 94		 jg	 SHORT $L187426
  0008a	89 58 f4	 mov	 DWORD PTR [eax-12], ebx
  0008d	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00090	5d		 pop	 ebp
  00091	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  00095	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00096	c2 08 00	 ret	 8
$L187429:
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT
$T187433 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_nCount$ = 12						; size = 4
?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left, COMDAT
; _this$ = ecx

; 1759 : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 1760 : 		// nCount is in XCHARs
; 1761 : 		if (nCount < 0)

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _nCount$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T187433[esp+12], 0
  00013	7d 02		 jge	 SHORT $L186807

; 1762 : 			nCount = 0;

  00015	33 f6		 xor	 esi, esi
$L186807:

; 1763 : 
; 1764 : 		int nLength = GetLength();

  00017	8b 07		 mov	 eax, DWORD PTR [edi]

; 1765 : 		if( nCount >= nLength )

  00019	3b 70 f4	 cmp	 esi, DWORD PTR [eax-12]
  0001c	7c 1d		 jl	 SHORT $L186809

; 1766 : 		{
; 1767 : 			return( *this );

  0001e	83 c0 f0	 add	 eax, -16		; fffffff0H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00027	83 c4 04	 add	 esp, 4
  0002a	8b c8		 mov	 ecx, eax
  0002c	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00030	83 c1 10	 add	 ecx, 16			; 00000010H
  00033	5f		 pop	 edi
  00034	89 08		 mov	 DWORD PTR [eax], ecx
  00036	5e		 pop	 esi

; 1771 : 	}

  00037	59		 pop	 ecx
  00038	c2 08 00	 ret	 8
$L186809:

; 1768 : 		}
; 1769 : 
; 1770 : 		return( CStringT( GetString(), nCount, GetManager() ) );

  0003b	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	ff 52 10	 call	 DWORD PTR [edx+16]
  00043	50		 push	 eax
  00044	8b 07		 mov	 eax, DWORD PTR [edi]
  00046	56		 push	 esi
  00047	8b 74 24 18	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+16]
  0004b	50		 push	 eax
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
  00053	5f		 pop	 edi
  00054	8b c6		 mov	 eax, esi
  00056	5e		 pop	 esi

; 1771 : 	}

  00057	59		 pop	 ecx
  00058	c2 08 00	 ret	 8
?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 274  : 		CStringData* pSrcData = strSrc.GetData();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]

; 275  : 		CStringData* pOldData = GetData();

  0000a	8b 37		 mov	 esi, DWORD PTR [edi]
  0000c	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000f	83 ee 10	 sub	 esi, 16			; 00000010H

; 276  : 		if( pSrcData != pOldData)

  00012	3b c6		 cmp	 eax, esi
  00014	74 4d		 je	 SHORT $L187532

; 277  : 		{
; 278  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )

  00016	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00019	85 d2		 test	 edx, edx
  0001b	53		 push	 ebx
  0001c	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  0001f	55		 push	 ebp
  00020	7c 33		 jl	 SHORT $L184213
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	3b 16		 cmp	 edx, DWORD PTR [esi]
  00026	75 2d		 jne	 SHORT $L184213

; 281  : 			}
; 282  : 			else
; 283  : 			{
; 284  : 				CStringData* pNewData = CloneData( pSrcData );

  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  0002e	8b e8		 mov	 ebp, eax
  00030	83 c4 04	 add	 esp, 4

; 285  : 				pOldData->Release();

  00033	83 c8 ff	 or	 eax, -1
  00036	f0 0f c1 03	 lock	  xadd	 DWORD PTR [ebx], eax
  0003a	48		 dec	 eax
  0003b	85 c0		 test	 eax, eax
  0003d	7f 08		 jg	 SHORT $L187523
  0003f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	56		 push	 esi
  00044	ff 52 04	 call	 DWORD PTR [edx+4]
$L187523:

; 286  : 				Attach( pNewData );

  00047	83 c5 10	 add	 ebp, 16			; 00000010H
  0004a	89 2f		 mov	 DWORD PTR [edi], ebp
  0004c	5d		 pop	 ebp
  0004d	5b		 pop	 ebx

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

  0004e	8b c7		 mov	 eax, edi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 291  : 	}

  00052	c2 04 00	 ret	 4
$L184213:

; 279  : 			{
; 280  : 				SetString( strSrc.GetString(), strSrc.GetLength() );

  00055	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  00058	50		 push	 eax
  00059	51		 push	 ecx
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00061	5d		 pop	 ebp
  00062	5b		 pop	 ebx
$L187532:

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

  00063	8b c7		 mov	 eax, edi
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 291  : 	}

  00067	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 968  : 		CThisSimpleString::operator=( strSrc );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=

; 969  : 
; 970  : 		return( *this );

  0000d	8b c6		 mov	 eax, esi
  0000f	5e		 pop	 esi

; 971  : 	}

  00010	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; SetStrNull
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T187646 DD	0ffffffffH
	DD	FLAT:$L187542
	DD	0ffffffffH
	DD	FLAT:$L187543
$T187637 DD	019930520H
	DD	02H
	DD	FLAT:$T187646
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
xdata$x	ENDS
;	COMDAT ?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T187570 = 8						; size = 1
$T187540 = 8						; size = 4
_string$ = 8						; size = 4
$T187541 = 12						; size = 4
_nNullLength$ = 12					; size = 4
?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC NEAR ; SetStrNull, COMDAT

; 161  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	53		 push	 ebx

; 162  : 	int nLength = string.GetLength();
; 163  : 	// 0을 넣을 포지션이 실제 스트링 길이보다 길면 실제 스트링 길이로 맞출 필요가 있음
; 164  : 	if( nNullLength > nLength )

  00016	8b 5c 24 18	 mov	 ebx, DWORD PTR _nNullLength$[esp+12]
  0001a	55		 push	 ebp
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b 7c 24 20	 mov	 edi, DWORD PTR _string$[esp+24]
  00021	8b 07		 mov	 eax, DWORD PTR [edi]
  00023	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  00026	3b d8		 cmp	 ebx, eax
  00028	7e 02		 jle	 SHORT $L186793

; 165  : 		nNullLength = nLength;

  0002a	8b d8		 mov	 ebx, eax
$L186793:

; 166  : 	for( int i = 0; i < nNullLength; )

  0002c	33 f6		 xor	 esi, esi
  0002e	85 db		 test	 ebx, ebx
  00030	7e 2d		 jle	 SHORT $L186797
  00032	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__IsDBCSLeadByte@4
$L186796:

; 167  : 	{
; 168  : #ifdef __CLIENT
; 169  : 		if( ::GetLanguage() == LANG_THA && g_codePage == 874 ) // 타이 
; 170  : 			i++;
; 171  : 		else if(::GetLanguage() == LANG_VTN && g_codePage == 1258)
; 172  : 			i++;
; 173  : 		else
; 174  : #endif//__CLIENT
; 175  : 		if( IsDBCSLeadByte( string[ i ] ) )

  00038	85 f6		 test	 esi, esi
  0003a	7c 4d		 jl	 SHORT $L187639
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	3b 70 f4	 cmp	 esi, DWORD PTR [eax-12]
  00041	7f 46		 jg	 SHORT $L187639
  00043	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  00046	88 4c 24 20	 mov	 BYTE PTR $T187570[esp+24], cl
  0004a	8b 54 24 20	 mov	 edx, DWORD PTR $T187570[esp+24]
  0004e	52		 push	 edx
  0004f	ff d5		 call	 ebp
  00051	85 c0		 test	 eax, eax
  00053	74 05		 je	 SHORT $L186798

; 176  : 			i+=2;

  00055	83 c6 02	 add	 esi, 2

; 177  : 		else

  00058	eb 01		 jmp	 SHORT $L186799
$L186798:

; 178  : 			i++;

  0005a	46		 inc	 esi
$L186799:

; 166  : 	for( int i = 0; i < nNullLength; )

  0005b	3b f3		 cmp	 esi, ebx
  0005d	7c d9		 jl	 SHORT $L186796
$L186797:

; 179  : 	}
; 180  : 	// i가 nLength 보다 크다면 Word캐릭터일 것이고, 끝부분이 깨져서 오차가 생긴 것이다.
; 181  : 	if( i > nNullLength )

  0005f	3b f3		 cmp	 esi, ebx

; 182  : 		string = string.Left( i - 2 );

  00061	8b cf		 mov	 ecx, edi
  00063	7e 2e		 jle	 SHORT $L186800
  00065	83 c6 fe	 add	 esi, -2			; fffffffeH
  00068	56		 push	 esi
  00069	8d 44 24 24	 lea	 eax, DWORD PTR $T187540[esp+28]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
  00073	50		 push	 eax
  00074	8b cf		 mov	 ecx, edi
  00076	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 0
  0007e	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
  00083	8b 44 24 20	 mov	 eax, DWORD PTR $T187540[esp+24]

; 183  : 	else

  00087	eb 29		 jmp	 SHORT $L187645
$L187639:

; 167  : 	{
; 168  : #ifdef __CLIENT
; 169  : 		if( ::GetLanguage() == LANG_THA && g_codePage == 874 ) // 타이 
; 170  : 			i++;
; 171  : 		else if(::GetLanguage() == LANG_VTN && g_codePage == 1258)
; 172  : 			i++;
; 173  : 		else
; 174  : #endif//__CLIENT
; 175  : 		if( IsDBCSLeadByte( string[ i ] ) )

  00089	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0008e	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L186800:

; 184  : 		string = string.Left( i );

  00093	56		 push	 esi
  00094	8d 44 24 28	 lea	 eax, DWORD PTR $T187541[esp+28]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 1
  000a9	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR $T187541[esp+24]
$L187645:
  000b2	83 c0 f0	 add	 eax, -16		; fffffff0H
  000b5	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  000bd	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  000c0	83 ca ff	 or	 edx, -1
  000c3	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000c7	4a		 dec	 edx
  000c8	85 d2		 test	 edx, edx
  000ca	7f 08		 jg	 SHORT $L187630
  000cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d0	50		 push	 eax
  000d1	ff 52 04	 call	 DWORD PTR [edx+4]
$L187630:

; 185  : }

  000d4	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5d		 pop	 ebp
  000db	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e2	5b		 pop	 ebx
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	c3		 ret	 0
$L187643:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L187542:
  00000	8d 4d 04	 lea	 ecx, DWORD PTR $T187540[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L187543:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR $T187541[ebp-4]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T187637
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; SetStrNull
END
