; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\ObjSerialize.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?Serialize@CCtrl@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CItemBase@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CItemElem@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CItem@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?time_null@@YAJXZ				; time_null
EXTRN	_time:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\cmnhdr.h
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT
?time_null@@YAJXZ PROC NEAR				; time_null, COMDAT

; 702  : #if defined(__WORLDSERVER) || defined(__CLIENT)
; 703  : 	return	g_tCurrent;
; 704  : #else	//
; 705  : 	return time( NULL );

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 _time
  00007	83 c4 04	 add	 esp, 4

; 706  : #endif	//
; 707  : }

  0000a	c3		 ret	 0
?time_null@@YAJXZ ENDP					; time_null
_TEXT	ENDS
PUBLIC	?IsStoring@CAr@@QBEHXZ				; CAr::IsStoring
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT
?IsStoring@CAr@@QBEHXZ PROC NEAR			; CAr::IsStoring, COMDAT
; _this$ = ecx

; 96   : 	{ return (m_nMode & CAr::load) == 0; }

  00000	33 c0		 xor	 eax, eax
  00002	8a 01		 mov	 al, BYTE PTR [ecx]
  00004	f7 d0		 not	 eax
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsStoring@CAr@@QBEHXZ ENDP				; CAr::IsStoring
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@E@Z				; CAr::operator<<
EXTRN	?CheckBuf@CAr@@QAEXI@Z:NEAR			; CAr::CheckBuf
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT
_by$ = 8						; size = 1
??6CAr@@QAEAAV0@E@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 107  : 	{ CheckBuf( sizeof(BYTE) );

  00000	56		 push	 esi
  00001	6a 01		 push	 1
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 108  : 		*(UNALIGNED BYTE*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8a 4c 24 08	 mov	 cl, BYTE PTR _by$[esp]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	ff 46 08	 inc	 DWORD PTR [esi+8]
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@E@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@G@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@G@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 110  : 	{ CheckBuf( sizeof( WORD ) );

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 111  : 		*(UNALIGNED WORD*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@G@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@J@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??6CAr@@QAEAAV0@J@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 113  : 	{ CheckBuf( sizeof(LONG) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 114  : 		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _l$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@J@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@K@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??6CAr@@QAEAAV0@K@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 116  : 	{ CheckBuf( sizeof(DWORD) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 117  : 		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@K@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAE@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT
_by$ = 8						; size = 4
??5CAr@@QAEAAV0@AAE@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 142  : 	{	CAR_SAFE_READ( BYTE, by );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0e		 ja	 SHORT $L162848
  00011	8a 09		 mov	 cl, BYTE PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _by$[esp-4]
  00017	88 0a		 mov	 BYTE PTR [edx], cl
  00019	ff 40 08	 inc	 DWORD PTR [eax+8]
  0001c	c2 04 00	 ret	 4
$L162848:
  0001f	8b 4c 24 04	 mov	 ecx, DWORD PTR _by$[esp-4]
  00023	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002c	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAE@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAG@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??5CAr@@QAEAAV0@AAG@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 144  : 	{	CAR_SAFE_READ( WORD, w );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 11		 ja	 SHORT $L162858
  00011	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00014	8b 54 24 04	 mov	 edx, DWORD PTR _w$[esp-4]
  00018	66 89 0a	 mov	 WORD PTR [edx], cx
  0001b	83 40 08 02	 add	 DWORD PTR [eax+8], 2
  0001f	c2 04 00	 ret	 4
$L162858:
  00022	8b 4c 24 04	 mov	 ecx, DWORD PTR _w$[esp-4]
  00026	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  0002b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00031	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAG@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAK@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??5CAr@@QAEAAV0@AAK@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 146  : 	{	CAR_SAFE_READ( DWORD, dw );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L162868
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _dw$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L162868:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _dw$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAK@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAJ@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??5CAr@@QAEAAV0@AAJ@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 152  : 	{	CAR_SAFE_READ( LONG, l );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L162898
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _l$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L162898:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _l$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAJ@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVCAr@@AAV0@_J@Z				; operator<<
EXTRN	?Write@CAr@@QAEXPBXI@Z:NEAR			; CAr::Write
; Function compile flags: /Ogty
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_i$ = 12						; size = 8
??6@YAAAVCAr@@AAV0@_J@Z PROC NEAR			; operator<<, COMDAT

; 163  : 	{	ar.Write( &i, sizeof(__int64) );	return ar;	}

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	6a 08		 push	 8
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _i$[esp+4]
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??6@YAAAVCAr@@AAV0@_J@Z ENDP				; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVCAr@@AAV0@AA_J@Z			; operator>>
EXTRN	?Read@CAr@@QAEXPAXI@Z:NEAR			; CAr::Read
; Function compile flags: /Ogty
;	COMDAT ??5@YAAAVCAr@@AAV0@AA_J@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_i$ = 12						; size = 4
??5@YAAAVCAr@@AAV0@AA_J@Z PROC NEAR			; operator>>, COMDAT

; 166  : 	{	ar.Read( &i, sizeof(__int64) );	return ar;	}

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _i$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00009	6a 08		 push	 8
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??5@YAAAVCAr@@AAV0@AA_J@Z ENDP				; operator>>
_TEXT	ENDS
PUBLIC	?Serialize@CCtrl@@UAEXAAVCAr@@@Z		; CCtrl::Serialize
EXTRN	?Serialize@CObj@@UAEXAAVCAr@@@Z:NEAR		; CObj::Serialize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\objserialize.cpp
;	COMDAT ?Serialize@CCtrl@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
?Serialize@CCtrl@@UAEXAAVCAr@@@Z PROC NEAR		; CCtrl::Serialize, COMDAT
; _this$ = ecx

; 16   : {

  00000	56		 push	 esi

; 17   : 	CObj::Serialize( ar );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	57		 push	 edi
  00006	56		 push	 esi
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?Serialize@CObj@@UAEXAAVCAr@@@Z ; CObj::Serialize

; 18   : 
; 19   : 	if( ar.IsStoring() )

  0000e	33 c0		 xor	 eax, eax
  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	f7 d0		 not	 eax
  00014	a8 01		 test	 al, 1
  00016	74 1f		 je	 SHORT $L186702

; 20   : 	{
; 21   : 		ar << m_objid;

  00018	8b 7f 30	 mov	 edi, DWORD PTR [edi+48]
  0001b	6a 04		 push	 4
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00027	89 39		 mov	 DWORD PTR [ecx], edi
  00029	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002c	83 c0 04	 add	 eax, 4
  0002f	5f		 pop	 edi
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	5e		 pop	 esi

; 26   : 	}
; 27   : }

  00034	c2 04 00	 ret	 4
$L186702:

; 22   : 	}
; 23   : 	else
; 24   : 	{
; 25   : 		ar >> m_objid;

  00037	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0003d	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00040	3b d1		 cmp	 edx, ecx
  00042	77 13		 ja	 SHORT $L186937
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 47 30	 mov	 DWORD PTR [edi+48], eax
  00049	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004c	83 c0 04	 add	 eax, 4
  0004f	5f		 pop	 edi
  00050	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00053	5e		 pop	 esi

; 26   : 	}
; 27   : }

  00054	c2 04 00	 ret	 4

; 22   : 	}
; 23   : 	else
; 24   : 	{
; 25   : 		ar >> m_objid;

$L186937:
  00057	c7 47 30 00 00
	00 00		 mov	 DWORD PTR [edi+48], 0
  0005e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00061	5f		 pop	 edi
  00062	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00065	5e		 pop	 esi

; 26   : 	}
; 27   : }

  00066	c2 04 00	 ret	 4
?Serialize@CCtrl@@UAEXAAVCAr@@@Z ENDP			; CCtrl::Serialize
_TEXT	ENDS
PUBLIC	?Serialize@CItemBase@@UAEXAAVCAr@@@Z		; CItemBase::Serialize
EXTRN	?WriteString@CAr@@QAEXPBD@Z:NEAR		; CAr::WriteString
EXTRN	?ReadString@CAr@@QAEPADPADH@Z:NEAR		; CAr::ReadString
; Function compile flags: /Ogty
;	COMDAT ?Serialize@CItemBase@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
?Serialize@CItemBase@@UAEXAAVCAr@@@Z PROC NEAR		; CItemBase::Serialize, COMDAT
; _this$ = ecx

; 32   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 33   : 	if( ar.IsStoring() )

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _ar$[esp+8]
  00007	33 c0		 xor	 eax, eax
  00009	8a 06		 mov	 al, BYTE PTR [esi]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 34   : 	{
; 35   : 		ar << m_dwObjId << m_dwItemId;

  0000e	bd 04 00 00 00	 mov	 ebp, 4
  00013	f7 d0		 not	 eax
  00015	a8 01		 test	 al, 1
  00017	74 50		 je	 SHORT $L186708
  00019	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0001c	55		 push	 ebp
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00024	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00027	89 19		 mov	 DWORD PTR [ecx], ebx
  00029	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  0002c	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0002f	55		 push	 ebp
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00037	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003a	89 1a		 mov	 DWORD PTR [edx], ebx
  0003c	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 36   : 		ar << m_liSerialNumber;

  0003f	8b 5f 30	 mov	 ebx, DWORD PTR [edi+48]
  00042	55		 push	 ebp
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004d	89 18		 mov	 DWORD PTR [eax], ebx
  0004f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00052	03 cd		 add	 ecx, ebp

; 37   : 		ar.WriteString( m_szItemText );

  00054	83 c7 0c	 add	 edi, 12			; 0000000cH
  00057	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0005a	57		 push	 edi
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	5b		 pop	 ebx

; 44   : 	}
; 45   : }

  00066	c2 04 00	 ret	 4
$L186708:

; 38   : 	}
; 39   : 	else
; 40   : 	{
; 41   : 		ar >> m_dwObjId >> m_dwItemId;

  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0006f	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00072	33 c9		 xor	 ecx, ecx
  00074	3b d3		 cmp	 edx, ebx
  00076	77 0a		 ja	 SHORT $L186960
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0007d	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  00080	eb 09		 jmp	 SHORT $L186961
$L186960:
  00082	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00085	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00088	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L186961:
  0008b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008e	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00091	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00094	3b d3		 cmp	 edx, ebx
  00096	77 0a		 ja	 SHORT $L186966
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0009d	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  000a0	eb 09		 jmp	 SHORT $L186967
$L186966:
  000a2	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000a5	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000a8	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L186967:

; 42   : 		ar >> m_liSerialNumber;

  000ab	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ae	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000b1	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  000b4	3b d3		 cmp	 edx, ebx
  000b6	77 21		 ja	 SHORT $L186972
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 47 30	 mov	 DWORD PTR [edi+48], eax
  000bd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 43   : 		ar.ReadString( m_szItemText, 32 );

  000c0	6a 20		 push	 32			; 00000020H
  000c2	83 c7 0c	 add	 edi, 12			; 0000000cH
  000c5	03 c5		 add	 eax, ebp
  000c7	57		 push	 edi
  000c8	8b ce		 mov	 ecx, esi
  000ca	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000cd	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp
  000d5	5b		 pop	 ebx

; 44   : 	}
; 45   : }

  000d6	c2 04 00	 ret	 4

; 42   : 		ar >> m_liSerialNumber;

$L186972:
  000d9	89 4f 30	 mov	 DWORD PTR [edi+48], ecx
  000dc	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]

; 43   : 		ar.ReadString( m_szItemText, 32 );

  000df	6a 20		 push	 32			; 00000020H
  000e1	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000e4	83 c7 0c	 add	 edi, 12			; 0000000cH
  000e7	57		 push	 edi
  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5d		 pop	 ebp
  000f2	5b		 pop	 ebx

; 44   : 	}
; 45   : }

  000f3	c2 04 00	 ret	 4
?Serialize@CItemBase@@UAEXAAVCAr@@@Z ENDP		; CItemBase::Serialize
_TEXT	ENDS
PUBLIC	?Serialize@CItem@@UAEXAAVCAr@@@Z		; CItem::Serialize
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??0CItemElem@@QAE@XZ:NEAR			; CItemElem::CItemElem
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
xdata$x	SEGMENT
$T186996 DD	0ffffffffH
	DD	FLAT:$L186986
$T186993 DD	019930520H
	DD	01H
	DD	FLAT:$T186996
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\objserialize.cpp
xdata$x	ENDS
;	COMDAT ?Serialize@CItem@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T186983 = 8						; size = 4
_ar$ = 8						; size = 4
?Serialize@CItem@@UAEXAAVCAr@@@Z PROC NEAR		; CItem::Serialize, COMDAT
; _this$ = ecx

; 159  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?Serialize@CItem@@UAEXAAVCAr@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	53		 push	 ebx

; 160  : 	CCtrl::Serialize( ar );		// 33

  00016	8b 5c 24 14	 mov	 ebx, DWORD PTR _ar$[esp+12]
  0001a	56		 push	 esi
  0001b	53		 push	 ebx
  0001c	8b f1		 mov	 esi, ecx
  0001e	e8 00 00 00 00	 call	 ?Serialize@CCtrl@@UAEXAAVCAr@@@Z ; CCtrl::Serialize

; 161  : 	
; 162  : 	if( ar.IsStoring() )

  00023	33 c0		 xor	 eax, eax
  00025	8a 03		 mov	 al, BYTE PTR [ebx]
  00027	f7 d0		 not	 eax
  00029	a8 01		 test	 al, 1
  0002b	75 47		 jne	 SHORT $L186739

; 163  : 	{
; 164  : 	}
; 165  : 	else
; 166  : 	{
; 167  : 		SAFE_DELETE( m_pItemBase );

  0002d	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00030	85 c9		 test	 ecx, ecx
  00032	74 0d		 je	 SHORT $L186740
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	6a 01		 push	 1
  00038	ff 12		 call	 DWORD PTR [edx]
  0003a	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
$L186740:

; 168  : 		m_pItemBase	= new CItemElem;

  00041	68 a0 00 00 00	 push	 160			; 000000a0H
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4
  0004e	89 44 24 18	 mov	 DWORD PTR $T186983[esp+16], eax
  00052	85 c0		 test	 eax, eax
  00054	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 0
  0005c	74 09		 je	 SHORT $L186984
  0005e	8b c8		 mov	 ecx, eax
  00060	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem
  00065	eb 02		 jmp	 SHORT $L186985
$L186984:
  00067	33 c0		 xor	 eax, eax
$L186985:
  00069	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+28], -1
  00071	89 46 34	 mov	 DWORD PTR [esi+52], eax
$L186739:

; 169  : 	}
; 170  : 
; 171  : 	m_pItemBase->Serialize( ar );	// 11

  00074	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00077	8b 01		 mov	 eax, DWORD PTR [ecx]
  00079	53		 push	 ebx
  0007a	ff 50 0c	 call	 DWORD PTR [eax+12]

; 172  : }

  0007d	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00081	5e		 pop	 esi
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00089	5b		 pop	 ebx
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L186986:
  00000	8b 45 04	 mov	 eax, DWORD PTR $T186983[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Serialize@CItem@@UAEXAAVCAr@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T186993
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Serialize@CItem@@UAEXAAVCAr@@@Z ENDP			; CItem::Serialize
PUBLIC	??6CAr@@QAEAAV0@H@Z				; CAr::operator<<
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??6CAr@@QAEAAV0@H@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 99   : 	{ return CAr::operator<<((LONG)i); }

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _i$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@H@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@F@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@F@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 103  : 	{ return CAr::operator<<((WORD)w); }

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@F@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAH@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??5CAr@@QAEAAV0@AAH@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 126  : 	{ return CAr::operator>>((LONG&)i); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L187014
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _i$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L187014:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _i$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAH@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAF@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAF@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??5CAr@@QAEAAV0@AAF@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 130  : 	{ return CAr::operator>>((WORD&)w); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 11		 ja	 SHORT $L187021
  00011	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00014	8b 54 24 04	 mov	 edx, DWORD PTR _w$[esp-4]
  00018	66 89 0a	 mov	 WORD PTR [edx], cx
  0001b	83 40 08 02	 add	 DWORD PTR [eax+8], 2
  0001f	c2 04 00	 ret	 4
$L187021:
  00022	8b 4c 24 04	 mov	 ecx, DWORD PTR _w$[esp-4]
  00026	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  0002b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00031	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAF@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	?Serialize@CItemElem@@UAEXAAVCAr@@@Z		; CItemElem::Serialize
EXTRN	??0CPet@@QAE@XZ:NEAR				; CPet::CPet
EXTRN	?Serialize@CPet@@QAEXAAVCAr@@@Z:NEAR		; CPet::Serialize
;	COMDAT xdata$x
xdata$x	SEGMENT
$T187309 DD	0ffffffffH
	DD	FLAT:$L187034
$T187295 DD	019930520H
	DD	01H
	DD	FLAT:$T187309
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\objserialize.cpp
xdata$x	ENDS
;	COMDAT ?Serialize@CItemElem@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
$T187120 = -20						; size = 8
__$EHRec$ = -12						; size = 12
$T187031 = 8						; size = 4
_ar$ = 8						; size = 4
?Serialize@CItemElem@@UAEXAAVCAr@@@Z PROC NEAR		; CItemElem::Serialize, COMDAT
; _this$ = ecx

; 49   : {

  00000	6a ff		 push	 -1
  00002	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00008	68 00 00 00 00	 push	 __ehhandler$?Serialize@CItemElem@@UAEXAAVCAr@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi

; 50   : 	CItemBase::Serialize( ar );

  0001b	8b 74 24 24	 mov	 esi, DWORD PTR _ar$[esp+28]
  0001f	57		 push	 edi
  00020	56		 push	 esi
  00021	8b f9		 mov	 edi, ecx
  00023	e8 00 00 00 00	 call	 ?Serialize@CItemBase@@UAEXAAVCAr@@@Z ; CItemBase::Serialize

; 51   : 	if( ar.IsStoring() )

  00028	33 c0		 xor	 eax, eax
  0002a	8a 06		 mov	 al, BYTE PTR [esi]
  0002c	f7 d0		 not	 eax
  0002e	a8 01		 test	 al, 1
  00030	0f 84 ad 01 00
	00		 je	 $L186714

; 52   : 	{
; 53   : 		ar << m_nItemNum;

  00036	66 8b 5f 72	 mov	 bx, WORD PTR [edi+114]
  0003a	6a 02		 push	 2
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00043	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00046	66 89 19	 mov	 WORD PTR [ecx], bx
  00049	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 54   : 		ar << m_nRepairNumber << m_nHitPoint;

  0004d	8a 5f 70	 mov	 bl, BYTE PTR [edi+112]
  00050	6a 01		 push	 1
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	88 1a		 mov	 BYTE PTR [edx], bl
  0005e	ff 46 08	 inc	 DWORD PTR [esi+8]
  00061	8b 5f 74	 mov	 ebx, DWORD PTR [edi+116]
  00064	bd 04 00 00 00	 mov	 ebp, 4
  00069	55		 push	 ebp
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00071	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00074	89 18		 mov	 DWORD PTR [eax], ebx
  00076	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 55   : 		ar << m_nRepair;

  00079	8b 5f 6c	 mov	 ebx, DWORD PTR [edi+108]
  0007c	55		 push	 ebp
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	89 19		 mov	 DWORD PTR [ecx], ebx
  00089	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 56   : 		ar << m_byFlag;

  0008c	8a 5f 71	 mov	 bl, BYTE PTR [edi+113]
  0008f	6a 01		 push	 1
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00098	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009b	88 1a		 mov	 BYTE PTR [edx], bl
  0009d	ff 46 08	 inc	 DWORD PTR [esi+8]

; 57   : 		ar << m_nAbilityOption;

  000a0	8b 5f 68	 mov	 ebx, DWORD PTR [edi+104]
  000a3	55		 push	 ebp
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ab	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ae	89 18		 mov	 DWORD PTR [eax], ebx
  000b0	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 58   : 		ar << m_idGuild;				// 길드번호도 저장.

  000b3	8b 5f 78	 mov	 ebx, DWORD PTR [edi+120]
  000b6	55		 push	 ebp
  000b7	8b ce		 mov	 ecx, esi
  000b9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000be	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c1	89 19		 mov	 DWORD PTR [ecx], ebx
  000c3	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 59   : 		ar << m_bItemResist;			// 어느 속성 인가?

  000c6	8a 5f 7c	 mov	 bl, BYTE PTR [edi+124]
  000c9	6a 01		 push	 1
  000cb	8b ce		 mov	 ecx, esi
  000cd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d2	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d5	88 1a		 mov	 BYTE PTR [edx], bl
  000d7	ff 46 08	 inc	 DWORD PTR [esi+8]

; 60   : 		ar << m_nResistAbilityOption ;	// 속성 추가 능력치 가변 옵션

  000da	8b 9f 80 00 00
	00		 mov	 ebx, DWORD PTR [edi+128]
  000e0	55		 push	 ebp
  000e1	8b ce		 mov	 ecx, esi
  000e3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000eb	89 18		 mov	 DWORD PTR [eax], ebx
  000ed	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 61   : 		ar << m_nResistSMItemId;

  000f0	8b 9f 84 00 00
	00		 mov	 ebx, DWORD PTR [edi+132]
  000f6	55		 push	 ebp
  000f7	8b ce		 mov	 ecx, esi
  000f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fe	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00101	89 19		 mov	 DWORD PTR [ecx], ebx
  00103	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00106	03 c5		 add	 eax, ebp

; 62   : 		m_piercing.Serialize( ar );

  00108	8d 4f 34	 lea	 ecx, DWORD PTR [edi+52]
  0010b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0010e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00110	56		 push	 esi
  00111	ff 52 04	 call	 DWORD PTR [edx+4]

; 63   : 		ar << m_bCharged;

  00114	8b 9f 88 00 00
	00		 mov	 ebx, DWORD PTR [edi+136]
  0011a	55		 push	 ebp
  0011b	8b ce		 mov	 ecx, esi
  0011d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00122	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00125	89 18		 mov	 DWORD PTR [eax], ebx
  00127	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 64   : #if __VER >= 11 // __SYS_IDENTIFY
; 65   : 		ar << m_iRandomOptItemId;

  0012a	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]
  00130	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [edi+148]
  00136	6a 08		 push	 8
  00138	8d 44 24 14	 lea	 eax, DWORD PTR $T187120[esp+40]
  0013c	89 4c 24 14	 mov	 DWORD PTR $T187120[esp+40], ecx
  00140	50		 push	 eax
  00141	8b ce		 mov	 ecx, esi
  00143	89 54 24 1c	 mov	 DWORD PTR $T187120[esp+48], edx
  00147	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 66   : #else	// __SYS_IDENTIFY
; 67   : 		ar << m_nRandomOptItemId;
; 68   : #endif	// __SYS_IDENTIFY
; 69   : 		ar << m_dwKeepTime;

  0014c	8b 9f 8c 00 00
	00		 mov	 ebx, DWORD PTR [edi+140]
  00152	55		 push	 ebp
  00153	8b ce		 mov	 ecx, esi
  00155	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0015a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0015d	89 19		 mov	 DWORD PTR [ecx], ebx
  0015f	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 70   : 		if( m_dwKeepTime )

  00162	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00168	85 c0		 test	 eax, eax
  0016a	74 22		 je	 SHORT $L187131

; 71   : 		{
; 72   : 			time_t t	= m_dwKeepTime - time_null();

  0016c	6a 00		 push	 0
  0016e	e8 00 00 00 00	 call	 _time
  00173	8b 9f 8c 00 00
	00		 mov	 ebx, DWORD PTR [edi+140]
  00179	83 c4 04	 add	 esp, 4

; 73   : 			ar << t;

  0017c	55		 push	 ebp
  0017d	8b ce		 mov	 ecx, esi
  0017f	2b d8		 sub	 ebx, eax
  00181	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00186	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00189	89 1a		 mov	 DWORD PTR [edx], ebx
  0018b	01 6e 08	 add	 DWORD PTR [esi+8], ebp
$L187131:

; 74   : 		}
; 75   : #if __VER >= 9	// __PET_0410
; 76   : 		if( m_pPet )

  0018e	8b 87 98 00 00
	00		 mov	 eax, DWORD PTR [edi+152]
  00194	85 c0		 test	 eax, eax

; 77   : 		{
; 78   : 			ar << (BYTE)0x01;

  00196	8b ce		 mov	 ecx, esi
  00198	6a 01		 push	 1
  0019a	74 1c		 je	 SHORT $L186717
  0019c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001a1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001a4	c6 00 01	 mov	 BYTE PTR [eax], 1
  001a7	ff 46 08	 inc	 DWORD PTR [esi+8]

; 79   : 			m_pPet->Serialize( ar );

  001aa	8b 8f 98 00 00
	00		 mov	 ecx, DWORD PTR [edi+152]
  001b0	56		 push	 esi
  001b1	e8 00 00 00 00	 call	 ?Serialize@CPet@@QAEXAAVCAr@@@Z ; CPet::Serialize

; 80   : 		}
; 81   : 		else

  001b6	eb 0e		 jmp	 SHORT $L187137
$L186717:

; 82   : 		{
; 83   : 			ar << (BYTE)0x00;

  001b8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001bd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c0	c6 01 00	 mov	 BYTE PTR [ecx], 0
  001c3	ff 46 08	 inc	 DWORD PTR [esi+8]
$L187137:

; 84   : 		}
; 85   : #endif	// __PET_0410
; 86   : #if __VER >= 15 // __PETVIS
; 87   : 		ar << m_bTranformVisPet;

  001c6	8b bf 9c 00 00
	00		 mov	 edi, DWORD PTR [edi+156]
  001cc	55		 push	 ebp
  001cd	8b ce		 mov	 ecx, esi
  001cf	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001d4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001d7	89 3a		 mov	 DWORD PTR [edx], edi
  001d9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001dc	03 c5		 add	 eax, ebp

; 88   : #endif // __PETVIS
; 89   : 	}
; 90   : 	else

  001de	e9 63 02 00 00	 jmp	 $L187297
$L186714:

; 91   : 	{
; 92   : 		ar >> m_nItemNum;

  001e3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001e6	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  001e9	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  001ec	3b ca		 cmp	 ecx, edx
  001ee	77 11		 ja	 SHORT $L187156
  001f0	66 8b 10	 mov	 dx, WORD PTR [eax]
  001f3	66 89 57 72	 mov	 WORD PTR [edi+114], dx
  001f7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001fa	83 c0 02	 add	 eax, 2
  001fd	33 db		 xor	 ebx, ebx
  001ff	eb 09		 jmp	 SHORT $L187298
$L187156:
  00201	33 db		 xor	 ebx, ebx
  00203	66 89 5f 72	 mov	 WORD PTR [edi+114], bx
  00207	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187298:

; 93   : 		ar >> m_nRepairNumber ;

  0020a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0020d	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00210	3b ca		 cmp	 ecx, edx
  00212	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00215	77 0b		 ja	 SHORT $L187162
  00217	8a 10		 mov	 dl, BYTE PTR [eax]
  00219	88 57 70	 mov	 BYTE PTR [edi+112], dl
  0021c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0021f	40		 inc	 eax
  00220	eb 07		 jmp	 SHORT $L187299
$L187162:
  00222	c6 47 70 00	 mov	 BYTE PTR [edi+112], 0
  00226	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187299:

; 94   : 		ar >> m_nHitPoint;

  00229	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0022c	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0022f	3b ca		 cmp	 ecx, edx
  00231	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00234	bd 04 00 00 00	 mov	 ebp, 4
  00239	77 0c		 ja	 SHORT $L187175
  0023b	8b 10		 mov	 edx, DWORD PTR [eax]
  0023d	89 57 74	 mov	 DWORD PTR [edi+116], edx
  00240	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00243	03 c5		 add	 eax, ebp
  00245	eb 06		 jmp	 SHORT $L187300
$L187175:
  00247	89 5f 74	 mov	 DWORD PTR [edi+116], ebx
  0024a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187300:

; 95   : 		ar >> m_nRepair;

  0024d	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00250	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00253	3b ca		 cmp	 ecx, edx
  00255	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00258	77 0c		 ja	 SHORT $L187188
  0025a	8b 10		 mov	 edx, DWORD PTR [eax]
  0025c	89 57 6c	 mov	 DWORD PTR [edi+108], edx
  0025f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00262	03 c5		 add	 eax, ebp
  00264	eb 06		 jmp	 SHORT $L187301
$L187188:
  00266	89 5f 6c	 mov	 DWORD PTR [edi+108], ebx
  00269	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187301:

; 96   : 		ar >> m_byFlag;

  0026c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0026f	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00272	3b ca		 cmp	 ecx, edx
  00274	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00277	77 0b		 ja	 SHORT $L187194
  00279	8a 10		 mov	 dl, BYTE PTR [eax]
  0027b	88 57 71	 mov	 BYTE PTR [edi+113], dl
  0027e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00281	40		 inc	 eax
  00282	eb 07		 jmp	 SHORT $L187302
$L187194:
  00284	c6 47 71 00	 mov	 BYTE PTR [edi+113], 0
  00288	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187302:

; 97   : 		ar >> m_nAbilityOption;

  0028b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0028e	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00291	3b ca		 cmp	 ecx, edx
  00293	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00296	77 0c		 ja	 SHORT $L187207
  00298	8b 10		 mov	 edx, DWORD PTR [eax]
  0029a	89 57 68	 mov	 DWORD PTR [edi+104], edx
  0029d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002a0	03 c5		 add	 eax, ebp
  002a2	eb 06		 jmp	 SHORT $L187303
$L187207:
  002a4	89 5f 68	 mov	 DWORD PTR [edi+104], ebx
  002a7	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187303:

; 98   : 		ar >> m_idGuild;		

  002aa	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  002ad	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  002b0	3b ca		 cmp	 ecx, edx
  002b2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  002b5	77 0c		 ja	 SHORT $L187213
  002b7	8b 10		 mov	 edx, DWORD PTR [eax]
  002b9	89 57 78	 mov	 DWORD PTR [edi+120], edx
  002bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002bf	03 c5		 add	 eax, ebp
  002c1	eb 06		 jmp	 SHORT $L187304
$L187213:
  002c3	89 5f 78	 mov	 DWORD PTR [edi+120], ebx
  002c6	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187304:

; 99   : 		ar >> m_bItemResist;	

  002c9	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  002cc	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  002cf	3b ca		 cmp	 ecx, edx
  002d1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  002d4	77 0b		 ja	 SHORT $L187219
  002d6	8a 10		 mov	 dl, BYTE PTR [eax]
  002d8	88 57 7c	 mov	 BYTE PTR [edi+124], dl
  002db	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002de	40		 inc	 eax
  002df	eb 07		 jmp	 SHORT $L187305
$L187219:
  002e1	c6 47 7c 00	 mov	 BYTE PTR [edi+124], 0
  002e5	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187305:

; 100  : 		ar >> m_nResistAbilityOption ;	

  002e8	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  002eb	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  002ee	3b ca		 cmp	 ecx, edx
  002f0	89 46 08	 mov	 DWORD PTR [esi+8], eax
  002f3	77 0f		 ja	 SHORT $L187232
  002f5	8b 10		 mov	 edx, DWORD PTR [eax]
  002f7	89 97 80 00 00
	00		 mov	 DWORD PTR [edi+128], edx
  002fd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00300	03 c5		 add	 eax, ebp
  00302	eb 09		 jmp	 SHORT $L187306
$L187232:
  00304	89 9f 80 00 00
	00		 mov	 DWORD PTR [edi+128], ebx
  0030a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187306:

; 101  : 		ar >> m_nResistSMItemId;

  0030d	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00310	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00313	3b ca		 cmp	 ecx, edx
  00315	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00318	77 0f		 ja	 SHORT $L187245
  0031a	8b 10		 mov	 edx, DWORD PTR [eax]
  0031c	89 97 84 00 00
	00		 mov	 DWORD PTR [edi+132], edx
  00322	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00325	03 c5		 add	 eax, ebp
  00327	eb 09		 jmp	 SHORT $L187307
$L187245:
  00329	89 9f 84 00 00
	00		 mov	 DWORD PTR [edi+132], ebx
  0032f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187307:

; 102  : //		memset( &m_piercingInfo, 0, sizeof(m_piercingInfo) );
; 103  : 		m_piercing.Serialize( ar );

  00332	8d 4f 34	 lea	 ecx, DWORD PTR [edi+52]
  00335	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00338	8b 11		 mov	 edx, DWORD PTR [ecx]
  0033a	56		 push	 esi
  0033b	ff 52 04	 call	 DWORD PTR [edx+4]

; 104  : 		ar >> m_bCharged;

  0033e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00341	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00344	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00347	3b ca		 cmp	 ecx, edx
  00349	77 0f		 ja	 SHORT $L187258
  0034b	8b 10		 mov	 edx, DWORD PTR [eax]
  0034d	89 97 88 00 00
	00		 mov	 DWORD PTR [edi+136], edx
  00353	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00356	03 c5		 add	 eax, ebp
  00358	eb 09		 jmp	 SHORT $L187308
$L187258:
  0035a	89 9f 88 00 00
	00		 mov	 DWORD PTR [edi+136], ebx
  00360	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187308:

; 105  : #if __VER >= 11 // __SYS_IDENTIFY
; 106  : 		ar >> m_iRandomOptItemId;

  00363	6a 08		 push	 8
  00365	8d 8f 90 00 00
	00		 lea	 ecx, DWORD PTR [edi+144]
  0036b	51		 push	 ecx
  0036c	8b ce		 mov	 ecx, esi
  0036e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00371	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 107  : #else	// __SYS_IDENTIFY
; 108  : 		ar >> m_nRandomOptItemId;
; 109  : #endif	// __SYS_IDENTIFY
; 110  : 		ar >> m_dwKeepTime;

  00376	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00379	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0037c	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0037f	3b d1		 cmp	 edx, ecx
  00381	77 0d		 ja	 SHORT $L187267
  00383	8b 00		 mov	 eax, DWORD PTR [eax]
  00385	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax
  0038b	01 6e 08	 add	 DWORD PTR [esi+8], ebp
  0038e	eb 0c		 jmp	 SHORT $L187268
$L187267:
  00390	89 9f 8c 00 00
	00		 mov	 DWORD PTR [edi+140], ebx
  00396	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00399	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L187268:

; 111  : 
; 112  : 		if( m_dwKeepTime ) 

  0039c	39 9f 8c 00 00
	00		 cmp	 DWORD PTR [edi+140], ebx
  003a2	74 15		 je	 SHORT $L187274

; 113  : 		{
; 114  : 			time_t t;
; 115  : 			ar >> t;

  003a4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003a7	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  003aa	83 c0 04	 add	 eax, 4
  003ad	3b c1		 cmp	 eax, ecx
  003af	77 05		 ja	 SHORT $L187273
  003b1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  003b4	eb 03		 jmp	 SHORT $L187274
$L187273:
  003b6	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L187274:

; 116  : 		#ifdef __CLIENT
; 117  : 			m_dwKeepTime	= time_null() + t;
; 118  : 		#endif	// __CLIENT
; 119  : 		}
; 120  : #if __VER >= 9	// __PET_0410
; 121  : 		SAFE_DELETE( m_pPet );

  003b9	8b 8f 98 00 00
	00		 mov	 ecx, DWORD PTR [edi+152]
  003bf	3b cb		 cmp	 ecx, ebx
  003c1	74 0c		 je	 SHORT $L186724
  003c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  003c5	6a 01		 push	 1
  003c7	ff 12		 call	 DWORD PTR [edx]
  003c9	89 9f 98 00 00
	00		 mov	 DWORD PTR [edi+152], ebx
$L186724:

; 122  : 		BYTE bPet;
; 123  : 		ar >> bPet;

  003cf	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003d2	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  003d5	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  003d8	3b ca		 cmp	 ecx, edx
  003da	77 28		 ja	 SHORT $L187278
  003dc	8a 00		 mov	 al, BYTE PTR [eax]

; 124  : 		if( bPet )

  003de	84 c0		 test	 al, al
  003e0	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  003e3	74 3c		 je	 SHORT $L186729

; 125  : 		{
; 126  : 			m_pPet	= new CPet;

  003e5	6a 28		 push	 40			; 00000028H
  003e7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003ec	83 c4 04	 add	 esp, 4
  003ef	89 44 24 28	 mov	 DWORD PTR $T187031[esp+32], eax
  003f3	3b c3		 cmp	 eax, ebx
  003f5	89 5c 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], ebx
  003f9	74 0e		 je	 SHORT $L187032
  003fb	8b c8		 mov	 ecx, eax
  003fd	e8 00 00 00 00	 call	 ??0CPet@@QAE@XZ		; CPet::CPet
  00402	eb 07		 jmp	 SHORT $L187033

; 122  : 		BYTE bPet;
; 123  : 		ar >> bPet;

$L187278:
  00404	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 124  : 		if( bPet )

  00407	eb 18		 jmp	 SHORT $L186729
$L187032:

; 125  : 		{
; 126  : 			m_pPet	= new CPet;

  00409	33 c0		 xor	 eax, eax
$L187033:

; 127  : 			m_pPet->Serialize( ar );

  0040b	56		 push	 esi
  0040c	8b c8		 mov	 ecx, eax
  0040e	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  00416	89 87 98 00 00
	00		 mov	 DWORD PTR [edi+152], eax
  0041c	e8 00 00 00 00	 call	 ?Serialize@CPet@@QAEXAAVCAr@@@Z ; CPet::Serialize
$L186729:

; 128  : 		}
; 129  : #endif	// __PET_0410
; 130  : #if __VER >= 15 // __PETVIS
; 131  : 		ar >> m_bTranformVisPet;

  00421	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00424	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00427	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0042a	3b ca		 cmp	 ecx, edx
  0042c	77 0f		 ja	 SHORT $L187290
  0042e	8b 10		 mov	 edx, DWORD PTR [eax]
  00430	89 97 9c 00 00
	00		 mov	 DWORD PTR [edi+156], edx
  00436	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00439	03 c5		 add	 eax, ebp
  0043b	eb 09		 jmp	 SHORT $L187297
$L187290:
  0043d	89 9f 9c 00 00
	00		 mov	 DWORD PTR [edi+156], ebx
  00443	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187297:

; 132  : #endif // __PETVIS
; 133  : 
; 134  : #ifdef __CLIENT
; 135  : 		SetTexture();
; 136  : #endif
; 137  : 	}
; 138  : }

  00446	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  0044a	5f		 pop	 edi
  0044b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0044e	5e		 pop	 esi
  0044f	5d		 pop	 ebp
  00450	5b		 pop	 ebx
  00451	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00458	83 c4 14	 add	 esp, 20			; 00000014H
  0045b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L187034:
  00000	8b 45 04	 mov	 eax, DWORD PTR $T187031[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Serialize@CItemElem@@UAEXAAVCAr@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T187295
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Serialize@CItemElem@@UAEXAAVCAr@@@Z ENDP		; CItemElem::Serialize
END
