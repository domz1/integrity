; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_UnhandledException\exceptionhandler.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@IBNEFJCG@DBGHELP?4DLL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CFDBLPGL@MSDBI?4DLL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BKGKJIBP@MSPDB60?4DLL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@CLICICIC@MSPDB50?4DLL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CLNKCBPC@rCnt?$DN?$CFd?5?$AN?6?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IPOGOAKJ@?$AN?6?1?1?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JEGEICAJ@?$AN?6?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1CSymbolEngine@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInMemoryFileVersion@CSymbolEngine@@QAEHPBDAAK1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSymbolEngine@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitEH@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddErrorMsg@@YAXPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSymbolEngine@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_s_nRecrvCnt DD	01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	?_AddErrorMsg@@YAXPBD0@Z			; _AddErrorMsg
_BSS	SEGMENT
_g_szErrorAdd DB 07fffH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_unhandledexception\exceptionhandler.cpp
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?_AddErrorMsg@@YAXPBD0@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_strHead$ = 12						; size = 4
?_AddErrorMsg@@YAXPBD0@Z PROC NEAR			; _AddErrorMsg, COMDAT

; 52   : 	if( str[0] == 0 )	

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _str$[esp-4]
  00004	80 38 00	 cmp	 BYTE PTR [eax], 0
  00007	0f 84 96 00 00
	00		 je	 $L196605

; 53   : 		return;
; 54   : 	if( strlen( g_szErrorAdd ) >= 0x7fff )

  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_g_szErrorAdd
  00012	56		 push	 esi
  00013	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L196823:
  00016	8a 11		 mov	 dl, BYTE PTR [ecx]
  00018	41		 inc	 ecx
  00019	84 d2		 test	 dl, dl
  0001b	75 f9		 jne	 SHORT $L196823
  0001d	2b ce		 sub	 ecx, esi
  0001f	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00025	73 7b		 jae	 SHORT $L196829

; 55   : 		return;
; 56   : 	strcat( g_szErrorAdd, strHead );		// 메모장에서 찾기 쉽에 이거 붙이자 ㅎㅎ

  00027	8b 4c 24 0c	 mov	 ecx, DWORD PTR _strHead$[esp]
  0002b	8b f1		 mov	 esi, ecx
  0002d	8d 49 00	 npad	 3
$L196824:
  00030	8a 11		 mov	 dl, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 d2		 test	 dl, dl
  00035	75 f9		 jne	 SHORT $L196824
  00037	57		 push	 edi
  00038	2b ce		 sub	 ecx, esi
  0003a	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_g_szErrorAdd
  0003f	8b d1		 mov	 edx, ecx
  00041	4f		 dec	 edi
$L196825:
  00042	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00045	47		 inc	 edi
  00046	84 c9		 test	 cl, cl
  00048	75 f8		 jne	 SHORT $L196825
  0004a	8b ca		 mov	 ecx, edx
  0004c	c1 e9 02	 shr	 ecx, 2
  0004f	f3 a5		 rep movsd
  00051	8b ca		 mov	 ecx, edx
  00053	83 e1 03	 and	 ecx, 3
  00056	f3 a4		 rep movsb

; 57   : 	strcat( g_szErrorAdd, str );

  00058	8b c8		 mov	 ecx, eax
  0005a	8d 9b 00 00 00
	00		 npad	 6
$L196826:
  00060	8a 10		 mov	 dl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 d2		 test	 dl, dl
  00065	75 f9		 jne	 SHORT $L196826
  00067	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_g_szErrorAdd
  0006c	2b c1		 sub	 eax, ecx
  0006e	8b f1		 mov	 esi, ecx
  00070	4f		 dec	 edi
$L196827:
  00071	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00074	47		 inc	 edi
  00075	84 c9		 test	 cl, cl
  00077	75 f8		 jne	 SHORT $L196827
  00079	8b c8		 mov	 ecx, eax
  0007b	c1 e9 02	 shr	 ecx, 2
  0007e	f3 a5		 rep movsd
  00080	8b c8		 mov	 ecx, eax
  00082	83 e1 03	 and	 ecx, 3
  00085	f3 a4		 rep movsb

; 58   : 	strcat( g_szErrorAdd, "\n" );

  00087	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_g_szErrorAdd
  0008c	4f		 dec	 edi
  0008d	8d 49 00	 npad	 3
$L196828:
  00090	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00093	47		 inc	 edi
  00094	84 c0		 test	 al, al
  00096	75 f8		 jne	 SHORT $L196828
  00098	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
  0009e	66 89 07	 mov	 WORD PTR [edi], ax
  000a1	5f		 pop	 edi
$L196829:
  000a2	5e		 pop	 esi
$L196605:

; 59   : }

  000a3	c3		 ret	 0
?_AddErrorMsg@@YAXPBD0@Z ENDP				; _AddErrorMsg
_TEXT	ENDS
PUBLIC	??_C@_0N@CLNKCBPC@rCnt?$DN?$CFd?5?$AN?6?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@	; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6?$AA@			; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@		; `string'
PUBLIC	??_C@_07IPOGOAKJ@?$AN?6?1?1?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_04JEGEICAJ@?$AN?6?$CFs?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; CrashHandlerExceptionFilter
EXTRN	__chkstk:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	_sprintf:NEAR
EXTRN	__imp__InterlockedIncrement@4:NEAR
EXTRN	__imp__GetFaultReason@4:NEAR
EXTRN	__imp__GetFirstStackTraceString@8:NEAR
EXTRN	__imp__GetNextStackTraceString@8:NEAR
EXTRN	__imp__GetRegisterString@4:NEAR
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
EXTRN	?g_DbManager@@3AAVCDbManager@@A:DWORD		; g_DbManager
;	COMDAT ??_C@_0N@CLNKCBPC@rCnt?$DN?$CFd?5?$AN?6?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@CLNKCBPC@rCnt?$DN?$CFd?5?$AN?6?$CFs?$AA@ DB 'rCnt=%d ', 0dH, 0aH
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@
CONST	SEGMENT
??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@ DB 0aH, 0aH, ' - Register'
	DB	's', 0aH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6?$AA@ DB 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ DB '(null)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPOGOAKJ@?$AN?6?1?1?5?$CFd?$AA@
CONST	SEGMENT
??_C@_07IPOGOAKJ@?$AN?6?1?1?5?$CFd?$AA@ DB 0dH, 0aH, '// %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JEGEICAJ@?$AN?6?$CFs?$AA@
CONST	SEGMENT
??_C@_04JEGEICAJ@?$AN?6?$CFs?$AA@ DB 0dH, 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z
_TEXT	SEGMENT
$T196833 = -16440					; size = 4
_szTemp$196628 = -16436					; size = 44
_szReason$ = -16392					; size = 16384
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pExPtrs$ = 8						; size = 4
?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z PROC NEAR ; CrashHandlerExceptionFilter, COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 3c 40 00 00	 mov	 eax, 16444		; 0000403cH
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _pExPtrs$[ebp]
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	33 c5		 xor	 eax, ebp

; 139  : 	LONG lRet;
; 140  : 	if( InterlockedIncrement( &s_nRecrvCnt ) >= 3 )

  0001d	68 00 00 00 00	 push	 OFFSET FLAT:_s_nRecrvCnt
  00022	89 84 24 48 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16460], eax

; 194  : 		strcat( szReason, szPtr );

  00029	89 5c 24 14	 mov	 DWORD PTR $T196833[esp+16460], ebx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedIncrement@4
  00033	83 f8 03	 cmp	 eax, 3
  00036	7c 19		 jl	 SHORT $L196614

; 141  : 		return EXCEPTION_CONTINUE_SEARCH;

  00038	33 c0		 xor	 eax, eax

; 215  : 
; 216  : #ifdef 	__CLIENT
; 217  : 	{
; 218  : 		char szPacket[512] = {0, };	// 마지막 패킷을 로그에 추가함.
; 219  : 		sprintf( szPacket, "0x%02x:0x%02x-", g_hdr, g_Prev );
; 220  : 		strcat( szReason, szPacket );
; 221  : 
; 222  : 		sprintf( szPacket, "YS%d %d %d-", g_Error_State.m_dwWndId, g_Error_State.m_bIsShowWnd, (int)g_Error_State.m_ch );
; 223  : 		strcat( szReason, szPacket );
; 224  : 
; 225  : 		sprintf( szPacket, "last Model:%s", g_szLastFile );
; 226  : 		strcat( szReason, szPacket );
; 227  : 	}
; 228  : 
; 229  : 	if( g_DPlay.m_pDump != NULL && ( 8192 - lstrlen( szReason ) ) > ( g_DPlay.m_nDumpSize * 2 ) )
; 230  : 	{
; 231  : 		strcat( szReason, "\r\ndump\r\n" );
; 232  : 		char s[8];
; 233  : 		for( int i = 0; i < g_DPlay.m_nDumpSize; i++ )
; 234  : 		{
; 235  : 			sprintf( s, "%02x", g_DPlay.m_pDump[i] );
; 236  : 			lstrcat( szReason, s );
; 237  : 		}
; 238  : 	}
; 239  : #endif	// __CLIENT
; 240  : 	
; 241  : #if defined( __CLIENT ) // 클라이언트는 싱글스레드이므로 이코드가 가능할 듯 싶다.
; 242  : 	g_dpCertified.DeleteDPObject();
; 243  : 	g_DPlay.DeleteDPObject();
; 244  : 	g_dpLoginClient.DeleteDPObject();
; 245  : #endif	// defined( __CLIENT ) 
; 246  : 
; 247  : #ifdef __TRANSFER_ERROR_TEXT
; 248  : 	strcat( szReason, g_szCrashClient );
; 249  : 	SendErrorText( szReason );
; 250  : #endif	// __TRANSFER_ERROR_TEXT
; 251  : 	
; 252  : #ifdef __CLIENT
; 253  : 	if( g_hMutex )
; 254  : 		CloseHandle( g_hMutex );
; 255  : #endif	// __CLIENT
; 256  : 
; 257  : 	return lRet;
; 258  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b 8c 24 38 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16444]
  00044	33 cd		 xor	 ecx, ebp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$L196614:

; 142  : 
; 143  : 	// 디버깅 모드 일때에는 추가 정보를 보여주지 않고
; 144  : 	// EXCEPTION_CONTINUE_SEARCH  값을 리턴함으로써
; 145  : 	// 프로그래머가 디버깅 할 수 있도록 한다.
; 146  : #ifdef _DEBUG
; 147  : 	lRet = EXCEPTION_CONTINUE_SEARCH ;
; 148  : 	return lRet;
; 149  : #else
; 150  : 	lRet = EXCEPTION_EXECUTE_HANDLER;
; 151  : #endif
; 152  : 	
; 153  : 	// 왜 죽었는지 알아내도록 합니다.
; 154  : 	char szReason[ 1024*16 ] = {0, };

  00051	c6 44 24 40 00	 mov	 BYTE PTR _szReason$[esp+16456], 0
  00056	33 c0		 xor	 eax, eax
  00058	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  0005d	8d 7c 24 41	 lea	 edi, DWORD PTR _szReason$[esp+16457]
  00061	f3 ab		 rep stosd
  00063	66 ab		 stosw

; 155  : #ifdef __CLIENT
; 156  : 	sprintf( szReason, "%s rCnt=%d\r\n%s", g_szVersion, s_nRecrvCnt, GetFaultReason(pExPtrs) );
; 157  : #else
; 158  : 	sprintf( szReason, "rCnt=%d \r\n%s", s_nRecrvCnt, GetFaultReason(pExPtrs) );

  00065	53		 push	 ebx
  00066	aa		 stosb
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFaultReason@4
  0006d	50		 push	 eax
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_nRecrvCnt
  00073	50		 push	 eax
  00074	8d 4c 24 48	 lea	 ecx, DWORD PTR _szReason$[esp+16464]
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@CLNKCBPC@rCnt?$DN?$CFd?5?$AN?6?$CFs?$AA@
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _sprintf

; 159  : #endif
; 160  : 
; 161  : #ifdef __CRASH_0404
; 162  : 	CCrashStatus::GetInstance()->PrintStatus();		// cache server only
; 163  : #endif	// __CRASH_0404
; 164  : 
; 165  : #ifdef __WORLDSERVER
; 166  : 	#if !defined(__REMOVE_SCIRPT_060712)
; 167  : 		char szLatestDialog[512]	= { 0, };
; 168  : 		sprintf( szLatestDialog, "\n\nlatest dialog : %s\t%s\t%s\t%s\n", CScriptDialog::s_pszName, CScriptDialog::s_pszKey, CScriptDialog::s_pszBeforeRun, CScriptDialog::s_pszAfterRun );
; 169  : 		strcat( szReason, szLatestDialog );
; 170  : 	#endif
; 171  : #endif	// __WORLDSERVER
; 172  : 
; 173  : 	strcat( szReason, "\n\n - Registers\n\n" );

  00083	8d 7c 24 50	 lea	 edi, DWORD PTR _szReason$[esp+16472]
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	4f		 dec	 edi
  0008b	eb 03 8d 49 00	 npad	 5
$L196840:
  00090	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00093	47		 inc	 edi
  00094	84 c0		 test	 al, al
  00096	75 f8		 jne	 SHORT $L196840
  00098	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@
  0009e	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@+4
  000a3	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@+8
  000a9	89 17		 mov	 DWORD PTR [edi], edx
  000ab	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@+12
  000b1	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000b4	a0 10 00 00 00	 mov	 al, BYTE PTR ??_C@_0BB@OMLDONOD@?6?6?5?9?5Registers?6?6?$AA@+16
  000b9	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  000bc	89 57 0c	 mov	 DWORD PTR [edi+12], edx

; 174  : 	strcat( szReason, GetRegisterString(pExPtrs) );

  000bf	53		 push	 ebx
  000c0	88 47 10	 mov	 BYTE PTR [edi+16], al
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetRegisterString@4
  000c9	8b d0		 mov	 edx, eax
  000cb	eb 03 8d 49 00	 npad	 5
$L196841:
  000d0	8a 08		 mov	 cl, BYTE PTR [eax]
  000d2	40		 inc	 eax
  000d3	84 c9		 test	 cl, cl
  000d5	75 f9		 jne	 SHORT $L196841
  000d7	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  000db	2b c2		 sub	 eax, edx
  000dd	4f		 dec	 edi
  000de	8b ff		 npad	 2
$L196842:
  000e0	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000e3	47		 inc	 edi
  000e4	84 c9		 test	 cl, cl
  000e6	75 f8		 jne	 SHORT $L196842
  000e8	8b c8		 mov	 ecx, eax
  000ea	c1 e9 02	 shr	 ecx, 2
  000ed	8b f2		 mov	 esi, edx
  000ef	f3 a5		 rep movsd
  000f1	8b c8		 mov	 ecx, eax

; 175  : 	
; 176  : #ifdef __CLIENT
; 177  : 	DWORD	dwOp = GSTSO_MODULE | GSTSO_SYMBOL;
; 178  : #else
; 179  : 	DWORD	dwOp = GSTSO_PARAMS | GSTSO_MODULE | GSTSO_SYMBOL | GSTSO_SRCLINE;
; 180  : #endif
; 181  : 	
; 182  : 	LPCTSTR szPtr = GetFirstStackTraceString( dwOp, pExPtrs);

  000f3	53		 push	 ebx
  000f4	83 e1 03	 and	 ecx, 3
  000f7	6a 0f		 push	 15			; 0000000fH
  000f9	f3 a4		 rep movsb
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFirstStackTraceString@8

; 183  : 	strcat( szReason, "\n\n" );

  00101	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  00105	4f		 dec	 edi
$L196843:
  00106	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00109	47		 inc	 edi
  0010a	84 c9		 test	 cl, cl
  0010c	75 f8		 jne	 SHORT $L196843

; 184  : 	if( szPtr )

  0010e	85 c0		 test	 eax, eax
  00110	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_02PHMGELLB@?6?6?$AA@
  00117	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR ??_C@_02PHMGELLB@?6?6?$AA@+2
  0011d	66 89 0f	 mov	 WORD PTR [edi], cx
  00120	88 57 02	 mov	 BYTE PTR [edi+2], dl
  00123	74 2a		 je	 SHORT $L196621

; 185  : 		strcat( szReason, szPtr );

  00125	8b d0		 mov	 edx, eax
$L196844:
  00127	8a 08		 mov	 cl, BYTE PTR [eax]
  00129	40		 inc	 eax
  0012a	84 c9		 test	 cl, cl
  0012c	75 f9		 jne	 SHORT $L196844
  0012e	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  00132	2b c2		 sub	 eax, edx
  00134	4f		 dec	 edi
$L196845:
  00135	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00138	47		 inc	 edi
  00139	84 c9		 test	 cl, cl
  0013b	75 f8		 jne	 SHORT $L196845
  0013d	8b c8		 mov	 ecx, eax
  0013f	c1 e9 02	 shr	 ecx, 2
  00142	8b f2		 mov	 esi, edx
  00144	f3 a5		 rep movsd
  00146	8b c8		 mov	 ecx, eax
  00148	83 e1 03	 and	 ecx, 3
  0014b	f3 a4		 rep movsb

; 186  : 	else

  0014d	eb 28		 jmp	 SHORT $L196835
$L196621:

; 187  : 		strcat( szReason, "(null)" );

  0014f	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  00153	4f		 dec	 edi
$L196846:
  00154	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00157	47		 inc	 edi
  00158	84 c0		 test	 al, al
  0015a	75 f8		 jne	 SHORT $L196846
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
  00161	66 8b 0d 04 00
	00 00		 mov	 cx, WORD PTR ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@+4
  00168	8a 15 06 00 00
	00		 mov	 dl, BYTE PTR ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@+6
  0016e	89 07		 mov	 DWORD PTR [edi], eax
  00170	66 89 4f 04	 mov	 WORD PTR [edi+4], cx
  00174	88 57 06	 mov	 BYTE PTR [edi+6], dl
$L196835:

; 188  : 	while(1)
; 189  : 	{
; 190  : 		szPtr = GetNextStackTraceString( dwOp, pExPtrs);

  00177	53		 push	 ebx
  00178	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetNextStackTraceString@8
  0017e	6a 0f		 push	 15			; 0000000fH
  00180	ff d3		 call	 ebx

; 191  : 		if( szPtr == NULL )		

  00182	85 c0		 test	 eax, eax
  00184	74 4f		 je	 SHORT $L196837
$L196625:

; 192  : 			break;
; 193  : 		strcat( szReason, "\n" );

  00186	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  0018a	4f		 dec	 edi
  0018b	eb 03 8d 49 00	 npad	 5
$L196847:
  00190	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00193	47		 inc	 edi
  00194	84 c9		 test	 cl, cl
  00196	75 f8		 jne	 SHORT $L196847
  00198	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
  0019f	66 89 0f	 mov	 WORD PTR [edi], cx

; 194  : 		strcat( szReason, szPtr );

  001a2	8b f0		 mov	 esi, eax
$L196848:
  001a4	8a 08		 mov	 cl, BYTE PTR [eax]
  001a6	40		 inc	 eax
  001a7	84 c9		 test	 cl, cl
  001a9	75 f9		 jne	 SHORT $L196848
  001ab	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  001af	2b c6		 sub	 eax, esi
  001b1	4f		 dec	 edi
$L196849:
  001b2	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  001b5	47		 inc	 edi
  001b6	84 c9		 test	 cl, cl
  001b8	75 f8		 jne	 SHORT $L196849
  001ba	8b 54 24 10	 mov	 edx, DWORD PTR $T196833[esp+16456]
  001be	8b c8		 mov	 ecx, eax
  001c0	c1 e9 02	 shr	 ecx, 2
  001c3	f3 a5		 rep movsd
  001c5	8b c8		 mov	 ecx, eax
  001c7	52		 push	 edx
  001c8	83 e1 03	 and	 ecx, 3
  001cb	6a 0f		 push	 15			; 0000000fH
  001cd	f3 a4		 rep movsb
  001cf	ff d3		 call	 ebx
  001d1	85 c0		 test	 eax, eax
  001d3	75 b1		 jne	 SHORT $L196625
$L196837:

; 195  : 	}
; 196  : 	
; 197  : #ifdef __DBSERVER
; 198  : 	{
; 199  : 		char szTemp[MAX_PLAYER+2]	= { 0, };

  001d5	c6 44 24 14 00	 mov	 BYTE PTR _szTemp$196628[esp+16456], 0
  001da	33 c0		 xor	 eax, eax
  001dc	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  001e1	8d 7c 24 15	 lea	 edi, DWORD PTR _szTemp$196628[esp+16457]
  001e5	f3 ab		 rep stosd
  001e7	66 ab		 stosw
  001e9	aa		 stosb

; 200  : 
; 201  : 		sprintf( szTemp, "\r\n// %d", g_DbManager.m_nJoin );

  001ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_DbManager@@3AAVCDbManager@@A ; g_DbManager
  001ef	8b 88 1c 03 00
	00		 mov	 ecx, DWORD PTR [eax+796]
  001f5	51		 push	 ecx
  001f6	8d 54 24 18	 lea	 edx, DWORD PTR _szTemp$196628[esp+16460]
  001fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07IPOGOAKJ@?$AN?6?1?1?5?$CFd?$AA@
  001ff	52		 push	 edx
  00200	e8 00 00 00 00	 call	 _sprintf

; 202  : 		strcat( szReason, szTemp );

  00205	8d 44 24 20	 lea	 eax, DWORD PTR _szTemp$196628[esp+16468]
  00209	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020c	8b d0		 mov	 edx, eax
  0020e	8b ff		 npad	 2
$L196850:
  00210	8a 08		 mov	 cl, BYTE PTR [eax]
  00212	40		 inc	 eax
  00213	84 c9		 test	 cl, cl
  00215	75 f9		 jne	 SHORT $L196850
  00217	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  0021b	2b c2		 sub	 eax, edx
  0021d	4f		 dec	 edi
  0021e	8b ff		 npad	 2
$L196851:
  00220	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00223	47		 inc	 edi
  00224	84 c9		 test	 cl, cl
  00226	75 f8		 jne	 SHORT $L196851
  00228	8b c8		 mov	 ecx, eax
  0022a	c1 e9 02	 shr	 ecx, 2
  0022d	8b f2		 mov	 esi, edx
  0022f	f3 a5		 rep movsd
  00231	8b c8		 mov	 ecx, eax
  00233	83 e1 03	 and	 ecx, 3
  00236	f3 a4		 rep movsb
  00238	33 db		 xor	 ebx, ebx
  0023a	8d 9b 00 00 00
	00		 npad	 6
$L196631:

; 203  : 
; 204  : 		for( int i = 0; i < MAX_JOIN_SIZE; i++ )
; 205  : 		{
; 206  : 			sprintf( szTemp, "\r\n%s", g_DbManager.m_aszJoin[i] );

  00240	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_DbManager@@3AAVCDbManager@@A ; g_DbManager
  00245	8d 4c 03 7c	 lea	 ecx, DWORD PTR [ebx+eax+124]
  00249	51		 push	 ecx
  0024a	8d 54 24 18	 lea	 edx, DWORD PTR _szTemp$196628[esp+16460]
  0024e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JEGEICAJ@?$AN?6?$CFs?$AA@
  00253	52		 push	 edx
  00254	e8 00 00 00 00	 call	 _sprintf

; 207  : 			strcat( szReason, szTemp );

  00259	8d 44 24 20	 lea	 eax, DWORD PTR _szTemp$196628[esp+16468]
  0025d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00260	8b d0		 mov	 edx, eax
$L196852:
  00262	8a 08		 mov	 cl, BYTE PTR [eax]
  00264	40		 inc	 eax
  00265	84 c9		 test	 cl, cl
  00267	75 f9		 jne	 SHORT $L196852
  00269	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  0026d	2b c2		 sub	 eax, edx
  0026f	4f		 dec	 edi
$L196853:
  00270	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00273	47		 inc	 edi
  00274	84 c9		 test	 cl, cl
  00276	75 f8		 jne	 SHORT $L196853
  00278	8b c8		 mov	 ecx, eax
  0027a	c1 e9 02	 shr	 ecx, 2
  0027d	8b f2		 mov	 esi, edx
  0027f	f3 a5		 rep movsd
  00281	8b c8		 mov	 ecx, eax
  00283	83 e1 03	 and	 ecx, 3
  00286	83 c3 2a	 add	 ebx, 42			; 0000002aH
  00289	81 fb a0 02 00
	00		 cmp	 ebx, 672		; 000002a0H
  0028f	f3 a4		 rep movsb
  00291	7c ad		 jl	 SHORT $L196631

; 208  : 		}
; 209  : 	}
; 210  : #endif	// __DBSERVER
; 211  : 
; 212  : 	Error( "%s", szReason);

  00293	8d 44 24 40	 lea	 eax, DWORD PTR _szReason$[esp+16456]
  00297	50		 push	 eax
  00298	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  0029d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 213  : 	strcat( szReason, "\n" );

  002a2	8d 7c 24 48	 lea	 edi, DWORD PTR _szReason$[esp+16464]
  002a6	83 c4 08	 add	 esp, 8
  002a9	4f		 dec	 edi
  002aa	8d 9b 00 00 00
	00		 npad	 6
$L196854:
  002b0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002b3	47		 inc	 edi
  002b4	84 c0		 test	 al, al
  002b6	75 f8		 jne	 SHORT $L196854
  002b8	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 214  : 	strcat( szReason, g_szErrorAdd );

  002bf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_g_szErrorAdd
  002c4	66 89 0f	 mov	 WORD PTR [edi], cx
  002c7	8b d0		 mov	 edx, eax
  002c9	8d a4 24 00 00
	00 00		 npad	 7
$L196855:
  002d0	8a 08		 mov	 cl, BYTE PTR [eax]
  002d2	40		 inc	 eax
  002d3	84 c9		 test	 cl, cl
  002d5	75 f9		 jne	 SHORT $L196855
  002d7	8d 7c 24 40	 lea	 edi, DWORD PTR _szReason$[esp+16456]
  002db	2b c2		 sub	 eax, edx
  002dd	4f		 dec	 edi
  002de	8b ff		 npad	 2
$L196856:
  002e0	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  002e3	47		 inc	 edi
  002e4	84 c9		 test	 cl, cl
  002e6	75 f8		 jne	 SHORT $L196856
  002e8	8b c8		 mov	 ecx, eax
  002ea	c1 e9 02	 shr	 ecx, 2
  002ed	8b f2		 mov	 esi, edx
  002ef	f3 a5		 rep movsd
  002f1	8b c8		 mov	 ecx, eax
  002f3	83 e1 03	 and	 ecx, 3
  002f6	f3 a4		 rep movsb

; 215  : 
; 216  : #ifdef 	__CLIENT
; 217  : 	{
; 218  : 		char szPacket[512] = {0, };	// 마지막 패킷을 로그에 추가함.
; 219  : 		sprintf( szPacket, "0x%02x:0x%02x-", g_hdr, g_Prev );
; 220  : 		strcat( szReason, szPacket );
; 221  : 
; 222  : 		sprintf( szPacket, "YS%d %d %d-", g_Error_State.m_dwWndId, g_Error_State.m_bIsShowWnd, (int)g_Error_State.m_ch );
; 223  : 		strcat( szReason, szPacket );
; 224  : 
; 225  : 		sprintf( szPacket, "last Model:%s", g_szLastFile );
; 226  : 		strcat( szReason, szPacket );
; 227  : 	}
; 228  : 
; 229  : 	if( g_DPlay.m_pDump != NULL && ( 8192 - lstrlen( szReason ) ) > ( g_DPlay.m_nDumpSize * 2 ) )
; 230  : 	{
; 231  : 		strcat( szReason, "\r\ndump\r\n" );
; 232  : 		char s[8];
; 233  : 		for( int i = 0; i < g_DPlay.m_nDumpSize; i++ )
; 234  : 		{
; 235  : 			sprintf( s, "%02x", g_DPlay.m_pDump[i] );
; 236  : 			lstrcat( szReason, s );
; 237  : 		}
; 238  : 	}
; 239  : #endif	// __CLIENT
; 240  : 	
; 241  : #if defined( __CLIENT ) // 클라이언트는 싱글스레드이므로 이코드가 가능할 듯 싶다.
; 242  : 	g_dpCertified.DeleteDPObject();
; 243  : 	g_DPlay.DeleteDPObject();
; 244  : 	g_dpLoginClient.DeleteDPObject();
; 245  : #endif	// defined( __CLIENT ) 
; 246  : 
; 247  : #ifdef __TRANSFER_ERROR_TEXT
; 248  : 	strcat( szReason, g_szCrashClient );
; 249  : 	SendErrorText( szReason );
; 250  : #endif	// __TRANSFER_ERROR_TEXT
; 251  : 	
; 252  : #ifdef __CLIENT
; 253  : 	if( g_hMutex )
; 254  : 		CloseHandle( g_hMutex );
; 255  : #endif	// __CLIENT
; 256  : 
; 257  : 	return lRet;
; 258  : }

  002f8	8b 8c 24 44 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16456]
  002ff	5f		 pop	 edi
  00300	5e		 pop	 esi
  00301	33 cd		 xor	 ecx, ebp
  00303	b8 01 00 00 00	 mov	 eax, 1
  00308	5b		 pop	 ebx
  00309	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030e	8b e5		 mov	 esp, ebp
  00310	5d		 pop	 ebp
  00311	c2 04 00	 ret	 4
?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ENDP ; CrashHandlerExceptionFilter
_TEXT	ENDS
PUBLIC	?InitEH@@YAXXZ					; InitEH
EXTRN	__imp__SetUnhandledExceptionFilter@4:NEAR
EXTRN	__imp__SetErrorMode@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?InitEH@@YAXXZ
_TEXT	SEGMENT
?InitEH@@YAXXZ PROC NEAR				; InitEH, COMDAT

; 41   : {

  00000	56		 push	 esi

; 42   : 	SetErrorMode(SetErrorMode(0) |
; 43   : 		SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetErrorMode@4
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	ff d6		 call	 esi
  0000c	0d 01 80 00 00	 or	 eax, 32769		; 00008001H
  00011	50		 push	 eax
  00012	ff d6		 call	 esi

; 44   : 	
; 45   : 	SetUnhandledExceptionFilter(CrashHandlerExceptionFilter);

  00014	68 00 00 00 00	 push	 OFFSET FLAT:?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; CrashHandlerExceptionFilter
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetUnhandledExceptionFilter@4

; 46   : 	memset( g_szErrorAdd, 0, sizeof(g_szErrorAdd) );

  0001f	33 c0		 xor	 eax, eax
  00021	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH
  00026	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_g_szErrorAdd
  0002b	f3 ab		 rep stosd
  0002d	66 ab		 stosw
  0002f	aa		 stosb
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 47   : }

  00032	c3		 ret	 0
?InitEH@@YAXXZ ENDP					; InitEH
_TEXT	ENDS
END
