; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Interface\UserTaskBar.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CE@CCMODOGC@CUserTaskBar?3?3SetShortcut?5nWhere@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CUserTaskBar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCUserTaskBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUserTaskBar@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTaskBar@CUserTaskBar@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTaskBarShorcutKind@CUserTaskBar@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CUserTaskBar@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetShortcut@CUserTaskBar@@QAEXHKKKKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CUserTaskBar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??1CUserTaskBar@@UAE@XZ				; CUserTaskBar::~CUserTaskBar
PUBLIC	??_7CUserTaskBar@@6B@				; CUserTaskBar::`vftable'
PUBLIC	??_GCUserTaskBar@@UAEPAXI@Z			; CUserTaskBar::`scalar deleting destructor'
EXTRN	??_ECUserTaskBar@@UAEPAXI@Z:NEAR		; CUserTaskBar::`vector deleting destructor'
;	COMDAT ??_7CUserTaskBar@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_interface\usertaskbar.cpp
CONST	SEGMENT
??_7CUserTaskBar@@6B@ DD FLAT:??_ECUserTaskBar@@UAEPAXI@Z ; CUserTaskBar::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1CUserTaskBar@@UAE@XZ
_TEXT	SEGMENT
??1CUserTaskBar@@UAE@XZ PROC NEAR			; CUserTaskBar::~CUserTaskBar, COMDAT
; _this$ = ecx

; 21   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CUserTaskBar@@6B@

; 22   : 
; 23   : }

  00006	c3		 ret	 0
??1CUserTaskBar@@UAE@XZ ENDP				; CUserTaskBar::~CUserTaskBar
_TEXT	ENDS
PUBLIC	?InitTaskBar@CUserTaskBar@@QAEXXZ		; CUserTaskBar::InitTaskBar
; Function compile flags: /Ogty
;	COMDAT ?InitTaskBar@CUserTaskBar@@QAEXXZ
_TEXT	SEGMENT
?InitTaskBar@CUserTaskBar@@QAEXXZ PROC NEAR		; CUserTaskBar::InitTaskBar, COMDAT
; _this$ = ecx

; 26   : {

  00000	8b d1		 mov	 edx, ecx
  00002	57		 push	 edi

; 27   : 	memset( m_aSlotApplet, 0, sizeof( m_aSlotApplet ) );

  00003	33 c0		 xor	 eax, eax
  00005	b9 ac 02 00 00	 mov	 ecx, 684		; 000002acH
  0000a	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  0000d	f3 ab		 rep stosd

; 28   : 	memset( m_aSlotItem  , 0, sizeof( m_aSlotItem ) );

  0000f	b9 e0 0b 00 00	 mov	 ecx, 3040		; 00000be0H
  00014	8d ba b4 0a 00
	00		 lea	 edi, DWORD PTR [edx+2740]
  0001a	f3 ab		 rep stosd

; 29   : 	memset( m_aSlotQueue , 0, sizeof( m_aSlotQueue ) );

  0001c	b9 e4 00 00 00	 mov	 ecx, 228		; 000000e4H
  00021	8d ba 34 3a 00
	00		 lea	 edi, DWORD PTR [edx+14900]
  00027	f3 ab		 rep stosd

; 30   : 	m_nActionPoint = 0;

  00029	89 82 c4 3d 00
	00		 mov	 DWORD PTR [edx+15812], eax

; 31   : 	m_nUsedSkillQueue = -1;

  0002f	c7 82 c8 3d 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+15816], -1
  00039	5f		 pop	 edi

; 32   : }

  0003a	c3		 ret	 0
?InitTaskBar@CUserTaskBar@@QAEXXZ ENDP			; CUserTaskBar::InitTaskBar
_TEXT	ENDS
PUBLIC	?InitTaskBarShorcutKind@CUserTaskBar@@QAEXK@Z	; CUserTaskBar::InitTaskBarShorcutKind
; Function compile flags: /Ogty
;	COMDAT ?InitTaskBarShorcutKind@CUserTaskBar@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwShortcutKind$ = 8					; size = 4
?InitTaskBarShorcutKind@CUserTaskBar@@QAEXK@Z PROC NEAR	; CUserTaskBar::InitTaskBarShorcutKind, COMDAT
; _this$ = ecx

; 35   : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 36   : 	for( int i = 0; i < MAX_SLOT_APPLET; i++ )

  00003	8b 6c 24 10	 mov	 ebp, DWORD PTR _dwShortcutKind$[esp+8]
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	89 5c 24 10	 mov	 DWORD PTR _this$[esp+20], ebx
  0000f	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  00012	be 12 00 00 00	 mov	 esi, 18			; 00000012H
$L186716:

; 37   : 	{
; 38   : 		if( m_aSlotApplet[i].m_dwShortcut == dwShortcutKind )		// 값이 들어있는지 검사

  00017	39 2a		 cmp	 DWORD PTR [edx], ebp
  00019	75 0b		 jne	 SHORT $L186717

; 39   : 			memset( &m_aSlotApplet[i], 0, sizeof( SHORTCUT ) );

  0001b	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
  00020	33 c0		 xor	 eax, eax
  00022	8b fa		 mov	 edi, edx
  00024	f3 ab		 rep stosd
$L186717:
  00026	81 c2 98 00 00
	00		 add	 edx, 152		; 00000098H
  0002c	4e		 dec	 esi
  0002d	75 e8		 jne	 SHORT $L186716

; 40   : 	}
; 41   : 
; 42   : 	for( i = 0; i < MAX_SLOT_ITEM_COUNT; i++ )

  0002f	8d 93 b4 0a 00
	00		 lea	 edx, DWORD PTR [ebx+2740]
  00035	bb 08 00 00 00	 mov	 ebx, 8
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L186721:

; 43   : 	{
; 44   : 		for( int j = 0; j < MAX_SLOT_ITEM; j++ )

  00040	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
$L186725:

; 45   : 		{
; 46   : 			if( m_aSlotItem[i][j].m_dwShortcut == dwShortcutKind )		// 값이 들어있는지 검사

  00045	39 2a		 cmp	 DWORD PTR [edx], ebp
  00047	75 0b		 jne	 SHORT $L186726

; 47   : 			{
; 48   : 				memset( &m_aSlotItem[i][j], 0, sizeof( SHORTCUT ) );

  00049	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
  0004e	33 c0		 xor	 eax, eax
  00050	8b fa		 mov	 edi, edx
  00052	f3 ab		 rep stosd
$L186726:
  00054	81 c2 98 00 00
	00		 add	 edx, 152		; 00000098H
  0005a	4e		 dec	 esi
  0005b	75 e8		 jne	 SHORT $L186725

; 40   : 	}
; 41   : 
; 42   : 	for( i = 0; i < MAX_SLOT_ITEM_COUNT; i++ )

  0005d	4b		 dec	 ebx
  0005e	75 e0		 jne	 SHORT $L186721

; 49   : 			}
; 50   : 		}
; 51   : 	}
; 52   : 	for( i = 0; i < MAX_SLOT_QUEUE; i++ )

  00060	8b 54 24 10	 mov	 edx, DWORD PTR _this$[esp+20]
  00064	81 c2 34 3a 00
	00		 add	 edx, 14900		; 00003a34H
  0006a	be 06 00 00 00	 mov	 esi, 6
  0006f	90		 npad	 1
$L186730:

; 53   : 	{
; 54   : 		if( m_aSlotQueue[i].m_dwShortcut == dwShortcutKind )		// 값이 들어있는지 검사

  00070	39 2a		 cmp	 DWORD PTR [edx], ebp
  00072	75 0b		 jne	 SHORT $L186731

; 55   : 		{
; 56   : 			memset( &m_aSlotQueue[i], 0, sizeof( SHORTCUT ) );

  00074	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
  00079	33 c0		 xor	 eax, eax
  0007b	8b fa		 mov	 edi, edx
  0007d	f3 ab		 rep stosd
$L186731:
  0007f	81 c2 98 00 00
	00		 add	 edx, 152		; 00000098H
  00085	4e		 dec	 esi
  00086	75 e8		 jne	 SHORT $L186730
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5d		 pop	 ebp
  0008b	5b		 pop	 ebx

; 57   : 		}
; 58   : 	}
; 59   : }

  0008c	59		 pop	 ecx
  0008d	c2 04 00	 ret	 4
?InitTaskBarShorcutKind@CUserTaskBar@@QAEXK@Z ENDP	; CUserTaskBar::InitTaskBarShorcutKind
_TEXT	ENDS
PUBLIC	??_C@_0CE@CCMODOGC@CUserTaskBar?3?3SetShortcut?5nWhere@ ; `string'
PUBLIC	?SetShortcut@CUserTaskBar@@QAEXHKKKKKH@Z	; CUserTaskBar::SetShortcut
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0CE@CCMODOGC@CUserTaskBar?3?3SetShortcut?5nWhere@
CONST	SEGMENT
??_C@_0CE@CCMODOGC@CUserTaskBar?3?3SetShortcut?5nWhere@ DB 'CUserTaskBar:'
	DB	':SetShortcut nWhere:%d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetShortcut@CUserTaskBar@@QAEXHKKKKKH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_dwShortcut$ = 12					; size = 4
_dwType$ = 16						; size = 4
_dwIndex$ = 20						; size = 4
_dwId$ = 24						; size = 4
_dwData$ = 28						; size = 4
_nWhere$ = 32						; size = 4
?SetShortcut@CUserTaskBar@@QAEXHKKKKKH@Z PROC NEAR	; CUserTaskBar::SetShortcut, COMDAT
; _this$ = ecx

; 173  : 	LPSHORTCUT pShortcut;
; 174  : 	if( nWhere == 0 )

  00000	8b 54 24 1c	 mov	 edx, DWORD PTR _nWhere$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	75 10		 jne	 SHORT $L186793

; 175  : 		pShortcut = &m_aSlotApplet[ nIndex ];

  00008	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  0000c	69 c0 98 00 00
	00		 imul	 eax, 152		; 00000098H
  00012	8d 44 08 04	 lea	 eax, DWORD PTR [eax+ecx+4]

; 176  : 	else if( nWhere == 1 )

  00016	eb 16		 jmp	 SHORT $L186796
$L186793:
  00018	83 fa 01	 cmp	 edx, 1
  0001b	75 39		 jne	 SHORT $L186795

; 177  : 		pShortcut = &m_aSlotItem[0][ nIndex ];

  0001d	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00021	69 c0 98 00 00
	00		 imul	 eax, 152		; 00000098H
  00027	8d 84 08 b4 0a
	00 00		 lea	 eax, DWORD PTR [eax+ecx+2740]
$L186796:

; 181  : 		return;
; 182  : 	}
; 183  : 
; 184  : //	LPSHORTCUT pShortcut	= &m_aSlotApplet[ nIndex ];
; 185  : 	pShortcut->m_dwShortcut		= dwShortcut   ;

  0002e	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwShortcut$[esp-4]
  00032	89 08		 mov	 DWORD PTR [eax], ecx

; 186  : 	pShortcut->m_dwType     = dwType;

  00034	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwType$[esp-4]
  00038	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 187  : 	pShortcut->m_dwIndex    = dwIndex;

  0003b	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwIndex$[esp-4]
  0003f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 188  : 	pShortcut->m_dwId       = dwId;

  00042	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwId$[esp-4]
  00046	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 189  : 	pShortcut->m_dwUserId   = 0 ;

  00049	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 190  : 	pShortcut->m_dwData     = nWhere;

  00050	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 191  : }

  00053	c2 1c 00	 ret	 28			; 0000001cH
$L186795:

; 178  : 	else
; 179  : 	{
; 180  : 		Error( "CUserTaskBar::SetShortcut nWhere:%d", nWhere ); 

  00056	52		 push	 edx
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@CCMODOGC@CUserTaskBar?3?3SetShortcut?5nWhere@
  0005c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00061	83 c4 08	 add	 esp, 8

; 191  : }

  00064	c2 1c 00	 ret	 28			; 0000001cH
?SetShortcut@CUserTaskBar@@QAEXHKKKKKH@Z ENDP		; CUserTaskBar::SetShortcut
_TEXT	ENDS
PUBLIC	?IsStoring@CAr@@QBEHXZ				; CAr::IsStoring
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT
?IsStoring@CAr@@QBEHXZ PROC NEAR			; CAr::IsStoring, COMDAT
; _this$ = ecx

; 96   : 	{ return (m_nMode & CAr::load) == 0; }

  00000	33 c0		 xor	 eax, eax
  00002	8a 01		 mov	 al, BYTE PTR [ecx]
  00004	f7 d0		 not	 eax
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsStoring@CAr@@QBEHXZ ENDP				; CAr::IsStoring
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@J@Z				; CAr::operator<<
EXTRN	?CheckBuf@CAr@@QAEXI@Z:NEAR			; CAr::CheckBuf
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??6CAr@@QAEAAV0@J@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 113  : 	{ CheckBuf( sizeof(LONG) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 114  : 		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _l$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@J@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@K@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??6CAr@@QAEAAV0@K@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 116  : 	{ CheckBuf( sizeof(DWORD) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 117  : 		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@K@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAK@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??5CAr@@QAEAAV0@AAK@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 146  : 	{	CAR_SAFE_READ( DWORD, dw );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L162868
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _dw$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L162868:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _dw$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAK@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAJ@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??5CAr@@QAEAAV0@AAJ@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 152  : 	{	CAR_SAFE_READ( LONG, l );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L162898
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _l$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L162898:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _l$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAJ@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	?GetOffset@CAr@@QAEKXZ				; CAr::GetOffset
; Function compile flags: /Ogty
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT
?GetOffset@CAr@@QAEKXZ PROC NEAR			; CAr::GetOffset, COMDAT
; _this$ = ecx

; 190  : 	ASSERT( IsStoring() );
; 191  : 	return( m_lpBufCur - m_lpBufStart );

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]

; 192  : }

  00006	c3		 ret	 0
?GetOffset@CAr@@QAEKXZ ENDP				; CAr::GetOffset
_TEXT	ENDS
PUBLIC	??0CUserTaskBar@@QAE@XZ				; CUserTaskBar::CUserTaskBar
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_interface\usertaskbar.cpp
;	COMDAT ??0CUserTaskBar@@QAE@XZ
_TEXT	SEGMENT
??0CUserTaskBar@@QAE@XZ PROC NEAR			; CUserTaskBar::CUserTaskBar, COMDAT
; _this$ = ecx

; 16   : {

  00000	8b d1		 mov	 edx, ecx
  00002	57		 push	 edi

; 17   : 	InitTaskBar();

  00003	33 c0		 xor	 eax, eax
  00005	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:??_7CUserTaskBar@@6B@
  0000b	b9 ac 02 00 00	 mov	 ecx, 684		; 000002acH
  00010	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00013	f3 ab		 rep stosd
  00015	b9 e0 0b 00 00	 mov	 ecx, 3040		; 00000be0H
  0001a	8d ba b4 0a 00
	00		 lea	 edi, DWORD PTR [edx+2740]
  00020	f3 ab		 rep stosd
  00022	b9 e4 00 00 00	 mov	 ecx, 228		; 000000e4H
  00027	8d ba 34 3a 00
	00		 lea	 edi, DWORD PTR [edx+14900]
  0002d	f3 ab		 rep stosd
  0002f	89 82 c4 3d 00
	00		 mov	 DWORD PTR [edx+15812], eax
  00035	c7 82 c8 3d 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+15816], -1

; 18   : }

  0003f	8b c2		 mov	 eax, edx
  00041	5f		 pop	 edi
  00042	c3		 ret	 0
??0CUserTaskBar@@QAE@XZ ENDP				; CUserTaskBar::CUserTaskBar
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCUserTaskBar@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCUserTaskBar@@UAEPAXI@Z PROC NEAR			; CUserTaskBar::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CUserTaskBar@@6B@
  0000e	74 09		 je	 SHORT $L186987
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$L186987:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_GCUserTaskBar@@UAEPAXI@Z ENDP			; CUserTaskBar::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@H@Z				; CAr::operator<<
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??6CAr@@QAEAAV0@H@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 99   : 	{ return CAr::operator<<((LONG)i); }

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _i$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@H@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAH@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??5CAr@@QAEAAV0@AAH@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 126  : 	{ return CAr::operator>>((LONG&)i); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L186997
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _i$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L186997:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _i$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAH@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	?Serialize@CUserTaskBar@@QAEXAAVCAr@@@Z		; CUserTaskBar::Serialize
EXTRN	?WriteString@CAr@@QAEXPBD@Z:NEAR		; CAr::WriteString
EXTRN	?ReadString@CAr@@QAEPADPADH@Z:NEAR		; CAr::ReadString
EXTRN	?GetBuffer@CAr@@QAEPAEPAH@Z:NEAR		; CAr::GetBuffer
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_interface\usertaskbar.cpp
;	COMDAT ?Serialize@CUserTaskBar@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_i$186742 = -16						; size = 4
_uOffset$186741 = -12					; size = 4
$T187141 = -8						; size = 4
$T187137 = -8						; size = 4
$T187133 = -8						; size = 4
$T187129 = -8						; size = 4
$T187125 = -8						; size = 4
$T187121 = -8						; size = 4
_j$186754 = -8						; size = 4
_nBufSize$186748 = -4					; size = 4
tv284 = 8						; size = 4
_nCount$186740 = 8					; size = 4
_ar$ = 8						; size = 4
?Serialize@CUserTaskBar@@QAEXAAVCAr@@@Z PROC NEAR	; CUserTaskBar::Serialize, COMDAT
; _this$ = ecx

; 62   : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 63   : 	if( ar.IsStoring() )

  00006	8b 74 24 24	 mov	 esi, DWORD PTR _ar$[esp+28]
  0000a	33 c0		 xor	 eax, eax
  0000c	8a 06		 mov	 al, BYTE PTR [esi]
  0000e	8b e9		 mov	 ebp, ecx
  00010	57		 push	 edi
  00011	89 6c 24 10	 mov	 DWORD PTR _this$[esp+36], ebp
  00015	f7 d0		 not	 eax
  00017	a8 01		 test	 al, 1
  00019	0f 84 94 03 00
	00		 je	 $L186739

; 64   : 	{
; 65   : 		int nCount	= 0;
; 66   : 		u_long uOffset	= ar.GetOffset();

  0001f	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00022	2b 6e 10	 sub	 ebp, DWORD PTR [esi+16]

; 67   : 		ar << nCount;

  00025	bb 04 00 00 00	 mov	 ebx, 4
  0002a	33 ff		 xor	 edi, edi
  0002c	53		 push	 ebx
  0002d	8b ce		 mov	 ecx, esi
  0002f	89 7c 24 2c	 mov	 DWORD PTR _nCount$186740[esp+36], edi
  00033	89 6c 24 1c	 mov	 DWORD PTR _uOffset$186741[esp+40], ebp
  00037	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003f	89 39		 mov	 DWORD PTR [ecx], edi
  00041	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 68   : 		for( int i = 0; i < MAX_SLOT_APPLET; i++ )

  00044	89 7c 24 14	 mov	 DWORD PTR _i$186742[esp+36], edi
  00048	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+36]
  0004c	03 c3		 add	 eax, ebx
  0004e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00051	83 c7 0c	 add	 edi, 12			; 0000000cH
$L186743:

; 69   : 		{
; 70   : 			if( m_aSlotApplet[i].m_dwShortcut != SHORTCUT_NONE )		// 값이 들어있는지 검사

  00054	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  00057	85 c0		 test	 eax, eax
  00059	0f 84 a3 00 00
	00		 je	 $L186744

; 71   : 			{
; 72   : 				ar << i;

  0005f	53		 push	 ebx
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00067	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006a	8b 44 24 14	 mov	 eax, DWORD PTR _i$186742[esp+36]
  0006e	89 02		 mov	 DWORD PTR [edx], eax
  00070	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 73   : 				ar << m_aSlotApplet[i].m_dwShortcut <<	m_aSlotApplet[i].m_dwId << m_aSlotApplet[i].m_dwType;

  00073	8b 6f f8	 mov	 ebp, DWORD PTR [edi-8]
  00076	53		 push	 ebx
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00081	89 29		 mov	 DWORD PTR [ecx], ebp
  00083	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00086	8b 6f fc	 mov	 ebp, DWORD PTR [edi-4]
  00089	53		 push	 ebx
  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00091	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00094	89 2a		 mov	 DWORD PTR [edx], ebp
  00096	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00099	8b 2f		 mov	 ebp, DWORD PTR [edi]
  0009b	53		 push	 ebx
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a6	89 28		 mov	 DWORD PTR [eax], ebp
  000a8	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 74   : 				ar << m_aSlotApplet[i].m_dwIndex <<	m_aSlotApplet[i].m_dwUserId << m_aSlotApplet[i].m_dwData;

  000ab	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  000ae	53		 push	 ebx
  000af	8b ce		 mov	 ecx, esi
  000b1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b9	89 29		 mov	 DWORD PTR [ecx], ebp
  000bb	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  000be	8b 6f 08	 mov	 ebp, DWORD PTR [edi+8]
  000c1	53		 push	 ebx
  000c2	8b ce		 mov	 ecx, esi
  000c4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c9	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000cc	89 2a		 mov	 DWORD PTR [edx], ebp
  000ce	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  000d1	8b 6f 0c	 mov	 ebp, DWORD PTR [edi+12]
  000d4	53		 push	 ebx
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000dc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000df	89 28		 mov	 DWORD PTR [eax], ebp
  000e1	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 75   : 				if( m_aSlotApplet[i].m_dwShortcut == SHORTCUT_CHAT)

  000e4	83 7f f8 08	 cmp	 DWORD PTR [edi-8], 8
  000e8	75 0b		 jne	 SHORT $L186747

; 76   : 					ar.WriteString( m_aSlotApplet[i].m_szString );

  000ea	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  000ed	51		 push	 ecx
  000ee	8b ce		 mov	 ecx, esi
  000f0	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
$L186747:

; 77   : 				nCount++;

  000f5	8b 44 24 28	 mov	 eax, DWORD PTR _nCount$186740[esp+32]
  000f9	8b 6c 24 18	 mov	 ebp, DWORD PTR _uOffset$186741[esp+36]
  000fd	40		 inc	 eax
  000fe	89 44 24 28	 mov	 DWORD PTR _nCount$186740[esp+32], eax
$L186744:
  00102	8b 44 24 14	 mov	 eax, DWORD PTR _i$186742[esp+36]
  00106	40		 inc	 eax
  00107	81 c7 98 00 00
	00		 add	 edi, 152		; 00000098H
  0010d	83 f8 12	 cmp	 eax, 18			; 00000012H
  00110	89 44 24 14	 mov	 DWORD PTR _i$186742[esp+36], eax
  00114	0f 8c 3a ff ff
	ff		 jl	 $L186743

; 78   : 			}
; 79   : 		}
; 80   : 		int nBufSize;
; 81   : 		LPBYTE lpBuf	= ar.GetBuffer( &nBufSize );

  0011a	8d 54 24 20	 lea	 edx, DWORD PTR _nBufSize$186748[esp+36]
  0011e	52		 push	 edx
  0011f	8b ce		 mov	 ecx, esi
  00121	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 82   : 		*(UNALIGNED int*)( lpBuf + uOffset )	= nCount;

  00126	8b 4c 24 28	 mov	 ecx, DWORD PTR _nCount$186740[esp+32]
  0012a	89 0c 28	 mov	 DWORD PTR [eax+ebp], ecx

; 83   : 
; 84   : 		nCount	= 0;
; 85   : 		uOffset	= ar.GetOffset();

  0012d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00130	2b 46 10	 sub	 eax, DWORD PTR [esi+16]
  00133	33 ff		 xor	 edi, edi

; 86   : 		ar << nCount;

  00135	53		 push	 ebx
  00136	8b ce		 mov	 ecx, esi
  00138	89 7c 24 2c	 mov	 DWORD PTR _nCount$186740[esp+36], edi
  0013c	89 44 24 1c	 mov	 DWORD PTR _uOffset$186741[esp+40], eax
  00140	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00145	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00148	89 3a		 mov	 DWORD PTR [edx], edi
  0014a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 87   : 		for( i = 0; i < MAX_SLOT_ITEM_COUNT; i++ )

  0014d	89 7c 24 14	 mov	 DWORD PTR _i$186742[esp+36], edi
  00151	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+36]
  00155	03 c3		 add	 eax, ebx
  00157	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0015a	81 c7 bc 0a 00
	00		 add	 edi, 2748		; 00000abcH
$L186751:

; 88   : 		{
; 89   : 			for( int j = 0; j < MAX_SLOT_ITEM; j++ )

  00160	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _j$186754[esp+36], 0
  00168	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L187374:

; 90   : 			{
; 91   : 				if( m_aSlotItem[i][j].m_dwShortcut != SHORTCUT_NONE )		// 값이 들어있는지 검사

  00170	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  00173	85 c0		 test	 eax, eax
  00175	0f 84 b3 00 00
	00		 je	 $L186756

; 92   : 				{
; 93   : 					ar << i << j;

  0017b	53		 push	 ebx
  0017c	8b ce		 mov	 ecx, esi
  0017e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00183	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00186	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$186742[esp+36]
  0018a	89 08		 mov	 DWORD PTR [eax], ecx
  0018c	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0018f	03 eb		 add	 ebp, ebx
  00191	53		 push	 ebx
  00192	8b ce		 mov	 ecx, esi
  00194	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00197	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0019c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0019f	8b 44 24 1c	 mov	 eax, DWORD PTR _j$186754[esp+36]
  001a3	89 02		 mov	 DWORD PTR [edx], eax
  001a5	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 94   : 					ar << m_aSlotItem[i][j].m_dwShortcut <<	m_aSlotItem[i][j].m_dwId << m_aSlotItem[i][j].m_dwType;

  001a8	8b 6f f8	 mov	 ebp, DWORD PTR [edi-8]
  001ab	53		 push	 ebx
  001ac	8b ce		 mov	 ecx, esi
  001ae	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001b3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001b6	89 29		 mov	 DWORD PTR [ecx], ebp
  001b8	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  001bb	8b 6f fc	 mov	 ebp, DWORD PTR [edi-4]
  001be	53		 push	 ebx
  001bf	8b ce		 mov	 ecx, esi
  001c1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001c6	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001c9	89 2a		 mov	 DWORD PTR [edx], ebp
  001cb	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  001ce	8b 2f		 mov	 ebp, DWORD PTR [edi]
  001d0	53		 push	 ebx
  001d1	8b ce		 mov	 ecx, esi
  001d3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001d8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001db	89 28		 mov	 DWORD PTR [eax], ebp
  001dd	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 95   : 					ar << m_aSlotItem[i][j].m_dwIndex << m_aSlotItem[i][j].m_dwUserId << m_aSlotItem[i][j].m_dwData;

  001e0	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  001e3	53		 push	 ebx
  001e4	8b ce		 mov	 ecx, esi
  001e6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001eb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001ee	89 29		 mov	 DWORD PTR [ecx], ebp
  001f0	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  001f3	8b 6f 08	 mov	 ebp, DWORD PTR [edi+8]
  001f6	53		 push	 ebx
  001f7	8b ce		 mov	 ecx, esi
  001f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001fe	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00201	89 2a		 mov	 DWORD PTR [edx], ebp
  00203	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00206	8b 6f 0c	 mov	 ebp, DWORD PTR [edi+12]
  00209	53		 push	 ebx
  0020a	8b ce		 mov	 ecx, esi
  0020c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00211	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00214	89 28		 mov	 DWORD PTR [eax], ebp
  00216	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 96   : 					if( m_aSlotItem[i][j].m_dwShortcut == SHORTCUT_CHAT)

  00219	83 7f f8 08	 cmp	 DWORD PTR [edi-8], 8
  0021d	75 0b		 jne	 SHORT $L186759

; 97   : 						ar.WriteString( m_aSlotItem[i][j].m_szString );

  0021f	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00222	51		 push	 ecx
  00223	8b ce		 mov	 ecx, esi
  00225	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString
$L186759:

; 98   : 					nCount++;

  0022a	ff 44 24 28	 inc	 DWORD PTR _nCount$186740[esp+32]
$L186756:
  0022e	8b 44 24 1c	 mov	 eax, DWORD PTR _j$186754[esp+36]
  00232	40		 inc	 eax
  00233	81 c7 98 00 00
	00		 add	 edi, 152		; 00000098H
  00239	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0023c	89 44 24 1c	 mov	 DWORD PTR _j$186754[esp+36], eax
  00240	0f 8c 2a ff ff
	ff		 jl	 $L187374
  00246	8b 44 24 14	 mov	 eax, DWORD PTR _i$186742[esp+36]
  0024a	40		 inc	 eax
  0024b	83 f8 08	 cmp	 eax, 8
  0024e	89 44 24 14	 mov	 DWORD PTR _i$186742[esp+36], eax
  00252	0f 8c 08 ff ff
	ff		 jl	 $L186751

; 99   : 					
; 100  : 				}
; 101  : 
; 102  : 				// m_aSlotItem[i][j]이 유효한 숏컷이라면
; 103  : //				ar << i << j << m_aSlotItem[i][j]의 필요한 정보 저장
; 104  : //				if( m_aSlotItem[i][j].m_dwType == SHORTCUT_CHAT )
; 105  : //					ar.WriteString(
; 106  : 			}
; 107  : 		}
; 108  : 		lpBuf	= ar.GetBuffer( &nBufSize );

  00258	8d 54 24 20	 lea	 edx, DWORD PTR _nBufSize$186748[esp+36]
  0025c	52		 push	 edx
  0025d	8b ce		 mov	 ecx, esi
  0025f	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 109  : 		*(UNALIGNED int*)( lpBuf + uOffset )	= nCount;

  00264	8b 4c 24 28	 mov	 ecx, DWORD PTR _nCount$186740[esp+32]
  00268	8b 54 24 18	 mov	 edx, DWORD PTR _uOffset$186741[esp+36]
  0026c	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 110  : 
; 111  : 		nCount	= 0;
; 112  : 		uOffset	= ar.GetOffset();

  0026f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00272	2b 46 10	 sub	 eax, DWORD PTR [esi+16]
  00275	33 ed		 xor	 ebp, ebp

; 113  : 		ar << nCount;

  00277	53		 push	 ebx
  00278	8b ce		 mov	 ecx, esi
  0027a	89 6c 24 2c	 mov	 DWORD PTR _nCount$186740[esp+36], ebp
  0027e	89 44 24 1c	 mov	 DWORD PTR _uOffset$186741[esp+40], eax
  00282	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00287	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0028a	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+36]
  0028e	89 28		 mov	 DWORD PTR [eax], ebp
  00290	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00293	81 c7 34 3a 00
	00		 add	 edi, 14900		; 00003a34H
  00299	8d a4 24 00 00
	00 00		 npad	 7
$L186761:

; 114  : 		for( i = 0; i < MAX_SLOT_QUEUE; i++ )
; 115  : 		{
; 116  : 			if( m_aSlotQueue[i].m_dwShortcut != SHORTCUT_NONE )		// 값이 들어있는지 검사

  002a0	83 3f 00	 cmp	 DWORD PTR [edi], 0
  002a3	0f 84 bf 00 00
	00		 je	 $L186762

; 117  : 			{
; 118  : 				ar << i;

  002a9	53		 push	 ebx
  002aa	8b ce		 mov	 ecx, esi
  002ac	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002b1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  002b4	89 29		 mov	 DWORD PTR [ecx], ebp
  002b6	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 119  : 				ar << m_aSlotQueue[i].m_dwShortcut << m_aSlotQueue[i].m_dwId << m_aSlotQueue[i].m_dwType;

  002b9	8b 17		 mov	 edx, DWORD PTR [edi]
  002bb	53		 push	 ebx
  002bc	8b ce		 mov	 ecx, esi
  002be	89 54 24 20	 mov	 DWORD PTR $T187121[esp+40], edx
  002c2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002c7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002ca	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T187121[esp+36]
  002ce	89 08		 mov	 DWORD PTR [eax], ecx
  002d0	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  002d3	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  002d6	53		 push	 ebx
  002d7	8b ce		 mov	 ecx, esi
  002d9	89 54 24 20	 mov	 DWORD PTR $T187125[esp+40], edx
  002dd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002e5	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T187125[esp+36]
  002e9	89 08		 mov	 DWORD PTR [eax], ecx
  002eb	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  002ee	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  002f1	53		 push	 ebx
  002f2	8b ce		 mov	 ecx, esi
  002f4	89 54 24 20	 mov	 DWORD PTR $T187129[esp+40], edx
  002f8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002fd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00300	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T187129[esp+36]
  00304	89 08		 mov	 DWORD PTR [eax], ecx
  00306	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 120  : 				ar << m_aSlotQueue[i].m_dwIndex << m_aSlotQueue[i].m_dwUserId << m_aSlotQueue[i].m_dwData;

  00309	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0030c	53		 push	 ebx
  0030d	8b ce		 mov	 ecx, esi
  0030f	89 54 24 20	 mov	 DWORD PTR $T187133[esp+40], edx
  00313	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00318	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0031b	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T187133[esp+36]
  0031f	89 08		 mov	 DWORD PTR [eax], ecx
  00321	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  00324	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00327	53		 push	 ebx
  00328	8b ce		 mov	 ecx, esi
  0032a	89 54 24 20	 mov	 DWORD PTR $T187137[esp+40], edx
  0032e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00333	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00336	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T187137[esp+36]
  0033a	89 08		 mov	 DWORD PTR [eax], ecx
  0033c	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0033f	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00342	53		 push	 ebx
  00343	8b ce		 mov	 ecx, esi
  00345	89 54 24 20	 mov	 DWORD PTR $T187141[esp+40], edx
  00349	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0034e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00351	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T187141[esp+36]
  00355	89 08		 mov	 DWORD PTR [eax], ecx
  00357	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 121  : 				nCount++;

  0035a	8b 44 24 28	 mov	 eax, DWORD PTR _nCount$186740[esp+32]
  0035e	03 cb		 add	 ecx, ebx
  00360	40		 inc	 eax
  00361	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00364	89 44 24 28	 mov	 DWORD PTR _nCount$186740[esp+32], eax
$L186762:
  00368	45		 inc	 ebp
  00369	81 c7 98 00 00
	00		 add	 edi, 152		; 00000098H
  0036f	83 fd 06	 cmp	 ebp, 6
  00372	0f 8c 28 ff ff
	ff		 jl	 $L186761

; 122  : 			}
; 123  : 			
; 124  : 							// m_aSlotQueue[i]이 유효한 숏컷이라면
; 125  : //				ar << i << m_aSlotQueue[i]의 필요한 정보 저장
; 126  : 		}
; 127  : 		ar << m_nActionPoint;

  00378	8b 54 24 10	 mov	 edx, DWORD PTR _this$[esp+36]
  0037c	8b ba c4 3d 00
	00		 mov	 edi, DWORD PTR [edx+15812]
  00382	53		 push	 ebx
  00383	8b ce		 mov	 ecx, esi
  00385	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0038a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0038d	89 38		 mov	 DWORD PTR [eax], edi
  0038f	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 128  : 		lpBuf	= ar.GetBuffer( &nBufSize );

  00392	8d 4c 24 20	 lea	 ecx, DWORD PTR _nBufSize$186748[esp+36]
  00396	51		 push	 ecx
  00397	8b ce		 mov	 ecx, esi
  00399	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 129  : 		*(UNALIGNED int*)( lpBuf + uOffset )	= nCount;

  0039e	8b 54 24 28	 mov	 edx, DWORD PTR _nCount$186740[esp+32]
  003a2	8b 4c 24 18	 mov	 ecx, DWORD PTR _uOffset$186741[esp+36]
  003a6	5f		 pop	 edi
  003a7	5e		 pop	 esi
  003a8	5d		 pop	 ebp
  003a9	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
  003ac	5b		 pop	 ebx

; 168  : 	}
; 169  : }

  003ad	83 c4 14	 add	 esp, 20			; 00000014H
  003b0	c2 04 00	 ret	 4
$L186739:

; 130  : 	}
; 131  : 	else
; 132  : 	{
; 133  : 		memset( m_aSlotApplet, 0, sizeof(m_aSlotApplet) );

  003b3	33 c0		 xor	 eax, eax
  003b5	b9 ac 02 00 00	 mov	 ecx, 684		; 000002acH
  003ba	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  003bd	f3 ab		 rep stosd

; 134  : 		memset( m_aSlotItem, 0, sizeof(m_aSlotItem) );

  003bf	b9 e0 0b 00 00	 mov	 ecx, 3040		; 00000be0H
  003c4	8d bd b4 0a 00
	00		 lea	 edi, DWORD PTR [ebp+2740]
  003ca	f3 ab		 rep stosd

; 135  : 		memset( m_aSlotQueue, 0, sizeof(m_aSlotQueue) );

  003cc	b9 e4 00 00 00	 mov	 ecx, 228		; 000000e4H
  003d1	8d bd 34 3a 00
	00		 lea	 edi, DWORD PTR [ebp+14900]
  003d7	f3 ab		 rep stosd

; 136  : 
; 137  : 		int nCount, nIndex;
; 138  : 		ar >> nCount;	// applet count

  003d9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003dc	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  003df	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  003e2	3b ca		 cmp	 ecx, edx
  003e4	77 07		 ja	 SHORT $L187160
  003e6	8b 00		 mov	 eax, DWORD PTR [eax]
  003e8	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  003eb	eb 05		 jmp	 SHORT $L187161
$L187160:
  003ed	33 c0		 xor	 eax, eax
  003ef	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187161:

; 139  : 		for( int i = 0; i < nCount; i++ )

  003f2	85 c0		 test	 eax, eax
  003f4	bb 04 00 00 00	 mov	 ebx, 4
  003f9	0f 8e fa 00 00
	00		 jle	 $L186772
  003ff	8b f8		 mov	 edi, eax
$L186770:

; 140  : 		{
; 141  : 			ar >> nIndex;

  00401	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00404	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00407	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0040a	3b ca		 cmp	 ecx, edx
  0040c	77 07		 ja	 SHORT $L187172
  0040e	8b 00		 mov	 eax, DWORD PTR [eax]
  00410	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00413	eb 05		 jmp	 SHORT $L187173
$L187172:
  00415	33 c0		 xor	 eax, eax
  00417	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187173:

; 142  : 			ar >> m_aSlotApplet[nIndex].m_dwShortcut >>	m_aSlotApplet[nIndex].m_dwId >> m_aSlotApplet[nIndex].m_dwType;

  0041a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0041d	69 c0 98 00 00
	00		 imul	 eax, 152		; 00000098H
  00423	03 c5		 add	 eax, ebp
  00425	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  00428	3b ea		 cmp	 ebp, edx
  0042a	77 0c		 ja	 SHORT $L187177
  0042c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00431	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00434	03 cb		 add	 ecx, ebx
  00436	eb 0a		 jmp	 SHORT $L187375
$L187177:
  00438	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0043f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187375:
  00442	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  00445	33 d2		 xor	 edx, edx
  00447	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  0044a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0044d	77 0c		 ja	 SHORT $L187183
  0044f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00451	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00454	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00457	03 cb		 add	 ecx, ebx
  00459	eb 06		 jmp	 SHORT $L187376
$L187183:
  0045b	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0045e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187376:
  00461	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  00464	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  00467	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0046a	77 0c		 ja	 SHORT $L187189
  0046c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0046e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00471	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00474	03 cb		 add	 ecx, ebx
  00476	eb 06		 jmp	 SHORT $L187377
$L187189:
  00478	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0047b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187377:

; 143  : 			ar >> m_aSlotApplet[nIndex].m_dwIndex >> m_aSlotApplet[nIndex].m_dwUserId >> m_aSlotApplet[nIndex].m_dwData;

  0047e	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  00481	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  00484	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00487	77 0c		 ja	 SHORT $L187195
  00489	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0048b	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0048e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00491	03 cb		 add	 ecx, ebx
  00493	eb 06		 jmp	 SHORT $L187378
$L187195:
  00495	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00498	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187378:
  0049b	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  0049e	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  004a1	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  004a4	77 0c		 ja	 SHORT $L187201
  004a6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004a8	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  004ab	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004ae	03 cb		 add	 ecx, ebx
  004b0	eb 06		 jmp	 SHORT $L187379
$L187201:
  004b2	89 50 14	 mov	 DWORD PTR [eax+20], edx
  004b5	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187379:
  004b8	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  004bb	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  004be	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  004c1	77 0c		 ja	 SHORT $L187207
  004c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  004c5	89 50 18	 mov	 DWORD PTR [eax+24], edx
  004c8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004cb	03 cb		 add	 ecx, ebx
  004cd	eb 06		 jmp	 SHORT $L187380
$L187207:
  004cf	89 50 18	 mov	 DWORD PTR [eax+24], edx
  004d2	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187380:
  004d5	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 144  : 			if( m_aSlotApplet[nIndex].m_dwShortcut == SHORTCUT_CHAT)

  004d8	83 78 04 08	 cmp	 DWORD PTR [eax+4], 8
  004dc	75 10		 jne	 SHORT $L186771

; 145  : 				ar.ReadString( m_aSlotApplet[nIndex].m_szString, MAX_SHORTCUT_STRING );

  004de	68 80 00 00 00	 push	 128			; 00000080H
  004e3	83 c0 1c	 add	 eax, 28			; 0000001cH
  004e6	50		 push	 eax
  004e7	8b ce		 mov	 ecx, esi
  004e9	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString
$L186771:
  004ee	4f		 dec	 edi
  004ef	8b 6c 24 10	 mov	 ebp, DWORD PTR _this$[esp+36]
  004f3	0f 85 08 ff ff
	ff		 jne	 $L186770
$L186772:

; 146  : //			ar >>  m_aSlotApplet[nIndex]에 아까 넣은 필요한 정보를 넣는다.
; 147  : 		}
; 148  : 		ar >> nCount;	// slot item count

  004f9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  004fc	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  004ff	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00502	3b ca		 cmp	 ecx, edx
  00504	77 07		 ja	 SHORT $L187220
  00506	8b 00		 mov	 eax, DWORD PTR [eax]
  00508	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0050b	eb 05		 jmp	 SHORT $L187221
$L187220:
  0050d	33 c0		 xor	 eax, eax
  0050f	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187221:

; 149  : 		int nIndex2;
; 150  : 		for( i = 0; i < nCount; i++ )

  00512	85 c0		 test	 eax, eax
  00514	0f 8e 41 01 00
	00		 jle	 $L186777
  0051a	89 44 24 28	 mov	 DWORD PTR tv284[esp+32], eax
  0051e	8b ff		 npad	 2
$L186775:

; 151  : 		{
; 152  : 			ar >> nIndex >> nIndex2;	// index

  00520	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00523	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00526	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00529	3b d1		 cmp	 edx, ecx
  0052b	77 07		 ja	 SHORT $L187232
  0052d	8b 00		 mov	 eax, DWORD PTR [eax]
  0052f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00532	eb 05		 jmp	 SHORT $L187233
$L187232:
  00534	33 c0		 xor	 eax, eax
  00536	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L187233:
  00539	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0053c	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  0053f	3b f9		 cmp	 edi, ecx
  00541	77 07		 ja	 SHORT $L187244
  00543	8b 12		 mov	 edx, DWORD PTR [edx]
  00545	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00548	eb 05		 jmp	 SHORT $L187245
$L187244:
  0054a	33 d2		 xor	 edx, edx
  0054c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L187245:

; 153  : 			ar >> m_aSlotItem[nIndex][nIndex2].m_dwShortcut >>	m_aSlotItem[nIndex][nIndex2].m_dwId >> m_aSlotItem[nIndex][nIndex2].m_dwType;

  0054f	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00552	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  00555	69 d2 98 00 00
	00		 imul	 edx, 152		; 00000098H
  0055b	8d 04 2a	 lea	 eax, DWORD PTR [edx+ebp]
  0055e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00561	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00564	3b f9		 cmp	 edi, ecx
  00566	77 11		 ja	 SHORT $L187249
  00568	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0056a	89 88 b4 0a 00
	00		 mov	 DWORD PTR [eax+2740], ecx
  00570	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00573	03 cb		 add	 ecx, ebx
  00575	33 d2		 xor	 edx, edx
  00577	eb 0b		 jmp	 SHORT $L187381
$L187249:
  00579	33 d2		 xor	 edx, edx
  0057b	89 90 b4 0a 00
	00		 mov	 DWORD PTR [eax+2740], edx
  00581	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187381:
  00584	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00587	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  0058a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0058d	77 0f		 ja	 SHORT $L187255
  0058f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00591	89 88 b8 0a 00
	00		 mov	 DWORD PTR [eax+2744], ecx
  00597	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0059a	03 cb		 add	 ecx, ebx
  0059c	eb 09		 jmp	 SHORT $L187382
$L187255:
  0059e	89 90 b8 0a 00
	00		 mov	 DWORD PTR [eax+2744], edx
  005a4	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187382:
  005a7	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  005aa	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  005ad	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  005b0	77 0f		 ja	 SHORT $L187261
  005b2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  005b4	89 88 bc 0a 00
	00		 mov	 DWORD PTR [eax+2748], ecx
  005ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  005bd	03 cb		 add	 ecx, ebx
  005bf	eb 09		 jmp	 SHORT $L187383
$L187261:
  005c1	89 90 bc 0a 00
	00		 mov	 DWORD PTR [eax+2748], edx
  005c7	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187383:

; 154  : 			ar >> m_aSlotItem[nIndex][nIndex2].m_dwIndex >> m_aSlotItem[nIndex][nIndex2].m_dwUserId >> m_aSlotItem[nIndex][nIndex2].m_dwData;

  005ca	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  005cd	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  005d0	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  005d3	77 0f		 ja	 SHORT $L187267
  005d5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  005d7	89 88 c0 0a 00
	00		 mov	 DWORD PTR [eax+2752], ecx
  005dd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  005e0	03 cb		 add	 ecx, ebx
  005e2	eb 09		 jmp	 SHORT $L187384
$L187267:
  005e4	89 90 c0 0a 00
	00		 mov	 DWORD PTR [eax+2752], edx
  005ea	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187384:
  005ed	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  005f0	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  005f3	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  005f6	77 0f		 ja	 SHORT $L187273
  005f8	8b 09		 mov	 ecx, DWORD PTR [ecx]
  005fa	89 88 c4 0a 00
	00		 mov	 DWORD PTR [eax+2756], ecx
  00600	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00603	03 cb		 add	 ecx, ebx
  00605	eb 09		 jmp	 SHORT $L187385
$L187273:
  00607	89 90 c4 0a 00
	00		 mov	 DWORD PTR [eax+2756], edx
  0060d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187385:
  00610	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00613	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  00616	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00619	77 0f		 ja	 SHORT $L187279
  0061b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0061d	89 90 c8 0a 00
	00		 mov	 DWORD PTR [eax+2760], edx
  00623	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00626	03 cb		 add	 ecx, ebx
  00628	eb 09		 jmp	 SHORT $L187386
$L187279:
  0062a	89 90 c8 0a 00
	00		 mov	 DWORD PTR [eax+2760], edx
  00630	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187386:
  00633	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 155  : 			if( m_aSlotItem[nIndex][nIndex2].m_dwShortcut == SHORTCUT_CHAT)

  00636	83 b8 b4 0a 00
	00 08		 cmp	 DWORD PTR [eax+2740], 8
  0063d	75 12		 jne	 SHORT $L186776

; 156  : 				ar.ReadString( m_aSlotItem[nIndex][nIndex2].m_szString, MAX_SHORTCUT_STRING );

  0063f	68 80 00 00 00	 push	 128			; 00000080H
  00644	05 cc 0a 00 00	 add	 eax, 2764		; 00000accH
  00649	50		 push	 eax
  0064a	8b ce		 mov	 ecx, esi
  0064c	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString
$L186776:
  00651	ff 4c 24 28	 dec	 DWORD PTR tv284[esp+32]
  00655	0f 85 c5 fe ff
	ff		 jne	 $L186775
$L186777:

; 157  : 		}
; 158  : 
; 159  : 		ar >> nCount;

  0065b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0065e	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00661	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00664	3b ca		 cmp	 ecx, edx
  00666	77 07		 ja	 SHORT $L187292
  00668	8b 00		 mov	 eax, DWORD PTR [eax]
  0066a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0066d	eb 05		 jmp	 SHORT $L187293
$L187292:
  0066f	33 c0		 xor	 eax, eax
  00671	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187293:

; 160  : 		for( i = 0; i < nCount; i++ )

  00674	85 c0		 test	 eax, eax
  00676	0f 8e 0c 01 00
	00		 jle	 $L187373
  0067c	8b f8		 mov	 edi, eax
  0067e	8b ff		 npad	 2
$L186779:

; 161  : 		{
; 162  : 			ar >> nIndex;

  00680	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00683	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00686	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00689	3b ca		 cmp	 ecx, edx
  0068b	77 07		 ja	 SHORT $L187304
  0068d	8b 00		 mov	 eax, DWORD PTR [eax]
  0068f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00692	eb 05		 jmp	 SHORT $L187305
$L187304:
  00694	33 c0		 xor	 eax, eax
  00696	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187305:

; 163  : 			ar >> m_aSlotQueue[nIndex].m_dwShortcut >> m_aSlotQueue[nIndex].m_dwId >> m_aSlotQueue[nIndex].m_dwType;

  00699	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0069c	69 c0 98 00 00
	00		 imul	 eax, 152		; 00000098H
  006a2	03 c5		 add	 eax, ebp
  006a4	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  006a7	3b ea		 cmp	 ebp, edx
  006a9	77 0f		 ja	 SHORT $L187309
  006ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  006ad	89 90 34 3a 00
	00		 mov	 DWORD PTR [eax+14900], edx
  006b3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006b6	03 cb		 add	 ecx, ebx
  006b8	eb 0d		 jmp	 SHORT $L187387
$L187309:
  006ba	c7 80 34 3a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+14900], 0
  006c4	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187387:
  006c7	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  006ca	33 d2		 xor	 edx, edx
  006cc	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  006cf	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  006d2	77 0f		 ja	 SHORT $L187315
  006d4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  006d6	89 88 38 3a 00
	00		 mov	 DWORD PTR [eax+14904], ecx
  006dc	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006df	03 cb		 add	 ecx, ebx
  006e1	eb 09		 jmp	 SHORT $L187388
$L187315:
  006e3	89 90 38 3a 00
	00		 mov	 DWORD PTR [eax+14904], edx
  006e9	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187388:
  006ec	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  006ef	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  006f2	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  006f5	77 0f		 ja	 SHORT $L187321
  006f7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  006f9	89 88 3c 3a 00
	00		 mov	 DWORD PTR [eax+14908], ecx
  006ff	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00702	03 cb		 add	 ecx, ebx
  00704	eb 09		 jmp	 SHORT $L187389
$L187321:
  00706	89 90 3c 3a 00
	00		 mov	 DWORD PTR [eax+14908], edx
  0070c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187389:

; 164  : 			ar >> m_aSlotQueue[nIndex].m_dwIndex >> m_aSlotQueue[nIndex].m_dwUserId >> m_aSlotQueue[nIndex].m_dwData;

  0070f	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  00712	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  00715	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00718	77 0f		 ja	 SHORT $L187327
  0071a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0071c	89 88 40 3a 00
	00		 mov	 DWORD PTR [eax+14912], ecx
  00722	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00725	03 cb		 add	 ecx, ebx
  00727	eb 09		 jmp	 SHORT $L187390
$L187327:
  00729	89 90 40 3a 00
	00		 mov	 DWORD PTR [eax+14912], edx
  0072f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187390:
  00732	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  00735	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  00738	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0073b	77 0f		 ja	 SHORT $L187333
  0073d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0073f	89 88 44 3a 00
	00		 mov	 DWORD PTR [eax+14916], ecx
  00745	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00748	03 cb		 add	 ecx, ebx
  0074a	eb 09		 jmp	 SHORT $L187391
$L187333:
  0074c	89 90 44 3a 00
	00		 mov	 DWORD PTR [eax+14916], edx
  00752	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L187391:
  00755	8d 69 04	 lea	 ebp, DWORD PTR [ecx+4]
  00758	3b 6e 0c	 cmp	 ebp, DWORD PTR [esi+12]
  0075b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0075e	77 0f		 ja	 SHORT $L187339
  00760	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00762	89 88 48 3a 00
	00		 mov	 DWORD PTR [eax+14920], ecx
  00768	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0076b	03 c3		 add	 eax, ebx
  0076d	eb 09		 jmp	 SHORT $L187392
$L187339:
  0076f	89 90 48 3a 00
	00		 mov	 DWORD PTR [eax+14920], edx
  00775	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L187392:
  00778	4f		 dec	 edi
  00779	8b 6c 24 10	 mov	 ebp, DWORD PTR _this$[esp+36]
  0077d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00780	0f 85 fa fe ff
	ff		 jne	 $L186779

; 160  : 		for( i = 0; i < nCount; i++ )

  00786	eb 02		 jmp	 SHORT $L186781
$L187373:
  00788	33 d2		 xor	 edx, edx
$L186781:

; 165  : //			ar >> m_aSlotQueue[nIndex]에 정보를 넣는다.
; 166  : 		}
; 167  : 		ar >> m_nActionPoint;

  0078a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0078d	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00790	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00793	3b cf		 cmp	 ecx, edi
  00795	77 1a		 ja	 SHORT $L187352
  00797	8b 10		 mov	 edx, DWORD PTR [eax]
  00799	89 95 c4 3d 00
	00		 mov	 DWORD PTR [ebp+15812], edx
  0079f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  007a2	03 c3		 add	 eax, ebx
  007a4	5f		 pop	 edi
  007a5	89 46 08	 mov	 DWORD PTR [esi+8], eax
  007a8	5e		 pop	 esi
  007a9	5d		 pop	 ebp
  007aa	5b		 pop	 ebx

; 168  : 	}
; 169  : }

  007ab	83 c4 14	 add	 esp, 20			; 00000014H
  007ae	c2 04 00	 ret	 4

; 165  : //			ar >> m_aSlotQueue[nIndex]에 정보를 넣는다.
; 166  : 		}
; 167  : 		ar >> m_nActionPoint;

$L187352:
  007b1	89 95 c4 3d 00
	00		 mov	 DWORD PTR [ebp+15812], edx
  007b7	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  007ba	5f		 pop	 edi
  007bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  007be	5e		 pop	 esi
  007bf	5d		 pop	 ebp
  007c0	5b		 pop	 ebx

; 168  : 	}
; 169  : }

  007c1	83 c4 14	 add	 esp, 20			; 00000014H
  007c4	c2 04 00	 ret	 4
?Serialize@CUserTaskBar@@QAEXAAVCAr@@@Z ENDP		; CUserTaskBar::Serialize
_TEXT	ENDS
END
