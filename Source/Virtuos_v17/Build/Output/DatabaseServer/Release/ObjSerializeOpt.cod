; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\ObjSerializeOpt.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?Init@HonorData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObj@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CMover@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__ForceSetState@CActionMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddStateFlag@CAction@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearStateFlag@CAction@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearEquipInfo@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEquipableNPC@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPetId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMethod@CObj@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStateFlag@CAction@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CActionMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?IsStoring@CAr@@QBEHXZ				; CAr::IsStoring
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT
?IsStoring@CAr@@QBEHXZ PROC NEAR			; CAr::IsStoring, COMDAT
; _this$ = ecx

; 96   : 	{ return (m_nMode & CAr::load) == 0; }

  00000	33 c0		 xor	 eax, eax
  00002	8a 01		 mov	 al, BYTE PTR [ecx]
  00004	f7 d0		 not	 eax
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsStoring@CAr@@QBEHXZ ENDP				; CAr::IsStoring
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@E@Z				; CAr::operator<<
EXTRN	?CheckBuf@CAr@@QAEXI@Z:NEAR			; CAr::CheckBuf
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT
_by$ = 8						; size = 1
??6CAr@@QAEAAV0@E@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 107  : 	{ CheckBuf( sizeof(BYTE) );

  00000	56		 push	 esi
  00001	6a 01		 push	 1
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 108  : 		*(UNALIGNED BYTE*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8a 4c 24 08	 mov	 cl, BYTE PTR _by$[esp]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	ff 46 08	 inc	 DWORD PTR [esi+8]
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@E@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@G@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@G@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 110  : 	{ CheckBuf( sizeof( WORD ) );

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 111  : 		*(UNALIGNED WORD*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@G@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@J@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??6CAr@@QAEAAV0@J@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 113  : 	{ CheckBuf( sizeof(LONG) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 114  : 		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _l$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@J@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@K@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??6CAr@@QAEAAV0@K@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 116  : 	{ CheckBuf( sizeof(DWORD) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 117  : 		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@K@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@M@Z				; CAr::operator<<
EXTRN	__fltused:NEAR
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??6CAr@@QAEAAV0@M@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 119  : 	{ CheckBuf( sizeof(float) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 120  : 		*(UNALIGNED FLOAT*)m_lpBufCur = *(FLOAT*)&f; m_lpBufCur += sizeof(float); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _f$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@M@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAE@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT
_by$ = 8						; size = 4
??5CAr@@QAEAAV0@AAE@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 142  : 	{	CAR_SAFE_READ( BYTE, by );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0e		 ja	 SHORT $L162848
  00011	8a 09		 mov	 cl, BYTE PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _by$[esp-4]
  00017	88 0a		 mov	 BYTE PTR [edx], cl
  00019	ff 40 08	 inc	 DWORD PTR [eax+8]
  0001c	c2 04 00	 ret	 4
$L162848:
  0001f	8b 4c 24 04	 mov	 ecx, DWORD PTR _by$[esp-4]
  00023	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002c	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAE@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAG@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??5CAr@@QAEAAV0@AAG@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 144  : 	{	CAR_SAFE_READ( WORD, w );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 11		 ja	 SHORT $L162858
  00011	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00014	8b 54 24 04	 mov	 edx, DWORD PTR _w$[esp-4]
  00018	66 89 0a	 mov	 WORD PTR [edx], cx
  0001b	83 40 08 02	 add	 DWORD PTR [eax+8], 2
  0001f	c2 04 00	 ret	 4
$L162858:
  00022	8b 4c 24 04	 mov	 ecx, DWORD PTR _w$[esp-4]
  00026	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  0002b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00031	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAG@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAK@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??5CAr@@QAEAAV0@AAK@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 146  : 	{	CAR_SAFE_READ( DWORD, dw );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L162868
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _dw$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L162868:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _dw$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAK@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAM@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??5CAr@@QAEAAV0@AAM@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 148  : 	{	CAR_SAFE_READ( float, f );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L162878
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _f$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L162878:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _f$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAM@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAJ@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??5CAr@@QAEAAV0@AAJ@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 152  : 	{	CAR_SAFE_READ( LONG, l );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L162898
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _l$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L162898:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _l$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAJ@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z		; operator<<
EXTRN	?Write@CAr@@QAEXPBXI@Z:NEAR			; CAr::Write
; Function compile flags: /Ogty
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_v$ = 12						; size = 12
??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z PROC NEAR		; operator<<, COMDAT

; 157  : 	{	ar.Write( &v, sizeof(D3DXVECTOR3) );	return ar;	}

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	6a 0c		 push	 12			; 0000000cH
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _v$[esp+4]
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z		; operator>>
EXTRN	?Read@CAr@@QAEXPAXI@Z:NEAR			; CAr::Read
; Function compile flags: /Ogty
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_v$ = 12						; size = 4
??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z PROC NEAR		; operator>>, COMDAT

; 160  : 	{	ar.Read( &v, sizeof(D3DXVECTOR3) );		return ar;	}

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _v$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVCAr@@AAV0@_J@Z				; operator<<
; Function compile flags: /Ogty
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_i$ = 12						; size = 8
??6@YAAAVCAr@@AAV0@_J@Z PROC NEAR			; operator<<, COMDAT

; 163  : 	{	ar.Write( &i, sizeof(__int64) );	return ar;	}

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	6a 08		 push	 8
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _i$[esp+4]
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??6@YAAAVCAr@@AAV0@_J@Z ENDP				; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVCAr@@AAV0@AA_J@Z			; operator>>
; Function compile flags: /Ogty
;	COMDAT ??5@YAAAVCAr@@AAV0@AA_J@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_i$ = 12						; size = 4
??5@YAAAVCAr@@AAV0@AA_J@Z PROC NEAR			; operator>>, COMDAT

; 166  : 	{	ar.Read( &i, sizeof(__int64) );	return ar;	}

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _i$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00009	6a 08		 push	 8
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??5@YAAAVCAr@@AAV0@AA_J@Z ENDP				; operator>>
_TEXT	ENDS
PUBLIC	?GetOffset@CAr@@QAEKXZ				; CAr::GetOffset
; Function compile flags: /Ogty
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT
?GetOffset@CAr@@QAEKXZ PROC NEAR			; CAr::GetOffset, COMDAT
; _this$ = ecx

; 190  : 	ASSERT( IsStoring() );
; 191  : 	return( m_lpBufCur - m_lpBufStart );

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]

; 192  : }

  00006	c3		 ret	 0
?GetOffset@CAr@@QAEKXZ ENDP				; CAr::GetOffset
_TEXT	ENDS
PUBLIC	?GetLevel@CPet@@QAEEXZ				; CPet::GetLevel
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT
?GetLevel@CPet@@QAEEXZ PROC NEAR			; CPet::GetLevel, COMDAT
; _this$ = ecx

; 134  : 	BYTE	GetLevel( void )	{	return m_nLevel;	}

  00000	8a 41 05	 mov	 al, BYTE PTR [ecx+5]
  00003	c3		 ret	 0
?GetLevel@CPet@@QAEEXZ ENDP				; CPet::GetLevel
_TEXT	ENDS
PUBLIC	?GetName@CPet@@QAEPBDXZ				; CPet::GetName
; Function compile flags: /Ogty
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT
?GetName@CPet@@QAEPBDXZ PROC NEAR			; CPet::GetName, COMDAT
; _this$ = ecx

; 149  : 	const char*	GetName()	{	return m_szName;	}

  00000	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]
  00003	c3		 ret	 0
?GetName@CPet@@QAEPBDXZ ENDP				; CPet::GetName
_TEXT	ENDS
PUBLIC	?GetMethod@CObj@@SAHXZ				; CObj::GetMethod
EXTRN	?m_nMethod@CObj@@2HA:DWORD			; CObj::m_nMethod
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?GetMethod@CObj@@SAHXZ
_TEXT	SEGMENT
?GetMethod@CObj@@SAHXZ PROC NEAR			; CObj::GetMethod, COMDAT

; 87   : static int	GetMethod( void )	{	return m_nMethod;	}

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nMethod@CObj@@2HA ; CObj::m_nMethod
  00005	c3		 ret	 0
?GetMethod@CObj@@SAHXZ ENDP				; CObj::GetMethod
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 133  : 	BOOL	IsEmpty()	{	return m_dwItemId ? FALSE : TRUE;	}

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	?ClearStateFlag@CAction@@QAEXXZ			; CAction::ClearStateFlag
; Function compile flags: /Ogty
;	COMDAT ?ClearStateFlag@CAction@@QAEXXZ
_TEXT	SEGMENT
?ClearStateFlag@CAction@@QAEXXZ PROC NEAR		; CAction::ClearStateFlag, COMDAT
; _this$ = ecx

; 887  : 	void	ClearStateFlag() { m_dwStateFlag = 0; }

  00000	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00007	c3		 ret	 0
?ClearStateFlag@CAction@@QAEXXZ ENDP			; CAction::ClearStateFlag
_TEXT	ENDS
PUBLIC	?AddStateFlag@CAction@@QAEXK@Z			; CAction::AddStateFlag
; Function compile flags: /Ogty
;	COMDAT ?AddStateFlag@CAction@@QAEXK@Z
_TEXT	SEGMENT
_dwStateFlag$ = 8					; size = 4
?AddStateFlag@CAction@@QAEXK@Z PROC NEAR		; CAction::AddStateFlag, COMDAT
; _this$ = ecx

; 888  : 	void	AddStateFlag( DWORD dwStateFlag ) { m_dwStateFlag |= dwStateFlag; }

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR _dwStateFlag$[esp-4]
  00007	0b d0		 or	 edx, eax
  00009	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0000c	c2 04 00	 ret	 4
?AddStateFlag@CAction@@QAEXK@Z ENDP			; CAction::AddStateFlag
_TEXT	ENDS
PUBLIC	?GetStateFlag@CAction@@QAEKXZ			; CAction::GetStateFlag
; Function compile flags: /Ogty
;	COMDAT ?GetStateFlag@CAction@@QAEKXZ
_TEXT	SEGMENT
?GetStateFlag@CAction@@QAEKXZ PROC NEAR			; CAction::GetStateFlag, COMDAT
; _this$ = ecx

; 889  : 	DWORD	GetStateFlag() { return m_dwStateFlag; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetStateFlag@CAction@@QAEKXZ ENDP			; CAction::GetStateFlag
_TEXT	ENDS
PUBLIC	?GetState@CActionMover@@QAEKXZ			; CActionMover::GetState
; Function compile flags: /Ogty
;	COMDAT ?GetState@CActionMover@@QAEKXZ
_TEXT	SEGMENT
?GetState@CActionMover@@QAEKXZ PROC NEAR		; CActionMover::GetState, COMDAT
; _this$ = ecx

; 901  : 	DWORD	GetState( void )	{	return m_dwState;	}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetState@CActionMover@@QAEKXZ ENDP			; CActionMover::GetState
_TEXT	ENDS
PUBLIC	?__ForceSetState@CActionMover@@QAEXK@Z		; CActionMover::__ForceSetState
; Function compile flags: /Ogty
;	COMDAT ?__ForceSetState@CActionMover@@QAEXK@Z
_TEXT	SEGMENT
_dwState$ = 8						; size = 4
?__ForceSetState@CActionMover@@QAEXK@Z PROC NEAR	; CActionMover::__ForceSetState, COMDAT
; _this$ = ecx

; 902  : 	void	__ForceSetState( DWORD dwState )	{	m_dwState	= dwState;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwState$[esp-4]
  00004	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00007	c2 04 00	 ret	 4
?__ForceSetState@CActionMover@@QAEXK@Z ENDP		; CActionMover::__ForceSetState
_TEXT	ENDS
PUBLIC	?IsEquipableNPC@CMover@@QAEHXZ			; CMover::IsEquipableNPC
; Function compile flags: /Ogty
;	COMDAT ?IsEquipableNPC@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsEquipableNPC@CMover@@QAEHXZ PROC NEAR		; CMover::IsEquipableNPC, COMDAT
; _this$ = ecx

; 984  : 	BOOL	IsEquipableNPC()	{	return FALSE;	}

  00000	33 c0		 xor	 eax, eax
  00002	c3		 ret	 0
?IsEquipableNPC@CMover@@QAEHXZ ENDP			; CMover::IsEquipableNPC
_TEXT	ENDS
PUBLIC	?GetPetId@CMover@@QAEKXZ			; CMover::GetPetId
; Function compile flags: /Ogty
;	COMDAT ?GetPetId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPetId@CMover@@QAEKXZ PROC NEAR			; CMover::GetPetId, COMDAT
; _this$ = ecx

; 1086 : 	DWORD	GetPetId( void )	{	return m_dwPetId;	}

  00000	8b 81 30 42 00
	00		 mov	 eax, DWORD PTR [ecx+16944]
  00006	c3		 ret	 0
?GetPetId@CMover@@QAEKXZ ENDP				; CMover::GetPetId
_TEXT	ENDS
PUBLIC	?SetPetId@CMover@@QAEXK@Z			; CMover::SetPetId
; Function compile flags: /Ogty
;	COMDAT ?SetPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwPetId$ = 8						; size = 4
?SetPetId@CMover@@QAEXK@Z PROC NEAR			; CMover::SetPetId, COMDAT
; _this$ = ecx

; 1087 : 	void	SetPetId( DWORD dwPetId )		{	m_dwPetId	= dwPetId;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwPetId$[esp-4]
  00004	89 81 30 42 00
	00		 mov	 DWORD PTR [ecx+16944], eax
  0000a	c2 04 00	 ret	 4
?SetPetId@CMover@@QAEXK@Z ENDP				; CMover::SetPetId
_TEXT	ENDS
PUBLIC	?ClearEquipInfo@CMover@@QAEXXZ			; CMover::ClearEquipInfo
; Function compile flags: /Ogty
;	COMDAT ?ClearEquipInfo@CMover@@QAEXXZ
_TEXT	SEGMENT
?ClearEquipInfo@CMover@@QAEXXZ PROC NEAR		; CMover::ClearEquipInfo, COMDAT
; _this$ = ecx

; 1124 : 		memset( m_aEquipInfo, 0, sizeof(EQUIP_INFO) * MAX_HUMAN_PARTS );

  00000	8d 91 24 45 00
	00		 lea	 edx, DWORD PTR [ecx+17700]
  00006	57		 push	 edi
  00007	33 c0		 xor	 eax, eax
  00009	b9 5d 00 00 00	 mov	 ecx, 93			; 0000005dH
  0000e	8b fa		 mov	 edi, edx
  00010	f3 ab		 rep stosd
  00012	8b c2		 mov	 eax, edx
  00014	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00019	5f		 pop	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$L177572:

; 1125 : 		for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 1126 : 			m_aEquipInfo[i].dwId	= NULL_ID;

  00020	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00026	83 c0 0c	 add	 eax, 12			; 0000000cH
  00029	49		 dec	 ecx
  0002a	75 f4		 jne	 SHORT $L177572

; 1127 : 	}

  0002c	c3		 ret	 0
?ClearEquipInfo@CMover@@QAEXXZ ENDP			; CMover::ClearEquipInfo
_TEXT	ENDS
PUBLIC	?GetSex@CMover@@QAEEXZ				; CMover::GetSex
; Function compile flags: /Ogty
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT
?GetSex@CMover@@QAEEXZ PROC NEAR			; CMover::GetSex, COMDAT
; _this$ = ecx

; 1197 : 	BYTE	GetSex() { return m_bySex; }

  00000	8a 81 b8 00 00
	00		 mov	 al, BYTE PTR [ecx+184]
  00006	c3		 ret	 0
?GetSex@CMover@@QAEEXZ ENDP				; CMover::GetSex
_TEXT	ENDS
PUBLIC	?SetSex@CMover@@QAEXE@Z				; CMover::SetSex
; Function compile flags: /Ogty
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT
_bySex$ = 8						; size = 1
?SetSex@CMover@@QAEXE@Z PROC NEAR			; CMover::SetSex, COMDAT
; _this$ = ecx

; 1198 : 	void	SetSex( BYTE bySex ) { m_bySex = bySex; }

  00000	8a 44 24 04	 mov	 al, BYTE PTR _bySex$[esp-4]
  00004	88 81 b8 00 00
	00		 mov	 BYTE PTR [ecx+184], al
  0000a	c2 04 00	 ret	 4
?SetSex@CMover@@QAEXE@Z ENDP				; CMover::SetSex
_TEXT	ENDS
PUBLIC	?GetGold@CMover@@QAEHXZ				; CMover::GetGold
; Function compile flags: /Ogty
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetGold@CMover@@QAEHXZ PROC NEAR			; CMover::GetGold, COMDAT
; _this$ = ecx

; 1230 : 	ASSERT( m_dwGold <= INT_MAX );
; 1231 : 	return m_dwGold;

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]

; 1232 : }

  00003	c3		 ret	 0
?GetGold@CMover@@QAEHXZ ENDP				; CMover::GetGold
_TEXT	ENDS
PUBLIC	?SetGold@CMover@@QAEXH@Z			; CMover::SetGold
; Function compile flags: /Ogty
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nGold$ = 8						; size = 4
?SetGold@CMover@@QAEXH@Z PROC NEAR			; CMover::SetGold, COMDAT
; _this$ = ecx

; 1236 : 	ASSERT( nGold >= 0 );
; 1237 : 	m_dwGold = (DWORD)nGold;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nGold$[esp-4]
  00004	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 1238 : }

  00007	c2 04 00	 ret	 4
?SetGold@CMover@@QAEXH@Z ENDP				; CMover::SetGold
_TEXT	ENDS
PUBLIC	?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
EXTRN	?GetBuffer@CAr@@QAEPAEPAH@Z:NEAR		; CAr::GetBuffer
; Function compile flags: /Ogty
;	COMDAT ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
_ch$187576 = -522					; size = 1
_chSize$ = -521						; size = 1
_uOffset$187575 = -520					; size = 4
_nBufSize$187582 = -516					; size = 4
_adwObjIndex$ = -512					; size = 512
_ar$ = 8						; size = 4
?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z PROC NEAR ; CItemContainer<CItemElem>::Serialize, COMDAT
; _this$ = ecx

; 804  : {

  00000	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi

; 805  : //	for( int i = 0; i < m_dwItemMax; i++ )	// 462
; 806  : //		m_apItem[i].Serialize( ar );
; 807  : 	DWORD	adwObjIndex[128];
; 808  : 
; 809  : 	unsigned char chSize	= 0;
; 810  : 	
; 811  : 	if( ar.IsStoring() )

  00009	8b b4 24 1c 02
	00 00		 mov	 esi, DWORD PTR _ar$[esp+532]
  00010	33 c0		 xor	 eax, eax
  00012	8a 06		 mov	 al, BYTE PTR [esi]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx
  00017	c6 44 24 13 00	 mov	 BYTE PTR _chSize$[esp+540], 0
  0001c	f7 d0		 not	 eax
  0001e	a8 01		 test	 al, 1
  00020	0f 84 c6 00 00
	00		 je	 $L187573

; 812  : 	{
; 813  : 		
; 814  : 		ar.Write( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  00026	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00029	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0002c	c1 e1 02	 shl	 ecx, 2
  0002f	51		 push	 ecx
  00030	52		 push	 edx
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 815  : 		u_long uOffset	= ar.GetOffset();

  00038	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0003b	2b 5e 10	 sub	 ebx, DWORD PTR [esi+16]

; 816  : 		ar << chSize;

  0003e	6a 01		 push	 1
  00040	8b ce		 mov	 ecx, esi
  00042	89 5c 24 18	 mov	 DWORD PTR _uOffset$187575[esp+544], ebx
  00046	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00051	ff 46 08	 inc	 DWORD PTR [esi+8]

; 817  : 
; 818  : 		for( u_char ch = 0; ch < m_dwItemMax; ch++ )	// 0-504

  00054	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00057	85 c0		 test	 eax, eax
  00059	c6 44 24 12 00	 mov	 BYTE PTR _ch$187576[esp+540], 0
  0005e	76 59		 jbe	 SHORT $L187579
  00060	33 db		 xor	 ebx, ebx
$L187897:

; 819  : 		{	
; 820  : 			if( m_apItem[ch].IsEmpty() == FALSE )

  00062	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00065	8d 2c 9b	 lea	 ebp, DWORD PTR [ebx+ebx*4]
  00068	c1 e5 05	 shl	 ebp, 5
  0006b	8b 44 29 08	 mov	 eax, DWORD PTR [ecx+ebp+8]
  0006f	85 c0		 test	 eax, eax
  00071	74 25		 je	 SHORT $L187580

; 821  : 			{
; 822  : 				ar << ch;

  00073	6a 01		 push	 1
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0007c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007f	8a 44 24 12	 mov	 al, BYTE PTR _ch$187576[esp+540]
  00083	88 02		 mov	 BYTE PTR [edx], al
  00085	ff 46 08	 inc	 DWORD PTR [esi+8]

; 823  : 				m_apItem[ch].Serialize( ar );

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	8b 14 29	 mov	 edx, DWORD PTR [ecx+ebp]
  0008e	03 cd		 add	 ecx, ebp
  00090	56		 push	 esi
  00091	ff 52 0c	 call	 DWORD PTR [edx+12]

; 824  : 				chSize++;

  00094	fe 44 24 13	 inc	 BYTE PTR _chSize$[esp+540]
$L187580:

; 825  : 			}
; 826  : 			adwObjIndex[ch]		= m_apItem[ch].m_dwObjIndex;

  00098	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0009b	8b 4c 28 2c	 mov	 ecx, DWORD PTR [eax+ebp+44]
  0009f	8a 44 24 12	 mov	 al, BYTE PTR _ch$187576[esp+540]
  000a3	fe c0		 inc	 al
  000a5	89 4c 9c 1c	 mov	 DWORD PTR _adwObjIndex$[esp+ebx*4+540], ecx
  000a9	0f b6 d8	 movzx	 ebx, al
  000ac	88 44 24 12	 mov	 BYTE PTR _ch$187576[esp+540], al
  000b0	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  000b3	72 ad		 jb	 SHORT $L187897

; 817  : 
; 818  : 		for( u_char ch = 0; ch < m_dwItemMax; ch++ )	// 0-504

  000b5	8b 5c 24 14	 mov	 ebx, DWORD PTR _uOffset$187575[esp+540]
$L187579:

; 827  : 		}
; 828  : 
; 829  : 		ar.Write( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  000b9	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000bc	c1 e2 02	 shl	 edx, 2
  000bf	52		 push	 edx
  000c0	8d 44 24 20	 lea	 eax, DWORD PTR _adwObjIndex$[esp+544]
  000c4	50		 push	 eax
  000c5	8b ce		 mov	 ecx, esi
  000c7	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 830  : 
; 831  : 		int nBufSize;
; 832  : 		LPBYTE lpBuf	= ar.GetBuffer( &nBufSize );

  000cc	8d 4c 24 18	 lea	 ecx, DWORD PTR _nBufSize$187582[esp+540]
  000d0	51		 push	 ecx
  000d1	8b ce		 mov	 ecx, esi
  000d3	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 833  : 		*( lpBuf + uOffset )	= chSize;

  000d8	8a 54 24 13	 mov	 dl, BYTE PTR _chSize$[esp+540]
  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5d		 pop	 ebp
  000df	88 14 18	 mov	 BYTE PTR [eax+ebx], dl
  000e2	5b		 pop	 ebx

; 855  : 		}
; 856  : 	}
; 857  : }

  000e3	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  000e9	c2 04 00	 ret	 4
$L187573:

; 834  : 	}
; 835  : 	else
; 836  : 	{
; 837  : 		ar.Read( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  000ec	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000ef	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f2	c1 e0 02	 shl	 eax, 2
  000f5	50		 push	 eax
  000f6	51		 push	 ecx
  000f7	8b ce		 mov	 ecx, esi
  000f9	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 838  : 		// Clear
; 839  : 		for( u_int i = 0; i < m_dwItemMax; i++ )

  000fe	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00101	33 db		 xor	 ebx, ebx
  00103	85 c0		 test	 eax, eax
  00105	76 23		 jbe	 SHORT $L187589

; 834  : 	}
; 835  : 	else
; 836  : 	{
; 837  : 		ar.Read( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  00107	33 ed		 xor	 ebp, ebp
  00109	8d a4 24 00 00
	00 00		 npad	 7
$L187587:

; 840  : 			m_apItem[i].Empty();

  00110	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00113	8b 04 2a	 mov	 eax, DWORD PTR [edx+ebp]
  00116	8d 0c 2a	 lea	 ecx, DWORD PTR [edx+ebp]
  00119	ff 50 04	 call	 DWORD PTR [eax+4]
  0011c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0011f	43		 inc	 ebx
  00120	81 c5 a0 00 00
	00		 add	 ebp, 160		; 000000a0H
  00126	3b d8		 cmp	 ebx, eax
  00128	72 e6		 jb	 SHORT $L187587
$L187589:

; 841  : 
; 842  : 		ar >> chSize;

  0012a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0012d	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00130	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00133	3b ca		 cmp	 ecx, edx
  00135	77 07		 ja	 SHORT $L187880
  00137	8a 00		 mov	 al, BYTE PTR [eax]
  00139	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0013c	eb 05		 jmp	 SHORT $L187881
$L187880:
  0013e	32 c0		 xor	 al, al
  00140	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187881:

; 852  : 		for( i = 0; i < m_dwItemMax; i++ )

  00143	0f b6 c0	 movzx	 eax, al
  00146	85 c0		 test	 eax, eax
  00148	76 37		 jbe	 SHORT $L187593

; 843  : 
; 844  : 		unsigned char ch;
; 845  : 		for( i = 0; i < chSize; i++ )

  0014a	8b d8		 mov	 ebx, eax
  0014c	8d 64 24 00	 npad	 4
$L187591:

; 846  : 		{
; 847  : 			ar >> ch;

  00150	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00153	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00156	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00159	3b ca		 cmp	 ecx, edx
  0015b	77 07		 ja	 SHORT $L187885
  0015d	8a 00		 mov	 al, BYTE PTR [eax]
  0015f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00162	eb 05		 jmp	 SHORT $L187886
$L187885:
  00164	32 c0		 xor	 al, al
  00166	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187886:

; 848  : 			m_apItem[ch].Serialize( ar );

  00169	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0016c	0f b6 c0	 movzx	 eax, al
  0016f	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00172	c1 e1 05	 shl	 ecx, 5
  00175	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  00178	03 ca		 add	 ecx, edx
  0017a	56		 push	 esi
  0017b	ff 50 0c	 call	 DWORD PTR [eax+12]
  0017e	4b		 dec	 ebx
  0017f	75 cf		 jne	 SHORT $L187591
$L187593:

; 849  : 		}
; 850  : 
; 851  : 		ar.Read( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  00181	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00184	c1 e1 02	 shl	 ecx, 2
  00187	51		 push	 ecx
  00188	8d 54 24 20	 lea	 edx, DWORD PTR _adwObjIndex$[esp+544]
  0018c	52		 push	 edx
  0018d	8b ce		 mov	 ecx, esi
  0018f	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 852  : 		for( i = 0; i < m_dwItemMax; i++ )

  00194	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00197	33 c0		 xor	 eax, eax
  00199	85 c9		 test	 ecx, ecx
  0019b	76 1c		 jbe	 SHORT $L187597

; 849  : 		}
; 850  : 
; 851  : 		ar.Read( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  0019d	33 c9		 xor	 ecx, ecx
  0019f	90		 npad	 1
$L187595:

; 853  : 		{
; 854  : 			m_apItem[i].m_dwObjIndex	= adwObjIndex[i];

  001a0	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  001a3	8b 74 84 1c	 mov	 esi, DWORD PTR _adwObjIndex$[esp+eax*4+540]
  001a7	89 74 11 2c	 mov	 DWORD PTR [ecx+edx+44], esi
  001ab	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  001ae	40		 inc	 eax
  001af	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  001b5	3b c2		 cmp	 eax, edx
  001b7	72 e7		 jb	 SHORT $L187595
$L187597:
  001b9	5f		 pop	 edi
  001ba	5e		 pop	 esi
  001bb	5d		 pop	 ebp
  001bc	5b		 pop	 ebx

; 855  : 		}
; 856  : 	}
; 857  : }

  001bd	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  001c3	c2 04 00	 ret	 4
?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ENDP ; CItemContainer<CItemElem>::Serialize
_TEXT	ENDS
PUBLIC	?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAt, COMDAT
; _this$ = ecx

; 652  : 	DWORD dwIdx		= m_apIndex[dwIndex];

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR _dwIndex$[esp-4]
  00007	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 653  : 	if( dwIdx == NULL_ID )

  0000a	83 f8 ff	 cmp	 eax, -1
  0000d	75 05		 jne	 SHORT $L187681

; 654  : 		return NULL;

  0000f	33 c0		 xor	 eax, eax

; 657  : 		return NULL;
; 658  : 	return pItemElem;
; 659  : }

  00011	c2 04 00	 ret	 4
$L187681:

; 655  : 	T* pItemElem	= &m_apItem[dwIdx];

  00014	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00017	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001a	c1 e2 05	 shl	 edx, 5
  0001d	03 d0		 add	 edx, eax

; 656  : 	if( pItemElem->IsEmpty() ) 

  0001f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00022	f7 d8		 neg	 eax
  00024	1b c0		 sbb	 eax, eax
  00026	23 c2		 and	 eax, edx

; 657  : 		return NULL;
; 658  : 	return pItemElem;
; 659  : }

  00028	c2 04 00	 ret	 4
?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAt
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@H@Z				; CAr::operator<<
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??6CAr@@QAEAAV0@H@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 99   : 	{ return CAr::operator<<((LONG)i); }

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _i$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@H@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@F@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@F@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 103  : 	{ return CAr::operator<<((WORD)w); }

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@F@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@D@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@D@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
??6CAr@@QAEAAV0@D@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 105  : 	{ return CAr::operator<<((BYTE)ch); }

  00000	56		 push	 esi
  00001	6a 01		 push	 1
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8a 4c 24 08	 mov	 cl, BYTE PTR _ch$[esp]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	ff 46 08	 inc	 DWORD PTR [esi+8]
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@D@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAH@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??5CAr@@QAEAAV0@AAH@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 126  : 	{ return CAr::operator>>((LONG&)i); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L187922
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _i$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L187922:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _i$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAH@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAF@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAF@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??5CAr@@QAEAAV0@AAF@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 130  : 	{ return CAr::operator>>((WORD&)w); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 11		 ja	 SHORT $L187929
  00011	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00014	8b 54 24 04	 mov	 edx, DWORD PTR _w$[esp-4]
  00018	66 89 0a	 mov	 WORD PTR [edx], cx
  0001b	83 40 08 02	 add	 DWORD PTR [eax+8], 2
  0001f	c2 04 00	 ret	 4
$L187929:
  00022	8b 4c 24 04	 mov	 ecx, DWORD PTR _w$[esp-4]
  00026	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  0002b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00031	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAF@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAD@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAD@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 4
??5CAr@@QAEAAV0@AAD@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 132  : 	{ return CAr::operator>>((BYTE&)ch); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0e		 ja	 SHORT $L187936
  00011	8a 09		 mov	 cl, BYTE PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _ch$[esp-4]
  00017	88 0a		 mov	 BYTE PTR [edx], cl
  00019	ff 40 08	 inc	 DWORD PTR [eax+8]
  0001c	c2 04 00	 ret	 4
$L187936:
  0001f	8b 4c 24 04	 mov	 ecx, DWORD PTR _ch$[esp-4]
  00023	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002c	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAD@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	?Serialize@CObj@@UAEXAAVCAr@@@Z			; CObj::Serialize
PUBLIC	__real@42c80000
PUBLIC	__real@41200000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
EXTRN	__ftol2:NEAR
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\objserializeopt.cpp
CONST	ENDS
;	COMDAT ?Serialize@CObj@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
$T187959 = -12						; size = 12
tv318 = 8						; size = 4
tv313 = 8						; size = 4
_ar$ = 8						; size = 4
?Serialize@CObj@@UAEXAAVCAr@@@Z PROC NEAR		; CObj::Serialize, COMDAT
; _this$ = ecx

; 25   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 26   : 	if( ar.IsStoring() )

  00005	8b 74 24 18	 mov	 esi, DWORD PTR _ar$[esp+16]
  00009	33 c0		 xor	 eax, eax
  0000b	8a 06		 mov	 al, BYTE PTR [esi]
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	f7 d0		 not	 eax
  00012	a8 01		 test	 al, 1
  00014	0f 84 a7 00 00
	00		 je	 $L187314

; 27   : 	{
; 28   : 		ar << (u_char)m_dwType;

  0001a	8a 5f 04	 mov	 bl, BYTE PTR [edi+4]
  0001d	6a 01		 push	 1
  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00026	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00029	88 19		 mov	 BYTE PTR [ecx], bl
  0002b	ff 46 08	 inc	 DWORD PTR [esi+8]

; 29   : 
; 30   : 		// mirchang_100513 type cast fix
; 31   : 		//ar << (u_short)m_dwIndex;
; 32   : 		ar << m_dwIndex;

  0002e	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  00031	6a 04		 push	 4
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003d	89 1a		 mov	 DWORD PTR [edx], ebx
  0003f	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00042	83 c3 04	 add	 ebx, 4
  00045	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 33   : 		// mirchang_100513 type cast fix
; 34   : 
; 35   : 		ar << (u_short)( m_vScale.x * 100.0f );

  00048	d9 47 0c	 fld	 DWORD PTR [edi+12]
  0004b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42c80000
  00051	e8 00 00 00 00	 call	 __ftol2
  00056	6a 02		 push	 2
  00058	8b ce		 mov	 ecx, esi
  0005a	8b d8		 mov	 ebx, eax
  0005c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00061	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00064	66 89 18	 mov	 WORD PTR [eax], bx
  00067	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 36   : 		ar << m_vPos;

  0006b	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00073	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00076	89 54 24 0c	 mov	 DWORD PTR $T187959[esp+24], edx
  0007a	6a 0c		 push	 12			; 0000000cH
  0007c	8d 54 24 10	 lea	 edx, DWORD PTR $T187959[esp+28]
  00080	89 4c 24 18	 mov	 DWORD PTR $T187959[esp+36], ecx
  00084	52		 push	 edx
  00085	8b ce		 mov	 ecx, esi
  00087	89 44 24 18	 mov	 DWORD PTR $T187959[esp+36], eax
  0008b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 37   : 		ar << (short)( m_fAngle * 10.0f );

  00090	d9 47 28	 fld	 DWORD PTR [edi+40]
  00093	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41200000
  00099	e8 00 00 00 00	 call	 __ftol2
  0009e	6a 02		 push	 2
  000a0	8b ce		 mov	 ecx, esi
  000a2	8b f8		 mov	 edi, eax
  000a4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ac	66 89 38	 mov	 WORD PTR [eax], di
  000af	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b2	83 c0 02	 add	 eax, 2
  000b5	5f		 pop	 edi
  000b6	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx

; 58   : 	#if defined(__WORLDSERVER) || defined(__CLIENT)
; 59   : 		SetAngle( m_fAngle );
; 60   : 	#endif
; 61   : 
; 62   : 	#ifdef __WORLDSERVER
; 63   : 		m_vLink		= m_vPos;
; 64   : 	#endif	// __WORLDSERVER
; 65   : 	}
; 66   : }

  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000be	c2 04 00	 ret	 4
$L187314:

; 38   : 	}
; 39   : 	else
; 40   : 	{
; 41   : 		u_short u2;
; 42   : 		short i2;
; 43   : 		m_dwType = m_dwIndex = 0; 

  000c1	33 db		 xor	 ebx, ebx
  000c3	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  000c6	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 44   : 		
; 45   : 		ar >> (u_char&)m_dwType;				// m_dwType

  000c9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000cc	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000cf	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  000d2	3b ca		 cmp	 ecx, edx
  000d4	77 0b		 ja	 SHORT $L187971
  000d6	8a 10		 mov	 dl, BYTE PTR [eax]
  000d8	88 57 04	 mov	 BYTE PTR [edi+4], dl
  000db	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000de	40		 inc	 eax
  000df	eb 06		 jmp	 SHORT $L188010
$L187971:
  000e1	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  000e4	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L188010:

; 46   : 
; 47   : 		// mirchang_100513 type cast fix
; 48   : 		//ar >> u2;								// m_dwIndex
; 49   : 		//m_dwIndex	= (DWORD)u2;
; 50   : 		ar >> m_dwIndex;

  000e7	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000ea	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  000ed	3b ca		 cmp	 ecx, edx
  000ef	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f2	77 0d		 ja	 SHORT $L187977
  000f4	8b 10		 mov	 edx, DWORD PTR [eax]
  000f6	89 57 08	 mov	 DWORD PTR [edi+8], edx
  000f9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fc	83 c0 04	 add	 eax, 4
  000ff	eb 06		 jmp	 SHORT $L188011
$L187977:
  00101	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00104	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L188011:

; 51   : 		// mirchang_100513 type cast fix
; 52   : 
; 53   : 		ar >> u2;								// m_vScale.x * 100.0f

  00107	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0010a	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0010d	3b ca		 cmp	 ecx, edx
  0010f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00112	77 08		 ja	 SHORT $L187983
  00114	66 8b 00	 mov	 ax, WORD PTR [eax]
  00117	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0011a	eb 05		 jmp	 SHORT $L187984
$L187983:
  0011c	33 c0		 xor	 eax, eax
  0011e	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187984:

; 54   : 		m_vScale.x	=	m_vScale.y	=	m_vScale.z	= (float)u2 / 100.0f;

  00121	0f b7 c8	 movzx	 ecx, ax
  00124	89 4c 24 1c	 mov	 DWORD PTR tv318[esp+20], ecx

; 55   : 		ar >> m_vPos;							// m_vPos

  00128	6a 0c		 push	 12			; 0000000cH
  0012a	8d 57 1c	 lea	 edx, DWORD PTR [edi+28]
  0012d	db 44 24 20	 fild	 DWORD PTR tv318[esp+24]
  00131	52		 push	 edx
  00132	8b ce		 mov	 ecx, esi
  00134	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0013a	d9 57 14	 fst	 DWORD PTR [edi+20]
  0013d	d9 57 10	 fst	 DWORD PTR [edi+16]
  00140	d9 5f 0c	 fstp	 DWORD PTR [edi+12]
  00143	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 56   : 		ar >> i2;								// m_fAngle * 10.0f

  00148	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0014b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0014e	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  00151	3b ca		 cmp	 ecx, edx
  00153	77 08		 ja	 SHORT $L187998
  00155	66 8b 00	 mov	 ax, WORD PTR [eax]
  00158	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0015b	eb 05		 jmp	 SHORT $L187999
$L187998:
  0015d	33 c0		 xor	 eax, eax
  0015f	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L187999:

; 57   : 		m_fAngle	= (float)i2 / 10.0f;

  00162	0f bf c0	 movsx	 eax, ax
  00165	89 44 24 1c	 mov	 DWORD PTR tv313[esp+20], eax
  00169	db 44 24 1c	 fild	 DWORD PTR tv313[esp+20]
  0016d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3dcccccd
  00173	d9 5f 28	 fstp	 DWORD PTR [edi+40]
  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	5b		 pop	 ebx

; 58   : 	#if defined(__WORLDSERVER) || defined(__CLIENT)
; 59   : 		SetAngle( m_fAngle );
; 60   : 	#endif
; 61   : 
; 62   : 	#ifdef __WORLDSERVER
; 63   : 		m_vLink		= m_vPos;
; 64   : 	#endif	// __WORLDSERVER
; 65   : 	}
; 66   : }

  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017c	c2 04 00	 ret	 4
?Serialize@CObj@@UAEXAAVCAr@@@Z ENDP			; CObj::Serialize
_TEXT	ENDS
PUBLIC	?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetEquip
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetEquip, COMDAT
; _this$ = ecx

; 741  : 	return GetAt( m_dwIndexNum + dwIndex );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _dwIndex$[esp-4]
  00004	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00007	03 c2		 add	 eax, edx
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0000f	83 f8 ff	 cmp	 eax, -1
  00012	75 05		 jne	 SHORT $L188020
  00014	33 c0		 xor	 eax, eax

; 742  : }

  00016	c2 04 00	 ret	 4

; 741  : 	return GetAt( m_dwIndexNum + dwIndex );

$L188020:
  00019	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  0001c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001f	c1 e2 05	 shl	 edx, 5
  00022	03 d0		 add	 edx, eax
  00024	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00027	f7 d8		 neg	 eax
  00029	1b c0		 sbb	 eax, eax
  0002b	23 c2		 and	 eax, edx

; 742  : }

  0002d	c2 04 00	 ret	 4
?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetEquip
_TEXT	ENDS
PUBLIC	?Serialize@CMover@@UAEXAAVCAr@@@Z		; CMover::Serialize
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	?Serialize@CPocketController@@QAEXAAVCAr@@@Z:NEAR ; CPocketController::Serialize
EXTRN	?Serialize@CBuffMgr@@QAEXAAVCAr@@@Z:NEAR	; CBuffMgr::Serialize
EXTRN	?GetPetItem@CMover@@QAEPAVCItemElem@@XZ:NEAR	; CMover::GetPetItem
EXTRN	?InitProp@CMover@@QAEXXZ:NEAR			; CMover::InitProp
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	?Serialize@CCtrl@@UAEXAAVCAr@@@Z:NEAR		; CCtrl::Serialize
EXTRN	?GetIndex@CPet@@QAEKXZ:NEAR			; CPet::GetIndex
EXTRN	?WriteString@CAr@@QAEXPBD@Z:NEAR		; CAr::WriteString
EXTRN	?ReadString@CAr@@QAEPADPADH@Z:NEAR		; CAr::ReadString
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\objserializeopt.cpp
CONST	ENDS
;	COMDAT ?Serialize@CMover@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
$T188401 = -616						; size = 1
$T188397 = -616						; size = 1
$T188393 = -616						; size = 1
$T188377 = -616						; size = 1
$T188369 = -616						; size = 1
$T188339 = -616						; size = 1
$T188335 = -616						; size = 1
$T188331 = -616						; size = 1
$T188226 = -616						; size = 1
$T188176 = -616						; size = 1
$T188097 = -616						; size = 1
$T188089 = -616						; size = 1
$T188081 = -616						; size = 1
$T188077 = -616						; size = 1
$T188062 = -616						; size = 1
$T188070 = -616						; size = 1
$T188040 = -616						; size = 1
_uSize$187397 = -616					; size = 1
$T188562 = -612						; size = 1
$T188558 = -612						; size = 1
$T188554 = -612						; size = 1
$T188509 = -612						; size = 1
$T188501 = -612						; size = 1
$T188487 = -612						; size = 1
$T188491 = -612						; size = 1
tv5656 = -608						; size = 4
tv3306 = -608						; size = 4
tv3218 = -608						; size = 4
$T188483 = -608						; size = 2
$T188101 = -608						; size = 2
$T188105 = -608						; size = 2
$T188109 = -608						; size = 2
$T188113 = -608						; size = 2
$T188117 = -608						; size = 2
tv2358 = -608						; size = 4
$T188429 = -608						; size = 4
$T188385 = -608						; size = 4
$T188381 = -608						; size = 4
$T188365 = -608						; size = 4
$T188257 = -608						; size = 4
$T188244 = -608						; size = 4
$T188093 = -608						; size = 4
$T188085 = -608						; size = 4
$T188066 = -608						; size = 4
$T188055 = -608						; size = 4
$T188044 = -608						; size = 4
$T188048 = -608						; size = 4
tv5651 = -604						; size = 4
tv5474 = -604						; size = 4
tv3038 = -604						; size = 4
tv2550 = -604						; size = 4
tv2489 = -604						; size = 4
tv1016 = -604						; size = 4
tv1001 = -604						; size = 4
tv990 = -604						; size = 4
tv979 = -604						; size = 4
_pszPetName$187410 = -604				; size = 4
_uParts$187399 = -597					; size = 1
$T188575 = -596						; size = 4
_pItemElem$187411 = -596				; size = 4
_uOffset$187398 = -596					; size = 4
_dwJobLv$187477 = -592					; size = 160
_dwJobLv$187366 = -592					; size = 160
_aJobSkill$187445 = -432				; size = 408
$T188405 = -24						; size = 8
$T188327 = -24						; size = 12
$T188315 = -24						; size = 8
$T188293 = -24						; size = 8
_szPetName$187531 = -24					; size = 17
_nBlockSize$187435 = -24				; size = 4
_nBlockSize$187406 = -24				; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_ar$ = 8						; size = 4
?Serialize@CMover@@UAEXAAVCAr@@@Z PROC NEAR		; CMover::Serialize, COMDAT
; _this$ = ecx

; 104  : {

  00000	81 ec 68 02 00
	00		 sub	 esp, 616		; 00000268H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	8b ac 24 74 02
	00 00		 mov	 ebp, DWORD PTR _ar$[esp+620]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 105  : 	CCtrl::Serialize( ar );	//	25

  00018	55		 push	 ebp
  00019	89 84 24 78 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+636], eax
  00020	8b d9		 mov	 ebx, ecx
  00022	e8 00 00 00 00	 call	 ?Serialize@CCtrl@@UAEXAAVCAr@@@Z ; CCtrl::Serialize

; 106  : 	DWORD dwGold;
; 107  : 
; 108  : 	if( ar.IsStoring() )	// STORING

  00027	33 c0		 xor	 eax, eax
  00029	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0002c	f7 d0		 not	 eax
  0002e	a8 01		 test	 al, 1
  00030	0f 84 d3 0c 00
	00		 je	 $L187329

; 109  : 	{
; 110  : 		ar << (u_short)m_dwMotion;

  00036	66 8b 73 18	 mov	 si, WORD PTR [ebx+24]
  0003a	bf 02 00 00 00	 mov	 edi, 2
  0003f	57		 push	 edi
  00040	8b cd		 mov	 ecx, ebp
  00042	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00047	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0004a	66 89 31	 mov	 WORD PTR [ecx], si
  0004d	01 7d 08	 add	 DWORD PTR [ebp+8], edi

; 111  : 		ar << (u_char)m_bPlayer;

  00050	8a 93 8c 00 00
	00		 mov	 dl, BYTE PTR [ebx+140]
  00056	6a 01		 push	 1
  00058	8b cd		 mov	 ecx, ebp
  0005a	88 54 24 14	 mov	 BYTE PTR $T188040[esp+636], dl
  0005e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00063	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00066	8a 4c 24 10	 mov	 cl, BYTE PTR $T188040[esp+632]
  0006a	88 08		 mov	 BYTE PTR [eax], cl
  0006c	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 112  : 		ar << m_nHitPoint;

  0006f	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [ebx+148]
  00075	be 04 00 00 00	 mov	 esi, 4
  0007a	56		 push	 esi
  0007b	8b cd		 mov	 ecx, ebp
  0007d	89 54 24 1c	 mov	 DWORD PTR $T188044[esp+636], edx
  00081	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00086	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00089	8b 4c 24 18	 mov	 ecx, DWORD PTR $T188044[esp+632]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx
  0008f	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 113  : 		ar << m_pActMover->GetState();

  00092	8b 93 10 41 00
	00		 mov	 edx, DWORD PTR [ebx+16656]
  00098	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009b	56		 push	 esi
  0009c	8b cd		 mov	 ecx, ebp
  0009e	89 44 24 1c	 mov	 DWORD PTR $T188048[esp+636], eax
  000a2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000aa	8b 54 24 18	 mov	 edx, DWORD PTR $T188048[esp+632]
  000ae	89 11		 mov	 DWORD PTR [ecx], edx
  000b0	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 114  : 		ar << m_pActMover->GetStateFlag();

  000b3	8b 83 10 41 00
	00		 mov	 eax, DWORD PTR [ebx+16656]
  000b9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bc	89 4c 24 18	 mov	 DWORD PTR $T188055[esp+632], ecx
  000c0	56		 push	 esi
  000c1	8b cd		 mov	 ecx, ebp
  000c3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c8	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  000cb	8b 44 24 18	 mov	 eax, DWORD PTR $T188055[esp+632]
  000cf	89 02		 mov	 DWORD PTR [edx], eax
  000d1	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 115  : 		ar << (u_char)m_dwBelligerence;

  000d4	8a 4b 5c	 mov	 cl, BYTE PTR [ebx+92]
  000d7	88 4c 24 10	 mov	 BYTE PTR $T188062[esp+632], cl
  000db	6a 01		 push	 1
  000dd	8b cd		 mov	 ecx, ebp
  000df	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000e4	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  000e7	8a 44 24 10	 mov	 al, BYTE PTR $T188062[esp+632]
  000eb	88 02		 mov	 BYTE PTR [edx], al
  000ed	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 116  : #if __VER >= 15 // __PETVIS
; 117  : 		ar << m_dwMoverSfxId;

  000f0	8b 8b 2c 42 00
	00		 mov	 ecx, DWORD PTR [ebx+16940]
  000f6	89 4c 24 18	 mov	 DWORD PTR $T188066[esp+632], ecx
  000fa	56		 push	 esi
  000fb	8b cd		 mov	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00102	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00105	8b 44 24 18	 mov	 eax, DWORD PTR $T188066[esp+632]
  00109	89 02		 mov	 DWORD PTR [edx], eax
  0010b	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 118  : #endif // __PETVIS
; 119  : 		if( m_bPlayer )	// PLAYER

  0010e	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  00114	85 c0		 test	 eax, eax
  00116	0f 84 d7 0a 00
	00		 je	 $L187333

; 120  : 		{
; 121  : 			ar.WriteString( m_szName );

  0011c	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  0011f	51		 push	 ecx
  00120	8b cd		 mov	 ecx, ebp
  00122	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 122  : 			ar << GetSex();

  00127	8a 93 b8 00 00
	00		 mov	 dl, BYTE PTR [ebx+184]
  0012d	6a 01		 push	 1
  0012f	8b cd		 mov	 ecx, ebp
  00131	88 54 24 14	 mov	 BYTE PTR $T188070[esp+636], dl
  00135	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0013a	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0013d	8a 4c 24 10	 mov	 cl, BYTE PTR $T188070[esp+632]
  00141	88 08		 mov	 BYTE PTR [eax], cl
  00143	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 123  : 			ar << (u_char)m_dwSkinSet;

  00146	8a 93 a0 00 00
	00		 mov	 dl, BYTE PTR [ebx+160]
  0014c	6a 01		 push	 1
  0014e	8b cd		 mov	 ecx, ebp
  00150	88 54 24 14	 mov	 BYTE PTR $T188077[esp+636], dl
  00154	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00159	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0015c	8a 4c 24 10	 mov	 cl, BYTE PTR $T188077[esp+632]
  00160	88 08		 mov	 BYTE PTR [eax], cl
  00162	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 124  : 			ar << (u_char)m_dwHairMesh;

  00165	8a 93 a4 00 00
	00		 mov	 dl, BYTE PTR [ebx+164]
  0016b	6a 01		 push	 1
  0016d	8b cd		 mov	 ecx, ebp
  0016f	88 54 24 14	 mov	 BYTE PTR $T188081[esp+636], dl
  00173	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00178	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0017b	8a 4c 24 10	 mov	 cl, BYTE PTR $T188081[esp+632]
  0017f	88 08		 mov	 BYTE PTR [eax], cl
  00181	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 125  : 			ar << m_dwHairColor;

  00184	8b 93 a8 00 00
	00		 mov	 edx, DWORD PTR [ebx+168]
  0018a	56		 push	 esi
  0018b	8b cd		 mov	 ecx, ebp
  0018d	89 54 24 1c	 mov	 DWORD PTR $T188085[esp+636], edx
  00191	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00196	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00199	8b 4c 24 18	 mov	 ecx, DWORD PTR $T188085[esp+632]
  0019d	89 08		 mov	 DWORD PTR [eax], ecx
  0019f	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 126  : 			ar << (u_char)m_dwHeadMesh;

  001a2	8a 93 ac 00 00
	00		 mov	 dl, BYTE PTR [ebx+172]
  001a8	6a 01		 push	 1
  001aa	8b cd		 mov	 ecx, ebp
  001ac	88 54 24 14	 mov	 BYTE PTR $T188089[esp+636], dl
  001b0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001b5	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  001b8	8a 4c 24 10	 mov	 cl, BYTE PTR $T188089[esp+632]
  001bc	88 08		 mov	 BYTE PTR [eax], cl
  001be	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 127  : 			ar << m_idPlayer;

  001c1	8b 93 90 00 00
	00		 mov	 edx, DWORD PTR [ebx+144]
  001c7	56		 push	 esi
  001c8	8b cd		 mov	 ecx, ebp
  001ca	89 54 24 1c	 mov	 DWORD PTR $T188093[esp+636], edx
  001ce	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001d3	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  001d6	8b 4c 24 18	 mov	 ecx, DWORD PTR $T188093[esp+632]
  001da	89 08		 mov	 DWORD PTR [eax], ecx
  001dc	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 128  : 			ar << (u_char)m_nJob;

  001df	8a 93 c4 00 00
	00		 mov	 dl, BYTE PTR [ebx+196]
  001e5	6a 01		 push	 1
  001e7	8b cd		 mov	 ecx, ebp
  001e9	88 54 24 14	 mov	 BYTE PTR $T188097[esp+636], dl
  001ed	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001f2	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  001f5	8a 4c 24 10	 mov	 cl, BYTE PTR $T188097[esp+632]
  001f9	88 08		 mov	 BYTE PTR [eax], cl
  001fb	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 129  : 			ar << (u_short)m_nStr;

  001fe	66 8b 93 d4 00
	00 00		 mov	 dx, WORD PTR [ebx+212]
  00205	57		 push	 edi
  00206	8b cd		 mov	 ecx, ebp
  00208	66 89 54 24 1c	 mov	 WORD PTR $T188101[esp+636], dx
  0020d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00212	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00215	66 8b 4c 24 18	 mov	 cx, WORD PTR $T188101[esp+632]
  0021a	66 89 08	 mov	 WORD PTR [eax], cx
  0021d	01 7d 08	 add	 DWORD PTR [ebp+8], edi

; 130  : 			ar << (u_short)m_nSta;

  00220	66 8b 93 d8 00
	00 00		 mov	 dx, WORD PTR [ebx+216]
  00227	57		 push	 edi
  00228	8b cd		 mov	 ecx, ebp
  0022a	66 89 54 24 1c	 mov	 WORD PTR $T188105[esp+636], dx
  0022f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00234	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00237	66 8b 4c 24 18	 mov	 cx, WORD PTR $T188105[esp+632]
  0023c	66 89 08	 mov	 WORD PTR [eax], cx
  0023f	01 7d 08	 add	 DWORD PTR [ebp+8], edi

; 131  : 			ar << (u_short)m_nDex;

  00242	66 8b 93 dc 00
	00 00		 mov	 dx, WORD PTR [ebx+220]
  00249	57		 push	 edi
  0024a	8b cd		 mov	 ecx, ebp
  0024c	66 89 54 24 1c	 mov	 WORD PTR $T188109[esp+636], dx
  00251	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00256	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00259	66 8b 4c 24 18	 mov	 cx, WORD PTR $T188109[esp+632]
  0025e	66 89 08	 mov	 WORD PTR [eax], cx
  00261	01 7d 08	 add	 DWORD PTR [ebp+8], edi

; 132  : 			ar << (u_short)m_nInt;

  00264	66 8b 93 e0 00
	00 00		 mov	 dx, WORD PTR [ebx+224]
  0026b	57		 push	 edi
  0026c	8b cd		 mov	 ecx, ebp
  0026e	66 89 54 24 1c	 mov	 WORD PTR $T188113[esp+636], dx
  00273	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00278	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0027b	66 8b 4c 24 18	 mov	 cx, WORD PTR $T188113[esp+632]
  00280	66 89 08	 mov	 WORD PTR [eax], cx
  00283	01 7d 08	 add	 DWORD PTR [ebp+8], edi

; 133  : 			ar << (u_short)m_nLevel;

  00286	66 8b 93 e4 00
	00 00		 mov	 dx, WORD PTR [ebx+228]
  0028d	57		 push	 edi
  0028e	8b cd		 mov	 ecx, ebp
  00290	66 89 54 24 1c	 mov	 WORD PTR $T188117[esp+636], dx
  00295	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0029a	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0029d	66 8b 4c 24 18	 mov	 cx, WORD PTR $T188117[esp+632]
  002a2	66 89 08	 mov	 WORD PTR [eax], cx
  002a5	01 7d 08	 add	 DWORD PTR [ebp+8], edi

; 134  : 			ar << m_nFuel;

  002a8	8b bb c0 00 00
	00		 mov	 edi, DWORD PTR [ebx+192]
  002ae	56		 push	 esi
  002af	8b cd		 mov	 ecx, ebp
  002b1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002b6	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  002b9	89 3a		 mov	 DWORD PTR [edx], edi
  002bb	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 135  : 			ar << m_tmAccFuel;

  002be	8b bb ec 41 00
	00		 mov	 edi, DWORD PTR [ebx+16876]
  002c4	56		 push	 esi
  002c5	8b cd		 mov	 ecx, ebp
  002c7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002cc	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  002cf	89 38		 mov	 DWORD PTR [eax], edi
  002d1	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 136  : 			if( m_idGuild > 0 )

  002d4	8b 83 cc 40 00
	00		 mov	 eax, DWORD PTR [ebx+16588]
  002da	85 c0		 test	 eax, eax

; 137  : 			{
; 138  : 				ar << (u_char)1;

  002dc	8b cd		 mov	 ecx, ebp
  002de	6a 01		 push	 1
  002e0	76 3e		 jbe	 SHORT $L187343
  002e2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002e7	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  002ea	c6 01 01	 mov	 BYTE PTR [ecx], 1
  002ed	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 139  : 				ar << m_idGuild;

  002f0	8b bb cc 40 00
	00		 mov	 edi, DWORD PTR [ebx+16588]
  002f6	56		 push	 esi
  002f7	8b cd		 mov	 ecx, ebp
  002f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002fe	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00301	89 3a		 mov	 DWORD PTR [edx], edi
  00303	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 140  : 				ar << m_idWar;

  00306	8b bb d0 40 00
	00		 mov	 edi, DWORD PTR [ebx+16592]
  0030c	56		 push	 esi
  0030d	8b cd		 mov	 ecx, ebp
  0030f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00314	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00317	89 38		 mov	 DWORD PTR [eax], edi
  00319	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0031c	03 c6		 add	 eax, esi

; 141  : 			}
; 142  : 			else

  0031e	eb 0f		 jmp	 SHORT $L189336
$L187343:

; 143  : 			{
; 144  : 				ar << (u_char)0;

  00320	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00325	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00328	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0032b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0032e	40		 inc	 eax
$L189336:
  0032f	89 45 08	 mov	 DWORD PTR [ebp+8], eax

; 145  : 			}
; 146  : 			ar << m_idGuildCloak;

  00332	8b bb d0 00 00
	00		 mov	 edi, DWORD PTR [ebx+208]
  00338	56		 push	 esi
  00339	8b cd		 mov	 ecx, ebp
  0033b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00340	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00343	89 3a		 mov	 DWORD PTR [edx], edi
  00345	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 147  : 
; 148  : 			if( m_idparty > 0 )

  00348	8b 83 c8 40 00
	00		 mov	 eax, DWORD PTR [ebx+16584]
  0034e	85 c0		 test	 eax, eax

; 149  : 			{
; 150  : 				ar << (u_char)1;

  00350	8b cd		 mov	 ecx, ebp
  00352	6a 01		 push	 1
  00354	76 3e		 jbe	 SHORT $L187347
  00356	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0035b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0035e	c6 00 01	 mov	 BYTE PTR [eax], 1
  00361	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 151  : 				ar << m_idparty;

  00364	8b bb c8 40 00
	00		 mov	 edi, DWORD PTR [ebx+16584]
  0036a	56		 push	 esi
  0036b	8b cd		 mov	 ecx, ebp
  0036d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00372	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00375	89 39		 mov	 DWORD PTR [ecx], edi
  00377	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 152  : 				ar << m_idDuelParty;

  0037a	8b bb 00 41 00
	00		 mov	 edi, DWORD PTR [ebx+16640]
  00380	56		 push	 esi
  00381	8b cd		 mov	 ecx, ebp
  00383	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00388	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  0038b	89 3a		 mov	 DWORD PTR [edx], edi
  0038d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00390	03 c6		 add	 eax, esi

; 153  : 			}
; 154  : 			else

  00392	eb 0f		 jmp	 SHORT $L189337
$L187347:

; 155  : 			{
; 156  : 				ar << (u_char)0;

  00394	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00399	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0039c	c6 00 00	 mov	 BYTE PTR [eax], 0
  0039f	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  003a2	40		 inc	 eax
$L189337:
  003a3	89 45 08	 mov	 DWORD PTR [ebp+8], eax

; 157  : 			}
; 158  : 
; 159  : 			ar << (char)m_dwAuthorization;

  003a6	8a 8b e0 02 00
	00		 mov	 cl, BYTE PTR [ebx+736]
  003ac	88 4c 24 10	 mov	 BYTE PTR $T188176[esp+632], cl
  003b0	6a 01		 push	 1
  003b2	8b cd		 mov	 ecx, ebp
  003b4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  003b9	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  003bc	8a 44 24 10	 mov	 al, BYTE PTR $T188176[esp+632]
  003c0	88 02		 mov	 BYTE PTR [edx], al
  003c2	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 160  : 			ar << m_dwMode;

  003c5	8b bb e4 02 00
	00		 mov	 edi, DWORD PTR [ebx+740]
  003cb	56		 push	 esi
  003cc	8b cd		 mov	 ecx, ebp
  003ce	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  003d3	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  003d6	89 39		 mov	 DWORD PTR [ecx], edi
  003d8	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 161  : 			ar << m_dwStateMode;

  003db	8b bb 98 46 00
	00		 mov	 edi, DWORD PTR [ebx+18072]
  003e1	56		 push	 esi
  003e2	8b cd		 mov	 ecx, ebp
  003e4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  003e9	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  003ec	89 3a		 mov	 DWORD PTR [edx], edi
  003ee	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 162  :  #ifdef __WORLDSERVER
; 163  : 			CItemElem* pItemElem = m_Inventory.GetAtId( m_dwUseItemId );
; 164  : 			if( pItemElem )
; 165  : 				ar << pItemElem->GetProp()->dwID;
; 166  : 			else
; 167  : 				ar << (OBJID)0;
; 168  :  #else // __WORLDSERVER
; 169  : 			ar << m_dwUseItemId;

  003f1	8b bb 9c 46 00
	00		 mov	 edi, DWORD PTR [ebx+18076]
  003f7	56		 push	 esi
  003f8	8b cd		 mov	 ecx, ebp
  003fa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  003ff	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00402	89 38		 mov	 DWORD PTR [eax], edi
  00404	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 170  :  #endif // __WORLDSERVER
; 171  : #if __VER >= 8 // __S8_PK
; 172  : 			if( m_dwPKTime > 0 )

  00407	8b bb d4 40 00
	00		 mov	 edi, DWORD PTR [ebx+16596]

; 173  : 	#ifdef __WORLDSERVER
; 174  : 				ar << ( m_dwPKTime - GetTickCount() );
; 175  : 	#else // __WORLDSERVER
; 176  : 				ar << m_dwPKTime;

  0040d	8b cd		 mov	 ecx, ebp
  0040f	56		 push	 esi
  00410	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00415	85 ff		 test	 edi, edi
  00417	76 07		 jbe	 SHORT $L187352
  00419	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0041c	89 39		 mov	 DWORD PTR [ecx], edi

; 177  : 	#endif // __WORLDSERVER
; 178  : 			else

  0041e	eb 05		 jmp	 SHORT $L189338
$L187352:

; 179  : 				ar << m_dwPKTime;

  00420	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00423	89 3a		 mov	 DWORD PTR [edx], edi
$L189338:
  00425	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 180  : 			ar << m_nPKValue;

  00428	8b bb d8 40 00
	00		 mov	 edi, DWORD PTR [ebx+16600]
  0042e	56		 push	 esi
  0042f	8b cd		 mov	 ecx, ebp
  00431	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00436	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00439	89 38		 mov	 DWORD PTR [eax], edi
  0043b	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 181  : 			ar << m_dwPKPropensity;

  0043e	8b bb dc 40 00
	00		 mov	 edi, DWORD PTR [ebx+16604]
  00444	56		 push	 esi
  00445	8b cd		 mov	 ecx, ebp
  00447	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0044c	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0044f	89 39		 mov	 DWORD PTR [ecx], edi
  00451	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 182  : 			ar << m_dwPKExp;

  00454	8b bb e0 40 00
	00		 mov	 edi, DWORD PTR [ebx+16608]
  0045a	56		 push	 esi
  0045b	8b cd		 mov	 ecx, ebp
  0045d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00462	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00465	89 3a		 mov	 DWORD PTR [edx], edi
  00467	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 183  : #else // __VER >= 8 // __S8_PK
; 184  : 			ar << (u_short)m_nNumKill;
; 185  : 			ar << m_nSlaughter;
; 186  : #endif // __VER >= 8 // __S8_PK
; 187  : 			ar << m_nFame;

  0046a	8b bb f4 40 00
	00		 mov	 edi, DWORD PTR [ebx+16628]
  00470	56		 push	 esi
  00471	8b cd		 mov	 ecx, ebp
  00473	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00478	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0047b	89 38		 mov	 DWORD PTR [eax], edi
  0047d	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 188  : 			ar << (u_char)m_nDuel;

  00480	8a 8b fc 40 00
	00		 mov	 cl, BYTE PTR [ebx+16636]
  00486	88 4c 24 10	 mov	 BYTE PTR $T188226[esp+632], cl
  0048a	6a 01		 push	 1
  0048c	8b cd		 mov	 ecx, ebp
  0048e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00493	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00496	8a 44 24 10	 mov	 al, BYTE PTR $T188226[esp+632]
  0049a	88 02		 mov	 BYTE PTR [edx], al
  0049c	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 189  : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 190  : 			ar << m_nHonor;					//  

  0049f	8b bb 44 42 00
	00		 mov	 edi, DWORD PTR [ebx+16964]
  004a5	56		 push	 esi
  004a6	8b cd		 mov	 ecx, ebp
  004a8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  004ad	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  004b0	89 39		 mov	 DWORD PTR [ecx], edi
  004b2	01 75 08	 add	 DWORD PTR [ebp+8], esi
  004b5	8d bb 28 45 00
	00		 lea	 edi, DWORD PTR [ebx+17704]
  004bb	c7 44 24 1c 1f
	00 00 00	 mov	 DWORD PTR tv2550[esp+632], 31 ; 0000001fH
$L187356:

; 191  : #endif	// __HONORABLE_TITLE			// 
; 192  : 			{
; 193  : 				int i;
; 194  : 				for( i = 0; i < MAX_HUMAN_PARTS; i ++ )
; 195  : 				{
; 196  : 					ar << m_aEquipInfo[i].nOption;

  004c3	8b 17		 mov	 edx, DWORD PTR [edi]
  004c5	56		 push	 esi
  004c6	8b cd		 mov	 ecx, ebp
  004c8	89 54 24 1c	 mov	 DWORD PTR $T188244[esp+636], edx
  004cc	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  004d1	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  004d4	8b 4c 24 18	 mov	 ecx, DWORD PTR $T188244[esp+632]
  004d8	89 08		 mov	 DWORD PTR [eax], ecx
  004da	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  004dd	8b 44 24 1c	 mov	 eax, DWORD PTR tv2550[esp+632]
  004e1	03 d6		 add	 edx, esi
  004e3	83 c7 0c	 add	 edi, 12			; 0000000cH
  004e6	48		 dec	 eax
  004e7	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  004ea	89 44 24 1c	 mov	 DWORD PTR tv2550[esp+632], eax
  004ee	75 d3		 jne	 SHORT $L187356

; 197  : 				}
; 198  : 			}
; 199  : 			ar << m_nGuildCombatState;

  004f0	8b bb 04 41 00
	00		 mov	 edi, DWORD PTR [ebx+16644]
  004f6	56		 push	 esi
  004f7	8b cd		 mov	 ecx, ebp
  004f9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  004fe	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00501	89 3a		 mov	 DWORD PTR [edx], edi
  00503	01 75 08	 add	 DWORD PTR [ebp+8], esi
  00506	8d bb a4 44 00
	00		 lea	 edi, DWORD PTR [ebx+17572]
  0050c	c7 44 24 1c 1a
	00 00 00	 mov	 DWORD PTR tv3038[esp+632], 26 ; 0000001aH
$L187360:

; 200  : 			
; 201  : 			for( int j = 0 ; j < SM_MAX ; ++j )
; 202  : 				ar << m_dwSMTime[j];

  00514	8b 07		 mov	 eax, DWORD PTR [edi]
  00516	56		 push	 esi
  00517	8b cd		 mov	 ecx, ebp
  00519	89 44 24 1c	 mov	 DWORD PTR $T188257[esp+636], eax
  0051d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00522	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00525	8b 54 24 18	 mov	 edx, DWORD PTR $T188257[esp+632]
  00529	89 11		 mov	 DWORD PTR [ecx], edx
  0052b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0052e	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv3038[esp+632]
  00532	03 c6		 add	 eax, esi
  00534	03 fe		 add	 edi, esi
  00536	49		 dec	 ecx
  00537	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  0053a	89 4c 24 1c	 mov	 DWORD PTR tv3038[esp+632], ecx
  0053e	75 d4		 jne	 SHORT $L187360

; 203  : 
; 204  : 			if( CObj::GetMethod() == METHOD_NONE )

  00540	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_nMethod@CObj@@2HA ; CObj::m_nMethod
  00546	85 c9		 test	 ecx, ecx
  00548	0f 85 30 05 00
	00		 jne	 $L187363

; 205  : 			{
; 206  : 				ar << (u_short)m_nManaPoint;

  0054e	66 8b bb 98 00
	00 00		 mov	 di, WORD PTR [ebx+152]
  00555	6a 02		 push	 2
  00557	8b cd		 mov	 ecx, ebp
  00559	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0055e	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00561	66 89 38	 mov	 WORD PTR [eax], di
  00564	83 45 08 02	 add	 DWORD PTR [ebp+8], 2

; 207  : 				ar << (u_short)m_nFatiguePoint;

  00568	66 8b bb 9c 00
	00 00		 mov	 di, WORD PTR [ebx+156]
  0056f	6a 02		 push	 2
  00571	8b cd		 mov	 ecx, ebp
  00573	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00578	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0057b	66 89 39	 mov	 WORD PTR [ecx], di
  0057e	83 45 08 02	 add	 DWORD PTR [ebp+8], 2

; 208  : #if __VER >= 12 // __MOD_TUTORIAL
; 209  : 				ar << m_nTutorialState;

  00582	8b bb b0 00 00
	00		 mov	 edi, DWORD PTR [ebx+176]
  00588	56		 push	 esi
  00589	8b cd		 mov	 ecx, ebp
  0058b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00590	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00593	89 3a		 mov	 DWORD PTR [edx], edi
  00595	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 210  : #else	// __MOD_TUTORIAL
; 211  : 				ar << (u_short)m_nFlightLv;
; 212  : #endif	// __MOD_TUTORIAL
; 213  : 				ar << m_nFxp;

  00598	8b bb b4 00 00
	00		 mov	 edi, DWORD PTR [ebx+180]
  0059e	56		 push	 esi
  0059f	8b cd		 mov	 ecx, ebp
  005a1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  005a6	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  005a9	89 38		 mov	 DWORD PTR [eax], edi
  005ab	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 214  : 				
; 215  : 				dwGold = GetGold();
; 216  : 				ar << dwGold;

  005ae	8b 7b 34	 mov	 edi, DWORD PTR [ebx+52]
  005b1	56		 push	 esi
  005b2	8b cd		 mov	 ecx, ebp
  005b4	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  005b9	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  005bc	89 39		 mov	 DWORD PTR [ecx], edi
  005be	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 217  : 				ar << m_nExp1;

  005c1	8b 93 f0 00 00
	00		 mov	 edx, DWORD PTR [ebx+240]
  005c7	8b 83 f4 00 00
	00		 mov	 eax, DWORD PTR [ebx+244]
  005cd	6a 08		 push	 8
  005cf	8d 8c 24 64 02
	00 00		 lea	 ecx, DWORD PTR $T188293[esp+636]
  005d6	51		 push	 ecx
  005d7	8b cd		 mov	 ecx, ebp
  005d9	89 94 24 68 02
	00 00		 mov	 DWORD PTR $T188293[esp+640], edx
  005e0	89 84 24 6c 02
	00 00		 mov	 DWORD PTR $T188293[esp+644], eax
  005e7	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 218  : 				ar << m_nSkillLevel;

  005ec	8b bb 08 41 00
	00		 mov	 edi, DWORD PTR [ebx+16648]
  005f2	56		 push	 esi
  005f3	8b cd		 mov	 ecx, ebp
  005f5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  005fa	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  005fd	89 3a		 mov	 DWORD PTR [edx], edi
  005ff	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 219  : 				ar << m_nSkillPoint;

  00602	8b bb 0c 41 00
	00		 mov	 edi, DWORD PTR [ebx+16652]
  00608	56		 push	 esi
  00609	8b cd		 mov	 ecx, ebp
  0060b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00610	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00613	89 38		 mov	 DWORD PTR [eax], edi
  00615	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 220  : 				ar << m_nDeathExp;

  00618	8b 8b f8 00 00
	00		 mov	 ecx, DWORD PTR [ebx+248]
  0061e	8b 93 fc 00 00
	00		 mov	 edx, DWORD PTR [ebx+252]
  00624	6a 08		 push	 8
  00626	8d 84 24 64 02
	00 00		 lea	 eax, DWORD PTR $T188315[esp+636]
  0062d	89 8c 24 64 02
	00 00		 mov	 DWORD PTR $T188315[esp+636], ecx
  00634	50		 push	 eax
  00635	8b cd		 mov	 ecx, ebp
  00637	89 94 24 6c 02
	00 00		 mov	 DWORD PTR $T188315[esp+644], edx
  0063e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 221  : 				ar << m_nDeathLevel;

  00643	8b bb e8 00 00
	00		 mov	 edi, DWORD PTR [ebx+232]
  00649	56		 push	 esi
  0064a	8b cd		 mov	 ecx, ebp
  0064c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00651	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00654	89 39		 mov	 DWORD PTR [ecx], edi
  00656	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 222  : 				DWORD dwJobLv[MAX_JOB] = {0, };

  00659	33 c0		 xor	 eax, eax
  0065b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _dwJobLv$187366[esp+632], 0
  00663	b9 27 00 00 00	 mov	 ecx, 39			; 00000027H
  00668	8d 7c 24 2c	 lea	 edi, DWORD PTR _dwJobLv$187366[esp+636]

; 223  : 				ar.Write( (void*)dwJobLv, sizeof(DWORD) * MAX_JOB );

  0066c	68 a0 00 00 00	 push	 160			; 000000a0H
  00671	8d 54 24 2c	 lea	 edx, DWORD PTR _dwJobLv$187366[esp+636]
  00675	f3 ab		 rep stosd
  00677	52		 push	 edx
  00678	8b cd		 mov	 ecx, ebp
  0067a	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 224  : 				ar << m_idMarkingWorld;

  0067f	8b bb cc 02 00
	00		 mov	 edi, DWORD PTR [ebx+716]
  00685	56		 push	 esi
  00686	8b cd		 mov	 ecx, ebp
  00688	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0068d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00690	89 38		 mov	 DWORD PTR [eax], edi
  00692	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 225  : 				ar << m_vMarkingPos;

  00695	8d 8b d0 02 00
	00		 lea	 ecx, DWORD PTR [ebx+720]
  0069b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0069d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  006a0	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  006a3	89 94 24 60 02
	00 00		 mov	 DWORD PTR $T188327[esp+632], edx
  006aa	6a 0c		 push	 12			; 0000000cH
  006ac	8d 94 24 64 02
	00 00		 lea	 edx, DWORD PTR $T188327[esp+636]
  006b3	89 8c 24 6c 02
	00 00		 mov	 DWORD PTR $T188327[esp+644], ecx
  006ba	52		 push	 edx
  006bb	8b cd		 mov	 ecx, ebp
  006bd	89 84 24 6c 02
	00 00		 mov	 DWORD PTR $T188327[esp+644], eax
  006c4	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 226  : 				ar << m_nQuestSize;

  006c9	8a 83 a8 46 00
	00		 mov	 al, BYTE PTR [ebx+18088]
  006cf	6a 01		 push	 1
  006d1	8b cd		 mov	 ecx, ebp
  006d3	88 44 24 14	 mov	 BYTE PTR $T188331[esp+636], al
  006d7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  006dc	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  006df	8a 54 24 10	 mov	 dl, BYTE PTR $T188331[esp+632]
  006e3	88 11		 mov	 BYTE PTR [ecx], dl
  006e5	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 227  : 				ar.Write( m_aQuest, sizeof(QUEST) * m_nQuestSize );

  006e8	0f b6 83 a8 46
	00 00		 movzx	 eax, BYTE PTR [ebx+18088]
  006ef	8b 8b a0 46 00
	00		 mov	 ecx, DWORD PTR [ebx+18080]
  006f5	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  006f8	c1 e0 02	 shl	 eax, 2
  006fb	50		 push	 eax
  006fc	51		 push	 ecx
  006fd	8b cd		 mov	 ecx, ebp
  006ff	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 228  : 				ar << m_nCompleteQuestSize;

  00704	8a 93 a9 46 00
	00		 mov	 dl, BYTE PTR [ebx+18089]
  0070a	6a 01		 push	 1
  0070c	8b cd		 mov	 ecx, ebp
  0070e	88 54 24 14	 mov	 BYTE PTR $T188335[esp+636], dl
  00712	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00717	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0071a	8a 4c 24 10	 mov	 cl, BYTE PTR $T188335[esp+632]
  0071e	88 08		 mov	 BYTE PTR [eax], cl
  00720	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 229  : 				ar.Write( m_aCompleteQuest, sizeof(WORD) * m_nCompleteQuestSize ); 

  00723	0f b6 93 a9 46
	00 00		 movzx	 edx, BYTE PTR [ebx+18089]
  0072a	8b 83 a4 46 00
	00		 mov	 eax, DWORD PTR [ebx+18084]
  00730	d1 e2		 shl	 edx, 1
  00732	52		 push	 edx
  00733	50		 push	 eax
  00734	8b cd		 mov	 ecx, ebp
  00736	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 230  : 
; 231  : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 232  : 				ar << m_nCheckedQuestSize;

  0073b	8a 8b c0 46 00
	00		 mov	 cl, BYTE PTR [ebx+18112]
  00741	88 4c 24 10	 mov	 BYTE PTR $T188339[esp+632], cl
  00745	6a 01		 push	 1
  00747	8b cd		 mov	 ecx, ebp
  00749	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0074e	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00751	8a 44 24 10	 mov	 al, BYTE PTR $T188339[esp+632]
  00755	88 02		 mov	 BYTE PTR [edx], al
  00757	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 233  : 				ar.Write( m_aCheckedQuest, sizeof(WORD) * m_nCheckedQuestSize ); 

  0075a	0f b6 8b c0 46
	00 00		 movzx	 ecx, BYTE PTR [ebx+18112]
  00761	8b 93 bc 46 00
	00		 mov	 edx, DWORD PTR [ebx+18108]
  00767	d1 e1		 shl	 ecx, 1
  00769	51		 push	 ecx
  0076a	52		 push	 edx
  0076b	8b cd		 mov	 ecx, ebp
  0076d	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 234  : #endif // __IMPROVE_QUEST_INTERFACE
; 235  : 
; 236  : 				ar << m_idMurderer;

  00772	8b bb f8 40 00
	00		 mov	 edi, DWORD PTR [ebx+16632]
  00778	56		 push	 esi
  00779	8b cd		 mov	 ecx, ebp
  0077b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00780	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00783	89 38		 mov	 DWORD PTR [eax], edi
  00785	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 237  : 				ar << (short)m_nRemainGP;

  00788	66 8b bb dc 02
	00 00		 mov	 di, WORD PTR [ebx+732]
  0078f	6a 02		 push	 2
  00791	8b cd		 mov	 ecx, ebp
  00793	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00798	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0079b	66 89 39	 mov	 WORD PTR [ecx], di
  0079e	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  007a1	bf 02 00 00 00	 mov	 edi, 2
  007a6	03 d7		 add	 edx, edi

; 238  : 				ar << (short)0;

  007a8	57		 push	 edi
  007a9	8b cd		 mov	 ecx, ebp
  007ab	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  007ae	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  007b3	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  007b6	66 c7 02 00 00	 mov	 WORD PTR [edx], 0
  007bb	01 7d 08	 add	 DWORD PTR [ebp+8], edi
  007be	8d bb 24 45 00
	00		 lea	 edi, DWORD PTR [ebx+17700]
  007c4	c7 44 24 1c 1f
	00 00 00	 mov	 DWORD PTR tv1016[esp+632], 31 ; 0000001fH
  007cc	8d 64 24 00	 npad	 4
$L187375:

; 239  : 				{
; 240  : 					for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 241  : 						ar << m_aEquipInfo[i].dwId;

  007d0	8b 07		 mov	 eax, DWORD PTR [edi]
  007d2	56		 push	 esi
  007d3	8b cd		 mov	 ecx, ebp
  007d5	89 44 24 1c	 mov	 DWORD PTR $T188365[esp+636], eax
  007d9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  007de	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  007e1	8b 54 24 18	 mov	 edx, DWORD PTR $T188365[esp+632]
  007e5	8b 44 24 1c	 mov	 eax, DWORD PTR tv1016[esp+632]
  007e9	89 11		 mov	 DWORD PTR [ecx], edx
  007eb	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  007ee	03 d6		 add	 edx, esi
  007f0	83 c7 0c	 add	 edi, 12			; 0000000cH
  007f3	48		 dec	 eax
  007f4	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  007f7	89 44 24 1c	 mov	 DWORD PTR tv1016[esp+632], eax
  007fb	75 d3		 jne	 SHORT $L187375

; 242  : 				}
; 243  : 				ar.Write( (void*)m_aJobSkill, sizeof(SKILL) *  ( MAX_SKILL_JOB ) );

  007fd	68 98 01 00 00	 push	 408			; 00000198H
  00802	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  00808	50		 push	 eax
  00809	8b cd		 mov	 ecx, ebp
  0080b	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 244  : 				
; 245  : 				ar << (BYTE)m_nCheerPoint << m_dwTickCheer - GetTickCount();

  00810	8a 8b b4 46 00
	00		 mov	 cl, BYTE PTR [ebx+18100]
  00816	88 4c 24 10	 mov	 BYTE PTR $T188369[esp+632], cl
  0081a	6a 01		 push	 1
  0081c	8b cd		 mov	 ecx, ebp
  0081e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00823	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00826	8a 44 24 10	 mov	 al, BYTE PTR $T188369[esp+632]
  0082a	88 02		 mov	 BYTE PTR [edx], al
  0082c	ff 45 08	 inc	 DWORD PTR [ebp+8]
  0082f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00835	8b bb b0 46 00
	00		 mov	 edi, DWORD PTR [ebx+18096]
  0083b	56		 push	 esi
  0083c	8b cd		 mov	 ecx, ebp
  0083e	2b f8		 sub	 edi, eax
  00840	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00845	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00848	89 39		 mov	 DWORD PTR [ecx], edi
  0084a	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 246  : 
; 247  : 				ar << m_nSlot;

  0084d	8a 93 c8 00 00
	00		 mov	 dl, BYTE PTR [ebx+200]
  00853	6a 01		 push	 1
  00855	8b cd		 mov	 ecx, ebp
  00857	88 54 24 14	 mov	 BYTE PTR $T188377[esp+636], dl
  0085b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00860	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00863	8a 4c 24 10	 mov	 cl, BYTE PTR $T188377[esp+632]
  00867	88 08		 mov	 BYTE PTR [eax], cl
  00869	ff 45 08	 inc	 DWORD PTR [ebp+8]
  0086c	8d bb d0 41 00
	00		 lea	 edi, DWORD PTR [ebx+16848]
  00872	c7 44 24 1c 03
	00 00 00	 mov	 DWORD PTR tv2489[esp+632], 3
  0087a	8d 9b 00 00 00
	00		 npad	 6
$L187382:

; 248  : 				for( int k = 0 ; k < 3 ; ++k )
; 249  : 					ar << m_dwGoldBank[k];

  00880	8b 17		 mov	 edx, DWORD PTR [edi]
  00882	56		 push	 esi
  00883	8b cd		 mov	 ecx, ebp
  00885	89 54 24 1c	 mov	 DWORD PTR $T188381[esp+636], edx
  00889	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0088e	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00891	8b 4c 24 18	 mov	 ecx, DWORD PTR $T188381[esp+632]
  00895	89 08		 mov	 DWORD PTR [eax], ecx
  00897	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  0089a	8b 44 24 1c	 mov	 eax, DWORD PTR tv2489[esp+632]
  0089e	03 d6		 add	 edx, esi
  008a0	03 fe		 add	 edi, esi
  008a2	48		 dec	 eax
  008a3	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  008a6	89 44 24 1c	 mov	 DWORD PTR tv2489[esp+632], eax
  008aa	75 d4		 jne	 SHORT $L187382

; 250  : 				for( k = 0 ; k < 3 ; ++k )

  008ac	8d bb 88 41 00
	00		 lea	 edi, DWORD PTR [ebx+16776]
  008b2	c7 44 24 1c 03
	00 00 00	 mov	 DWORD PTR tv1001[esp+632], 3
  008ba	8d 9b 00 00 00
	00		 npad	 6
$L187385:

; 251  : 					ar << m_idPlayerBank[k];

  008c0	8b 17		 mov	 edx, DWORD PTR [edi]
  008c2	56		 push	 esi
  008c3	8b cd		 mov	 ecx, ebp
  008c5	89 54 24 1c	 mov	 DWORD PTR $T188385[esp+636], edx
  008c9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  008ce	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  008d1	8b 4c 24 18	 mov	 ecx, DWORD PTR $T188385[esp+632]
  008d5	89 08		 mov	 DWORD PTR [eax], ecx
  008d7	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  008da	8b 44 24 1c	 mov	 eax, DWORD PTR tv1001[esp+632]
  008de	03 d6		 add	 edx, esi
  008e0	03 fe		 add	 edi, esi
  008e2	48		 dec	 eax
  008e3	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  008e6	89 44 24 1c	 mov	 DWORD PTR tv1001[esp+632], eax
  008ea	75 d4		 jne	 SHORT $L187385

; 252  : 				ar << m_nPlusMaxHitPoint;

  008ec	8b bb a0 44 00
	00		 mov	 edi, DWORD PTR [ebx+17568]
  008f2	56		 push	 esi
  008f3	8b cd		 mov	 ecx, ebp
  008f5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  008fa	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  008fd	89 3a		 mov	 DWORD PTR [edx], edi
  008ff	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 253  : 				ar << m_nAttackResistLeft;

  00902	8a 83 0c 45 00
	00		 mov	 al, BYTE PTR [ebx+17676]
  00908	6a 01		 push	 1
  0090a	8b cd		 mov	 ecx, ebp
  0090c	88 44 24 14	 mov	 BYTE PTR $T188393[esp+636], al
  00910	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00915	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00918	8a 54 24 10	 mov	 dl, BYTE PTR $T188393[esp+632]
  0091c	88 11		 mov	 BYTE PTR [ecx], dl
  0091e	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 254  : 				ar << m_nAttackResistRight;

  00921	8a 83 0d 45 00
	00		 mov	 al, BYTE PTR [ebx+17677]
  00927	6a 01		 push	 1
  00929	8b cd		 mov	 ecx, ebp
  0092b	88 44 24 14	 mov	 BYTE PTR $T188397[esp+636], al
  0092f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00934	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00937	8a 54 24 10	 mov	 dl, BYTE PTR $T188397[esp+632]
  0093b	88 11		 mov	 BYTE PTR [ecx], dl
  0093d	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 255  : 				ar << m_nDefenseResist;

  00940	8a 83 0e 45 00
	00		 mov	 al, BYTE PTR [ebx+17678]
  00946	6a 01		 push	 1
  00948	8b cd		 mov	 ecx, ebp
  0094a	88 44 24 14	 mov	 BYTE PTR $T188401[esp+636], al
  0094e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00953	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00956	8a 54 24 10	 mov	 dl, BYTE PTR $T188401[esp+632]
  0095a	88 11		 mov	 BYTE PTR [ecx], dl
  0095c	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 256  : #if __VER >= 8 // __CSC_VER8_5
; 257  : 				ar << m_nAngelExp;

  0095f	8b 8b ec 40 00
	00		 mov	 ecx, DWORD PTR [ebx+16620]
  00965	8b 83 e8 40 00
	00		 mov	 eax, DWORD PTR [ebx+16616]
  0096b	6a 08		 push	 8
  0096d	8d 94 24 64 02
	00 00		 lea	 edx, DWORD PTR $T188405[esp+636]
  00974	89 8c 24 68 02
	00 00		 mov	 DWORD PTR $T188405[esp+640], ecx
  0097b	52		 push	 edx
  0097c	8b cd		 mov	 ecx, ebp
  0097e	89 84 24 68 02
	00 00		 mov	 DWORD PTR $T188405[esp+640], eax
  00985	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 258  : 				ar << m_nAngelLevel;

  0098a	8b bb f0 40 00
	00		 mov	 edi, DWORD PTR [ebx+16624]
  00990	56		 push	 esi
  00991	8b cd		 mov	 ecx, ebp
  00993	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00998	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0099b	89 38		 mov	 DWORD PTR [eax], edi
  0099d	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 259  : #endif // __CSC_VER8_5
; 260  : 				m_Inventory.Serialize( ar );

  009a0	55		 push	 ebp
  009a1	8d 8b 14 41 00
	00		 lea	 ecx, DWORD PTR [ebx+16660]
  009a7	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  009ac	8d bb 94 41 00
	00		 lea	 edi, DWORD PTR [ebx+16788]
  009b2	c7 44 24 1c 03
	00 00 00	 mov	 DWORD PTR tv990[esp+632], 3
  009ba	8d 9b 00 00 00
	00		 npad	 6
$L187388:

; 261  : 				for( k = 0 ; k < 3 ; ++k )
; 262  : 					m_Bank[k].Serialize( ar );

  009c0	55		 push	 ebp
  009c1	8b cf		 mov	 ecx, edi
  009c3	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  009c8	8b 44 24 1c	 mov	 eax, DWORD PTR tv990[esp+632]
  009cc	83 c7 14	 add	 edi, 20			; 00000014H
  009cf	48		 dec	 eax
  009d0	89 44 24 1c	 mov	 DWORD PTR tv990[esp+632], eax
  009d4	75 ea		 jne	 SHORT $L187388

; 263  : #if __VER >= 9	// __PET_0410
; 264  : 				ar << GetPetId();	//     

  009d6	8b bb 30 42 00
	00		 mov	 edi, DWORD PTR [ebx+16944]
  009dc	56		 push	 esi
  009dd	8b cd		 mov	 ecx, ebp
  009df	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  009e4	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  009e7	89 39		 mov	 DWORD PTR [ecx], edi
  009e9	8b 7d 08	 mov	 edi, DWORD PTR [ebp+8]
  009ec	03 fe		 add	 edi, esi

; 265  : #endif	// __PET_0410
; 266  : #if __VER >= 11 // __SYS_POCKET
; 267  : 				m_Pocket.Serialize( ar );

  009ee	55		 push	 ebp
  009ef	8d 8b 78 41 00
	00		 lea	 ecx, DWORD PTR [ebx+16760]
  009f5	89 7d 08	 mov	 DWORD PTR [ebp+8], edi
  009f8	e8 00 00 00 00	 call	 ?Serialize@CPocketController@@QAEXAAVCAr@@@Z ; CPocketController::Serialize

; 268  : #endif	// __SYS_POCKET
; 269  : #ifdef __JEFF_9_20
; 270  : 				ar << m_dwMute;

  009fd	8b bb f0 41 00
	00		 mov	 edi, DWORD PTR [ebx+16880]
  00a03	56		 push	 esi
  00a04	8b cd		 mov	 ecx, ebp
  00a06	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a0b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00a0e	89 3a		 mov	 DWORD PTR [edx], edi
  00a10	01 75 08	 add	 DWORD PTR [ebp+8], esi
  00a13	8d bb 48 42 00
	00		 lea	 edi, DWORD PTR [ebx+16968]
  00a19	c7 44 24 1c 96
	00 00 00	 mov	 DWORD PTR tv979[esp+632], 150 ; 00000096H
$L187392:

; 271  : #endif	// __JEFF_9_20
; 272  : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 273  : 				for( int i = 0 ; i < MAX_HONOR_TITLE ; ++i )
; 274  : 				{
; 275  : 					ar << m_aHonorTitle[i];

  00a21	8b 07		 mov	 eax, DWORD PTR [edi]
  00a23	56		 push	 esi
  00a24	8b cd		 mov	 ecx, ebp
  00a26	89 44 24 1c	 mov	 DWORD PTR $T188429[esp+636], eax
  00a2a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a2f	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00a32	8b 54 24 18	 mov	 edx, DWORD PTR $T188429[esp+632]
  00a36	8b 44 24 1c	 mov	 eax, DWORD PTR tv979[esp+632]
  00a3a	89 11		 mov	 DWORD PTR [ecx], edx
  00a3c	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00a3f	03 d6		 add	 edx, esi
  00a41	03 fe		 add	 edi, esi
  00a43	48		 dec	 eax
  00a44	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00a47	89 44 24 1c	 mov	 DWORD PTR tv979[esp+632], eax
  00a4b	75 d4		 jne	 SHORT $L187392

; 276  : 
; 277  : 				}
; 278  : #endif	// __HONORABLE_TITLE			// 
; 279  : #if __VER >= 15 // __CAMPUS
; 280  : 				ar << m_idCampus;

  00a4d	8b bb c4 46 00
	00		 mov	 edi, DWORD PTR [ebx+18116]
  00a53	56		 push	 esi
  00a54	8b cd		 mov	 ecx, ebp
  00a56	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a5b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00a5e	89 38		 mov	 DWORD PTR [eax], edi
  00a60	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 281  : 				ar << m_nCampusPoint;

  00a63	8b bb c8 46 00
	00		 mov	 edi, DWORD PTR [ebx+18120]
  00a69	56		 push	 esi
  00a6a	8b cd		 mov	 ecx, ebp
  00a6c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a71	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00a74	89 39		 mov	 DWORD PTR [ecx], edi

; 355  : #if __VER >= 9	//__AI_0509
; 356  : 			ar << m_fSpeedFactor;

  00a76	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 357  : #endif	// __AI_0509
; 358  : 		}
; 359  : #ifdef __BUFF_1107
; 360  : 		m_buffs.Serialize( ar );
; 361  : #else	// __BUFF_1107
; 362  : 		m_SkillState.Serialize( ar );
; 363  : #endif	// __BUFF_1107
; 364  : 	}
; 365  : 	else	// LOADING

  00a79	e9 83 13 00 00	 jmp	 $L189260
$L187363:

; 282  : #endif // __CAMPUS
; 283  : 			}
; 284  : 			else if( CObj::GetMethod() == METHOD_EXCLUDE_ITEM )

  00a7e	83 f9 01	 cmp	 ecx, 1
  00a81	0f 85 7a 13 00
	00		 jne	 $L189260

; 285  : 			{
; 286  : #	if defined (__WORLDSERVER) || defined(__CLIENT)
; 287  : 				ar.WriteString( m_vtInfo.GetTitle() );
; 288  : #	endif
; 289  : 				u_char uSize	= 0;
; 290  : 				u_long uOffset	= ar.GetOffset();

  00a87	2b 45 10	 sub	 eax, DWORD PTR [ebp+16]

; 291  : 				ar << uSize;

  00a8a	51		 push	 ecx
  00a8b	8b cd		 mov	 ecx, ebp
  00a8d	c6 44 24 14 00	 mov	 BYTE PTR _uSize$187397[esp+636], 0
  00a92	89 44 24 28	 mov	 DWORD PTR _uOffset$187398[esp+636], eax
  00a96	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a9b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00a9e	c6 02 00	 mov	 BYTE PTR [edx], 0
  00aa1	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 292  : 				for( u_char uParts = 0; uParts < MAX_HUMAN_PARTS; uParts++ )

  00aa4	c6 44 24 23 00	 mov	 BYTE PTR _uParts$187399[esp+632], 0
  00aa9	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv5474[esp+632], 0
  00ab1	eb 0d 8d a4 24
	00 00 00 00 8d
	9b 00 00 00 00	 npad	 15
$L189332:

; 293  : 				{
; 294  : 					CItemElem* pItemElem	= m_Inventory.GetEquip( uParts );

  00ac0	8b 83 1c 41 00
	00		 mov	 eax, DWORD PTR [ebx+16668]
  00ac6	8b 54 24 1c	 mov	 edx, DWORD PTR tv5474[esp+632]
  00aca	8b 8b 18 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16664]
  00ad0	03 c2		 add	 eax, edx
  00ad2	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00ad5	83 f8 ff	 cmp	 eax, -1
  00ad8	74 72		 je	 SHORT $L187401
  00ada	8b 8b 20 41 00
	00		 mov	 ecx, DWORD PTR [ebx+16672]
  00ae0	8d 3c 80	 lea	 edi, DWORD PTR [eax+eax*4]
  00ae3	c1 e7 05	 shl	 edi, 5
  00ae6	8b 44 0f 08	 mov	 eax, DWORD PTR [edi+ecx+8]
  00aea	03 f9		 add	 edi, ecx
  00aec	85 c0		 test	 eax, eax
  00aee	74 5c		 je	 SHORT $L187401

; 295  : 					if( pItemElem )
; 296  : 					{
; 297  : 						uSize++;

  00af0	8a 44 24 10	 mov	 al, BYTE PTR _uSize$187397[esp+632]
  00af4	fe c0		 inc	 al

; 298  : 						ar << uParts;

  00af6	6a 01		 push	 1
  00af8	8b cd		 mov	 ecx, ebp
  00afa	88 44 24 14	 mov	 BYTE PTR _uSize$187397[esp+636], al
  00afe	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00b03	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00b06	8a 44 24 23	 mov	 al, BYTE PTR _uParts$187399[esp+632]
  00b0a	88 02		 mov	 BYTE PTR [edx], al
  00b0c	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 299  : 						ar << (u_short)pItemElem->m_dwItemId;

  00b0f	66 8b 4f 08	 mov	 cx, WORD PTR [edi+8]
  00b13	66 89 4c 24 18	 mov	 WORD PTR $T188483[esp+632], cx
  00b18	6a 02		 push	 2
  00b1a	8b cd		 mov	 ecx, ebp
  00b1c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00b21	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00b24	66 8b 44 24 18	 mov	 ax, WORD PTR $T188483[esp+632]
  00b29	66 89 02	 mov	 WORD PTR [edx], ax
  00b2c	83 45 08 02	 add	 DWORD PTR [ebp+8], 2

; 300  : 						ar << pItemElem->m_byFlag;

  00b30	8a 4f 71	 mov	 cl, BYTE PTR [edi+113]
  00b33	88 4c 24 14	 mov	 BYTE PTR $T188487[esp+632], cl
  00b37	6a 01		 push	 1
  00b39	8b cd		 mov	 ecx, ebp
  00b3b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00b40	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00b43	8a 44 24 14	 mov	 al, BYTE PTR $T188487[esp+632]
  00b47	88 02		 mov	 BYTE PTR [edx], al
  00b49	ff 45 08	 inc	 DWORD PTR [ebp+8]
$L187401:
  00b4c	8a 44 24 23	 mov	 al, BYTE PTR _uParts$187399[esp+632]
  00b50	8b 54 24 1c	 mov	 edx, DWORD PTR tv5474[esp+632]
  00b54	fe c0		 inc	 al
  00b56	42		 inc	 edx
  00b57	3c 1f		 cmp	 al, 31			; 0000001fH
  00b59	88 44 24 23	 mov	 BYTE PTR _uParts$187399[esp+632], al
  00b5d	89 54 24 1c	 mov	 DWORD PTR tv5474[esp+632], edx
  00b61	0f 82 59 ff ff
	ff		 jb	 $L189332

; 301  : 					}
; 302  : 				}
; 303  : 				GETBLOCK( ar, pBlock, nBlockSize );

  00b67	8d 8c 24 60 02
	00 00		 lea	 ecx, DWORD PTR _nBlockSize$187406[esp+632]
  00b6e	51		 push	 ecx
  00b6f	8b cd		 mov	 ecx, ebp
  00b71	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 304  : 				*(UNALIGNED u_char*)( pBlock + uOffset )	= uSize;

  00b76	8a 54 24 10	 mov	 dl, BYTE PTR _uSize$187397[esp+632]
  00b7a	8b 4c 24 24	 mov	 ecx, DWORD PTR _uOffset$187398[esp+632]
  00b7e	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 305  : #if __VER >= 9	// __PET_0410
; 306  : 				DWORD dwPetId	= NULL_ID;
; 307  : #ifdef __PET_1024
; 308  : 				char* pszPetName	= "";
; 309  : #endif	// __PET_1024
; 310  : 				CItemElem* pItemElem	= GetPetItem();

  00b81	8b cb		 mov	 ecx, ebx
  00b83	83 cf ff	 or	 edi, -1
  00b86	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _pszPetName$187410[esp+632], OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00b8e	e8 00 00 00 00	 call	 ?GetPetItem@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetPetItem

; 311  : 				if( pItemElem )

  00b93	85 c0		 test	 eax, eax
  00b95	89 44 24 24	 mov	 DWORD PTR _pItemElem$187411[esp+632], eax
  00b99	74 32		 je	 SHORT $L187412

; 312  : 				{
; 313  : 					dwPetId		= MAKELONG( (WORD)pItemElem->m_pPet->GetIndex(), (WORD)pItemElem->m_pPet->GetLevel() );

  00b9b	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [eax+152]
  00ba1	8a 50 05	 mov	 dl, BYTE PTR [eax+5]
  00ba4	8b c8		 mov	 ecx, eax
  00ba6	88 54 24 14	 mov	 BYTE PTR $T188491[esp+632], dl
  00baa	e8 00 00 00 00	 call	 ?GetIndex@CPet@@QAEKXZ	; CPet::GetIndex

; 314  : #ifdef __PET_1024
; 315  : 					pszPetName	= const_cast<char*>( pItemElem->m_pPet->GetName() );

  00baf	8b 4c 24 24	 mov	 ecx, DWORD PTR _pItemElem$187411[esp+632]
  00bb3	0f b7 f8	 movzx	 edi, ax
  00bb6	0f b6 44 24 14	 movzx	 eax, BYTE PTR $T188491[esp+632]
  00bbb	c1 e0 10	 shl	 eax, 16			; 00000010H
  00bbe	0b f8		 or	 edi, eax
  00bc0	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00bc6	83 c0 16	 add	 eax, 22			; 00000016H
  00bc9	89 44 24 1c	 mov	 DWORD PTR _pszPetName$187410[esp+632], eax
$L187412:

; 316  : #endif	// __PET_1024
; 317  : 				}
; 318  : 				ar << dwPetId;

  00bcd	56		 push	 esi
  00bce	8b cd		 mov	 ecx, ebp
  00bd0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00bd5	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]

; 319  : #ifdef __PET_1024
; 320  : 				ar.WriteString( pszPetName );

  00bd8	8b 44 24 1c	 mov	 eax, DWORD PTR _pszPetName$187410[esp+632]
  00bdc	89 3a		 mov	 DWORD PTR [edx], edi
  00bde	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00be1	03 d6		 add	 edx, esi
  00be3	50		 push	 eax
  00be4	8b cd		 mov	 ecx, ebp
  00be6	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00be9	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 321  : #endif	// __PET_1024
; 322  : #endif	// __PET_0410
; 323  : 			}
; 324  : 		}
; 325  : 		else	// NPC

  00bee	e9 0e 12 00 00	 jmp	 $L189260
$L187333:

; 326  : 		{
; 327  : 			ar << (u_char)m_dwHairMesh << m_dwHairColor << (u_char)m_dwHeadMesh;

  00bf3	8a 8b a4 00 00
	00		 mov	 cl, BYTE PTR [ebx+164]
  00bf9	88 4c 24 14	 mov	 BYTE PTR $T188501[esp+632], cl
  00bfd	6a 01		 push	 1
  00bff	8b cd		 mov	 ecx, ebp
  00c01	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c06	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00c09	8a 44 24 14	 mov	 al, BYTE PTR $T188501[esp+632]
  00c0d	88 02		 mov	 BYTE PTR [edx], al
  00c0f	ff 45 08	 inc	 DWORD PTR [ebp+8]
  00c12	8b bb a8 00 00
	00		 mov	 edi, DWORD PTR [ebx+168]
  00c18	56		 push	 esi
  00c19	8b cd		 mov	 ecx, ebp
  00c1b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c20	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00c23	89 39		 mov	 DWORD PTR [ecx], edi
  00c25	01 75 08	 add	 DWORD PTR [ebp+8], esi
  00c28	8a 93 ac 00 00
	00		 mov	 dl, BYTE PTR [ebx+172]
  00c2e	6a 01		 push	 1
  00c30	8b cd		 mov	 ecx, ebp
  00c32	88 54 24 18	 mov	 BYTE PTR $T188509[esp+636], dl
  00c36	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c3b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00c3e	8a 4c 24 14	 mov	 cl, BYTE PTR $T188509[esp+632]
  00c42	88 08		 mov	 BYTE PTR [eax], cl
  00c44	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 328  : 			ar.WriteString( m_szCharacterKey );

  00c47	8d 53 38	 lea	 edx, DWORD PTR [ebx+56]
  00c4a	52		 push	 edx
  00c4b	8b cd		 mov	 ecx, ebp
  00c4d	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 329  : 
; 330  : 			u_char uSize	= 0;
; 331  : 			u_long uOffset	= ar.GetOffset();

  00c52	8b 7d 08	 mov	 edi, DWORD PTR [ebp+8]
  00c55	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]

; 332  : 			ar << uSize;

  00c58	6a 01		 push	 1
  00c5a	8b cd		 mov	 ecx, ebp
  00c5c	2b f8		 sub	 edi, eax
  00c5e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c63	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00c66	c6 00 00	 mov	 BYTE PTR [eax], 0
  00c69	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 333  : 			if( IsEquipableNPC() )
; 334  : 			{
; 335  : 				CItemElem* pItemElem;
; 336  : 				for( u_char uParts = 0; uParts < MAX_HUMAN_PARTS; uParts++ )
; 337  : 				{
; 338  : 					pItemElem	= m_Inventory.GetEquip( uParts );
; 339  : 					if( pItemElem )
; 340  : 					{
; 341  : 						uSize++;
; 342  : 						ar << uParts;
; 343  : 						ar << (u_short)pItemElem->m_dwItemId;
; 344  : 					}
; 345  : 				}
; 346  : 			}
; 347  : 			GETBLOCK( ar, pBlock, nBlockSize );

  00c6c	8d 8c 24 60 02
	00 00		 lea	 ecx, DWORD PTR _nBlockSize$187435[esp+632]
  00c73	51		 push	 ecx
  00c74	8b cd		 mov	 ecx, ebp
  00c76	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 348  : 			*(UNALIGNED u_char*)( pBlock + uOffset )	= uSize;

  00c7b	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 349  : 
; 350  : 
; 351  : 			ar << (u_char)m_bActiveAttack;

  00c7f	8a 53 58	 mov	 dl, BYTE PTR [ebx+88]
  00c82	6a 01		 push	 1
  00c84	8b cd		 mov	 ecx, ebp
  00c86	88 54 24 18	 mov	 BYTE PTR $T188554[esp+636], dl
  00c8a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c8f	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00c92	8a 4c 24 14	 mov	 cl, BYTE PTR $T188554[esp+632]
  00c96	88 08		 mov	 BYTE PTR [eax], cl
  00c98	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 352  : 			ar << (u_char)m_nMovePattern;

  00c9b	8a 53 60	 mov	 dl, BYTE PTR [ebx+96]
  00c9e	6a 01		 push	 1
  00ca0	8b cd		 mov	 ecx, ebp
  00ca2	88 54 24 18	 mov	 BYTE PTR $T188558[esp+636], dl
  00ca6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00cab	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00cae	8a 4c 24 14	 mov	 cl, BYTE PTR $T188558[esp+632]
  00cb2	88 08		 mov	 BYTE PTR [eax], cl
  00cb4	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 353  : 			ar << (u_char)m_nMoveEvent;

  00cb7	8a 53 64	 mov	 dl, BYTE PTR [ebx+100]
  00cba	6a 01		 push	 1
  00cbc	8b cd		 mov	 ecx, ebp
  00cbe	88 54 24 18	 mov	 BYTE PTR $T188562[esp+636], dl
  00cc2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00cc7	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00cca	8a 4c 24 14	 mov	 cl, BYTE PTR $T188562[esp+632]
  00cce	88 08		 mov	 BYTE PTR [eax], cl
  00cd0	ff 45 08	 inc	 DWORD PTR [ebp+8]

; 354  : 			ar << m_nMoveEventCnt;

  00cd3	8b 7b 68	 mov	 edi, DWORD PTR [ebx+104]
  00cd6	56		 push	 esi
  00cd7	8b cd		 mov	 ecx, ebp
  00cd9	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00cde	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00ce1	89 3a		 mov	 DWORD PTR [edx], edi
  00ce3	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 355  : #if __VER >= 9	//__AI_0509
; 356  : 			ar << m_fSpeedFactor;

  00ce6	8b 83 34 42 00
	00		 mov	 eax, DWORD PTR [ebx+16948]
  00cec	56		 push	 esi
  00ced	8b cd		 mov	 ecx, ebp
  00cef	89 44 24 28	 mov	 DWORD PTR $T188575[esp+636], eax
  00cf3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00cf8	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00cfb	8b 54 24 24	 mov	 edx, DWORD PTR $T188575[esp+632]
  00cff	89 11		 mov	 DWORD PTR [ecx], edx
  00d01	01 75 08	 add	 DWORD PTR [ebp+8], esi

; 357  : #endif	// __AI_0509
; 358  : 		}
; 359  : #ifdef __BUFF_1107
; 360  : 		m_buffs.Serialize( ar );
; 361  : #else	// __BUFF_1107
; 362  : 		m_SkillState.Serialize( ar );
; 363  : #endif	// __BUFF_1107
; 364  : 	}
; 365  : 	else	// LOADING

  00d04	e9 f8 10 00 00	 jmp	 $L189260
$L187329:

; 366  : 	{
; 367  : 		m_dwMotion = 0;

  00d09	33 c0		 xor	 eax, eax
  00d0b	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 368  : 
; 369  : 		u_short nMotion;
; 370  : 		ar >> nMotion;							// m_dwMotion

  00d0e	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00d11	8b 75 0c	 mov	 esi, DWORD PTR [ebp+12]
  00d14	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  00d17	3b d6		 cmp	 edx, esi
  00d19	77 08		 ja	 SHORT $L188578
  00d1b	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00d1e	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00d21	eb 05		 jmp	 SHORT $L188579
$L188578:
  00d23	33 c9		 xor	 ecx, ecx
  00d25	89 75 08	 mov	 DWORD PTR [ebp+8], esi
$L188579:

; 371  : 
; 372  : 		#if defined(__WORLDSERVER) || defined(__CLIENT)
; 373  : 				m_dwMotion = (DWORD)nMotion;	//     SetMotion .
; 374  : 		#else	// defined(__WORLDSERVER) || defined(__CLIENT)
; 375  : 			m_dwMotion = (DWORD)nMotion;

  00d28	0f b7 c9	 movzx	 ecx, cx

; 376  : 		#endif
; 377  : 
; 378  : 		m_bPlayer	=
; 379  : 		m_dwBelligerence	=
; 380  : 		m_idGuild	=
; 381  : 		m_idWar	=
; 382  : 		m_idparty	=
; 383  : 		m_idDuelParty	=
; 384  : 		m_nDuel		= 
; 385  : 		m_dwRideItemIdx		= 0;

  00d2b	89 83 bc 00 00
	00		 mov	 DWORD PTR [ebx+188], eax
  00d31	89 83 fc 40 00
	00		 mov	 DWORD PTR [ebx+16636], eax
  00d37	89 83 00 41 00
	00		 mov	 DWORD PTR [ebx+16640], eax
  00d3d	89 83 c8 40 00
	00		 mov	 DWORD PTR [ebx+16584], eax
  00d43	89 83 d0 40 00
	00		 mov	 DWORD PTR [ebx+16592], eax
  00d49	89 83 cc 40 00
	00		 mov	 DWORD PTR [ebx+16588], eax
  00d4f	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  00d52	89 83 8c 00 00
	00		 mov	 DWORD PTR [ebx+140], eax
  00d58	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx

; 386  : 
; 387  : 		ClearEquipInfo();

  00d5b	8d 93 24 45 00
	00		 lea	 edx, DWORD PTR [ebx+17700]
  00d61	33 c0		 xor	 eax, eax
  00d63	b9 5d 00 00 00	 mov	 ecx, 93			; 0000005dH
  00d68	8b fa		 mov	 edi, edx
  00d6a	f3 ab		 rep stosd
  00d6c	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
$L188585:
  00d71	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  00d77	83 c2 0c	 add	 edx, 12			; 0000000cH
  00d7a	48		 dec	 eax
  00d7b	75 f4		 jne	 SHORT $L188585

; 388  : 		
; 389  : 		ar >> (u_char&)m_bPlayer;

  00d7d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00d80	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00d83	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00d86	3b d1		 cmp	 edx, ecx
  00d88	77 0d		 ja	 SHORT $L188590
  00d8a	8a 00		 mov	 al, BYTE PTR [eax]
  00d8c	88 83 8c 00 00
	00		 mov	 BYTE PTR [ebx+140], al
  00d92	ff 45 08	 inc	 DWORD PTR [ebp+8]
  00d95	eb 0d		 jmp	 SHORT $L188591
$L188590:
  00d97	c6 83 8c 00 00
	00 00		 mov	 BYTE PTR [ebx+140], 0
  00d9e	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00da1	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188591:

; 390  : 
; 391  : #ifdef __SKILL_0205
; 392  : 		SKILL	aJobSkill[MAX_SKILL_JOB];
; 393  : 		memcpy( aJobSkill, m_aJobSkill, sizeof(aJobSkill) );

  00da4	8d b3 00 01 00
	00		 lea	 esi, DWORD PTR [ebx+256]
  00daa	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00daf	8d bc 24 c8 00
	00 00		 lea	 edi, DWORD PTR _aJobSkill$187445[esp+632]
  00db6	f3 a5		 rep movsd

; 394  : #endif	// __SKILL_0205
; 395  : 
; 396  : 		InitProp();

  00db8	8b cb		 mov	 ecx, ebx
  00dba	e8 00 00 00 00	 call	 ?InitProp@CMover@@QAEXXZ ; CMover::InitProp

; 397  : 
; 398  : 		m_nHitPoint	= 0;

  00dbf	c7 83 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+148], 0

; 399  : 
; 400  : 		ar >> m_nHitPoint;

  00dc9	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00dcc	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00dcf	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00dd2	3b d1		 cmp	 edx, ecx
  00dd4	77 0e		 ja	 SHORT $L188596
  00dd6	8b 00		 mov	 eax, DWORD PTR [eax]
  00dd8	89 83 94 00 00
	00		 mov	 DWORD PTR [ebx+148], eax
  00dde	83 45 08 04	 add	 DWORD PTR [ebp+8], 4
  00de2	eb 10		 jmp	 SHORT $L188597
$L188596:
  00de4	c7 83 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+148], 0
  00dee	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00df1	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188597:

; 401  : 		DWORD dw1, dw2;
; 402  : 		ar >> dw1;

  00df4	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00df7	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00dfa	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00dfd	33 ff		 xor	 edi, edi
  00dff	3b d0		 cmp	 edx, eax
  00e01	77 07		 ja	 SHORT $L188602
  00e03	8b 31		 mov	 esi, DWORD PTR [ecx]
  00e05	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00e08	eb 05		 jmp	 SHORT $L188603
$L188602:
  00e0a	33 f6		 xor	 esi, esi
  00e0c	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L188603:

; 403  : 		ar >> dw2;

  00e0f	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00e12	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00e15	3b d0		 cmp	 edx, eax
  00e17	77 07		 ja	 SHORT $L188607
  00e19	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00e1b	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00e1e	eb 05		 jmp	 SHORT $L188608
$L188607:
  00e20	33 c9		 xor	 ecx, ecx
  00e22	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L188608:

; 404  : 		m_pActMover->ClearStateFlag();

  00e25	8b 93 10 41 00
	00		 mov	 edx, DWORD PTR [ebx+16656]
  00e2b	89 7a 08	 mov	 DWORD PTR [edx+8], edi

; 405  : 		m_pActMover->AddStateFlag( dw2 );

  00e2e	8b 83 10 41 00
	00		 mov	 eax, DWORD PTR [ebx+16656]
  00e34	09 48 08	 or	 DWORD PTR [eax+8], ecx

; 406  : 		m_pActMover->__ForceSetState( dw1 );

  00e37	8b 83 10 41 00
	00		 mov	 eax, DWORD PTR [ebx+16656]
  00e3d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 407  : 		ar >> (u_char&)m_dwBelligerence;

  00e40	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00e43	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  00e46	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00e49	3b ca		 cmp	 ecx, edx
  00e4b	77 0b		 ja	 SHORT $L188626
  00e4d	8a 10		 mov	 dl, BYTE PTR [eax]
  00e4f	88 53 5c	 mov	 BYTE PTR [ebx+92], dl
  00e52	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00e55	40		 inc	 eax
  00e56	eb 07		 jmp	 SHORT $L189340
$L188626:
  00e58	c6 43 5c 00	 mov	 BYTE PTR [ebx+92], 0
  00e5c	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189340:

; 408  : #if __VER >= 15 // __PETVIS
; 409  : 		ar >> m_dwMoverSfxId;

  00e5f	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  00e62	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00e65	3b ca		 cmp	 ecx, edx
  00e67	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  00e6a	be 04 00 00 00	 mov	 esi, 4
  00e6f	77 0f		 ja	 SHORT $L188632
  00e71	8b 10		 mov	 edx, DWORD PTR [eax]
  00e73	89 93 2c 42 00
	00		 mov	 DWORD PTR [ebx+16940], edx
  00e79	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00e7c	03 c6		 add	 eax, esi
  00e7e	eb 09		 jmp	 SHORT $L189341
$L188632:
  00e80	89 bb 2c 42 00
	00		 mov	 DWORD PTR [ebx+16940], edi
  00e86	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189341:
  00e89	89 45 08	 mov	 DWORD PTR [ebp+8], eax

; 410  : #endif // __PETVIS
; 411  : 		if( m_bPlayer )	// PLAYER

  00e8c	39 bb 8c 00 00
	00		 cmp	 DWORD PTR [ebx+140], edi
  00e92	0f 84 09 0e 00
	00		 je	 $L187449

; 412  : 		{
; 413  : 			m_dwSkinSet		=
; 414  : 			m_dwHairMesh	=
; 415  : 			m_dwHeadMesh	=
; 416  : 			m_idPlayer	=
; 417  : 			m_nJob	=
; 418  : 			m_nStr	=
; 419  : 			m_nSta	=
; 420  : 			m_nDex	=
; 421  : 			m_nInt	=
; 422  : 			m_nLevel	=
; 423  : 			m_dwAuthorization	=
; 424  : #if __VER < 8 // __S8_PK
; 425  : 			m_nNumKill	=
; 426  : #endif // __VER < 8 // __S8_PK
; 427  : 									0;
; 428  : 
; 429  : 			BYTE bySex;
; 430  : 			ar.ReadString( m_szName, 32 );

  00e98	6a 20		 push	 32			; 00000020H
  00e9a	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  00e9d	51		 push	 ecx
  00e9e	8b cd		 mov	 ecx, ebp
  00ea0	89 bb e0 02 00
	00		 mov	 DWORD PTR [ebx+736], edi
  00ea6	89 bb e4 00 00
	00		 mov	 DWORD PTR [ebx+228], edi
  00eac	89 bb e0 00 00
	00		 mov	 DWORD PTR [ebx+224], edi
  00eb2	89 bb dc 00 00
	00		 mov	 DWORD PTR [ebx+220], edi
  00eb8	89 bb d8 00 00
	00		 mov	 DWORD PTR [ebx+216], edi
  00ebe	89 bb d4 00 00
	00		 mov	 DWORD PTR [ebx+212], edi
  00ec4	89 bb c4 00 00
	00		 mov	 DWORD PTR [ebx+196], edi
  00eca	89 bb 90 00 00
	00		 mov	 DWORD PTR [ebx+144], edi
  00ed0	89 bb ac 00 00
	00		 mov	 DWORD PTR [ebx+172], edi
  00ed6	89 bb a4 00 00
	00		 mov	 DWORD PTR [ebx+164], edi
  00edc	89 bb a0 00 00
	00		 mov	 DWORD PTR [ebx+160], edi
  00ee2	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString

; 431  : 			ar >> bySex;

  00ee7	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00eea	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  00eed	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00ef0	3b ca		 cmp	 ecx, edx
  00ef2	77 07		 ja	 SHORT $L188638
  00ef4	8a 00		 mov	 al, BYTE PTR [eax]
  00ef6	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  00ef9	eb 05		 jmp	 SHORT $L188639
$L188638:
  00efb	32 c0		 xor	 al, al
  00efd	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188639:

; 432  : 			SetSex( bySex );

  00f00	88 83 b8 00 00
	00		 mov	 BYTE PTR [ebx+184], al

; 433  : 			ar >> (u_char&)m_dwSkinSet;

  00f06	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00f09	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f0c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00f0f	3b d1		 cmp	 edx, ecx
  00f11	77 0d		 ja	 SHORT $L188647
  00f13	8a 00		 mov	 al, BYTE PTR [eax]
  00f15	88 83 a0 00 00
	00		 mov	 BYTE PTR [ebx+160], al
  00f1b	ff 45 08	 inc	 DWORD PTR [ebp+8]
  00f1e	eb 0d		 jmp	 SHORT $L188648
$L188647:
  00f20	c6 83 a0 00 00
	00 00		 mov	 BYTE PTR [ebx+160], 0
  00f27	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f2a	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188648:

; 434  : 			ar >> (u_char&)m_dwHairMesh;

  00f2d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00f30	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f33	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00f36	3b d1		 cmp	 edx, ecx
  00f38	77 0d		 ja	 SHORT $L188653
  00f3a	8a 00		 mov	 al, BYTE PTR [eax]
  00f3c	88 83 a4 00 00
	00		 mov	 BYTE PTR [ebx+164], al
  00f42	ff 45 08	 inc	 DWORD PTR [ebp+8]
  00f45	eb 0d		 jmp	 SHORT $L188654
$L188653:
  00f47	c6 83 a4 00 00
	00 00		 mov	 BYTE PTR [ebx+164], 0
  00f4e	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f51	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188654:

; 435  : 			ar >> m_dwHairColor;

  00f54	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00f57	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f5a	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00f5d	3b d1		 cmp	 edx, ecx
  00f5f	77 0d		 ja	 SHORT $L188659
  00f61	8b 00		 mov	 eax, DWORD PTR [eax]
  00f63	89 83 a8 00 00
	00		 mov	 DWORD PTR [ebx+168], eax
  00f69	01 75 08	 add	 DWORD PTR [ebp+8], esi
  00f6c	eb 0c		 jmp	 SHORT $L188660
$L188659:
  00f6e	89 bb a8 00 00
	00		 mov	 DWORD PTR [ebx+168], edi
  00f74	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f77	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188660:

; 436  : 			ar >> (u_char&)m_dwHeadMesh;

  00f7a	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00f7d	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f80	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00f83	3b d1		 cmp	 edx, ecx
  00f85	77 0d		 ja	 SHORT $L188665
  00f87	8a 00		 mov	 al, BYTE PTR [eax]
  00f89	88 83 ac 00 00
	00		 mov	 BYTE PTR [ebx+172], al
  00f8f	ff 45 08	 inc	 DWORD PTR [ebp+8]
  00f92	eb 0d		 jmp	 SHORT $L188666
$L188665:
  00f94	c6 83 ac 00 00
	00 00		 mov	 BYTE PTR [ebx+172], 0
  00f9b	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00f9e	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188666:

; 437  : #	if defined (__WORLDSERVER) || defined(__CLIENT)
; 438  : 			SetHairColor( m_dwHairColor );
; 439  : #	endif	// __WORLDSERVER	//__CLIENT
; 440  : 			ar >> m_idPlayer;

  00fa1	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00fa4	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00fa7	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00faa	3b d1		 cmp	 edx, ecx
  00fac	77 0d		 ja	 SHORT $L188671
  00fae	8b 00		 mov	 eax, DWORD PTR [eax]
  00fb0	89 83 90 00 00
	00		 mov	 DWORD PTR [ebx+144], eax
  00fb6	01 75 08	 add	 DWORD PTR [ebp+8], esi
  00fb9	eb 0c		 jmp	 SHORT $L188672
$L188671:
  00fbb	89 bb 90 00 00
	00		 mov	 DWORD PTR [ebx+144], edi
  00fc1	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00fc4	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188672:

; 441  : 			ar >> (u_char&)m_nJob;

  00fc7	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00fca	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00fcd	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00fd0	3b d1		 cmp	 edx, ecx
  00fd2	77 0d		 ja	 SHORT $L188677
  00fd4	8a 00		 mov	 al, BYTE PTR [eax]
  00fd6	88 83 c4 00 00
	00		 mov	 BYTE PTR [ebx+196], al
  00fdc	ff 45 08	 inc	 DWORD PTR [ebp+8]
  00fdf	eb 0d		 jmp	 SHORT $L188678
$L188677:
  00fe1	c6 83 c4 00 00
	00 00		 mov	 BYTE PTR [ebx+196], 0
  00fe8	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00feb	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188678:

; 442  : 			ar >> (u_short&)m_nStr;

  00fee	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00ff1	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00ff4	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00ff7	3b d1		 cmp	 edx, ecx
  00ff9	be 02 00 00 00	 mov	 esi, 2
  00ffe	77 0f		 ja	 SHORT $L188683
  01000	66 8b 00	 mov	 ax, WORD PTR [eax]
  01003	66 89 83 d4 00
	00 00		 mov	 WORD PTR [ebx+212], ax
  0100a	01 75 08	 add	 DWORD PTR [ebp+8], esi
  0100d	eb 0d		 jmp	 SHORT $L188684
$L188683:
  0100f	66 89 bb d4 00
	00 00		 mov	 WORD PTR [ebx+212], di
  01016	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01019	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188684:

; 443  : 			ar >> (u_short&)m_nSta;

  0101c	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0101f	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01022	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  01025	3b d1		 cmp	 edx, ecx
  01027	77 0f		 ja	 SHORT $L188689
  01029	66 8b 00	 mov	 ax, WORD PTR [eax]
  0102c	66 89 83 d8 00
	00 00		 mov	 WORD PTR [ebx+216], ax
  01033	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01036	eb 0d		 jmp	 SHORT $L188690
$L188689:
  01038	66 89 bb d8 00
	00 00		 mov	 WORD PTR [ebx+216], di
  0103f	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01042	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188690:

; 444  : 			ar >> (u_short&)m_nDex;

  01045	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01048	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0104b	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0104e	3b d1		 cmp	 edx, ecx
  01050	77 0f		 ja	 SHORT $L188695
  01052	66 8b 00	 mov	 ax, WORD PTR [eax]
  01055	66 89 83 dc 00
	00 00		 mov	 WORD PTR [ebx+220], ax
  0105c	01 75 08	 add	 DWORD PTR [ebp+8], esi
  0105f	eb 0d		 jmp	 SHORT $L188696
$L188695:
  01061	66 89 bb dc 00
	00 00		 mov	 WORD PTR [ebx+220], di
  01068	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0106b	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188696:

; 445  : 			ar >> (u_short&)m_nInt;

  0106e	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01071	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01074	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  01077	3b d1		 cmp	 edx, ecx
  01079	77 0f		 ja	 SHORT $L188701
  0107b	66 8b 00	 mov	 ax, WORD PTR [eax]
  0107e	66 89 83 e0 00
	00 00		 mov	 WORD PTR [ebx+224], ax
  01085	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01088	eb 0d		 jmp	 SHORT $L188702
$L188701:
  0108a	66 89 bb e0 00
	00 00		 mov	 WORD PTR [ebx+224], di
  01091	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01094	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188702:

; 446  : 			ar >> (u_short&)m_nLevel;

  01097	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0109a	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0109d	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  010a0	3b d1		 cmp	 edx, ecx
  010a2	77 0f		 ja	 SHORT $L188707
  010a4	66 8b 00	 mov	 ax, WORD PTR [eax]
  010a7	66 89 83 e4 00
	00 00		 mov	 WORD PTR [ebx+228], ax
  010ae	01 75 08	 add	 DWORD PTR [ebp+8], esi
  010b1	eb 0d		 jmp	 SHORT $L188708
$L188707:
  010b3	66 89 bb e4 00
	00 00		 mov	 WORD PTR [ebx+228], di
  010ba	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  010bd	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188708:

; 447  : 			ar >> m_nFuel;

  010c0	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  010c3	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  010c6	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  010c9	3b d1		 cmp	 edx, ecx
  010cb	77 0e		 ja	 SHORT $L188720
  010cd	8b 00		 mov	 eax, DWORD PTR [eax]
  010cf	89 83 c0 00 00
	00		 mov	 DWORD PTR [ebx+192], eax
  010d5	83 45 08 04	 add	 DWORD PTR [ebp+8], 4
  010d9	eb 0c		 jmp	 SHORT $L188721
$L188720:
  010db	89 bb c0 00 00
	00		 mov	 DWORD PTR [ebx+192], edi
  010e1	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  010e4	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188721:

; 448  : 			ar >> m_tmAccFuel;

  010e7	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  010ea	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  010ed	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  010f0	3b d1		 cmp	 edx, ecx
  010f2	77 0e		 ja	 SHORT $L188726
  010f4	8b 00		 mov	 eax, DWORD PTR [eax]
  010f6	89 83 ec 41 00
	00		 mov	 DWORD PTR [ebx+16876], eax
  010fc	83 45 08 04	 add	 DWORD PTR [ebp+8], 4
  01100	eb 0c		 jmp	 SHORT $L188727
$L188726:
  01102	89 bb ec 41 00
	00		 mov	 DWORD PTR [ebx+16876], edi
  01108	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0110b	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188727:

; 449  : 
; 450  : 			u_char u1;
; 451  : 			ar >> u1;

  0110e	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01111	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01114	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01117	3b ca		 cmp	 ecx, edx
  01119	77 40		 ja	 SHORT $L188732
  0111b	8a 00		 mov	 al, BYTE PTR [eax]

; 452  : 			if( u1 == 1 )

  0111d	3c 01		 cmp	 al, 1
  0111f	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01122	75 1c		 jne	 SHORT $L187461

; 453  : 			{
; 454  : 				ar >> m_idGuild;

  01124	8d 83 cc 40 00
	00		 lea	 eax, DWORD PTR [ebx+16588]
  0112a	50		 push	 eax
  0112b	8b cd		 mov	 ecx, ebp
  0112d	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>

; 455  : 				ar >> m_idWar;

  01132	8d 83 d0 40 00
	00		 lea	 eax, DWORD PTR [ebx+16592]
  01138	50		 push	 eax
  01139	8b cd		 mov	 ecx, ebp
  0113b	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>
$L187461:

; 456  : 			}
; 457  : 			ar >> m_idGuildCloak;

  01140	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01143	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01146	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01149	3b d1		 cmp	 edx, ecx
  0114b	77 13		 ja	 SHORT $L188744
  0114d	8b 00		 mov	 eax, DWORD PTR [eax]
  0114f	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  01155	83 45 08 04	 add	 DWORD PTR [ebp+8], 4
  01159	eb 11		 jmp	 SHORT $L188745

; 449  : 
; 450  : 			u_char u1;
; 451  : 			ar >> u1;

$L188732:
  0115b	89 55 08	 mov	 DWORD PTR [ebp+8], edx

; 452  : 			if( u1 == 1 )

  0115e	eb e0		 jmp	 SHORT $L187461

; 456  : 			}
; 457  : 			ar >> m_idGuildCloak;

$L188744:
  01160	89 bb d0 00 00
	00		 mov	 DWORD PTR [ebx+208], edi
  01166	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01169	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188745:

; 458  : 
; 459  : 			ar >> u1;

  0116c	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0116f	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01172	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01175	3b ca		 cmp	 ecx, edx
  01177	77 3f		 ja	 SHORT $L188750
  01179	8a 00		 mov	 al, BYTE PTR [eax]

; 460  : 			if( u1 == 1 )

  0117b	3c 01		 cmp	 al, 1
  0117d	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01180	75 1c		 jne	 SHORT $L187462

; 461  : 			{
; 462  : 				ar >> m_idparty;

  01182	8d 83 c8 40 00
	00		 lea	 eax, DWORD PTR [ebx+16584]
  01188	50		 push	 eax
  01189	8b cd		 mov	 ecx, ebp
  0118b	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>

; 463  : 				ar >> m_idDuelParty;

  01190	8d 83 00 41 00
	00		 lea	 eax, DWORD PTR [ebx+16640]
  01196	50		 push	 eax
  01197	8b cd		 mov	 ecx, ebp
  01199	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>
$L187462:

; 464  : 			}
; 465  : 
; 466  : 			ar >> (char&)m_dwAuthorization;

  0119e	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  011a1	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  011a4	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  011a7	3b d1		 cmp	 edx, ecx
  011a9	77 12		 ja	 SHORT $L188762
  011ab	8a 00		 mov	 al, BYTE PTR [eax]
  011ad	88 83 e0 02 00
	00		 mov	 BYTE PTR [ebx+736], al
  011b3	ff 45 08	 inc	 DWORD PTR [ebp+8]
  011b6	eb 12		 jmp	 SHORT $L188763

; 458  : 
; 459  : 			ar >> u1;

$L188750:
  011b8	89 55 08	 mov	 DWORD PTR [ebp+8], edx

; 460  : 			if( u1 == 1 )

  011bb	eb e1		 jmp	 SHORT $L187462

; 464  : 			}
; 465  : 
; 466  : 			ar >> (char&)m_dwAuthorization;

$L188762:
  011bd	c6 83 e0 02 00
	00 00		 mov	 BYTE PTR [ebx+736], 0
  011c4	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  011c7	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188763:

; 467  : 			ar >> m_dwMode;

  011ca	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  011cd	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  011d0	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  011d3	3b d1		 cmp	 edx, ecx
  011d5	77 17		 ja	 SHORT $L188768
  011d7	8b 00		 mov	 eax, DWORD PTR [eax]
  011d9	89 83 e4 02 00
	00		 mov	 DWORD PTR [ebx+740], eax
  011df	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  011e2	b9 04 00 00 00	 mov	 ecx, 4
  011e7	03 c1		 add	 eax, ecx
  011e9	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  011ec	eb 11		 jmp	 SHORT $L188769
$L188768:
  011ee	89 bb e4 02 00
	00		 mov	 DWORD PTR [ebx+740], edi
  011f4	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  011f7	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  011fa	b9 04 00 00 00	 mov	 ecx, 4
$L188769:

; 468  : 			ar >> m_dwStateMode;

  011ff	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01202	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01205	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  01208	77 0d		 ja	 SHORT $L188774
  0120a	8b 00		 mov	 eax, DWORD PTR [eax]
  0120c	89 83 98 46 00
	00		 mov	 DWORD PTR [ebx+18072], eax
  01212	01 4d 08	 add	 DWORD PTR [ebp+8], ecx
  01215	eb 0c		 jmp	 SHORT $L188775
$L188774:
  01217	89 bb 98 46 00
	00		 mov	 DWORD PTR [ebx+18072], edi
  0121d	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01220	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188775:

; 469  : #ifdef __WORLDSERVER
; 470  : 			OBJID dwItemTem;
; 471  : 			ar >> dwItemTem;
; 472  : #else // __WORLDSERVER
; 473  : 			ar >> m_dwUseItemId;

  01223	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01226	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01229	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  0122c	77 0d		 ja	 SHORT $L188780
  0122e	8b 00		 mov	 eax, DWORD PTR [eax]
  01230	89 83 9c 46 00
	00		 mov	 DWORD PTR [ebx+18076], eax
  01236	01 4d 08	 add	 DWORD PTR [ebp+8], ecx
  01239	eb 0c		 jmp	 SHORT $L188781
$L188780:
  0123b	89 bb 9c 46 00
	00		 mov	 DWORD PTR [ebx+18076], edi
  01241	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01244	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188781:

; 474  : #endif // __WORLDSERVER
; 475  : #if __VER >= 8 // __S8_PK
; 476  : 			ar >> m_dwPKTime;

  01247	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0124a	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0124d	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  01250	77 0d		 ja	 SHORT $L188786
  01252	8b 00		 mov	 eax, DWORD PTR [eax]
  01254	89 83 d4 40 00
	00		 mov	 DWORD PTR [ebx+16596], eax
  0125a	01 4d 08	 add	 DWORD PTR [ebp+8], ecx
  0125d	eb 0c		 jmp	 SHORT $L188787
$L188786:
  0125f	89 bb d4 40 00
	00		 mov	 DWORD PTR [ebx+16596], edi
  01265	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01268	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188787:

; 477  : 	#ifdef __WORLDSERVER
; 478  : 			if( m_dwPKTime > 0 )
; 479  : 				m_dwPKTime = GetTickCount() + m_dwPKTime;
; 480  : 	#endif // __WORLDSERVER
; 481  : 			ar >> m_nPKValue;

  0126b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0126e	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01271	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  01274	77 0d		 ja	 SHORT $L188799
  01276	8b 00		 mov	 eax, DWORD PTR [eax]
  01278	89 83 d8 40 00
	00		 mov	 DWORD PTR [ebx+16600], eax
  0127e	01 4d 08	 add	 DWORD PTR [ebp+8], ecx
  01281	eb 0c		 jmp	 SHORT $L188800
$L188799:
  01283	89 bb d8 40 00
	00		 mov	 DWORD PTR [ebx+16600], edi
  01289	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  0128c	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188800:

; 482  : 			ar >> m_dwPKPropensity;

  0128f	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01292	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01295	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  01298	77 0d		 ja	 SHORT $L188805
  0129a	8b 00		 mov	 eax, DWORD PTR [eax]
  0129c	89 83 dc 40 00
	00		 mov	 DWORD PTR [ebx+16604], eax
  012a2	01 4d 08	 add	 DWORD PTR [ebp+8], ecx
  012a5	eb 0c		 jmp	 SHORT $L188806
$L188805:
  012a7	89 bb dc 40 00
	00		 mov	 DWORD PTR [ebx+16604], edi
  012ad	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  012b0	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188806:

; 483  : 			ar >> m_dwPKExp;

  012b3	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  012b6	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  012b9	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  012bc	77 0d		 ja	 SHORT $L188811
  012be	8b 00		 mov	 eax, DWORD PTR [eax]
  012c0	89 83 e0 40 00
	00		 mov	 DWORD PTR [ebx+16608], eax
  012c6	01 4d 08	 add	 DWORD PTR [ebp+8], ecx
  012c9	eb 0c		 jmp	 SHORT $L188812
$L188811:
  012cb	89 bb e0 40 00
	00		 mov	 DWORD PTR [ebx+16608], edi
  012d1	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  012d4	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188812:

; 484  : #else // __VER >= 8 // __S8_PK
; 485  : 			ar >> (u_short&)m_nNumKill;
; 486  : 			ar >> m_nSlaughter;
; 487  : #endif // __VER >= 8 // __S8_PK
; 488  : 			ar >> m_nFame;

  012d7	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  012da	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  012dd	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  012e0	77 0d		 ja	 SHORT $L188824
  012e2	8b 00		 mov	 eax, DWORD PTR [eax]
  012e4	89 83 f4 40 00
	00		 mov	 DWORD PTR [ebx+16628], eax
  012ea	01 4d 08	 add	 DWORD PTR [ebp+8], ecx
  012ed	eb 0c		 jmp	 SHORT $L188825
$L188824:
  012ef	89 bb f4 40 00
	00		 mov	 DWORD PTR [ebx+16628], edi
  012f5	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  012f8	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188825:

; 489  : 			ar >> (u_char&)m_nDuel;

  012fb	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  012fe	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01301	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01304	3b d1		 cmp	 edx, ecx
  01306	77 0d		 ja	 SHORT $L188830
  01308	8a 00		 mov	 al, BYTE PTR [eax]
  0130a	88 83 fc 40 00
	00		 mov	 BYTE PTR [ebx+16636], al
  01310	ff 45 08	 inc	 DWORD PTR [ebp+8]
  01313	eb 0d		 jmp	 SHORT $L188831
$L188830:
  01315	c6 83 fc 40 00
	00 00		 mov	 BYTE PTR [ebx+16636], 0
  0131c	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0131f	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188831:

; 490  : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 491  : 			int nTemp = -1;
; 492  : 			ar >> nTemp;

  01322	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01325	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01328	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0132b	3b ca		 cmp	 ecx, edx
  0132d	77 07		 ja	 SHORT $L188843
  0132f	8b 00		 mov	 eax, DWORD PTR [eax]
  01331	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01334	eb 05		 jmp	 SHORT $L188844
$L188843:
  01336	33 c0		 xor	 eax, eax
  01338	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188844:

; 493  : #ifdef __CLIENT
; 494  : 			if(m_nHonor != nTemp)//  
; 495  : 			{
; 496  : 				m_nHonor = nTemp;
; 497  : 				SetTitle(CTitleManager::Instance()->GetTitle(m_nHonor));
; 498  : 			}
; 499  : #else	// __CLIENT
; 500  : 			m_nHonor = nTemp;

  0133b	89 83 44 42 00
	00		 mov	 DWORD PTR [ebx+16964], eax
  01341	8d 83 28 45 00
	00		 lea	 eax, DWORD PTR [ebx+17704]
  01347	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  0134c	8d 64 24 00	 npad	 4
$L187467:

; 501  : #endif	// __CLIENT
; 502  : #endif	// __HONORABLE_TITLE			// 
; 503  : 			{
; 504  : 				for( int i = 0; i < MAX_HUMAN_PARTS; i ++ )
; 505  : 				{
; 506  : 					ar >> m_aEquipInfo[i].nOption;

  01350	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01353	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01356	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  01359	77 0c		 ja	 SHORT $L188855
  0135b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0135d	89 08		 mov	 DWORD PTR [eax], ecx
  0135f	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01362	83 c1 04	 add	 ecx, 4
  01365	eb 09		 jmp	 SHORT $L189342
$L188855:
  01367	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0136d	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189342:
  01370	83 c0 0c	 add	 eax, 12			; 0000000cH
  01373	4a		 dec	 edx
  01374	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01377	75 d7		 jne	 SHORT $L187467

; 507  : 				}
; 508  : 			}
; 509  : 			ar >> m_nGuildCombatState;

  01379	8b c1		 mov	 eax, ecx
  0137b	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0137e	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01381	3b d1		 cmp	 edx, ecx
  01383	77 0e		 ja	 SHORT $L188868
  01385	8b 00		 mov	 eax, DWORD PTR [eax]
  01387	89 83 04 41 00
	00		 mov	 DWORD PTR [ebx+16644], eax
  0138d	83 45 08 04	 add	 DWORD PTR [ebp+8], 4
  01391	eb 10		 jmp	 SHORT $L188869
$L188868:
  01393	c7 83 04 41 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+16644], 0
  0139d	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  013a0	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188869:

; 510  : 			
; 511  : 			for( int j = 0 ; j < SM_MAX ; ++j )

  013a3	8d 83 a8 44 00
	00		 lea	 eax, DWORD PTR [ebx+17576]
  013a9	ba 0d 00 00 00	 mov	 edx, 13			; 0000000dH
  013ae	8b ff		 npad	 2
$L187471:

; 512  : 				ar >> m_dwSMTime[j];

  013b0	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  013b3	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  013b6	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  013b9	77 0d		 ja	 SHORT $L188874
  013bb	8b 09		 mov	 ecx, DWORD PTR [ecx]
  013bd	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  013c0	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  013c3	83 c1 04	 add	 ecx, 4
  013c6	eb 0a		 jmp	 SHORT $L189343
$L188874:
  013c8	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  013cf	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189343:
  013d2	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  013d5	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  013d8	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  013db	77 15		 ja	 SHORT $L189305
  013dd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  013df	89 08		 mov	 DWORD PTR [eax], ecx
  013e1	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  013e4	bf 04 00 00 00	 mov	 edi, 4
  013e9	03 cf		 add	 ecx, edi
  013eb	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  013ee	33 c9		 xor	 ecx, ecx
  013f0	eb 0f		 jmp	 SHORT $L189306
$L189305:
  013f2	33 c9		 xor	 ecx, ecx
  013f4	89 08		 mov	 DWORD PTR [eax], ecx
  013f6	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  013f9	89 7d 08	 mov	 DWORD PTR [ebp+8], edi
  013fc	bf 04 00 00 00	 mov	 edi, 4
$L189306:
  01401	83 c0 08	 add	 eax, 8
  01404	4a		 dec	 edx
  01405	75 a9		 jne	 SHORT $L187471

; 513  : 			// ,     m_nPlusMaxHitPoint  OnApplySM() .
; 514  : 
; 515  : 			if( CObj::GetMethod() == METHOD_NONE )

  01407	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nMethod@CObj@@2HA ; CObj::m_nMethod
  0140c	3b c1		 cmp	 eax, ecx
  0140e	0f 85 6e 07 00
	00		 jne	 $L187474

; 516  : 			{
; 517  : 				m_nManaPoint	= 0;

  01414	89 8b 98 00 00
	00		 mov	 DWORD PTR [ebx+152], ecx

; 518  : 				m_nFatiguePoint	= 0;

  0141a	89 8b 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], ecx

; 519  : #if __VER < 12 // __MOD_TUTORIAL
; 520  : 				m_nFlightLv		= 0;
; 521  : #endif	// __MOD_TUTORIAL
; 522  : 				m_nRemainGP		= 0;

  01420	89 8b dc 02 00
	00		 mov	 DWORD PTR [ebx+732], ecx

; 523  : 
; 524  : 				ar >> (u_short&)m_nManaPoint;

  01426	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01429	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0142c	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  0142f	77 0f		 ja	 SHORT $L188883
  01431	66 8b 00	 mov	 ax, WORD PTR [eax]
  01434	66 89 83 98 00
	00 00		 mov	 WORD PTR [ebx+152], ax
  0143b	01 75 08	 add	 DWORD PTR [ebp+8], esi
  0143e	eb 0d		 jmp	 SHORT $L188884
$L188883:
  01440	66 89 8b 98 00
	00 00		 mov	 WORD PTR [ebx+152], cx
  01447	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  0144a	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188884:

; 525  : 				ar >> (u_short&)m_nFatiguePoint;

  0144d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01450	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  01453	3b 55 0c	 cmp	 edx, DWORD PTR [ebp+12]
  01456	77 0f		 ja	 SHORT $L188889
  01458	66 8b 00	 mov	 ax, WORD PTR [eax]
  0145b	66 89 83 9c 00
	00 00		 mov	 WORD PTR [ebx+156], ax
  01462	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01465	eb 0d		 jmp	 SHORT $L188890
$L188889:
  01467	66 89 8b 9c 00
	00 00		 mov	 WORD PTR [ebx+156], cx
  0146e	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01471	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188890:

; 526  : #if __VER >= 12 // __MOD_TUTORIAL
; 527  : 				ar >> m_nTutorialState;

  01474	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01477	8b 75 0c	 mov	 esi, DWORD PTR [ebp+12]
  0147a	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0147d	3b d6		 cmp	 edx, esi
  0147f	77 0d		 ja	 SHORT $L188902
  01481	8b 00		 mov	 eax, DWORD PTR [eax]
  01483	89 83 b0 00 00
	00		 mov	 DWORD PTR [ebx+176], eax
  01489	01 7d 08	 add	 DWORD PTR [ebp+8], edi
  0148c	eb 0c		 jmp	 SHORT $L188903
$L188902:
  0148e	89 8b b0 00 00
	00		 mov	 DWORD PTR [ebx+176], ecx
  01494	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01497	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188903:

; 528  : #ifdef __CLIENT
; 529  : 				g_Option.m_nTutorialLv	= m_nTutorialState;
; 530  : #endif	// __CLIENT
; 531  : #else	// __MOD_TUTORIAL
; 532  : 				ar >> (u_short&)m_nFlightLv;
; 533  : #endif	// __MOD_TUTORIAL
; 534  : 				ar >> m_nFxp;

  0149a	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0149d	8b 75 0c	 mov	 esi, DWORD PTR [ebp+12]
  014a0	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  014a3	3b d6		 cmp	 edx, esi
  014a5	77 0d		 ja	 SHORT $L188908
  014a7	8b 00		 mov	 eax, DWORD PTR [eax]
  014a9	89 83 b4 00 00
	00		 mov	 DWORD PTR [ebx+180], eax
  014af	01 7d 08	 add	 DWORD PTR [ebp+8], edi
  014b2	eb 0c		 jmp	 SHORT $L188909
$L188908:
  014b4	89 8b b4 00 00
	00		 mov	 DWORD PTR [ebx+180], ecx
  014ba	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  014bd	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188909:

; 535  : 
; 536  : 				ar >> dwGold;

  014c0	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  014c3	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  014c6	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  014c9	33 f6		 xor	 esi, esi
  014cb	3b ca		 cmp	 ecx, edx
  014cd	77 07		 ja	 SHORT $L188914
  014cf	8b 00		 mov	 eax, DWORD PTR [eax]
  014d1	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  014d4	eb 05		 jmp	 SHORT $L188915
$L188914:
  014d6	33 c0		 xor	 eax, eax
  014d8	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L188915:

; 537  : 				SetGold( dwGold );
; 538  : 
; 539  : 				ar >> m_nExp1;

  014db	6a 08		 push	 8
  014dd	8d 93 f0 00 00
	00		 lea	 edx, DWORD PTR [ebx+240]
  014e3	52		 push	 edx
  014e4	8b cd		 mov	 ecx, ebp
  014e6	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  014e9	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 540  : 				ar >> m_nSkillLevel;

  014ee	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  014f1	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  014f4	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  014f7	3b ca		 cmp	 ecx, edx
  014f9	77 0f		 ja	 SHORT $L188933
  014fb	8b 10		 mov	 edx, DWORD PTR [eax]
  014fd	89 93 08 41 00
	00		 mov	 DWORD PTR [ebx+16648], edx
  01503	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01506	03 c7		 add	 eax, edi
  01508	eb 09		 jmp	 SHORT $L189344
$L188933:
  0150a	89 b3 08 41 00
	00		 mov	 DWORD PTR [ebx+16648], esi
  01510	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189344:

; 541  : 				ar >> m_nSkillPoint;

  01513	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01516	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01519	3b ca		 cmp	 ecx, edx
  0151b	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  0151e	77 0f		 ja	 SHORT $L188946
  01520	8b 10		 mov	 edx, DWORD PTR [eax]
  01522	89 93 0c 41 00
	00		 mov	 DWORD PTR [ebx+16652], edx
  01528	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0152b	03 c7		 add	 eax, edi
  0152d	eb 09		 jmp	 SHORT $L189345
$L188946:
  0152f	89 b3 0c 41 00
	00		 mov	 DWORD PTR [ebx+16652], esi
  01535	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189345:

; 542  : 				ar >> m_nDeathExp;

  01538	6a 08		 push	 8
  0153a	8d 8b f8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+248]
  01540	51		 push	 ecx
  01541	8b cd		 mov	 ecx, ebp
  01543	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  01546	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 543  : 				ar >> m_nDeathLevel; 

  0154b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0154e	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01551	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01554	3b d1		 cmp	 edx, ecx
  01556	77 0d		 ja	 SHORT $L188955
  01558	8b 00		 mov	 eax, DWORD PTR [eax]
  0155a	89 83 e8 00 00
	00		 mov	 DWORD PTR [ebx+232], eax
  01560	01 7d 08	 add	 DWORD PTR [ebp+8], edi
  01563	eb 0c		 jmp	 SHORT $L188956
$L188955:
  01565	89 b3 e8 00 00
	00		 mov	 DWORD PTR [ebx+232], esi
  0156b	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0156e	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188956:

; 544  : 				DWORD dwJobLv[MAX_JOB];		//   
; 545  : 				ar.Read( (void*)dwJobLv, sizeof(DWORD) * MAX_JOB );

  01571	68 a0 00 00 00	 push	 160			; 000000a0H
  01576	8d 54 24 2c	 lea	 edx, DWORD PTR _dwJobLv$187477[esp+636]
  0157a	52		 push	 edx
  0157b	8b cd		 mov	 ecx, ebp
  0157d	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 546  : 				ar >> m_idMarkingWorld;

  01582	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01585	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01588	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0158b	3b ca		 cmp	 ecx, edx
  0158d	77 0f		 ja	 SHORT $L188961
  0158f	8b 10		 mov	 edx, DWORD PTR [eax]
  01591	89 93 cc 02 00
	00		 mov	 DWORD PTR [ebx+716], edx
  01597	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0159a	03 c7		 add	 eax, edi
  0159c	eb 09		 jmp	 SHORT $L189346
$L188961:
  0159e	89 b3 cc 02 00
	00		 mov	 DWORD PTR [ebx+716], esi
  015a4	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189346:

; 547  : 				ar >> m_vMarkingPos;

  015a7	6a 0c		 push	 12			; 0000000cH
  015a9	8d 8b d0 02 00
	00		 lea	 ecx, DWORD PTR [ebx+720]
  015af	51		 push	 ecx
  015b0	8b cd		 mov	 ecx, ebp
  015b2	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  015b5	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 548  : 				ar >> m_nQuestSize;

  015ba	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  015bd	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  015c0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  015c3	3b d1		 cmp	 edx, ecx
  015c5	77 0d		 ja	 SHORT $L188970
  015c7	8a 00		 mov	 al, BYTE PTR [eax]
  015c9	88 83 a8 46 00
	00		 mov	 BYTE PTR [ebx+18088], al
  015cf	ff 45 08	 inc	 DWORD PTR [ebp+8]
  015d2	eb 0d		 jmp	 SHORT $L188971
$L188970:
  015d4	c6 83 a8 46 00
	00 00		 mov	 BYTE PTR [ebx+18088], 0
  015db	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  015de	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L188971:

; 549  : 				ar.Read( m_aQuest, sizeof(QUEST) * m_nQuestSize ); 

  015e1	0f b6 83 a8 46
	00 00		 movzx	 eax, BYTE PTR [ebx+18088]
  015e8	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  015eb	8b 83 a0 46 00
	00		 mov	 eax, DWORD PTR [ebx+18080]
  015f1	c1 e2 02	 shl	 edx, 2
  015f4	52		 push	 edx
  015f5	50		 push	 eax
  015f6	8b cd		 mov	 ecx, ebp
  015f8	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 550  : 				ar >> m_nCompleteQuestSize;

  015fd	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01600	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01603	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01606	3b ca		 cmp	 ecx, edx
  01608	77 0e		 ja	 SHORT $L188976
  0160a	8a 10		 mov	 dl, BYTE PTR [eax]
  0160c	88 93 a9 46 00
	00		 mov	 BYTE PTR [ebx+18089], dl
  01612	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01615	40		 inc	 eax
  01616	eb 0a		 jmp	 SHORT $L189347
$L188976:
  01618	c6 83 a9 46 00
	00 00		 mov	 BYTE PTR [ebx+18089], 0
  0161f	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189347:
  01622	89 45 08	 mov	 DWORD PTR [ebp+8], eax

; 551  : 				ar.Read( m_aCompleteQuest, sizeof(WORD) * m_nCompleteQuestSize ); 

  01625	0f b6 8b a9 46
	00 00		 movzx	 ecx, BYTE PTR [ebx+18089]
  0162c	8b 93 a4 46 00
	00		 mov	 edx, DWORD PTR [ebx+18084]
  01632	d1 e1		 shl	 ecx, 1
  01634	51		 push	 ecx
  01635	52		 push	 edx
  01636	8b cd		 mov	 ecx, ebp
  01638	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 552  : 
; 553  : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 554  : 				ar >> m_nCheckedQuestSize;

  0163d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01640	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01643	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01646	3b ca		 cmp	 ecx, edx
  01648	77 0e		 ja	 SHORT $L188982
  0164a	8a 10		 mov	 dl, BYTE PTR [eax]
  0164c	88 93 c0 46 00
	00		 mov	 BYTE PTR [ebx+18112], dl
  01652	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01655	40		 inc	 eax
  01656	eb 0a		 jmp	 SHORT $L189348
$L188982:
  01658	c6 83 c0 46 00
	00 00		 mov	 BYTE PTR [ebx+18112], 0
  0165f	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189348:
  01662	89 45 08	 mov	 DWORD PTR [ebp+8], eax

; 555  : 				ar.Read( m_aCheckedQuest, sizeof(WORD) * m_nCheckedQuestSize );

  01665	0f b6 8b c0 46
	00 00		 movzx	 ecx, BYTE PTR [ebx+18112]
  0166c	8b 93 bc 46 00
	00		 mov	 edx, DWORD PTR [ebx+18108]
  01672	d1 e1		 shl	 ecx, 1
  01674	51		 push	 ecx
  01675	52		 push	 edx
  01676	8b cd		 mov	 ecx, ebp
  01678	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 556  : #endif // __IMPROVE_QUEST_INTERFACE
; 557  : 
; 558  : 				ar >> m_idMurderer;

  0167d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01680	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01683	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01686	3b ca		 cmp	 ecx, edx
  01688	77 0f		 ja	 SHORT $L188988
  0168a	8b 10		 mov	 edx, DWORD PTR [eax]
  0168c	89 93 f8 40 00
	00		 mov	 DWORD PTR [ebx+16632], edx
  01692	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01695	03 c7		 add	 eax, edi
  01697	eb 09		 jmp	 SHORT $L189349
$L188988:
  01699	89 b3 f8 40 00
	00		 mov	 DWORD PTR [ebx+16632], esi
  0169f	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189349:

; 559  : 				short n1, n2;		// n2  .
; 560  : 				ar >> n1 >> n2;		

  016a2	8b c8		 mov	 ecx, eax
  016a4	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  016a7	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  016aa	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  016ad	3b d0		 cmp	 edx, eax
  016af	77 08		 ja	 SHORT $L189001
  016b1	66 8b 09	 mov	 cx, WORD PTR [ecx]
  016b4	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  016b7	eb 05		 jmp	 SHORT $L189002
$L189001:
  016b9	33 c9		 xor	 ecx, ecx
  016bb	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L189002:
  016be	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  016c1	83 c2 02	 add	 edx, 2
  016c4	3b d0		 cmp	 edx, eax
  016c6	77 05		 ja	 SHORT $L189013
  016c8	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  016cb	eb 03		 jmp	 SHORT $L189014
$L189013:
  016cd	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L189014:

; 561  : 				m_nRemainGP	= n1;

  016d0	0f bf c9	 movsx	 ecx, cx
  016d3	89 8b dc 02 00
	00		 mov	 DWORD PTR [ebx+732], ecx
  016d9	8d 83 24 45 00
	00		 lea	 eax, DWORD PTR [ebx+17700]
  016df	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
$L187486:

; 562  : 				{
; 563  : 					for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 564  : 						ar >> m_aEquipInfo[i].dwId;

  016e4	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  016e7	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  016ea	3b 75 0c	 cmp	 esi, DWORD PTR [ebp+12]
  016ed	77 0b		 ja	 SHORT $L189018
  016ef	8b 09		 mov	 ecx, DWORD PTR [ecx]
  016f1	89 08		 mov	 DWORD PTR [eax], ecx
  016f3	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  016f6	03 cf		 add	 ecx, edi
  016f8	eb 09		 jmp	 SHORT $L189350
$L189018:
  016fa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  01700	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189350:
  01703	83 c0 0c	 add	 eax, 12			; 0000000cH
  01706	4a		 dec	 edx
  01707	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  0170a	75 d8		 jne	 SHORT $L187486

; 565  : 				}
; 566  : #ifdef __SKILL_0205
; 567  : 				ar.Read( (void*)m_aJobSkill, sizeof(SKILL) *  ( MAX_SKILL_JOB ) );

  0170c	68 98 01 00 00	 push	 408			; 00000198H
  01711	8d b3 00 01 00
	00		 lea	 esi, DWORD PTR [ebx+256]
  01717	56		 push	 esi
  01718	8b cd		 mov	 ecx, ebp
  0171a	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  0171f	8d bc 24 c8 00
	00 00		 lea	 edi, DWORD PTR _aJobSkill$187445[esp+632]

; 568  : 				for( int i = 0 ; i < MAX_SKILL_JOB; i++)

  01726	33 c0		 xor	 eax, eax
  01728	89 7c 24 1c	 mov	 DWORD PTR tv5651[esp+632], edi
  0172c	89 74 24 18	 mov	 DWORD PTR tv5656[esp+632], esi
$L187492:

; 569  : 					m_abUpdateSkill[i]	= (BOOL)( memcmp( &m_aJobSkill[i], &aJobSkill[i], sizeof(SKILL) ) != 0 );

  01730	33 d2		 xor	 edx, edx
  01732	b9 02 00 00 00	 mov	 ecx, 2
  01737	f3 a7		 repe cmpsd
  01739	8b 7c 24 1c	 mov	 edi, DWORD PTR tv5651[esp+632]
  0173d	8b 74 24 18	 mov	 esi, DWORD PTR tv5656[esp+632]
  01741	0f 95 c1	 setne	 cl
  01744	88 8c 18 98 02
	00 00		 mov	 BYTE PTR [eax+ebx+664], cl
  0174b	40		 inc	 eax
  0174c	83 c7 08	 add	 edi, 8
  0174f	83 c6 08	 add	 esi, 8
  01752	83 f8 33	 cmp	 eax, 51			; 00000033H
  01755	89 7c 24 1c	 mov	 DWORD PTR tv5651[esp+632], edi
  01759	89 74 24 18	 mov	 DWORD PTR tv5656[esp+632], esi
  0175d	7c d1		 jl	 SHORT $L187492

; 570  : #else	// __SKILL_0205
; 571  : 				ar.Read( (void*)m_aJobSkill, sizeof(SKILL) *  ( MAX_SKILL_JOB ) );
; 572  : #endif	// __SKILL_0205
; 573  : 
; 574  : 				m_nCheerPoint	= 0;

  0175f	33 c9		 xor	 ecx, ecx
  01761	89 8b b4 46 00
	00		 mov	 DWORD PTR [ebx+18100], ecx

; 575  : 				ar >> (BYTE&)m_nCheerPoint >> m_dwTickCheer;

  01767	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0176a	8b 75 0c	 mov	 esi, DWORD PTR [ebp+12]
  0176d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01770	3b d6		 cmp	 edx, esi
  01772	77 0d		 ja	 SHORT $L189024
  01774	8a 00		 mov	 al, BYTE PTR [eax]
  01776	88 83 b4 46 00
	00		 mov	 BYTE PTR [ebx+18100], al
  0177c	ff 45 08	 inc	 DWORD PTR [ebp+8]
  0177f	eb 0d		 jmp	 SHORT $L189025
$L189024:
  01781	c6 83 b4 46 00
	00 00		 mov	 BYTE PTR [ebx+18100], 0
  01788	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  0178b	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L189025:
  0178e	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01791	8b 75 0c	 mov	 esi, DWORD PTR [ebp+12]
  01794	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01797	3b d6		 cmp	 edx, esi
  01799	77 0e		 ja	 SHORT $L189030
  0179b	8b 00		 mov	 eax, DWORD PTR [eax]
  0179d	89 83 b0 46 00
	00		 mov	 DWORD PTR [ebx+18096], eax
  017a3	83 45 08 04	 add	 DWORD PTR [ebp+8], 4
  017a7	eb 0c		 jmp	 SHORT $L189031
$L189030:
  017a9	89 8b b0 46 00
	00		 mov	 DWORD PTR [ebx+18096], ecx
  017af	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  017b2	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189031:

; 576  : 				m_dwTickCheer	+= GetTickCount();

  017b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  017bb	01 83 b0 46 00
	00		 add	 DWORD PTR [ebx+18096], eax

; 577  : 				ar >> m_nSlot;

  017c1	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  017c4	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  017c7	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  017ca	3b d1		 cmp	 edx, ecx
  017cc	77 0d		 ja	 SHORT $L189036
  017ce	8a 00		 mov	 al, BYTE PTR [eax]
  017d0	88 83 c8 00 00
	00		 mov	 BYTE PTR [ebx+200], al
  017d6	ff 45 08	 inc	 DWORD PTR [ebp+8]
  017d9	eb 0d		 jmp	 SHORT $L189037
$L189036:
  017db	c6 83 c8 00 00
	00 00		 mov	 BYTE PTR [ebx+200], 0
  017e2	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  017e5	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189037:

; 578  : 				for( int k = 0 ; k < 3 ; ++k )
; 579  : 					ar >> m_dwGoldBank[k];

  017e8	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  017eb	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  017ee	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  017f1	3b d1		 cmp	 edx, ecx
  017f3	be 04 00 00 00	 mov	 esi, 4
  017f8	77 0d		 ja	 SHORT $L189042
  017fa	8b 00		 mov	 eax, DWORD PTR [eax]
  017fc	89 83 d0 41 00
	00		 mov	 DWORD PTR [ebx+16848], eax
  01802	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01805	eb 10		 jmp	 SHORT $L189351
$L189042:
  01807	c7 83 d0 41 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+16848], 0
  01811	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01814	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189351:
  01817	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0181a	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0181d	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01820	33 ff		 xor	 edi, edi
  01822	3b d1		 cmp	 edx, ecx
  01824	77 0d		 ja	 SHORT $L189308
  01826	8b 00		 mov	 eax, DWORD PTR [eax]
  01828	89 83 d4 41 00
	00		 mov	 DWORD PTR [ebx+16852], eax
  0182e	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01831	eb 0c		 jmp	 SHORT $L189309
$L189308:
  01833	89 bb d4 41 00
	00		 mov	 DWORD PTR [ebx+16852], edi
  01839	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0183c	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189309:
  0183f	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01842	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01845	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01848	3b d1		 cmp	 edx, ecx
  0184a	77 0d		 ja	 SHORT $L189311
  0184c	8b 00		 mov	 eax, DWORD PTR [eax]
  0184e	89 83 d8 41 00
	00		 mov	 DWORD PTR [ebx+16856], eax
  01854	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01857	eb 0c		 jmp	 SHORT $L189312
$L189311:
  01859	89 bb d8 41 00
	00		 mov	 DWORD PTR [ebx+16856], edi
  0185f	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01862	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189312:

; 580  : 				for( k = 0 ; k < 3 ; ++k )
; 581  : 					ar >> m_idPlayerBank[k];

  01865	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01868	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0186b	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0186e	3b d1		 cmp	 edx, ecx
  01870	77 0d		 ja	 SHORT $L189048
  01872	8b 00		 mov	 eax, DWORD PTR [eax]
  01874	89 83 88 41 00
	00		 mov	 DWORD PTR [ebx+16776], eax
  0187a	01 75 08	 add	 DWORD PTR [ebp+8], esi
  0187d	eb 0c		 jmp	 SHORT $L187503
$L189048:
  0187f	89 bb 88 41 00
	00		 mov	 DWORD PTR [ebx+16776], edi
  01885	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01888	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L187503:
  0188b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0188e	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01891	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01894	3b d1		 cmp	 edx, ecx
  01896	77 0d		 ja	 SHORT $L189314
  01898	8b 00		 mov	 eax, DWORD PTR [eax]
  0189a	89 83 8c 41 00
	00		 mov	 DWORD PTR [ebx+16780], eax
  018a0	01 75 08	 add	 DWORD PTR [ebp+8], esi
  018a3	eb 0c		 jmp	 SHORT $L189315
$L189314:
  018a5	89 bb 8c 41 00
	00		 mov	 DWORD PTR [ebx+16780], edi
  018ab	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  018ae	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189315:
  018b1	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  018b4	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  018b7	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  018ba	3b d1		 cmp	 edx, ecx
  018bc	77 0d		 ja	 SHORT $L189317
  018be	8b 00		 mov	 eax, DWORD PTR [eax]
  018c0	89 83 90 41 00
	00		 mov	 DWORD PTR [ebx+16784], eax
  018c6	01 75 08	 add	 DWORD PTR [ebp+8], esi
  018c9	eb 0c		 jmp	 SHORT $L189318
$L189317:
  018cb	89 bb 90 41 00
	00		 mov	 DWORD PTR [ebx+16784], edi
  018d1	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  018d4	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189318:

; 582  : 
; 583  : 				ar >> m_nPlusMaxHitPoint;

  018d7	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  018da	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  018dd	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  018e0	3b d1		 cmp	 edx, ecx
  018e2	77 0d		 ja	 SHORT $L189054
  018e4	8b 00		 mov	 eax, DWORD PTR [eax]
  018e6	89 83 a0 44 00
	00		 mov	 DWORD PTR [ebx+17568], eax
  018ec	01 75 08	 add	 DWORD PTR [ebp+8], esi
  018ef	eb 0c		 jmp	 SHORT $L189055
$L189054:
  018f1	89 bb a0 44 00
	00		 mov	 DWORD PTR [ebx+17568], edi
  018f7	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  018fa	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189055:

; 584  : 				ar >> m_nAttackResistLeft;

  018fd	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01900	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01903	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01906	3b d1		 cmp	 edx, ecx
  01908	77 0d		 ja	 SHORT $L189060
  0190a	8a 00		 mov	 al, BYTE PTR [eax]
  0190c	88 83 0c 45 00
	00		 mov	 BYTE PTR [ebx+17676], al
  01912	ff 45 08	 inc	 DWORD PTR [ebp+8]
  01915	eb 0d		 jmp	 SHORT $L189061
$L189060:
  01917	c6 83 0c 45 00
	00 00		 mov	 BYTE PTR [ebx+17676], 0
  0191e	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01921	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189061:

; 585  : 				ar >> m_nAttackResistRight;

  01924	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01927	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0192a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0192d	3b d1		 cmp	 edx, ecx
  0192f	77 0d		 ja	 SHORT $L189066
  01931	8a 00		 mov	 al, BYTE PTR [eax]
  01933	88 83 0d 45 00
	00		 mov	 BYTE PTR [ebx+17677], al
  01939	ff 45 08	 inc	 DWORD PTR [ebp+8]
  0193c	eb 0d		 jmp	 SHORT $L189067
$L189066:
  0193e	c6 83 0d 45 00
	00 00		 mov	 BYTE PTR [ebx+17677], 0
  01945	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01948	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189067:

; 586  : 				ar >> m_nDefenseResist;

  0194b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0194e	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01951	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01954	3b d1		 cmp	 edx, ecx
  01956	77 0d		 ja	 SHORT $L189072
  01958	8a 00		 mov	 al, BYTE PTR [eax]
  0195a	88 83 0e 45 00
	00		 mov	 BYTE PTR [ebx+17678], al
  01960	ff 45 08	 inc	 DWORD PTR [ebp+8]
  01963	eb 0d		 jmp	 SHORT $L189073
$L189072:
  01965	c6 83 0e 45 00
	00 00		 mov	 BYTE PTR [ebx+17678], 0
  0196c	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0196f	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189073:

; 587  : #if __VER >= 8 //__CSC_VER8_5
; 588  : 				ar >> m_nAngelExp;

  01972	6a 08		 push	 8
  01974	8d 93 e8 40 00
	00		 lea	 edx, DWORD PTR [ebx+16616]
  0197a	52		 push	 edx
  0197b	8b cd		 mov	 ecx, ebp
  0197d	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 589  : 				ar >> m_nAngelLevel;

  01982	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01985	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01988	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0198b	3b ca		 cmp	 ecx, edx
  0198d	77 0f		 ja	 SHORT $L189081
  0198f	8b 10		 mov	 edx, DWORD PTR [eax]
  01991	89 93 f0 40 00
	00		 mov	 DWORD PTR [ebx+16624], edx
  01997	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0199a	03 c6		 add	 eax, esi
  0199c	eb 09		 jmp	 SHORT $L189352
$L189081:
  0199e	89 bb f0 40 00
	00		 mov	 DWORD PTR [ebx+16624], edi
  019a4	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189352:

; 590  : #endif // __CSC_VER8_5
; 591  : 				m_Inventory.Serialize( ar );

  019a7	8d bb 14 41 00
	00		 lea	 edi, DWORD PTR [ebx+16660]
  019ad	55		 push	 ebp
  019ae	8b cf		 mov	 ecx, edi
  019b0	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  019b3	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  019b8	8d b3 94 41 00
	00		 lea	 esi, DWORD PTR [ebx+16788]
  019be	c7 44 24 18 03
	00 00 00	 mov	 DWORD PTR tv2358[esp+632], 3
$L187505:

; 592  : 				for( k = 0 ; k < 3 ; ++k )
; 593  : 					m_Bank[k].Serialize( ar );

  019c6	55		 push	 ebp
  019c7	8b ce		 mov	 ecx, esi
  019c9	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  019ce	8b 44 24 18	 mov	 eax, DWORD PTR tv2358[esp+632]
  019d2	83 c6 14	 add	 esi, 20			; 00000014H
  019d5	48		 dec	 eax
  019d6	89 44 24 18	 mov	 DWORD PTR tv2358[esp+632], eax
  019da	75 ea		 jne	 SHORT $L187505

; 594  : 
; 595  : 				CItemElem* pItemElem	= m_Inventory.GetEquip( PARTS_RIDE );

  019dc	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  019df	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  019e2	8b 44 8a 34	 mov	 eax, DWORD PTR [edx+ecx*4+52]
  019e6	33 f6		 xor	 esi, esi
  019e8	83 f8 ff	 cmp	 eax, -1
  019eb	74 1b		 je	 SHORT $L187509
  019ed	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  019f0	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  019f3	c1 e0 05	 shl	 eax, 5
  019f6	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  019fa	03 c2		 add	 eax, edx
  019fc	3b ce		 cmp	 ecx, esi
  019fe	74 08		 je	 SHORT $L187509

; 596  : 				if( pItemElem )
; 597  : 					m_dwRideItemIdx		= pItemElem->m_dwItemId;

  01a00	8b c1		 mov	 eax, ecx
  01a02	89 83 bc 00 00
	00		 mov	 DWORD PTR [ebx+188], eax
$L187509:

; 598  : 
; 599  : #if __VER >= 9	// __PET_0410
; 600  : 				DWORD dwPetId;
; 601  : 				ar >> dwPetId;

  01a08	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01a0b	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01a0e	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01a11	3b ca		 cmp	 ecx, edx
  01a13	77 07		 ja	 SHORT $L189112
  01a15	8b 00		 mov	 eax, DWORD PTR [eax]
  01a17	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01a1a	eb 05		 jmp	 SHORT $L189113
$L189112:
  01a1c	33 c0		 xor	 eax, eax
  01a1e	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L189113:

; 602  : 				SetPetId( dwPetId );
; 603  : 	#ifdef __PET_1024
; 604  : 	#ifdef __CLIENT
; 605  : 				CPet* pPet	= GetPet();
; 606  : 				if( pPet )
; 607  : 					m_pet.SetName( const_cast<char*>( pPet->GetName() ) );
; 608  : 	#endif	// __CLIENT
; 609  : 	#endif	// __PET_1024
; 610  : #endif	// __PET_0410
; 611  : #if __VER >= 11 // __SYS_POCKET
; 612  : 				m_Pocket.Serialize( ar );

  01a21	55		 push	 ebp
  01a22	8d 8b 78 41 00
	00		 lea	 ecx, DWORD PTR [ebx+16760]
  01a28	89 83 30 42 00
	00		 mov	 DWORD PTR [ebx+16944], eax
  01a2e	e8 00 00 00 00	 call	 ?Serialize@CPocketController@@QAEXAAVCAr@@@Z ; CPocketController::Serialize

; 613  : #endif	// __SYS_POCKET
; 614  : 
; 615  : #ifdef __JEFF_9_20
; 616  : 				ar >> m_dwMute;

  01a33	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01a36	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01a39	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01a3c	3b ca		 cmp	 ecx, edx
  01a3e	77 14		 ja	 SHORT $L189121
  01a40	8b 10		 mov	 edx, DWORD PTR [eax]
  01a42	89 93 f0 41 00
	00		 mov	 DWORD PTR [ebx+16880], edx
  01a48	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01a4b	ba 04 00 00 00	 mov	 edx, 4
  01a50	03 c2		 add	 eax, edx
  01a52	eb 0e		 jmp	 SHORT $L189353
$L189121:
  01a54	89 b3 f0 41 00
	00		 mov	 DWORD PTR [ebx+16880], esi
  01a5a	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  01a5d	ba 04 00 00 00	 mov	 edx, 4
$L189353:
  01a62	89 45 08	 mov	 DWORD PTR [ebp+8], eax

; 617  : #endif	// __JEFF_9_20
; 618  : #if __VER >= 13 // __HONORABLE_TITLE	// 
; 619  : #ifdef __CLIENT
; 620  : 				CTitleManager::Instance()->InitEarned();
; 621  : #endif	// __CLIENT
; 622  : 				for( int l = 0 ; l < MAX_HONOR_TITLE ; ++l )

  01a65	8d 83 4c 42 00
	00		 lea	 eax, DWORD PTR [ebx+16972]
  01a6b	c7 44 24 18 19
	00 00 00	 mov	 DWORD PTR tv3306[esp+632], 25 ; 00000019H
$L187512:

; 623  : 				{
; 624  : 					ar >> m_aHonorTitle[l];

  01a73	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01a76	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01a79	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  01a7c	77 0c		 ja	 SHORT $L189134
  01a7e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01a80	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  01a83	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01a86	03 ca		 add	 ecx, edx
  01a88	eb 06		 jmp	 SHORT $L189354
$L189134:
  01a8a	89 70 fc	 mov	 DWORD PTR [eax-4], esi
  01a8d	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189354:
  01a90	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01a93	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  01a96	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01a99	77 0b		 ja	 SHORT $L189319
  01a9b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01a9d	89 08		 mov	 DWORD PTR [eax], ecx
  01a9f	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01aa2	03 ca		 add	 ecx, edx
  01aa4	eb 05		 jmp	 SHORT $L189355
$L189319:
  01aa6	89 30		 mov	 DWORD PTR [eax], esi
  01aa8	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189355:
  01aab	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01aae	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  01ab1	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01ab4	77 0c		 ja	 SHORT $L189321
  01ab6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01ab8	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01abb	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01abe	03 ca		 add	 ecx, edx
  01ac0	eb 06		 jmp	 SHORT $L189356
$L189321:
  01ac2	89 70 04	 mov	 DWORD PTR [eax+4], esi
  01ac5	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189356:
  01ac8	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01acb	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  01ace	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01ad1	77 0c		 ja	 SHORT $L189323
  01ad3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01ad5	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  01ad8	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01adb	03 ca		 add	 ecx, edx
  01add	eb 06		 jmp	 SHORT $L189357
$L189323:
  01adf	89 70 08	 mov	 DWORD PTR [eax+8], esi
  01ae2	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189357:
  01ae5	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01ae8	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  01aeb	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01aee	77 0c		 ja	 SHORT $L189325
  01af0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01af2	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  01af5	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01af8	03 ca		 add	 ecx, edx
  01afa	eb 06		 jmp	 SHORT $L189358
$L189325:
  01afc	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  01aff	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189358:
  01b02	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01b05	3b 7d 0c	 cmp	 edi, DWORD PTR [ebp+12]
  01b08	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01b0b	77 0c		 ja	 SHORT $L189327
  01b0d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01b0f	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01b12	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01b15	03 ca		 add	 ecx, edx
  01b17	eb 06		 jmp	 SHORT $L189359
$L189327:
  01b19	89 70 10	 mov	 DWORD PTR [eax+16], esi
  01b1c	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
$L189359:
  01b1f	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01b22	8b 4c 24 18	 mov	 ecx, DWORD PTR tv3306[esp+632]
  01b26	83 c0 18	 add	 eax, 24			; 00000018H
  01b29	49		 dec	 ecx
  01b2a	89 4c 24 18	 mov	 DWORD PTR tv3306[esp+632], ecx
  01b2e	0f 85 3f ff ff
	ff		 jne	 $L187512

; 625  : #ifdef __CLIENT
; 626  : 					int nNeed = CTitleManager::Instance()->GetNeedCount(l, -1);
; 627  : 					if(m_aHonorTitle[l] >= nNeed && nNeed > 0)
; 628  : 					{
; 629  : 						CTitleManager::Instance()->AddEarned(l);	
; 630  : 					}
; 631  : 					else
; 632  : 					{
; 633  : 						//     
; 634  : 						if(CTitleManager::Instance()->IsEarned(l))
; 635  : 						{
; 636  : 							CTitleManager::Instance()->RemoveEarned(l);
; 637  : 						}
; 638  : 					}
; 639  : #endif	// __CLIENT
; 640  : 				}
; 641  : #endif	// __HONORABLE_TITLE			// 
; 642  : #if __VER >= 15 // __CAMPUS
; 643  : 				ar >> m_idCampus;

  01b34	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01b37	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  01b3a	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01b3d	3b cf		 cmp	 ecx, edi
  01b3f	77 0d		 ja	 SHORT $L189140
  01b41	8b 00		 mov	 eax, DWORD PTR [eax]
  01b43	89 83 c4 46 00
	00		 mov	 DWORD PTR [ebx+18116], eax
  01b49	01 55 08	 add	 DWORD PTR [ebp+8], edx
  01b4c	eb 0c		 jmp	 SHORT $L189141
$L189140:
  01b4e	89 b3 c4 46 00
	00		 mov	 DWORD PTR [ebx+18116], esi
  01b54	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01b57	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189141:

; 644  : 				ar >> m_nCampusPoint;

  01b5a	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01b5d	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  01b60	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01b63	3b cf		 cmp	 ecx, edi
  01b65	77 10		 ja	 SHORT $L189153
  01b67	8b 00		 mov	 eax, DWORD PTR [eax]
  01b69	89 83 c8 46 00
	00		 mov	 DWORD PTR [ebx+18120], eax
  01b6f	01 55 08	 add	 DWORD PTR [ebp+8], edx
  01b72	e9 8a 02 00 00	 jmp	 $L189260
$L189153:
  01b77	89 b3 c8 46 00
	00		 mov	 DWORD PTR [ebx+18120], esi

; 645  : #endif // __CAMPUS
; 646  : 			}
; 647  : 			else if( CObj::GetMethod() == METHOD_EXCLUDE_ITEM )

  01b7d	e9 79 02 00 00	 jmp	 $L189360
$L187474:
  01b82	83 f8 01	 cmp	 eax, 1
  01b85	0f 85 76 02 00
	00		 jne	 $L189260

; 648  : 			{
; 649  : 			#if defined (__WORLDSERVER) || defined(__CLIENT)
; 650  : 				char szPVendor[MAX_VENDORNAME] = {0, };
; 651  : 				ar.ReadString( szPVendor, MAX_VENDORNAME );
; 652  : 				m_vtInfo.SetTitle( szPVendor );
; 653  : 			#endif
; 654  : 				for( int i = 0; i < MAX_HUMAN_PARTS; i++ )

  01b8b	8d 83 24 45 00
	00		 lea	 eax, DWORD PTR [ebx+17700]
  01b91	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
$L187518:

; 655  : 					m_aEquipInfo[i].dwId	= NULL_ID;

  01b96	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  01b9c	83 c0 0c	 add	 eax, 12			; 0000000cH
  01b9f	49		 dec	 ecx
  01ba0	75 f4		 jne	 SHORT $L187518

; 656  : 
; 657  : 				u_char uSize;
; 658  : 				ar >> uSize;

  01ba2	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01ba5	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01ba8	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01bab	3b ca		 cmp	 ecx, edx
  01bad	77 07		 ja	 SHORT $L189162
  01baf	8a 00		 mov	 al, BYTE PTR [eax]
  01bb1	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01bb4	eb 05		 jmp	 SHORT $L189163
$L189162:
  01bb6	32 c0		 xor	 al, al
  01bb8	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L189163:

; 659  : 				u_char uParts;
; 660  : 				u_short	u2;
; 661  : 				for( u_char uCount = 0; uCount < uSize; uCount++ )

  01bbb	84 c0		 test	 al, al
  01bbd	76 76		 jbe	 SHORT $L187527
  01bbf	0f b6 d0	 movzx	 edx, al
  01bc2	89 54 24 18	 mov	 DWORD PTR tv3218[esp+632], edx
$L187525:

; 662  : 				{
; 663  : 					ar >> uParts;

  01bc6	8b 75 08	 mov	 esi, DWORD PTR [ebp+8]
  01bc9	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  01bcc	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
  01bcf	3b f8		 cmp	 edi, eax
  01bd1	77 07		 ja	 SHORT $L189167
  01bd3	8a 16		 mov	 dl, BYTE PTR [esi]
  01bd5	89 7d 08	 mov	 DWORD PTR [ebp+8], edi
  01bd8	eb 05		 jmp	 SHORT $L189168
$L189167:
  01bda	32 d2		 xor	 dl, dl
  01bdc	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L189168:

; 664  : 					ar >> u2;

  01bdf	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01be2	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
  01be5	3b f0		 cmp	 esi, eax
  01be7	77 08		 ja	 SHORT $L189172
  01be9	66 8b 09	 mov	 cx, WORD PTR [ecx]
  01bec	89 75 08	 mov	 DWORD PTR [ebp+8], esi
  01bef	eb 05		 jmp	 SHORT $L189173
$L189172:
  01bf1	33 c9		 xor	 ecx, ecx
  01bf3	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L189173:

; 665  : 					m_aEquipInfo[uParts].dwId	= (DWORD)u2;

  01bf6	0f b6 c2	 movzx	 eax, dl
  01bf9	0f b7 c9	 movzx	 ecx, cx
  01bfc	8d 94 40 49 11
	00 00		 lea	 edx, DWORD PTR [eax+eax*2+4425]
  01c03	89 0c 93	 mov	 DWORD PTR [ebx+edx*4], ecx

; 666  : 					ar >> m_aEquipInfo[uParts].byFlag;

  01c06	8b 75 0c	 mov	 esi, DWORD PTR [ebp+12]
  01c09	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01c0c	8d 8c 83 2c 45
	00 00		 lea	 ecx, DWORD PTR [ebx+eax*4+17708]
  01c13	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01c16	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01c19	3b d6		 cmp	 edx, esi
  01c1b	77 09		 ja	 SHORT $L189177
  01c1d	8a 00		 mov	 al, BYTE PTR [eax]
  01c1f	88 01		 mov	 BYTE PTR [ecx], al
  01c21	ff 45 08	 inc	 DWORD PTR [ebp+8]
  01c24	eb 09		 jmp	 SHORT $L187526
$L189177:
  01c26	c6 01 00	 mov	 BYTE PTR [ecx], 0
  01c29	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01c2c	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L187526:
  01c2f	ff 4c 24 18	 dec	 DWORD PTR tv3218[esp+632]
  01c33	75 91		 jne	 SHORT $L187525
$L187527:

; 667  : 				}
; 668  : 				if( m_aEquipInfo[PARTS_RIDE].dwId != NULL_ID )

  01c35	8b 83 c0 45 00
	00		 mov	 eax, DWORD PTR [ebx+17856]
  01c3b	83 f8 ff	 cmp	 eax, -1
  01c3e	74 06		 je	 SHORT $L187529

; 669  : 					m_dwRideItemIdx		= m_aEquipInfo[PARTS_RIDE].dwId;

  01c40	89 83 bc 00 00
	00		 mov	 DWORD PTR [ebx+188], eax
$L187529:

; 670  : #if __VER >= 9	// __PET_0410
; 671  : 				DWORD dwPetId;
; 672  : 				ar >> dwPetId;

  01c46	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01c49	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01c4c	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01c4f	3b ca		 cmp	 ecx, edx
  01c51	77 07		 ja	 SHORT $L189183
  01c53	8b 00		 mov	 eax, DWORD PTR [eax]
  01c55	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  01c58	eb 05		 jmp	 SHORT $L189184
$L189183:
  01c5a	33 c0		 xor	 eax, eax
  01c5c	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L189184:

; 673  : 				SetPetId( dwPetId );
; 674  : 	#ifdef __PET_1024
; 675  : 				char szPetName[MAX_PET_NAME]	= { 0,};

  01c5f	33 d2		 xor	 edx, edx
  01c61	89 94 24 61 02
	00 00		 mov	 DWORD PTR _szPetName$187531[esp+633], edx
  01c68	89 83 30 42 00
	00		 mov	 DWORD PTR [ebx+16944], eax
  01c6e	89 94 24 65 02
	00 00		 mov	 DWORD PTR _szPetName$187531[esp+637], edx

; 676  : 				ar.ReadString( szPetName, MAX_PET_NAME );

  01c75	6a 11		 push	 17			; 00000011H
  01c77	8d 84 24 64 02
	00 00		 lea	 eax, DWORD PTR _szPetName$187531[esp+636]
  01c7e	89 94 24 6d 02
	00 00		 mov	 DWORD PTR _szPetName$187531[esp+645], edx
  01c85	50		 push	 eax
  01c86	8b cd		 mov	 ecx, ebp
  01c88	c6 84 24 68 02
	00 00 00	 mov	 BYTE PTR _szPetName$187531[esp+640], 0
  01c90	89 94 24 75 02
	00 00		 mov	 DWORD PTR _szPetName$187531[esp+653], edx
  01c97	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString

; 677  : 	#ifdef __CLIENT
; 678  : 				m_pet.SetName( szPetName );
; 679  : 	#endif	// __CLIENT
; 680  : 	#endif	// __PET_1024
; 681  : #endif	// __PET_0410
; 682  : 			}
; 683  : 
; 684  : 		#if defined(__WORLDSERVER) || defined(__CLIENT)
; 685  : 			if( m_dwRideItemIdx )
; 686  : 			{
; 687  : 				ItemProp *pItemProp	= prj.GetItemProp( m_dwRideItemIdx );
; 688  : 				if( pItemProp && m_nFuel == -1 )
; 689  : 					m_nFuel		= (int)( pItemProp->dwFFuelReMax * 0.2f );
; 690  : 			}
; 691  : 			OnApplySM();
; 692  : 		#endif	// __WORLDSERVER	// __CLIENT
; 693  : 
; 694  : 		}
; 695  : 		else	// NPC

  01c9c	e9 60 01 00 00	 jmp	 $L189260
$L187449:

; 696  : 		{
; 697  : 			ar >> (u_char&)m_dwHairMesh >> m_dwHairColor >> (u_char&)m_dwHeadMesh;

  01ca1	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01ca4	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01ca7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01caa	3b ca		 cmp	 ecx, edx
  01cac	77 0e		 ja	 SHORT $L189192
  01cae	8a 10		 mov	 dl, BYTE PTR [eax]
  01cb0	88 93 a4 00 00
	00		 mov	 BYTE PTR [ebx+164], dl
  01cb6	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01cb9	40		 inc	 eax
  01cba	eb 0a		 jmp	 SHORT $L189361
$L189192:
  01cbc	c6 83 a4 00 00
	00 00		 mov	 BYTE PTR [ebx+164], 0
  01cc3	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189361:
  01cc6	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01cc9	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01ccc	3b ca		 cmp	 ecx, edx
  01cce	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  01cd1	77 0f		 ja	 SHORT $L189198
  01cd3	8b 10		 mov	 edx, DWORD PTR [eax]
  01cd5	89 93 a8 00 00
	00		 mov	 DWORD PTR [ebx+168], edx
  01cdb	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01cde	03 c6		 add	 eax, esi
  01ce0	eb 09		 jmp	 SHORT $L189362
$L189198:
  01ce2	89 bb a8 00 00
	00		 mov	 DWORD PTR [ebx+168], edi
  01ce8	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189362:
  01ceb	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01cee	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01cf1	3b ca		 cmp	 ecx, edx
  01cf3	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  01cf6	77 0e		 ja	 SHORT $L189204
  01cf8	8a 10		 mov	 dl, BYTE PTR [eax]
  01cfa	88 93 ac 00 00
	00		 mov	 BYTE PTR [ebx+172], dl
  01d00	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01d03	40		 inc	 eax
  01d04	eb 0a		 jmp	 SHORT $L189363
$L189204:
  01d06	c6 83 ac 00 00
	00 00		 mov	 BYTE PTR [ebx+172], 0
  01d0d	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
$L189363:

; 698  : 			ar.ReadString( m_szCharacterKey, 32 );

  01d10	6a 20		 push	 32			; 00000020H
  01d12	8d 4b 38	 lea	 ecx, DWORD PTR [ebx+56]
  01d15	51		 push	 ecx
  01d16	8b cd		 mov	 ecx, ebp
  01d18	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  01d1b	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString
  01d20	8d 83 24 45 00
	00		 lea	 eax, DWORD PTR [ebx+17700]
  01d26	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  01d2b	eb 03 8d 49 00	 npad	 5
$L187536:

; 699  : 		#if defined (__WORLDSERVER) || defined(__CLIENT)
; 700  : 			SetHairColor( m_dwHairColor );
; 701  : 		#endif	// __WORLDSERVER	//__CLIENT
; 702  : 			{
; 703  : 				for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 704  : 					m_aEquipInfo[i].dwId	= NULL_ID;

  01d30	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  01d36	83 c0 0c	 add	 eax, 12			; 0000000cH
  01d39	49		 dec	 ecx
  01d3a	75 f4		 jne	 SHORT $L187536

; 705  : 			}
; 706  : 			u_char uSize;
; 707  : 			ar >> uSize;

  01d3c	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01d3f	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01d42	40		 inc	 eax
  01d43	3b c1		 cmp	 eax, ecx
  01d45	77 05		 ja	 SHORT $L189210
  01d47	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  01d4a	eb 03		 jmp	 SHORT $L189211
$L189210:
  01d4c	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189211:

; 708  : 			if( IsEquipableNPC() )
; 709  : 			{
; 710  : 				u_char uParts;
; 711  : 				u_short	u2;
; 712  : 				for( u_char uCount = 0; uCount < uSize; uCount++ )
; 713  : 				{
; 714  : 					ar >> uParts;
; 715  : 					ar >> u2;
; 716  : 					m_aEquipInfo[uParts].dwId	= (DWORD)u2;
; 717  : 					/*
; 718  : #ifdef __PERF_0229
; 719  : 					if( GetIndex() == 11 || GetIndex() == 12 )
; 720  : 					{
; 721  : 						int nAttr	= 0; //xRandom( 0,  5 );
; 722  : 						int nAttrLevel	= 0;
; 723  : 						//if( nAttr > 0 )
; 724  : 						//	nAttrLevel= xRandom( 8, 10 );
; 725  : 						int nLevel	= 0;
; 726  : 						//if( nAttr < 3 )
; 727  : 								nLevel	= xRandom( 9, 10 );
; 728  : 						int nOption	= nLevel;
; 729  : 						nOption	|= ( nAttrLevel << 24 );
; 730  : 						nOption	|= (nAttr << 16 );
; 731  : 						m_aEquipInfo[uParts].nOption	= nOption;
; 732  : 					}
; 733  : #endif	// __PERF_0229
; 734  : 					*/
; 735  : 				}
; 736  : 			}
; 737  : 
; 738  : 			m_bActiveAttack	=
; 739  : 			m_nMovePattern	=
; 740  : 			m_nMoveEvent	=
; 741  : 									0;

  01d4f	89 7b 64	 mov	 DWORD PTR [ebx+100], edi
  01d52	89 7b 60	 mov	 DWORD PTR [ebx+96], edi
  01d55	89 7b 58	 mov	 DWORD PTR [ebx+88], edi

; 742  : 
; 743  : 			ar >> (u_char&)m_bActiveAttack;

  01d58	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01d5b	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01d5e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01d61	3b d1		 cmp	 edx, ecx
  01d63	77 0a		 ja	 SHORT $L189228
  01d65	8a 00		 mov	 al, BYTE PTR [eax]
  01d67	88 43 58	 mov	 BYTE PTR [ebx+88], al
  01d6a	ff 45 08	 inc	 DWORD PTR [ebp+8]
  01d6d	eb 0a		 jmp	 SHORT $L189229
$L189228:
  01d6f	c6 43 58 00	 mov	 BYTE PTR [ebx+88], 0
  01d73	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01d76	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189229:

; 744  : 			ar >> (u_char&)m_nMovePattern;

  01d79	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01d7c	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01d7f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01d82	3b d1		 cmp	 edx, ecx
  01d84	77 0a		 ja	 SHORT $L189234
  01d86	8a 00		 mov	 al, BYTE PTR [eax]
  01d88	88 43 60	 mov	 BYTE PTR [ebx+96], al
  01d8b	ff 45 08	 inc	 DWORD PTR [ebp+8]
  01d8e	eb 0a		 jmp	 SHORT $L189235
$L189234:
  01d90	c6 43 60 00	 mov	 BYTE PTR [ebx+96], 0
  01d94	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01d97	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189235:

; 745  : 			ar >> (u_char&)m_nMoveEvent;

  01d9a	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01d9d	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01da0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01da3	3b d1		 cmp	 edx, ecx
  01da5	77 0a		 ja	 SHORT $L189240
  01da7	8a 00		 mov	 al, BYTE PTR [eax]
  01da9	88 43 64	 mov	 BYTE PTR [ebx+100], al
  01dac	ff 45 08	 inc	 DWORD PTR [ebp+8]
  01daf	eb 0a		 jmp	 SHORT $L189241
$L189240:
  01db1	c6 43 64 00	 mov	 BYTE PTR [ebx+100], 0
  01db5	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01db8	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189241:

; 746  : 			ar >> m_nMoveEventCnt;

  01dbb	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01dbe	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01dc1	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01dc4	3b d1		 cmp	 edx, ecx
  01dc6	77 0a		 ja	 SHORT $L189253
  01dc8	8b 00		 mov	 eax, DWORD PTR [eax]
  01dca	89 43 68	 mov	 DWORD PTR [ebx+104], eax
  01dcd	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01dd0	eb 09		 jmp	 SHORT $L189254
$L189253:
  01dd2	89 7b 68	 mov	 DWORD PTR [ebx+104], edi
  01dd5	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01dd8	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189254:

; 747  : 		#ifdef __CLIENT
; 748  : 			if( *m_szCharacterKey )
; 749  : 			{
; 750  : 				LPCHARACTER pCharacter	= prj.GetCharacter( m_szCharacterKey );
; 751  : 				if( pCharacter )
; 752  : 				{
; 753  : 					_tcscpy( m_szName, pCharacter->m_strName );
; 754  : 					AllocShopInventory( pCharacter );
; 755  : 				}
; 756  : 			}
; 757  : 		#endif	// __CLIENT
; 758  : #if __VER >= 9	//__AI_0509
; 759  : 			ar >> m_fSpeedFactor;

  01ddb	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  01dde	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01de1	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01de4	3b d1		 cmp	 edx, ecx
  01de6	77 0d		 ja	 SHORT $L189259
  01de8	8b 00		 mov	 eax, DWORD PTR [eax]
  01dea	89 83 34 42 00
	00		 mov	 DWORD PTR [ebx+16948], eax
  01df0	01 75 08	 add	 DWORD PTR [ebp+8], esi
  01df3	eb 0c		 jmp	 SHORT $L189260
$L189259:
  01df5	89 bb 34 42 00
	00		 mov	 DWORD PTR [ebx+16948], edi
$L189360:
  01dfb	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01dfe	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
$L189260:

; 760  : #endif	// __AI_0509
; 761  : 		}
; 762  : 
; 763  : #ifdef __BUFF_1107
; 764  : 		m_buffs.Serialize( ar );

  01e01	8d 8b 10 45 00
	00		 lea	 ecx, DWORD PTR [ebx+17680]
  01e07	55		 push	 ebp
  01e08	e8 00 00 00 00	 call	 ?Serialize@CBuffMgr@@QAEXAAVCAr@@@Z ; CBuffMgr::Serialize

; 765  : #else	// __BUFF_1107
; 766  : 		m_SkillState.Serialize( ar );
; 767  : #endif	// __BUFF_1107
; 768  : 
; 769  : 	#ifdef __CLIENT
; 770  : 		InitInterpolation();
; 771  : 	#endif	// __CLIENT
; 772  : 
; 773  : 	} // LOADING
; 774  : 
; 775  : #ifdef __CLIENT	
; 776  : 	m_fDestScale = GetScale().x;
; 777  : 	if( m_fDestScale > 10.0f )
; 778  : 	{
; 779  : 		LPCTSTR szErr = Error( "SerializeOpt:%f %s", m_fDestScale, GetName() );
; 780  : 		ADDERRORMSG( szErr );
; 781  : 	}
; 782  : #endif
; 783  : }

  01e0d	8b 8c 24 74 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+632]
  01e14	5f		 pop	 edi
  01e15	5e		 pop	 esi
  01e16	5d		 pop	 ebp
  01e17	5b		 pop	 ebx
  01e18	33 cc		 xor	 ecx, esp
  01e1a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01e1f	81 c4 68 02 00
	00		 add	 esp, 616		; 00000268H
  01e25	c2 04 00	 ret	 4
?Serialize@CMover@@UAEXAAVCAr@@@Z ENDP			; CMover::Serialize
_TEXT	ENDS
END
