; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Database\DBConvertNew.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DB@BEDINLHB@RANKING?4RANKING_DBF?4dbo?4RANKING_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@HNMEKJGP@CDbManager?3?3UpdateGuildRanking?$LP?$KB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LJMBJH@m_dwLogo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NKFNPOPN@m_szGuild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HDDJDJAG@m_szName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LJIKPPDH@m_nWin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IGCLHJHO@m_nLose?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BBOGLCAO@m_nSurrender?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EKKIFFNL@m_AvgLevel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EMHJODPK@m_nWinPoint?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CJGBCKAI@MAKE_RANKING_STR?5?8?$CFd?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@IPKIBOKB@CDbManager?3?3RankingDBUpdate?5?$CI?$CFs?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MOGJFHKK@tr1?3?3bad_weak_ptr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOHNFIBA@SetLOD?5?3?5lv?$DN?$CFd?0?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BKFDOEMK@wt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JENMLJIO@0?5?1?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LLJCPOLH@Init?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FDLCCPK@Connect?5Not?5Item?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@NAMJIFIH@select?5count?5?$DN?5count?$CIm_idPlayer?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CKCLBOEC@Inven?5No?5Data?5Convert?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@KMPMKKMC@select?5count?5?$DN?5count?$CIm_idGuild?$CJ?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@CFCEBDAL@GuildBank?5No?5Data?5Convert?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0JD@JEKOKICJ@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CIN@DLEPDECP@CREATE?5view?5seghope?5?5as?5?5select?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0JP@LDPJLGLD@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BAF@BHMIJDAM@CREATE?5view?5seghope_guild?5?5as?5?5s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MIENAMNJ@drop?5view?5seghope?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@PBCPAKJD@drop?5view?5seghope_guild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@IGKJACAI@select?5?$CK?5from?5seghope?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@LEGEANNN@select?5?$CK?5from?5seghope_guild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FONFFEJF@m_idPlayer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@BLIMKIB@playerslot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IG@DEIOPEPG@UPDATE?5INVENTORY_TBL?5SET?5m_Inven@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HHJABCJL@UPDATE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IC@GOCAMAFG@UPDATE?5INVENTORY_EXT_TBL?5SET?5m_e@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HNFBAJDL@UPDATE?5INVENTORY_EXT_TBL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IG@OELLNNGM@UPDATE?5BANK_TBL?5SET?5m_Bank?5?$DN?5?8?$CFs@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HFOKCGBB@UPDATE?5BANK_TBL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0HD@HOMCPDMG@UPDATE?5BANK_EXT_TBL?5SET?5m_extBan@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNFPHPPG@UPDATE?5BANK_EXT_TBL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FP@DEDGGBGG@UPDATE?5GUILD_BANK_TBL?5SET?5m_Guil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IC@KHIDFCII@UPDATE?5GUILD_BANK_EXT_TBL?5SET?5m_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GI@EMHCMEPI@UPDATE?5GUILD_TBL?5SET?5m_nGuildGol@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@ICGMIJIF@GuildId?5?$DN?5?$CFd?0?5Item0?5?$DN?5?$CFd?0?5Item1?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@EEOAJLHJ@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EFMGLFAG@?C?$LF?$LP?n?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@IEHBFJPC@?F?D?H?$LC?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@GKENJFPN@GuildId?5?$DN?5?$CFd?0?5ItemName?5?3?5?$CFs?5?$CFd?1?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GF@MLKCNPJL@UPDATE?5CHARACTER_TBL?5SET?5m_dwGol@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@NAOGPEOL@IdPlayer?5?$DN?5?$CF07d?0?5Item0?5?$DN?5?$CFd?0?5Ite@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@GNEHNCOD@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@CKGEIIKM@?4?4?2RemoveItemPiercingConfirm?4log@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@HKBGNFHB@nGuildId?5?$DN?5?$CF06d?0?5ItemName?5?3?5?$CFs?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EJJFONGK@ConvItemStart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OOLLELLG@0?5?$CF?$CF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OGBLLJAD@Inventory?0?5Bank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04FEAGFOMF@?$CFd?5?$CF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KPBJBCIO@GuildBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MHDEIN@m_idGuild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0_GUILDQUEST@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@bad_weak_ptr@boost@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sp_counted_base@detail@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@sp_counted_base@detail@boost@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_copy@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_lock@sp_counted_base@detail@boost@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_add_ref@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@sp_counted_base@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gsp_counted_base@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@shared_count@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_weak_ptr@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_weak_ptr@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCooltime@CLordSkillComponent@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTick@CLordSkillComponent@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLordSkillComponentExecutable@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CLordSkillComponentExecutable@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Execute@CLordSkillComponentExecutable@@UAEXKKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLordSkillComponentExecutable@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDeposit@CCandidate@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVote@CCandidate@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCreate@CCandidate@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FILEOUT2@@YAXPBD0ZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitConvItemDialog@CDbManager@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvItemConnectDB@CDbManager@@QAEHPAVCQuery@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCQuery@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxInventory@CDbManager@@QAEKPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxGuildBank@CDbManager@@QAEKPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInventoryBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUserInventoryBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveUserInventoryBank@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveConvGuildBank@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveGuildBankList@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAH2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveGuildBankListPanya@CDbManager@@QAEHPADHPAVCQuery@@1HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRemoveItemPanya@CDbManager@@QAEKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItemInvenBank@CDbManager@@QAEHPAVCMover@@PAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItemGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@PAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveInventoryBankList@CDbManager@@QAEHPADPAVCMover@@PAH2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveInventoryBankListPanya@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PiercingConfirmInventoryBank@CDbManager@@QAEHPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PiercingConfirmGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InventoryBankConv@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildBankConv@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvItemStart@CDbManager@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@?$MemPooler@VCGuildMember@@@@QAEPAVCGuildMember@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$MemPooler@VCGuildMember@@@@QAEHPAVCGuildMember@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@?$MemPooler@VCGuild@@@@QAEPAVCGuild@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$MemPooler@VCGuild@@@@QAEHPAVCGuild@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAU_PlayerData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAU_PlayerData@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@PAVsp_counted_base@detail@boost@@@std@@QBE_NABQAVsp_counted_base@detail@boost@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLordSkillComponentExecutable@@V?$allocator@PAVCLordSkillComponentExecutable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$shared_ptr@VCCandidate@@@boost@@V?$allocator@V?$shared_ptr@VCCandidate@@@boost@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$shared_ptr@VCCandidate@@@boost@@QBEPAVCCandidate@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLEComponent@@V?$allocator@PAVCLEComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@M_J@std@@V?$allocator@U?$pair@M_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPADPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SafeStringLen@?$ChTraitsCRT@D@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$MemPooler@VCGuildMember@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$MemPooler@VCGuild@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPLoginSrvr@@AEXAAVCAr@@KPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreSrvr@@AEXAAVCAr@@PAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPTrans@@AEXAAVCAr@@KKKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPTrans@@AEXAAVCAr@@KKKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CItemContainer@VCItemElem@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$throw_exception@Vbad_weak_ptr@boost@@@boost@@YAXABVbad_weak_ptr@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_weak_ptr@boost@@@8??0bad_weak_ptr@boost@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_weak_ptr@boost@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CItemContainer@VCItemElem@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_G?$CItemContainer@VCItemElem@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXViterator@12@ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QBEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@QAE@PAU012@0ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAX@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nextnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09PKKCPLIP@bad?5alloc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CItemContainer@VCItemElem@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CMover@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@?$MemPooler@VCMover@@@@QAEHPAVCMover@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CMover@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@?$MemPooler@VCMover@@@@QAEPAVCMover@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$MemPooler@VCMover@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPiercingItem@CItemElem@@QAEKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ItemContainerStruct@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?szBuffer@?1??FILEOUT2@@YAXPBD0ZZ@4PADA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CLordSkillComponentExecutable@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_weak_ptr@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7sp_counted_base@detail@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?hItemConvDlg@@3PAUHWND__@@A			; hItemConvDlg
PUBLIC	?hItemConvWndPB@@3PAUHWND__@@A			; hItemConvWndPB
_BSS	SEGMENT
?hItemConvDlg@@3PAUHWND__@@A DD 01H DUP (?)		; hItemConvDlg
?hItemConvWndPB@@3PAUHWND__@@A DD 01H DUP (?)		; hItemConvWndPB
_BSS	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __P$[esp-4]
  00004	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogty
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?FILEOUT2@@YAXPBD0ZZ				; FILEOUT2
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_02BKFDOEMK@wt?$AA@			; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fprintf:NEAR
EXTRN	__vsnprintf:NEAR
;	COMDAT ?szBuffer@?1??FILEOUT2@@YAXPBD0ZZ@4PADA
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
_BSS	SEGMENT
?szBuffer@?1??FILEOUT2@@YAXPBD0ZZ@4PADA DB 0a000H DUP (?) ; `FILEOUT2'::`2'::szBuffer
_BSS	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BKFDOEMK@wt?$AA@
CONST	SEGMENT
??_C@_02BKFDOEMK@wt?$AA@ DB 'wt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?FILEOUT2@@YAXPBD0ZZ
_TEXT	SEGMENT
_lpszFileName$ = 8					; size = 4
_lpszFormat$ = 12					; size = 4
?FILEOUT2@@YAXPBD0ZZ PROC NEAR				; FILEOUT2, COMDAT

; 23   : 	va_list args;
; 24   : 	va_start(args, lpszFormat);
; 25   : 	int nBuf;
; 26   : 	static TCHAR szBuffer[40960];
; 27   : 	nBuf = _vsntprintf(szBuffer, 40960, lpszFormat, args);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _lpszFormat$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8d 44 24 14	 lea	 eax, DWORD PTR _lpszFormat$[esp+8]
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	68 00 a0 00 00	 push	 40960			; 0000a000H
  00011	68 00 00 00 00	 push	 OFFSET FLAT:?szBuffer@?1??FILEOUT2@@YAXPBD0ZZ@4PADA
  00016	e8 00 00 00 00	 call	 __vsnprintf

; 28   : 	FILE* fp;
; 29   : 	if(!(fp = fopen(lpszFileName,"a")))

  0001b	8b 7c 24 1c	 mov	 edi, DWORD PTR _lpszFileName$[esp+20]
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01MCMALHOG@a?$AA@
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 _fopen
  0002a	8b f0		 mov	 esi, eax
  0002c	83 c4 18	 add	 esp, 24			; 00000018H
  0002f	85 f6		 test	 esi, esi
  00031	75 14		 jne	 SHORT $L204480

; 30   : 		if(!(fp = fopen(lpszFileName,"wt")))

  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02BKFDOEMK@wt?$AA@
  00038	57		 push	 edi
  00039	e8 00 00 00 00	 call	 _fopen
  0003e	8b f0		 mov	 esi, eax
  00040	83 c4 08	 add	 esp, 8
  00043	85 f6		 test	 esi, esi
  00045	74 1f		 je	 SHORT $L204468
$L204480:

; 31   : 			return;
; 32   : 		fprintf(fp,szBuffer);

  00047	68 00 00 00 00	 push	 OFFSET FLAT:?szBuffer@?1??FILEOUT2@@YAXPBD0ZZ@4PADA
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 _fprintf

; 33   : 		fprintf(fp,"\r\n");

  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 _fprintf

; 34   : 		va_end(args);
; 35   : 		fclose(fp);

  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 _fclose
  00063	83 c4 14	 add	 esp, 20			; 00000014H
$L204468:
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi

; 36   : }

  00068	c3		 ret	 0
?FILEOUT2@@YAXPBD0ZZ ENDP				; FILEOUT2
_TEXT	ENDS
PUBLIC	?InitConvItemDialog@CDbManager@@QAEXXZ		; CDbManager::InitConvItemDialog
PUBLIC	??_C@_05JENMLJIO@0?5?1?50?$AA@			; `string'
PUBLIC	??_C@_04LLJCPOLH@Init?$AA@			; `string'
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__CreateDialogParamA@20:NEAR
EXTRN	__imp__GetDlgItem@8:NEAR
EXTRN	__imp__SetDlgItemTextA@12:NEAR
EXTRN	?VerifyPlayerDlgProc@@YGHPAUHWND__@@IIJ@Z:NEAR	; VerifyPlayerDlgProc
EXTRN	?hMainWnd@@3PAUHWND__@@A:DWORD			; hMainWnd
EXTRN	?hInst@@3PAUHINSTANCE__@@A:DWORD		; hInst
EXTRN	__imp__SendMessageA@16:NEAR
;	COMDAT ??_C@_05JENMLJIO@0?5?1?50?$AA@
CONST	SEGMENT
??_C@_05JENMLJIO@0?5?1?50?$AA@ DB '0 / 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLJCPOLH@Init?$AA@
CONST	SEGMENT
??_C@_04LLJCPOLH@Init?$AA@ DB 'Init', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?InitConvItemDialog@CDbManager@@QAEXXZ
_TEXT	SEGMENT
?InitConvItemDialog@CDbManager@@QAEXXZ PROC NEAR	; CDbManager::InitConvItemDialog, COMDAT
; _this$ = ecx

; 49   : 	HWND hItemConvDlg	= CreateDialog( hInst, MAKEINTRESOURCE( IDD_VERIFYPLAYER ),
; 50   : 		hMainWnd, VerifyPlayerDlgProc );

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMainWnd@@3PAUHWND__@@A ; hMainWnd
  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hInst@@3PAUHINSTANCE__@@A ; hInst
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET FLAT:?VerifyPlayerDlgProc@@YGHPAUHWND__@@IIJ@Z ; VerifyPlayerDlgProc
  00015	50		 push	 eax
  00016	68 87 00 00 00	 push	 135			; 00000087H
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDialogParamA@20
  00022	8b f0		 mov	 esi, eax

; 51   : 	ShowWindow( hItemConvDlg, SW_SHOW );

  00024	6a 05		 push	 5
  00026	56		 push	 esi
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 52   : 	HWND hItemConvWndPB;
; 53   : 	hItemConvWndPB	= GetDlgItem( hItemConvDlg, IDC_PROGRESS1 );

  0002d	68 e8 03 00 00	 push	 1000			; 000003e8H
  00032	56		 push	 esi
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8

; 54   : 	SetDlgItemText( hItemConvDlg, IDC_STATIC1, "0 / 0" );

  00039	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetDlgItemTextA@12
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05JENMLJIO@0?5?1?50?$AA@
  00044	68 e9 03 00 00	 push	 1001			; 000003e9H
  00049	56		 push	 esi
  0004a	8b f8		 mov	 edi, eax
  0004c	ff d3		 call	 ebx

; 55   : 	SetDlgItemText( hItemConvDlg, IDC_STATIC, "Init" );

  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LLJCPOLH@Init?$AA@
  00053	6a ff		 push	 -1
  00055	56		 push	 esi
  00056	ff d3		 call	 ebx

; 56   : 	SendMessage( hItemConvWndPB, PBM_SETRANGE, 0, MAKELPARAM( 0, 100 ) ); 

  00058	68 00 00 64 00	 push	 6553600			; 00640000H
  0005d	6a 00		 push	 0
  0005f	68 01 04 00 00	 push	 1025			; 00000401H
  00064	57		 push	 edi
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx

; 57   : }

  0006e	c3		 ret	 0
?InitConvItemDialog@CDbManager@@QAEXXZ ENDP		; CDbManager::InitConvItemDialog
_TEXT	ENDS
PUBLIC	?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z	; CDbManager::UpdateConvItemDialog
; Function compile flags: /Ogty
;	COMDAT ?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z
_TEXT	SEGMENT
_pTitle$ = 8						; size = 4
_pString$ = 12						; size = 4
_pPosStirng$ = 16					; size = 4
_nPos$ = 20						; size = 4
?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z PROC NEAR ; CDbManager::UpdateConvItemDialog, COMDAT
; _this$ = ecx

; 61   : 	SetDlgItemText( hItemConvDlg, IDC_STATIC2, pTitle );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pTitle$[esp-4]
  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hItemConvDlg@@3PAUHWND__@@A ; hItemConvDlg
  0000a	56		 push	 esi
  0000b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetDlgItemTextA@12
  00011	50		 push	 eax
  00012	68 ec 03 00 00	 push	 1004			; 000003ecH
  00017	51		 push	 ecx
  00018	ff d6		 call	 esi

; 62   : 	SetDlgItemText( hItemConvDlg, IDC_STATIC1, pString );

  0001a	8b 54 24 0c	 mov	 edx, DWORD PTR _pString$[esp]
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hItemConvDlg@@3PAUHWND__@@A ; hItemConvDlg
  00023	52		 push	 edx
  00024	68 e9 03 00 00	 push	 1001			; 000003e9H
  00029	50		 push	 eax
  0002a	ff d6		 call	 esi

; 63   : 	SetDlgItemText( hItemConvDlg, IDC_STATIC, pPosStirng );

  0002c	8b 4c 24 10	 mov	 ecx, DWORD PTR _pPosStirng$[esp]
  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hItemConvDlg@@3PAUHWND__@@A ; hItemConvDlg
  00036	51		 push	 ecx
  00037	6a ff		 push	 -1
  00039	52		 push	 edx
  0003a	ff d6		 call	 esi

; 64   : 	SendMessage( hItemConvWndPB, PBM_SETPOS, (WPARAM)nPos, 0 );	

  0003c	8b 44 24 14	 mov	 eax, DWORD PTR _nPos$[esp]
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hItemConvWndPB@@3PAUHWND__@@A ; hItemConvWndPB
  00046	6a 00		 push	 0
  00048	50		 push	 eax
  00049	68 02 04 00 00	 push	 1026			; 00000402H
  0004e	51		 push	 ecx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  00055	5e		 pop	 esi

; 65   : }

  00056	c2 10 00	 ret	 16			; 00000010H
?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z ENDP	; CDbManager::UpdateConvItemDialog
_TEXT	ENDS
PUBLIC	??_GCQuery@@QAEPAXI@Z				; CQuery::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??1CQuery@@QAE@XZ:NEAR				; CQuery::~CQuery
; Function compile flags: /Ogty
;	COMDAT ??_GCQuery@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCQuery@@QAEPAXI@Z PROC NEAR				; CQuery::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L206419
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L206419:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCQuery@@QAEPAXI@Z ENDP				; CQuery::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetMaxInventory@CDbManager@@QAEKPADPAVCQuery@@1@Z ; CDbManager::GetMaxInventory
PUBLIC	??_C@_0EP@NAMJIFIH@select?5count?5?$DN?5count?$CIm_idPlayer?$CJ@ ; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_0BG@CKCLBOEC@Inven?5No?5Data?5Convert?$AA@ ; `string'
EXTRN	?Exec@CQuery@@QAEHPBD@Z:NEAR			; CQuery::Exec
EXTRN	?Fetch@CQuery@@QAEHXZ:NEAR			; CQuery::Fetch
EXTRN	?GetInt@CQuery@@QAEHPAD@Z:NEAR			; CQuery::GetInt
EXTRN	_sprintf:NEAR
EXTRN	?g_appInfo@@3UAppInfo@@A:QWORD			; g_appInfo
EXTRN	?AfxMessageBox@@YGHPBDII@Z:NEAR			; AfxMessageBox
;	COMDAT ??_C@_0EP@NAMJIFIH@select?5count?5?$DN?5count?$CIm_idPlayer?$CJ@
CONST	SEGMENT
??_C@_0EP@NAMJIFIH@select?5count?5?$DN?5count?$CIm_idPlayer?$CJ@ DB 'sele'
	DB	'ct count = count(m_idPlayer) from INVENTORY_TBL where serveri'
	DB	'ndex = ''%02d''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CKCLBOEC@Inven?5No?5Data?5Convert?$AA@
CONST	SEGMENT
??_C@_0BG@CKCLBOEC@Inven?5No?5Data?5Convert?$AA@ DB 'Inven No Data Conver'
	DB	't', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMaxInventory@CDbManager@@QAEKPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?GetMaxInventory@CDbManager@@QAEKPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::GetMaxInventory, COMDAT
; _this$ = ecx

; 90   : 	DWORD dwMaxConv = 0;
; 91   : 	sprintf( pszSQL, "select count = count(m_idPlayer) from INVENTORY_TBL where serverindex = '%02d'", g_appInfo.dwSys );

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7c 24 10	 mov	 edi, DWORD PTR _pszSQL$[esp+8]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@NAMJIFIH@select?5count?5?$DN?5count?$CIm_idPlayer?$CJ@
  00012	57		 push	 edi
  00013	33 db		 xor	 ebx, ebx
  00015	e8 00 00 00 00	 call	 _sprintf

; 92   : 	TRACE( pszSQL ); TRACE( "\n" );
; 93   : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  0001a	8b 74 24 20	 mov	 esi, DWORD PTR _pQueryChar$[esp+20]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	57		 push	 edi
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00029	85 c0		 test	 eax, eax
  0002b	75 3e		 jne	 SHORT $L204545

; 94   : 	{
; 95   : 		SAFE_DELETE( pQueryChar );

  0002d	85 f6		 test	 esi, esi
  0002f	74 10		 je	 SHORT $L206424
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
$L206424:

; 96   : 		SAFE_DELETE( pQuerySave );

  00041	8b 74 24 18	 mov	 esi, DWORD PTR _pQuerySave$[esp+8]
  00045	85 f6		 test	 esi, esi
  00047	74 10		 je	 SHORT $L206428
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4
$L206428:

; 97   : 		AfxMessageBox( pszSQL, MB_OK );

  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 98   : 		return dwMaxConv;

  00065	33 c0		 xor	 eax, eax
  00067	5b		 pop	 ebx

; 106  : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
$L204545:

; 99   : 	}
; 100  : 	if( pQueryChar->Fetch() )

  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  00072	85 c0		 test	 eax, eax
  00074	74 14		 je	 SHORT $L204554

; 101  : 		dwMaxConv = (DWORD)pQueryChar->GetInt( "count" );

  00076	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b d8		 mov	 ebx, eax
  00086	5b		 pop	 ebx

; 106  : }

  00087	c2 0c 00	 ret	 12			; 0000000cH
$L204554:

; 102  : 	else
; 103  : 		AfxMessageBox( "Inven No Data Convert", MB_OK );

  0008a	6a 00		 push	 0
  0008c	6a 00		 push	 0
  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@CKCLBOEC@Inven?5No?5Data?5Convert?$AA@
  00093	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 104  : 	
; 105  : 	return dwMaxConv;

  0009a	8b c3		 mov	 eax, ebx
  0009c	5b		 pop	 ebx

; 106  : }

  0009d	c2 0c 00	 ret	 12			; 0000000cH
?GetMaxInventory@CDbManager@@QAEKPADPAVCQuery@@1@Z ENDP	; CDbManager::GetMaxInventory
_TEXT	ENDS
PUBLIC	?GetMaxGuildBank@CDbManager@@QAEKPADPAVCQuery@@1@Z ; CDbManager::GetMaxGuildBank
PUBLIC	??_C@_0EP@KMPMKKMC@select?5count?5?$DN?5count?$CIm_idGuild?$CJ?5@ ; `string'
PUBLIC	??_C@_0BK@CFCEBDAL@GuildBank?5No?5Data?5Convert?$AA@ ; `string'
;	COMDAT ??_C@_0EP@KMPMKKMC@select?5count?5?$DN?5count?$CIm_idGuild?$CJ?5@
CONST	SEGMENT
??_C@_0EP@KMPMKKMC@select?5count?5?$DN?5count?$CIm_idGuild?$CJ?5@ DB 'sel'
	DB	'ect count = count(m_idGuild) from GUILD_BANK_TBL where server'
	DB	'index = ''%02d''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CFCEBDAL@GuildBank?5No?5Data?5Convert?$AA@
CONST	SEGMENT
??_C@_0BK@CFCEBDAL@GuildBank?5No?5Data?5Convert?$AA@ DB 'GuildBank No Dat'
	DB	'a Convert', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMaxGuildBank@CDbManager@@QAEKPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?GetMaxGuildBank@CDbManager@@QAEKPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::GetMaxGuildBank, COMDAT
; _this$ = ecx

; 110  : 	DWORD dwMaxConv = 0;
; 111  : 	sprintf( pszSQL, "select count = count(m_idGuild) from GUILD_BANK_TBL where serverindex = '%02d'", g_appInfo.dwSys );

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7c 24 10	 mov	 edi, DWORD PTR _pszSQL$[esp+8]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EP@KMPMKKMC@select?5count?5?$DN?5count?$CIm_idGuild?$CJ?5@
  00012	57		 push	 edi
  00013	33 db		 xor	 ebx, ebx
  00015	e8 00 00 00 00	 call	 _sprintf

; 112  : 	TRACE( pszSQL ); 	TRACE( "\n" );
; 113  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  0001a	8b 74 24 20	 mov	 esi, DWORD PTR _pQueryChar$[esp+20]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	57		 push	 edi
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00029	85 c0		 test	 eax, eax
  0002b	75 3e		 jne	 SHORT $L204567

; 114  : 	{
; 115  : 		SAFE_DELETE( pQueryChar );

  0002d	85 f6		 test	 esi, esi
  0002f	74 10		 je	 SHORT $L206442
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
$L206442:

; 116  : 		SAFE_DELETE( pQuerySave );

  00041	8b 74 24 18	 mov	 esi, DWORD PTR _pQuerySave$[esp+8]
  00045	85 f6		 test	 esi, esi
  00047	74 10		 je	 SHORT $L206446
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4
$L206446:

; 117  : 		AfxMessageBox( pszSQL, MB_OK );

  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	57		 push	 edi
  0005e	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 118  : 		return dwMaxConv;

  00065	33 c0		 xor	 eax, eax
  00067	5b		 pop	 ebx

; 126  : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
$L204567:

; 119  : 	}
; 120  : 	if( pQueryChar->Fetch() )

  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  00072	85 c0		 test	 eax, eax
  00074	74 14		 je	 SHORT $L204576

; 121  : 		dwMaxConv = (DWORD)pQueryChar->GetInt( "count" );

  00076	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b d8		 mov	 ebx, eax
  00086	5b		 pop	 ebx

; 126  : }

  00087	c2 0c 00	 ret	 12			; 0000000cH
$L204576:

; 122  : 	else
; 123  : 		AfxMessageBox( "GuildBank No Data Convert", MB_OK );

  0008a	6a 00		 push	 0
  0008c	6a 00		 push	 0
  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@CFCEBDAL@GuildBank?5No?5Data?5Convert?$AA@
  00093	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 124  : 	
; 125  : 	return dwMaxConv;

  0009a	8b c3		 mov	 eax, ebx
  0009c	5b		 pop	 ebx

; 126  : }

  0009d	c2 0c 00	 ret	 12			; 0000000cH
?GetMaxGuildBank@CDbManager@@QAEKPADPAVCQuery@@1@Z ENDP	; CDbManager::GetMaxGuildBank
_TEXT	ENDS
PUBLIC	?CreateInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::CreateInvenBankView
PUBLIC	??_C@_0JD@JEKOKICJ@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@ ; `string'
PUBLIC	??_C@_0CIN@DLEPDECP@CREATE?5view?5seghope?5?5as?5?5select?5@ ; `string'
;	COMDAT ??_C@_0JD@JEKOKICJ@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@
CONST	SEGMENT
??_C@_0JD@JEKOKICJ@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@ DB ' if'
	DB	' exists (select * from dbo.sysobjects where id = object_id(N'''
	DB	'[dbo].[seghope]'') and OBJECTPROPERTY(id, N''IsView'') = 1) d'
	DB	'rop view [dbo].[seghope]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CIN@DLEPDECP@CREATE?5view?5seghope?5?5as?5?5select?5@
CONST	SEGMENT
??_C@_0CIN@DLEPDECP@CREATE?5view?5seghope?5?5as?5?5select?5@ DB 'CREATE v'
	DB	'iew seghope  as  select a.m_idPlayer, a.m_Inventory, a.m_apIn'
	DB	'dex, a.m_dwObjIndex, b.m_extInventory, b.m_InventoryPiercing,'
	DB	' c.m_Bank, c.m_apIndex_Bank, c.m_dwObjIndex_Bank,  d.m_extBan'
	DB	'k, d.m_BankPiercing, e.playerslot from  INVENTORY_TBL a(noloc'
	DB	'k), INVENTORY_EXT_TBL b(nolock), BANK_TBL c(nolock), BANK_EXT'
	DB	'_TBL d(nolock), CHARACTER_TBL e(nolock) where a.serverindex ='
	DB	' b.serverindex  and b.serverindex = c.serverindex  and c.serv'
	DB	'erindex = d.serverindex  and d.serverindex = e.serverindex an'
	DB	'd e.serverindex = ''%02d''  and a.m_idPlayer = b.m_idPlayer  '
	DB	'and b.m_idPlayer = c.m_idPlayer  and c.m_idPlayer = d.m_idPla'
	DB	'yer  and d.m_idPlayer = e.m_idPlayer', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?CreateInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?CreateInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::CreateInvenBankView, COMDAT
; _this$ = ecx

; 128  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 129  : 	// Inven, Bank view 
; 130  : 	sprintf( pszSQL, " if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[seghope]') and OBJECTPROPERTY(id, N'IsView') = 1)"
; 131  : 		" drop view [dbo].[seghope]");

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pszSQL$[esp+4]
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0JD@JEKOKICJ@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _sprintf

; 132  : 	
; 133  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00011	8b 74 24 18	 mov	 esi, DWORD PTR _pQueryChar$[esp+12]
  00015	83 c4 08	 add	 esp, 8
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00020	85 c0		 test	 eax, eax
  00022	75 3d		 jne	 SHORT $L204587

; 134  : 	{
; 135  : 		SAFE_DELETE( pQueryChar );

  00024	85 f6		 test	 esi, esi
  00026	74 10		 je	 SHORT $L206460
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$L206460:

; 136  : 		SAFE_DELETE( pQuerySave );

  00038	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  0003c	85 f6		 test	 esi, esi
  0003e	74 10		 je	 SHORT $L206464
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
$L206464:

; 137  : 		AfxMessageBox( pszSQL, MB_OK );

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  0005a	5f		 pop	 edi

; 138  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 169  : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
$L204587:

; 139  : 	}
; 140  : 	
; 141  : 	sprintf( pszSQL, "CREATE view seghope "
; 142  : 		" as "
; 143  : 		" select a.m_idPlayer, a.m_Inventory, a.m_apIndex, a.m_dwObjIndex,"
; 144  : 		" b.m_extInventory, b.m_InventoryPiercing,"
; 145  : 		" c.m_Bank, c.m_apIndex_Bank, c.m_dwObjIndex_Bank, "
; 146  : 		" d.m_extBank, d.m_BankPiercing,"
; 147  : 		" e.playerslot"
; 148  : 		" from "
; 149  : 		" INVENTORY_TBL a(nolock), INVENTORY_EXT_TBL b(nolock), BANK_TBL c(nolock), BANK_EXT_TBL d(nolock), CHARACTER_TBL e(nolock)"
; 150  : 		" where a.serverindex = b.serverindex "
; 151  : 		" and b.serverindex = c.serverindex "
; 152  : 		" and c.serverindex = d.serverindex "
; 153  : 		" and d.serverindex = e.serverindex"
; 154  : 		" and e.serverindex = '%02d' "
; 155  : 		" and a.m_idPlayer = b.m_idPlayer "
; 156  : 		" and b.m_idPlayer = c.m_idPlayer "
; 157  : 		" and c.m_idPlayer = d.m_idPlayer "
; 158  : 		" and d.m_idPlayer = e.m_idPlayer"
; 159  : 		,g_appInfo.dwSys );

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00066	50		 push	 eax
  00067	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CIN@DLEPDECP@CREATE?5view?5seghope?5?5as?5?5select?5@
  0006c	57		 push	 edi
  0006d	e8 00 00 00 00	 call	 _sprintf
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 160  : 	
; 161  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00075	57		 push	 edi
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  0007d	85 c0		 test	 eax, eax
  0007f	75 3d		 jne	 SHORT $L204597

; 162  : 	{
; 163  : 		SAFE_DELETE( pQueryChar );

  00081	85 f6		 test	 esi, esi
  00083	74 10		 je	 SHORT $L206468
  00085	8b ce		 mov	 ecx, esi
  00087	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00092	83 c4 04	 add	 esp, 4
$L206468:

; 164  : 		SAFE_DELETE( pQuerySave );

  00095	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  00099	85 f6		 test	 esi, esi
  0009b	74 10		 je	 SHORT $L206472
  0009d	8b ce		 mov	 ecx, esi
  0009f	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  000a4	56		 push	 esi
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$L206472:

; 165  : 		AfxMessageBox( pszSQL, MB_OK );

  000ad	6a 00		 push	 0
  000af	6a 00		 push	 0
  000b1	57		 push	 edi
  000b2	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  000b7	5f		 pop	 edi

; 166  : 		return FALSE;

  000b8	33 c0		 xor	 eax, eax
  000ba	5e		 pop	 esi

; 169  : }

  000bb	c2 0c 00	 ret	 12			; 0000000cH
$L204597:
  000be	5f		 pop	 edi

; 167  : 	}
; 168  : 	return TRUE;

  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	5e		 pop	 esi

; 169  : }

  000c5	c2 0c 00	 ret	 12			; 0000000cH
?CreateInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ENDP ; CDbManager::CreateInvenBankView
_TEXT	ENDS
PUBLIC	?CreateGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::CreateGuildBankView
PUBLIC	??_C@_0JP@LDPJLGLD@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@ ; `string'
PUBLIC	??_C@_0BAF@BHMIJDAM@CREATE?5view?5seghope_guild?5?5as?5?5s@ ; `string'
;	COMDAT ??_C@_0JP@LDPJLGLD@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@
CONST	SEGMENT
??_C@_0JP@LDPJLGLD@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@ DB ' if'
	DB	' exists (select * from dbo.sysobjects where id = object_id(N'''
	DB	'[dbo].[seghope_guild]'') and OBJECTPROPERTY(id, N''IsView'') '
	DB	'= 1) drop view [dbo].[seghope_guild]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAF@BHMIJDAM@CREATE?5view?5seghope_guild?5?5as?5?5s@
CONST	SEGMENT
??_C@_0BAF@BHMIJDAM@CREATE?5view?5seghope_guild?5?5as?5?5s@ DB 'CREATE vi'
	DB	'ew seghope_guild  as  select a.m_idGuild, a.m_GuildBank, b.m_'
	DB	'extGuildBank , b.m_GuildBankPiercing from  GUILD_BANK_TBL a(n'
	DB	'olock), GUILD_BANK_EXT_TBL b(nolock) where a.serverindex = b.'
	DB	'serverindex and b.serverindex = ''%02d'' and a.m_idGuild = b.'
	DB	'm_idGuild', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?CreateGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?CreateGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::CreateGuildBankView, COMDAT
; _this$ = ecx

; 172  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 173  : 	// Inven, Bank view 
; 174  : 	sprintf( pszSQL, " if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[seghope_guild]') and OBJECTPROPERTY(id, N'IsView') = 1)"
; 175  : 		" drop view [dbo].[seghope_guild]");

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pszSQL$[esp+4]
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0JP@LDPJLGLD@?5if?5exists?5?$CIselect?5?$CK?5from?5dbo?4sy@
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _sprintf

; 176  : 	
; 177  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00011	8b 74 24 18	 mov	 esi, DWORD PTR _pQueryChar$[esp+12]
  00015	83 c4 08	 add	 esp, 8
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00020	85 c0		 test	 eax, eax
  00022	75 3d		 jne	 SHORT $L204613

; 178  : 	{
; 179  : 		SAFE_DELETE( pQueryChar );

  00024	85 f6		 test	 esi, esi
  00026	74 10		 je	 SHORT $L206494
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$L206494:

; 180  : 		SAFE_DELETE( pQuerySave );

  00038	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  0003c	85 f6		 test	 esi, esi
  0003e	74 10		 je	 SHORT $L206498
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
$L206498:

; 181  : 		AfxMessageBox( pszSQL, MB_OK );

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  0005a	5f		 pop	 edi

; 182  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 204  : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
$L204613:

; 183  : 	}
; 184  : 	
; 185  : 	sprintf( pszSQL, "CREATE view seghope_guild "
; 186  : 		" as "
; 187  : 		" select a.m_idGuild, a.m_GuildBank,"
; 188  : 		" b.m_extGuildBank , b.m_GuildBankPiercing"
; 189  : 		" from "
; 190  : 		" GUILD_BANK_TBL a(nolock), GUILD_BANK_EXT_TBL b(nolock)"
; 191  : 		" where a.serverindex = b.serverindex"
; 192  : 		" and b.serverindex = '%02d'"
; 193  : 		" and a.m_idGuild = b.m_idGuild"
; 194  : 		, g_appInfo.dwSys );

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00066	50		 push	 eax
  00067	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BAF@BHMIJDAM@CREATE?5view?5seghope_guild?5?5as?5?5s@
  0006c	57		 push	 edi
  0006d	e8 00 00 00 00	 call	 _sprintf
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  : 	
; 196  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00075	57		 push	 edi
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  0007d	85 c0		 test	 eax, eax
  0007f	75 3d		 jne	 SHORT $L204623

; 197  : 	{
; 198  : 		SAFE_DELETE( pQueryChar );

  00081	85 f6		 test	 esi, esi
  00083	74 10		 je	 SHORT $L206502
  00085	8b ce		 mov	 ecx, esi
  00087	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00092	83 c4 04	 add	 esp, 4
$L206502:

; 199  : 		SAFE_DELETE( pQuerySave );

  00095	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  00099	85 f6		 test	 esi, esi
  0009b	74 10		 je	 SHORT $L206506
  0009d	8b ce		 mov	 ecx, esi
  0009f	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  000a4	56		 push	 esi
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$L206506:

; 200  : 		AfxMessageBox( pszSQL, MB_OK );

  000ad	6a 00		 push	 0
  000af	6a 00		 push	 0
  000b1	57		 push	 edi
  000b2	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  000b7	5f		 pop	 edi

; 201  : 		return FALSE;

  000b8	33 c0		 xor	 eax, eax
  000ba	5e		 pop	 esi

; 204  : }

  000bb	c2 0c 00	 ret	 12			; 0000000cH
$L204623:
  000be	5f		 pop	 edi

; 202  : 	}
; 203  : 	return TRUE;

  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	5e		 pop	 esi

; 204  : }

  000c5	c2 0c 00	 ret	 12			; 0000000cH
?CreateGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ENDP ; CDbManager::CreateGuildBankView
_TEXT	ENDS
PUBLIC	?DeleteInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::DeleteInvenBankView
PUBLIC	??_C@_0BC@MIENAMNJ@drop?5view?5seghope?$AA@	; `string'
;	COMDAT ??_C@_0BC@MIENAMNJ@drop?5view?5seghope?$AA@
CONST	SEGMENT
??_C@_0BC@MIENAMNJ@drop?5view?5seghope?$AA@ DB 'drop view seghope', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DeleteInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?DeleteInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::DeleteInvenBankView, COMDAT
; _this$ = ecx

; 207  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 208  : 	// Inven, Bank view 
; 209  : 	sprintf( pszSQL, "drop view seghope" );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pszSQL$[esp+4]
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@MIENAMNJ@drop?5view?5seghope?$AA@
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _sprintf

; 210  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00011	8b 74 24 18	 mov	 esi, DWORD PTR _pQueryChar$[esp+12]
  00015	83 c4 08	 add	 esp, 8
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00020	85 c0		 test	 eax, eax
  00022	75 3d		 jne	 SHORT $L204639

; 211  : 	{
; 212  : 		SAFE_DELETE( pQueryChar );

  00024	85 f6		 test	 esi, esi
  00026	74 10		 je	 SHORT $L206528
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$L206528:

; 213  : 		SAFE_DELETE( pQuerySave );

  00038	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  0003c	85 f6		 test	 esi, esi
  0003e	74 10		 je	 SHORT $L206532
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
$L206532:

; 214  : 		AfxMessageBox( pszSQL, MB_OK );

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  0005a	5f		 pop	 edi

; 215  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 218  : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
$L204639:
  00061	5f		 pop	 edi

; 216  : 	}
; 217  : 	return TRUE;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	5e		 pop	 esi

; 218  : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
?DeleteInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ENDP ; CDbManager::DeleteInvenBankView
_TEXT	ENDS
PUBLIC	?DeleteGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::DeleteGuildBankView
PUBLIC	??_C@_0BI@PBCPAKJD@drop?5view?5seghope_guild?$AA@ ; `string'
;	COMDAT ??_C@_0BI@PBCPAKJD@drop?5view?5seghope_guild?$AA@
CONST	SEGMENT
??_C@_0BI@PBCPAKJD@drop?5view?5seghope_guild?$AA@ DB 'drop view seghope_g'
	DB	'uild', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DeleteGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?DeleteGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::DeleteGuildBankView, COMDAT
; _this$ = ecx

; 221  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 222  : 	sprintf( pszSQL, "drop view seghope_guild" );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pszSQL$[esp+4]
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@PBCPAKJD@drop?5view?5seghope_guild?$AA@
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _sprintf

; 223  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00011	8b 74 24 18	 mov	 esi, DWORD PTR _pQueryChar$[esp+12]
  00015	83 c4 08	 add	 esp, 8
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00020	85 c0		 test	 eax, eax
  00022	75 3d		 jne	 SHORT $L204655

; 224  : 	{
; 225  : 		SAFE_DELETE( pQueryChar );

  00024	85 f6		 test	 esi, esi
  00026	74 10		 je	 SHORT $L206546
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$L206546:

; 226  : 		SAFE_DELETE( pQuerySave );

  00038	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  0003c	85 f6		 test	 esi, esi
  0003e	74 10		 je	 SHORT $L206550
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
$L206550:

; 227  : 		AfxMessageBox( pszSQL, MB_OK );

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  0005a	5f		 pop	 edi

; 228  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 231  : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
$L204655:
  00061	5f		 pop	 edi

; 229  : 	}
; 230  : 	return TRUE;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	5e		 pop	 esi

; 231  : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
?DeleteGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ENDP ; CDbManager::DeleteGuildBankView
_TEXT	ENDS
PUBLIC	?GetInventoryBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::GetInventoryBankView
PUBLIC	??_C@_0BG@IGKJACAI@select?5?$CK?5from?5seghope?$AA@ ; `string'
;	COMDAT ??_C@_0BG@IGKJACAI@select?5?$CK?5from?5seghope?$AA@
CONST	SEGMENT
??_C@_0BG@IGKJACAI@select?5?$CK?5from?5seghope?$AA@ DB 'select * from seg'
	DB	'hope', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetInventoryBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?GetInventoryBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::GetInventoryBankView, COMDAT
; _this$ = ecx

; 234  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 235  : 	sprintf( pszSQL, "select * from seghope" );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pszSQL$[esp+4]
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@IGKJACAI@select?5?$CK?5from?5seghope?$AA@
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _sprintf

; 236  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00011	8b 74 24 18	 mov	 esi, DWORD PTR _pQueryChar$[esp+12]
  00015	83 c4 08	 add	 esp, 8
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00020	85 c0		 test	 eax, eax
  00022	75 3d		 jne	 SHORT $L204671

; 237  : 	{
; 238  : 		SAFE_DELETE( pQueryChar ); SAFE_DELETE( pQuerySave ); AfxMessageBox( pszSQL, MB_OK );

  00024	85 f6		 test	 esi, esi
  00026	74 10		 je	 SHORT $L206564
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$L206564:
  00038	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  0003c	85 f6		 test	 esi, esi
  0003e	74 10		 je	 SHORT $L206568
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
$L206568:
  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  0005a	5f		 pop	 edi

; 239  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 242  : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
$L204671:
  00061	5f		 pop	 edi

; 240  : 	}
; 241  : 	return TRUE;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	5e		 pop	 esi

; 242  : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
?GetInventoryBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ENDP ; CDbManager::GetInventoryBankView
_TEXT	ENDS
PUBLIC	?GetGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::GetGuildBankView
PUBLIC	??_C@_0BM@LEGEANNN@select?5?$CK?5from?5seghope_guild?$AA@ ; `string'
;	COMDAT ??_C@_0BM@LEGEANNN@select?5?$CK?5from?5seghope_guild?$AA@
CONST	SEGMENT
??_C@_0BM@LEGEANNN@select?5?$CK?5from?5seghope_guild?$AA@ DB 'select * fr'
	DB	'om seghope_guild', 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
_pQuerySave$ = 16					; size = 4
?GetGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z PROC NEAR ; CDbManager::GetGuildBankView, COMDAT
; _this$ = ecx

; 245  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 246  : 	sprintf( pszSQL, "select * from seghope_guild" );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pszSQL$[esp+4]
  00006	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@LEGEANNN@select?5?$CK?5from?5seghope_guild?$AA@
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _sprintf

; 247  : 	if( FALSE == pQueryChar->Exec( pszSQL ) )

  00011	8b 74 24 18	 mov	 esi, DWORD PTR _pQueryChar$[esp+12]
  00015	83 c4 08	 add	 esp, 8
  00018	57		 push	 edi
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00020	85 c0		 test	 eax, eax
  00022	75 3d		 jne	 SHORT $L204687

; 248  : 	{
; 249  : 		SAFE_DELETE( pQueryChar ); SAFE_DELETE( pQuerySave ); AfxMessageBox( pszSQL, MB_OK );

  00024	85 f6		 test	 esi, esi
  00026	74 10		 je	 SHORT $L206582
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4
$L206582:
  00038	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+4]
  0003c	85 f6		 test	 esi, esi
  0003e	74 10		 je	 SHORT $L206586
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
$L206586:
  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  0005a	5f		 pop	 edi

; 250  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 253  : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
$L204687:
  00061	5f		 pop	 edi

; 251  : 	}
; 252  : 	return TRUE;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	5e		 pop	 esi

; 253  : }

  00068	c2 0c 00	 ret	 12			; 0000000cH
?GetGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ENDP ; CDbManager::GetGuildBankView
_TEXT	ENDS
PUBLIC	?GetUserInventoryBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@@Z ; CDbManager::GetUserInventoryBank
PUBLIC	??_C@_0L@FONFFEJF@m_idPlayer?$AA@		; `string'
PUBLIC	??_C@_0L@BLIMKIB@playerslot?$AA@		; `string'
EXTRN	?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z:NEAR ; CDbManager::GetBankMover
EXTRN	?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z:NEAR ; CDbManager::GetInventory
;	COMDAT ??_C@_0L@FONFFEJF@m_idPlayer?$AA@
CONST	SEGMENT
??_C@_0L@FONFFEJF@m_idPlayer?$AA@ DB 'm_idPlayer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BLIMKIB@playerslot?$AA@
CONST	SEGMENT
??_C@_0L@BLIMKIB@playerslot?$AA@ DB 'playerslot', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetUserInventoryBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@@Z
_TEXT	SEGMENT
_pMover$ = 8						; size = 4
_pQueryChar$ = 12					; size = 4
?GetUserInventoryBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@@Z PROC NEAR ; CDbManager::GetUserInventoryBank, COMDAT
; _this$ = ecx

; 256  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 257  : 	pMover->m_idPlayer	= pQueryChar->GetInt( "m_idPlayer" );

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _pQueryChar$[esp+4]
  00006	57		 push	 edi
  00007	8b d9		 mov	 ebx, ecx
  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@FONFFEJF@m_idPlayer?$AA@
  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt
  00015	8b 7c 24 10	 mov	 edi, DWORD PTR _pMover$[esp+8]

; 258  : 	pMover->m_nSlot		= pQueryChar->GetInt( "playerslot" );

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@BLIMKIB@playerslot?$AA@
  0001e	8b ce		 mov	 ecx, esi
  00020	89 87 90 00 00
	00		 mov	 DWORD PTR [edi+144], eax
  00026	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 259  : 	
; 260  : 	// GetItem
; 261  : 	LPDB_OVERLAPPED_PLUS lpDbOverlappedPlus	= NULL;
; 262  : 	//GetInventory( pMover, pQueryChar, lpDbOverlappedPlus );
; 263  : 	//GetBankMover( pMover, pQueryChar, 0 );
; 264  : 	// mirchang_100416 VERIFYSTRING use return value
; 265  : 	if( GetInventory( pMover, pQueryChar, lpDbOverlappedPlus ) == FALSE || GetBankMover( pMover, pQueryChar, 0 ) == FALSE )

  0002b	6a 00		 push	 0
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	8b cb		 mov	 ecx, ebx
  00031	88 87 c8 00 00
	00		 mov	 BYTE PTR [edi+200], al
  00037	e8 00 00 00 00	 call	 ?GetInventory@CDbManager@@QAEHPAVCMover@@PAVCQuery@@PAUtagDB_OVERLAPPED_PLUS@@@Z ; CDbManager::GetInventory
  0003c	85 c0		 test	 eax, eax
  0003e	74 1a		 je	 SHORT $L204705
  00040	6a 00		 push	 0
  00042	56		 push	 esi
  00043	57		 push	 edi
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?GetBankMover@CDbManager@@QAEHPAVCMover@@PAVCQuery@@H@Z ; CDbManager::GetBankMover
  0004b	85 c0		 test	 eax, eax
  0004d	74 0b		 je	 SHORT $L204705
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 268  : 	}
; 269  : 	return TRUE;

  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	5b		 pop	 ebx

; 270  : 	// mirchang_100416
; 271  : }

  00057	c2 08 00	 ret	 8
$L204705:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 266  : 	{
; 267  : 		return FALSE;

  0005c	33 c0		 xor	 eax, eax
  0005e	5b		 pop	 ebx

; 270  : 	// mirchang_100416
; 271  : }

  0005f	c2 08 00	 ret	 8
?GetUserInventoryBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@@Z ENDP ; CDbManager::GetUserInventoryBank
_TEXT	ENDS
PUBLIC	?GetRemoveItemPanya@CDbManager@@QAEKHH@Z	; CDbManager::GetRemoveItemPanya
; Function compile flags: /Ogty
;	COMDAT ?GetRemoveItemPanya@CDbManager@@QAEKHH@Z
_TEXT	SEGMENT
_nItem0$ = 8						; size = 4
_nItem1$ = 12						; size = 4
?GetRemoveItemPanya@CDbManager@@QAEKHH@Z PROC NEAR	; CDbManager::GetRemoveItemPanya, COMDAT
; _this$ = ecx

; 443  : 	DWORD dwAddGold = 0;
; 444  : 	if( nItem0 )	//" "

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _nItem0$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $L204848

; 445  : 	{
; 446  : 		dwAddGold += 36000 * nItem0;

  0000a	69 c9 a0 8c 00
	00		 imul	 ecx, 36000		; 00008ca0H
  00010	8b c1		 mov	 eax, ecx
$L204848:

; 447  : 	}
; 448  : 	if( nItem1 )	//" "

  00012	8b 4c 24 08	 mov	 ecx, DWORD PTR _nItem1$[esp-4]
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $L204849

; 449  : 	{
; 450  : 		dwAddGold += 147500 * nItem1;

  0001a	69 c9 2c 40 02
	00		 imul	 ecx, 147500		; 0002402cH
  00020	03 c1		 add	 eax, ecx
$L204849:

; 451  : 	}
; 452  : 	return dwAddGold;
; 453  : }

  00022	c2 08 00	 ret	 8
?GetRemoveItemPanya@CDbManager@@QAEKHH@Z ENDP		; CDbManager::GetRemoveItemPanya
_TEXT	ENDS
PUBLIC	??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@	; `string'
PUBLIC	??_C@_0GF@MLKCNPJL@UPDATE?5CHARACTER_TBL?5SET?5m_dwGol@ ; `string'
PUBLIC	??_C@_0DG@NAOGPEOL@IdPlayer?5?$DN?5?$CF07d?0?5Item0?5?$DN?5?$CFd?0?5Ite@ ; `string'
PUBLIC	?RemoveInventoryBankListPanya@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2HH@Z ; CDbManager::RemoveInventoryBankListPanya
EXTRN	?IsConvMode@CProject@@QAEHK@Z:NEAR		; CProject::IsConvMode
EXTRN	?FILEOUT@@YAXPBD0ZZ:NEAR			; FILEOUT
EXTRN	?prj@@3VCProject@@A:BYTE			; prj
;	COMDAT ??_C@_0GF@MLKCNPJL@UPDATE?5CHARACTER_TBL?5SET?5m_dwGol@
CONST	SEGMENT
??_C@_0GF@MLKCNPJL@UPDATE?5CHARACTER_TBL?5SET?5m_dwGol@ DB 'UPDATE CHARAC'
	DB	'TER_TBL SET m_dwGold = m_dwGold + %d where m_idPlayer = ''%07'
	DB	'd'' and serverindex = ''%02d''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NAOGPEOL@IdPlayer?5?$DN?5?$CF07d?0?5Item0?5?$DN?5?$CFd?0?5Ite@
CONST	SEGMENT
??_C@_0DG@NAOGPEOL@IdPlayer?5?$DN?5?$CF07d?0?5Item0?5?$DN?5?$CFd?0?5Ite@ DB 'I'
	DB	'dPlayer = %07d, Item0 = %d, Item1 = %d, AddGold = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@
CONST	SEGMENT
??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@ DB '..\RemoveItem.log', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?RemoveInventoryBankListPanya@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2HH@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pMover$ = 12						; size = 4
_pQueryChar$ = 16					; size = 4
_pQuerySave$ = 20					; size = 4
_nCountItem0$ = 24					; size = 4
_nCountItem1$ = 28					; size = 4
?RemoveInventoryBankListPanya@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2HH@Z PROC NEAR ; CDbManager::RemoveInventoryBankListPanya, COMDAT
; _this$ = ecx

; 581  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 582  : 	if( prj.IsConvMode( REMOVE_ITEM_ALL_PAY ) )

  00003	6a 08		 push	 8
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000a	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  0000f	85 c0		 test	 eax, eax
  00011	0f 84 b6 00 00
	00		 je	 $L205028

; 583  : 	{
; 584  : 		DWORD dwAddGold = GetRemoveItemPanya( nCountItem0, nCountItem1 );

  00017	8b 44 24 20	 mov	 eax, DWORD PTR _nCountItem0$[esp+8]
  0001b	33 f6		 xor	 esi, esi
  0001d	85 c0		 test	 eax, eax
  0001f	74 08		 je	 SHORT $L206614
  00021	8b f0		 mov	 esi, eax
  00023	69 f6 a0 8c 00
	00		 imul	 esi, 36000		; 00008ca0H
$L206614:
  00029	55		 push	 ebp
  0002a	8b 6c 24 28	 mov	 ebp, DWORD PTR _nCountItem1$[esp+12]
  0002e	85 ed		 test	 ebp, ebp
  00030	74 0a		 je	 SHORT $L206615
  00032	8b c5		 mov	 eax, ebp
  00034	69 c0 2c 40 02
	00		 imul	 eax, 147500		; 0002402cH
  0003a	03 f0		 add	 esi, eax
$L206615:

; 585  : 		sprintf( pszSQL, "UPDATE CHARACTER_TBL"
; 586  : 			" SET m_dwGold = m_dwGold + %d"
; 587  : 			" where m_idPlayer = '%07d' and serverindex = '%02d'",
; 588  : 			dwAddGold, pMover->m_idPlayer, g_appInfo.dwSys );

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00042	8b 7c 24 18	 mov	 edi, DWORD PTR _pMover$[esp+12]
  00046	8b 97 90 00 00
	00		 mov	 edx, DWORD PTR [edi+144]
  0004c	8b 5c 24 14	 mov	 ebx, DWORD PTR _pszSQL$[esp+12]
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	56		 push	 esi
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GF@MLKCNPJL@UPDATE?5CHARACTER_TBL?5SET?5m_dwGol@
  00058	53		 push	 ebx
  00059	e8 00 00 00 00	 call	 _sprintf

; 589  : 		FILEOUT( "..\\RemoveItem.log", "IdPlayer = %07d, Item0 = %d, Item1 = %d, AddGold = %d", pMover->m_idPlayer,  nCountItem0, nCountItem1, dwAddGold );

  0005e	8b 44 24 38	 mov	 eax, DWORD PTR _nCountItem0$[esp+32]
  00062	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]
  00068	56		 push	 esi
  00069	55		 push	 ebp
  0006a	50		 push	 eax
  0006b	51		 push	 ecx
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@NAOGPEOL@IdPlayer?5?$DN?5?$CF07d?0?5Item0?5?$DN?5?$CFd?0?5Ite@
  00071	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@
  00076	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT

; 590  : 		
; 591  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  0007b	8b 74 24 4c	 mov	 esi, DWORD PTR _pQuerySave$[esp+56]
  0007f	83 c4 2c	 add	 esp, 44			; 0000002cH
  00082	53		 push	 ebx
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  0008a	85 c0		 test	 eax, eax
  0008c	5d		 pop	 ebp
  0008d	75 3e		 jne	 SHORT $L205028

; 592  : 		{
; 593  : 			SAFE_DELETE( pQueryChar );

  0008f	8b 7c 24 18	 mov	 edi, DWORD PTR _pQueryChar$[esp+8]
  00093	85 ff		 test	 edi, edi
  00095	74 10		 je	 SHORT $L206605
  00097	8b cf		 mov	 ecx, edi
  00099	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0009e	57		 push	 edi
  0009f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a4	83 c4 04	 add	 esp, 4
$L206605:

; 594  : 			SAFE_DELETE( pQuerySave );

  000a7	85 f6		 test	 esi, esi
  000a9	74 10		 je	 SHORT $L206609
  000ab	8b ce		 mov	 ecx, esi
  000ad	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b8	83 c4 04	 add	 esp, 4
$L206609:

; 595  : 			AfxMessageBox( pszSQL, MB_OK );

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	53		 push	 ebx
  000c0	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi

; 596  : 			return FALSE;

  000c7	33 c0		 xor	 eax, eax
  000c9	5b		 pop	 ebx

; 600  : }

  000ca	c2 18 00	 ret	 24			; 00000018H
$L205028:
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi

; 597  : 		}
; 598  : 	}
; 599  : 	return TRUE;

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	5b		 pop	 ebx

; 600  : }

  000d5	c2 18 00	 ret	 24			; 00000018H
?RemoveInventoryBankListPanya@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2HH@Z ENDP ; CDbManager::RemoveInventoryBankListPanya
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 193  : 			{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 194  : 			}

  00008	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Left
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 29	 add	 eax, 41			; 00000029H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L205716
  0000d	8d 49 00	 npad	 3
$L205715:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L205715
$L205716:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Min
_TEXT	ENDS
PUBLIC	??_7?$CItemContainer@VCItemElem@@@@6B@		; CItemContainer<CItemElem>::`vftable'
PUBLIC	??_G?$CItemContainer@VCItemElem@@@@UAEPAXI@Z	; CItemContainer<CItemElem>::`scalar deleting destructor'
PUBLIC	??0?$CItemContainer@VCItemElem@@@@QAE@XZ	; CItemContainer<CItemElem>::CItemContainer<CItemElem>
EXTRN	??_E?$CItemContainer@VCItemElem@@@@UAEPAXI@Z:NEAR ; CItemContainer<CItemElem>::`vector deleting destructor'
;	COMDAT ??_7?$CItemContainer@VCItemElem@@@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_7?$CItemContainer@VCItemElem@@@@6B@ DD FLAT:??_E?$CItemContainer@VCItemElem@@@@UAEPAXI@Z ; CItemContainer<CItemElem>::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0?$CItemContainer@VCItemElem@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CItemContainer@VCItemElem@@@@QAE@XZ PROC NEAR	; CItemContainer<CItemElem>::CItemContainer<CItemElem>, COMDAT
; _this$ = ecx

; 312  : {

  00000	8b c1		 mov	 eax, ecx

; 313  : 	m_apItem = NULL;

  00002	33 c9		 xor	 ecx, ecx
  00004	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7?$CItemContainer@VCItemElem@@@@6B@
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 314  : 	m_apIndex = NULL;

  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 315  : }

  00010	c3		 ret	 0
??0?$CItemContainer@VCItemElem@@@@QAE@XZ ENDP		; CItemContainer<CItemElem>::CItemContainer<CItemElem>
_TEXT	ENDS
PUBLIC	?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAtId
; Function compile flags: /Ogty
;	COMDAT ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z
_TEXT	SEGMENT
_dwObjId$ = 8						; size = 4
?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z PROC NEAR ; CItemContainer<CItemElem>::RemoveAtId, COMDAT
; _this$ = ecx

; 727  : 	if( dwObjId >= m_dwItemMax )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwObjId$[esp-4]
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
  00007	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0000a	3b c1		 cmp	 eax, ecx
  0000c	73 43		 jae	 SHORT $L205778
  0000e	56		 push	 esi

; 728  : 		return;
; 729  : 	if( m_apItem[ dwObjId ].m_dwObjIndex >= m_dwItemMax )

  0000f	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  00012	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00015	c1 e6 05	 shl	 esi, 5
  00018	39 4c 30 2c	 cmp	 DWORD PTR [eax+esi+44], ecx
  0001c	73 32		 jae	 SHORT $L206659

; 730  : 		return;
; 731  : 	m_apItem[ dwObjId ].Empty();

  0001e	8b c8		 mov	 ecx, eax
  00020	8b 14 31	 mov	 edx, DWORD PTR [ecx+esi]
  00023	03 ce		 add	 ecx, esi
  00025	ff 52 04	 call	 DWORD PTR [edx+4]

; 732  : 	if( m_apItem[ dwObjId ].m_dwObjIndex >= m_dwIndexNum )

  00028	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0002b	8b 4c 30 2c	 mov	 ecx, DWORD PTR [eax+esi+44]
  0002f	3b 4f 08	 cmp	 ecx, DWORD PTR [edi+8]
  00032	72 1c		 jb	 SHORT $L206659

; 733  : 	{
; 734  : 		m_apIndex[ m_apItem[ dwObjId ].m_dwObjIndex ] = NULL_ID;

  00034	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00037	8b 44 32 2c	 mov	 eax, DWORD PTR [edx+esi+44]
  0003b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003e	c7 04 81 ff ff
	ff ff		 mov	 DWORD PTR [ecx+eax*4], -1

; 735  : 		m_apItem[ dwObjId ].m_dwObjIndex = NULL_ID;

  00045	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00048	c7 44 32 2c ff
	ff ff ff	 mov	 DWORD PTR [edx+esi+44], -1
$L206659:
  00050	5e		 pop	 esi
$L205778:
  00051	5f		 pop	 edi

; 736  : 	}
; 737  : }

  00052	c2 04 00	 ret	 4
?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ENDP	; CItemContainer<CItemElem>::RemoveAtId
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 331  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl

; 332  : 		}

  0000c	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Ogty
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC NEAR	; std::char_traits<char>::compare, COMDAT

; 347  : 		return (::memcmp(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR __First1$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR __First2$[esp+4]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 a6		 repe cmpsb
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	74 05		 je	 SHORT $L206664
  00016	1b c0		 sbb	 eax, eax
  00018	83 d8 ff	 sbb	 eax, -1
$L206664:

; 348  : 		}

  0001b	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogty
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 352  : 		return (::strlen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L206668:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $L206668
  0000e	2b c2		 sub	 eax, edx

; 353  : 		}

  00010	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Ogty
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __First2$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __First1$[esp+4]
  0000e	8b c1		 mov	 eax, ecx
  00010	8b d7		 mov	 edx, edi
  00012	c1 e9 02	 shr	 ecx, 2
  00015	f3 a5		 rep movsd
  00017	8b c8		 mov	 ecx, eax
  00019	83 e1 03	 and	 ecx, 3
  0001c	f3 a4		 rep movsb
  0001e	5f		 pop	 edi
  0001f	8b c2		 mov	 eax, edx
  00021	5e		 pop	 esi

; 359  : 		}

  00022	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

  00000	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 133  : 	BOOL	IsEmpty()	{	return m_dwItemId ? FALSE : TRUE;	}

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	?GetPiercingSize@CItemElem@@QAEHXZ		; CItemElem::GetPiercingSize
EXTRN	?GetPiercingSize@CPiercing@@QAEHXZ:NEAR		; CPiercing::GetPiercingSize
; Function compile flags: /Ogty
;	COMDAT ?GetPiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetPiercingSize@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::GetPiercingSize, COMDAT
; _this$ = ecx

; 153  : 	int		GetPiercingSize()	{	return m_piercing.GetPiercingSize();		}

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
?GetPiercingSize@CItemElem@@QAEHXZ ENDP			; CItemElem::GetPiercingSize
_TEXT	ENDS
PUBLIC	?GetPiercingItem@CItemElem@@QAEKH@Z		; CItemElem::GetPiercingItem
EXTRN	?GetPiercingItem@CPiercing@@QAEKH@Z:NEAR	; CPiercing::GetPiercingItem
; Function compile flags: /Ogty
;	COMDAT ?GetPiercingItem@CItemElem@@QAEKH@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
?GetPiercingItem@CItemElem@@QAEKH@Z PROC NEAR		; CItemElem::GetPiercingItem, COMDAT
; _this$ = ecx

; 155  : 	DWORD	GetPiercingItem( int nth )	{	return m_piercing.GetPiercingItem( nth );	}

  00000	83 c1 34	 add	 ecx, 52			; 00000034H
  00003	e9 00 00 00 00	 jmp	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
?GetPiercingItem@CItemElem@@QAEKH@Z ENDP		; CItemElem::GetPiercingItem
_TEXT	ENDS
PUBLIC	?GetOption@CItemElem@@QAEHXZ			; CItemElem::GetOption
; Function compile flags: /Ogty
;	COMDAT ?GetOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetOption@CItemElem@@QAEHXZ PROC NEAR			; CItemElem::GetOption, COMDAT
; _this$ = ecx

; 218  : 	int		GetOption( void )			{ return m_nAbilityOption;	}

  00000	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00003	c3		 ret	 0
?GetOption@CItemElem@@QAEHXZ ENDP			; CItemElem::GetOption
_TEXT	ENDS
PUBLIC	??0_ItemContainerStruct@@QAE@XZ			; _ItemContainerStruct::_ItemContainerStruct
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbmanager.h
;	COMDAT ??0_ItemContainerStruct@@QAE@XZ
_TEXT	SEGMENT
??0_ItemContainerStruct@@QAE@XZ PROC NEAR		; _ItemContainerStruct::_ItemContainerStruct, COMDAT
; _this$ = ecx

; 613  : 	_ItemContainerStruct()

  00000	8b c1		 mov	 eax, ecx

; 614  : 		{
; 615  : 			*szItem	= '\0';

  00002	32 c9		 xor	 cl, cl
  00004	88 08		 mov	 BYTE PTR [eax], cl

; 616  : 			*szIndex	= '\0';

  00006	88 88 00 18 00
	00		 mov	 BYTE PTR [eax+6144], cl

; 617  : 			*szObjIndex	= '\0';

  0000c	88 88 00 1a 00
	00		 mov	 BYTE PTR [eax+6656], cl

; 618  : 			*szExt	= '\0';

  00012	88 88 00 1c 00
	00		 mov	 BYTE PTR [eax+7168], cl

; 619  : 			*szPiercing	= '\0';

  00018	88 88 00 24 00
	00		 mov	 BYTE PTR [eax+9216], cl

; 620  : 			*szPet	= '\0';

  0001e	88 88 40 43 00
	00		 mov	 BYTE PTR [eax+17216], cl

; 621  : 		}

  00024	c3		 ret	 0
??0_ItemContainerStruct@@QAE@XZ ENDP			; _ItemContainerStruct::_ItemContainerStruct
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1109 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1110 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?Free@?$MemPooler@VCMover@@@@QAEHPAVCMover@@@Z	; MemPooler<CMover>::Free
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\mempooler.h
;	COMDAT ?Free@?$MemPooler@VCMover@@@@QAEHPAVCMover@@@Z
_TEXT	SEGMENT
_lpMem$ = 8						; size = 4
?Free@?$MemPooler@VCMover@@@@QAEHPAVCMover@@@Z PROC NEAR ; MemPooler<CMover>::Free, COMDAT
; _this$ = ecx

; 80   : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 81   : #ifdef __VERIFY_MEMPOOL
; 82   : 			::operator delete(lpMem);
; 83   : 			return TRUE;
; 84   : #endif
; 85   : 
; 86   : 			BlockNode* pNode	= NULL;
; 87   : 
; 88   : 			EnterCriticalSection( &m_cs );

  00005	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
  00008	53		 push	 ebx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 89   : 
; 90   : 			pNode	= ( reinterpret_cast<BlockNode*>( lpMem ) ) - 1;
; 91   : 			if( m_nAllocCount > 0 )

  0000f	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00012	85 c9		 test	 ecx, ecx
  00014	8b 7c 24 10	 mov	 edi, DWORD PTR _lpMem$[esp+8]
  00018	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0001b	7e 09		 jle	 SHORT $L184103

; 92   : 			{
; 93   : 				pNode->pNext	= m_pFreeList;

  0001d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 94   : 				m_pFreeList		= pNode;

  00021	89 06		 mov	 DWORD PTR [esi], eax

; 95   : 				m_nAllocCount--;

  00023	ff 4e 18	 dec	 DWORD PTR [esi+24]
$L184103:

; 96   : 			}
; 97   : 
; 98   : 			//	mulcom	BEGIN100422	 
; 99   : 			::memset( lpMem, 0, sizeof(T) );

  00026	33 c0		 xor	 eax, eax
  00028	b9 c2 11 00 00	 mov	 ecx, 4546		; 000011c2H

; 100  : 			//	mulcom	END100422	 
; 101  : 
; 102  : 			LeaveCriticalSection( &m_cs );

  0002d	53		 push	 ebx
  0002e	f3 ab		 rep stosd
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 103  : 
; 104  : 			return TRUE;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	5b		 pop	 ebx

; 105  : 		}

  0003e	c2 04 00	 ret	 4
?Free@?$MemPooler@VCMover@@@@QAEHPAVCMover@@@Z ENDP	; MemPooler<CMover>::Free
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L206692
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  00009	c3		 ret	 0
$L206692:

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L206704
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  00009	c3		 ret	 0
$L206704:

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z PROC NEAR ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00001	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  00004	83 fe 10	 cmp	 esi, 16			; 00000010H
  00007	57		 push	 edi
  00008	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0000b	72 04		 jb	 SHORT $L206726
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	eb 02		 jmp	 SHORT $L206727
$L206726:
  00011	8b d0		 mov	 edx, eax
$L206727:
  00013	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00017	3b fa		 cmp	 edi, edx
  00019	72 17		 jb	 SHORT $L185560
  0001b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0001e	72 02		 jb	 SHORT $L206734
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L206734:
  00022	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00025	03 c8		 add	 ecx, eax
  00027	3b cf		 cmp	 ecx, edi
  00029	76 07		 jbe	 SHORT $L185560
  0002b	5f		 pop	 edi

; 1497 : 		else
; 1498 : 			return (true);

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi

; 1499 : 		}

  0002f	c2 04 00	 ret	 4
$L185560:
  00032	5f		 pop	 edi

; 1496 : 			return (false);	// don't ask

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 1499 : 		}

  00036	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 2d	 add	 eax, 45			; 0000002dH

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 159  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Parent
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z ; std::list<void *,std::allocator<void *> >::_Nextnode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Nextnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::_Nextnode, COMDAT

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 109  : 		}

  00004	c3		 ret	 0
?_Nextnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z ENDP ; std::list<void *,std::allocator<void *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z ; std::list<void *,std::allocator<void *> >::_Prevnode
; Function compile flags: /Ogty
;	COMDAT ?_Prevnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::_Prevnode, COMDAT

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 114  : 		}

  00007	c3		 ret	 0
?_Prevnode@?$list@PAXV?$allocator@PAX@std@@@std@@KAAAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@@Z ENDP ; std::list<void *,std::allocator<void *> >::_Prevnode
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QBEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@3@XZ ; std::list<void *,std::allocator<void *> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QBEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QBEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@3@XZ PROC NEAR ; std::list<void *,std::allocator<void *> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 207  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 208  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QBEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@3@XZ ENDP ; std::list<void *,std::allocator<void *> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z ; std::allocator<std::_List_nod<void *,std::allocator<void *> >::_Node>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<void *,std::allocator<void *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<void *,std::allocator<void *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z ; std::list<void *,std::allocator<void *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z ENDP ; std::list<void *,std::allocator<void *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@QAE@PAU012@0ABQAX@Z ; std::_List_nod<void *,std::allocator<void *> >::_Node::_Node
; Function compile flags: /Ogty
;	COMDAT ??0_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@QAE@PAU012@0ABQAX@Z
_TEXT	SEGMENT
__Nextarg$ = 8						; size = 4
__Prevarg$ = 12						; size = 4
__Myvalarg$ = 16					; size = 4
??0_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@QAE@PAU012@0ABQAX@Z PROC NEAR ; std::_List_nod<void *,std::allocator<void *> >::_Node::_Node, COMDAT
; _this$ = ecx

; 34   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Prevarg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Nextarg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Myvalarg$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 35   : 			}

  00018	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@QAE@PAU012@0ABQAX@Z ENDP ; std::_List_nod<void *,std::allocator<void *> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAX@std@@QBEIXZ		; std::allocator<void *>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@PAX@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAX@std@@QBEIXZ PROC NEAR		; std::allocator<void *>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAX@std@@QBEIXZ ENDP		; std::allocator<void *>::max_size
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ; CFixedArray<ItemProp>::GetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z PROC NEAR ; CFixedArray<ItemProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L186281

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L186281:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ENDP ; CFixedArray<ItemProp>::GetAt
_TEXT	ENDS
PUBLIC	??1?$CItemContainer@VCItemElem@@@@UAE@XZ	; CItemContainer<CItemElem>::~CItemContainer<CItemElem>
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ??1?$CItemContainer@VCItemElem@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CItemContainer@VCItemElem@@@@UAE@XZ PROC NEAR	; CItemContainer<CItemElem>::~CItemContainer<CItemElem>, COMDAT
; _this$ = ecx

; 328  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 329  : 	SAFE_DELETE_ARRAY( m_apItem );

  00003	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00006	85 c9		 test	 ecx, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7?$CItemContainer@VCItemElem@@@@6B@
  0000e	74 22		 je	 SHORT $L186305
  00010	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00013	85 d2		 test	 edx, edx
  00015	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00018	74 08		 je	 SHORT $L206770
  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	6a 03		 push	 3
  0001e	ff 10		 call	 DWORD PTR [eax]
  00020	eb 09		 jmp	 SHORT $L206771
$L206770:
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00028	83 c4 04	 add	 esp, 4
$L206771:
  0002b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$L186305:

; 330  : 	SAFE_DELETE_ARRAY( m_apIndex );

  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	85 c0		 test	 eax, eax
  00037	74 10		 je	 SHORT $L186310
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003f	83 c4 04	 add	 esp, 4
  00042	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$L186310:
  00049	5e		 pop	 esi

; 331  : }

  0004a	c3		 ret	 0
??1?$CItemContainer@VCItemElem@@@@UAE@XZ ENDP		; CItemContainer<CItemElem>::~CItemContainer<CItemElem>
_TEXT	ENDS
PUBLIC	?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z ; CItemContainer<CItemElem>::SetItemContainer
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:NEAR			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??0CItemElem@@QAE@XZ:NEAR			; CItemElem::CItemElem
EXTRN	??1CItemElem@@UAE@XZ:NEAR			; CItemElem::~CItemElem
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T206800 DD	0ffffffffH
	DD	FLAT:$L206791
$T206795 DD	019930520H
	DD	01H
	DD	FLAT:$T206800
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_dwItemType$ = 8					; size = 4
$T206787 = 12						; size = 4
_dwItemMax$ = 12					; size = 4
_dwExtra$ = 16						; size = 4
?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z PROC NEAR ; CItemContainer<CItemElem>::SetItemContainer, COMDAT
; _this$ = ecx

; 356  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z
  0000d	50		 push	 eax

; 357  : 	m_dwIndexNum	= dwItemMax;

  0000e	8b 44 24 14	 mov	 eax, DWORD PTR _dwItemMax$[esp+8]
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx

; 358  : 	m_dwItemMax		= dwItemMax;
; 359  : 	if( dwExtra != 0xffffffff )

  0001d	8b 4c 24 20	 mov	 ecx, DWORD PTR _dwExtra$[esp+16]
  00021	83 f9 ff	 cmp	 ecx, -1
  00024	57		 push	 edi
  00025	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00028	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0002b	74 05		 je	 SHORT $L186334

; 360  : 		m_dwItemMax		+= dwExtra;

  0002d	03 c1		 add	 eax, ecx
  0002f	89 46 10	 mov	 DWORD PTR [esi+16], eax
$L186334:

; 361  : 
; 362  : 	SAFE_DELETE_ARRAY( m_apItem );

  00032	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00035	85 c9		 test	 ecx, ecx
  00037	74 22		 je	 SHORT $L186335
  00039	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0003c	85 d2		 test	 edx, edx
  0003e	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00041	74 08		 je	 SHORT $L206780
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	6a 03		 push	 3
  00047	ff 10		 call	 DWORD PTR [eax]
  00049	eb 09		 jmp	 SHORT $L206781
$L206780:
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00051	83 c4 04	 add	 esp, 4
$L206781:
  00054	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$L186335:

; 363  : 	SAFE_DELETE_ARRAY( m_apIndex );

  0005b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005e	85 c0		 test	 eax, eax
  00060	74 10		 je	 SHORT $L186340
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00068	83 c4 04	 add	 esp, 4
  0006b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$L186340:

; 364  : 
; 365  : 	m_apItem	= new T[ m_dwItemMax ];

  00072	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00075	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00078	c1 e1 05	 shl	 ecx, 5
  0007b	83 c1 04	 add	 ecx, 4
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00084	83 c4 04	 add	 esp, 4
  00087	89 44 24 20	 mov	 DWORD PTR $T206787[esp+20], eax
  0008b	85 c0		 test	 eax, eax
  0008d	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00095	74 1d		 je	 SHORT $L206788
  00097	68 00 00 00 00	 push	 OFFSET FLAT:??1CItemElem@@UAE@XZ ; CItemElem::~CItemElem
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??0CItemElem@@QAE@XZ ; CItemElem::CItemElem
  000a1	57		 push	 edi
  000a2	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  000a5	68 a0 00 00 00	 push	 160			; 000000a0H
  000aa	53		 push	 ebx
  000ab	89 38		 mov	 DWORD PTR [eax], edi
  000ad	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  000b2	eb 02		 jmp	 SHORT $L206789
$L206788:
  000b4	33 db		 xor	 ebx, ebx
$L206789:

; 366  : 	m_apIndex	= new DWORD[ m_dwItemMax ];

  000b6	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000b9	c1 e2 02	 shl	 edx, 2
  000bc	52		 push	 edx
  000bd	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  000c5	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  000c8	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 367  : 	for( u_long i = 0; i < m_dwItemMax; i++ )

  000cd	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000d0	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000d3	83 c4 04	 add	 esp, 4
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c9		 test	 ecx, ecx
  000da	76 37		 jbe	 SHORT $L186355

; 364  : 
; 365  : 	m_apItem	= new T[ m_dwItemMax ];

  000dc	33 c9		 xor	 ecx, ecx
  000de	8b ff		 npad	 2
$L186353:

; 368  : 	{
; 369  : 		m_apItem[i].m_dwObjId = i;

  000e0	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000e3	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 370  : 		if( i < m_dwIndexNum )

  000e7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  000ea	73 0f		 jae	 SHORT $L186356

; 371  : 		{
; 372  : 			m_apItem[i].m_dwObjIndex	= i;

  000ec	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000ef	89 44 0a 2c	 mov	 DWORD PTR [edx+ecx+44], eax

; 373  : 			m_apIndex[i]	= i;

  000f3	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000f6	89 04 82	 mov	 DWORD PTR [edx+eax*4], eax

; 374  : 		}
; 375  : 		else 

  000f9	eb 0a		 jmp	 SHORT $L186354
$L186356:

; 376  : 			m_apIndex[i]	= NULL_ID;

  000fb	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000fe	c7 04 82 ff ff
	ff ff		 mov	 DWORD PTR [edx+eax*4], -1
$L186354:
  00105	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00108	40		 inc	 eax
  00109	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  0010f	3b c2		 cmp	 eax, edx
  00111	72 cd		 jb	 SHORT $L186353
$L186355:

; 377  : 	}
; 378  : }

  00113	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00120	5b		 pop	 ebx
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH
  00124	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L206791:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T206787[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T206795
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z ENDP ; CItemContainer<CItemElem>::SetItemContainer
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<void *,std::allocator<void *> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<void *,std::allocator<void *> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<void *,std::allocator<void *> >::_Node>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_G?$CItemContainer@VCItemElem@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CItemContainer@VCItemElem@@@@UAEPAXI@Z PROC NEAR	; CItemContainer<CItemElem>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00006	85 c9		 test	 ecx, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7?$CItemContainer@VCItemElem@@@@6B@
  0000e	74 22		 je	 SHORT $L206820
  00010	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00013	85 d2		 test	 edx, edx
  00015	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00018	74 08		 je	 SHORT $L206826
  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	6a 03		 push	 3
  0001e	ff 10		 call	 DWORD PTR [eax]
  00020	eb 09		 jmp	 SHORT $L206827
$L206826:
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00028	83 c4 04	 add	 esp, 4
$L206827:
  0002b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$L206820:
  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	85 c0		 test	 eax, eax
  00037	74 10		 je	 SHORT $L206821
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003f	83 c4 04	 add	 esp, 4
  00042	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$L206821:
  00049	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0004e	74 09		 je	 SHORT $L206831
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4
$L206831:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	c2 04 00	 ret	 4
??_G?$CItemContainer@VCItemElem@@@@UAEPAXI@Z ENDP	; CItemContainer<CItemElem>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?ConvItemConnectDB@CDbManager@@QAEHPAVCQuery@@0@Z ; CDbManager::ConvItemConnectDB
PUBLIC	??_C@_0BB@FDLCCPK@Connect?5Not?5Item?$AA@	; `string'
EXTRN	?Connect@CQuery@@QAEHHPAD0PBD@Z:NEAR		; CQuery::Connect
EXTRN	?DSN_NAME_CHARACTER01@@3PADA:BYTE		; DSN_NAME_CHARACTER01
EXTRN	?DB_ADMIN_ID_CHARACTER01@@3PADA:BYTE		; DB_ADMIN_ID_CHARACTER01
;	COMDAT ??_C@_0BB@FDLCCPK@Connect?5Not?5Item?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
CONST	SEGMENT
??_C@_0BB@FDLCCPK@Connect?5Not?5Item?$AA@ DB 'Connect Not Item', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?ConvItemConnectDB@CDbManager@@QAEHPAVCQuery@@0@Z
_TEXT	SEGMENT
_pQueryChar$ = 8					; size = 4
_pQuerySave$ = 12					; size = 4
?ConvItemConnectDB@CDbManager@@QAEHPAVCQuery@@0@Z PROC NEAR ; CDbManager::ConvItemConnectDB, COMDAT
; _this$ = ecx

; 70   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 71   : 	if( FALSE == pQueryChar->Connect( 3, DSN_NAME_CHARACTER01, DB_ADMIN_ID_CHARACTER01, DB_ADMIN_PASS_CHARACTER01 ) )

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pQueryChar$[esp+4]
  00006	8d b1 c0 04 00
	00		 lea	 esi, DWORD PTR [ecx+1216]
  0000c	56		 push	 esi
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:?DB_ADMIN_ID_CHARACTER01@@3PADA ; DB_ADMIN_ID_CHARACTER01
  00012	68 00 00 00 00	 push	 OFFSET FLAT:?DSN_NAME_CHARACTER01@@3PADA ; DSN_NAME_CHARACTER01
  00017	6a 03		 push	 3
  00019	8b cf		 mov	 ecx, edi
  0001b	e8 00 00 00 00	 call	 ?Connect@CQuery@@QAEHHPAD0PBD@Z ; CQuery::Connect
  00020	85 c0		 test	 eax, eax
  00022	75 0e		 jne	 SHORT $L204522

; 72   : 	{
; 73   : 		SAFE_DELETE( pQueryChar );

  00024	85 ff		 test	 edi, edi
  00026	74 3a		 je	 SHORT $L206840
  00028	8b cf		 mov	 ecx, edi
  0002a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0002f	57		 push	 edi

; 74   : 		AfxMessageBox( "Connect Not Item", MB_OK );
; 75   : 		return FALSE;

  00030	eb 28		 jmp	 SHORT $L206850
$L204522:

; 76   : 	}
; 77   : 	
; 78   : 	if( FALSE == pQuerySave->Connect( 3, DSN_NAME_CHARACTER01, DB_ADMIN_ID_CHARACTER01, DB_ADMIN_PASS_CHARACTER01 ) )

  00032	56		 push	 esi
  00033	8b 74 24 14	 mov	 esi, DWORD PTR _pQuerySave$[esp+8]
  00037	68 00 00 00 00	 push	 OFFSET FLAT:?DB_ADMIN_ID_CHARACTER01@@3PADA ; DB_ADMIN_ID_CHARACTER01
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:?DSN_NAME_CHARACTER01@@3PADA ; DSN_NAME_CHARACTER01
  00041	6a 03		 push	 3
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?Connect@CQuery@@QAEHHPAD0PBD@Z ; CQuery::Connect
  0004a	85 c0		 test	 eax, eax
  0004c	75 29		 jne	 SHORT $L204528

; 79   : 	{
; 80   : 		SAFE_DELETE( pQuerySave );

  0004e	85 f6		 test	 esi, esi
  00050	74 10		 je	 SHORT $L206840
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00059	56		 push	 esi
$L206850:
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005f	83 c4 04	 add	 esp, 4
$L206840:

; 81   : 		AfxMessageBox( "Connect Not Item", MB_OK );

  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@FDLCCPK@Connect?5Not?5Item?$AA@
  0006b	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00070	5f		 pop	 edi

; 82   : 		return FALSE;

  00071	33 c0		 xor	 eax, eax
  00073	5e		 pop	 esi

; 86   : }

  00074	c2 08 00	 ret	 8
$L204528:
  00077	5f		 pop	 edi

; 83   : 	}	
; 84   : 	
; 85   : 	return TRUE;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	5e		 pop	 esi

; 86   : }

  0007e	c2 08 00	 ret	 8
?ConvItemConnectDB@CDbManager@@QAEHPAVCQuery@@0@Z ENDP	; CDbManager::ConvItemConnectDB
_TEXT	ENDS
PUBLIC	?SaveUserInventoryBank@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z ; CDbManager::SaveUserInventoryBank
PUBLIC	??_C@_0IG@DEIOPEPG@UPDATE?5INVENTORY_TBL?5SET?5m_Inven@ ; `string'
PUBLIC	??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@	; `string'
PUBLIC	??_C@_06HHJABCJL@UPDATE?$AA@			; `string'
PUBLIC	??_C@_0IC@GOCAMAFG@UPDATE?5INVENTORY_EXT_TBL?5SET?5m_e@ ; `string'
PUBLIC	??_C@_0BJ@HNFBAJDL@UPDATE?5INVENTORY_EXT_TBL?$AA@ ; `string'
PUBLIC	??_C@_0IG@OELLNNGM@UPDATE?5BANK_TBL?5SET?5m_Bank?5?$DN?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0BA@HFOKCGBB@UPDATE?5BANK_TBL?$AA@	; `string'
PUBLIC	??_C@_0HD@HOMCPDMG@UPDATE?5BANK_EXT_TBL?5SET?5m_extBan@ ; `string'
PUBLIC	??_C@_0BE@BNFPHPPG@UPDATE?5BANK_EXT_TBL?$AA@	; `string'
EXTRN	__chkstk:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	?SaveInventory@CDbManager@@QAEXPAVCMover@@PAU_ItemContainerStruct@@@Z:NEAR ; CDbManager::SaveInventory
EXTRN	?SaveBank@CDbManager@@QAEXPAVCMover@@PAV?$CItemContainer@VCItemElem@@@@PAU_ItemContainerStruct@@@Z:NEAR ; CDbManager::SaveBank
;	COMDAT ??_C@_0IG@DEIOPEPG@UPDATE?5INVENTORY_TBL?5SET?5m_Inven@
CONST	SEGMENT
??_C@_0IG@DEIOPEPG@UPDATE?5INVENTORY_TBL?5SET?5m_Inven@ DB 'UPDATE INVENT'
	DB	'ORY_TBL SET m_Inventory = ''%s'', m_apIndex = ''%s'', m_dwObj'
	DB	'Index = ''%s'' where m_idPlayer = ''%07d'' and serverindex = '
	DB	'''%02d''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
CONST	SEGMENT
??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@ DB '..\ConvertQuery.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IC@GOCAMAFG@UPDATE?5INVENTORY_EXT_TBL?5SET?5m_e@
CONST	SEGMENT
??_C@_0IC@GOCAMAFG@UPDATE?5INVENTORY_EXT_TBL?5SET?5m_e@ DB 'UPDATE INVENT'
	DB	'ORY_EXT_TBL SET m_extInventory = ''%s'', m_InventoryPiercing '
	DB	'= ''%s'' where m_idPlayer = ''%07d'' and serverindex = ''%02d'
	DB	'''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0IG@OELLNNGM@UPDATE?5BANK_TBL?5SET?5m_Bank?5?$DN?5?8?$CFs@
CONST	SEGMENT
??_C@_0IG@OELLNNGM@UPDATE?5BANK_TBL?5SET?5m_Bank?5?$DN?5?8?$CFs@ DB 'UPDA'
	DB	'TE BANK_TBL SET m_Bank = ''%s'', m_apIndex_Bank = ''%s'', m_d'
	DB	'wObjIndex_Bank = ''%s'' where m_idPlayer = ''%07d'' and serve'
	DB	'rindex = ''%02d''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@HOMCPDMG@UPDATE?5BANK_EXT_TBL?5SET?5m_extBan@
CONST	SEGMENT
??_C@_0HD@HOMCPDMG@UPDATE?5BANK_EXT_TBL?5SET?5m_extBan@ DB 'UPDATE BANK_E'
	DB	'XT_TBL SET m_extBank = ''%s'', m_BankPiercing = ''%s'' where '
	DB	'm_idPlayer = ''%07d'' and serverindex = ''%02d''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHJABCJL@UPDATE?$AA@
CONST	SEGMENT
??_C@_06HHJABCJL@UPDATE?$AA@ DB 'UPDATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HNFBAJDL@UPDATE?5INVENTORY_EXT_TBL?$AA@
CONST	SEGMENT
??_C@_0BJ@HNFBAJDL@UPDATE?5INVENTORY_EXT_TBL?$AA@ DB 'UPDATE INVENTORY_EX'
	DB	'T_TBL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HFOKCGBB@UPDATE?5BANK_TBL?$AA@
CONST	SEGMENT
??_C@_0BA@HFOKCGBB@UPDATE?5BANK_TBL?$AA@ DB 'UPDATE BANK_TBL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNFPHPPG@UPDATE?5BANK_EXT_TBL?$AA@
CONST	SEGMENT
??_C@_0BE@BNFPHPPG@UPDATE?5BANK_EXT_TBL?$AA@ DB 'UPDATE BANK_EXT_TBL', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SaveUserInventoryBank@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z
_TEXT	SEGMENT
$T206927 = -42844					; size = 4
$T206928 = -42840					; size = 4
_icsInventory$ = -42836					; size = 21416
_icsBank$ = -21420					; size = 21416
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pszSQL$ = 8						; size = 4
_pMover$ = 12						; size = 4
_pQueryChar$ = 16					; size = 4
_pQuerySave$ = 20					; size = 4
?SaveUserInventoryBank@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z PROC NEAR ; CDbManager::SaveUserInventoryBank, COMDAT
; _this$ = ecx

; 274  : {

  00000	b8 5c a7 00 00	 mov	 eax, 42844		; 0000a75cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	53		 push	 ebx
  00012	55		 push	 ebp

; 275  : 	ItemContainerStruct icsInventory, icsBank;

  00013	33 db		 xor	 ebx, ebx
  00015	56		 push	 esi
  00016	8b b4 24 70 a7
	00 00		 mov	 esi, DWORD PTR _pMover$[esp+42852]
  0001d	57		 push	 edi
  0001e	8b bc 24 70 a7
	00 00		 mov	 edi, DWORD PTR _pszSQL$[esp+42856]
  00025	8b e9		 mov	 ebp, ecx
  00027	8b 8c 24 7c a7
	00 00		 mov	 ecx, DWORD PTR _pQuerySave$[esp+42856]

; 276  : 	SaveInventory( pMover, &icsInventory );

  0002e	8d 54 24 18	 lea	 edx, DWORD PTR _icsInventory$[esp+42860]
  00032	89 84 24 68 a7
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+42860], eax
  00039	8b 84 24 78 a7
	00 00		 mov	 eax, DWORD PTR _pQueryChar$[esp+42856]
  00040	52		 push	 edx
  00041	89 4c 24 18	 mov	 DWORD PTR $T206928[esp+42864], ecx
  00045	56		 push	 esi
  00046	8b cd		 mov	 ecx, ebp
  00048	89 44 24 18	 mov	 DWORD PTR $T206927[esp+42868], eax
  0004c	88 5c 24 20	 mov	 BYTE PTR _icsInventory$[esp+42868], bl
  00050	88 9c 24 20 18
	00 00		 mov	 BYTE PTR _icsInventory$[esp+49012], bl
  00057	88 9c 24 20 1a
	00 00		 mov	 BYTE PTR _icsInventory$[esp+49524], bl
  0005e	88 9c 24 20 1c
	00 00		 mov	 BYTE PTR _icsInventory$[esp+50036], bl
  00065	88 9c 24 20 24
	00 00		 mov	 BYTE PTR _icsInventory$[esp+52084], bl
  0006c	88 9c 24 60 43
	00 00		 mov	 BYTE PTR _icsInventory$[esp+60084], bl
  00073	88 9c 24 c8 53
	00 00		 mov	 BYTE PTR _icsBank$[esp+42868], bl
  0007a	88 9c 24 c8 6b
	00 00		 mov	 BYTE PTR _icsBank$[esp+49012], bl
  00081	88 9c 24 c8 6d
	00 00		 mov	 BYTE PTR _icsBank$[esp+49524], bl
  00088	88 9c 24 c8 6f
	00 00		 mov	 BYTE PTR _icsBank$[esp+50036], bl
  0008f	88 9c 24 c8 77
	00 00		 mov	 BYTE PTR _icsBank$[esp+52084], bl
  00096	88 9c 24 08 97
	00 00		 mov	 BYTE PTR _icsBank$[esp+60084], bl
  0009d	e8 00 00 00 00	 call	 ?SaveInventory@CDbManager@@QAEXPAVCMover@@PAU_ItemContainerStruct@@@Z ; CDbManager::SaveInventory

; 277  : 	SaveBank( pMover, &pMover->m_Bank[0], &icsBank );

  000a2	8d 84 24 c0 53
	00 00		 lea	 eax, DWORD PTR _icsBank$[esp+42860]
  000a9	50		 push	 eax
  000aa	8d 8e 94 41 00
	00		 lea	 ecx, DWORD PTR [esi+16788]
  000b0	51		 push	 ecx
  000b1	56		 push	 esi
  000b2	8b cd		 mov	 ecx, ebp
  000b4	e8 00 00 00 00	 call	 ?SaveBank@CDbManager@@QAEXPAVCMover@@PAV?$CItemContainer@VCItemElem@@@@PAU_ItemContainerStruct@@@Z ; CDbManager::SaveBank

; 278  : 
; 279  : 	sprintf( pszSQL, "UPDATE INVENTORY_TBL"
; 280  : 		" SET m_Inventory = '%s', m_apIndex = '%s', m_dwObjIndex = '%s'"
; 281  : 		" where m_idPlayer = '%07d' and serverindex = '%02d'",
; 282  : 		icsInventory.szItem, icsInventory.szIndex, icsInventory.szObjIndex
; 283  : 		, pMover->m_idPlayer, g_appInfo.dwSys );

  000b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  000bf	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  000c5	52		 push	 edx
  000c6	50		 push	 eax
  000c7	8d 8c 24 20 1a
	00 00		 lea	 ecx, DWORD PTR _icsInventory$[esp+49524]
  000ce	51		 push	 ecx
  000cf	8d 94 24 24 18
	00 00		 lea	 edx, DWORD PTR _icsInventory$[esp+49016]
  000d6	52		 push	 edx
  000d7	8d 44 24 28	 lea	 eax, DWORD PTR _icsInventory$[esp+42876]
  000db	50		 push	 eax
  000dc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0IG@DEIOPEPG@UPDATE?5INVENTORY_TBL?5SET?5m_Inven@
  000e1	57		 push	 edi
  000e2	e8 00 00 00 00	 call	 _sprintf
  000e7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 284  : 
; 285  : 	if( prj.IsConvMode( SAVE_TEXT ) )

  000ea	6a 02		 push	 2
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000f1	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  000f6	85 c0		 test	 eax, eax

; 286  : 	{
; 287  : 		FILEOUT2( "..\\ConvertQuery.txt", pszSQL );

  000f8	57		 push	 edi
  000f9	0f 84 23 01 00
	00		 je	 $L204717
  000ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
  00104	e8 00 00 00 00	 call	 ?FILEOUT2@@YAXPBD0ZZ	; FILEOUT2

; 288  : 	}
; 289  : 	else

  00109	8b 6c 24 1c	 mov	 ebp, DWORD PTR $T206928[esp+42868]
  0010d	83 c4 08	 add	 esp, 8
$L204720:

; 297  : 		}
; 298  : 	}
; 299  : 	
; 300  : 	sprintf( pszSQL, "UPDATE INVENTORY_EXT_TBL"
; 301  : 		" SET m_extInventory = '%s', m_InventoryPiercing = '%s'"
; 302  : 		" where m_idPlayer = '%07d' and serverindex = '%02d'",
; 303  : 		icsInventory.szExt, icsInventory.szPiercing, pMover->m_idPlayer, g_appInfo.dwSys );

  00110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00116	8b 96 90 00 00
	00		 mov	 edx, DWORD PTR [esi+144]
  0011c	51		 push	 ecx
  0011d	52		 push	 edx
  0011e	8d 84 24 20 24
	00 00		 lea	 eax, DWORD PTR _icsInventory$[esp+52084]
  00125	50		 push	 eax
  00126	8d 8c 24 24 1c
	00 00		 lea	 ecx, DWORD PTR _icsInventory$[esp+50040]
  0012d	51		 push	 ecx
  0012e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0IC@GOCAMAFG@UPDATE?5INVENTORY_EXT_TBL?5SET?5m_e@
  00133	57		 push	 edi
  00134	e8 00 00 00 00	 call	 _sprintf
  00139	83 c4 18	 add	 esp, 24			; 00000018H

; 304  : 	
; 305  : 	if( prj.IsConvMode( SAVE_TEXT ) )

  0013c	6a 02		 push	 2
  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00143	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00148	85 c0		 test	 eax, eax

; 306  : 	{
; 307  : 		FILEOUT2( "..\\ConvertQuery.txt", pszSQL );

  0014a	57		 push	 edi
  0014b	0f 84 20 01 00
	00		 je	 $L204732
  00151	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
  00156	e8 00 00 00 00	 call	 ?FILEOUT2@@YAXPBD0ZZ	; FILEOUT2
  0015b	83 c4 08	 add	 esp, 8
$L204734:

; 317  : 		}
; 318  : 	}
; 319  : 	
; 320  : 	sprintf( pszSQL, "UPDATE BANK_TBL"
; 321  : 		" SET m_Bank = '%s', m_apIndex_Bank = '%s', m_dwObjIndex_Bank = '%s'"
; 322  : 		" where m_idPlayer = '%07d' and serverindex = '%02d'",
; 323  : 		icsBank.szItem, icsBank.szIndex, icsBank.szObjIndex, pMover->m_idPlayer, g_appInfo.dwSys );

  0015e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00164	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  0016a	52		 push	 edx
  0016b	50		 push	 eax
  0016c	8d 8c 24 c8 6d
	00 00		 lea	 ecx, DWORD PTR _icsBank$[esp+49524]
  00173	51		 push	 ecx
  00174	8d 94 24 cc 6b
	00 00		 lea	 edx, DWORD PTR _icsBank$[esp+49016]
  0017b	52		 push	 edx
  0017c	8d 84 24 d0 53
	00 00		 lea	 eax, DWORD PTR _icsBank$[esp+42876]
  00183	50		 push	 eax
  00184	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0IG@OELLNNGM@UPDATE?5BANK_TBL?5SET?5m_Bank?5?$DN?5?8?$CFs@
  00189	57		 push	 edi
  0018a	e8 00 00 00 00	 call	 _sprintf
  0018f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 324  : 
; 325  : 		if( prj.IsConvMode( SAVE_TEXT ) )

  00192	6a 02		 push	 2
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00199	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  0019e	85 c0		 test	 eax, eax

; 326  : 	{
; 327  : 		FILEOUT2( "..\\ConvertQuery.txt", pszSQL );

  001a0	57		 push	 edi
  001a1	0f 84 18 01 00
	00		 je	 $L204746
  001a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
  001ac	e8 00 00 00 00	 call	 ?FILEOUT2@@YAXPBD0ZZ	; FILEOUT2
  001b1	83 c4 08	 add	 esp, 8
$L204748:

; 337  : 		}		
; 338  : 	}
; 339  : 	
; 340  : 	sprintf( pszSQL, "UPDATE BANK_EXT_TBL"
; 341  : 		" SET m_extBank = '%s', m_BankPiercing = '%s'"
; 342  : 		" where m_idPlayer = '%07d' and serverindex = '%02d'",
; 343  : 		icsBank.szExt, icsBank.szPiercing, pMover->m_idPlayer, g_appInfo.dwSys );

  001b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  001ba	8b 96 90 00 00
	00		 mov	 edx, DWORD PTR [esi+144]
  001c0	51		 push	 ecx
  001c1	52		 push	 edx
  001c2	8d 84 24 c8 77
	00 00		 lea	 eax, DWORD PTR _icsBank$[esp+52084]
  001c9	50		 push	 eax
  001ca	8d 8c 24 cc 6f
	00 00		 lea	 ecx, DWORD PTR _icsBank$[esp+50040]
  001d1	51		 push	 ecx
  001d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0HD@HOMCPDMG@UPDATE?5BANK_EXT_TBL?5SET?5m_extBan@
  001d7	57		 push	 edi
  001d8	e8 00 00 00 00	 call	 _sprintf
  001dd	83 c4 18	 add	 esp, 24			; 00000018H

; 344  : 		
; 345  : 	if( prj.IsConvMode( SAVE_TEXT ) )

  001e0	6a 02		 push	 2
  001e2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  001e7	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  001ec	85 c0		 test	 eax, eax

; 346  : 	{
; 347  : 		FILEOUT2( "..\\ConvertQuery.txt", pszSQL );

  001ee	57		 push	 edi
  001ef	0f 84 18 01 00
	00		 je	 $L204760
  001f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
  001fa	e8 00 00 00 00	 call	 ?FILEOUT2@@YAXPBD0ZZ	; FILEOUT2
  001ff	83 c4 08	 add	 esp, 8
$L204762:

; 357  : 		}
; 358  : 	}
; 359  : 	return TRUE;

  00202	b8 01 00 00 00	 mov	 eax, 1
$L204712:

; 360  : }

  00207	8b 8c 24 68 a7
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+42860]
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5d		 pop	 ebp
  00211	5b		 pop	 ebx
  00212	33 cc		 xor	 ecx, esp
  00214	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00219	81 c4 5c a7 00
	00		 add	 esp, 42844		; 0000a75cH
  0021f	c2 10 00	 ret	 16			; 00000010H
$L204717:

; 290  : 	{
; 291  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  00222	8b 6c 24 18	 mov	 ebp, DWORD PTR $T206928[esp+42864]
  00226	8b cd		 mov	 ecx, ebp
  00228	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  0022d	85 c0		 test	 eax, eax
  0022f	0f 85 db fe ff
	ff		 jne	 $L204720

; 292  : 		{
; 293  : 			SAFE_DELETE( pQueryChar );

  00235	8b 74 24 10	 mov	 esi, DWORD PTR $T206927[esp+42860]
  00239	3b f3		 cmp	 esi, ebx
  0023b	74 10		 je	 SHORT $L206856
  0023d	8b ce		 mov	 ecx, esi
  0023f	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00244	56		 push	 esi
  00245	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0024a	83 c4 04	 add	 esp, 4
$L206856:

; 294  : 			SAFE_DELETE( pQuerySave );

  0024d	3b eb		 cmp	 ebp, ebx
  0024f	74 10		 je	 SHORT $L206860
  00251	8b cd		 mov	 ecx, ebp
  00253	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00258	55		 push	 ebp
  00259	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0025e	83 c4 04	 add	 esp, 4
$L206860:

; 295  : 			AfxMessageBox( "UPDATE", MB_OK );

  00261	53		 push	 ebx
  00262	53		 push	 ebx
  00263	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06HHJABCJL@UPDATE?$AA@
  00268	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 296  : 			return FALSE;

  0026d	33 c0		 xor	 eax, eax
  0026f	eb 96		 jmp	 SHORT $L204712
$L204732:

; 308  : 	}
; 309  : 	else
; 310  : 	{
; 311  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  00271	8b cd		 mov	 ecx, ebp
  00273	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00278	85 c0		 test	 eax, eax
  0027a	0f 85 de fe ff
	ff		 jne	 $L204734

; 312  : 		{
; 313  : 			SAFE_DELETE( pQueryChar );

  00280	8b 74 24 10	 mov	 esi, DWORD PTR $T206927[esp+42860]
  00284	3b f3		 cmp	 esi, ebx
  00286	74 10		 je	 SHORT $L206864
  00288	8b ce		 mov	 ecx, esi
  0028a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0028f	56		 push	 esi
  00290	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00295	83 c4 04	 add	 esp, 4
$L206864:

; 314  : 			SAFE_DELETE( pQuerySave );

  00298	3b eb		 cmp	 ebp, ebx
  0029a	74 10		 je	 SHORT $L206868
  0029c	8b cd		 mov	 ecx, ebp
  0029e	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  002a3	55		 push	 ebp
  002a4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002a9	83 c4 04	 add	 esp, 4
$L206868:

; 315  : 			AfxMessageBox( "UPDATE INVENTORY_EXT_TBL", MB_OK );

  002ac	53		 push	 ebx
  002ad	53		 push	 ebx
  002ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@HNFBAJDL@UPDATE?5INVENTORY_EXT_TBL?$AA@
  002b3	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 316  : 			return FALSE;

  002b8	33 c0		 xor	 eax, eax
  002ba	e9 48 ff ff ff	 jmp	 $L204712
$L204746:

; 328  : 	}
; 329  : 	else
; 330  : 	{
; 331  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  002bf	8b cd		 mov	 ecx, ebp
  002c1	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  002c6	85 c0		 test	 eax, eax
  002c8	0f 85 e6 fe ff
	ff		 jne	 $L204748

; 332  : 		{
; 333  : 			SAFE_DELETE( pQueryChar );

  002ce	8b 74 24 10	 mov	 esi, DWORD PTR $T206927[esp+42860]
  002d2	3b f3		 cmp	 esi, ebx
  002d4	74 10		 je	 SHORT $L206872
  002d6	8b ce		 mov	 ecx, esi
  002d8	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  002dd	56		 push	 esi
  002de	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002e3	83 c4 04	 add	 esp, 4
$L206872:

; 334  : 			SAFE_DELETE( pQuerySave );

  002e6	3b eb		 cmp	 ebp, ebx
  002e8	74 10		 je	 SHORT $L206876
  002ea	8b cd		 mov	 ecx, ebp
  002ec	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  002f1	55		 push	 ebp
  002f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002f7	83 c4 04	 add	 esp, 4
$L206876:

; 335  : 			AfxMessageBox( "UPDATE BANK_TBL", MB_OK );

  002fa	53		 push	 ebx
  002fb	53		 push	 ebx
  002fc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@HFOKCGBB@UPDATE?5BANK_TBL?$AA@
  00301	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 336  : 			return FALSE;

  00306	33 c0		 xor	 eax, eax
  00308	e9 fa fe ff ff	 jmp	 $L204712
$L204760:

; 348  : 	}
; 349  : 	else
; 350  : 	{
; 351  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  0030d	8b cd		 mov	 ecx, ebp
  0030f	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00314	85 c0		 test	 eax, eax
  00316	0f 85 e6 fe ff
	ff		 jne	 $L204762

; 352  : 		{
; 353  : 			SAFE_DELETE( pQueryChar );

  0031c	8b 74 24 10	 mov	 esi, DWORD PTR $T206927[esp+42860]
  00320	3b f3		 cmp	 esi, ebx
  00322	74 10		 je	 SHORT $L206880
  00324	8b ce		 mov	 ecx, esi
  00326	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0032b	56		 push	 esi
  0032c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00331	83 c4 04	 add	 esp, 4
$L206880:

; 354  : 			SAFE_DELETE( pQuerySave );

  00334	3b eb		 cmp	 ebp, ebx
  00336	74 10		 je	 SHORT $L206884
  00338	8b cd		 mov	 ecx, ebp
  0033a	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0033f	55		 push	 ebp
  00340	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00345	83 c4 04	 add	 esp, 4
$L206884:

; 355  : 			AfxMessageBox( "UPDATE BANK_EXT_TBL", MB_OK );

  00348	53		 push	 ebx
  00349	53		 push	 ebx
  0034a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@BNFPHPPG@UPDATE?5BANK_EXT_TBL?$AA@
  0034f	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 356  : 			return FALSE;

  00354	33 c0		 xor	 eax, eax
  00356	e9 ac fe ff ff	 jmp	 $L204712
?SaveUserInventoryBank@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z ENDP ; CDbManager::SaveUserInventoryBank
_TEXT	ENDS
PUBLIC	?SaveConvGuildBank@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z ; CDbManager::SaveConvGuildBank
PUBLIC	??_C@_0FP@DEDGGBGG@UPDATE?5GUILD_BANK_TBL?5SET?5m_Guil@ ; `string'
PUBLIC	??_C@_0IC@KHIDFCII@UPDATE?5GUILD_BANK_EXT_TBL?5SET?5m_@ ; `string'
EXTRN	?SaveGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAU_ItemContainerStruct@@@Z:NEAR ; CDbManager::SaveGuildBank
;	COMDAT ??_C@_0FP@DEDGGBGG@UPDATE?5GUILD_BANK_TBL?5SET?5m_Guil@
CONST	SEGMENT
??_C@_0FP@DEDGGBGG@UPDATE?5GUILD_BANK_TBL?5SET?5m_Guil@ DB 'UPDATE GUILD_'
	DB	'BANK_TBL SET m_GuildBank = ''%s'' where m_idGuild = ''%06d'' '
	DB	'and serverindex = ''%02d''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IC@KHIDFCII@UPDATE?5GUILD_BANK_EXT_TBL?5SET?5m_@
CONST	SEGMENT
??_C@_0IC@KHIDFCII@UPDATE?5GUILD_BANK_EXT_TBL?5SET?5m_@ DB 'UPDATE GUILD_'
	DB	'BANK_EXT_TBL SET m_extGuildBank = ''%s'', m_GuildBankPiercing'
	DB	' = ''%s'' where m_idGuild = ''%06d'' and serverindex = ''%02d'
	DB	'''', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SaveConvGuildBank@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z
_TEXT	SEGMENT
_icsGuildBank$ = -21420					; size = 21416
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pszSQL$ = 8						; size = 4
_nGuildId$ = 12						; size = 4
_GuildBank$ = 16					; size = 4
_pQueryChar$ = 20					; size = 4
_pQuerySave$ = 24					; size = 4
?SaveConvGuildBank@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z PROC NEAR ; CDbManager::SaveConvGuildBank, COMDAT
; _this$ = ecx

; 363  : {

  00000	b8 ac 53 00 00	 mov	 eax, 21420		; 000053acH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	8b ac 24 c4 53
	00 00		 mov	 ebp, DWORD PTR _pQueryChar$[esp+21424]
  0001a	56		 push	 esi
  0001b	8b b4 24 bc 53
	00 00		 mov	 esi, DWORD PTR _pszSQL$[esp+21428]
  00022	57		 push	 edi
  00023	8b bc 24 d0 53
	00 00		 mov	 edi, DWORD PTR _pQuerySave$[esp+21432]

; 364  : 	// Guild Save
; 365  : 	ItemContainerStruct	icsGuildBank;

  0002a	33 db		 xor	 ebx, ebx

; 366  : 	SaveGuildBank( GuildBank, &icsGuildBank );

  0002c	8d 54 24 10	 lea	 edx, DWORD PTR _icsGuildBank$[esp+21436]
  00030	89 84 24 b8 53
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+21436], eax
  00037	8b 84 24 c8 53
	00 00		 mov	 eax, DWORD PTR _GuildBank$[esp+21432]
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	88 5c 24 18	 mov	 BYTE PTR _icsGuildBank$[esp+21444], bl
  00044	88 9c 24 18 18
	00 00		 mov	 BYTE PTR _icsGuildBank$[esp+27588], bl
  0004b	88 9c 24 18 1a
	00 00		 mov	 BYTE PTR _icsGuildBank$[esp+28100], bl
  00052	88 9c 24 18 1c
	00 00		 mov	 BYTE PTR _icsGuildBank$[esp+28612], bl
  00059	88 9c 24 18 24
	00 00		 mov	 BYTE PTR _icsGuildBank$[esp+30660], bl
  00060	88 9c 24 58 43
	00 00		 mov	 BYTE PTR _icsGuildBank$[esp+38660], bl
  00067	e8 00 00 00 00	 call	 ?SaveGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAU_ItemContainerStruct@@@Z ; CDbManager::SaveGuildBank

; 367  : 	
; 368  : 	sprintf( pszSQL, "UPDATE GUILD_BANK_TBL"
; 369  : 		" SET m_GuildBank = '%s'"
; 370  : 		" where m_idGuild = '%06d' and serverindex = '%02d'",
; 371  : 		icsGuildBank.szItem, g_appInfo.dwSys );

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00071	50		 push	 eax
  00072	8d 4c 24 14	 lea	 ecx, DWORD PTR _icsGuildBank$[esp+21440]
  00076	51		 push	 ecx
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FP@DEDGGBGG@UPDATE?5GUILD_BANK_TBL?5SET?5m_Guil@
  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 _sprintf
  00082	83 c4 10	 add	 esp, 16			; 00000010H

; 372  : 
; 373  : 	if( prj.IsConvMode( SAVE_TEXT ) )

  00085	6a 02		 push	 2
  00087	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0008c	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00091	85 c0		 test	 eax, eax

; 374  : 	{
; 375  : 		FILEOUT2( "..\\ConvertQuery.txt", pszSQL );

  00093	56		 push	 esi
  00094	74 0f		 je	 SHORT $L204783
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
  0009b	e8 00 00 00 00	 call	 ?FILEOUT2@@YAXPBD0ZZ	; FILEOUT2
  000a0	83 c4 08	 add	 esp, 8

; 376  : 	}
; 377  : 	else

  000a3	eb 0b		 jmp	 SHORT $L204785
$L204783:

; 378  : 	{	
; 379  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  000a5	8b cf		 mov	 ecx, edi
  000a7	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  000ac	85 c0		 test	 eax, eax

; 380  : 		{
; 381  : 			SAFE_DELETE( pQueryChar );
; 382  : 			SAFE_DELETE( pQuerySave );
; 383  : 			AfxMessageBox( pszSQL, MB_OK );
; 384  : 			return FALSE;

  000ae	74 76		 je	 SHORT $L206981
$L204785:

; 385  : 		}
; 386  : 	}
; 387  : 	
; 388  : 	sprintf( pszSQL, "UPDATE GUILD_BANK_EXT_TBL"
; 389  : 		" SET m_extGuildBank = '%s', m_GuildBankPiercing = '%s'"
; 390  : 		" where m_idGuild = '%06d' and serverindex = '%02d'",
; 391  : 		icsGuildBank.szExt, icsGuildBank.szPiercing, nGuildId, g_appInfo.dwSys );

  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  000b6	8b 84 24 c4 53
	00 00		 mov	 eax, DWORD PTR _nGuildId$[esp+21432]
  000bd	52		 push	 edx
  000be	50		 push	 eax
  000bf	8d 8c 24 18 24
	00 00		 lea	 ecx, DWORD PTR _icsGuildBank$[esp+30660]
  000c6	51		 push	 ecx
  000c7	8d 94 24 1c 1c
	00 00		 lea	 edx, DWORD PTR _icsGuildBank$[esp+28616]
  000ce	52		 push	 edx
  000cf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0IC@KHIDFCII@UPDATE?5GUILD_BANK_EXT_TBL?5SET?5m_@
  000d4	56		 push	 esi
  000d5	e8 00 00 00 00	 call	 _sprintf
  000da	83 c4 18	 add	 esp, 24			; 00000018H

; 392  : 
; 393  : 	if( prj.IsConvMode( SAVE_TEXT ) )

  000dd	6a 02		 push	 2
  000df	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000e4	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  000e9	85 c0		 test	 eax, eax

; 394  : 	{
; 395  : 		FILEOUT2( "..\\ConvertQuery.txt", pszSQL );

  000eb	56		 push	 esi
  000ec	74 2d		 je	 SHORT $L204796
  000ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@PAOPBHJN@?4?4?2ConvertQuery?4txt?$AA@
  000f3	e8 00 00 00 00	 call	 ?FILEOUT2@@YAXPBD0ZZ	; FILEOUT2
  000f8	83 c4 08	 add	 esp, 8
$L204798:

; 405  : 		}
; 406  : 	}
; 407  : 	return TRUE;	

  000fb	b8 01 00 00 00	 mov	 eax, 1
$L204779:

; 408  : }

  00100	8b 8c 24 b8 53
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+21436]
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5d		 pop	 ebp
  0010a	5b		 pop	 ebx
  0010b	33 cc		 xor	 ecx, esp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	81 c4 ac 53 00
	00		 add	 esp, 21420		; 000053acH
  00118	c2 14 00	 ret	 20			; 00000014H
$L204796:

; 396  : 	}
; 397  : 	else
; 398  : 	{
; 399  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  0011b	8b cf		 mov	 ecx, edi
  0011d	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  00122	85 c0		 test	 eax, eax
  00124	75 d5		 jne	 SHORT $L204798
$L206981:

; 400  : 		{
; 401  : 			SAFE_DELETE( pQueryChar );

  00126	3b eb		 cmp	 ebp, ebx
  00128	74 10		 je	 SHORT $L206946
  0012a	8b cd		 mov	 ecx, ebp
  0012c	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00131	55		 push	 ebp
  00132	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00137	83 c4 04	 add	 esp, 4
$L206946:

; 402  : 			SAFE_DELETE( pQuerySave );

  0013a	3b fb		 cmp	 edi, ebx
  0013c	74 10		 je	 SHORT $L206950
  0013e	8b cf		 mov	 ecx, edi
  00140	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00145	57		 push	 edi
  00146	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014b	83 c4 04	 add	 esp, 4
$L206950:

; 403  : 			AfxMessageBox( pszSQL, MB_OK );

  0014e	53		 push	 ebx
  0014f	53		 push	 ebx
  00150	56		 push	 esi
  00151	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 404  : 			return FALSE;

  00156	33 c0		 xor	 eax, eax
  00158	eb a6		 jmp	 SHORT $L204779
?SaveConvGuildBank@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z ENDP ; CDbManager::SaveConvGuildBank
_TEXT	ENDS
PUBLIC	??_C@_0GI@EMHCMEPI@UPDATE?5GUILD_TBL?5SET?5m_nGuildGol@ ; `string'
PUBLIC	??_C@_0DD@ICGMIJIF@GuildId?5?$DN?5?$CFd?0?5Item0?5?$DN?5?$CFd?0?5Item1?5@ ; `string'
PUBLIC	?RemoveGuildBankListPanya@CDbManager@@QAEHPADHPAVCQuery@@1HH@Z ; CDbManager::RemoveGuildBankListPanya
;	COMDAT ??_C@_0GI@EMHCMEPI@UPDATE?5GUILD_TBL?5SET?5m_nGuildGol@
CONST	SEGMENT
??_C@_0GI@EMHCMEPI@UPDATE?5GUILD_TBL?5SET?5m_nGuildGol@ DB 'UPDATE GUILD_'
	DB	'TBL SET m_nGuildGold = m_nGuildGold + %d where m_idGuild = '''
	DB	'%06d'' and serverindex = ''%02d''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ICGMIJIF@GuildId?5?$DN?5?$CFd?0?5Item0?5?$DN?5?$CFd?0?5Item1?5@
CONST	SEGMENT
??_C@_0DD@ICGMIJIF@GuildId?5?$DN?5?$CFd?0?5Item0?5?$DN?5?$CFd?0?5Item1?5@ DB 'G'
	DB	'uildId = %d, Item0 = %d, Item1 = %d, AddGold = %d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?RemoveGuildBankListPanya@CDbManager@@QAEHPADHPAVCQuery@@1HH@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_nGuildId$ = 12						; size = 4
_pQueryChar$ = 16					; size = 4
_pQuerySave$ = 20					; size = 4
_nCountItem0$ = 24					; size = 4
_nCountItem1$ = 28					; size = 4
?RemoveGuildBankListPanya@CDbManager@@QAEHPADHPAVCQuery@@1HH@Z PROC NEAR ; CDbManager::RemoveGuildBankListPanya, COMDAT
; _this$ = ecx

; 420  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 421  : 	if( prj.IsConvMode( REMOVE_ITEM_ALL_PAY ) )

  00003	6a 08		 push	 8
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000a	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  0000f	85 c0		 test	 eax, eax
  00011	0f 84 aa 00 00
	00		 je	 $L204833

; 422  : 	{
; 423  : 		DWORD dwAddGold = GetRemoveItemPanya( nCountItem0, nCountItem1 );

  00017	8b 44 24 20	 mov	 eax, DWORD PTR _nCountItem0$[esp+8]
  0001b	33 f6		 xor	 esi, esi
  0001d	85 c0		 test	 eax, eax
  0001f	74 08		 je	 SHORT $L206995
  00021	8b f0		 mov	 esi, eax
  00023	69 f6 a0 8c 00
	00		 imul	 esi, 36000		; 00008ca0H
$L206995:
  00029	55		 push	 ebp
  0002a	8b 6c 24 28	 mov	 ebp, DWORD PTR _nCountItem1$[esp+12]
  0002e	85 ed		 test	 ebp, ebp
  00030	74 0a		 je	 SHORT $L206996
  00032	8b c5		 mov	 eax, ebp
  00034	69 c0 2c 40 02
	00		 imul	 eax, 147500		; 0002402cH
  0003a	03 f0		 add	 esi, eax
$L206996:

; 424  : 		sprintf( pszSQL, "UPDATE GUILD_TBL"
; 425  : 			" SET m_nGuildGold = m_nGuildGold + %d"
; 426  : 			" where m_idGuild = '%06d' and serverindex = '%02d'",
; 427  : 			dwAddGold, nGuildId, g_appInfo.dwSys );

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_appInfo@@3UAppInfo@@A
  00042	8b 7c 24 18	 mov	 edi, DWORD PTR _nGuildId$[esp+12]
  00046	8b 5c 24 14	 mov	 ebx, DWORD PTR _pszSQL$[esp+12]
  0004a	51		 push	 ecx
  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GI@EMHCMEPI@UPDATE?5GUILD_TBL?5SET?5m_nGuildGol@
  00052	53		 push	 ebx
  00053	e8 00 00 00 00	 call	 _sprintf

; 428  : 		FILEOUT( "..\\RemoveItem.log", "GuildId = %d, Item0 = %d, Item1 = %d, AddGold = %d", nGuildId,  nCountItem0, nCountItem1, dwAddGold );

  00058	8b 54 24 38	 mov	 edx, DWORD PTR _nCountItem0$[esp+32]
  0005c	56		 push	 esi
  0005d	55		 push	 ebp
  0005e	52		 push	 edx
  0005f	57		 push	 edi
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@ICGMIJIF@GuildId?5?$DN?5?$CFd?0?5Item0?5?$DN?5?$CFd?0?5Item1?5@
  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@
  0006a	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT

; 429  : 		
; 430  : 		if( FALSE == pQuerySave->Exec( pszSQL ) )

  0006f	8b 74 24 4c	 mov	 esi, DWORD PTR _pQuerySave$[esp+56]
  00073	83 c4 2c	 add	 esp, 44			; 0000002cH
  00076	53		 push	 ebx
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  0007e	85 c0		 test	 eax, eax
  00080	5d		 pop	 ebp
  00081	75 3e		 jne	 SHORT $L204833

; 431  : 		{
; 432  : 			SAFE_DELETE( pQueryChar );

  00083	8b 7c 24 18	 mov	 edi, DWORD PTR _pQueryChar$[esp+8]
  00087	85 ff		 test	 edi, edi
  00089	74 10		 je	 SHORT $L206986
  0008b	8b cf		 mov	 ecx, edi
  0008d	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  00092	57		 push	 edi
  00093	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00098	83 c4 04	 add	 esp, 4
$L206986:

; 433  : 			SAFE_DELETE( pQuerySave );

  0009b	85 f6		 test	 esi, esi
  0009d	74 10		 je	 SHORT $L206990
  0009f	8b ce		 mov	 ecx, esi
  000a1	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  000a6	56		 push	 esi
  000a7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ac	83 c4 04	 add	 esp, 4
$L206990:

; 434  : 			AfxMessageBox( pszSQL, MB_OK );

  000af	6a 00		 push	 0
  000b1	6a 00		 push	 0
  000b3	53		 push	 ebx
  000b4	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi

; 435  : 			return FALSE;

  000bb	33 c0		 xor	 eax, eax
  000bd	5b		 pop	 ebx

; 439  : }

  000be	c2 18 00	 ret	 24			; 00000018H
$L204833:
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi

; 436  : 		}
; 437  : 	}
; 438  : 	return TRUE;

  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	5b		 pop	 ebx

; 439  : }

  000c9	c2 18 00	 ret	 24			; 00000018H
?RemoveGuildBankListPanya@CDbManager@@QAEHPADHPAVCQuery@@1HH@Z ENDP ; CDbManager::RemoveGuildBankListPanya
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 304  : 		iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00008	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1412 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 1413 : 		if (_Mysize < _Off)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Off$[esp+4]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000c	73 05		 jae	 SHORT $L205398

; 1414 : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L205398:

; 1415 : 		if (_Mysize - _Off < _N0)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 54 24 14	 mov	 edx, DWORD PTR __N0$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c2		 cmp	 eax, edx
  0001e	73 02		 jae	 SHORT $L205399

; 1416 : 			_N0 = _Mysize - _Off;	// trim _N0 to size

  00020	8b d0		 mov	 edx, eax
$L205399:

; 1417 : 
; 1418 : 		size_type _Ans = _N0 == 0 ? 0
; 1419 : 			: _Traits::compare(_Myptr() + _Off, _Ptr,
; 1420 : 				_N0 < _Count ? _N0 : _Count);

  00022	85 d2		 test	 edx, edx
  00024	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Count$[esp+8]
  00028	74 2e		 je	 SHORT $L207039
  0002a	3b d3		 cmp	 edx, ebx
  0002c	8b ca		 mov	 ecx, edx
  0002e	72 02		 jb	 SHORT $L207019
  00030	8b cb		 mov	 ecx, ebx
$L207019:
  00032	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00036	72 05		 jb	 SHORT $L207031
  00038	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003b	eb 03		 jmp	 SHORT $L207032
$L207031:
  0003d	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L207032:
  00040	57		 push	 edi
  00041	8b 7c 24 1c	 mov	 edi, DWORD PTR __Ptr$[esp+12]
  00045	8d 34 28	 lea	 esi, DWORD PTR [eax+ebp]
  00048	33 c0		 xor	 eax, eax
  0004a	f3 a6		 repe cmpsb
  0004c	5f		 pop	 edi
  0004d	74 05		 je	 SHORT $L207038
  0004f	1b c0		 sbb	 eax, eax
  00051	83 d8 ff	 sbb	 eax, -1
$L207038:

; 1421 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1422 : 			: _N0 == _Count ? 0 : +1);

  00054	85 c0		 test	 eax, eax
  00056	75 14		 jne	 SHORT $L207023
$L207039:
  00058	3b d3		 cmp	 edx, ebx
  0005a	73 09		 jae	 SHORT $L207022
  0005c	5e		 pop	 esi
  0005d	5d		 pop	 ebp
  0005e	83 c8 ff	 or	 eax, -1
  00061	5b		 pop	 ebx

; 1423 : 		}

  00062	c2 10 00	 ret	 16			; 00000010H
$L207022:

; 1421 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1422 : 			: _N0 == _Count ? 0 : +1);

  00065	33 c0		 xor	 eax, eax
  00067	3b d3		 cmp	 edx, ebx
  00069	0f 95 c0	 setne	 al
$L207023:
  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	5b		 pop	 ebx

; 1423 : 		}

  0006f	c2 10 00	 ret	 16			; 00000010H
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Lmost
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 29	 mov	 dl, BYTE PTR [eax+41]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L205700

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 29	 mov	 bl, BYTE PTR [edx+41]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L207101

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 29	 mov	 bl, BYTE PTR [eax+41]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L207089
  0001d	8d 49 00	 npad	 3
$L207088:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 29	 mov	 bl, BYTE PTR [eax+41]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L207088
$L207089:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L207101:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 29	 mov	 dl, BYTE PTR [eax+41]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L205704
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L205703:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L205704

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 29	 mov	 dl, BYTE PTR [eax+41]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L205703
$L205704:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L205700:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwObjId$ = 8						; size = 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtId, COMDAT
; _this$ = ecx

; 663  : 	if( dwObjId >= m_dwItemMax )	return NULL;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwObjId$[esp-4]
  00004	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00007	72 05		 jb	 SHORT $L205768
  00009	33 c0		 xor	 eax, eax

; 666  : 		return NULL;
; 667  : 	return pItemElem;
; 668  : }

  0000b	c2 04 00	 ret	 4
$L205768:

; 664  : 	T* pItemElem	= &m_apItem[dwObjId];

  0000e	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	c1 e2 05	 shl	 edx, 5
  00017	03 d0		 add	 edx, eax

; 665  : 	if( pItemElem->IsEmpty() )

  00019	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001c	f7 d8		 neg	 eax
  0001e	1b c0		 sbb	 eax, eax
  00020	23 c2		 and	 eax, edx

; 666  : 		return NULL;
; 667  : 	return pItemElem;
; 668  : }

  00022	c2 04 00	 ret	 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAtId
_TEXT	ENDS
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetItemProp
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\databaseserver\project.h
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 200  : 	ItemProp*	GetItemProp( int nIndex )	{	return m_aPropItem.GetAt( nIndex );	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00007	72 05		 jb	 SHORT $L207115
  00009	33 c0		 xor	 eax, eax
  0000b	c2 04 00	 ret	 4
$L207115:
  0000e	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00014	c2 04 00	 ret	 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ENDP		; CProject::GetItemProp
_TEXT	ENDS
PUBLIC	??3CMover@@SAXPAX@Z				; CMover::operator delete
EXTRN	?m_pPool@CMover@@2PAV?$MemPooler@VCMover@@@@A:DWORD ; CMover::m_pPool
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ??3CMover@@SAXPAX@Z
_TEXT	SEGMENT
_lpMem$ = 8						; size = 4
??3CMover@@SAXPAX@Z PROC NEAR				; CMover::operator delete, COMDAT

; 1219 : 	void	operator delete( void* lpMem )	{	CMover::m_pPool->Free( (CMover*)lpMem );	}

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?m_pPool@CMover@@2PAV?$MemPooler@VCMover@@@@A ; CMover::m_pPool
  00008	57		 push	 edi
  00009	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
  0000c	53		 push	 ebx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00013	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00016	85 c9		 test	 ecx, ecx
  00018	8b 7c 24 10	 mov	 edi, DWORD PTR _lpMem$[esp+8]
  0001c	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0001f	7e 09		 jle	 SHORT $L207124
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	89 06		 mov	 DWORD PTR [esi], eax
  00027	ff 4e 18	 dec	 DWORD PTR [esi+24]
$L207124:
  0002a	33 c0		 xor	 eax, eax
  0002c	b9 c2 11 00 00	 mov	 ecx, 4546		; 000011c2H
  00031	53		 push	 ebx
  00032	f3 ab		 rep stosd
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c3		 ret	 0
??3CMover@@SAXPAX@Z ENDP				; CMover::operator delete
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1094 : 		return (_Myptr());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L207133
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1095 : 		}

  00009	c3		 ret	 0

; 1094 : 		return (_Myptr());

$L207133:
  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1095 : 		}

  0000d	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 35   : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@KAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00008	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000b	72 0a		 jb	 SHORT $L207175
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1476 : 		}

  00014	c2 04 00	 ret	 4

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$L207175:
  00017	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 1476 : 		}

  0001c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1116 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 138  : 		}

  0000d	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z ; std::list<void *,std::allocator<void *> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 236  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$list@PAXV?$allocator@PAX@std@@@std@@QAE@PAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@@Z ENDP ; std::list<void *,std::allocator<void *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?max_size@?$list@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::list<void *,std::allocator<void *> >::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$list@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC NEAR ; std::list<void *,std::allocator<void *> >::max_size, COMDAT
; _this$ = ecx

; 436  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 437  : 		}

  00005	c3		 ret	 0
?max_size@?$list@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::list<void *,std::allocator<void *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z ; std::allocator<std::_List_nod<void *,std::allocator<void *> >::_Node>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<void *,std::allocator<void *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<void *,std::allocator<void *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??_C@_0DH@GNEHNCOD@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@ ; `string'
PUBLIC	??_C@_0CB@CKGEIIKM@?4?4?2RemoveItemPiercingConfirm?4log@ ; `string'
PUBLIC	?PiercingConfirmInventoryBank@CDbManager@@QAEHPAVCMover@@@Z ; CDbManager::PiercingConfirmInventoryBank
;	COMDAT ??_C@_0DH@GNEHNCOD@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_C@_0DH@GNEHNCOD@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@ DB 'I'
	DB	'dPlayer = %07d, ItemName : %s %d/%d/%d %d/%d/%d/%d/%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CKGEIIKM@?4?4?2RemoveItemPiercingConfirm?4log@
CONST	SEGMENT
??_C@_0CB@CKGEIIKM@?4?4?2RemoveItemPiercingConfirm?4log@ DB '..\RemoveIte'
	DB	'mPiercingConfirm.log', 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
CONST	ENDS
;	COMDAT ?PiercingConfirmInventoryBank@CDbManager@@QAEHPAVCMover@@@Z
_TEXT	SEGMENT
_i$205046 = -24						; size = 4
tv553 = -20						; size = 4
tv543 = -20						; size = 4
_nSize$205044 = -16					; size = 4
$T207295 = -12						; size = 4
$T207264 = -12						; size = 4
$T207320 = -8						; size = 4
$T207268 = -8						; size = 4
$T207316 = -4						; size = 4
$T207243 = -4						; size = 4
_pMover$ = 8						; size = 4
?PiercingConfirmInventoryBank@CDbManager@@QAEHPAVCMover@@@Z PROC NEAR ; CDbManager::PiercingConfirmInventoryBank, COMDAT
; _this$ = ecx

; 603  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 604  : 	BOOL bUpdate = FALSE;
; 605  : 	if( prj.IsConvMode( PIERCING_CONFIRM ) )	

  00005	6a 10		 push	 16			; 00000010H
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000c	33 ed		 xor	 ebp, ebp
  0000e	33 db		 xor	 ebx, ebx
  00010	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00015	85 c0		 test	 eax, eax
  00017	0f 84 88 02 00
	00		 je	 $L207334

; 606  : 	{
; 607  : 		// Inventory
; 608  : 		int	nSize	= pMover->m_Inventory.m_dwItemMax;

  0001d	8b 44 24 24	 mov	 eax, DWORD PTR _pMover$[esp+28]
  00021	8b 80 24 41 00
	00		 mov	 eax, DWORD PTR [eax+16676]

; 609  : 		CItemElem* pItemElem;
; 610  : 		for( int i = 0 ; i < nSize; i++ )

  00027	3b c5		 cmp	 eax, ebp
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	89 44 24 18	 mov	 DWORD PTR _nSize$205044[esp+40], eax
  0002f	89 6c 24 10	 mov	 DWORD PTR _i$205046[esp+40], ebp
  00033	0f 8e 20 01 00
	00		 jle	 $L207336

; 606  : 	{
; 607  : 		// Inventory
; 608  : 		int	nSize	= pMover->m_Inventory.m_dwItemMax;

  00039	89 6c 24 14	 mov	 DWORD PTR tv543[esp+40], ebp
  0003d	8d 49 00	 npad	 3
$L207338:

; 611  : 		{
; 612  : 			pItemElem	= pMover->m_Inventory.GetAtId( i );

  00040	8b 44 24 2c	 mov	 eax, DWORD PTR _pMover$[esp+36]
  00044	8b 88 24 41 00
	00		 mov	 ecx, DWORD PTR [eax+16676]
  0004a	05 14 41 00 00	 add	 eax, 16660		; 00004114H
  0004f	3b e9		 cmp	 ebp, ecx
  00051	0f 83 e3 00 00
	00		 jae	 $L205048
  00057	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0005a	8b 54 24 14	 mov	 edx, DWORD PTR tv543[esp+40]
  0005e	8b 44 17 08	 mov	 eax, DWORD PTR [edi+edx+8]
  00062	03 fa		 add	 edi, edx
  00064	85 c0		 test	 eax, eax
  00066	0f 84 ce 00 00
	00		 je	 $L205048

; 613  : 			if( pItemElem )
; 614  : 			{
; 615  : 				ItemProp* pGetItemProp		= prj.GetItemProp( pItemElem->m_dwItemId );	

  0006c	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  00072	0f 83 c2 00 00
	00		 jae	 $L205048
  00078	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+64
  0007e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 616  : 				if( pGetItemProp && pGetItemProp->dwItemKind3 != IK3_SUIT && pItemElem->GetPiercingSize() != 0 )

  00081	85 c0		 test	 eax, eax
  00083	89 44 24 24	 mov	 DWORD PTR $T207243[esp+40], eax
  00087	0f 84 ad 00 00
	00		 je	 $L205048
  0008d	83 78 78 12	 cmp	 DWORD PTR [eax+120], 18	; 00000012H
  00091	0f 84 a3 00 00
	00		 je	 $L205048
  00097	8d 77 34	 lea	 esi, DWORD PTR [edi+52]
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000a1	85 c0		 test	 eax, eax
  000a3	0f 84 91 00 00
	00		 je	 $L205048

; 617  : 				{
; 618  : 					FILEOUT( "..\\RemoveItemPiercingConfirm.log", "IdPlayer = %07d, ItemName : %s %d/%d/%d %d/%d/%d/%d/%d", 
; 619  : 						pMover->m_idPlayer,  pGetItemProp->szName, pItemElem->GetOption(), pItemElem->m_bItemResist, pItemElem->m_nResistAbilityOption, pItemElem->GetPiercingSize(), pItemElem->GetPiercingItem( 0 ), pItemElem->GetPiercingItem( 1 ), pItemElem->GetPiercingItem( 2 ), pItemElem->GetPiercingItem( 3 ) );

  000a9	6a 03		 push	 3
  000ab	8b ce		 mov	 ecx, esi
  000ad	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000b2	6a 02		 push	 2
  000b4	8b ce		 mov	 ecx, esi
  000b6	8b d8		 mov	 ebx, eax
  000b8	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000bd	6a 01		 push	 1
  000bf	8b ce		 mov	 ecx, esi
  000c1	8b e8		 mov	 ebp, eax
  000c3	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000c8	6a 00		 push	 0
  000ca	8b ce		 mov	 ecx, esi
  000cc	89 44 24 20	 mov	 DWORD PTR $T207264[esp+44], eax
  000d0	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000d5	8b ce		 mov	 ecx, esi
  000d7	89 44 24 20	 mov	 DWORD PTR $T207268[esp+40], eax
  000db	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000e0	8b 54 24 1c	 mov	 edx, DWORD PTR $T207264[esp+40]
  000e4	8b 4c 24 20	 mov	 ecx, DWORD PTR $T207268[esp+40]
  000e8	8b 74 24 2c	 mov	 esi, DWORD PTR _pMover$[esp+36]
  000ec	53		 push	 ebx
  000ed	55		 push	 ebp
  000ee	52		 push	 edx
  000ef	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000f5	51		 push	 ecx
  000f6	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  000f9	50		 push	 eax
  000fa	0f b6 47 7c	 movzx	 eax, BYTE PTR [edi+124]
  000fe	52		 push	 edx
  000ff	8b 54 24 3c	 mov	 edx, DWORD PTR $T207243[esp+64]
  00103	50		 push	 eax
  00104	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  0010a	51		 push	 ecx
  0010b	83 c2 04	 add	 edx, 4
  0010e	52		 push	 edx
  0010f	50		 push	 eax
  00110	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@GNEHNCOD@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
  00115	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CKGEIIKM@?4?4?2RemoveItemPiercingConfirm?4log@
  0011a	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT

; 620  : 					pMover->m_Inventory.RemoveAtId( pItemElem->m_dwObjId );

  0011f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00122	83 c4 30	 add	 esp, 48			; 00000030H
  00125	51		 push	 ecx
  00126	8d 8e 14 41 00
	00		 lea	 ecx, DWORD PTR [esi+16660]
  0012c	e8 00 00 00 00	 call	 ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAtId

; 621  : 					bUpdate = TRUE;

  00131	8b 6c 24 10	 mov	 ebp, DWORD PTR _i$205046[esp+40]
  00135	bb 01 00 00 00	 mov	 ebx, 1
$L205048:
  0013a	8b 4c 24 14	 mov	 ecx, DWORD PTR tv543[esp+40]
  0013e	8b 44 24 18	 mov	 eax, DWORD PTR _nSize$205044[esp+40]
  00142	45		 inc	 ebp
  00143	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00149	3b e8		 cmp	 ebp, eax
  0014b	89 6c 24 10	 mov	 DWORD PTR _i$205046[esp+40], ebp
  0014f	89 4c 24 14	 mov	 DWORD PTR tv543[esp+40], ecx
  00153	0f 8c e7 fe ff
	ff		 jl	 $L207338
$L207336:

; 622  : 				}
; 623  : 			}
; 624  : 		}
; 625  : 		// Bank
; 626  : 		nSize	= pMover->m_Bank[0].m_dwItemMax;

  00159	8b 54 24 2c	 mov	 edx, DWORD PTR _pMover$[esp+36]
  0015d	8b 82 a4 41 00
	00		 mov	 eax, DWORD PTR [edx+16804]

; 627  : 		for( i = 0 ; i < nSize; i++ )

  00163	33 ed		 xor	 ebp, ebp
  00165	3b c5		 cmp	 eax, ebp
  00167	89 44 24 18	 mov	 DWORD PTR _nSize$205044[esp+40], eax
  0016b	89 6c 24 10	 mov	 DWORD PTR _i$205046[esp+40], ebp
  0016f	0f 8e 24 01 00
	00		 jle	 $L207333

; 622  : 				}
; 623  : 			}
; 624  : 		}
; 625  : 		// Bank
; 626  : 		nSize	= pMover->m_Bank[0].m_dwItemMax;

  00175	89 6c 24 14	 mov	 DWORD PTR tv553[esp+40], ebp
  00179	8d a4 24 00 00
	00 00		 npad	 7
$L207339:

; 628  : 		{
; 629  : 			pItemElem	= pMover->m_Bank[0].GetAtId( i );

  00180	8b 44 24 2c	 mov	 eax, DWORD PTR _pMover$[esp+36]
  00184	8b 88 a4 41 00
	00		 mov	 ecx, DWORD PTR [eax+16804]
  0018a	05 94 41 00 00	 add	 eax, 16788		; 00004194H
  0018f	3b e9		 cmp	 ebp, ecx
  00191	0f 83 e3 00 00
	00		 jae	 $L205056
  00197	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0019a	8b 54 24 14	 mov	 edx, DWORD PTR tv553[esp+40]
  0019e	8b 44 17 08	 mov	 eax, DWORD PTR [edi+edx+8]
  001a2	03 fa		 add	 edi, edx
  001a4	85 c0		 test	 eax, eax
  001a6	0f 84 ce 00 00
	00		 je	 $L205056

; 630  : 			if( pItemElem )
; 631  : 			{
; 632  : 				ItemProp* pGetItemProp		= prj.GetItemProp( pItemElem->m_dwItemId );	

  001ac	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  001b2	0f 83 c2 00 00
	00		 jae	 $L205056
  001b8	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+64
  001be	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 633  : 				if( pGetItemProp && pGetItemProp->dwItemKind3 != IK3_SUIT && pItemElem->GetPiercingSize() != 0 )

  001c1	85 c0		 test	 eax, eax
  001c3	89 44 24 1c	 mov	 DWORD PTR $T207295[esp+40], eax
  001c7	0f 84 ad 00 00
	00		 je	 $L205056
  001cd	83 78 78 12	 cmp	 DWORD PTR [eax+120], 18	; 00000012H
  001d1	0f 84 a3 00 00
	00		 je	 $L205056
  001d7	8d 77 34	 lea	 esi, DWORD PTR [edi+52]
  001da	8b ce		 mov	 ecx, esi
  001dc	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  001e1	85 c0		 test	 eax, eax
  001e3	0f 84 91 00 00
	00		 je	 $L205056

; 634  : 				{
; 635  : 					FILEOUT( "..\\RemoveItemPiercingConfirm.log", "IdPlayer = %07d, ItemName : %s %d/%d/%d %d/%d/%d/%d/%d", 
; 636  : 						pMover->m_idPlayer,  pGetItemProp->szName, pItemElem->GetOption(), pItemElem->m_bItemResist, pItemElem->m_nResistAbilityOption, pItemElem->GetPiercingSize(), pItemElem->GetPiercingItem( 0 ), pItemElem->GetPiercingItem( 1 ), pItemElem->GetPiercingItem( 2 ), pItemElem->GetPiercingItem( 3 ) );

  001e9	6a 03		 push	 3
  001eb	8b ce		 mov	 ecx, esi
  001ed	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  001f2	6a 02		 push	 2
  001f4	8b ce		 mov	 ecx, esi
  001f6	8b d8		 mov	 ebx, eax
  001f8	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  001fd	6a 01		 push	 1
  001ff	8b ce		 mov	 ecx, esi
  00201	8b e8		 mov	 ebp, eax
  00203	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  00208	6a 00		 push	 0
  0020a	8b ce		 mov	 ecx, esi
  0020c	89 44 24 28	 mov	 DWORD PTR $T207316[esp+44], eax
  00210	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  00215	8b ce		 mov	 ecx, esi
  00217	89 44 24 20	 mov	 DWORD PTR $T207320[esp+40], eax
  0021b	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00220	8b 54 24 24	 mov	 edx, DWORD PTR $T207316[esp+40]
  00224	8b 4c 24 20	 mov	 ecx, DWORD PTR $T207320[esp+40]
  00228	8b 74 24 2c	 mov	 esi, DWORD PTR _pMover$[esp+36]
  0022c	53		 push	 ebx
  0022d	55		 push	 ebp
  0022e	52		 push	 edx
  0022f	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  00235	51		 push	 ecx
  00236	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00239	50		 push	 eax
  0023a	0f b6 47 7c	 movzx	 eax, BYTE PTR [edi+124]
  0023e	52		 push	 edx
  0023f	8b 54 24 34	 mov	 edx, DWORD PTR $T207295[esp+64]
  00243	50		 push	 eax
  00244	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  0024a	51		 push	 ecx
  0024b	83 c2 04	 add	 edx, 4
  0024e	52		 push	 edx
  0024f	50		 push	 eax
  00250	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@GNEHNCOD@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
  00255	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CKGEIIKM@?4?4?2RemoveItemPiercingConfirm?4log@
  0025a	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT

; 637  : 					pMover->m_Bank[0].RemoveAtId( pItemElem->m_dwObjId );

  0025f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00262	83 c4 30	 add	 esp, 48			; 00000030H
  00265	51		 push	 ecx
  00266	8d 8e 94 41 00
	00		 lea	 ecx, DWORD PTR [esi+16788]
  0026c	e8 00 00 00 00	 call	 ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAtId

; 638  : 					bUpdate = TRUE;

  00271	8b 6c 24 10	 mov	 ebp, DWORD PTR _i$205046[esp+40]
  00275	bb 01 00 00 00	 mov	 ebx, 1
$L205056:
  0027a	8b 4c 24 14	 mov	 ecx, DWORD PTR tv553[esp+40]
  0027e	8b 44 24 18	 mov	 eax, DWORD PTR _nSize$205044[esp+40]
  00282	45		 inc	 ebp
  00283	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00289	3b e8		 cmp	 ebp, eax
  0028b	89 6c 24 10	 mov	 DWORD PTR _i$205046[esp+40], ebp
  0028f	89 4c 24 14	 mov	 DWORD PTR tv553[esp+40], ecx
  00293	0f 8c e7 fe ff
	ff		 jl	 $L207339
$L207333:
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5d		 pop	 ebp

; 639  : 				}
; 640  : 			}
; 641  : 		}
; 642  : 	}
; 643  : 	return bUpdate;

  0029c	8b c3		 mov	 eax, ebx
  0029e	5b		 pop	 ebx

; 644  : }

  0029f	83 c4 18	 add	 esp, 24			; 00000018H
  002a2	c2 04 00	 ret	 4
$L207334:
  002a5	5d		 pop	 ebp

; 639  : 				}
; 640  : 			}
; 641  : 		}
; 642  : 	}
; 643  : 	return bUpdate;

  002a6	8b c3		 mov	 eax, ebx
  002a8	5b		 pop	 ebx

; 644  : }

  002a9	83 c4 18	 add	 esp, 24			; 00000018H
  002ac	c2 04 00	 ret	 4
?PiercingConfirmInventoryBank@CDbManager@@QAEHPAVCMover@@@Z ENDP ; CDbManager::PiercingConfirmInventoryBank
_TEXT	ENDS
PUBLIC	??_C@_0DH@HKBGNFHB@nGuildId?5?$DN?5?$CF06d?0?5ItemName?5?3?5?$CFs?5?$CF@ ; `string'
PUBLIC	?PiercingConfirmGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@@Z ; CDbManager::PiercingConfirmGuildBank
;	COMDAT ??_C@_0DH@HKBGNFHB@nGuildId?5?$DN?5?$CF06d?0?5ItemName?5?3?5?$CFs?5?$CF@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
CONST	SEGMENT
??_C@_0DH@HKBGNFHB@nGuildId?5?$DN?5?$CF06d?0?5ItemName?5?3?5?$CFs?5?$CF@ DB 'n'
	DB	'GuildId = %06d, ItemName : %s %d/%d/%d %d/%d/%d/%d/%d', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
CONST	ENDS
;	COMDAT ?PiercingConfirmGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@@Z
_TEXT	SEGMENT
tv329 = -24						; size = 4
_i$205071 = -20						; size = 4
$T207382 = -16						; size = 4
$T207386 = -12						; size = 4
$T207361 = -8						; size = 4
_nSize$205069 = -4					; size = 4
_nGuildId$ = 8						; size = 4
_GuildBank$ = 12					; size = 4
?PiercingConfirmGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@@Z PROC NEAR ; CDbManager::PiercingConfirmGuildBank, COMDAT
; _this$ = ecx

; 647  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 648  : 	BOOL bUpdate = FALSE;
; 649  : 	if( prj.IsConvMode( PIERCING_CONFIRM ) )	

  00005	6a 10		 push	 16			; 00000010H
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000c	33 ed		 xor	 ebp, ebp
  0000e	33 db		 xor	 ebx, ebx
  00010	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00015	85 c0		 test	 eax, eax
  00017	0f 84 28 01 00
	00		 je	 $L207398

; 650  : 	{
; 651  : 		int	nSize	= GuildBank->m_dwItemMax;

  0001d	8b 44 24 28	 mov	 eax, DWORD PTR _GuildBank$[esp+28]
  00021	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 652  : 		CItemElem* pItemElem;
; 653  : 		for( int i = 0 ; i < nSize; i++ )

  00024	3b cd		 cmp	 ecx, ebp
  00026	89 4c 24 1c	 mov	 DWORD PTR _nSize$205069[esp+32], ecx
  0002a	89 6c 24 0c	 mov	 DWORD PTR _i$205071[esp+32], ebp
  0002e	0f 8e 11 01 00
	00		 jle	 $L207398
  00034	56		 push	 esi
  00035	57		 push	 edi
  00036	89 6c 24 10	 mov	 DWORD PTR tv329[esp+40], ebp
  0003a	eb 04		 jmp	 SHORT $L205072
$L207400:

; 650  : 	{
; 651  : 		int	nSize	= GuildBank->m_dwItemMax;

  0003c	8b 44 24 30	 mov	 eax, DWORD PTR _GuildBank$[esp+36]
$L205072:

; 654  : 		{
; 655  : 			pItemElem	= GuildBank->GetAtId( i );

  00040	3b 68 10	 cmp	 ebp, DWORD PTR [eax+16]
  00043	0f 83 db 00 00
	00		 jae	 $L205073
  00049	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0004c	8b 54 24 10	 mov	 edx, DWORD PTR tv329[esp+40]
  00050	8b 44 17 08	 mov	 eax, DWORD PTR [edi+edx+8]
  00054	03 fa		 add	 edi, edx
  00056	85 c0		 test	 eax, eax
  00058	0f 84 c6 00 00
	00		 je	 $L205073

; 656  : 			if( pItemElem )
; 657  : 			{
; 658  : 				ItemProp* pGetItemProp		= prj.GetItemProp( pItemElem->m_dwItemId );	

  0005e	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  00064	0f 83 ba 00 00
	00		 jae	 $L205073
  0006a	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+64
  00070	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 659  : 				if( pGetItemProp && pGetItemProp->dwItemKind3 != IK3_SUIT && pItemElem->GetPiercingSize() != 0 )

  00073	85 c0		 test	 eax, eax
  00075	89 44 24 20	 mov	 DWORD PTR $T207361[esp+40], eax
  00079	0f 84 a5 00 00
	00		 je	 $L205073
  0007f	83 78 78 12	 cmp	 DWORD PTR [eax+120], 18	; 00000012H
  00083	0f 84 9b 00 00
	00		 je	 $L205073
  00089	8d 77 34	 lea	 esi, DWORD PTR [edi+52]
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00093	85 c0		 test	 eax, eax
  00095	0f 84 89 00 00
	00		 je	 $L205073

; 660  : 				{
; 661  : 					FILEOUT( "..\\RemoveItemPiercingConfirm.log", "nGuildId = %06d, ItemName : %s %d/%d/%d %d/%d/%d/%d/%d", 
; 662  : 						nGuildId,  pGetItemProp->szName, pItemElem->GetOption(), pItemElem->m_bItemResist, pItemElem->m_nResistAbilityOption, pItemElem->GetPiercingSize(), pItemElem->GetPiercingItem( 0 ), pItemElem->GetPiercingItem( 1 ), pItemElem->GetPiercingItem( 2 ), pItemElem->GetPiercingItem( 3 ) );

  0009b	6a 03		 push	 3
  0009d	8b ce		 mov	 ecx, esi
  0009f	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000a4	6a 02		 push	 2
  000a6	8b ce		 mov	 ecx, esi
  000a8	8b d8		 mov	 ebx, eax
  000aa	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000af	6a 01		 push	 1
  000b1	8b ce		 mov	 ecx, esi
  000b3	8b e8		 mov	 ebp, eax
  000b5	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000ba	6a 00		 push	 0
  000bc	8b ce		 mov	 ecx, esi
  000be	89 44 24 1c	 mov	 DWORD PTR $T207382[esp+44], eax
  000c2	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000c7	8b ce		 mov	 ecx, esi
  000c9	89 44 24 1c	 mov	 DWORD PTR $T207386[esp+40], eax
  000cd	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000d2	8b 54 24 18	 mov	 edx, DWORD PTR $T207382[esp+40]
  000d6	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T207386[esp+40]
  000da	53		 push	 ebx
  000db	55		 push	 ebp
  000dc	52		 push	 edx
  000dd	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000e3	51		 push	 ecx
  000e4	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  000e7	50		 push	 eax
  000e8	0f b6 47 7c	 movzx	 eax, BYTE PTR [edi+124]
  000ec	52		 push	 edx
  000ed	8b 54 24 38	 mov	 edx, DWORD PTR $T207361[esp+64]
  000f1	50		 push	 eax
  000f2	8b 44 24 48	 mov	 eax, DWORD PTR _nGuildId$[esp+64]
  000f6	51		 push	 ecx
  000f7	83 c2 04	 add	 edx, 4
  000fa	52		 push	 edx
  000fb	50		 push	 eax
  000fc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@HKBGNFHB@nGuildId?5?$DN?5?$CF06d?0?5ItemName?5?3?5?$CFs?5?$CF@
  00101	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@CKGEIIKM@?4?4?2RemoveItemPiercingConfirm?4log@
  00106	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT

; 663  : 					GuildBank->RemoveAtId( pItemElem->m_dwObjId );

  0010b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0010e	83 c4 30	 add	 esp, 48			; 00000030H
  00111	51		 push	 ecx
  00112	8b 4c 24 34	 mov	 ecx, DWORD PTR _GuildBank$[esp+40]
  00116	e8 00 00 00 00	 call	 ?RemoveAtId@?$CItemContainer@VCItemElem@@@@QAEXK@Z ; CItemContainer<CItemElem>::RemoveAtId

; 664  : 					bUpdate = TRUE;

  0011b	8b 6c 24 14	 mov	 ebp, DWORD PTR _i$205071[esp+40]
  0011f	bb 01 00 00 00	 mov	 ebx, 1
$L205073:
  00124	8b 4c 24 10	 mov	 ecx, DWORD PTR tv329[esp+40]
  00128	8b 44 24 24	 mov	 eax, DWORD PTR _nSize$205069[esp+40]
  0012c	45		 inc	 ebp
  0012d	81 c1 a0 00 00
	00		 add	 ecx, 160		; 000000a0H
  00133	3b e8		 cmp	 ebp, eax
  00135	89 6c 24 14	 mov	 DWORD PTR _i$205071[esp+40], ebp
  00139	89 4c 24 10	 mov	 DWORD PTR tv329[esp+40], ecx
  0013d	0f 8c f9 fe ff
	ff		 jl	 $L207400
  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
$L207398:
  00145	5d		 pop	 ebp

; 665  : 				}
; 666  : 			}
; 667  : 		}
; 668  : 	}
; 669  : 	return bUpdate;

  00146	8b c3		 mov	 eax, ebx
  00148	5b		 pop	 ebx

; 670  : }

  00149	83 c4 18	 add	 esp, 24			; 00000018H
  0014c	c2 08 00	 ret	 8
?PiercingConfirmGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@@Z ENDP ; CDbManager::PiercingConfirmGuildBank
_TEXT	ENDS
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 1099 : 		return (c_str());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L207414
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1100 : 		}

  00009	c3		 ret	 0

; 1099 : 		return (c_str());

$L207414:
  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1100 : 		}

  0000d	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Ogty
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1380 : 		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00007	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0000b	72 13		 jb	 SHORT $L207428
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	52		 push	 edx
  00011	50		 push	 eax
  00012	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00015	50		 push	 eax
  00016	6a 00		 push	 0
  00018	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 1381 : 		}

  0001d	c2 04 00	 ret	 4

; 1380 : 		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));

$L207428:
  00020	52		 push	 edx
  00021	83 c0 04	 add	 eax, 4
  00024	50		 push	 eax
  00025	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 1381 : 		}

  00030	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1510 : 		if (!_Built)

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Built$[esp-4]
  00004	84 c0		 test	 al, al
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Newsize$[esp+4]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	74 2f		 je	 SHORT $L207508

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00010	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00014	72 29		 jb	 SHORT $L207508

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;
; 1515 : 			if (0 < _Newsize)

  00016	85 ed		 test	 ebp, ebp
  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	57		 push	 edi
  0001c	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  0001f	76 14		 jbe	 SHORT $L207505
  00021	56		 push	 esi

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  00022	8b cd		 mov	 ecx, ebp
  00024	8b d1		 mov	 edx, ecx
  00026	c1 e9 02	 shr	 ecx, 2
  00029	8b f0		 mov	 esi, eax
  0002b	f3 a5		 rep movsd
  0002d	8b ca		 mov	 ecx, edx
  0002f	83 e1 03	 and	 ecx, 3
  00032	f3 a4		 rep movsb
  00034	5e		 pop	 esi
$L207505:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
  0003e	5f		 pop	 edi
$L207508:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;
; 1520 : 		_Eos(_Newsize);

  0003f	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00042	c7 43 18 0f 00
	00 00		 mov	 DWORD PTR [ebx+24], 15	; 0000000fH
  00049	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0004e	5d		 pop	 ebp
  0004f	5b		 pop	 ebx

; 1521 : 		}

  00050	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogty
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp

; 793  : 		if (_Mysize < _Off)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000b	57		 push	 edi
  0000c	73 05		 jae	 SHORT $L184993

; 794  : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L184993:

; 795  : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $L184994

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$L184994:

; 797  : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 47		 jbe	 SHORT $L207572

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002c	53		 push	 ebx
  0002d	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00030	72 04		 jb	 SHORT $L207537
  00032	8b 13		 mov	 edx, DWORD PTR [ebx]
  00034	eb 02		 jmp	 SHORT $L207538
$L207537:
  00036	8b d3		 mov	 edx, ebx
$L207538:
  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	72 04		 jb	 SHORT $L207545
  0003d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0003f	eb 02		 jmp	 SHORT $L207546
$L207545:
  00041	8b cb		 mov	 ecx, ebx
$L207546:
  00043	2b c7		 sub	 eax, edi

; 803  : 			}
; 804  : 		return (*this);

  00045	03 d5		 add	 edx, ebp
  00047	50		 push	 eax
  00048	03 d7		 add	 edx, edi
  0004a	52		 push	 edx
  0004b	03 cd		 add	 ecx, ebp
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _memmove
  00053	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00056	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00059	2b c7		 sub	 eax, edi
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00061	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00064	72 02		 jb	 SHORT $L207569

; 801  : 			size_type _Newsize = _Mysize - _Count;
; 802  : 			_Eos(_Newsize);

  00066	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$L207569:
  00068	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  0006c	5b		 pop	 ebx
$L207572:
  0006d	5f		 pop	 edi

; 803  : 			}
; 804  : 		return (*this);

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp

; 805  : 		}

  00072	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T207776 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T207778 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L207579
$T207779 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L207577
$T207777 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T207778
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T207779
$T207771 DD	019930520H
	DD	04H
	DD	FLAT:$T207776
	DD	02H
	DD	FLAT:$T207777
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b d8		 mov	 ebx, eax
  00022	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 1446 : 		if (max_size() < _Newres)

  00025	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00028	57		 push	 edi
  00029	8b f1		 mov	 esi, ecx
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00031	76 04		 jbe	 SHORT $L185550

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  00033	8b d8		 mov	 ebx, eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00035	eb 22		 jmp	 SHORT $L185552
$L185550:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00037	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  0003a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0003f	f7 e3		 mul	 ebx
  00041	8b cf		 mov	 ecx, edi
  00043	d1 e9		 shr	 ecx, 1
  00045	d1 ea		 shr	 edx, 1
  00047	3b d1		 cmp	 edx, ecx
  00049	73 0e		 jae	 SHORT $L185552
  0004b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00050	2b c1		 sub	 eax, ecx
  00052	3b f8		 cmp	 edi, eax
  00054	77 03		 ja	 SHORT $L185552

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00056	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
$L185552:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN
; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00059	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0005c	51		 push	 ecx
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00064	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00069	8b d0		 mov	 edx, eax
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
  00071	eb 29		 jmp	 SHORT $L185554
$L207577:

; 1455 : 		_CATCH_ALL
; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN
; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00079	40		 inc	 eax
  0007a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0007d	50		 push	 eax
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00087	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0008a	83 c4 04	 add	 esp, 4

; 1462 : 			_CATCH_END
; 1463 : 		_CATCH_END

  0008d	b8 00 00 00 00	 mov	 eax, $L207772
  00092	c3		 ret	 0
$L207772:
  00093	8b 5d e8	 mov	 ebx, DWORD PTR __Newres$[ebp]
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$L185554:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  0009f	85 c9		 test	 ecx, ecx
  000a1	76 24		 jbe	 SHORT $L207697

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000a3	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000a7	72 05		 jb	 SHORT $L207693
  000a9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000ac	eb 03		 jmp	 SHORT $L207694
$L207693:
  000ae	83 c6 04	 add	 esi, 4
$L207694:
  000b1	8b c1		 mov	 eax, ecx
  000b3	c1 e9 02	 shr	 ecx, 2
  000b6	8b fa		 mov	 edi, edx
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb
  000c1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
$L207697:

; 1467 : 		_Tidy(true);

  000c7	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000cb	72 12		 jb	 SHORT $L207738
  000cd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000dc	83 c4 04	 add	 esp, 4
$L207738:

; 1468 : 		_Bx._Ptr = _Ptr;
; 1469 : 		_Myres = _Newres;
; 1470 : 		_Eos(_Oldlen);

  000df	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000e5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e8	89 10		 mov	 DWORD PTR [eax], edx
  000ea	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000ed	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000f0	72 02		 jb	 SHORT $L207767
  000f2	8b c2		 mov	 eax, edx
$L207767:

; 1471 : 		}

  000f4	5f		 pop	 edi
  000f5	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fc	5e		 pop	 esi
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 08 00	 ret	 8
$L207579:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  0010b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0010e	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00112	72 0c		 jb	 SHORT $L207677
  00114	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011d	83 c4 04	 add	 esp, 4
$L207677:

; 1461 : 			_RERAISE;

  00120	6a 00		 push	 0
  00122	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00129	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00130	6a 00		 push	 0
  00132	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$L207775:
  0013b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T207771
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?end@?$list@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ; std::list<void *,std::allocator<void *> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?end@?$list@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<void *,std::allocator<void *> >::end, COMDAT
; _this$ = ecx

; 387  : 		return (iterator(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : 		}

  00009	c2 04 00	 ret	 4
?end@?$list@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<void *,std::allocator<void *> >::end
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z ; std::list<void *,std::allocator<void *> >::_Buynode
; Function compile flags: /Ogty
;	COMDAT ?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::_Buynode, COMDAT
; _this$ = ecx

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 919  : 		_TRY_BEGIN
; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

  0000a	85 c0		 test	 eax, eax
  0000c	74 16		 je	 SHORT $L207796
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Next$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Prev$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0001c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L207796:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);
; 923  : 		_RERAISE;
; 924  : 		_CATCH_END
; 925  : 		return (_Pnode);
; 926  : 		}

  00024	c2 0c 00	 ret	 12			; 0000000cH
?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z ENDP ; std::list<void *,std::allocator<void *> >::_Buynode
_TEXT	ENDS
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\string
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 132  : 	return (_Left.compare(_Right) < 0);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00008	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000b	72 05		 jb	 SHORT $L207841
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	eb 03		 jmp	 SHORT $L207842
$L207841:
  00012	83 c0 04	 add	 eax, 4
$L207842:
  00015	51		 push	 ecx
  00016	8b 4c 24 08	 mov	 ecx, DWORD PTR __Left$[esp]
  0001a	50		 push	 eax
  0001b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00026	33 c9		 xor	 ecx, ecx
  00028	85 c0		 test	 eax, eax
  0002a	0f 9c c1	 setl	 cl
  0002d	8a c1		 mov	 al, cl

; 133  : 	}

  0002f	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator->
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tset_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 457  : 		_Tidy(true);

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $L207897
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$L207897:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi

; 458  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC NEAR ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (_Left < _Right);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00008	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000b	72 05		 jb	 SHORT $L207946
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	eb 03		 jmp	 SHORT $L207947
$L207946:
  00012	83 c0 04	 add	 eax, 4
$L207947:
  00015	51		 push	 ecx
  00016	8b 4c 24 08	 mov	 ecx, DWORD PTR __Left$[esp]
  0001a	50		 push	 eax
  0001b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0001e	50		 push	 eax
  0001f	6a 00		 push	 0
  00021	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00026	33 c9		 xor	 ecx, ecx
  00028	85 c0		 test	 eax, eax
  0002a	0f 9c c1	 setl	 cl
  0002d	8a c1		 mov	 al, cl

; 140  : 		}

  0002f	c2 08 00	 ret	 8
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 1481 : 		if (max_size() < _Newsize)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR __Newsize$[esp+4]
  00006	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00009	8b e9		 mov	 ebp, ecx
  0000b	76 05		 jbe	 SHORT $L185002

; 1482 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L185002:

; 1483 : 		if (_Myres < _Newsize)

  00012	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00015	3b c6		 cmp	 eax, esi
  00017	73 19		 jae	 SHORT $L185003

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  00019	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	8b cd		 mov	 ecx, ebp
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  00025	33 c0		 xor	 eax, eax
  00027	3b c6		 cmp	 eax, esi
  00029	1b c0		 sbb	 eax, eax
  0002b	5e		 pop	 esi
  0002c	f7 d8		 neg	 eax
  0002e	5d		 pop	 ebp

; 1491 : 		}

  0002f	c2 08 00	 ret	 8
$L185003:

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00032	8a 4c 24 10	 mov	 cl, BYTE PTR __Trim$[esp+4]
  00036	84 c9		 test	 cl, cl
  00038	74 5c		 je	 SHORT $L185005
  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0003d	73 57		 jae	 SHORT $L185005
  0003f	53		 push	 ebx

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00040	8b 5d 14	 mov	 ebx, DWORD PTR [ebp+20]
  00043	3b f3		 cmp	 esi, ebx
  00045	73 02		 jae	 SHORT $L207953
  00047	8b de		 mov	 ebx, esi
$L207953:
  00049	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004c	72 2b		 jb	 SHORT $L208014
  0004e	85 db		 test	 ebx, ebx
  00050	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00053	57		 push	 edi
  00054	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  00057	76 16		 jbe	 SHORT $L208012
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b d1		 mov	 edx, ecx
  0005d	c1 e9 02	 shr	 ecx, 2
  00060	8b f0		 mov	 esi, eax
  00062	f3 a5		 rep movsd
  00064	8b ca		 mov	 ecx, edx
  00066	83 e1 03	 and	 ecx, 3
  00069	f3 a4		 rep movsb
  0006b	8b 74 24 14	 mov	 esi, DWORD PTR __Newsize$[esp+12]
$L208012:
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00075	83 c4 04	 add	 esp, 4
  00078	5f		 pop	 edi
$L208014:
  00079	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0007c	33 c0		 xor	 eax, eax
  0007e	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00085	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0008a	3b c6		 cmp	 eax, esi
  0008c	5b		 pop	 ebx
  0008d	1b c0		 sbb	 eax, eax
  0008f	5e		 pop	 esi
  00090	f7 d8		 neg	 eax
  00092	5d		 pop	 ebp

; 1491 : 		}

  00093	c2 08 00	 ret	 8
$L185005:

; 1488 : 		else if (_Newsize == 0)

  00096	85 f6		 test	 esi, esi
  00098	75 23		 jne	 SHORT $L208044

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  0009a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009d	89 75 14	 mov	 DWORD PTR [ebp+20], esi
  000a0	72 14		 jb	 SHORT $L208040
  000a2	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000a5	33 c0		 xor	 eax, eax
  000a7	3b c6		 cmp	 eax, esi
  000a9	1b c0		 sbb	 eax, eax
  000ab	5e		 pop	 esi
  000ac	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  000b0	f7 d8		 neg	 eax
  000b2	5d		 pop	 ebp

; 1491 : 		}

  000b3	c2 08 00	 ret	 8

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

$L208040:
  000b6	83 c5 04	 add	 ebp, 4
  000b9	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
$L208044:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000bd	33 c0		 xor	 eax, eax
  000bf	3b c6		 cmp	 eax, esi
  000c1	1b c0		 sbb	 eax, eax
  000c3	5e		 pop	 esi
  000c4	f7 d8		 neg	 eax
  000c6	5d		 pop	 ebp

; 1491 : 		}

  000c7	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
tv208 = -4						; size = 4
tv210 = 8						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 987  : 		{	// find leftmost node not less than _Keyval

  00000	83 ec 08	 sub	 esp, 8

; 988  : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	55		 push	 ebp
  00007	8b 68 04	 mov	 ebp, DWORD PTR [eax+4]

; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0000a	8a 4d 2d	 mov	 cl, BYTE PTR [ebp+45]
  0000d	84 c9		 test	 cl, cl
  0000f	89 44 24 04	 mov	 DWORD PTR __Wherenode$[esp+12], eax
  00013	0f 85 94 00 00
	00		 jne	 $L185107

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00019	8b 4c 24 10	 mov	 ecx, DWORD PTR __Keyval$[esp+8]
  0001d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00020	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00023	53		 push	 ebx
  00024	56		 push	 esi
  00025	83 c1 04	 add	 ecx, 4
  00028	57		 push	 edi
  00029	89 54 24 14	 mov	 DWORD PTR tv208[esp+24], edx
  0002d	89 4c 24 1c	 mov	 DWORD PTR tv210[esp+20], ecx
  00031	eb 0d		 jmp	 SHORT $L185106
$L208228:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

  00033	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv210[esp+20]
  00037	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L185106:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00040	8b 74 24 14	 mov	 esi, DWORD PTR tv208[esp+24]
  00044	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00049	3b f2		 cmp	 esi, edx
  0004b	72 04		 jb	 SHORT $L208194
  0004d	8b 39		 mov	 edi, DWORD PTR [ecx]
  0004f	eb 02		 jmp	 SHORT $L208195
$L208194:
  00051	8b f9		 mov	 edi, ecx
$L208195:
  00053	8b 5d 20	 mov	 ebx, DWORD PTR [ebp+32]
  00056	8b cb		 mov	 ecx, ebx
  00058	3b cb		 cmp	 ecx, ebx
  0005a	73 00		 jae	 SHORT $L208213
$L208213:
  0005c	85 db		 test	 ebx, ebx
  0005e	74 24		 je	 SHORT $L208227
  00060	3b d8		 cmp	 ebx, eax
  00062	8b cb		 mov	 ecx, ebx
  00064	72 02		 jb	 SHORT $L208198
  00066	8b c8		 mov	 ecx, eax
$L208198:
  00068	39 55 24	 cmp	 DWORD PTR [ebp+36], edx
  0006b	72 05		 jb	 SHORT $L208207
  0006d	8b 75 10	 mov	 esi, DWORD PTR [ebp+16]
  00070	eb 03		 jmp	 SHORT $L208208
$L208207:
  00072	8d 75 10	 lea	 esi, DWORD PTR [ebp+16]
$L208208:
  00075	33 d2		 xor	 edx, edx
  00077	f3 a6		 repe cmpsb
  00079	74 05		 je	 SHORT $L208225
  0007b	1b d2		 sbb	 edx, edx
  0007d	83 da ff	 sbb	 edx, -1
$L208225:
  00080	85 d2		 test	 edx, edx
  00082	75 0d		 jne	 SHORT $L208229
$L208227:
  00084	3b d8		 cmp	 ebx, eax
  00086	72 0b		 jb	 SHORT $L208224
  00088	33 d2		 xor	 edx, edx
  0008a	3b d8		 cmp	 ebx, eax
  0008c	0f 95 c2	 setne	 dl
  0008f	85 d2		 test	 edx, edx
$L208229:
  00091	7d 05		 jge	 SHORT $L185108
$L208224:

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00093	8b 6d 08	 mov	 ebp, DWORD PTR [ebp+8]

; 994  : 			else

  00096	eb 07		 jmp	 SHORT $L185109
$L185108:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00098	89 6c 24 10	 mov	 DWORD PTR __Wherenode$[esp+24], ebp

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0009c	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
$L185109:
  0009f	8a 4d 2d	 mov	 cl, BYTE PTR [ebp+45]
  000a2	84 c9		 test	 cl, cl
  000a4	74 8d		 je	 SHORT $L208228

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate

  000a6	8b 44 24 10	 mov	 eax, DWORD PTR __Wherenode$[esp+24]
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
$L185107:
  000ad	5d		 pop	 ebp

; 1001 : 		}

  000ae	83 c4 08	 add	 esp, 8
  000b1	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L208296
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L208296:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 27   : 		return (_Str.c_str());

  00000	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L208322
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  00009	c3		 ret	 0

; 27   : 		return (_Str.c_str());

$L208322:
  0000a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  0000d	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L208328
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L208328:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 591  : 		if (_Right.size() < _Roff)

  00003	8b 74 24 14	 mov	 esi, DWORD PTR __Roff$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 14	 mov	 edi, DWORD PTR __Right$[esp+12]
  0000c	39 77 14	 cmp	 DWORD PTR [edi+20], esi
  0000f	8b d9		 mov	 ebx, ecx
  00011	73 05		 jae	 SHORT $L184271

; 592  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L184271:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 6f 14	 mov	 ebp, DWORD PTR [edi+20]

; 594  : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b ee		 sub	 ebp, esi
  00021	3b c5		 cmp	 eax, ebp
  00023	73 02		 jae	 SHORT $L184273

; 595  : 			_Num = _Count;	// trim _Num to size

  00025	8b e8		 mov	 ebp, eax
$L184273:

; 596  : 
; 597  : 		if (this == &_Right)

  00027	3b df		 cmp	 ebx, edi
  00029	75 1f		 jne	 SHORT $L184274

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 ee		 add	 ebp, esi
  0002f	55		 push	 ebp
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00037	56		 push	 esi
  00038	6a 00		 push	 0
  0003a	8b cb		 mov	 ecx, ebx
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00044	8b c3		 mov	 eax, ebx
  00046	5b		 pop	 ebx

; 605  : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$L184274:

; 599  : 		else if (_Grow(_Num))

  0004a	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  0004d	76 07		 jbe	 SHORT $L208478
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L208478:
  00056	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00059	3b c5		 cmp	 eax, ebp
  0005b	73 21		 jae	 SHORT $L208479
  0005d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00060	50		 push	 eax
  00061	55		 push	 ebp
  00062	8b cb		 mov	 ecx, ebx
  00064	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00069	85 ed		 test	 ebp, ebp
$L208524:
  0006b	76 6d		 jbe	 SHORT $L208523

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0006d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00070	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00075	3b c8		 cmp	 ecx, eax
  00077	72 2f		 jb	 SHORT $L208489
  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	eb 2d		 jmp	 SHORT $L208490

; 599  : 		else if (_Grow(_Num))

$L208479:
  0007e	85 ed		 test	 ebp, ebp
  00080	75 e9		 jne	 SHORT $L208524
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00088	72 0f		 jb	 SHORT $L208471
  0008a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00093	8b c3		 mov	 eax, ebx
  00095	5b		 pop	 ebx

; 605  : 		}

  00096	c2 0c 00	 ret	 12			; 0000000cH

; 599  : 		else if (_Grow(_Num))

$L208471:
  00099	5f		 pop	 edi
  0009a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009d	5e		 pop	 esi
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a1	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000a2	8b c3		 mov	 eax, ebx
  000a4	5b		 pop	 ebx

; 605  : 		}

  000a5	c2 0c 00	 ret	 12			; 0000000cH

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$L208489:
  000a8	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
$L208490:
  000ab	39 43 18	 cmp	 DWORD PTR [ebx+24], eax
  000ae	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000b1	72 04		 jb	 SHORT $L208495
  000b3	8b 38		 mov	 edi, DWORD PTR [eax]
  000b5	eb 02		 jmp	 SHORT $L208496
$L208495:
  000b7	8b f8		 mov	 edi, eax
$L208496:
  000b9	03 f2		 add	 esi, edx
  000bb	8b cd		 mov	 ecx, ebp
  000bd	8b d1		 mov	 edx, ecx
  000bf	c1 e9 02	 shr	 ecx, 2
  000c2	f3 a5		 rep movsd
  000c4	8b ca		 mov	 ecx, edx
  000c6	83 e1 03	 and	 ecx, 3
  000c9	f3 a4		 rep movsb

; 602  : 			_Eos(_Num);

  000cb	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000cf	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000d2	72 02		 jb	 SHORT $L208518
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
$L208518:
  000d6	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L208523:
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000dd	8b c3		 mov	 eax, ebx
  000df	5b		 pop	 ebx

; 605  : 		}

  000e0	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::lower_bound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Keyval$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound
  0000a	8b 4c 24 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp-4]
  0000e	89 01		 mov	 DWORD PTR [ecx], eax
  00010	8b c1		 mov	 eax, ecx

; 811  : 		}

  00012	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 609  : 		if (_Inside(_Ptr))

  00003	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	72 05		 jb	 SHORT $L208559
  0000d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00010	eb 03		 jmp	 SHORT $L208560
$L208559:
  00012	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$L208560:
  00015	8b 74 24 10	 mov	 esi, DWORD PTR __Ptr$[esp+8]
  00019	3b f0		 cmp	 esi, eax
  0001b	72 34		 jb	 SHORT $L184989
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00023	72 04		 jb	 SHORT $L208563
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $L208564
$L208563:
  00029	8b c8		 mov	 ecx, eax
$L208564:
  0002b	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  0002e	03 f9		 add	 edi, ecx
  00030	3b fe		 cmp	 edi, esi
  00032	76 1d		 jbe	 SHORT $L184989

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  00034	83 fa 10	 cmp	 edx, 16			; 00000010H
  00037	72 02		 jb	 SHORT $L208573
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$L208573:
  0003b	8b 4c 24 14	 mov	 ecx, DWORD PTR __Num$[esp+8]
  0003f	51		 push	 ecx
  00040	2b f0		 sub	 esi, eax
  00042	56		 push	 esi
  00043	53		 push	 ebx
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 618  : 		}

  0004e	c2 08 00	 ret	 8
$L184989:
  00051	55		 push	 ebp

; 611  : 
; 612  : 		if (_Grow(_Num))

  00052	8b 6c 24 18	 mov	 ebp, DWORD PTR __Num$[esp+12]
  00056	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  00059	76 07		 jbe	 SHORT $L208671
  0005b	8b cb		 mov	 ecx, ebx
  0005d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L208671:
  00062	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00065	3b c5		 cmp	 eax, ebp
  00067	73 1b		 jae	 SHORT $L208672
  00069	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  0006c	52		 push	 edx
  0006d	55		 push	 ebp
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00075	85 ed		 test	 ebp, ebp
$L208752:
  00077	76 68		 jbe	 SHORT $L208750

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00079	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0007d	72 2f		 jb	 SHORT $L208724
  0007f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00082	eb 2d		 jmp	 SHORT $L208725

; 611  : 
; 612  : 		if (_Grow(_Num))

$L208672:
  00084	85 ed		 test	 ebp, ebp
  00086	75 ef		 jne	 SHORT $L208752
  00088	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008b	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  0008e	72 0f		 jb	 SHORT $L208715
  00090	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00093	5d		 pop	 ebp
  00094	5f		 pop	 edi
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0
  00098	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  00099	8b c3		 mov	 eax, ebx
  0009b	5b		 pop	 ebx

; 618  : 		}

  0009c	c2 08 00	 ret	 8

; 611  : 
; 612  : 		if (_Grow(_Num))

$L208715:
  0009f	5d		 pop	 ebp
  000a0	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000a3	5f		 pop	 edi
  000a4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a7	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx

; 618  : 		}

  000ab	c2 08 00	 ret	 8

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

$L208724:
  000ae	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
$L208725:
  000b1	8b cd		 mov	 ecx, ebp
  000b3	8b c1		 mov	 eax, ecx
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb

; 615  : 			_Eos(_Num);

  000c1	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000c5	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000c8	72 10		 jb	 SHORT $L208747
  000ca	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000cd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  000d1	5d		 pop	 ebp
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000d4	8b c3		 mov	 eax, ebx
  000d6	5b		 pop	 ebx

; 618  : 		}

  000d7	c2 08 00	 ret	 8

; 615  : 			_Eos(_Num);

$L208747:
  000da	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000dd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L208750:
  000e1	5d		 pop	 ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000e4	8b c3		 mov	 eax, ebx
  000e6	5b		 pop	 ebx

; 618  : 		}

  000e7	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

  00000	56		 push	 esi

; 324  : 		_Tidy();

  00001	33 c0		 xor	 eax, eax
  00003	8b f1		 mov	 esi, ecx

; 325  : 		assign(_Right, 0, npos);

  00005	6a ff		 push	 -1
  00007	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	50		 push	 eax
  00012	88 46 04	 mov	 BYTE PTR [esi+4], al
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Right$[esp+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T208824 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00003	8b 7c 24 14	 mov	 edi, DWORD PTR __Keyval$[esp+8]
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::_Lbound

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0000f	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00012	89 44 24 14	 mov	 DWORD PTR __Where$[esp+8], eax
  00016	74 36		 je	 SHORT $L208823
  00018	83 78 24 10	 cmp	 DWORD PTR [eax+36], 16	; 00000010H
  0001c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001f	72 05		 jb	 SHORT $L208912
  00021	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00024	eb 03		 jmp	 SHORT $L208913
$L208912:
  00026	83 c0 10	 add	 eax, 16			; 00000010H
$L208913:
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	8b cf		 mov	 ecx, edi
  00033	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00038	85 c0		 test	 eax, eax
  0003a	7c 12		 jl	 SHORT $L208823
  0003c	8d 44 24 14	 lea	 eax, DWORD PTR __Where$[esp+8]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00046	5f		 pop	 edi
  00047	89 10		 mov	 DWORD PTR [eax], edx
  00049	5e		 pop	 esi

; 791  : 		}

  0004a	59		 pop	 ecx
  0004b	c2 08 00	 ret	 8
$L208823:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0004e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00051	8d 44 24 08	 lea	 eax, DWORD PTR $T208824[esp+12]
  00055	89 4c 24 08	 mov	 DWORD PTR $T208824[esp+12], ecx
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  0005f	5f		 pop	 edi
  00060	89 10		 mov	 DWORD PTR [eax], edx
  00062	5e		 pop	 esi

; 791  : 		}

  00063	59		 pop	 ecx
  00064	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L208943:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L208943
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 623  : 		}

  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T209046 DD	0ffffffffH
	DD	FLAT:$L208946
$T209044 DD	019930520H
	DD	01H
	DD	FLAT:$T209046
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	e8 00 00 00 00	 call	 ??0exception@@QAE@XZ	; exception::exception
  00022	33 c0		 xor	 eax, eax
  00024	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	6a ff		 push	 -1
  0002f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00032	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00039	50		 push	 eax
  0003a	89 44 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], eax
  0003e	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00041	8b 44 24 20	 mov	 eax, DWORD PTR __Message$[esp+24]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 20   : 		}

  0004b	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L208946:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T209044
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogty
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L209054
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L209054:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L209147
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L209147:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 361  : 		_Tidy();
; 362  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b c2		 mov	 eax, edx
  00009	57		 push	 edi
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$L209234:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L209234
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 363  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::list<void *,std::allocator<void *> >::_Incsize
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T209370 DD	0ffffffffH
	DD	FLAT:$L209239
$T209367 DD	019930520H
	DD	01H
	DD	FLAT:$T209370
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_DATA	ENDS
;	COMDAT ?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T209238 = -80						; size = 28
$T209237 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::_Incsize, COMDAT
; _this$ = ecx

; 956  : 		{	// alter element count, with checking

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list

; 957  : 		if (max_size() - _Mysize < _Count)

  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Count$[esp-4]
  0000a	6a ff		 push	 -1
  0000c	68 00 00 00 00	 push	 __ehhandler$?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z
  00011	50		 push	 eax
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	83 ec 44	 sub	 esp, 68			; 00000044H
  0001f	56		 push	 esi
  00020	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00025	2b f0		 sub	 esi, eax
  00027	3b f2		 cmp	 esi, edx
  00029	5e		 pop	 esi
  0002a	73 51		 jae	 SHORT $L185954

; 958  : 			_THROW(length_error, "list<T> too long");

  0002c	6a 10		 push	 16			; 00000010H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00033	8d 4c 24 08	 lea	 ecx, DWORD PTR $T209238[esp+88]
  00037	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T209238[esp+112], 15 ; 0000000fH
  0003f	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T209238[esp+108], 0
  00047	c6 44 24 0c 00	 mov	 BYTE PTR $T209238[esp+92], 0
  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00051	8d 04 24	 lea	 eax, DWORD PTR $T209238[esp+80]
  00054	50		 push	 eax
  00055	8d 4c 24 20	 lea	 ecx, DWORD PTR $T209237[esp+84]
  00059	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  00061	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00066	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0006b	8d 4c 24 20	 lea	 ecx, DWORD PTR $T209237[esp+84]
  0006f	51		 push	 ecx
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T209237[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00078	e8 00 00 00 00	 call	 __CxxThrowException@8
$L185954:

; 959  : 		_Mysize += _Count;

  0007d	03 c2		 add	 eax, edx
  0007f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 960  : 		}

  00082	8b 4c 24 44	 mov	 ecx, DWORD PTR __$EHRec$[esp+80]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008d	83 c4 50	 add	 esp, 80			; 00000050H
  00090	c2 04 00	 ret	 4
$L209369:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L209239:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T209238[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T209367
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ENDP ; std::list<void *,std::allocator<void *> >::_Incsize
;	COMDAT xdata$x
xdata$x	SEGMENT
$T209475 DD	0ffffffffH
	DD	FLAT:$L209375
$T209473 DD	019930520H
	DD	01H
	DD	FLAT:$T209475
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	e8 00 00 00 00	 call	 ??0exception@@QAE@ABV0@@Z ; exception::exception
  00028	33 c0		 xor	 eax, eax
  0002a	6a ff		 push	 -1
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	50		 push	 eax
  00036	83 c7 0c	 add	 edi, 12			; 0000000cH
  00039	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00040	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00043	57		 push	 edi
  00044	89 44 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], eax
  00048	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00054	5f		 pop	 edi
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L209375:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T209473
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogty
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z	; CProject::GetItemProp
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
xdata$x	SEGMENT
$T209730 DD	0ffffffffH
	DD	FLAT:$L209485
$T209727 DD	019930520H
	DD	01H
	DD	FLAT:$T209730
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\databaseserver\project.h
xdata$x	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z
_TEXT	SEGMENT
$T209483 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_i$ = 8							; size = 4
_lpszItem$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 255  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 256  : 	map<string, DWORD>::iterator i	= m_mapII.find( lpszItem );

  00018	8b 54 24 2c	 mov	 edx, DWORD PTR _lpszItem$[esp+36]
  0001c	56		 push	 esi
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8b f1		 mov	 esi, ecx
  00022	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T209483[esp+72], 15 ; 0000000fH
  0002a	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T209483[esp+68], 0
  00032	c6 44 24 0c 00	 mov	 BYTE PTR $T209483[esp+52], 0
  00037	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L209728:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $L209728
  00047	2b c7		 sub	 eax, edi
  00049	50		 push	 eax
  0004a	52		 push	 edx
  0004b	8d 4c 24 10	 lea	 ecx, DWORD PTR $T209483[esp+56]
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00054	8d 44 24 08	 lea	 eax, DWORD PTR $T209483[esp+48]
  00058	50		 push	 eax
  00059	8d 4c 24 38	 lea	 ecx, DWORD PTR _i$[esp+48]
  0005d	51		 push	 ecx
  0005e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00061	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+64], 0
  00069	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,unsigned long,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,unsigned long> >,0> >::find
  0006e	83 7c 24 20 10	 cmp	 DWORD PTR $T209483[esp+72], 16 ; 00000010H
  00073	72 0d		 jb	 SHORT $L209653
  00075	8b 54 24 0c	 mov	 edx, DWORD PTR $T209483[esp+52]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007f	83 c4 04	 add	 esp, 4
$L209653:

; 257  : 	if( i != m_mapII.end() )

  00082	8b 44 24 34	 mov	 eax, DWORD PTR _i$[esp+44]
  00086	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00089	74 21		 je	 SHORT $L156841

; 258  : 		return GetItemProp( i->second );

  0008b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0008e	3b 46 50	 cmp	 eax, DWORD PTR [esi+80]
  00091	73 19		 jae	 SHORT $L156841
  00093	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00096	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi

; 259  : 	return NULL;
; 260  : }

  0009b	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a6	83 c4 28	 add	 esp, 40			; 00000028H
  000a9	c2 04 00	 ret	 4
$L156841:
  000ac	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000b0	5f		 pop	 edi
  000b1	33 c0		 xor	 eax, eax
  000b3	5e		 pop	 esi
  000b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000bb	83 c4 28	 add	 esp, 40			; 00000028H
  000be	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L209485:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T209483[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T209727
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z ENDP	; CProject::GetItemProp
PUBLIC	?_Insert@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXViterator@12@ABQAX@Z ; std::list<void *,std::allocator<void *> >::_Insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Insert@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXViterator@12@ABQAX@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXViterator@12@ABQAX@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::_Insert, COMDAT
; _this$ = ecx

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();
; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	8b 5c 24 08	 mov	 ebx, DWORD PTR __Where$[esp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	8b cf		 mov	 ecx, edi
  00015	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z ; std::list<void *,std::allocator<void *> >::_Buynode

; 524  : 		_Incsize(1);

  0001a	6a 01		 push	 1
  0001c	8b cf		 mov	 ecx, edi
  0001e	8b f0		 mov	 esi, eax
  00020	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::list<void *,std::allocator<void *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

  00025	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

  00028	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002b	5f		 pop	 edi
  0002c	89 32		 mov	 DWORD PTR [edx], esi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 527  : 		}

  00030	c2 08 00	 ret	 8
?_Insert@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXViterator@12@ABQAX@Z ENDP ; std::list<void *,std::allocator<void *> >::_Insert
_TEXT	ENDS
PUBLIC	??_C@_0CI@EEOAJLHJ@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@ ; `string'
PUBLIC	??_C@_0O@EFMGLFAG@?C?$LF?$LP?n?$MA?G?5?$LN?$LK?E?B?G?A?$AA@ ; `string'
PUBLIC	??_C@_0O@IEHBFJPC@?F?D?H?$LC?$MA?G?5?$LN?$LK?E?B?G?A?$AA@ ; `string'
PUBLIC	?RemoveItemInvenBank@CDbManager@@QAEHPAVCMover@@PAH1@Z ; CDbManager::RemoveItemInvenBank
EXTRN	__imp__lstrcmpA@8:NEAR
;	COMDAT ??_C@_0CI@EEOAJLHJ@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
CONST	SEGMENT
??_C@_0CI@EEOAJLHJ@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@ DB 'I'
	DB	'dPlayer = %07d, ItemName : %s %d/%d/%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EFMGLFAG@?C?$LF?$LP?n?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
CONST	SEGMENT
??_C@_0O@EFMGLFAG@?C?$LF?$LP?n?$MA?G?5?$LN?$LK?E?B?G?A?$AA@ DB 0c3H, 0b5H
	DB	0bfH, 0eeH, 0c0H, 0c7H, ' ', 0bdH, 0baH, 0c5H, 0c2H, 0c7H, 0c1H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IEHBFJPC@?F?D?H?$LC?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
CONST	SEGMENT
??_C@_0O@IEHBFJPC@?F?D?H?$LC?$MA?G?5?$LN?$LK?E?B?G?A?$AA@ DB 0c6H, 0c4H, 0c8H
	DB	0b2H, 0c0H, 0c7H, ' ', 0bdH, 0baH, 0c5H, 0c2H, 0c7H, 0c1H, 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
CONST	ENDS
;	COMDAT ?RemoveItemInvenBank@CDbManager@@QAEHPAVCMover@@PAH1@Z
_TEXT	SEGMENT
tv1133 = -20						; size = 4
tv1123 = -20						; size = 4
_nSize$204942 = -16					; size = 4
_bResult$ = -12						; size = 4
_pItemProp$204940 = -8					; size = 4
_this$ = -4						; size = 4
_i$204944 = 8						; size = 4
_pMover$ = 8						; size = 4
_nCountItem0$ = 12					; size = 4
_nCountItem1$ = 16					; size = 4
?RemoveItemInvenBank@CDbManager@@QAEHPAVCMover@@PAH1@Z PROC NEAR ; CDbManager::RemoveItemInvenBank, COMDAT
; _this$ = ecx

; 456  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H

; 457  : 	BOOL bResult = FALSE;
; 458  : 	SET_STRING::iterator it;
; 459  : 	for( it = m_RemoveItem_List.begin() ; it != m_RemoveItem_List.end() ; ++it )

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	53		 push	 ebx
  00007	8b 18		 mov	 ebx, DWORD PTR [eax]
  00009	33 d2		 xor	 edx, edx
  0000b	3b d8		 cmp	 ebx, eax
  0000d	89 4c 24 14	 mov	 DWORD PTR _this$[esp+24], ecx
  00011	89 54 24 0c	 mov	 DWORD PTR _bResult$[esp+24], edx
  00015	0f 84 d3 03 00
	00		 je	 $L210393
  0001b	55		 push	 ebp
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b 7c 24 28	 mov	 edi, DWORD PTR _pMover$[esp+32]
$L210400:

; 460  : 	{
; 461  : 		// Inven
; 462  : 		ItemProp* pItemProp = NULL;
; 463  : 		pItemProp = prj.GetItemProp( it->data() );

  00022	83 7b 24 10	 cmp	 DWORD PTR [ebx+36], 16	; 00000010H
  00026	72 05		 jb	 SHORT $L210009
  00028	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0002b	eb 03		 jmp	 SHORT $L210010
$L210009:
  0002d	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
$L210010:
  00030	50		 push	 eax
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00036	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z ; CProject::GetItemProp
  0003b	8b c8		 mov	 ecx, eax

; 464  : 		if( pItemProp )

  0003d	33 d2		 xor	 edx, edx
  0003f	3b ca		 cmp	 ecx, edx
  00041	89 4c 24 1c	 mov	 DWORD PTR _pItemProp$204940[esp+36], ecx
  00045	0f 84 40 03 00
	00		 je	 $L204938

; 465  : 		{
; 466  : 			int	nSize	= pMover->m_Inventory.m_dwItemMax;

  0004b	8b 87 24 41 00
	00		 mov	 eax, DWORD PTR [edi+16676]

; 467  : 			CItemElem* pItemElem;
; 468  : 			for( int i = 0 ; i < nSize; i++ )

  00051	3b c2		 cmp	 eax, edx
  00053	89 44 24 14	 mov	 DWORD PTR _nSize$204942[esp+36], eax
  00057	89 54 24 28	 mov	 DWORD PTR _i$204944[esp+32], edx
  0005b	0f 8e 90 01 00
	00		 jle	 $L210394

; 465  : 		{
; 466  : 			int	nSize	= pMover->m_Inventory.m_dwItemMax;

  00061	89 54 24 10	 mov	 DWORD PTR tv1123[esp+36], edx
  00065	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$L204945:

; 469  : 			{
; 470  : 				pItemElem	= pMover->m_Inventory.GetAtId( i );

  00070	3b 97 24 41 00
	00		 cmp	 edx, DWORD PTR [edi+16676]
  00076	0f 83 56 01 00
	00		 jae	 $L204946
  0007c	8b 44 24 10	 mov	 eax, DWORD PTR tv1123[esp+36]
  00080	8b b7 20 41 00
	00		 mov	 esi, DWORD PTR [edi+16672]
  00086	03 f0		 add	 esi, eax
  00088	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 3f 01 00
	00		 je	 $L204946

; 471  : 				if( pItemElem )
; 472  : 				{
; 473  : 					ItemProp* pGetItemProp		= prj.GetItemProp( pItemElem->m_dwItemId );	

  00093	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  00099	0f 83 33 01 00
	00		 jae	 $L204946
  0009f	8b 2d 40 00 00
	00		 mov	 ebp, DWORD PTR ?prj@@3VCProject@@A+64
  000a5	8b 44 85 00	 mov	 eax, DWORD PTR [ebp+eax*4]

; 474  : 					if( pGetItemProp && pGetItemProp->dwID == pItemProp->dwID )

  000a9	85 c0		 test	 eax, eax
  000ab	0f 84 21 01 00
	00		 je	 $L204946
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000b5	0f 85 17 01 00
	00		 jne	 $L204946

; 475  : 					{
; 476  : 						if( pItemElem->m_bItemResist || pItemElem->GetOption() || pItemElem->m_nResistAbilityOption )

  000bb	8a 56 7c	 mov	 dl, BYTE PTR [esi+124]
  000be	84 d2		 test	 dl, dl
  000c0	75 11		 jne	 SHORT $L204952
  000c2	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  000c5	85 c0		 test	 eax, eax
  000c7	75 0a		 jne	 SHORT $L204952
  000c9	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  000cf	85 c0		 test	 eax, eax
  000d1	74 37		 je	 SHORT $L204951
$L204952:

; 477  : 						{
; 478  : 							FILEOUT( "..\\RemoveItem.log", "IdPlayer = %07d, ItemName : %s %d/%d/%d", pMover->m_idPlayer,  it->data(), pItemElem->GetOption(), pItemElem->m_bItemResist, pItemElem->m_nResistAbilityOption );

  000d3	83 7b 24 10	 cmp	 DWORD PTR [ebx+36], 16	; 00000010H
  000d7	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  000da	72 05		 jb	 SHORT $L210090
  000dc	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000df	eb 03		 jmp	 SHORT $L210091
$L210090:
  000e1	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
$L210091:
  000e4	8b ae 80 00 00
	00		 mov	 ebp, DWORD PTR [esi+128]
  000ea	55		 push	 ebp
  000eb	0f b6 d2	 movzx	 edx, dl
  000ee	52		 push	 edx
  000ef	51		 push	 ecx
  000f0	50		 push	 eax
  000f1	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@EEOAJLHJ@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
  000fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@
  00102	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT
  00107	83 c4 1c	 add	 esp, 28			; 0000001cH
$L204951:

; 479  : 						}
; 480  : 						pMover->m_Inventory.RemoveAtId( pItemElem->m_dwObjId );

  0010a	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0010d	8b 87 24 41 00
	00		 mov	 eax, DWORD PTR [edi+16676]
  00113	3b f0		 cmp	 esi, eax
  00115	73 50		 jae	 SHORT $L210100
  00117	8b 8f 20 41 00
	00		 mov	 ecx, DWORD PTR [edi+16672]
  0011d	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  00120	c1 e6 05	 shl	 esi, 5
  00123	39 44 0e 2c	 cmp	 DWORD PTR [esi+ecx+44], eax
  00127	73 3e		 jae	 SHORT $L210100
  00129	8b d1		 mov	 edx, ecx
  0012b	8b 04 16	 mov	 eax, DWORD PTR [esi+edx]
  0012e	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  00131	ff 50 04	 call	 DWORD PTR [eax+4]
  00134	8b 8f 20 41 00
	00		 mov	 ecx, DWORD PTR [edi+16672]
  0013a	8b 54 0e 2c	 mov	 edx, DWORD PTR [esi+ecx+44]
  0013e	3b 97 1c 41 00
	00		 cmp	 edx, DWORD PTR [edi+16668]
  00144	72 21		 jb	 SHORT $L210100
  00146	8b 97 18 41 00
	00		 mov	 edx, DWORD PTR [edi+16664]
  0014c	8b c1		 mov	 eax, ecx
  0014e	8b 4c 06 2c	 mov	 ecx, DWORD PTR [esi+eax+44]
  00152	c7 04 8a ff ff
	ff ff		 mov	 DWORD PTR [edx+ecx*4], -1
  00159	8b 87 20 41 00
	00		 mov	 eax, DWORD PTR [edi+16672]
  0015f	c7 44 06 2c ff
	ff ff ff	 mov	 DWORD PTR [esi+eax+44], -1
$L210100:

; 481  : 						if( prj.IsConvMode( REMOVE_ITEM_ALL_PAY ) )

  00167	6a 08		 push	 8
  00169	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0016e	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00173	85 c0		 test	 eax, eax
  00175	74 4b		 je	 SHORT $L210398

; 482  : 						{
; 483  : 							if( lstrcmp( it->data(), " " ) == 0 )

  00177	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0017a	bd 10 00 00 00	 mov	 ebp, 16			; 00000010H
  0017f	3b c5		 cmp	 eax, ebp
  00181	72 05		 jb	 SHORT $L210147
  00183	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00186	eb 03		 jmp	 SHORT $L210148
$L210147:
  00188	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
$L210148:
  0018b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcmpA@8
  00191	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EFMGLFAG@?C?$LF?$LP?n?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
  00196	50		 push	 eax
  00197	ff d6		 call	 esi
  00199	85 c0		 test	 eax, eax
  0019b	75 06		 jne	 SHORT $L204956

; 484  : 								(*nCountItem0)++;

  0019d	8b 44 24 2c	 mov	 eax, DWORD PTR _nCountItem0$[esp+32]
  001a1	ff 00		 inc	 DWORD PTR [eax]
$L204956:

; 485  : 							if( lstrcmp( it->data(), " " ) == 0 )

  001a3	39 6b 24	 cmp	 DWORD PTR [ebx+36], ebp
  001a6	72 05		 jb	 SHORT $L210195
  001a8	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  001ab	eb 03		 jmp	 SHORT $L210196
$L210195:
  001ad	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
$L210196:
  001b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@IEHBFJPC@?F?D?H?$LC?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
  001b5	50		 push	 eax
  001b6	ff d6		 call	 esi
  001b8	85 c0		 test	 eax, eax
  001ba	75 06		 jne	 SHORT $L210398

; 486  : 								(*nCountItem1)++;

  001bc	8b 44 24 30	 mov	 eax, DWORD PTR _nCountItem1$[esp+32]
  001c0	ff 00		 inc	 DWORD PTR [eax]
$L210398:

; 487  : 						}
; 488  : //						FILEOUT( "..\\RemoveItem.log", "PlayerName = %s, ItemName : %s", pMover->m_szName,  it->data() );
; 489  : 						bResult = TRUE;

  001c2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pItemProp$204940[esp+36]
  001c6	8b 54 24 28	 mov	 edx, DWORD PTR _i$204944[esp+32]
  001ca	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _bResult$[esp+36], 1
$L204946:
  001d2	8b 74 24 10	 mov	 esi, DWORD PTR tv1123[esp+36]
  001d6	8b 44 24 14	 mov	 eax, DWORD PTR _nSize$204942[esp+36]
  001da	42		 inc	 edx
  001db	81 c6 a0 00 00
	00		 add	 esi, 160		; 000000a0H
  001e1	3b d0		 cmp	 edx, eax
  001e3	89 54 24 28	 mov	 DWORD PTR _i$204944[esp+32], edx
  001e7	89 74 24 10	 mov	 DWORD PTR tv1123[esp+36], esi
  001eb	0f 8c 7f fe ff
	ff		 jl	 $L204945
$L210394:

; 490  : 					}
; 491  : 				}
; 492  : 			}
; 493  : 
; 494  : 			// Bank
; 495  : 			nSize	= pMover->m_Bank[0].m_dwItemMax;

  001f1	8b 8f a4 41 00
	00		 mov	 ecx, DWORD PTR [edi+16804]

; 496  : 			for( i = 0 ; i < nSize; i++ )

  001f7	33 ed		 xor	 ebp, ebp
  001f9	3b cd		 cmp	 ecx, ebp
  001fb	89 4c 24 14	 mov	 DWORD PTR _nSize$204942[esp+36], ecx
  001ff	89 6c 24 28	 mov	 DWORD PTR _i$204944[esp+32], ebp
  00203	0f 8e 82 01 00
	00		 jle	 $L204938

; 490  : 					}
; 491  : 				}
; 492  : 			}
; 493  : 
; 494  : 			// Bank
; 495  : 			nSize	= pMover->m_Bank[0].m_dwItemMax;

  00209	89 6c 24 10	 mov	 DWORD PTR tv1133[esp+36], ebp
  0020d	8d 49 00	 npad	 3
$L204960:

; 497  : 			{
; 498  : 				pItemElem	= pMover->m_Bank[0].GetAtId( i );

  00210	3b af a4 41 00
	00		 cmp	 ebp, DWORD PTR [edi+16804]
  00216	0f 83 54 01 00
	00		 jae	 $L204961
  0021c	8b 44 24 10	 mov	 eax, DWORD PTR tv1133[esp+36]
  00220	8b b7 a0 41 00
	00		 mov	 esi, DWORD PTR [edi+16800]
  00226	03 f0		 add	 esi, eax
  00228	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0022b	85 c0		 test	 eax, eax
  0022d	0f 84 3d 01 00
	00		 je	 $L204961

; 499  : 				if( pItemElem )
; 500  : 				{
; 501  : 					ItemProp* pGetItemProp		= prj.GetItemProp( pItemElem->m_dwItemId );	

  00233	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  00239	0f 83 31 01 00
	00		 jae	 $L204961
  0023f	8b 15 40 00 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+64
  00245	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]

; 502  : 					if( pGetItemProp && pGetItemProp->dwID == pItemProp->dwID )

  00248	85 c0		 test	 eax, eax
  0024a	0f 84 20 01 00
	00		 je	 $L204961
  00250	8b 00		 mov	 eax, DWORD PTR [eax]
  00252	8b 54 24 1c	 mov	 edx, DWORD PTR _pItemProp$204940[esp+36]
  00256	3b 02		 cmp	 eax, DWORD PTR [edx]
  00258	0f 85 12 01 00
	00		 jne	 $L204961

; 503  : 					{
; 504  : 						if( pItemElem->m_bItemResist || pItemElem->GetOption() || pItemElem->m_nResistAbilityOption )

  0025e	8a 56 7c	 mov	 dl, BYTE PTR [esi+124]
  00261	84 d2		 test	 dl, dl
  00263	75 11		 jne	 SHORT $L204967
  00265	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  00268	85 c0		 test	 eax, eax
  0026a	75 0a		 jne	 SHORT $L204967
  0026c	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00272	85 c0		 test	 eax, eax
  00274	74 3b		 je	 SHORT $L204966
$L204967:

; 505  : 						{
; 506  : 							FILEOUT( "..\\RemoveItem.log", "IdPlayer = %07d, ItemName : %s %d/%d/%d", pMover->m_idPlayer,  it->data(), pItemElem->GetOption(), pItemElem->m_bItemResist, pItemElem->m_nResistAbilityOption );

  00276	83 7b 24 10	 cmp	 DWORD PTR [ebx+36], 16	; 00000010H
  0027a	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  0027d	72 05		 jb	 SHORT $L210275
  0027f	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00282	eb 03		 jmp	 SHORT $L210276
$L210275:
  00284	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
$L210276:
  00287	8b ae 80 00 00
	00		 mov	 ebp, DWORD PTR [esi+128]
  0028d	55		 push	 ebp
  0028e	0f b6 d2	 movzx	 edx, dl
  00291	52		 push	 edx
  00292	51		 push	 ecx
  00293	50		 push	 eax
  00294	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0029a	50		 push	 eax
  0029b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@EEOAJLHJ@IdPlayer?5?$DN?5?$CF07d?0?5ItemName?5?3?5?$CFs?5?$CF@
  002a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@
  002a5	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT
  002aa	8b 6c 24 44	 mov	 ebp, DWORD PTR _i$204944[esp+60]
  002ae	83 c4 1c	 add	 esp, 28			; 0000001cH
$L204966:

; 507  : 						}
; 508  : 
; 509  : 						pMover->m_Bank[0].RemoveAtId( pItemElem->m_dwObjId );

  002b1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  002b4	8b 87 a4 41 00
	00		 mov	 eax, DWORD PTR [edi+16804]
  002ba	3b f0		 cmp	 esi, eax
  002bc	73 50		 jae	 SHORT $L210285
  002be	8b 8f a0 41 00
	00		 mov	 ecx, DWORD PTR [edi+16800]
  002c4	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  002c7	c1 e6 05	 shl	 esi, 5
  002ca	39 44 0e 2c	 cmp	 DWORD PTR [esi+ecx+44], eax
  002ce	73 3e		 jae	 SHORT $L210285
  002d0	8b d1		 mov	 edx, ecx
  002d2	8b 04 16	 mov	 eax, DWORD PTR [esi+edx]
  002d5	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  002d8	ff 50 04	 call	 DWORD PTR [eax+4]
  002db	8b 8f a0 41 00
	00		 mov	 ecx, DWORD PTR [edi+16800]
  002e1	8b 54 0e 2c	 mov	 edx, DWORD PTR [esi+ecx+44]
  002e5	3b 97 9c 41 00
	00		 cmp	 edx, DWORD PTR [edi+16796]
  002eb	72 21		 jb	 SHORT $L210285
  002ed	8b 97 98 41 00
	00		 mov	 edx, DWORD PTR [edi+16792]
  002f3	8b c1		 mov	 eax, ecx
  002f5	8b 4c 06 2c	 mov	 ecx, DWORD PTR [esi+eax+44]
  002f9	c7 04 8a ff ff
	ff ff		 mov	 DWORD PTR [edx+ecx*4], -1
  00300	8b 87 a0 41 00
	00		 mov	 eax, DWORD PTR [edi+16800]
  00306	c7 44 06 2c ff
	ff ff ff	 mov	 DWORD PTR [esi+eax+44], -1
$L210285:

; 510  : 						if( prj.IsConvMode( REMOVE_ITEM_ALL_PAY ) )

  0030e	6a 08		 push	 8
  00310	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00315	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  0031a	85 c0		 test	 eax, eax
  0031c	74 46		 je	 SHORT $L204971

; 511  : 						{
; 512  : 							if( lstrcmp( it->data(), " " ) == 0 )

  0031e	83 7b 24 10	 cmp	 DWORD PTR [ebx+36], 16	; 00000010H
  00322	72 05		 jb	 SHORT $L210332
  00324	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00327	eb 03		 jmp	 SHORT $L210333
$L210332:
  00329	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
$L210333:
  0032c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcmpA@8
  00332	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EFMGLFAG@?C?$LF?$LP?n?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
  00337	50		 push	 eax
  00338	ff d6		 call	 esi
  0033a	85 c0		 test	 eax, eax
  0033c	75 06		 jne	 SHORT $L204970

; 513  : 								(*nCountItem0)++;

  0033e	8b 44 24 2c	 mov	 eax, DWORD PTR _nCountItem0$[esp+32]
  00342	ff 00		 inc	 DWORD PTR [eax]
$L204970:

; 514  : 							if( lstrcmp( it->data(), " " ) == 0 )

  00344	83 7b 24 10	 cmp	 DWORD PTR [ebx+36], 16	; 00000010H
  00348	72 05		 jb	 SHORT $L210381
  0034a	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0034d	eb 03		 jmp	 SHORT $L210382
$L210381:
  0034f	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
$L210382:
  00352	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@IEHBFJPC@?F?D?H?$LC?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
  00357	50		 push	 eax
  00358	ff d6		 call	 esi
  0035a	85 c0		 test	 eax, eax
  0035c	75 06		 jne	 SHORT $L204971

; 515  : 								(*nCountItem1)++;

  0035e	8b 44 24 30	 mov	 eax, DWORD PTR _nCountItem1$[esp+32]
  00362	ff 00		 inc	 DWORD PTR [eax]
$L204971:

; 516  : 						}
; 517  : //						FILEOUT( "..\\RemoveItem.log", "PlayerName = %s, ItemName : %s", pMover->m_szName,  it->data() );
; 518  : 						bResult = TRUE;

  00364	8b 4c 24 14	 mov	 ecx, DWORD PTR _nSize$204942[esp+36]
  00368	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _bResult$[esp+36], 1
$L204961:
  00370	8b 54 24 10	 mov	 edx, DWORD PTR tv1133[esp+36]
  00374	45		 inc	 ebp
  00375	81 c2 a0 00 00
	00		 add	 edx, 160		; 000000a0H
  0037b	3b e9		 cmp	 ebp, ecx
  0037d	89 6c 24 28	 mov	 DWORD PTR _i$204944[esp+32], ebp
  00381	89 54 24 10	 mov	 DWORD PTR tv1133[esp+36], edx
  00385	0f 8c 85 fe ff
	ff		 jl	 $L204960
$L204938:

; 457  : 	BOOL bResult = FALSE;
; 458  : 	SET_STRING::iterator it;
; 459  : 	for( it = m_RemoveItem_List.begin() ; it != m_RemoveItem_List.end() ; ++it )

  0038b	8a 43 29	 mov	 al, BYTE PTR [ebx+41]
  0038e	84 c0		 test	 al, al
  00390	75 41		 jne	 SHORT $L209915
  00392	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00395	8a 41 29	 mov	 al, BYTE PTR [ecx+41]
  00398	84 c0		 test	 al, al
  0039a	75 18		 jne	 SHORT $L210388
  0039c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0039e	8a 50 29	 mov	 dl, BYTE PTR [eax+41]
  003a1	84 d2		 test	 dl, dl
  003a3	75 0b		 jne	 SHORT $L209932
$L209930:
  003a5	8b c8		 mov	 ecx, eax
  003a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  003a9	8a 50 29	 mov	 dl, BYTE PTR [eax+41]
  003ac	84 d2		 test	 dl, dl
  003ae	74 f5		 je	 SHORT $L209930
$L209932:
  003b0	8b d9		 mov	 ebx, ecx
  003b2	eb 1f		 jmp	 SHORT $L209915
$L210388:
  003b4	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  003b7	8a 48 29	 mov	 cl, BYTE PTR [eax+41]
  003ba	84 c9		 test	 cl, cl
  003bc	75 13		 jne	 SHORT $L209921
  003be	8b ff		 npad	 2
$L209919:
  003c0	3b 58 08	 cmp	 ebx, DWORD PTR [eax+8]
  003c3	75 0c		 jne	 SHORT $L209921
  003c5	8b d8		 mov	 ebx, eax
  003c7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003ca	8a 48 29	 mov	 cl, BYTE PTR [eax+41]
  003cd	84 c9		 test	 cl, cl
  003cf	74 ef		 je	 SHORT $L209919
$L209921:
  003d1	8b d8		 mov	 ebx, eax
$L209915:
  003d3	8b 4c 24 20	 mov	 ecx, DWORD PTR _this$[esp+36]
  003d7	3b 59 04	 cmp	 ebx, DWORD PTR [ecx+4]
  003da	0f 85 42 fc ff
	ff		 jne	 $L210400

; 519  : 					}
; 520  : 				}
; 521  : 			}
; 522  : 		}
; 523  : 	}
; 524  : 	return bResult;

  003e0	8b 44 24 18	 mov	 eax, DWORD PTR _bResult$[esp+36]
  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	5d		 pop	 ebp
  003e7	5b		 pop	 ebx

; 525  : }

  003e8	83 c4 14	 add	 esp, 20			; 00000014H
  003eb	c2 0c 00	 ret	 12			; 0000000cH
$L210393:

; 519  : 					}
; 520  : 				}
; 521  : 			}
; 522  : 		}
; 523  : 	}
; 524  : 	return bResult;

  003ee	8b c2		 mov	 eax, edx
  003f0	5b		 pop	 ebx

; 525  : }

  003f1	83 c4 14	 add	 esp, 20			; 00000014H
  003f4	c2 0c 00	 ret	 12			; 0000000cH
?RemoveItemInvenBank@CDbManager@@QAEHPAVCMover@@PAH1@Z ENDP ; CDbManager::RemoveItemInvenBank
_TEXT	ENDS
PUBLIC	??_C@_0CF@GKENJFPN@GuildId?5?$DN?5?$CFd?0?5ItemName?5?3?5?$CFs?5?$CFd?1?$CF@ ; `string'
PUBLIC	?RemoveItemGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@PAH1@Z ; CDbManager::RemoveItemGuildBank
;	COMDAT ??_C@_0CF@GKENJFPN@GuildId?5?$DN?5?$CFd?0?5ItemName?5?3?5?$CFs?5?$CFd?1?$CF@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
CONST	SEGMENT
??_C@_0CF@GKENJFPN@GuildId?5?$DN?5?$CFd?0?5ItemName?5?3?5?$CFs?5?$CFd?1?$CF@ DB 'G'
	DB	'uildId = %d, ItemName : %s %d/%d/%d', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
CONST	ENDS
;	COMDAT ?RemoveItemGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@PAH1@Z
_TEXT	SEGMENT
_i$204990 = -20						; size = 4
_bResult$ = -16						; size = 4
_pItemProp$204986 = -12					; size = 4
_nSize$204988 = -8					; size = 4
_this$ = -4						; size = 4
_nGuildId$ = 8						; size = 4
tv723 = 12						; size = 4
_GuildBank$ = 12					; size = 4
_nCountItem0$ = 16					; size = 4
_nCountItem1$ = 20					; size = 4
?RemoveItemGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@PAH1@Z PROC NEAR ; CDbManager::RemoveItemGuildBank, COMDAT
; _this$ = ecx

; 528  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 529  : 	BOOL bResult = FALSE;
; 530  : 	SET_STRING::iterator it;
; 531  : 	for( it = m_RemoveItem_List.begin() ; it != m_RemoveItem_List.end() ; ++it )

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]
  0000c	33 c9		 xor	 ecx, ecx
  0000e	3b f8		 cmp	 edi, eax
  00010	89 74 24 18	 mov	 DWORD PTR _this$[esp+28], esi
  00014	89 4c 24 0c	 mov	 DWORD PTR _bResult$[esp+28], ecx
  00018	0f 84 0c 02 00
	00		 je	 $L210854
  0001e	53		 push	 ebx
  0001f	8b 5c 24 28	 mov	 ebx, DWORD PTR _GuildBank$[esp+28]
  00023	55		 push	 ebp
$L210858:

; 532  : 	{
; 533  : 		ItemProp* pItemProp = NULL;
; 534  : 		pItemProp = prj.GetItemProp( it->data() );

  00024	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H
  00028	72 05		 jb	 SHORT $L210661
  0002a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0002d	eb 03		 jmp	 SHORT $L210662
$L210661:
  0002f	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
$L210662:
  00032	50		 push	 eax
  00033	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00038	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@PBD@Z ; CProject::GetItemProp

; 535  : 		if( pItemProp )

  0003d	85 c0		 test	 eax, eax
  0003f	89 44 24 18	 mov	 DWORD PTR _pItemProp$204986[esp+36], eax
  00043	0f 84 7e 01 00
	00		 je	 $L204984

; 536  : 		{
; 537  : 			int	nSize	= GuildBank->m_dwItemMax;

  00049	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 538  : 			CItemElem* pItemElem;
; 539  : 			for( int i = 0 ; i < nSize; i++ )

  0004c	33 ed		 xor	 ebp, ebp
  0004e	85 c9		 test	 ecx, ecx
  00050	89 4c 24 1c	 mov	 DWORD PTR _nSize$204988[esp+36], ecx
  00054	89 6c 24 10	 mov	 DWORD PTR _i$204990[esp+36], ebp
  00058	0f 8e 69 01 00
	00		 jle	 $L204984

; 536  : 		{
; 537  : 			int	nSize	= GuildBank->m_dwItemMax;

  0005e	89 6c 24 2c	 mov	 DWORD PTR tv723[esp+32], ebp
$L204991:

; 540  : 			{
; 541  : 				pItemElem	= GuildBank->GetAtId( i );

  00062	3b 6b 10	 cmp	 ebp, DWORD PTR [ebx+16]
  00065	0f 83 3d 01 00
	00		 jae	 $L204992
  0006b	8b 44 24 2c	 mov	 eax, DWORD PTR tv723[esp+32]
  0006f	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  00072	03 f0		 add	 esi, eax
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	85 c0		 test	 eax, eax
  00079	0f 84 29 01 00
	00		 je	 $L204992

; 542  : 				if( pItemElem )
; 543  : 				{
; 544  : 					ItemProp* pGetItemProp		= prj.GetItemProp( pItemElem->m_dwItemId );	

  0007f	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+80
  00085	0f 83 1d 01 00
	00		 jae	 $L204992
  0008b	8b 15 40 00 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+64
  00091	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]

; 545  : 					if( pGetItemProp && pGetItemProp->dwID == pItemProp->dwID )

  00094	85 c0		 test	 eax, eax
  00096	0f 84 0c 01 00
	00		 je	 $L204992
  0009c	8b 00		 mov	 eax, DWORD PTR [eax]
  0009e	8b 54 24 18	 mov	 edx, DWORD PTR _pItemProp$204986[esp+36]
  000a2	3b 02		 cmp	 eax, DWORD PTR [edx]
  000a4	0f 85 fe 00 00
	00		 jne	 $L204992

; 546  : 					{
; 547  : 						if( pItemElem->m_bItemResist || pItemElem->GetOption() || pItemElem->m_nResistAbilityOption )

  000aa	8a 56 7c	 mov	 dl, BYTE PTR [esi+124]
  000ad	84 d2		 test	 dl, dl
  000af	75 11		 jne	 SHORT $L204998
  000b1	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  000b4	85 c0		 test	 eax, eax
  000b6	75 0a		 jne	 SHORT $L204998
  000b8	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  000be	85 c0		 test	 eax, eax
  000c0	74 39		 je	 SHORT $L204997
$L204998:

; 548  : 						{
; 549  : 							FILEOUT( "..\\RemoveItem.log", "GuildId = %d, ItemName : %s %d/%d/%d", nGuildId,  it->data(), pItemElem->GetOption(), pItemElem->m_bItemResist, pItemElem->m_nResistAbilityOption );

  000c2	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H
  000c6	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  000c9	72 05		 jb	 SHORT $L210740
  000cb	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000ce	eb 03		 jmp	 SHORT $L210741
$L210740:
  000d0	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
$L210741:
  000d3	8b ae 80 00 00
	00		 mov	 ebp, DWORD PTR [esi+128]
  000d9	55		 push	 ebp
  000da	0f b6 d2	 movzx	 edx, dl
  000dd	52		 push	 edx
  000de	51		 push	 ecx
  000df	50		 push	 eax
  000e0	8b 44 24 38	 mov	 eax, DWORD PTR _nGuildId$[esp+48]
  000e4	50		 push	 eax
  000e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@GKENJFPN@GuildId?5?$DN?5?$CFd?0?5ItemName?5?3?5?$CFs?5?$CFd?1?$CF@
  000ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@JBKLBMKC@?4?4?2RemoveItem?4log?$AA@
  000ef	e8 00 00 00 00	 call	 ?FILEOUT@@YAXPBD0ZZ	; FILEOUT
  000f4	8b 6c 24 2c	 mov	 ebp, DWORD PTR _i$204990[esp+64]
  000f8	83 c4 1c	 add	 esp, 28			; 0000001cH
$L204997:

; 550  : 						}
; 551  : 						
; 552  : 						GuildBank->RemoveAtId( pItemElem->m_dwObjId );

  000fb	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000fe	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00101	3b f0		 cmp	 esi, eax
  00103	73 41		 jae	 SHORT $L210749
  00105	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00108	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  0010b	c1 e6 05	 shl	 esi, 5
  0010e	39 44 0e 2c	 cmp	 DWORD PTR [esi+ecx+44], eax
  00112	73 32		 jae	 SHORT $L210749
  00114	8b d1		 mov	 edx, ecx
  00116	8b 04 16	 mov	 eax, DWORD PTR [esi+edx]
  00119	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  0011c	ff 50 04	 call	 DWORD PTR [eax+4]
  0011f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00122	8b 54 0e 2c	 mov	 edx, DWORD PTR [esi+ecx+44]
  00126	3b 53 08	 cmp	 edx, DWORD PTR [ebx+8]
  00129	72 1b		 jb	 SHORT $L210749
  0012b	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0012e	8b c1		 mov	 eax, ecx
  00130	8b 4c 06 2c	 mov	 ecx, DWORD PTR [esi+eax+44]
  00134	c7 04 8a ff ff
	ff ff		 mov	 DWORD PTR [edx+ecx*4], -1
  0013b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0013e	c7 44 06 2c ff
	ff ff ff	 mov	 DWORD PTR [esi+eax+44], -1
$L210749:

; 553  : 						if( prj.IsConvMode( REMOVE_ITEM_ALL_PAY ) )

  00146	6a 08		 push	 8
  00148	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0014d	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00152	85 c0		 test	 eax, eax
  00154	74 46		 je	 SHORT $L205003

; 554  : 						{
; 555  : 							if( lstrcmp( it->data(), " " ) == 0 )

  00156	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H
  0015a	72 05		 jb	 SHORT $L210796
  0015c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0015f	eb 03		 jmp	 SHORT $L210797
$L210796:
  00161	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
$L210797:
  00164	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__lstrcmpA@8
  0016a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EFMGLFAG@?C?$LF?$LP?n?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
  0016f	50		 push	 eax
  00170	ff d6		 call	 esi
  00172	85 c0		 test	 eax, eax
  00174	75 06		 jne	 SHORT $L205002

; 556  : 								(*nCountItem0)++;

  00176	8b 44 24 30	 mov	 eax, DWORD PTR _nCountItem0$[esp+32]
  0017a	ff 00		 inc	 DWORD PTR [eax]
$L205002:

; 557  : 							if( lstrcmp( it->data(), " " ) == 0 )

  0017c	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H
  00180	72 05		 jb	 SHORT $L210844
  00182	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00185	eb 03		 jmp	 SHORT $L210845
$L210844:
  00187	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
$L210845:
  0018a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@IEHBFJPC@?F?D?H?$LC?$MA?G?5?$LN?$LK?E?B?G?A?$AA@
  0018f	50		 push	 eax
  00190	ff d6		 call	 esi
  00192	85 c0		 test	 eax, eax
  00194	75 06		 jne	 SHORT $L205003

; 558  : 								(*nCountItem1)++;

  00196	8b 44 24 34	 mov	 eax, DWORD PTR _nCountItem1$[esp+32]
  0019a	ff 00		 inc	 DWORD PTR [eax]
$L205003:

; 559  : 						}
; 560  : //						FILEOUT( "..\\RemoveItem.log", "GuildId = %s, ItemName : %s", nGuildId,  it->data() );
; 561  : 						bResult = TRUE;

  0019c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nSize$204988[esp+36]
  001a0	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _bResult$[esp+36], 1
$L204992:
  001a8	8b 54 24 2c	 mov	 edx, DWORD PTR tv723[esp+32]
  001ac	45		 inc	 ebp
  001ad	81 c2 a0 00 00
	00		 add	 edx, 160		; 000000a0H
  001b3	3b e9		 cmp	 ebp, ecx
  001b5	89 6c 24 10	 mov	 DWORD PTR _i$204990[esp+36], ebp
  001b9	89 54 24 2c	 mov	 DWORD PTR tv723[esp+32], edx
  001bd	0f 8c 9f fe ff
	ff		 jl	 $L204991

; 538  : 			CItemElem* pItemElem;
; 539  : 			for( int i = 0 ; i < nSize; i++ )

  001c3	8b 74 24 20	 mov	 esi, DWORD PTR _this$[esp+36]
$L204984:

; 529  : 	BOOL bResult = FALSE;
; 530  : 	SET_STRING::iterator it;
; 531  : 	for( it = m_RemoveItem_List.begin() ; it != m_RemoveItem_List.end() ; ++it )

  001c7	8a 47 29	 mov	 al, BYTE PTR [edi+41]
  001ca	84 c0		 test	 al, al
  001cc	75 45		 jne	 SHORT $L210587
  001ce	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001d1	8a 41 29	 mov	 al, BYTE PTR [ecx+41]
  001d4	84 c0		 test	 al, al
  001d6	75 18		 jne	 SHORT $L210850
  001d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  001da	8a 50 29	 mov	 dl, BYTE PTR [eax+41]
  001dd	84 d2		 test	 dl, dl
  001df	75 0b		 jne	 SHORT $L210576
$L210575:
  001e1	8b c8		 mov	 ecx, eax
  001e3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e5	8a 50 29	 mov	 dl, BYTE PTR [eax+41]
  001e8	84 d2		 test	 dl, dl
  001ea	74 f5		 je	 SHORT $L210575
$L210576:
  001ec	8b f9		 mov	 edi, ecx
  001ee	eb 23		 jmp	 SHORT $L210587
$L210850:
  001f0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001f3	8a 48 29	 mov	 cl, BYTE PTR [eax+41]
  001f6	84 c9		 test	 cl, cl
  001f8	75 17		 jne	 SHORT $L210590
  001fa	8d 9b 00 00 00
	00		 npad	 6
$L210589:
  00200	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  00203	75 0c		 jne	 SHORT $L210590
  00205	8b f8		 mov	 edi, eax
  00207	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0020a	8a 48 29	 mov	 cl, BYTE PTR [eax+41]
  0020d	84 c9		 test	 cl, cl
  0020f	74 ef		 je	 SHORT $L210589
$L210590:
  00211	8b f8		 mov	 edi, eax
$L210587:
  00213	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00216	0f 85 08 fe ff
	ff		 jne	 $L210858

; 562  : 					}
; 563  : 				}
; 564  : 			}		
; 565  : 		}
; 566  : 	}
; 567  : 	return bResult;

  0021c	8b 44 24 14	 mov	 eax, DWORD PTR _bResult$[esp+36]
  00220	5d		 pop	 ebp
  00221	5b		 pop	 ebx
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi

; 568  : }

  00224	83 c4 14	 add	 esp, 20			; 00000014H
  00227	c2 10 00	 ret	 16			; 00000010H
$L210854:
  0022a	5f		 pop	 edi

; 562  : 					}
; 563  : 				}
; 564  : 			}		
; 565  : 		}
; 566  : 	}
; 567  : 	return bResult;

  0022b	8b c1		 mov	 eax, ecx
  0022d	5e		 pop	 esi

; 568  : }

  0022e	83 c4 14	 add	 esp, 20			; 00000014H
  00231	c2 10 00	 ret	 16			; 00000010H
?RemoveItemGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@PAH1@Z ENDP ; CDbManager::RemoveItemGuildBank
_TEXT	ENDS
PUBLIC	?RemoveInventoryBankList@CDbManager@@QAEHPADPAVCMover@@PAH2@Z ; CDbManager::RemoveInventoryBankList
; Function compile flags: /Ogty
;	COMDAT ?RemoveInventoryBankList@CDbManager@@QAEHPADPAVCMover@@PAH2@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_pMover$ = 12						; size = 4
_nCountItem0$ = 16					; size = 4
_nCountItem1$ = 20					; size = 4
?RemoveInventoryBankList@CDbManager@@QAEHPADPAVCMover@@PAH2@Z PROC NEAR ; CDbManager::RemoveInventoryBankList, COMDAT
; _this$ = ecx

; 571  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 572  : 	// RemoveItem
; 573  : 	BOOL bUpdate = FALSE;
; 574  : 	if( prj.IsConvMode( REMOVE_ITEM_ALL ) )

  00004	6a 04		 push	 4
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000b	33 ff		 xor	 edi, edi
  0000d	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00012	85 c0		 test	 eax, eax
  00014	74 1b		 je	 SHORT $L210861

; 575  : 		bUpdate = RemoveItemInvenBank( pMover, nCountItem0, nCountItem1 );

  00016	8b 44 24 18	 mov	 eax, DWORD PTR _nCountItem1$[esp+4]
  0001a	8b 4c 24 14	 mov	 ecx, DWORD PTR _nCountItem0$[esp+4]
  0001e	8b 54 24 10	 mov	 edx, DWORD PTR _pMover$[esp+4]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?RemoveItemInvenBank@CDbManager@@QAEHPAVCMover@@PAH1@Z ; CDbManager::RemoveItemInvenBank
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 578  : }

  0002e	c2 10 00	 ret	 16			; 00000010H
$L210861:

; 576  : 
; 577  : 	return bUpdate;

  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 578  : }

  00035	c2 10 00	 ret	 16			; 00000010H
?RemoveInventoryBankList@CDbManager@@QAEHPADPAVCMover@@PAH2@Z ENDP ; CDbManager::RemoveInventoryBankList
_TEXT	ENDS
PUBLIC	?InventoryBankConv@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z ; CDbManager::InventoryBankConv
; Function compile flags: /Ogty
;	COMDAT ?InventoryBankConv@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z
_TEXT	SEGMENT
_nCountItem1$ = -8					; size = 4
_nCountItem0$ = -4					; size = 4
_pszSQL$ = 8						; size = 4
_pMover$ = 12						; size = 4
_pQueryChar$ = 16					; size = 4
_pQuerySave$ = 20					; size = 4
?InventoryBankConv@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z PROC NEAR ; CDbManager::InventoryBankConv, COMDAT
; _this$ = ecx

; 673  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 674  : 	int nCountItem0 = 0;
; 675  : 	int nCountItem1 = 0;
; 676  : 	BOOL bUpdateRemove = FALSE;
; 677  : 	BOOL bUpdatePiercingConfirm = FALSE;
; 678  : 
; 679  : 	bUpdateRemove = RemoveInventoryBankList( pszSQL, pMover, &nCountItem0, &nCountItem1 );

  00008	6a 04		 push	 4
  0000a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000f	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _nCountItem0$[esp+24], 0
  00017	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _nCountItem1$[esp+24], 0
  0001f	33 f6		 xor	 esi, esi
  00021	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00026	85 c0		 test	 eax, eax
  00028	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pMover$[esp+16]
  0002c	74 39		 je	 SHORT $L205090
  0002e	8d 44 24 0c	 lea	 eax, DWORD PTR _nCountItem1$[esp+20]
  00032	50		 push	 eax
  00033	8d 4c 24 14	 lea	 ecx, DWORD PTR _nCountItem0$[esp+24]
  00037	51		 push	 ecx
  00038	53		 push	 ebx
  00039	8b cf		 mov	 ecx, edi
  0003b	e8 00 00 00 00	 call	 ?RemoveItemInvenBank@CDbManager@@QAEHPAVCMover@@PAH1@Z ; CDbManager::RemoveItemInvenBank
  00040	8b f0		 mov	 esi, eax

; 680  : 	if( bUpdateRemove )

  00042	85 f6		 test	 esi, esi
  00044	74 21		 je	 SHORT $L205090

; 681  : 		RemoveInventoryBankListPanya( pszSQL, pMover, pQueryChar, pQuerySave, nCountItem0, nCountItem1 );

  00046	8b 54 24 0c	 mov	 edx, DWORD PTR _nCountItem1$[esp+20]
  0004a	8b 44 24 10	 mov	 eax, DWORD PTR _nCountItem0$[esp+20]
  0004e	8b 4c 24 24	 mov	 ecx, DWORD PTR _pQuerySave$[esp+16]
  00052	52		 push	 edx
  00053	8b 54 24 24	 mov	 edx, DWORD PTR _pQueryChar$[esp+20]
  00057	50		 push	 eax
  00058	8b 44 24 20	 mov	 eax, DWORD PTR _pszSQL$[esp+24]
  0005c	51		 push	 ecx
  0005d	52		 push	 edx
  0005e	53		 push	 ebx
  0005f	50		 push	 eax
  00060	8b cf		 mov	 ecx, edi
  00062	e8 00 00 00 00	 call	 ?RemoveInventoryBankListPanya@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2HH@Z ; CDbManager::RemoveInventoryBankListPanya
$L205090:

; 682  : 	bUpdatePiercingConfirm = PiercingConfirmInventoryBank( pMover );

  00067	53		 push	 ebx
  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ?PiercingConfirmInventoryBank@CDbManager@@QAEHPAVCMover@@@Z ; CDbManager::PiercingConfirmInventoryBank
  0006f	5f		 pop	 edi

; 683  : 
; 684  : 	if( bUpdateRemove || bUpdatePiercingConfirm )

  00070	85 f6		 test	 esi, esi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	75 0a		 jne	 SHORT $L205092
  00076	85 c0		 test	 eax, eax
  00078	75 06		 jne	 SHORT $L205092

; 686  : 	else
; 687  : 		return FALSE;
; 688  : }

  0007a	83 c4 08	 add	 esp, 8
  0007d	c2 10 00	 ret	 16			; 00000010H
$L205092:

; 685  : 		return TRUE;

  00080	b8 01 00 00 00	 mov	 eax, 1

; 686  : 	else
; 687  : 		return FALSE;
; 688  : }

  00085	83 c4 08	 add	 esp, 8
  00088	c2 10 00	 ret	 16			; 00000010H
?InventoryBankConv@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z ENDP ; CDbManager::InventoryBankConv
_TEXT	ENDS
PUBLIC	?push_back@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ; std::list<void *,std::allocator<void *> >::push_back
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?push_back@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z PROC NEAR ; std::list<void *,std::allocator<void *> >::push_back, COMDAT
; _this$ = ecx

; 481  : 		_Insert(end(), _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z ; std::list<void *,std::allocator<void *> >::_Buynode
  00019	6a 01		 push	 1
  0001b	8b ce		 mov	 ecx, esi
  0001d	8b d8		 mov	 ebx, eax
  0001f	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::list<void *,std::allocator<void *> >::_Incsize
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	89 1a		 mov	 DWORD PTR [edx], ebx
  0002e	5b		 pop	 ebx

; 482  : 		}

  0002f	c2 04 00	 ret	 4
?push_back@?$list@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ENDP ; std::list<void *,std::allocator<void *> >::push_back
_TEXT	ENDS
PUBLIC	?RemoveGuildBankList@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAH2@Z ; CDbManager::RemoveGuildBankList
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
;	COMDAT ?RemoveGuildBankList@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAH2@Z
_TEXT	SEGMENT
_pszSQL$ = 8						; size = 4
_nGuildId$ = 12						; size = 4
_GuildBank$ = 16					; size = 4
_nCountItem0$ = 20					; size = 4
_nCountItem1$ = 24					; size = 4
?RemoveGuildBankList@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAH2@Z PROC NEAR ; CDbManager::RemoveGuildBankList, COMDAT
; _this$ = ecx

; 411  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 412  : 	BOOL bUpdate = FALSE;
; 413  : 	if( prj.IsConvMode( REMOVE_ITEM_ALL ) )

  00004	6a 04		 push	 4
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000b	33 ff		 xor	 edi, edi
  0000d	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  00012	85 c0		 test	 eax, eax
  00014	74 20		 je	 SHORT $L210922

; 414  : 		bUpdate = RemoveItemGuildBank( nGuildId, GuildBank, nCountItem0, nCountItem1 );

  00016	8b 44 24 1c	 mov	 eax, DWORD PTR _nCountItem1$[esp+4]
  0001a	8b 4c 24 18	 mov	 ecx, DWORD PTR _nCountItem0$[esp+4]
  0001e	8b 54 24 14	 mov	 edx, DWORD PTR _GuildBank$[esp+4]
  00022	50		 push	 eax
  00023	8b 44 24 14	 mov	 eax, DWORD PTR _nGuildId$[esp+8]
  00027	51		 push	 ecx
  00028	52		 push	 edx
  00029	50		 push	 eax
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?RemoveItemGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@PAH1@Z ; CDbManager::RemoveItemGuildBank
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 417  : }

  00033	c2 14 00	 ret	 20			; 00000014H
$L210922:

; 415  : 	
; 416  : 	return bUpdate;

  00036	8b c7		 mov	 eax, edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 417  : }

  0003a	c2 14 00	 ret	 20			; 00000014H
?RemoveGuildBankList@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAH2@Z ENDP ; CDbManager::RemoveGuildBankList
_TEXT	ENDS
PUBLIC	?GuildBankConv@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z ; CDbManager::GuildBankConv
; Function compile flags: /Ogty
;	COMDAT ?GuildBankConv@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z
_TEXT	SEGMENT
_nCountItem1$ = -8					; size = 4
_nCountItem0$ = -4					; size = 4
_pszSQL$ = 8						; size = 4
_nGuildId$ = 12						; size = 4
_GuildBank$ = 16					; size = 4
_pQueryChar$ = 20					; size = 4
_pQuerySave$ = 24					; size = 4
?GuildBankConv@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z PROC NEAR ; CDbManager::GuildBankConv, COMDAT
; _this$ = ecx

; 691  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 692  : 	int nCountItem0 = 0;

  00009	33 f6		 xor	 esi, esi

; 693  : 	int nCountItem1 = 0;
; 694  : 	BOOL bUpdateRemove = FALSE;
; 695  : 	BOOL bUpdatePiercingConfirm = FALSE;
; 696  : 	
; 697  : 	bUpdateRemove = RemoveGuildBankList( pszSQL, nGuildId, GuildBank, &nCountItem0, &nCountItem1 );

  0000b	6a 04		 push	 4
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00012	89 74 24 18	 mov	 DWORD PTR _nCountItem0$[esp+28], esi
  00016	89 74 24 14	 mov	 DWORD PTR _nCountItem1$[esp+28], esi
  0001a	e8 00 00 00 00	 call	 ?IsConvMode@CProject@@QAEHK@Z ; CProject::IsConvMode
  0001f	85 c0		 test	 eax, eax
  00021	8b 6c 24 24	 mov	 ebp, DWORD PTR _GuildBank$[esp+20]
  00025	8b 5c 24 20	 mov	 ebx, DWORD PTR _nGuildId$[esp+20]
  00029	74 3a		 je	 SHORT $L205106
  0002b	8d 44 24 10	 lea	 eax, DWORD PTR _nCountItem1$[esp+24]
  0002f	50		 push	 eax
  00030	8d 4c 24 18	 lea	 ecx, DWORD PTR _nCountItem0$[esp+28]
  00034	51		 push	 ecx
  00035	55		 push	 ebp
  00036	53		 push	 ebx
  00037	8b cf		 mov	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?RemoveItemGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@PAH1@Z ; CDbManager::RemoveItemGuildBank
  0003e	8b f0		 mov	 esi, eax

; 698  : 	if( bUpdateRemove )

  00040	85 f6		 test	 esi, esi
  00042	74 21		 je	 SHORT $L205106

; 699  : 		RemoveGuildBankListPanya( pszSQL, nGuildId, pQueryChar, pQuerySave, nCountItem0, nCountItem1 );

  00044	8b 54 24 10	 mov	 edx, DWORD PTR _nCountItem1$[esp+24]
  00048	8b 44 24 14	 mov	 eax, DWORD PTR _nCountItem0$[esp+24]
  0004c	8b 4c 24 2c	 mov	 ecx, DWORD PTR _pQuerySave$[esp+20]
  00050	52		 push	 edx
  00051	8b 54 24 2c	 mov	 edx, DWORD PTR _pQueryChar$[esp+24]
  00055	50		 push	 eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR _pszSQL$[esp+28]
  0005a	51		 push	 ecx
  0005b	52		 push	 edx
  0005c	53		 push	 ebx
  0005d	50		 push	 eax
  0005e	8b cf		 mov	 ecx, edi
  00060	e8 00 00 00 00	 call	 ?RemoveGuildBankListPanya@CDbManager@@QAEHPADHPAVCQuery@@1HH@Z ; CDbManager::RemoveGuildBankListPanya
$L205106:

; 700  : 
; 701  : 	bUpdatePiercingConfirm = PiercingConfirmGuildBank( nGuildId, GuildBank );

  00065	55		 push	 ebp
  00066	53		 push	 ebx
  00067	8b cf		 mov	 ecx, edi
  00069	e8 00 00 00 00	 call	 ?PiercingConfirmGuildBank@CDbManager@@QAEHHPAV?$CItemContainer@VCItemElem@@@@@Z ; CDbManager::PiercingConfirmGuildBank
  0006e	5f		 pop	 edi

; 702  : 
; 703  : 	if( bUpdateRemove || bUpdatePiercingConfirm )

  0006f	85 f6		 test	 esi, esi
  00071	5e		 pop	 esi
  00072	5d		 pop	 ebp
  00073	5b		 pop	 ebx
  00074	75 0a		 jne	 SHORT $L205108
  00076	85 c0		 test	 eax, eax
  00078	75 06		 jne	 SHORT $L205108

; 705  : 	else
; 706  : 		return FALSE;
; 707  : 	
; 708  : }

  0007a	83 c4 08	 add	 esp, 8
  0007d	c2 14 00	 ret	 20			; 00000014H
$L205108:

; 704  : 		return TRUE;

  00080	b8 01 00 00 00	 mov	 eax, 1

; 705  : 	else
; 706  : 		return FALSE;
; 707  : 	
; 708  : }

  00085	83 c4 08	 add	 esp, 8
  00088	c2 14 00	 ret	 20			; 00000014H
?GuildBankConv@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z ENDP ; CDbManager::GuildBankConv
_TEXT	ENDS
PUBLIC	??_C@_09PKKCPLIP@bad?5alloc?$AA@		; `string'
PUBLIC	?Create@?$MemPooler@VCMover@@@@IAEXXZ		; MemPooler<CMover>::Create
EXTRN	__imp__VirtualAlloc@16:NEAR
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_09PKKCPLIP@bad?5alloc?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
CONST	SEGMENT
??_C@_09PKKCPLIP@bad?5alloc?$AA@ DB 'bad alloc', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\mempooler.h
CONST	ENDS
;	COMDAT ?Create@?$MemPooler@VCMover@@@@IAEXXZ
_TEXT	SEGMENT
_pMemBlock$ = -4					; size = 4
?Create@?$MemPooler@VCMover@@@@IAEXXZ PROC NEAR		; MemPooler<CMover>::Create, COMDAT
; _this$ = ecx

; 120  : 		{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 121  : #ifdef __VERIFY_MEMPOOL
; 122  : 			return;
; 123  : #endif
; 124  : #ifdef __VM_0819
; 125  : 			Log( "Create" );
; 126  : #endif	// __VM_0819
; 127  : 			const int AllocationSize	= m_nListBlockSize * m_nNumOfBlock;

  00004	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00007	0f af 46 14	 imul	 eax, DWORD PTR [esi+20]
  0000b	57		 push	 edi

; 128  : 			void* pMemBlock		= VirtualAlloc( NULL, AllocationSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );

  0000c	6a 04		 push	 4
  0000e	68 00 30 00 00	 push	 12288			; 00003000H
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16

; 129  : 			ASSERT( pMemBlock );
; 130  : 			if( !pMemBlock )

  0001c	85 c0		 test	 eax, eax
  0001e	89 44 24 08	 mov	 DWORD PTR _pMemBlock$[esp+12], eax
  00022	75 0d		 jne	 SHORT $L184871

; 131  : 				Error( "bad alloc" );

  00024	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09PKKCPLIP@bad?5alloc?$AA@
  00029	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0002e	83 c4 04	 add	 esp, 4
$L184871:
  00031	53		 push	 ebx

; 132  : 			m_ListOfMemBlockPtr.push_back( pMemBlock );

  00032	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00035	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00038	55		 push	 ebp
  00039	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0003c	8d 44 24 10	 lea	 eax, DWORD PTR _pMemBlock$[esp+20]
  00040	50		 push	 eax
  00041	51		 push	 ecx
  00042	53		 push	 ebx
  00043	8b cf		 mov	 ecx, edi
  00045	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAXV?$allocator@PAX@std@@@std@@IAEPAU_Node@?$_List_nod@PAXV?$allocator@PAX@std@@@2@PAU342@0ABQAX@Z ; std::list<void *,std::allocator<void *> >::_Buynode
  0004a	6a 01		 push	 1
  0004c	8b cf		 mov	 ecx, edi
  0004e	8b e8		 mov	 ebp, eax
  00050	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::list<void *,std::allocator<void *> >::_Incsize

; 133  : 			BlockNode* pNode	= reinterpret_cast<BlockNode*>(pMemBlock);
; 134  : 			pNode	= reinterpret_cast<BlockNode*>( ( reinterpret_cast<DWORD>( pNode ) ) + ( m_nNumOfBlock - 1 ) * ( m_nListBlockSize ) );	// set pNode to last

  00055	8b 7c 24 10	 mov	 edi, DWORD PTR _pMemBlock$[esp+20]
  00059	89 6b 04	 mov	 DWORD PTR [ebx+4], ebp
  0005c	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  0005f	89 2a		 mov	 DWORD PTR [edx], ebp
  00061	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00064	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00067	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0006a	0f af c1	 imul	 eax, ecx
  0006d	03 c7		 add	 eax, edi

; 135  : 			for( int i = m_nNumOfBlock - 1; i >= 0; i-- )

  0006f	85 c9		 test	 ecx, ecx
  00071	5d		 pop	 ebp
  00072	5b		 pop	 ebx
  00073	7c 0f		 jl	 SHORT $L184879

; 132  : 			m_ListOfMemBlockPtr.push_back( pMemBlock );

  00075	41		 inc	 ecx
$L184877:

; 136  : 			{
; 137  : 				pNode->pNext	= m_pFreeList;

  00076	8b 16		 mov	 edx, DWORD PTR [esi]
  00078	89 10		 mov	 DWORD PTR [eax], edx

; 138  : 				m_pFreeList	= pNode;
; 139  : 				pNode	= reinterpret_cast<BlockNode*>( ( reinterpret_cast<DWORD>( pNode ) ) - m_nListBlockSize );	// set pNode to previous

  0007a	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0007d	89 06		 mov	 DWORD PTR [esi], eax
  0007f	2b c7		 sub	 eax, edi
  00081	49		 dec	 ecx
  00082	75 f2		 jne	 SHORT $L184877
$L184879:
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 140  : 			}
; 141  : 		}

  00086	59		 pop	 ecx
  00087	c3		 ret	 0
?Create@?$MemPooler@VCMover@@@@IAEXXZ ENDP		; MemPooler<CMover>::Create
_TEXT	ENDS
PUBLIC	?Alloc@?$MemPooler@VCMover@@@@QAEPAVCMover@@XZ	; MemPooler<CMover>::Alloc
; Function compile flags: /Ogty
;	COMDAT ?Alloc@?$MemPooler@VCMover@@@@QAEPAVCMover@@XZ
_TEXT	SEGMENT
?Alloc@?$MemPooler@VCMover@@@@QAEPAVCMover@@XZ PROC NEAR ; MemPooler<CMover>::Alloc, COMDAT
; _this$ = ecx

; 56   : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 57   : #ifdef __VERIFY_MEMPOOL
; 58   : 			return (T*) ::operator new( sizeof(T) );
; 59   : #endif
; 60   : 
; 61   : 			BlockNode* pNode	= NULL;
; 62   : 			T* lpMem	= NULL;
; 63   : 
; 64   : 			EnterCriticalSection( &m_cs );

  00005	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
  00008	53		 push	 ebx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 65   : 
; 66   : 			if( !m_pFreeList )

  0000f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00012	75 07		 jne	 SHORT $L184090

; 67   : 				Create();

  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?Create@?$MemPooler@VCMover@@@@IAEXXZ ; MemPooler<CMover>::Create
$L184090:

; 68   : 
; 69   : 			pNode	= m_pFreeList;

  0001b	8b 3e		 mov	 edi, DWORD PTR [esi]

; 70   : 			m_pFreeList		= m_pFreeList->pNext;
; 71   : 			m_nAllocCount++;

  0001d	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	41		 inc	 ecx

; 72   : 			lpMem	= reinterpret_cast<T*>( pNode + 1 );
; 73   : 
; 74   : 			LeaveCriticalSection( &m_cs );

  00023	53		 push	 ebx
  00024	89 06		 mov	 DWORD PTR [esi], eax
  00026	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0002f	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx

; 75   : 
; 76   : 			return lpMem;
; 77   : 		}

  00035	c3		 ret	 0
?Alloc@?$MemPooler@VCMover@@@@QAEPAVCMover@@XZ ENDP	; MemPooler<CMover>::Alloc
_TEXT	ENDS
PUBLIC	??2CMover@@SAPAXI@Z				; CMover::operator new
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\objects\obj.h
;	COMDAT ??2CMover@@SAPAXI@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
??2CMover@@SAPAXI@Z PROC NEAR				; CMover::operator new, COMDAT

; 1217 : 	void*	operator new( size_t nSize )	{	return CMover::m_pPool->Alloc();	}

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?m_pPool@CMover@@2PAV?$MemPooler@VCMover@@@@A ; CMover::m_pPool
  00008	57		 push	 edi
  00009	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
  0000c	53		 push	 ebx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00013	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00016	75 07		 jne	 SHORT $L211017
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?Create@?$MemPooler@VCMover@@@@IAEXXZ ; MemPooler<CMover>::Create
$L211017:
  0001f	8b 3e		 mov	 edi, DWORD PTR [esi]
  00021	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00024	8b 07		 mov	 eax, DWORD PTR [edi]
  00026	41		 inc	 ecx
  00027	53		 push	 ebx
  00028	89 06		 mov	 DWORD PTR [esi], eax
  0002a	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00033	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	c3		 ret	 0
??2CMover@@SAPAXI@Z ENDP				; CMover::operator new
_TEXT	ENDS
PUBLIC	__real@42c80000
PUBLIC	__real@4f800000
PUBLIC	??_C@_0O@EJJFONGK@ConvItemStart?$AA@		; `string'
PUBLIC	??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@		; `string'
PUBLIC	?ConvItemStart@CDbManager@@QAEHXZ		; CDbManager::ConvItemStart
PUBLIC	??_C@_04OOLLELLG@0?5?$CF?$CF?$AA@		; `string'
PUBLIC	??_C@_0BA@OGBLLJAD@Inventory?0?5Bank?$AA@	; `string'
PUBLIC	??_C@_04FEAGFOMF@?$CFd?5?$CF?$AA@		; `string'
PUBLIC	??_C@_09KPBJBCIO@GuildBank?$AA@			; `string'
PUBLIC	??_C@_09MHDEIN@m_idGuild?$AA@			; `string'
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	??0CQuery@@QAE@XZ:NEAR				; CQuery::CQuery
EXTRN	?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z:NEAR ; CDbManager::GetGuildBank
EXTRN	??0CMover@@QAE@XZ:NEAR				; CMover::CMover
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\dbconvertnew.cpp
xdata$x	SEGMENT
$T211109 DD	0ffffffffH
	DD	FLAT:$L211056
	DD	0ffffffffH
	DD	FLAT:$L211057
	DD	0ffffffffH
	DD	FLAT:$L211058
	DD	0ffffffffH
	DD	FLAT:$L211059
$T211088 DD	019930520H
	DD	04H
	DD	FLAT:$T211109
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0O@EJJFONGK@ConvItemStart?$AA@
CONST	SEGMENT
??_C@_0O@EJJFONGK@ConvItemStart?$AA@ DB 'ConvItemStart', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@
CONST	SEGMENT
??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@ DB '%d / %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOLLELLG@0?5?$CF?$CF?$AA@
CONST	SEGMENT
??_C@_04OOLLELLG@0?5?$CF?$CF?$AA@ DB '0 %%', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OGBLLJAD@Inventory?0?5Bank?$AA@
CONST	SEGMENT
??_C@_0BA@OGBLLJAD@Inventory?0?5Bank?$AA@ DB 'Inventory, Bank', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT ??_C@_04FEAGFOMF@?$CFd?5?$CF?$AA@
CONST	SEGMENT
??_C@_04FEAGFOMF@?$CFd?5?$CF?$AA@ DB '%d %', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KPBJBCIO@GuildBank?$AA@
CONST	SEGMENT
??_C@_09KPBJBCIO@GuildBank?$AA@ DB 'GuildBank', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHDEIN@m_idGuild?$AA@
CONST	SEGMENT
??_C@_09MHDEIN@m_idGuild?$AA@ DB 'm_idGuild', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?ConvItemStart@CDbManager@@QAEHXZ
_TEXT	SEGMENT
_szSQL$ = -656						; size = 4
_nStarted$ = -652					; size = 4
tv534 = -648						; size = 4
tv523 = -648						; size = 4
tv504 = -648						; size = 4
$T211032 = -648						; size = 4
$T211028 = -648						; size = 4
$T211024 = -648						; size = 4
_dwMaxConv$ = -644					; size = 4
tv425 = -640						; size = 4
_GuildBank$205177 = -636				; size = 20
_lpString$ = -616					; size = 300
_lpString1$ = -316					; size = 300
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?ConvItemStart@CDbManager@@QAEHXZ PROC NEAR		; CDbManager::ConvItemStart, COMDAT
; _this$ = ecx

; 711  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?ConvItemStart@CDbManager@@QAEHXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	57		 push	 edi

; 712  : 	int nCount	= 0;
; 713  : 	int nStarted	= 0;

  00026	33 ed		 xor	 ebp, ebp

; 714  : 	DWORD dwMaxConv	= 0;
; 715  : 	char* szSQL	= new char[40960];

  00028	68 00 a0 00 00	 push	 40960			; 0000a000H
  0002d	89 84 24 94 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+676], eax
  00034	8b f1		 mov	 esi, ecx
  00036	89 6c 24 18	 mov	 DWORD PTR _nStarted$[esp+676], ebp
  0003a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0003f	8b d8		 mov	 ebx, eax

; 716  : 	char lpString[300];
; 717  : 	char lpString1[300];
; 718  : 
; 719  : 	CQuery* pQueryChar	= new CQuery;

  00041	68 10 3d 00 00	 push	 15632			; 00003d10H
  00046	89 5c 24 18	 mov	 DWORD PTR _szSQL$[esp+680], ebx
  0004a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004f	83 c4 08	 add	 esp, 8
  00052	89 44 24 18	 mov	 DWORD PTR $T211024[esp+672], eax
  00056	3b c5		 cmp	 eax, ebp
  00058	89 ac 24 9c 02
	00 00		 mov	 DWORD PTR __$EHRec$[esp+680], ebp
  0005f	74 0b		 je	 SHORT $L211025
  00061	8b c8		 mov	 ecx, eax
  00063	e8 00 00 00 00	 call	 ??0CQuery@@QAE@XZ	; CQuery::CQuery
  00068	8b f8		 mov	 edi, eax
  0006a	eb 02		 jmp	 SHORT $L211026
$L211025:
  0006c	33 ff		 xor	 edi, edi
$L211026:

; 720  : 	CQuery* pQuerySave	= new CQuery;

  0006e	68 10 3d 00 00	 push	 15632			; 00003d10H
  00073	c7 84 24 a0 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+684], -1
  0007e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00083	83 c4 04	 add	 esp, 4
  00086	89 44 24 18	 mov	 DWORD PTR $T211028[esp+672], eax
  0008a	3b c5		 cmp	 eax, ebp
  0008c	c7 84 24 9c 02
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+680], 1
  00097	74 09		 je	 SHORT $L211030
  00099	8b c8		 mov	 ecx, eax
  0009b	e8 00 00 00 00	 call	 ??0CQuery@@QAE@XZ	; CQuery::CQuery
  000a0	8b e8		 mov	 ebp, eax
$L211030:

; 721  : 	if( ConvItemConnectDB( pQueryChar, pQuerySave ) == FALSE )

  000a2	55		 push	 ebp
  000a3	57		 push	 edi
  000a4	8b ce		 mov	 ecx, esi
  000a6	c7 84 24 a4 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+688], -1
  000b1	e8 00 00 00 00	 call	 ?ConvItemConnectDB@CDbManager@@QAEHPAVCQuery@@0@Z ; CDbManager::ConvItemConnectDB
  000b6	85 c0		 test	 eax, eax

; 722  : 		return FALSE;

  000b8	0f 84 19 04 00
	00		 je	 $L211107

; 723  : 
; 724  : 	InitConvItemDialog();

  000be	8b ce		 mov	 ecx, esi
  000c0	e8 00 00 00 00	 call	 ?InitConvItemDialog@CDbManager@@QAEXXZ ; CDbManager::InitConvItemDialog

; 725  : 	
; 726  : 	AfxMessageBox( "ConvItemStart", MB_OK );

  000c5	6a 00		 push	 0
  000c7	6a 00		 push	 0
  000c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@EJJFONGK@ConvItemStart?$AA@
  000ce	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 727  : //////////////////////////////////////// Inventory Start ////////////////////////////////////////
; 728  : 	if( ( dwMaxConv = GetMaxInventory( szSQL, pQueryChar, pQuerySave ) ) == 0 )

  000d3	55		 push	 ebp
  000d4	57		 push	 edi
  000d5	53		 push	 ebx
  000d6	8b ce		 mov	 ecx, esi
  000d8	e8 00 00 00 00	 call	 ?GetMaxInventory@CDbManager@@QAEKPADPAVCQuery@@1@Z ; CDbManager::GetMaxInventory
  000dd	8b d8		 mov	 ebx, eax
  000df	85 db		 test	 ebx, ebx
  000e1	89 5c 24 1c	 mov	 DWORD PTR _dwMaxConv$[esp+672], ebx

; 729  : 		return FALSE;

  000e5	0f 84 ec 03 00
	00		 je	 $L211107

; 730  : 
; 731  : 	sprintf( lpString, "%d / %d", 0, dwMaxConv );

  000eb	53		 push	 ebx
  000ec	6a 00		 push	 0
  000ee	8d 44 24 40	 lea	 eax, DWORD PTR _lpString$[esp+680]
  000f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _sprintf
  000fd	83 c4 10	 add	 esp, 16			; 00000010H

; 732  : 	UpdateConvItemDialog( "Inventory, Bank", lpString, "0 %%", 0 );

  00100	6a 00		 push	 0
  00102	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OOLLELLG@0?5?$CF?$CF?$AA@
  00107	8d 4c 24 40	 lea	 ecx, DWORD PTR _lpString$[esp+680]
  0010b	51		 push	 ecx
  0010c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@OGBLLJAD@Inventory?0?5Bank?$AA@
  00111	8b ce		 mov	 ecx, esi
  00113	e8 00 00 00 00	 call	 ?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z ; CDbManager::UpdateConvItemDialog

; 733  : 	if( CreateInvenBankView( szSQL, pQueryChar, pQuerySave ) == FALSE )

  00118	8b 54 24 10	 mov	 edx, DWORD PTR _szSQL$[esp+672]
  0011c	55		 push	 ebp
  0011d	57		 push	 edi
  0011e	52		 push	 edx
  0011f	8b ce		 mov	 ecx, esi
  00121	e8 00 00 00 00	 call	 ?CreateInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::CreateInvenBankView
  00126	85 c0		 test	 eax, eax

; 734  : 		return FALSE;

  00128	0f 84 a9 03 00
	00		 je	 $L211107

; 735  : 	// Inven, Bank Item  
; 736  : 	if( GetInventoryBankView( szSQL, pQueryChar, pQuerySave ) == FALSE )

  0012e	8b 44 24 10	 mov	 eax, DWORD PTR _szSQL$[esp+672]
  00132	55		 push	 ebp
  00133	57		 push	 edi
  00134	50		 push	 eax
  00135	8b ce		 mov	 ecx, esi
  00137	e8 00 00 00 00	 call	 ?GetInventoryBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::GetInventoryBankView
  0013c	85 c0		 test	 eax, eax

; 737  : 		return FALSE;

  0013e	0f 84 93 03 00
	00		 je	 $L211107

; 738  : 	while( pQueryChar->Fetch() )

  00144	8b cf		 mov	 ecx, edi
  00146	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  0014b	85 c0		 test	 eax, eax
  0014d	0f 84 34 01 00
	00		 je	 $L205142
  00153	85 db		 test	 ebx, ebx
  00155	89 5c 24 18	 mov	 DWORD PTR tv534[esp+672], ebx
  00159	db 44 24 18	 fild	 DWORD PTR tv534[esp+672]
  0015d	7d 06		 jge	 SHORT $L211103
  0015f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L211103:
  00165	d9 5c 24 20	 fstp	 DWORD PTR tv425[esp+672]
  00169	eb 05		 jmp	 SHORT $L205141
$L211098:
  0016b	8b 5c 24 1c	 mov	 ebx, DWORD PTR _dwMaxConv$[esp+672]
  0016f	90		 npad	 1
$L205141:

; 739  : 	{
; 740  : 		++nStarted;

  00170	8b 44 24 14	 mov	 eax, DWORD PTR _nStarted$[esp+672]
  00174	40		 inc	 eax

; 741  : 		sprintf( lpString, "%d / %d", nStarted, dwMaxConv );

  00175	53		 push	 ebx
  00176	50		 push	 eax
  00177	8d 4c 24 40	 lea	 ecx, DWORD PTR _lpString$[esp+680]
  0017b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@
  00180	51		 push	 ecx
  00181	89 44 24 24	 mov	 DWORD PTR _nStarted$[esp+688], eax
  00185	e8 00 00 00 00	 call	 _sprintf

; 742  : 		sprintf( lpString1, "%d %", int( float( (float)nStarted / (float)dwMaxConv ) * 100.0f ) );

  0018a	db 44 24 24	 fild	 DWORD PTR _nStarted$[esp+688]
  0018e	d8 74 24 30	 fdiv	 DWORD PTR tv425[esp+688]
  00192	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42c80000
  00198	e8 00 00 00 00	 call	 __ftol2
  0019d	8b d8		 mov	 ebx, eax
  0019f	53		 push	 ebx
  001a0	8d 94 24 78 01
	00 00		 lea	 edx, DWORD PTR _lpString1$[esp+692]
  001a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04FEAGFOMF@?$CFd?5?$CF?$AA@
  001ac	52		 push	 edx
  001ad	e8 00 00 00 00	 call	 _sprintf
  001b2	83 c4 1c	 add	 esp, 28			; 0000001cH

; 743  : 		UpdateConvItemDialog( "Inventory, Bank", lpString, lpString1, (int( float( (float)nStarted / (float)dwMaxConv ) * 100.0f )) );

  001b5	53		 push	 ebx
  001b6	8d 84 24 68 01
	00 00		 lea	 eax, DWORD PTR _lpString1$[esp+676]
  001bd	50		 push	 eax
  001be	8d 4c 24 40	 lea	 ecx, DWORD PTR _lpString$[esp+680]
  001c2	51		 push	 ecx
  001c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@OGBLLJAD@Inventory?0?5Bank?$AA@
  001c8	8b ce		 mov	 ecx, esi
  001ca	e8 00 00 00 00	 call	 ?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z ; CDbManager::UpdateConvItemDialog

; 744  : 		
; 745  : 		CMover* pMover	= new CMover;

  001cf	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?m_pPool@CMover@@2PAV?$MemPooler@VCMover@@@@A ; CMover::m_pPool
  001d5	8d 43 1c	 lea	 eax, DWORD PTR [ebx+28]
  001d8	50		 push	 eax
  001d9	89 44 24 1c	 mov	 DWORD PTR tv523[esp+676], eax
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  001e3	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  001e6	75 07		 jne	 SHORT $L211073
  001e8	8b cb		 mov	 ecx, ebx
  001ea	e8 00 00 00 00	 call	 ?Create@?$MemPooler@VCMover@@@@IAEXXZ ; MemPooler<CMover>::Create
$L211073:
  001ef	8b 03		 mov	 eax, DWORD PTR [ebx]
  001f1	8b 10		 mov	 edx, DWORD PTR [eax]
  001f3	89 13		 mov	 DWORD PTR [ebx], edx
  001f5	ff 43 18	 inc	 DWORD PTR [ebx+24]
  001f8	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  001fb	8b 44 24 18	 mov	 eax, DWORD PTR tv523[esp+672]
  001ff	50		 push	 eax
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00206	89 5c 24 18	 mov	 DWORD PTR $T211032[esp+672], ebx
  0020a	85 db		 test	 ebx, ebx
  0020c	c7 84 24 9c 02
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+680], 2
  00217	74 0b		 je	 SHORT $L211033
  00219	8b cb		 mov	 ecx, ebx
  0021b	e8 00 00 00 00	 call	 ??0CMover@@QAE@XZ	; CMover::CMover
  00220	8b d8		 mov	 ebx, eax
  00222	eb 02		 jmp	 SHORT $L211034
$L211033:
  00224	33 db		 xor	 ebx, ebx
$L211034:

; 746  : 		//GetUserInventoryBank( pMover, pQueryChar );
; 747  : 		// mirchang_100416 VERIFYSTRING use return value
; 748  : 		if( GetUserInventoryBank( pMover, pQueryChar ) == FALSE )

  00226	57		 push	 edi
  00227	53		 push	 ebx
  00228	8b ce		 mov	 ecx, esi
  0022a	c7 84 24 a4 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+688], -1
  00235	e8 00 00 00 00	 call	 ?GetUserInventoryBank@CDbManager@@QAEHPAVCMover@@PAVCQuery@@@Z ; CDbManager::GetUserInventoryBank
  0023a	85 c0		 test	 eax, eax
  0023c	0f 84 f5 00 00
	00		 je	 $L211091

; 752  : 		}
; 753  : 		// mirchang_100416
; 754  : 
; 755  : 		if( InventoryBankConv( szSQL, pMover, pQueryChar, pQuerySave ) ) // SaveItem

  00242	8b 4c 24 10	 mov	 ecx, DWORD PTR _szSQL$[esp+672]
  00246	55		 push	 ebp
  00247	57		 push	 edi
  00248	53		 push	 ebx
  00249	51		 push	 ecx
  0024a	8b ce		 mov	 ecx, esi
  0024c	e8 00 00 00 00	 call	 ?InventoryBankConv@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z ; CDbManager::InventoryBankConv
  00251	85 c0		 test	 eax, eax
  00253	74 17		 je	 SHORT $L205158

; 756  : 		{
; 757  : 			if( SaveUserInventoryBank( szSQL, pMover, pQueryChar, pQuerySave ) == FALSE )

  00255	8b 54 24 10	 mov	 edx, DWORD PTR _szSQL$[esp+672]
  00259	55		 push	 ebp
  0025a	57		 push	 edi
  0025b	53		 push	 ebx
  0025c	52		 push	 edx
  0025d	8b ce		 mov	 ecx, esi
  0025f	e8 00 00 00 00	 call	 ?SaveUserInventoryBank@CDbManager@@QAEHPADPAVCMover@@PAVCQuery@@2@Z ; CDbManager::SaveUserInventoryBank
  00264	85 c0		 test	 eax, eax
  00266	0f 84 de 00 00
	00		 je	 $L211092
$L205158:

; 761  : 			}
; 762  : 		}
; 763  : 		safe_delete( pMover );

  0026c	85 db		 test	 ebx, ebx
  0026e	74 08		 je	 SHORT $L211045
  00270	8b 03		 mov	 eax, DWORD PTR [ebx]
  00272	6a 01		 push	 1
  00274	8b cb		 mov	 ecx, ebx
  00276	ff 10		 call	 DWORD PTR [eax]
$L211045:
  00278	8b cf		 mov	 ecx, edi
  0027a	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  0027f	85 c0		 test	 eax, eax
  00281	0f 85 e4 fe ff
	ff		 jne	 $L211098
$L205142:

; 764  : 	}
; 765  : 	if( DeleteInvenBankView( szSQL, pQueryChar, pQuerySave ) == FALSE )

  00287	8b 4c 24 10	 mov	 ecx, DWORD PTR _szSQL$[esp+672]
  0028b	55		 push	 ebp
  0028c	57		 push	 edi
  0028d	51		 push	 ecx
  0028e	8b ce		 mov	 ecx, esi
  00290	e8 00 00 00 00	 call	 ?DeleteInvenBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::DeleteInvenBankView
  00295	85 c0		 test	 eax, eax

; 766  : 		return FALSE;

  00297	0f 84 3a 02 00
	00		 je	 $L211107

; 767  : 
; 768  : //////////////////////////////////////// GuildBank Start ////////////////////////////////////////
; 769  : 	nStarted = 0;
; 770  : 	if( ( dwMaxConv = GetMaxGuildBank( szSQL, pQueryChar, pQuerySave ) ) == 0 )

  0029d	8b 54 24 10	 mov	 edx, DWORD PTR _szSQL$[esp+672]
  002a1	55		 push	 ebp
  002a2	57		 push	 edi
  002a3	52		 push	 edx
  002a4	8b ce		 mov	 ecx, esi
  002a6	33 db		 xor	 ebx, ebx
  002a8	e8 00 00 00 00	 call	 ?GetMaxGuildBank@CDbManager@@QAEKPADPAVCQuery@@1@Z ; CDbManager::GetMaxGuildBank
  002ad	85 c0		 test	 eax, eax
  002af	89 44 24 1c	 mov	 DWORD PTR _dwMaxConv$[esp+672], eax

; 771  : 		return FALSE;

  002b3	0f 84 1e 02 00
	00		 je	 $L211107

; 772  : 	
; 773  : 	sprintf( lpString, "%d / %d", 0, dwMaxConv );

  002b9	50		 push	 eax
  002ba	53		 push	 ebx
  002bb	8d 44 24 40	 lea	 eax, DWORD PTR _lpString$[esp+680]
  002bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 _sprintf
  002ca	83 c4 10	 add	 esp, 16			; 00000010H

; 774  : 	UpdateConvItemDialog( "GuildBank", lpString, "0 %%", 0 );

  002cd	53		 push	 ebx
  002ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OOLLELLG@0?5?$CF?$CF?$AA@
  002d3	8d 4c 24 40	 lea	 ecx, DWORD PTR _lpString$[esp+680]
  002d7	51		 push	 ecx
  002d8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09KPBJBCIO@GuildBank?$AA@
  002dd	8b ce		 mov	 ecx, esi
  002df	e8 00 00 00 00	 call	 ?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z ; CDbManager::UpdateConvItemDialog

; 775  : 	if( CreateGuildBankView( szSQL, pQueryChar, pQuerySave ) == FALSE )

  002e4	8b 54 24 10	 mov	 edx, DWORD PTR _szSQL$[esp+672]
  002e8	55		 push	 ebp
  002e9	57		 push	 edi
  002ea	52		 push	 edx
  002eb	8b ce		 mov	 ecx, esi
  002ed	e8 00 00 00 00	 call	 ?CreateGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::CreateGuildBankView
  002f2	85 c0		 test	 eax, eax

; 776  : 		return FALSE;

  002f4	0f 84 dd 01 00
	00		 je	 $L211107

; 777  : 	// Inven, Bank Item  
; 778  : 	if( GetGuildBankView( szSQL, pQueryChar, pQuerySave ) == FALSE )

  002fa	8b 44 24 10	 mov	 eax, DWORD PTR _szSQL$[esp+672]
  002fe	55		 push	 ebp
  002ff	57		 push	 edi
  00300	50		 push	 eax
  00301	8b ce		 mov	 ecx, esi
  00303	e8 00 00 00 00	 call	 ?GetGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::GetGuildBankView
  00308	85 c0		 test	 eax, eax

; 779  : 		return FALSE;

  0030a	0f 84 c7 01 00
	00		 je	 $L211107

; 780  : 	
; 781  : 	while( pQueryChar->Fetch() )

  00310	8b cf		 mov	 ecx, edi
  00312	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  00317	85 c0		 test	 eax, eax
  00319	0f 84 3e 01 00
	00		 je	 $L211100
  0031f	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dwMaxConv$[esp+672]
  00323	db 44 24 1c	 fild	 DWORD PTR _dwMaxConv$[esp+672]
  00327	85 c9		 test	 ecx, ecx
  00329	7d 06		 jge	 SHORT $L211106
  0032b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L211106:
  00331	d9 5c 24 20	 fstp	 DWORD PTR tv425[esp+672]
  00335	eb 2a		 jmp	 SHORT $L205171
$L211091:

; 749  : 		{
; 750  : 			safe_delete( pMover );

  00337	85 db		 test	 ebx, ebx
  00339	74 08		 je	 SHORT $L211037
  0033b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0033d	6a 01		 push	 1
  0033f	8b cb		 mov	 ecx, ebx
  00341	ff 12		 call	 DWORD PTR [edx]
$L211037:

; 751  : 			return FALSE;

  00343	33 c0		 xor	 eax, eax
  00345	e9 52 01 00 00	 jmp	 $L205113
$L211092:

; 758  : 			{
; 759  : 				safe_delete( pMover );

  0034a	85 db		 test	 ebx, ebx
  0034c	74 08		 je	 SHORT $L211041
  0034e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00350	6a 01		 push	 1
  00352	8b cb		 mov	 ecx, ebx
  00354	ff 10		 call	 DWORD PTR [eax]
$L211041:

; 760  : 				return FALSE;

  00356	33 c0		 xor	 eax, eax
  00358	e9 3f 01 00 00	 jmp	 $L205113
$L211099:

; 780  : 	
; 781  : 	while( pQueryChar->Fetch() )

  0035d	8b 5c 24 14	 mov	 ebx, DWORD PTR _nStarted$[esp+672]
$L205171:

; 782  : 	{
; 783  : 		++nStarted;
; 784  : 
; 785  : 		sprintf( lpString, "%d / %d", nStarted, dwMaxConv );

  00361	8b 54 24 1c	 mov	 edx, DWORD PTR _dwMaxConv$[esp+672]
  00365	52		 push	 edx
  00366	43		 inc	 ebx
  00367	53		 push	 ebx
  00368	8d 44 24 40	 lea	 eax, DWORD PTR _lpString$[esp+680]
  0036c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07IPKKBMCH@?$CFd?5?1?5?$CFd?$AA@
  00371	50		 push	 eax
  00372	89 5c 24 24	 mov	 DWORD PTR _nStarted$[esp+688], ebx
  00376	e8 00 00 00 00	 call	 _sprintf

; 786  : 		sprintf( lpString1, "%d %", int( float( (float)nStarted / (float)dwMaxConv ) * 100.0f ) );

  0037b	db 44 24 24	 fild	 DWORD PTR _nStarted$[esp+688]
  0037f	d8 74 24 30	 fdiv	 DWORD PTR tv425[esp+688]
  00383	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42c80000
  00389	e8 00 00 00 00	 call	 __ftol2
  0038e	8b d8		 mov	 ebx, eax
  00390	53		 push	 ebx
  00391	8d 8c 24 78 01
	00 00		 lea	 ecx, DWORD PTR _lpString1$[esp+692]
  00398	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04FEAGFOMF@?$CFd?5?$CF?$AA@
  0039d	51		 push	 ecx
  0039e	e8 00 00 00 00	 call	 _sprintf
  003a3	83 c4 1c	 add	 esp, 28			; 0000001cH

; 787  : 		UpdateConvItemDialog( "GuildBank", lpString, lpString1, (int( float( (float)nStarted / (float)dwMaxConv ) * 100.0f )) );

  003a6	53		 push	 ebx
  003a7	8d 94 24 68 01
	00 00		 lea	 edx, DWORD PTR _lpString1$[esp+676]
  003ae	52		 push	 edx
  003af	8d 44 24 40	 lea	 eax, DWORD PTR _lpString$[esp+680]
  003b3	50		 push	 eax
  003b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09KPBJBCIO@GuildBank?$AA@
  003b9	8b ce		 mov	 ecx, esi
  003bb	e8 00 00 00 00	 call	 ?UpdateConvItemDialog@CDbManager@@QAEXPAD00H@Z ; CDbManager::UpdateConvItemDialog

; 788  : 			
; 789  : 		CItemContainer<CItemElem>	GuildBank;	//  

  003c0	33 c0		 xor	 eax, eax
  003c2	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _GuildBank$205177[esp+672], OFFSET FLAT:??_7?$CItemContainer@VCItemElem@@@@6B@
  003ca	89 44 24 30	 mov	 DWORD PTR _GuildBank$205177[esp+684], eax
  003ce	89 44 24 28	 mov	 DWORD PTR _GuildBank$205177[esp+676], eax

; 790  : 		int							nGuildId	= 0;
; 791  : 	
; 792  : 		GuildBank.SetItemContainer( ITYPE_ITEM, MAX_GUILDBANK );

  003d2	6a ff		 push	 -1
  003d4	6a 2a		 push	 42			; 0000002aH
  003d6	50		 push	 eax
  003d7	8d 4c 24 30	 lea	 ecx, DWORD PTR _GuildBank$205177[esp+684]
  003db	c7 84 24 a8 02
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+692], 3
  003e6	e8 00 00 00 00	 call	 ?SetItemContainer@?$CItemContainer@VCItemElem@@@@QAEXKKK@Z ; CItemContainer<CItemElem>::SetItemContainer

; 793  : 		nGuildId		= pQueryChar->GetInt( "m_idGuild" );

  003eb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09MHDEIN@m_idGuild?$AA@
  003f0	8b cf		 mov	 ecx, edi
  003f2	e8 00 00 00 00	 call	 ?GetInt@CQuery@@QAEHPAD@Z ; CQuery::GetInt

; 794  : 		GetGuildBank( &GuildBank, pQueryChar );

  003f7	57		 push	 edi
  003f8	8d 4c 24 28	 lea	 ecx, DWORD PTR _GuildBank$205177[esp+676]
  003fc	51		 push	 ecx
  003fd	8b ce		 mov	 ecx, esi
  003ff	8b d8		 mov	 ebx, eax
  00401	e8 00 00 00 00	 call	 ?GetGuildBank@CDbManager@@QAEXPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@@Z ; CDbManager::GetGuildBank

; 795  : 		
; 796  : 		if( GuildBankConv( szSQL, nGuildId, &GuildBank, pQueryChar, pQuerySave ) )

  00406	8b 44 24 10	 mov	 eax, DWORD PTR _szSQL$[esp+672]
  0040a	55		 push	 ebp
  0040b	57		 push	 edi
  0040c	8d 54 24 2c	 lea	 edx, DWORD PTR _GuildBank$205177[esp+680]
  00410	52		 push	 edx
  00411	53		 push	 ebx
  00412	50		 push	 eax
  00413	8b ce		 mov	 ecx, esi
  00415	e8 00 00 00 00	 call	 ?GuildBankConv@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z ; CDbManager::GuildBankConv
  0041a	85 c0		 test	 eax, eax
  0041c	74 1c		 je	 SHORT $L205181

; 797  : 		{
; 798  : 			if( SaveConvGuildBank( szSQL, nGuildId, &GuildBank, pQueryChar, pQuerySave ) == FALSE )

  0041e	8b 54 24 10	 mov	 edx, DWORD PTR _szSQL$[esp+672]
  00422	55		 push	 ebp
  00423	57		 push	 edi
  00424	8d 4c 24 2c	 lea	 ecx, DWORD PTR _GuildBank$205177[esp+680]
  00428	51		 push	 ecx
  00429	53		 push	 ebx
  0042a	52		 push	 edx
  0042b	8b ce		 mov	 ecx, esi
  0042d	e8 00 00 00 00	 call	 ?SaveConvGuildBank@CDbManager@@QAEHPADHPAV?$CItemContainer@VCItemElem@@@@PAVCQuery@@2@Z ; CDbManager::SaveConvGuildBank
  00432	85 c0		 test	 eax, eax
  00434	0f 84 89 00 00
	00		 je	 $L211093
$L205181:

; 800  : 		}
; 801  : 	}

  0043a	8d 4c 24 24	 lea	 ecx, DWORD PTR _GuildBank$205177[esp+672]
  0043e	c7 84 24 9c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+680], -1
  00449	e8 00 00 00 00	 call	 ??1?$CItemContainer@VCItemElem@@@@UAE@XZ ; CItemContainer<CItemElem>::~CItemContainer<CItemElem>
  0044e	8b cf		 mov	 ecx, edi
  00450	e8 00 00 00 00	 call	 ?Fetch@CQuery@@QAEHXZ	; CQuery::Fetch
  00455	85 c0		 test	 eax, eax
  00457	0f 85 00 ff ff
	ff		 jne	 $L211099
$L211100:

; 802  : 	if( DeleteGuildBankView( szSQL, pQueryChar, pQuerySave ) == FALSE )

  0045d	8b 44 24 10	 mov	 eax, DWORD PTR _szSQL$[esp+672]
  00461	55		 push	 ebp
  00462	57		 push	 edi
  00463	50		 push	 eax
  00464	8b ce		 mov	 ecx, esi
  00466	e8 00 00 00 00	 call	 ?DeleteGuildBankView@CDbManager@@QAEHPADPAVCQuery@@1@Z ; CDbManager::DeleteGuildBankView
  0046b	85 c0		 test	 eax, eax

; 803  : 		return FALSE;

  0046d	74 68		 je	 SHORT $L211107

; 804  : 	
; 805  : 	SAFE_DELETE( pQueryChar ); SAFE_DELETE( pQuerySave );

  0046f	85 ff		 test	 edi, edi
  00471	74 10		 je	 SHORT $L211050
  00473	8b cf		 mov	 ecx, edi
  00475	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0047a	57		 push	 edi
  0047b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00480	83 c4 04	 add	 esp, 4
$L211050:
  00483	85 ed		 test	 ebp, ebp
  00485	74 10		 je	 SHORT $L211054
  00487	8b cd		 mov	 ecx, ebp
  00489	e8 00 00 00 00	 call	 ??1CQuery@@QAE@XZ	; CQuery::~CQuery
  0048e	55		 push	 ebp
  0048f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00494	83 c4 04	 add	 esp, 4
$L211054:

; 806  : 	return TRUE;

  00497	b8 01 00 00 00	 mov	 eax, 1
$L205113:

; 807  : }

  0049c	8b 8c 24 94 02
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+672]
  004a3	5f		 pop	 edi
  004a4	5e		 pop	 esi
  004a5	5d		 pop	 ebp
  004a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  004ad	8b 8c 24 84 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+660]
  004b4	5b		 pop	 ebx
  004b5	33 cc		 xor	 ecx, esp
  004b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bc	81 c4 90 02 00
	00		 add	 esp, 656		; 00000290H
  004c2	c3		 ret	 0
$L211093:

; 799  : 				return FALSE;

  004c3	8d 4c 24 24	 lea	 ecx, DWORD PTR _GuildBank$205177[esp+672]
  004c7	c7 84 24 9c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+680], -1
  004d2	e8 00 00 00 00	 call	 ??1?$CItemContainer@VCItemElem@@@@UAE@XZ ; CItemContainer<CItemElem>::~CItemContainer<CItemElem>
$L211107:
  004d7	33 c0		 xor	 eax, eax
  004d9	eb c1		 jmp	 SHORT $L205113
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L211056:
  00000	8b 85 78 fd ff
	ff		 mov	 eax, DWORD PTR $T211024[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
$L211057:
  0000e	8b 85 78 fd ff
	ff		 mov	 eax, DWORD PTR $T211028[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
$L211058:
  0001c	8b 85 78 fd ff
	ff		 mov	 eax, DWORD PTR $T211032[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3CMover@@SAXPAX@Z	; CMover::operator delete
  00028	59		 pop	 ecx
  00029	c3		 ret	 0
$L211059:
  0002a	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _GuildBank$205177[ebp]
  00030	e9 00 00 00 00	 jmp	 ??1?$CItemContainer@VCItemElem@@@@UAE@XZ ; CItemContainer<CItemElem>::~CItemContainer<CItemElem>
__ehhandler$?ConvItemStart@CDbManager@@QAEHXZ:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T211088
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ConvItemStart@CDbManager@@QAEHXZ ENDP			; CDbManager::ConvItemStart
END
