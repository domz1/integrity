; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Database\Query.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NOJCDH@?$CF02x?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PHEABAGN@SQLMoreResults?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OAGAMKLF@00000?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?Decrpyt@@YAXPAEPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPWDFromToken@@YAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CQuery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CQuery@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisConnect@CQuery@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableConnectionPooling@CQuery@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Connect@CQuery@@QAEHHPAD0PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exec@CQuery@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoreResults@CQuery@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fetch@CQuery@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CQuery@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindCol@CQuery@@AAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt@CQuery@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt@CQuery@@QAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt64@CQuery@@QAE_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt64@CQuery@@QAE_JPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFloat@CQuery@@QAEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFloat@CQuery@@QAEMPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChar@CQuery@@QAEDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChar@CQuery@@QAEDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintDiag@CQuery@@QAEXPBDF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadBlob@CQuery@@QAEHPBDPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteBlob@CQuery@@QAEXPBDPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteLogFile@CQuery@@QAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareFetch@CQuery@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Execute@CQuery@@QAAHPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Decrpyt@@YAXPAEPAD@Z				; Decrpyt
EXTRN	_des3_set_3keys:NEAR
EXTRN	_des3_decrypt:NEAR
;	COMDAT ?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_database\query.cpp
_DATA	SEGMENT
?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA DB 032H		; `Decrpyt'::`2'::keys
	DB	089H
	DB	045H
	DB	09aH
	DB	089H
	DB	0abH
	DB	0cdH
	DB	011H
	DB	023H
	DB	045H
	DB	067H
	DB	089H
	DB	0abH
	DB	0cdH
	DB	0efH
	DB	01H
	DB	01fH
	DB	067H
	DB	089H
	DB	054H
	DB	0cdH
	DB	0efH
	DB	00H
	DB	023H
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?Decrpyt@@YAXPAEPAD@Z
_TEXT	SEGMENT
_ctx3$ = -768						; size = 768
_pEncrypted$ = 8					; size = 4
_szResult$ = 12						; size = 4
?Decrpyt@@YAXPAEPAD@Z PROC NEAR				; Decrpyt, COMDAT

; 14   : {

  00000	81 ec 00 03 00
	00		 sub	 esp, 768		; 00000300H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15   : 	static unsigned char keys[3][8] =
; 16   : 	{
; 17   : 		{ 0x32, 0x89, 0x45, 0x9A, 0x89, 0xAB, 0xCD, 0x11 },
; 18   : 		{ 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01 },
; 19   : 		{ 0x1F, 0x67, 0x89, 0x54, 0xCD, 0xEF, 0x00, 0x23 }
; 20   : 	};
; 21   : 
; 22   :     des3_context ctx3;
; 23   :     des3_set_3keys( &ctx3, keys[0], keys[1], keys[2] );

  00009	68 10 00 00 00	 push	 OFFSET FLAT:?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA+16
  0000e	68 08 00 00 00	 push	 OFFSET FLAT:?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA+8
  00013	8d 44 24 14	 lea	 eax, DWORD PTR _ctx3$[esp+788]
  00017	68 00 00 00 00	 push	 OFFSET FLAT:?keys@?1??Decrpyt@@YAXPAEPAD@Z@4PAY07EA
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _des3_set_3keys
  00022	8b b4 24 20 03
	00 00		 mov	 esi, DWORD PTR _pEncrypted$[esp+792]

; 24   : 
; 25   :     unsigned char* input = pEncrypted;
; 26   :     unsigned char* result = (unsigned char*)szResult;
; 27   : 	for( int i=0; i<3; i++ )

  00029	8b bc 24 24 03
	00 00		 mov	 edi, DWORD PTR _szResult$[esp+792]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	2b fe		 sub	 edi, esi
  00035	bb 03 00 00 00	 mov	 ebx, 3
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L186761:

; 28   : 		des3_decrypt( &ctx3, input + i*8, result + i*8 );

  00040	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  00043	51		 push	 ecx
  00044	8d 54 24 10	 lea	 edx, DWORD PTR _ctx3$[esp+784]
  00048	56		 push	 esi
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _des3_decrypt
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	83 c6 08	 add	 esi, 8
  00055	4b		 dec	 ebx
  00056	75 e8		 jne	 SHORT $L186761
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 29   : }

  0005b	81 c4 00 03 00
	00		 add	 esp, 768		; 00000300H
  00061	c3		 ret	 0
?Decrpyt@@YAXPAEPAD@Z ENDP				; Decrpyt
_TEXT	ENDS
PUBLIC	?GetPWDFromToken@@YAHPBDPAD@Z			; GetPWDFromToken
PUBLIC	??_C@_04NOJCDH@?$CF02x?$AA@			; `string'
EXTRN	_sscanf:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT ??_C@_04NOJCDH@?$CF02x?$AA@
CONST	SEGMENT
??_C@_04NOJCDH@?$CF02x?$AA@ DB '%02x', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetPWDFromToken@@YAHPBDPAD@Z
_TEXT	SEGMENT
_szBuf$186771 = -264					; size = 3
_byPWD$186770 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szToken$ = 8						; size = 4
_szPWD$ = 12						; size = 4
?GetPWDFromToken@@YAHPBDPAD@Z PROC NEAR			; GetPWDFromToken, COMDAT

; 32   : {

  00000	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	53		 push	 ebx
  0000e	8b 9c 24 10 01
	00 00		 mov	 ebx, DWORD PTR _szToken$[esp+264]
  00015	55		 push	 ebp
  00016	8b ac 24 18 01
	00 00		 mov	 ebp, DWORD PTR _szPWD$[esp+268]
  0001d	89 84 24 0c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+272], eax
  00024	56		 push	 esi

; 33   : 
; 34   : 	int nCount = strlen( szToken ) / 2;

  00025	8b c3		 mov	 eax, ebx
  00027	57		 push	 edi
  00028	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0002b	33 d2		 xor	 edx, edx
  0002d	8d 49 00	 npad	 3
$L187325:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	3a ca		 cmp	 cl, dl
  00035	75 f9		 jne	 SHORT $L187325
  00037	2b c6		 sub	 eax, esi
  00039	d1 e8		 shr	 eax, 1
  0003b	8b f8		 mov	 edi, eax

; 35   : 	if( nCount > 0 )

  0003d	3b fa		 cmp	 edi, edx
  0003f	7e 49		 jle	 SHORT $L186769

; 36   : 	{
; 37   : 		BYTE byPWD[256];
; 38   : 		char szBuf[3] = {0, };
; 39   : 		for( int i=0; i<nCount; i++ )

  00041	33 f6		 xor	 esi, esi
  00043	3b fa		 cmp	 edi, edx
  00045	88 54 24 10	 mov	 BYTE PTR _szBuf$186771[esp+280], dl
  00049	66 89 54 24 11	 mov	 WORD PTR _szBuf$186771[esp+281], dx
  0004e	7e 25		 jle	 SHORT $L186775
$L186773:

; 40   : 		{
; 41   : 			memcpy( szBuf, szToken + i*2, 2 );						

  00050	66 8b 04 73	 mov	 ax, WORD PTR [ebx+esi*2]

; 42   : 			sscanf( szBuf, "%02x", (byPWD + i) );

  00054	8d 4c 34 14	 lea	 ecx, DWORD PTR _byPWD$186770[esp+esi+280]
  00058	51		 push	 ecx
  00059	8d 54 24 14	 lea	 edx, DWORD PTR _szBuf$186771[esp+284]
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04NOJCDH@?$CF02x?$AA@
  00062	52		 push	 edx
  00063	66 89 44 24 1c	 mov	 WORD PTR _szBuf$186771[esp+292], ax
  00068	e8 00 00 00 00	 call	 _sscanf
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00070	46		 inc	 esi
  00071	3b f7		 cmp	 esi, edi
  00073	7c db		 jl	 SHORT $L186773
$L186775:

; 43   : 		}
; 44   : 		Decrpyt( byPWD, szPWD );

  00075	8d 44 24 14	 lea	 eax, DWORD PTR _byPWD$186770[esp+280]
  00079	55		 push	 ebp
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?Decrpyt@@YAXPAEPAD@Z	; Decrpyt
  00080	83 c4 08	 add	 esp, 8

; 45   : 		return TRUE;

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	eb 02		 jmp	 SHORT $L186767
$L186769:

; 46   : 	}
; 47   : 	return FALSE;

  0008a	33 c0		 xor	 eax, eax
$L186767:

; 48   : /*
; 49   : 	int i;
; 50   : 	static unsigned char keys[3][8] =
; 51   : 	{
; 52   : 		{ 0x32, 0x89, 0x45, 0x9A, 0x89, 0xAB, 0xCD, 0x11 },
; 53   : 		{ 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01 },
; 54   : 		{ 0x1F, 0x67, 0x89, 0x54, 0xCD, 0xEF, 0x00, 0x23 }
; 55   : 	};
; 56   : 
; 57   :     des3_context ctx3;
; 58   :     des3_set_3keys( &ctx3, keys[0], keys[1], keys[2] );
; 59   : 
; 60   : 	{
; 61   : 		// uncomment this block to make encrypted password
; 62   : 		// unsigned char input[24] = { '1', '2', };       // original password
; 63   : 		unsigned char input[24] = {0, };       // original password
; 64   : 		unsigned char output[24];
; 65   : 		
; 66   : 		strcpy( (char*)input, szToken );
; 67   : 
; 68   : 		for( i=0; i<3; i++ )
; 69   : 		{
; 70   : 			unsigned char buf[8] = { 0, };
; 71   : 			memcpy( buf, input+i*8, 8 );
; 72   : 			des3_encrypt( &ctx3, buf, output + i*8 );
; 73   : 		}
; 74   : 
; 75   : 		char szBuffer[256] = {0, };
; 76   : 		for( i=0; i<24; i++ )
; 77   : 			sprintf( szBuffer+i*2, "%02X", output[i] );
; 78   : 		OutputDebugString( szBuffer );
; 79   : 		
; 80   : 	}
; 81   : 	OutputDebugString( "\n" );
; 82   : */
; 83   : 	return TRUE;
; 84   : }

  0008c	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+280]
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5d		 pop	 ebp
  00096	5b		 pop	 ebx
  00097	33 cc		 xor	 ecx, esp
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  000a4	c3		 ret	 0
?GetPWDFromToken@@YAHPBDPAD@Z ENDP			; GetPWDFromToken
_TEXT	ENDS
PUBLIC	??0CQuery@@QAE@XZ				; CQuery::CQuery
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
; Function compile flags: /Ogty
;	COMDAT ??0CQuery@@QAE@XZ
_TEXT	SEGMENT
??0CQuery@@QAE@XZ PROC NEAR				; CQuery::CQuery, COMDAT
; _this$ = ecx

; 88   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 89   : 	hStmt	= NULL;

  00002	33 c0		 xor	 eax, eax
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
  00007	89 87 08 07 00
	00		 mov	 DWORD PTR [edi+1800], eax

; 90   : 	hDbc	= NULL;
; 91   : 	hDbc	= NULL;

  0000d	89 87 04 03 00
	00		 mov	 DWORD PTR [edi+772], eax

; 92   : 	hEnv	= NULL;

  00013	89 87 00 03 00
	00		 mov	 DWORD PTR [edi+768], eax
  00019	8d b7 08 03 00
	00		 lea	 esi, DWORD PTR [edi+776]
  0001f	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
$L186781:

; 93   : 
; 94   : 	for( int i = 0; i < MAXCOL; i++ )
; 95   : 		Col[i]	= new char[8192];

  00024	68 00 20 00 00	 push	 8192			; 00002000H
  00029	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002e	89 06		 mov	 DWORD PTR [esi], eax
  00030	83 c4 04	 add	 esp, 4
  00033	83 c6 04	 add	 esi, 4
  00036	4b		 dec	 ebx
  00037	75 eb		 jne	 SHORT $L186781

; 96   : }

  00039	8b c7		 mov	 eax, edi
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	c3		 ret	 0
??0CQuery@@QAE@XZ ENDP					; CQuery::CQuery
_TEXT	ENDS
PUBLIC	??1CQuery@@QAE@XZ				; CQuery::~CQuery
EXTRN	_SQLDisconnect@4:NEAR
EXTRN	_SQLFreeHandle@8:NEAR
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogty
;	COMDAT ??1CQuery@@QAE@XZ
_TEXT	SEGMENT
??1CQuery@@QAE@XZ PROC NEAR				; CQuery::~CQuery, COMDAT
; _this$ = ecx

; 100  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 101  : 	if (hStmt)	SQLFreeHandle(SQL_HANDLE_STMT,hStmt);

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	85 c0		 test	 eax, eax
  0000b	57		 push	 edi
  0000c	74 08		 je	 SHORT $L186789
  0000e	50		 push	 eax
  0000f	6a 03		 push	 3
  00011	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L186789:

; 102  : 	if (hDbc)	SQLDisconnect(hDbc);

  00016	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  0001c	85 c0		 test	 eax, eax
  0001e	74 06		 je	 SHORT $L186790
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _SQLDisconnect@4
$L186790:

; 103  : 	if (hDbc)	SQLFreeHandle(SQL_HANDLE_DBC,hDbc);

  00026	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  0002c	85 c0		 test	 eax, eax
  0002e	74 08		 je	 SHORT $L186791
  00030	50		 push	 eax
  00031	6a 02		 push	 2
  00033	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L186791:

; 104  : 	if (hEnv)	SQLFreeHandle(SQL_HANDLE_ENV,hEnv);

  00038	8b 86 00 03 00
	00		 mov	 eax, DWORD PTR [esi+768]
  0003e	85 c0		 test	 eax, eax
  00040	74 08		 je	 SHORT $L186792
  00042	50		 push	 eax
  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L186792:

; 105  : 
; 106  : 	for( int i = 0; i < MAXCOL; i++ )

  0004a	81 c6 08 03 00
	00		 add	 esi, 776		; 00000308H
  00050	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
$L186794:

; 107  : 		SAFE_DELETE_ARRAY( Col[i] );

  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	85 c0		 test	 eax, eax
  00059	74 0f		 je	 SHORT $L186795
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00061	83 c4 04	 add	 esp, 4
  00064	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$L186795:
  0006a	83 c6 04	 add	 esi, 4
  0006d	4f		 dec	 edi
  0006e	75 e5		 jne	 SHORT $L186794
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 108  : }

  00072	c3		 ret	 0
??1CQuery@@QAE@XZ ENDP					; CQuery::~CQuery
_TEXT	ENDS
PUBLIC	?DisConnect@CQuery@@QAEXXZ			; CQuery::DisConnect
; Function compile flags: /Ogty
;	COMDAT ?DisConnect@CQuery@@QAEXXZ
_TEXT	SEGMENT
?DisConnect@CQuery@@QAEXXZ PROC NEAR			; CQuery::DisConnect, COMDAT
; _this$ = ecx

; 111  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 112  : 	if (hStmt)	SQLFreeHandle(SQL_HANDLE_STMT,hStmt);	hStmt = NULL;

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	3b c7		 cmp	 eax, edi
  0000e	74 08		 je	 SHORT $L186803
  00010	50		 push	 eax
  00011	6a 03		 push	 3
  00013	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L186803:

; 113  : 	if (hDbc)	SQLDisconnect(hDbc);

  00018	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  0001e	3b c7		 cmp	 eax, edi
  00020	89 be 08 07 00
	00		 mov	 DWORD PTR [esi+1800], edi
  00026	74 06		 je	 SHORT $L186804
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _SQLDisconnect@4
$L186804:

; 114  : 	if (hDbc)	SQLFreeHandle(SQL_HANDLE_DBC,hDbc);		hDbc = NULL;

  0002e	8b 86 04 03 00
	00		 mov	 eax, DWORD PTR [esi+772]
  00034	3b c7		 cmp	 eax, edi
  00036	74 08		 je	 SHORT $L186805
  00038	50		 push	 eax
  00039	6a 02		 push	 2
  0003b	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L186805:

; 115  : 	if (hEnv)	SQLFreeHandle(SQL_HANDLE_ENV,hEnv);		hEnv = NULL;

  00040	8b 86 00 03 00
	00		 mov	 eax, DWORD PTR [esi+768]
  00046	3b c7		 cmp	 eax, edi
  00048	89 be 04 03 00
	00		 mov	 DWORD PTR [esi+772], edi
  0004e	74 08		 je	 SHORT $L187341
  00050	50		 push	 eax
  00051	6a 01		 push	 1
  00053	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$L187341:
  00058	89 be 00 03 00
	00		 mov	 DWORD PTR [esi+768], edi
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 116  : }

  00060	c3		 ret	 0
?DisConnect@CQuery@@QAEXXZ ENDP				; CQuery::DisConnect
_TEXT	ENDS
PUBLIC	?EnableConnectionPooling@CQuery@@SAHXZ		; CQuery::EnableConnectionPooling
EXTRN	_SQLSetEnvAttr@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?EnableConnectionPooling@CQuery@@SAHXZ
_TEXT	SEGMENT
?EnableConnectionPooling@CQuery@@SAHXZ PROC NEAR	; CQuery::EnableConnectionPooling, COMDAT

; 122  : 	SQLRETURN result = SQLSetEnvAttr( NULL,  // make process level cursor pooling
; 123  : 					   			     SQL_ATTR_CONNECTION_POOLING,
; 124  : 						             (SQLPOINTER)SQL_CP_ONE_PER_DRIVER,
; 125  : 						             SQL_IS_INTEGER );

  00000	6a fa		 push	 -6			; fffffffaH
  00002	6a 01		 push	 1
  00004	68 c9 00 00 00	 push	 201			; 000000c9H
  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _SQLSetEnvAttr@16

; 126  : 
; 127  : 	return SQL_SUCCEEDED( result ); 

  00010	83 e0 fe	 and	 eax, -2			; fffffffeH
  00013	66 f7 d8	 neg	 ax
  00016	1b c0		 sbb	 eax, eax
  00018	40		 inc	 eax

; 128  : }

  00019	c3		 ret	 0
?EnableConnectionPooling@CQuery@@SAHXZ ENDP		; CQuery::EnableConnectionPooling
_TEXT	ENDS
PUBLIC	?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z	; CQuery::BindParameter
PUBLIC	??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@ ; `string'
EXTRN	?WriteLog@@YAXPBDZZ:NEAR			; WriteLog
EXTRN	_SQLBindParameter@40:NEAR
EXTRN	__imp__GetCurrentThreadId@0:NEAR
;	COMDAT ??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@
CONST	SEGMENT
??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@ DB 'CQuery::B'
	DB	'indParameter - result : %d, ThreadID : %d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z
_TEXT	SEGMENT
_parameterNumber$ = 8					; size = 2
_inputOutputType$ = 12					; size = 2
_valueType$ = 16					; size = 2
_parameterType$ = 20					; size = 2
_columnSize$ = 24					; size = 4
_decimalDigits$ = 28					; size = 2
_parameterValuePtr$ = 32				; size = 4
_bufferLength$ = 36					; size = 4
_strLen_or_IndPtr$ = 40					; size = 4
?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z PROC NEAR	; CQuery::BindParameter, COMDAT
; _this$ = ecx

; 202  : 	SQLRETURN result = ::SQLBindParameter( hStmt, parameterNumber, inputOutputType, valueType, parameterType, columnSize,
; 203  : 		                                decimalDigits, parameterValuePtr, bufferLength, strLen_or_IndPtr );

  00000	8b 44 24 24	 mov	 eax, DWORD PTR _strLen_or_IndPtr$[esp-4]
  00004	8b 54 24 20	 mov	 edx, DWORD PTR _bufferLength$[esp-4]
  00008	8b 89 08 07 00
	00		 mov	 ecx, DWORD PTR [ecx+1800]
  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	8b 44 24 24	 mov	 eax, DWORD PTR _parameterValuePtr$[esp+4]
  00014	52		 push	 edx
  00015	8b 54 24 24	 mov	 edx, DWORD PTR _decimalDigits$[esp+8]
  00019	50		 push	 eax
  0001a	8b 44 24 24	 mov	 eax, DWORD PTR _columnSize$[esp+12]
  0001e	52		 push	 edx
  0001f	8b 54 24 24	 mov	 edx, DWORD PTR _parameterType$[esp+16]
  00023	50		 push	 eax
  00024	8b 44 24 24	 mov	 eax, DWORD PTR _valueType$[esp+20]
  00028	52		 push	 edx
  00029	8b 54 24 24	 mov	 edx, DWORD PTR _inputOutputType$[esp+24]
  0002d	50		 push	 eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR _parameterNumber$[esp+28]
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _SQLBindParameter@40
  0003a	8b f0		 mov	 esi, eax

; 204  : 	if( result != SQL_SUCCESS )

  0003c	66 85 f6	 test	 si, si
  0003f	74 1e		 je	 SHORT $L186854

; 205  : 	{
; 206  : 		TRACE( "CQuery::BindParameter\n" );
; 207  : 		WriteLog( "CQuery::BindParameter - result : %d, ThreadID : %d", result, ::GetCurrentThreadId() );

  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00047	0f bf d6	 movsx	 edx, si
  0004a	50		 push	 eax
  0004b	52		 push	 edx
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@BKEPHFNG@CQuery?3?3BindParameter?5?9?5result?5?3@
  00051	e8 00 00 00 00	 call	 ?WriteLog@@YAXPBDZZ	; WriteLog
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 208  : 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	5e		 pop	 esi

; 212  : }

  0005c	c2 24 00	 ret	 36			; 00000024H
$L186854:

; 209  : 	}
; 210  : 	else
; 211  : 		return TRUE;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5e		 pop	 esi

; 212  : }

  00065	c2 24 00	 ret	 36			; 00000024H
?BindParameter@CQuery@@QAEHGFFFKFPAXJPAJ@Z ENDP		; CQuery::BindParameter
_TEXT	ENDS
PUBLIC	?Fetch@CQuery@@QAEHXZ				; CQuery::Fetch
EXTRN	_SQLFetch@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Fetch@CQuery@@QAEHXZ
_TEXT	SEGMENT
?Fetch@CQuery@@QAEHXZ PROC NEAR				; CQuery::Fetch, COMDAT
; _this$ = ecx

; 303  : 	SQLRETURN result = SQLFetch( hStmt );

  00000	8b 81 08 07 00
	00		 mov	 eax, DWORD PTR [ecx+1800]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _SQLFetch@4

; 314  : 
; 315  : 	case SQL_NO_DATA_FOUND:		// == SQL_NO_DATA
; 316  : 		return FALSE;
; 317  : 	}
; 318  : 
; 319  : #ifdef __INTERNALSERVER
; 320  : 	PrintDiag( NULL, SQL_HANDLE_STMT );
; 321  : #endif
; 322  : 
; 323  : 	return FALSE;

  0000c	0f bf c0	 movsx	 eax, ax
  0000f	83 f8 64	 cmp	 eax, 100		; 00000064H
  00012	77 14		 ja	 SHORT $L186907

; 304  : 
; 305  : 	switch( result )

  00014	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L187348[eax]
  0001b	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L187349[ecx*4]
$L186910:

; 306  : 	{
; 307  : 	case SQL_SUCCESS_WITH_INFO:
; 308  : 		#ifdef _DEBUG
; 309  : 			PrintDiag( NULL, SQL_HANDLE_STMT );
; 310  : 		#endif
; 311  : 	case SQL_SUCCESS:
; 312  : 	case SQL_NEED_DATA:
; 313  : 		return TRUE;

  00022	b8 01 00 00 00	 mov	 eax, 1

; 324  : }

  00027	c3		 ret	 0
$L186907:

; 314  : 
; 315  : 	case SQL_NO_DATA_FOUND:		// == SQL_NO_DATA
; 316  : 		return FALSE;
; 317  : 	}
; 318  : 
; 319  : #ifdef __INTERNALSERVER
; 320  : 	PrintDiag( NULL, SQL_HANDLE_STMT );
; 321  : #endif
; 322  : 
; 323  : 	return FALSE;

  00028	33 c0		 xor	 eax, eax

; 324  : }

  0002a	c3		 ret	 0
  0002b	90		 npad	 1
$L187349:
  0002c	00 00 00 00	 DD	 $L186910
  00030	00 00 00 00	 DD	 $L186907
  00034	00 00 00 00	 DD	 $L186907
$L187348:
  00038	00		 DB	 0
  00039	00		 DB	 0
  0003a	02		 DB	 2
  0003b	02		 DB	 2
  0003c	02		 DB	 2
  0003d	02		 DB	 2
  0003e	02		 DB	 2
  0003f	02		 DB	 2
  00040	02		 DB	 2
  00041	02		 DB	 2
  00042	02		 DB	 2
  00043	02		 DB	 2
  00044	02		 DB	 2
  00045	02		 DB	 2
  00046	02		 DB	 2
  00047	02		 DB	 2
  00048	02		 DB	 2
  00049	02		 DB	 2
  0004a	02		 DB	 2
  0004b	02		 DB	 2
  0004c	02		 DB	 2
  0004d	02		 DB	 2
  0004e	02		 DB	 2
  0004f	02		 DB	 2
  00050	02		 DB	 2
  00051	02		 DB	 2
  00052	02		 DB	 2
  00053	02		 DB	 2
  00054	02		 DB	 2
  00055	02		 DB	 2
  00056	02		 DB	 2
  00057	02		 DB	 2
  00058	02		 DB	 2
  00059	02		 DB	 2
  0005a	02		 DB	 2
  0005b	02		 DB	 2
  0005c	02		 DB	 2
  0005d	02		 DB	 2
  0005e	02		 DB	 2
  0005f	02		 DB	 2
  00060	02		 DB	 2
  00061	02		 DB	 2
  00062	02		 DB	 2
  00063	02		 DB	 2
  00064	02		 DB	 2
  00065	02		 DB	 2
  00066	02		 DB	 2
  00067	02		 DB	 2
  00068	02		 DB	 2
  00069	02		 DB	 2
  0006a	02		 DB	 2
  0006b	02		 DB	 2
  0006c	02		 DB	 2
  0006d	02		 DB	 2
  0006e	02		 DB	 2
  0006f	02		 DB	 2
  00070	02		 DB	 2
  00071	02		 DB	 2
  00072	02		 DB	 2
  00073	02		 DB	 2
  00074	02		 DB	 2
  00075	02		 DB	 2
  00076	02		 DB	 2
  00077	02		 DB	 2
  00078	02		 DB	 2
  00079	02		 DB	 2
  0007a	02		 DB	 2
  0007b	02		 DB	 2
  0007c	02		 DB	 2
  0007d	02		 DB	 2
  0007e	02		 DB	 2
  0007f	02		 DB	 2
  00080	02		 DB	 2
  00081	02		 DB	 2
  00082	02		 DB	 2
  00083	02		 DB	 2
  00084	02		 DB	 2
  00085	02		 DB	 2
  00086	02		 DB	 2
  00087	02		 DB	 2
  00088	02		 DB	 2
  00089	02		 DB	 2
  0008a	02		 DB	 2
  0008b	02		 DB	 2
  0008c	02		 DB	 2
  0008d	02		 DB	 2
  0008e	02		 DB	 2
  0008f	02		 DB	 2
  00090	02		 DB	 2
  00091	02		 DB	 2
  00092	02		 DB	 2
  00093	02		 DB	 2
  00094	02		 DB	 2
  00095	02		 DB	 2
  00096	02		 DB	 2
  00097	02		 DB	 2
  00098	02		 DB	 2
  00099	02		 DB	 2
  0009a	02		 DB	 2
  0009b	00		 DB	 0
  0009c	01		 DB	 1
?Fetch@CQuery@@QAEHXZ ENDP				; CQuery::Fetch
_TEXT	ENDS
PUBLIC	?Clear@CQuery@@QAEXXZ				; CQuery::Clear
EXTRN	_SQLCloseCursor@4:NEAR
EXTRN	_SQLFreeStmt@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Clear@CQuery@@QAEXXZ
_TEXT	SEGMENT
?Clear@CQuery@@QAEXXZ PROC NEAR				; CQuery::Clear, COMDAT
; _this$ = ecx

; 328  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 329  : 	SQLCloseCursor(hStmt);

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _SQLCloseCursor@4

; 330  : 	SQLFreeStmt(hStmt, SQL_UNBIND);

  0000f	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00015	6a 02		 push	 2
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  0001d	5e		 pop	 esi

; 331  : }

  0001e	c3		 ret	 0
?Clear@CQuery@@QAEXXZ ENDP				; CQuery::Clear
_TEXT	ENDS
PUBLIC	?FindCol@CQuery@@AAEHPAD@Z			; CQuery::FindCol
EXTRN	_stricmp:NEAR
; Function compile flags: /Ogty
;	COMDAT ?FindCol@CQuery@@AAEHPAD@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
?FindCol@CQuery@@AAEHPAD@Z PROC NEAR			; CQuery::FindCol, COMDAT
; _this$ = ecx

; 335  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	8b d9		 mov	 ebx, ecx

; 336  : 	int i;
; 337  : 	for (i=0;i<nCol;i++) 

  00005	33 f6		 xor	 esi, esi
  00007	66 39 b3 0c 07
	00 00		 cmp	 WORD PTR [ebx+1804], si
  0000e	57		 push	 edi
  0000f	7e 2c		 jle	 SHORT $L186922
  00011	8b 6c 24 14	 mov	 ebp, DWORD PTR _name$[esp+12]
  00015	8d bb 0e 07 00
	00		 lea	 edi, DWORD PTR [ebx+1806]
  0001b	eb 03 8d 49 00	 npad	 5
$L186920:

; 338  : 	{
; 339  : 		if (stricmp(name,(LPCTSTR)ColName[i])==0)

  00020	57		 push	 edi
  00021	55		 push	 ebp
  00022	e8 00 00 00 00	 call	 _stricmp
  00027	83 c4 08	 add	 esp, 8
  0002a	85 c0		 test	 eax, eax
  0002c	74 19		 je	 SHORT $L187355
  0002e	0f bf 83 0c 07
	00 00		 movsx	 eax, WORD PTR [ebx+1804]
  00035	46		 inc	 esi
  00036	83 c7 32	 add	 edi, 50			; 00000032H
  00039	3b f0		 cmp	 esi, eax
  0003b	7c e3		 jl	 SHORT $L186920
$L186922:
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5d		 pop	 ebp

; 341  : 	}
; 342  : 	return -1;

  00040	83 c8 ff	 or	 eax, -1
  00043	5b		 pop	 ebx

; 343  : }

  00044	c2 04 00	 ret	 4
$L187355:
  00047	5f		 pop	 edi

; 340  : 			return i+1;

  00048	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0004b	5e		 pop	 esi
  0004c	5d		 pop	 ebp
  0004d	5b		 pop	 ebx

; 343  : }

  0004e	c2 04 00	 ret	 4
?FindCol@CQuery@@AAEHPAD@Z ENDP				; CQuery::FindCol
_TEXT	ENDS
PUBLIC	?GetInt@CQuery@@QAEHH@Z				; CQuery::GetInt
EXTRN	_atoi:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetInt@CQuery@@QAEHH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetInt@CQuery@@QAEHH@Z PROC NEAR			; CQuery::GetInt, COMDAT
; _this$ = ecx

; 348  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 08		 jle	 SHORT $L186929

; 349  : 		return CQUERYNOCOL;

  0000f	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 357  : 	}
; 358  : }

  00014	c2 04 00	 ret	 4
$L186929:

; 350  : 
; 351  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00017	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1
  0001f	75 08		 jne	 SHORT $L186930

; 352  : 	{
; 353  : 		return CQUERYNULL;

  00021	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH

; 357  : 	}
; 358  : }

  00026	c2 04 00	 ret	 4
$L186930:

; 354  : 	} else 
; 355  : 	{
; 356  : 		return atoi(Col[nCol-1]);

  00029	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _atoi
  00036	83 c4 04	 add	 esp, 4

; 357  : 	}
; 358  : }

  00039	c2 04 00	 ret	 4
?GetInt@CQuery@@QAEHH@Z ENDP				; CQuery::GetInt
_TEXT	ENDS
PUBLIC	?GetInt@CQuery@@QAEHPAD@Z			; CQuery::GetInt
; Function compile flags: /Ogty
;	COMDAT ?GetInt@CQuery@@QAEHPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetInt@CQuery@@QAEHPAD@Z PROC NEAR			; CQuery::GetInt, COMDAT
; _this$ = ecx

; 363  : 	int n;
; 364  : 	n=FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 365  : 	if (n==-1) 

  0000d	83 f8 ff	 cmp	 eax, -1

; 366  : 	{
; 367  : 		return CQUERYNOCOL;

  00010	74 0b		 je	 SHORT $L187368

; 368  : 	} else 
; 369  : 	{
; 370  : 		return GetInt(n);

  00012	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  00019	3b c1		 cmp	 eax, ecx
  0001b	7e 09		 jle	 SHORT $L187363
$L187368:
  0001d	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00022	5e		 pop	 esi

; 371  : 	}
; 372  : }

  00023	c2 04 00	 ret	 4

; 368  : 	} else 
; 369  : 	{
; 370  : 		return GetInt(n);

$L187363:
  00026	83 bc 86 0c 39
	00 00 ff	 cmp	 DWORD PTR [esi+eax*4+14604], -1
  0002e	75 09		 jne	 SHORT $L187364
  00030	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00035	5e		 pop	 esi

; 371  : 	}
; 372  : }

  00036	c2 04 00	 ret	 4

; 368  : 	} else 
; 369  : 	{
; 370  : 		return GetInt(n);

$L187364:
  00039	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _atoi
  00046	83 c4 04	 add	 esp, 4
  00049	5e		 pop	 esi

; 371  : 	}
; 372  : }

  0004a	c2 04 00	 ret	 4
?GetInt@CQuery@@QAEHPAD@Z ENDP				; CQuery::GetInt
_TEXT	ENDS
PUBLIC	?GetInt64@CQuery@@QAE_JH@Z			; CQuery::GetInt64
EXTRN	__atoi64:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetInt64@CQuery@@QAE_JH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetInt64@CQuery@@QAE_JH@Z PROC NEAR			; CQuery::GetInt64, COMDAT
; _this$ = ecx

; 377  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 0b		 jle	 SHORT $L186943

; 378  : 		return CQUERYNOCOL;

  0000f	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00014	83 ca ff	 or	 edx, -1

; 386  : 	}
; 387  : }

  00017	c2 04 00	 ret	 4
$L186943:
  0001a	56		 push	 esi

; 379  : 
; 380  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  0001b	8b b4 81 0c 39
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+14604]
  00022	83 ca ff	 or	 edx, -1
  00025	3b f2		 cmp	 esi, edx
  00027	5e		 pop	 esi
  00028	75 08		 jne	 SHORT $L186944

; 381  : 	{
; 382  : 		return CQUERYNULL;

  0002a	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH

; 386  : 	}
; 387  : }

  0002f	c2 04 00	 ret	 4
$L186944:

; 383  : 	} else 
; 384  : 	{
; 385  : 		return _atoi64(Col[nCol-1]);

  00032	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 __atoi64
  0003f	83 c4 04	 add	 esp, 4

; 386  : 	}
; 387  : }

  00042	c2 04 00	 ret	 4
?GetInt64@CQuery@@QAE_JH@Z ENDP				; CQuery::GetInt64
_TEXT	ENDS
PUBLIC	?GetInt64@CQuery@@QAE_JPAD@Z			; CQuery::GetInt64
; Function compile flags: /Ogty
;	COMDAT ?GetInt64@CQuery@@QAE_JPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetInt64@CQuery@@QAE_JPAD@Z PROC NEAR			; CQuery::GetInt64, COMDAT
; _this$ = ecx

; 392  : 	int n;
; 393  : 	n=FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 394  : 	if (n==-1) 

  0000d	83 ca ff	 or	 edx, -1
  00010	3b c2		 cmp	 eax, edx

; 395  : 	{
; 396  : 		return CQUERYNOCOL;

  00012	74 0b		 je	 SHORT $L187380

; 397  : 	} else 
; 398  : 	{
; 399  : 		return GetInt64( n );

  00014	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  0001b	3b c1		 cmp	 eax, ecx
  0001d	7e 09		 jle	 SHORT $L187375
$L187380:
  0001f	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00024	5e		 pop	 esi

; 400  : 	}
; 401  : }

  00025	c2 04 00	 ret	 4

; 397  : 	} else 
; 398  : 	{
; 399  : 		return GetInt64( n );

$L187375:
  00028	39 94 86 0c 39
	00 00		 cmp	 DWORD PTR [esi+eax*4+14604], edx
  0002f	75 09		 jne	 SHORT $L187376
  00031	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00036	5e		 pop	 esi

; 400  : 	}
; 401  : }

  00037	c2 04 00	 ret	 4

; 397  : 	} else 
; 398  : 	{
; 399  : 		return GetInt64( n );

$L187376:
  0003a	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 __atoi64
  00047	83 c4 04	 add	 esp, 4
  0004a	5e		 pop	 esi

; 400  : 	}
; 401  : }

  0004b	c2 04 00	 ret	 4
?GetInt64@CQuery@@QAE_JPAD@Z ENDP			; CQuery::GetInt64
_TEXT	ENDS
PUBLIC	?GetFloat@CQuery@@QAEMH@Z			; CQuery::GetFloat
PUBLIC	__real@c2cc0000
PUBLIC	__real@c2c80000
EXTRN	_atof:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@c2cc0000
CONST	SEGMENT
__real@c2cc0000 DD 0c2cc0000r			; -102
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetFloat@CQuery@@QAEMH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetFloat@CQuery@@QAEMH@Z PROC NEAR			; CQuery::GetFloat, COMDAT
; _this$ = ecx

; 406  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 09		 jle	 SHORT $L186957

; 407  : 		return CQUERYNOCOL;

  0000f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2cc0000

; 415  : 	}
; 416  : }

  00015	c2 04 00	 ret	 4
$L186957:

; 408  : 	
; 409  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00018	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1
  00020	75 09		 jne	 SHORT $L186958

; 410  : 	{
; 411  : 		return CQUERYNULL;

  00022	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2c80000

; 415  : 	}
; 416  : }

  00028	c2 04 00	 ret	 4
$L186958:

; 412  : 	} else 
; 413  : 	{
; 414  : 		return	( (float)( atof(Col[nCol-1]) ) );

  0002b	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _atof
  00038	83 c4 04	 add	 esp, 4

; 415  : 	}
; 416  : }

  0003b	c2 04 00	 ret	 4
?GetFloat@CQuery@@QAEMH@Z ENDP				; CQuery::GetFloat
_TEXT	ENDS
PUBLIC	?GetFloat@CQuery@@QAEMPAD@Z			; CQuery::GetFloat
; Function compile flags: /Ogty
;	COMDAT ?GetFloat@CQuery@@QAEMPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetFloat@CQuery@@QAEMPAD@Z PROC NEAR			; CQuery::GetFloat, COMDAT
; _this$ = ecx

; 421  : 	int n;
; 422  : 	n = FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 423  : 	if (n==-1)

  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 0a		 jne	 SHORT $L186966

; 424  : 		return CQUERYNOCOL;

  00012	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2cc0000
  00018	5e		 pop	 esi

; 427  : }

  00019	c2 04 00	 ret	 4
$L186966:

; 425  : 	else
; 426  : 		return GetFloat(n);

  0001c	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  00023	3b c1		 cmp	 eax, ecx
  00025	7e 0a		 jle	 SHORT $L187392
  00027	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2cc0000
  0002d	5e		 pop	 esi

; 427  : }

  0002e	c2 04 00	 ret	 4

; 425  : 	else
; 426  : 		return GetFloat(n);

$L187392:
  00031	83 bc 86 0c 39
	00 00 ff	 cmp	 DWORD PTR [esi+eax*4+14604], -1
  00039	75 0a		 jne	 SHORT $L187393
  0003b	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c2c80000
  00041	5e		 pop	 esi

; 427  : }

  00042	c2 04 00	 ret	 4

; 425  : 	else
; 426  : 		return GetFloat(n);

$L187393:
  00045	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 _atof
  00052	83 c4 04	 add	 esp, 4
  00055	5e		 pop	 esi

; 427  : }

  00056	c2 04 00	 ret	 4
?GetFloat@CQuery@@QAEMPAD@Z ENDP			; CQuery::GetFloat
_TEXT	ENDS
PUBLIC	?GetChar@CQuery@@QAEDH@Z			; CQuery::GetChar
; Function compile flags: /Ogty
;	COMDAT ?GetChar@CQuery@@QAEDH@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
?GetChar@CQuery@@QAEDH@Z PROC NEAR			; CQuery::GetChar, COMDAT
; _this$ = ecx

; 432  : 	if (nCol > this->nCol)

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 05		 jle	 SHORT $L186972

; 433  : 		return CQUERYNOCOL;

  0000f	b0 9a		 mov	 al, -102		; ffffff9aH

; 441  : 	}
; 442  : }

  00011	c2 04 00	 ret	 4
$L186972:

; 434  : 	
; 435  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00014	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1
  0001c	75 05		 jne	 SHORT $L186973

; 436  : 	{
; 437  : 		return CQUERYNULL;

  0001e	b0 9c		 mov	 al, -100		; ffffff9cH

; 441  : 	}
; 442  : }

  00020	c2 04 00	 ret	 4
$L186973:

; 438  : 	} else 
; 439  : 	{
; 440  : 		return Col[nCol-1][0];

  00023	8b 84 81 04 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+772]
  0002a	8a 00		 mov	 al, BYTE PTR [eax]

; 441  : 	}
; 442  : }

  0002c	c2 04 00	 ret	 4
?GetChar@CQuery@@QAEDH@Z ENDP				; CQuery::GetChar
_TEXT	ENDS
PUBLIC	?GetChar@CQuery@@QAEDPAD@Z			; CQuery::GetChar
; Function compile flags: /Ogty
;	COMDAT ?GetChar@CQuery@@QAEDPAD@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
?GetChar@CQuery@@QAEDPAD@Z PROC NEAR			; CQuery::GetChar, COMDAT
; _this$ = ecx

; 446  : 	int n;
; 447  : 	n = FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 448  : 	if (n==-1)

  0000d	83 f8 ff	 cmp	 eax, -1

; 449  : 		return CQUERYNOCOL;

  00010	74 0b		 je	 SHORT $L187408

; 450  : 	else
; 451  : 		return GetChar(n);

  00012	0f bf 8e 0c 07
	00 00		 movsx	 ecx, WORD PTR [esi+1804]
  00019	3b c1		 cmp	 eax, ecx
  0001b	7e 06		 jle	 SHORT $L187404
$L187408:
  0001d	b0 9a		 mov	 al, -102		; ffffff9aH
  0001f	5e		 pop	 esi

; 452  : }

  00020	c2 04 00	 ret	 4

; 450  : 	else
; 451  : 		return GetChar(n);

$L187404:
  00023	83 bc 86 0c 39
	00 00 ff	 cmp	 DWORD PTR [esi+eax*4+14604], -1
  0002b	75 06		 jne	 SHORT $L187405
  0002d	b0 9c		 mov	 al, -100		; ffffff9cH
  0002f	5e		 pop	 esi

; 452  : }

  00030	c2 04 00	 ret	 4

; 450  : 	else
; 451  : 		return GetChar(n);

$L187405:
  00033	8b 94 86 04 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+772]
  0003a	8a 02		 mov	 al, BYTE PTR [edx]
  0003c	5e		 pop	 esi

; 452  : }

  0003d	c2 04 00	 ret	 4
?GetChar@CQuery@@QAEDPAD@Z ENDP				; CQuery::GetChar
_TEXT	ENDS
PUBLIC	?GetStr@CQuery@@QAEXHPAD@Z			; CQuery::GetStr
PUBLIC	??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@		; `string'
PUBLIC	??_C@_04HIBGFPH@NULL?$AA@			; `string'
EXTRN	__imp__lstrcpyA@8:NEAR
;	COMDAT ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@
CONST	SEGMENT
??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@ DB 'CQUERYNOCOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL?$AA@ DB 'NULL', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXHPAD@Z
_TEXT	SEGMENT
_nCol$ = 8						; size = 4
_buf$ = 12						; size = 4
?GetStr@CQuery@@QAEXHPAD@Z PROC NEAR			; CQuery::GetStr, COMDAT
; _this$ = ecx

; 458  : 	if (nCol > this->nCol) 

  00000	0f bf 91 0c 07
	00 00		 movsx	 edx, WORD PTR [ecx+1804]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _nCol$[esp-4]
  0000b	3b c2		 cmp	 eax, edx
  0000d	7e 21		 jle	 SHORT $L186987

; 459  : 	{
; 460  : 		strcpy(buf, "CQUERYNOCOL");

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _buf$[esp-4]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@+4
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00024	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0M@FBMLJEEM@CQUERYNOCOL?$AA@+8
  0002a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 469  : 	}
; 470  : }

  0002d	c2 08 00	 ret	 8
$L186987:

; 461  : 		return;
; 462  : 	}
; 463  : 
; 464  : 	if (lCol[nCol-1]==SQL_NULL_DATA) 

  00030	83 bc 81 0c 39
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+14604], -1

; 465  : 	{
; 466  : 		lstrcpy(buf,"NULL");

  00038	8b 54 24 08	 mov	 edx, DWORD PTR _buf$[esp-4]
  0003c	75 0f		 jne	 SHORT $L186989
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HIBGFPH@NULL?$AA@
  00043	52		 push	 edx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 469  : 	}
; 470  : }

  0004a	c2 08 00	 ret	 8
$L186989:

; 467  : 	} else {
; 468  : 		 strcpy(buf,Col[nCol-1]);

  0004d	8b 8c 81 04 03
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+772]
$L187411:
  00054	8a 01		 mov	 al, BYTE PTR [ecx]
  00056	41		 inc	 ecx
  00057	88 02		 mov	 BYTE PTR [edx], al
  00059	42		 inc	 edx
  0005a	84 c0		 test	 al, al
  0005c	75 f6		 jne	 SHORT $L187411

; 469  : 	}
; 470  : }

  0005e	c2 08 00	 ret	 8
?GetStr@CQuery@@QAEXHPAD@Z ENDP				; CQuery::GetStr
_TEXT	ENDS
PUBLIC	?GetStr@CQuery@@QAEXPAD0@Z			; CQuery::GetStr
PUBLIC	??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@ ; `string'
;	COMDAT ??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@ DB 'ERROR:Colume not fo'
	DB	'und', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetStr@CQuery@@QAEXPAD0@Z
_TEXT	SEGMENT
_sCol$ = 8						; size = 4
_buf$ = 12						; size = 4
?GetStr@CQuery@@QAEXPAD0@Z PROC NEAR			; CQuery::GetStr, COMDAT
; _this$ = ecx

; 475  : 	int n;
; 476  : 	n=FindCol(sCol);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sCol$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?FindCol@CQuery@@AAEHPAD@Z ; CQuery::FindCol

; 477  : 	if (n==-1) 

  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 14		 jne	 SHORT $L186998

; 478  : 	{
; 479  : 		lstrcpy(buf,"ERROR:Colume not found");

  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR _buf$[esp]
  00016	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@NJAMFEFI@ERROR?3Colume?5not?5found?$AA@
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00022	5e		 pop	 esi

; 483  : 	}
; 484  : }

  00023	c2 08 00	 ret	 8
$L186998:

; 480  : 	} else 
; 481  : 	{
; 482  : 		GetStr(n, buf);

  00026	8b 54 24 0c	 mov	 edx, DWORD PTR _buf$[esp]
  0002a	52		 push	 edx
  0002b	50		 push	 eax
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?GetStr@CQuery@@QAEXHPAD@Z ; CQuery::GetStr
  00033	5e		 pop	 esi

; 483  : 	}
; 484  : }

  00034	c2 08 00	 ret	 8
?GetStr@CQuery@@QAEXPAD0@Z ENDP				; CQuery::GetStr
_TEXT	ENDS
PUBLIC	?WriteBlob@CQuery@@QAEXPBDPAXH@Z		; CQuery::WriteBlob
EXTRN	__chkstk:NEAR
EXTRN	_SQLExecDirect@12:NEAR
EXTRN	_SQLParamData@8:NEAR
EXTRN	_SQLPutData@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?WriteBlob@CQuery@@QAEXPBDPAXH@Z
_TEXT	SEGMENT
tv253 = -10036						; size = 4
$T187424 = -10036					; size = 4
$T187423 = -10032					; size = 4
_pToken$ = -10028					; size = 4
_cbBlob$ = -10024					; size = 4
$T187425 = -10020					; size = 4
$T187426 = -10016					; size = 4
$T187431 = -10012					; size = 4
_tmp$ = -10008						; size = 10000
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szSQL$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
?WriteBlob@CQuery@@QAEXPBDPAXH@Z PROC NEAR		; CQuery::WriteBlob, COMDAT
; _this$ = ecx

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 34 27 00 00	 mov	 eax, 10036		; 00002734H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _buf$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _size$[ebp]

; 576  : 	SQLINTEGER cbBlob;
; 577  : 	char tmp[BLOBBATCH],*p;
; 578  : 	SQLPOINTER pToken;
; 579  : 	int nPut;
; 580  : 
; 581  : 	cbBlob=SQL_LEN_DATA_AT_EXEC(size);
; 582  : 	SQLBindParameter(hStmt,1,SQL_PARAM_INPUT,SQL_C_BINARY,SQL_LONGVARBINARY,
; 583  : 		size,0,(SQLPOINTER)1,0,&cbBlob);

  0001e	8d 54 24 18	 lea	 edx, DWORD PTR _cbBlob$[esp+10048]
  00022	52		 push	 edx
  00023	6a 00		 push	 0
  00025	6a 01		 push	 1
  00027	6a 00		 push	 0
  00029	57		 push	 edi
  0002a	6a fc		 push	 -4			; fffffffcH
  0002c	33 c5		 xor	 eax, ebp
  0002e	6a fe		 push	 -2			; fffffffeH
  00030	89 84 24 58 27
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+10076], eax
  00037	8b 45 08	 mov	 eax, DWORD PTR _szSQL$[ebp]
  0003a	8b f1		 mov	 esi, ecx
  0003c	6a 01		 push	 1

; 597  : 				}
; 598  : 			}
; 599  : 		}
; 600  : 		ret=SQLParamData(hStmt, &pToken);

  0003e	89 44 24 2c	 mov	 DWORD PTR $T187424[esp+10080], eax
  00042	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00048	b9 9c ff ff ff	 mov	 ecx, -100		; ffffff9cH
  0004d	6a 01		 push	 1
  0004f	2b cf		 sub	 ecx, edi
  00051	50		 push	 eax
  00052	89 74 24 38	 mov	 DWORD PTR $T187423[esp+10088], esi
  00056	89 5c 24 44	 mov	 DWORD PTR $T187425[esp+10088], ebx
  0005a	89 7c 24 48	 mov	 DWORD PTR $T187426[esp+10088], edi
  0005e	89 4c 24 40	 mov	 DWORD PTR _cbBlob$[esp+10088], ecx
  00062	e8 00 00 00 00	 call	 _SQLBindParameter@40
  00067	8b 4c 24 0c	 mov	 ecx, DWORD PTR $T187424[esp+10048]
  0006b	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  00071	6a fd		 push	 -3			; fffffffdH
  00073	51		 push	 ecx
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 _SQLExecDirect@12
  0007a	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00080	8d 44 24 14	 lea	 eax, DWORD PTR _pToken$[esp+10048]
  00084	50		 push	 eax
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 _SQLParamData@8
  0008b	66 3d 63 00	 cmp	 ax, 99			; 00000063H
  0008f	0f 85 99 00 00
	00		 jne	 $L187069
$L187438:

; 584  : 	SQLExecDirect(hStmt,(SQLCHAR *)szSQL,SQL_NTS);
; 585  : 	SQLRETURN ret=SQLParamData(hStmt, &pToken);
; 586  : 	while (ret==SQL_NEED_DATA) 
; 587  : 	{
; 588  : 		if (ret==SQL_NEED_DATA) 
; 589  : 		{
; 590  : 			if ((int)pToken==1) 

  00095	83 7c 24 14 01	 cmp	 DWORD PTR _pToken$[esp+10048], 1
  0009a	75 77		 jne	 SHORT $L187077

; 591  : 			{
; 592  : 				for (p=(char *)buf;p<(char *)buf+size;p+=BLOBBATCH) 

  0009c	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0009f	3b d8		 cmp	 ebx, eax
  000a1	89 44 24 24	 mov	 DWORD PTR $T187431[esp+10048], eax
  000a5	73 6c		 jae	 SHORT $L187077
  000a7	8b c7		 mov	 eax, edi
  000a9	89 44 24 0c	 mov	 DWORD PTR tv253[esp+10048], eax
  000ad	eb 04		 jmp	 SHORT $L187075
$L187432:
  000af	8b 44 24 0c	 mov	 eax, DWORD PTR tv253[esp+10048]
$L187075:

; 593  : 				{
; 594  : 					nPut=min(BLOBBATCH,(char *)buf+size-p);

  000b3	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  000b8	7e 05		 jle	 SHORT $L187419
  000ba	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
$L187419:

; 595  : 					memcpy(tmp,p,nPut);

  000bf	8b c8		 mov	 ecx, eax
  000c1	8b d1		 mov	 edx, ecx
  000c3	c1 e9 02	 shr	 ecx, 2
  000c6	8b f3		 mov	 esi, ebx
  000c8	8d 7c 24 28	 lea	 edi, DWORD PTR _tmp$[esp+10048]
  000cc	f3 a5		 rep movsd
  000ce	8b ca		 mov	 ecx, edx
  000d0	83 e1 03	 and	 ecx, 3

; 596  : 					SQLPutData(hStmt,(PTR)tmp,nPut);

  000d3	50		 push	 eax
  000d4	f3 a4		 rep movsb
  000d6	8b 4c 24 14	 mov	 ecx, DWORD PTR $T187423[esp+10052]
  000da	8b 91 08 07 00
	00		 mov	 edx, DWORD PTR [ecx+1800]
  000e0	8d 44 24 2c	 lea	 eax, DWORD PTR _tmp$[esp+10052]
  000e4	50		 push	 eax
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 _SQLPutData@12
  000eb	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv253[esp+10048]
  000ef	8b 44 24 24	 mov	 eax, DWORD PTR $T187431[esp+10048]
  000f3	81 c3 10 27 00
	00		 add	 ebx, 10000		; 00002710H
  000f9	81 e9 10 27 00
	00		 sub	 ecx, 10000		; 00002710H
  000ff	3b d8		 cmp	 ebx, eax
  00101	89 4c 24 0c	 mov	 DWORD PTR tv253[esp+10048], ecx
  00105	72 a8		 jb	 SHORT $L187432
  00107	8b 74 24 10	 mov	 esi, DWORD PTR $T187423[esp+10048]
  0010b	8b 5c 24 1c	 mov	 ebx, DWORD PTR $T187425[esp+10048]
  0010f	8b 7c 24 20	 mov	 edi, DWORD PTR $T187426[esp+10048]
$L187077:

; 597  : 				}
; 598  : 			}
; 599  : 		}
; 600  : 		ret=SQLParamData(hStmt, &pToken);

  00113	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00119	8d 44 24 14	 lea	 eax, DWORD PTR _pToken$[esp+10048]
  0011d	50		 push	 eax
  0011e	51		 push	 ecx
  0011f	e8 00 00 00 00	 call	 _SQLParamData@8
  00124	66 3d 63 00	 cmp	 ax, 99			; 00000063H
  00128	0f 84 67 ff ff
	ff		 je	 $L187438
$L187069:

; 601  : 	}
; 602  : 	Clear();

  0012e	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  0013a	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00140	6a 02		 push	 2
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 603  : }

  00148	8b 8c 24 3c 27
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+10048]
  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	33 cd		 xor	 ecx, ebp
  00153	5b		 pop	 ebx
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 0c 00	 ret	 12			; 0000000cH
?WriteBlob@CQuery@@QAEXPBDPAXH@Z ENDP			; CQuery::WriteBlob
_TEXT	ENDS
PUBLIC	?WriteLogFile@CQuery@@QAAXPADZZ			; CQuery::WriteLogFile
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@ ; `string'
PUBLIC	??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@ ; `string'
EXTRN	__imp__OutputDebugStringA@4:NEAR
EXTRN	_fclose:NEAR
EXTRN	?MakeFileNameDate@@YAPBDPBD@Z:NEAR		; MakeFileNameDate
EXTRN	_fopen:NEAR
EXTRN	_fprintf:NEAR
EXTRN	__imp__GetLocalTime@4:NEAR
EXTRN	__vsnprintf:NEAR
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@
CONST	SEGMENT
??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@ DB '..\CQuery-LogFile.'
	DB	'txt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@ DB '%'
	DB	'd/%02d/%02d', 09H, '%02d:%02d:%02d', 0aH, '%s', 0aH, 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?WriteLogFile@CQuery@@QAAXPADZZ
_TEXT	SEGMENT
_time$ = -65556						; size = 16
_szBuffer$ = -65540					; size = 65536
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?WriteLogFile@CQuery@@QAAXPADZZ PROC NEAR		; CQuery::WriteLogFile, COMDAT

; 606  : {	

  00000	b8 14 00 01 00	 mov	 eax, 65556		; 00010014H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 607  : 	TCHAR szBuffer[1024* 64];
; 608  : 
; 609  : 	va_list args;
; 610  : 	va_start( args, lpszFormat );
; 611  : 	int n = _vsntprintf( szBuffer, sizeof(szBuffer)-1, lpszFormat, args );

  0000f	8b 8c 24 1c 00
	01 00		 mov	 ecx, DWORD PTR _lpszFormat$[esp+65552]
  00016	33 c4		 xor	 eax, esp
  00018	89 84 24 10 00
	01 00		 mov	 DWORD PTR __$ArrayPad$[esp+65556], eax
  0001f	8d 84 24 20 00
	01 00		 lea	 eax, DWORD PTR _lpszFormat$[esp+65556]
  00026	50		 push	 eax
  00027	51		 push	 ecx
  00028	8d 54 24 18	 lea	 edx, DWORD PTR _szBuffer$[esp+65564]
  0002c	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 __vsnprintf
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 612  : 	va_end( args );
; 613  : 
; 614  : 	if( n == -1 ) // if the number of bytes to write exceeds buffer, then count bytes are written and -1 is returned

  0003a	83 f8 ff	 cmp	 eax, -1
  0003d	74 76		 je	 SHORT $L187085
  0003f	56		 push	 esi

; 615  : 		return;
; 616  : 
; 617  : 	OutputDebugString( szBuffer );

  00040	8d 44 24 14	 lea	 eax, DWORD PTR _szBuffer$[esp+65560]
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 618  : 
; 619  : 	FILE* fp = fopen( MakeFileNameDate( "..\\CQuery-LogFile.txt" ), "a" );

  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01MCMALHOG@a?$AA@
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@DGAFOMHO@?4?4?2CQuery?9LogFile?4txt?$AA@
  00055	e8 00 00 00 00	 call	 ?MakeFileNameDate@@YAPBDPBD@Z ; MakeFileNameDate
  0005a	83 c4 04	 add	 esp, 4
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _fopen
  00063	8b f0		 mov	 esi, eax
  00065	83 c4 08	 add	 esp, 8

; 620  : 	if( fp == NULL )

  00068	85 f6		 test	 esi, esi
  0006a	74 48		 je	 SHORT $L187442

; 621  : 		return;
; 622  : 
; 623  : 	// time
; 624  : 	SYSTEMTIME	time;
; 625  : 	GetLocalTime( &time );

  0006c	8d 4c 24 04	 lea	 ecx, DWORD PTR _time$[esp+65560]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 626  : 	fprintf( fp, "%d/%02d/%02d\t%02d:%02d:%02d\n%s\n", 
; 627  : 		     time.wYear, time.wMonth, time.wDay, time.wHour, time.wMinute, time.wSecond,
; 628  : 		     szBuffer );

  00077	0f b7 44 24 10	 movzx	 eax, WORD PTR _time$[esp+65572]
  0007c	0f b7 4c 24 0e	 movzx	 ecx, WORD PTR _time$[esp+65570]
  00081	8d 54 24 14	 lea	 edx, DWORD PTR _szBuffer$[esp+65560]
  00085	52		 push	 edx
  00086	0f b7 54 24 10	 movzx	 edx, WORD PTR _time$[esp+65572]
  0008b	50		 push	 eax
  0008c	0f b7 44 24 12	 movzx	 eax, WORD PTR _time$[esp+65574]
  00091	51		 push	 ecx
  00092	0f b7 4c 24 12	 movzx	 ecx, WORD PTR _time$[esp+65574]
  00097	52		 push	 edx
  00098	0f b7 54 24 14	 movzx	 edx, WORD PTR _time$[esp+65576]
  0009d	50		 push	 eax
  0009e	51		 push	 ecx
  0009f	52		 push	 edx
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CKBPMIJH@?$CFd?1?$CF02d?1?$CF02d?7?$CF02d?3?$CF02d?3?$CF02d?6?$CFs?6?$AA@
  000a5	56		 push	 esi
  000a6	e8 00 00 00 00	 call	 _fprintf

; 629  : 	fclose( fp );

  000ab	56		 push	 esi
  000ac	e8 00 00 00 00	 call	 _fclose
  000b1	83 c4 28	 add	 esp, 40			; 00000028H
$L187442:
  000b4	5e		 pop	 esi
$L187085:

; 630  : }

  000b5	8b 8c 24 10 00
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+65556]
  000bc	33 cc		 xor	 ecx, esp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	81 c4 14 00 01
	00		 add	 esp, 65556		; 00010014H
  000c9	c3		 ret	 0
?WriteLogFile@CQuery@@QAAXPADZZ ENDP			; CQuery::WriteLogFile
_TEXT	ENDS
PUBLIC	?PrepareFetch@CQuery@@QAEHXZ			; CQuery::PrepareFetch
EXTRN	_SQLBindCol@24:NEAR
EXTRN	_SQLDescribeCol@36:NEAR
EXTRN	_SQLNumResultCols@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?PrepareFetch@CQuery@@QAEHXZ
_TEXT	SEGMENT
_m_nNullability$ = -24					; size = 2
_m_nScale$ = -20					; size = 2
_m_nSQLType$ = -16					; size = 2
_nActualLen$ = -12					; size = 2
tv271 = -8						; size = 4
_m_nPrecision$ = -4					; size = 4
?PrepareFetch@CQuery@@QAEHXZ PROC NEAR			; CQuery::PrepareFetch, COMDAT
; _this$ = ecx

; 634  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	55		 push	 ebp
  00004	56		 push	 esi
  00005	8b e9		 mov	 ebp, ecx

; 635  : 	SQLNumResultCols(hStmt,&nCol);

  00007	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  0000d	8d b5 0c 07 00
	00		 lea	 esi, DWORD PTR [ebp+1804]
  00013	56		 push	 esi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _SQLNumResultCols@8

; 636  : 	if (nCol > MAXCOL)

  0001a	66 8b 06	 mov	 ax, WORD PTR [esi]
  0001d	66 3d 00 01	 cmp	 ax, 256			; 00000100H
  00021	7e 08		 jle	 SHORT $L187104
  00023	5e		 pop	 esi

; 637  : 		return FALSE;

  00024	33 c0		 xor	 eax, eax
  00026	5d		 pop	 ebp

; 668  : }

  00027	83 c4 18	 add	 esp, 24			; 00000018H
  0002a	c3		 ret	 0
$L187104:

; 638  : 	
; 639  : 	// nCol 0  Select      
; 640  : 	//    .
; 641  : 	if (nCol == 0) 

  0002b	66 85 c0	 test	 ax, ax
  0002e	75 25		 jne	 SHORT $L187105

; 642  : 	{
; 643  : 		Clear();

  00030	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  0003c	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  00042	6a 02		 push	 2
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  0004a	5e		 pop	 esi

; 665  : 	}
; 666  : 
; 667  : 	return TRUE;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	5d		 pop	 ebp

; 668  : }

  00051	83 c4 18	 add	 esp, 24			; 00000018H
  00054	c3		 ret	 0
$L187105:
  00055	57		 push	 edi

; 644  : 		return TRUE;
; 645  : 	}
; 646  : 	
; 647  : 	SWORD	nActualLen;
; 648  : 	SWORD	m_nSQLType;
; 649  : 	UDWORD	m_nPrecision;
; 650  : 	SWORD	m_nScale;
; 651  : 	SWORD	m_nNullability;
; 652  :  
; 653  : 	//     . Col zero base, 
; 654  : 	//   one base  
; 655  : 	for (int c=0;c<nCol;c++) 

  00056	33 ff		 xor	 edi, edi
  00058	66 85 c0	 test	 ax, ax
  0005b	7e 7c		 jle	 SHORT $L187114
  0005d	8d 85 0e 07 00
	00		 lea	 eax, DWORD PTR [ebp+1806]
  00063	89 44 24 1c	 mov	 DWORD PTR tv271[esp+36], eax
  00067	8d b5 08 03 00
	00		 lea	 esi, DWORD PTR [ebp+776]
  0006d	53		 push	 ebx
  0006e	8b ff		 npad	 2
$L187112:

; 656  : 	{
; 657  : 		SQLBindCol(hStmt,c+1,SQL_C_CHAR,Col[c],8192,&lCol[c]);

  00070	8b 16		 mov	 edx, DWORD PTR [esi]
  00072	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  00078	8d 8e 08 36 00
	00		 lea	 ecx, DWORD PTR [esi+13832]
  0007e	51		 push	 ecx
  0007f	68 00 20 00 00	 push	 8192			; 00002000H
  00084	52		 push	 edx
  00085	6a 01		 push	 1
  00087	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  0008a	53		 push	 ebx
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _SQLBindCol@24

; 658  : 	//	SQLDescribeCol(hStmt,c+1,ColName[c],30,NULL,NULL,NULL,NULL,NULL);
; 659  : 		SQLDescribeCol(hStmt,c+1,ColName[c],30,
; 660  : 			&nActualLen,
; 661  : 			&m_nSQLType,
; 662  : 			&m_nPrecision,
; 663  : 			&m_nScale,
; 664  : 			&m_nNullability);

  00091	8d 4c 24 10	 lea	 ecx, DWORD PTR _m_nNullability$[esp+40]
  00095	51		 push	 ecx
  00096	8d 54 24 18	 lea	 edx, DWORD PTR _m_nScale$[esp+44]
  0009a	52		 push	 edx
  0009b	8d 44 24 2c	 lea	 eax, DWORD PTR _m_nPrecision$[esp+48]
  0009f	50		 push	 eax
  000a0	8b 44 24 2c	 mov	 eax, DWORD PTR tv271[esp+52]
  000a4	8d 4c 24 24	 lea	 ecx, DWORD PTR _m_nSQLType$[esp+52]
  000a8	51		 push	 ecx
  000a9	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  000af	8d 54 24 2c	 lea	 edx, DWORD PTR _nActualLen$[esp+56]
  000b3	52		 push	 edx
  000b4	6a 1e		 push	 30			; 0000001eH
  000b6	50		 push	 eax
  000b7	53		 push	 ebx
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _SQLDescribeCol@36
  000be	8b 4c 24 20	 mov	 ecx, DWORD PTR tv271[esp+40]
  000c2	0f bf 95 0c 07
	00 00		 movsx	 edx, WORD PTR [ebp+1804]
  000c9	47		 inc	 edi
  000ca	83 c1 32	 add	 ecx, 50			; 00000032H
  000cd	83 c6 04	 add	 esi, 4
  000d0	3b fa		 cmp	 edi, edx
  000d2	89 4c 24 20	 mov	 DWORD PTR tv271[esp+40], ecx
  000d6	7c 98		 jl	 SHORT $L187112
  000d8	5b		 pop	 ebx
$L187114:
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 665  : 	}
; 666  : 
; 667  : 	return TRUE;

  000db	b8 01 00 00 00	 mov	 eax, 1
  000e0	5d		 pop	 ebp

; 668  : }

  000e1	83 c4 18	 add	 esp, 24			; 00000018H
  000e4	c3		 ret	 0
?PrepareFetch@CQuery@@QAEHXZ ENDP			; CQuery::PrepareFetch
_TEXT	ENDS
PUBLIC	?PrintDiag@CQuery@@QAEXPBDF@Z			; CQuery::PrintDiag
PUBLIC	??_C@_05OAGAMKLF@00000?$AA@			; `string'
PUBLIC	??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ ; `string'
EXTRN	_SQLGetDiagRec@32:NEAR
EXTRN	__imp__lstrcmpA@8:NEAR
;	COMDAT ??_C@_05OAGAMKLF@00000?$AA@
CONST	SEGMENT
??_C@_05OAGAMKLF@00000?$AA@ DB '00000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT
??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ DB 'q'
	DB	'uery:%s', 0aH, 'SQLSTATE:%s error:%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@ DB 'SQLSTATE:%s err'
	DB	'or:%s', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?PrintDiag@CQuery@@QAEXPBDF@Z
_TEXT	SEGMENT
_nLen$ = -536						; size = 2
$T187455 = -532						; size = 4
_nError$ = -528						; size = 4
_szState$ = -524					; size = 6
_szMsg$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szSQL$ = 8						; size = 4
_type$ = 12						; size = 2
?PrintDiag@CQuery@@QAEXPBDF@Z PROC NEAR			; CQuery::PrintDiag, COMDAT
; _this$ = ecx

; 488  : {

  00000	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp

; 489  : 
; 490  : /*
; 491  : 	SQLINTEGER NativeError;
; 492  : 	SQLCHAR SqlState[6], Msg[1024];
; 493  : 	SQLSMALLINT MsgLen;
; 494  : 
; 495  : 	int ii=1;
; 496  : 	SQLRETURN Ret = SQLGetDiagRec(SQL_HANDLE_STMT, hStmt, ii, SqlState, &NativeError, Msg, sizeof(Msg), &MsgLen);
; 497  : 	if( Ret != SQL_NO_DATA )
; 498  : 	{
; 499  : 		if( szSQL )
; 500  : 			WriteLogFile("query:%s\nSQLSTATE:%s error:%s", szSQL, (LPCTSTR)SqlState,(LPCTSTR)Msg );
; 501  : 		else
; 502  : 			WriteLogFile("SQLSTATE:%s error:%s", (LPCTSTR)SqlState,(LPCTSTR)Msg );
; 503  : 	}
; 504  : */
; 505  : 	UCHAR szMsg[SQL_MAX_MESSAGE_LENGTH];
; 506  : 	UCHAR szState[SQL_SQLSTATE_SIZE+1];
; 507  : 	SQLSMALLINT nLen;
; 508  : 	SQLINTEGER nError;
; 509  : 	SQLRETURN ret;
; 510  : 
; 511  : 	SQLHANDLE handle = hDbc;
; 512  : 	if( type == SQL_HANDLE_STMT )

  0000f	8b ac 24 28 02
	00 00		 mov	 ebp, DWORD PTR _type$[esp+540]
  00016	66 83 fd 03	 cmp	 bp, 3
  0001a	56		 push	 esi
  0001b	89 84 24 20 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+548], eax
  00022	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR _szSQL$[esp+544]
  00029	8b f1		 mov	 esi, ecx
  0002b	57		 push	 edi
  0002c	8b be 04 03 00
	00		 mov	 edi, DWORD PTR [esi+772]

; 525  : 			nIndex++;

  00032	89 44 24 14	 mov	 DWORD PTR $T187455[esp+552], eax
  00036	75 06		 jne	 SHORT $L187012

; 513  : 		handle = hStmt;

  00038	8b be 08 07 00
	00		 mov	 edi, DWORD PTR [esi+1800]
$L187012:

; 514  : 
; 515  : 	int nIndex=1;

  0003e	bb 01 00 00 00	 mov	 ebx, 1
$L187015:

; 516  : 	while( TRUE )
; 517  : 	{
; 518  : 		ret = SQLGetDiagRec( type, handle, nIndex, szState, &nError, szMsg, SQL_MAX_MESSAGE_LENGTH-1, &nLen );

  00043	8d 4c 24 10	 lea	 ecx, DWORD PTR _nLen$[esp+552]
  00047	51		 push	 ecx
  00048	68 ff 01 00 00	 push	 511			; 000001ffH
  0004d	8d 54 24 2c	 lea	 edx, DWORD PTR _szMsg$[esp+560]
  00051	52		 push	 edx
  00052	8d 44 24 24	 lea	 eax, DWORD PTR _nError$[esp+564]
  00056	50		 push	 eax
  00057	8d 4c 24 2c	 lea	 ecx, DWORD PTR _szState$[esp+568]
  0005b	51		 push	 ecx
  0005c	53		 push	 ebx
  0005d	57		 push	 edi
  0005e	55		 push	 ebp
  0005f	e8 00 00 00 00	 call	 _SQLGetDiagRec@32

; 519  : 		if( (ret == SQL_SUCCESS || ret == SQL_SUCCESS_WITH_INFO) &&	lstrcmp((LPCTSTR)szState, "00000") != 0 )

  00064	66 85 c0	 test	 ax, ax
  00067	74 06		 je	 SHORT $L187019
  00069	66 3d 01 00	 cmp	 ax, 1
  0006d	75 53		 jne	 SHORT $L187018
$L187019:
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05OAGAMKLF@00000?$AA@
  00074	8d 54 24 20	 lea	 edx, DWORD PTR _szState$[esp+556]
  00078	52		 push	 edx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpA@8
  0007f	85 c0		 test	 eax, eax
  00081	74 3f		 je	 SHORT $L187018

; 520  : 		{
; 521  : 			if( szSQL )

  00083	8b 44 24 14	 mov	 eax, DWORD PTR $T187455[esp+552]
  00087	85 c0		 test	 eax, eax
  00089	74 1c		 je	 SHORT $L187021

; 522  : 				WriteLogFile("query:%s\nSQLSTATE:%s error:%s", szSQL, (LPCTSTR)szState,(LPCTSTR)szMsg );

  0008b	8d 4c 24 24	 lea	 ecx, DWORD PTR _szMsg$[esp+552]
  0008f	51		 push	 ecx
  00090	8d 54 24 20	 lea	 edx, DWORD PTR _szState$[esp+556]
  00094	52		 push	 edx
  00095	50		 push	 eax
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@HJEJONGA@query?3?$CFs?6SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
  0009b	56		 push	 esi
  0009c	e8 00 00 00 00	 call	 ?WriteLogFile@CQuery@@QAAXPADZZ ; CQuery::WriteLogFile
  000a1	83 c4 14	 add	 esp, 20			; 00000014H

; 525  : 			nIndex++;

  000a4	43		 inc	 ebx

; 526  : 		}
; 527  : 		else
; 528  : 			break;	
; 529  : 	}

  000a5	eb 9c		 jmp	 SHORT $L187015
$L187021:

; 523  : 			else
; 524  : 				WriteLogFile("SQLSTATE:%s error:%s", (LPCTSTR)szState,(LPCTSTR)szMsg );

  000a7	8d 44 24 24	 lea	 eax, DWORD PTR _szMsg$[esp+552]
  000ab	50		 push	 eax
  000ac	8d 4c 24 20	 lea	 ecx, DWORD PTR _szState$[esp+556]
  000b0	51		 push	 ecx
  000b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@KIMLEFFG@SQLSTATE?3?$CFs?5error?3?$CFs?$AA@
  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 ?WriteLogFile@CQuery@@QAAXPADZZ ; CQuery::WriteLogFile
  000bc	83 c4 10	 add	 esp, 16			; 00000010H

; 525  : 			nIndex++;

  000bf	43		 inc	 ebx

; 526  : 		}
; 527  : 		else
; 528  : 			break;	
; 529  : 	}

  000c0	eb 81		 jmp	 SHORT $L187015
$L187018:

; 530  : }

  000c2	8b 8c 24 24 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+552]
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5d		 pop	 ebp
  000cc	5b		 pop	 ebx
  000cd	33 cc		 xor	 ecx, esp
  000cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d4	81 c4 18 02 00
	00		 add	 esp, 536		; 00000218H
  000da	c2 08 00	 ret	 8
?PrintDiag@CQuery@@QAEXPBDF@Z ENDP			; CQuery::PrintDiag
_TEXT	ENDS
PUBLIC	?ReadBlob@CQuery@@QAEHPBDPAX@Z			; CQuery::ReadBlob
EXTRN	_SQLGetData@24:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ReadBlob@CQuery@@QAEHPBDPAX@Z
_TEXT	SEGMENT
_TotalGet$ = -10016					; size = 4
_LenBin$ = -10012					; size = 4
$T187469 = -10008					; size = 4
_BinaryPtr$ = -10004					; size = 10000
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szSQL$ = 8						; size = 4
_buf$ = 12						; size = 4
?ReadBlob@CQuery@@QAEHPBDPAX@Z PROC NEAR		; CQuery::ReadBlob, COMDAT
; _this$ = ecx

; 536  : {

  00000	b8 20 27 00 00	 mov	 eax, 10016		; 00002720H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	55		 push	 ebp
  00012	56		 push	 esi
  00013	8b b4 24 2c 27
	00 00		 mov	 esi, DWORD PTR _szSQL$[esp+10020]

; 537  : 	SQLCHAR BinaryPtr[BLOBBATCH];
; 538  : 	SQLINTEGER LenBin;
; 539  : 	char *p;
; 540  : 	int nGet;
; 541  : 	int TotalGet=0;
; 542  : 
; 543  : 	SQLRETURN ret=SQLExecDirect(hStmt,(SQLCHAR *)szSQL,SQL_NTS);

  0001a	6a fd		 push	 -3			; fffffffdH
  0001c	8b e9		 mov	 ebp, ecx
  0001e	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00024	89 84 24 28 27
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+10028], eax

; 569  : 	return TotalGet;

  0002b	8b 84 24 34 27
	00 00		 mov	 eax, DWORD PTR _buf$[esp+10024]
  00032	56		 push	 esi
  00033	51		 push	 ecx
  00034	89 44 24 1c	 mov	 DWORD PTR $T187469[esp+10036], eax
  00038	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _TotalGet$[esp+10036], 0
  00040	e8 00 00 00 00	 call	 _SQLExecDirect@12
  00045	66 85 c0	 test	 ax, ax
  00048	74 12		 je	 SHORT $L187470
  0004a	6a 02		 push	 2
  0004c	56		 push	 esi
  0004d	8b cd		 mov	 ecx, ebp
  0004f	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag
  00054	83 c8 ff	 or	 eax, -1
  00057	e9 ea 00 00 00	 jmp	 $L187034
$L187470:

; 544  : 	if (ret!=SQL_SUCCESS) {
; 545  : 		PrintDiag( szSQL );
; 546  : 		return -1;
; 547  : 	}
; 548  : 
; 549  : 	while ((ret=SQLFetch(hStmt)) != SQL_NO_DATA) 

  0005c	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  00062	53		 push	 ebx
  00063	57		 push	 edi
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _SQLFetch@4
  0006a	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  0006e	0f 84 b2 00 00
	00		 je	 $L187045
  00074	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$L187044:

; 550  : 	{
; 551  : 		p=(char *)buf;
; 552  : 		while ((ret=SQLGetData(hStmt,1,SQL_C_BINARY,BinaryPtr,sizeof(BinaryPtr),
; 553  : 			&LenBin))!=SQL_NO_DATA) {

  00080	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  00086	8b 5c 24 18	 mov	 ebx, DWORD PTR $T187469[esp+10032]
  0008a	8d 44 24 14	 lea	 eax, DWORD PTR _LenBin$[esp+10032]
  0008e	50		 push	 eax
  0008f	68 10 27 00 00	 push	 10000			; 00002710H
  00094	8d 4c 24 24	 lea	 ecx, DWORD PTR _BinaryPtr$[esp+10040]
  00098	51		 push	 ecx
  00099	6a fe		 push	 -2			; fffffffeH
  0009b	6a 01		 push	 1
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _SQLGetData@24
  000a3	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  000a7	74 67		 je	 SHORT $L187049
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$L187048:

; 554  : 			if (LenBin==SQL_NULL_DATA) 

  000b0	8b 4c 24 14	 mov	 ecx, DWORD PTR _LenBin$[esp+10032]
  000b4	83 f9 ff	 cmp	 ecx, -1
  000b7	0f 84 a2 00 00
	00		 je	 $L187472

; 558  : 			}
; 559  : 			if (ret==SQL_SUCCESS)

  000bd	66 85 c0	 test	 ax, ax

; 560  : 				nGet=LenBin;

  000c0	8b c1		 mov	 eax, ecx
  000c2	74 05		 je	 SHORT $L187052

; 561  : 			else
; 562  : 				nGet=BLOBBATCH;

  000c4	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
$L187052:

; 563  : 			TotalGet+=nGet;

  000c9	8b 74 24 10	 mov	 esi, DWORD PTR _TotalGet$[esp+10032]
  000cd	03 f0		 add	 esi, eax

; 564  : 			memcpy(p,BinaryPtr,nGet);

  000cf	8b c8		 mov	 ecx, eax
  000d1	8b d1		 mov	 edx, ecx
  000d3	c1 e9 02	 shr	 ecx, 2
  000d6	89 74 24 10	 mov	 DWORD PTR _TotalGet$[esp+10032], esi
  000da	8b fb		 mov	 edi, ebx
  000dc	8d 74 24 1c	 lea	 esi, DWORD PTR _BinaryPtr$[esp+10032]
  000e0	f3 a5		 rep movsd
  000e2	8b ca		 mov	 ecx, edx

; 565  : 			p+=nGet;

  000e4	03 d8		 add	 ebx, eax
  000e6	83 e1 03	 and	 ecx, 3
  000e9	8d 44 24 14	 lea	 eax, DWORD PTR _LenBin$[esp+10032]
  000ed	50		 push	 eax
  000ee	68 10 27 00 00	 push	 10000			; 00002710H
  000f3	f3 a4		 rep movsb
  000f5	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  000fb	8d 4c 24 24	 lea	 ecx, DWORD PTR _BinaryPtr$[esp+10040]
  000ff	51		 push	 ecx
  00100	6a fe		 push	 -2			; fffffffeH
  00102	6a 01		 push	 1
  00104	52		 push	 edx
  00105	e8 00 00 00 00	 call	 _SQLGetData@24
  0010a	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  0010e	75 a0		 jne	 SHORT $L187048
$L187049:

; 544  : 	if (ret!=SQL_SUCCESS) {
; 545  : 		PrintDiag( szSQL );
; 546  : 		return -1;
; 547  : 	}
; 548  : 
; 549  : 	while ((ret=SQLFetch(hStmt)) != SQL_NO_DATA) 

  00110	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _SQLFetch@4
  0011c	66 3d 64 00	 cmp	 ax, 100			; 00000064H
  00120	0f 85 5a ff ff
	ff		 jne	 $L187044
$L187045:

; 566  : 		}
; 567  : 	}
; 568  : 	Clear();

  00126	8b 85 08 07 00
	00		 mov	 eax, DWORD PTR [ebp+1800]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00132	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00138	6a 02		 push	 2
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 569  : 	return TotalGet;

  00140	8b 44 24 10	 mov	 eax, DWORD PTR _TotalGet$[esp+10032]
$L187477:
  00144	5f		 pop	 edi
  00145	5b		 pop	 ebx
$L187034:

; 570  : }

  00146	8b 8c 24 24 27
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+10024]
  0014d	5e		 pop	 esi
  0014e	5d		 pop	 ebp
  0014f	33 cc		 xor	 ecx, esp
  00151	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00156	81 c4 20 27 00
	00		 add	 esp, 10016		; 00002720H
  0015c	c2 08 00	 ret	 8
$L187472:

; 555  : 			{
; 556  : 				Clear();

  0015f	8b 8d 08 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1800]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  0016b	8b 95 08 07 00
	00		 mov	 edx, DWORD PTR [ebp+1800]
  00171	6a 02		 push	 2
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 557  : 				return 0;

  00179	33 c0		 xor	 eax, eax
  0017b	eb c7		 jmp	 SHORT $L187477
?ReadBlob@CQuery@@QAEHPBDPAX@Z ENDP			; CQuery::ReadBlob
_TEXT	ENDS
PUBLIC	?Connect@CQuery@@QAEHHPAD0PBD@Z			; CQuery::Connect
PUBLIC	??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@ ; `string'
PUBLIC	??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@		; `string'
EXTRN	_SQLAllocHandle@12:NEAR
EXTRN	_SQLConnect@28:NEAR
EXTRN	__imp__wsprintfA:NEAR
EXTRN	_SQLDriverConnect@32:NEAR
;	COMDAT ??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@ DB 'FileDsn=%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@
CONST	SEGMENT
??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@ DB 'DRIVER='
	DB	'{Microsoft Access Driver (*.mdb)};DBQ=%s;', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?Connect@CQuery@@QAEHHPAD0PBD@Z
_TEXT	SEGMENT
_cbOutCon$ = -528					; size = 2
$T187487 = -524						; size = 4
$T187488 = -520						; size = 4
_InCon$ = -516						; size = 255
_OutCon$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_Type$ = 8						; size = 4
_ConStr$ = 12						; size = 4
_UID$ = 16						; size = 4
_PWD$ = 20						; size = 4
?Connect@CQuery@@QAEHHPAD0PBD@Z PROC NEAR		; CQuery::Connect, COMDAT
; _this$ = ecx

; 137  : {

  00000	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	8b ac 24 20 02
	00 00		 mov	 ebp, DWORD PTR _ConStr$[esp+532]
  00016	56		 push	 esi
  00017	8b b4 24 28 02
	00 00		 mov	 esi, DWORD PTR _UID$[esp+536]
  0001e	8b d9		 mov	 ebx, ecx
  00020	57		 push	 edi
  00021	8b bc 24 30 02
	00 00		 mov	 edi, DWORD PTR _PWD$[esp+540]

; 138  : 	strcpy( DBName, ConStr );

  00028	8b d3		 mov	 edx, ebx
  0002a	89 84 24 1c 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+544], eax

; 181  : 	{
; 182  : 		PrintDiag( ConStr );

  00031	89 74 24 14	 mov	 DWORD PTR $T187487[esp+544], esi
  00035	89 7c 24 18	 mov	 DWORD PTR $T187488[esp+544], edi
  00039	8b c5		 mov	 eax, ebp
  0003b	2b d5		 sub	 edx, ebp
  0003d	8d 49 00	 npad	 3
$L187482:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00045	40		 inc	 eax
  00046	84 c9		 test	 cl, cl
  00048	75 f6		 jne	 SHORT $L187482
  0004a	8d 93 00 01 00
	00		 lea	 edx, DWORD PTR [ebx+256]
  00050	8b c6		 mov	 eax, esi
  00052	2b d6		 sub	 edx, esi
$L187483:
  00054	8a 08		 mov	 cl, BYTE PTR [eax]
  00056	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00059	40		 inc	 eax
  0005a	84 c9		 test	 cl, cl
  0005c	75 f6		 jne	 SHORT $L187483
  0005e	8d 93 00 02 00
	00		 lea	 edx, DWORD PTR [ebx+512]
  00064	8b c7		 mov	 eax, edi
  00066	2b d7		 sub	 edx, edi
$L187484:
  00068	8a 08		 mov	 cl, BYTE PTR [eax]
  0006a	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0006d	40		 inc	 eax
  0006e	84 c9		 test	 cl, cl
  00070	75 f6		 jne	 SHORT $L187484
  00072	8d bb 00 03 00
	00		 lea	 edi, DWORD PTR [ebx+768]
  00078	57		 push	 edi
  00079	6a 00		 push	 0
  0007b	6a 01		 push	 1
  0007d	e8 00 00 00 00	 call	 _SQLAllocHandle@12
  00082	8b 07		 mov	 eax, DWORD PTR [edi]
  00084	6a fa		 push	 -6			; fffffffaH
  00086	6a 03		 push	 3
  00088	68 c8 00 00 00	 push	 200			; 000000c8H
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _SQLSetEnvAttr@16
  00093	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00095	8d b3 04 03 00
	00		 lea	 esi, DWORD PTR [ebx+772]
  0009b	56		 push	 esi
  0009c	51		 push	 ecx
  0009d	6a 02		 push	 2
  0009f	e8 00 00 00 00	 call	 _SQLAllocHandle@12
  000a4	8b 84 24 24 02
	00 00		 mov	 eax, DWORD PTR _Type$[esp+540]
  000ab	48		 dec	 eax
  000ac	74 5e		 je	 SHORT $L186827

; 139  : 	strcpy( DBId, UID );
; 140  : 	strcpy( DBPass, PWD );
; 141  : 	
; 142  : 	SQLCHAR InCon[255];
; 143  : 	SQLCHAR OutCon[255];
; 144  :     SQLSMALLINT cbOutCon;
; 145  : 
; 146  : 	SQLRETURN ret;
; 147  : 
; 148  : 	//      .
; 149  : 	SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HANDLE,&hEnv);
; 150  : 	SQLSetEnvAttr(hEnv,SQL_ATTR_ODBC_VERSION,(SQLPOINTER)SQL_OV_ODBC3,SQL_IS_INTEGER);
; 151  : 	
; 152  : 	//    MDB  SQL ,  DSN .
; 153  : 	SQLAllocHandle(SQL_HANDLE_DBC,hEnv,&hDbc);
; 154  : 	switch (Type) 

  000ae	48		 dec	 eax
  000af	74 22		 je	 SHORT $L186831
  000b1	48		 dec	 eax

; 166  : 	case 3:
; 167  : 		ret=SQLConnect(hDbc,(SQLCHAR *)ConStr,SQL_NTS,(SQLCHAR *)UID,SQL_NTS,
; 168  : 			(SQLCHAR *)PWD,SQL_NTS);

  000b2	8b 44 24 14	 mov	 eax, DWORD PTR $T187487[esp+544]
  000b6	0f 85 8c 00 00
	00		 jne	 $L186824
  000bc	8b 54 24 18	 mov	 edx, DWORD PTR $T187488[esp+544]
  000c0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000c2	6a fd		 push	 -3			; fffffffdH
  000c4	52		 push	 edx
  000c5	6a fd		 push	 -3			; fffffffdH
  000c7	50		 push	 eax
  000c8	6a fd		 push	 -3			; fffffffdH
  000ca	55		 push	 ebp
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 _SQLConnect@28

; 169  : 		break;

  000d1	eb 75		 jmp	 SHORT $L186824
$L186831:

; 160  : 		break;
; 161  : 	case 2:
; 162  : 		wsprintf((char *)InCon, "FileDsn=%s",ConStr);

  000d3	55		 push	 ebp
  000d4	8d 54 24 20	 lea	 edx, DWORD PTR _InCon$[esp+548]
  000d8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@IGAOAHAB@FileDsn?$DN?$CFs?$AA@
  000dd	52		 push	 edx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 		ret=SQLDriverConnect(hDbc,NULL,(SQLCHAR *)InCon,sizeof(InCon),OutCon,
; 164  : 			sizeof(OutCon),&cbOutCon, SQL_DRIVER_NOPROMPT);

  000e7	6a 00		 push	 0
  000e9	8d 44 24 14	 lea	 eax, DWORD PTR _cbOutCon$[esp+548]
  000ed	50		 push	 eax
  000ee	8b 06		 mov	 eax, DWORD PTR [esi]
  000f0	68 ff 00 00 00	 push	 255			; 000000ffH
  000f5	8d 8c 24 28 01
	00 00		 lea	 ecx, DWORD PTR _OutCon$[esp+556]
  000fc	51		 push	 ecx
  000fd	68 ff 00 00 00	 push	 255			; 000000ffH
  00102	8d 54 24 30	 lea	 edx, DWORD PTR _InCon$[esp+564]
  00106	52		 push	 edx
  00107	6a 00		 push	 0
  00109	50		 push	 eax

; 165  : 		break;

  0010a	eb 37		 jmp	 SHORT $L187496
$L186827:

; 155  : 	{
; 156  : 	case 1:
; 157  : 		wsprintf((char *)InCon,"DRIVER={Microsoft Access Driver (*.mdb)};DBQ=%s;",ConStr);

  0010c	55		 push	 ebp
  0010d	8d 4c 24 20	 lea	 ecx, DWORD PTR _InCon$[esp+548]
  00111	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@LCKDCOHF@DRIVER?$DN?$HLMicrosoft?5Access?5Driver?5@
  00116	51		 push	 ecx
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  : 		ret=SQLDriverConnect(hDbc,NULL,(SQLCHAR *)InCon,sizeof(InCon),OutCon,
; 159  : 			sizeof(OutCon),&cbOutCon, SQL_DRIVER_NOPROMPT);

  00120	6a 00		 push	 0
  00122	8d 54 24 14	 lea	 edx, DWORD PTR _cbOutCon$[esp+548]
  00126	52		 push	 edx
  00127	8b 16		 mov	 edx, DWORD PTR [esi]
  00129	68 ff 00 00 00	 push	 255			; 000000ffH
  0012e	8d 84 24 28 01
	00 00		 lea	 eax, DWORD PTR _OutCon$[esp+556]
  00135	50		 push	 eax
  00136	68 ff 00 00 00	 push	 255			; 000000ffH
  0013b	8d 4c 24 30	 lea	 ecx, DWORD PTR _InCon$[esp+564]
  0013f	51		 push	 ecx
  00140	6a 00		 push	 0
  00142	52		 push	 edx
$L187496:
  00143	e8 00 00 00 00	 call	 _SQLDriverConnect@32
$L186824:

; 170  : 	}
; 171  : 
; 172  : 	if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO)) 

  00148	66 85 c0	 test	 ax, ax
  0014b	74 14		 je	 SHORT $L187493
  0014d	66 3d 01 00	 cmp	 ax, 1
  00151	74 0e		 je	 SHORT $L187493

; 173  : 	{
; 174  : 		PrintDiag( ConStr );

  00153	6a 02		 push	 2
  00155	55		 push	 ebp
  00156	8b cb		 mov	 ecx, ebx
  00158	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 175  : 		return FALSE;

  0015d	33 c0		 xor	 eax, eax
  0015f	eb 35		 jmp	 SHORT $L186817
$L187493:

; 176  : 	}
; 177  : 
; 178  : 	//   .
; 179  : 	ret=SQLAllocHandle(SQL_HANDLE_STMT,hDbc,&hStmt);

  00161	8b 06		 mov	 eax, DWORD PTR [esi]
  00163	8d bb 08 07 00
	00		 lea	 edi, DWORD PTR [ebx+1800]
  00169	57		 push	 edi
  0016a	50		 push	 eax
  0016b	6a 03		 push	 3
  0016d	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 180  : 	if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO)) 

  00172	66 85 c0	 test	 ax, ax
  00175	74 1a		 je	 SHORT $L187494
  00177	66 3d 01 00	 cmp	 ax, 1
  0017b	74 14		 je	 SHORT $L187494

; 181  : 	{
; 182  : 		PrintDiag( ConStr );

  0017d	6a 02		 push	 2
  0017f	55		 push	 ebp
  00180	8b cb		 mov	 ecx, ebx
  00182	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 183  : 		hStmt=0;

  00187	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 184  : 		return FALSE;

  0018d	33 c0		 xor	 eax, eax
  0018f	eb 05		 jmp	 SHORT $L186817
$L187494:

; 185  : 	}
; 186  : 
; 187  : //	::SQLSetStmtOption(hStmt, SQL_QUERY_TIMEOUT, 10);  // 10  
; 188  : 	return TRUE;

  00191	b8 01 00 00 00	 mov	 eax, 1
$L186817:

; 189  : }

  00196	8b 8c 24 1c 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+544]
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5d		 pop	 ebp
  001a0	5b		 pop	 ebx
  001a1	33 cc		 xor	 ecx, esp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	81 c4 10 02 00
	00		 add	 esp, 528		; 00000210H
  001ae	c2 10 00	 ret	 16			; 00000010H
?Connect@CQuery@@QAEHHPAD0PBD@Z ENDP			; CQuery::Connect
_TEXT	ENDS
PUBLIC	?Exec@CQuery@@QAEHPBD@Z				; CQuery::Exec
EXTRN	__imp__lstrlenA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Exec@CQuery@@QAEHPBD@Z
_TEXT	SEGMENT
_szSQL$ = 8						; size = 4
?Exec@CQuery@@QAEHPBD@Z PROC NEAR			; CQuery::Exec, COMDAT
; _this$ = ecx

; 216  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 217  : 	Clear();	//       .

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00010	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00016	6a 02		 push	 2
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 218  : 
; 219  : 	SQLRETURN ret = SQLExecDirect( hStmt, (SQLCHAR*)szSQL, lstrlen( szSQL ) );

  0001e	8b 7c 24 0c	 mov	 edi, DWORD PTR _szSQL$[esp+4]
  00022	57		 push	 edi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00029	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 220  : 	switch( ret )

  00037	0f bf c0	 movsx	 eax, ax
  0003a	85 c0		 test	 eax, eax
  0003c	7c 0a		 jl	 SHORT $L186868
  0003e	83 f8 01	 cmp	 eax, 1
  00041	7e 52		 jle	 SHORT $L186871
  00043	83 f8 64	 cmp	 eax, 100		; 00000064H

; 221  : 	{
; 222  : 	case SQL_SUCCESS_WITH_INFO:
; 223  : #ifdef _DEBUG
; 224  : 		PrintDiag( szSQL, SQL_HANDLE_STMT );	
; 225  : #endif
; 226  : 		//    
; 227  : 	case SQL_SUCCESS:
; 228  : 	case SQL_NO_DATA_FOUND:
; 229  : 		break;

  00046	74 4d		 je	 SHORT $L186871
$L186868:

; 230  : 	default:
; 231  : 		{
; 232  : 			PrintDiag( szSQL, SQL_HANDLE_STMT );	

  00048	6a 03		 push	 3
  0004a	57		 push	 edi
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 233  : 			DisConnect();

  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?DisConnect@CQuery@@QAEXXZ ; CQuery::DisConnect

; 234  : 			if( Connect( 3, DBName, DBId, DBPass ) )

  00059	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  0005f	50		 push	 eax
  00060	8d 8e 00 01 00
	00		 lea	 ecx, DWORD PTR [esi+256]
  00066	51		 push	 ecx
  00067	56		 push	 esi
  00068	6a 03		 push	 3
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?Connect@CQuery@@QAEHHPAD0PBD@Z ; CQuery::Connect
  00071	85 c0		 test	 eax, eax
  00073	74 2c		 je	 SHORT $L186869

; 235  : 			{
; 236  : 				ret = SQLExecDirect( hStmt, (SQLCHAR *)szSQL, SQL_NTS );

  00075	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0007b	6a fd		 push	 -3			; fffffffdH
  0007d	57		 push	 edi
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 237  : 				if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO) && (ret != SQL_NO_DATA)) 

  00084	66 85 c0	 test	 ax, ax
  00087	74 0c		 je	 SHORT $L186871
  00089	66 3d 01 00	 cmp	 ax, 1
  0008d	74 06		 je	 SHORT $L186871
  0008f	66 3d 64 00	 cmp	 ax, 100			; 00000064H

; 238  : 					return FALSE;

  00093	75 0c		 jne	 SHORT $L186869
$L186871:

; 242  : 		}
; 243  : 	}
; 244  : 
; 245  : 	return PrepareFetch();

  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?PrepareFetch@CQuery@@QAEHXZ ; CQuery::PrepareFetch
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 246  : }

  0009e	c2 04 00	 ret	 4
$L186869:
  000a1	5f		 pop	 edi

; 239  : 			}
; 240  : 			else
; 241  : 				return FALSE;

  000a2	33 c0		 xor	 eax, eax
  000a4	5e		 pop	 esi

; 246  : }

  000a5	c2 04 00	 ret	 4
?Exec@CQuery@@QAEHPBD@Z ENDP				; CQuery::Exec
_TEXT	ENDS
PUBLIC	?MoreResults@CQuery@@QAEHXZ			; CQuery::MoreResults
PUBLIC	??_C@_0P@PHEABAGN@SQLMoreResults?$AA@		; `string'
EXTRN	_SQLMoreResults@4:NEAR
;	COMDAT ??_C@_0P@PHEABAGN@SQLMoreResults?$AA@
CONST	SEGMENT
??_C@_0P@PHEABAGN@SQLMoreResults?$AA@ DB 'SQLMoreResults', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?MoreResults@CQuery@@QAEHXZ
_TEXT	SEGMENT
?MoreResults@CQuery@@QAEHXZ PROC NEAR			; CQuery::MoreResults, COMDAT
; _this$ = ecx

; 249  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 250  : //	Clear();	//       .
; 251  : 	
; 252  : 	SQLRETURN ret = SQLMoreResults( hStmt );

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _SQLMoreResults@4

; 253  : 	switch( ret ) {

  0000f	0f bf c0	 movsx	 eax, ax
  00012	85 c0		 test	 eax, eax
  00014	7c 0d		 jl	 SHORT $L186882
  00016	83 f8 01	 cmp	 eax, 1
  00019	7f 08		 jg	 SHORT $L186882

; 260  : 	}
; 261  : 
; 262  : 	return PrepareFetch();

  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	e9 00 00 00 00	 jmp	 ?PrepareFetch@CQuery@@QAEHXZ ; CQuery::PrepareFetch
$L186882:

; 254  : 	case SQL_SUCCESS:
; 255  : 	case SQL_SUCCESS_WITH_INFO:
; 256  : 		break;
; 257  : 	default:
; 258  : 		PrintDiag( "SQLMoreResults", SQL_HANDLE_STMT );	

  00023	6a 03		 push	 3
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@PHEABAGN@SQLMoreResults?$AA@
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 259  : 		return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 263  : }

  00034	c3		 ret	 0
?MoreResults@CQuery@@QAEHXZ ENDP			; CQuery::MoreResults
_TEXT	ENDS
PUBLIC	?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z	; CQuery::Exec
; Function compile flags: /Ogty
;	COMDAT ?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z
_TEXT	SEGMENT
_szSQL$ = 8						; size = 4
_nCount$ = 12						; size = 4
_infos$ = 16						; size = 4
?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z PROC NEAR	; CQuery::Exec, COMDAT
; _this$ = ecx

; 267  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 268  : 	Clear();	//       .

  00003	8b 86 08 07 00
	00		 mov	 eax, DWORD PTR [esi+1800]
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00010	8b 8e 08 07 00
	00		 mov	 ecx, DWORD PTR [esi+1800]
  00016	6a 02		 push	 2
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _SQLFreeStmt@8

; 269  : 
; 270  : 	SQLRETURN ret = SQLExecDirect( hStmt, (SQLCHAR*)szSQL, lstrlen( szSQL ) );

  0001e	8b 7c 24 0c	 mov	 edi, DWORD PTR _szSQL$[esp+4]
  00022	57		 push	 edi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00029	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 271  : 	switch( ret )

  00037	0f bf c0	 movsx	 eax, ax
  0003a	85 c0		 test	 eax, eax
  0003c	7c 0a		 jl	 SHORT $L186897
  0003e	83 f8 01	 cmp	 eax, 1
  00041	7e 52		 jle	 SHORT $L186900
  00043	83 f8 64	 cmp	 eax, 100		; 00000064H

; 272  : 	{
; 273  : 	case SQL_SUCCESS_WITH_INFO:
; 274  : #ifdef _DEBUG
; 275  : 		PrintDiag( szSQL, SQL_HANDLE_STMT );	
; 276  : #endif
; 277  : 		//    
; 278  : 	case SQL_SUCCESS:
; 279  : 	case SQL_NO_DATA_FOUND:
; 280  : 		break;

  00046	74 4d		 je	 SHORT $L186900
$L186897:

; 281  : 	default:
; 282  : 		{
; 283  : 			PrintDiag( szSQL, SQL_HANDLE_STMT );	

  00048	6a 03		 push	 3
  0004a	57		 push	 edi
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?PrintDiag@CQuery@@QAEXPBDF@Z ; CQuery::PrintDiag

; 284  : 			DisConnect();

  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?DisConnect@CQuery@@QAEXXZ ; CQuery::DisConnect

; 285  : 			if( Connect( 3, DBName, DBId, DBPass ) )

  00059	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  0005f	50		 push	 eax
  00060	8d 8e 00 01 00
	00		 lea	 ecx, DWORD PTR [esi+256]
  00066	51		 push	 ecx
  00067	56		 push	 esi
  00068	6a 03		 push	 3
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?Connect@CQuery@@QAEHHPAD0PBD@Z ; CQuery::Connect
  00071	85 c0		 test	 eax, eax
  00073	74 2c		 je	 SHORT $L186898

; 286  : 			{
; 287  : 				ret = SQLExecDirect( hStmt, (SQLCHAR *)szSQL, SQL_NTS );

  00075	8b 96 08 07 00
	00		 mov	 edx, DWORD PTR [esi+1800]
  0007b	6a fd		 push	 -3			; fffffffdH
  0007d	57		 push	 edi
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 288  : 				if ((ret != SQL_SUCCESS) && (ret != SQL_SUCCESS_WITH_INFO) && (ret != SQL_NO_DATA)) 

  00084	66 85 c0	 test	 ax, ax
  00087	74 0c		 je	 SHORT $L186900
  00089	66 3d 01 00	 cmp	 ax, 1
  0008d	74 06		 je	 SHORT $L186900
  0008f	66 3d 64 00	 cmp	 ax, 100			; 00000064H

; 289  : 					return FALSE;

  00093	75 0c		 jne	 SHORT $L186898
$L186900:

; 293  : 		}
; 294  : 	}
; 295  : 
; 296  : 	return PrepareFetch();

  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?PrepareFetch@CQuery@@QAEHXZ ; CQuery::PrepareFetch
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 297  : }

  0009e	c2 0c 00	 ret	 12			; 0000000cH
$L186898:
  000a1	5f		 pop	 edi

; 290  : 			}
; 291  : 			else
; 292  : 				return FALSE;

  000a2	33 c0		 xor	 eax, eax
  000a4	5e		 pop	 esi

; 297  : }

  000a5	c2 0c 00	 ret	 12			; 0000000cH
?Exec@CQuery@@QAEHPBDHQAUQUERY_BINDINFO@@@Z ENDP	; CQuery::Exec
_TEXT	ENDS
PUBLIC	?Execute@CQuery@@QAAHPBDZZ			; CQuery::Execute
; Function compile flags: /Ogty
;	COMDAT ?Execute@CQuery@@QAAHPBDZZ
_TEXT	SEGMENT
_szQuery$ = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Execute@CQuery@@QAAHPBDZZ PROC NEAR			; CQuery::Execute, COMDAT

; 671  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c5		 xor	 eax, ebp
  00013	57		 push	 edi
  00014	89 84 24 0c 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1040], eax

; 672  : 	char szQuery[1024]		= { 0,};

  0001b	33 c0		 xor	 eax, eax
  0001d	c6 44 24 08 00	 mov	 BYTE PTR _szQuery$[esp+1040], 0
  00022	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00027	8d 7c 24 09	 lea	 edi, DWORD PTR _szQuery$[esp+1041]
  0002b	f3 ab		 rep stosd

; 673  : 	va_list	args;
; 674  : 	va_start( args, lpszFormat );
; 675  : 	int n	= _vsntprintf( szQuery, 1024, lpszFormat, args );

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszFormat$[ebp]
  00030	66 ab		 stosw
  00032	aa		 stosb
  00033	8d 45 10	 lea	 eax, DWORD PTR _lpszFormat$[ebp+4]
  00036	50		 push	 eax
  00037	51		 push	 ecx
  00038	8d 54 24 10	 lea	 edx, DWORD PTR _szQuery$[esp+1048]
  0003c	68 00 04 00 00	 push	 1024			; 00000400H
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 __vsnprintf
  00047	83 c4 10	 add	 esp, 16			; 00000010H

; 676  : 	va_end( args );
; 677  : 	return n > 0 && Exec( szQuery );

  0004a	85 c0		 test	 eax, eax
  0004c	7e 29		 jle	 SHORT $L187513
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8d 44 24 08	 lea	 eax, DWORD PTR _szQuery$[esp+1040]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?Exec@CQuery@@QAEHPBD@Z	; CQuery::Exec
  0005b	85 c0		 test	 eax, eax
  0005d	74 18		 je	 SHORT $L187513
  0005f	b8 01 00 00 00	 mov	 eax, 1

; 678  : }

  00064	5f		 pop	 edi
  00065	8b 8c 24 08 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1036]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
$L187513:
  00077	8b 8c 24 0c 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1040]
  0007e	33 cd		 xor	 ecx, ebp
  00080	33 c0		 xor	 eax, eax
  00082	5f		 pop	 edi
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?Execute@CQuery@@QAAHPBDZZ ENDP				; CQuery::Execute
_TEXT	ENDS
END
