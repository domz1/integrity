; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\xUtil.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CC@DAGMFPKN@?$CFd?1?$CF2d?1?$CF2d?5?5?5?$CF02d?3?$CF02d?3?$CF02d?5?5?5?$CFs@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@INFALIMF@?4?4?2error?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?xRandom@@YAKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xRandomF@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xSRand@@YAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Error@@YAPBDPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileName@@YAXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileTitle@@YAXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExt@@YAXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFilePath@@YAXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFind@@YAHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringTrimRight@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeEven@@YAXAAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLanguageInfo@@YAXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLanguage@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSubLanguage@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUse2ndPassWord@@YAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsUse2ndPassWord@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Insert@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __tcsinc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?xRandom@@YAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_szWorkDir@@3PADA				; g_szWorkDir
PUBLIC	?g_szExeDir@@3PADA				; g_szExeDir
PUBLIC	?g_llFreq@@3T_LARGE_INTEGER@@A			; g_llFreq
PUBLIC	?g_nMaxTri@@3HA					; g_nMaxTri
PUBLIC	?g_next@@3KA					; g_next
PUBLIC	?g_osVersion@@3W4OSTYPE@@A			; g_osVersion
_BSS	SEGMENT
?g_szWorkDir@@3PADA DB 0100H DUP (?)			; g_szWorkDir
?g_szExeDir@@3PADA DB 0100H DUP (?)			; g_szExeDir
_g_nSubLanguage DD 01H DUP (?)
_g_b2ndPassWord DD 01H DUP (?)
?g_llFreq@@3T_LARGE_INTEGER@@A DQ 01H DUP (?)		; g_llFreq
?g_nMaxTri@@3HA DD 01H DUP (?)				; g_nMaxTri
?g_next@@3KA DD	01H DUP (?)				; g_next
?g_osVersion@@3W4OSTYPE@@A DD 01H DUP (?)		; g_osVersion
_BSS	ENDS
_DATA	SEGMENT
_g_bShowMsgBox DD 01H
_g_nLanguage DD	0ffffffffH
_DATA	ENDS
PUBLIC	?xRandomF@@YAMM@Z				; xRandomF
PUBLIC	__real@38000100
EXTRN	_rand:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@38000100
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\xutil.cpp
CONST	SEGMENT
__real@38000100 DD 038000100r			; 3.05185e-005
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?xRandomF@@YAMM@Z
_TEXT	SEGMENT
tv130 = -4						; size = 4
_num$ = 8						; size = 4
?xRandomF@@YAMM@Z PROC NEAR				; xRandomF, COMDAT

; 55   : {

  00000	51		 push	 ecx

; 56   : 	return ((float)rand() / (float)RAND_MAX) * (float)num;

  00001	e8 00 00 00 00	 call	 _rand
  00006	89 04 24	 mov	 DWORD PTR tv130[esp+4], eax
  00009	db 04 24	 fild	 DWORD PTR tv130[esp+4]
  0000c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@38000100
  00012	d8 4c 24 08	 fmul	 DWORD PTR _num$[esp]

; 57   : }

  00016	59		 pop	 ecx
  00017	c3		 ret	 0
?xRandomF@@YAMM@Z ENDP					; xRandomF
_TEXT	ENDS
PUBLIC	?xSRand@@YAXK@Z					; xSRand
; Function compile flags: /Ogty
;	COMDAT ?xSRand@@YAXK@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?xSRand@@YAXK@Z PROC NEAR				; xSRand, COMDAT

; 61   :    g_next = seed;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _seed$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next

; 62   : }

  00009	c3		 ret	 0
?xSRand@@YAXK@Z ENDP					; xSRand
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0CC@DAGMFPKN@?$CFd?1?$CF2d?1?$CF2d?5?5?5?$CF02d?3?$CF02d?3?$CF02d?5?5?5?$CFs@ ; `string'
PUBLIC	??_C@_0N@INFALIMF@?4?4?2error?4txt?$AA@		; `string'
PUBLIC	?Error@@YAPBDPBDZZ				; Error
EXTRN	?DEBUGOUT2@@YAXPBD0@Z:NEAR			; DEBUGOUT2
EXTRN	__imp__GetLocalTime@4:NEAR
EXTRN	_sprintf:NEAR
EXTRN	__vsnprintf:NEAR
EXTRN	__chkstk:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT ??_C@_0CC@DAGMFPKN@?$CFd?1?$CF2d?1?$CF2d?5?5?5?$CF02d?3?$CF02d?3?$CF02d?5?5?5?$CFs@
CONST	SEGMENT
??_C@_0CC@DAGMFPKN@?$CFd?1?$CF2d?1?$CF2d?5?5?5?$CF02d?3?$CF02d?3?$CF02d?5?5?5?$CFs@ DB '%'
	DB	'd/%2d/%2d   %02d:%02d:%02d   %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INFALIMF@?4?4?2error?4txt?$AA@
CONST	SEGMENT
??_C@_0N@INFALIMF@?4?4?2error?4txt?$AA@ DB '..\error.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?Error@@YAPBDPBDZZ
_TEXT	SEGMENT
_time$186797 = -16404					; size = 16
_szBuff$ = -16388					; size = 8192
_szStr$186796 = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_strFormat$ = 8						; size = 4
?Error@@YAPBDPBDZZ PROC NEAR				; Error, COMDAT

; 99   : {

  00000	b8 14 40 00 00	 mov	 eax, 16404		; 00004014H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 100  :     char szBuff[8192];
; 101  :     va_list args;
; 102  :     va_start(args, strFormat);
; 103  :     int n = _vsntprintf( szBuff, 8191, strFormat, args );

  0000f	8b 8c 24 18 40
	00 00		 mov	 ecx, DWORD PTR _strFormat$[esp+16400]
  00016	33 c4		 xor	 eax, esp
  00018	89 84 24 10 40
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+16404], eax
  0001f	8d 84 24 1c 40
	00 00		 lea	 eax, DWORD PTR _strFormat$[esp+16404]
  00026	50		 push	 eax
  00027	51		 push	 ecx
  00028	8d 54 24 18	 lea	 edx, DWORD PTR _szBuff$[esp+16412]
  0002c	68 ff 1f 00 00	 push	 8191			; 00001fffH
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 __vsnprintf
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 104  :     va_end(args);
; 105  : 
; 106  : 	if( n > 0 )

  0003a	85 c0		 test	 eax, eax
  0003c	7e 5a		 jle	 SHORT $L187091

; 107  : 	{
; 108  : #if defined(_DEBUG) && defined(__XUZHU)
; 109  : 		if( g_bShowMsgBox && MessageBox( NULL, szBuff, "오류", MB_OKCANCEL) == IDCANCEL )
; 110  : 			g_bShowMsgBox	= FALSE;		
; 111  : #endif
; 112  : 		char szStr[8192];
; 113  : 		SYSTEMTIME time;
; 114  : 		GetLocalTime( &time );

  0003e	8d 04 24	 lea	 eax, DWORD PTR _time$186797[esp+16404]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 115  : 		sprintf( szStr, "%d/%2d/%2d   %02d:%02d:%02d   %s\n", 
; 116  : 			time.wYear, time.wMonth, time.wDay,
; 117  : 			time.wHour, time.wMinute, time.wSecond, 
; 118  : 			szBuff );		

  00048	0f b7 54 24 0c	 movzx	 edx, WORD PTR _time$186797[esp+16416]
  0004d	0f b7 44 24 0a	 movzx	 eax, WORD PTR _time$186797[esp+16414]
  00052	8d 4c 24 10	 lea	 ecx, DWORD PTR _szBuff$[esp+16404]
  00056	51		 push	 ecx
  00057	0f b7 4c 24 0c	 movzx	 ecx, WORD PTR _time$186797[esp+16416]
  0005c	52		 push	 edx
  0005d	0f b7 54 24 0e	 movzx	 edx, WORD PTR _time$186797[esp+16418]
  00062	50		 push	 eax
  00063	0f b7 44 24 0e	 movzx	 eax, WORD PTR _time$186797[esp+16418]
  00068	51		 push	 ecx
  00069	0f b7 4c 24 10	 movzx	 ecx, WORD PTR _time$186797[esp+16420]
  0006e	52		 push	 edx
  0006f	50		 push	 eax
  00070	51		 push	 ecx
  00071	8d 94 24 2c 20
	00 00		 lea	 edx, DWORD PTR _szStr$186796[esp+16432]
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@DAGMFPKN@?$CFd?1?$CF2d?1?$CF2d?5?5?5?$CF02d?3?$CF02d?3?$CF02d?5?5?5?$CFs@
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _sprintf

; 119  : 		
; 120  : 		DEBUGOUT2( szStr );	

  00083	8d 84 24 34 20
	00 00		 lea	 eax, DWORD PTR _szStr$186796[esp+16440]
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@INFALIMF@?4?4?2error?4txt?$AA@
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?DEBUGOUT2@@YAXPBD0@Z	; DEBUGOUT2
  00095	83 c4 2c	 add	 esp, 44			; 0000002cH
$L187091:

; 121  : 	}
; 122  : 
; 123  : 	return "";
; 124  : }

  00098	8b 8c 24 10 40
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16404]
  0009f	33 cc		 xor	 ecx, esp
  000a1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	81 c4 14 40 00
	00		 add	 esp, 16404		; 00004014H
  000b1	c3		 ret	 0
?Error@@YAPBDPBDZZ ENDP					; Error
_TEXT	ENDS
PUBLIC	?GetFileName@@YAXPBDPAD@Z			; GetFileName
EXTRN	__imp__lstrcpyA@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetFileName@@YAXPBDPAD@Z
_TEXT	SEGMENT
_szSrc$ = 8						; size = 4
_szFileName$ = 12					; size = 4
?GetFileName@@YAXPBDPAD@Z PROC NEAR			; GetFileName, COMDAT

; 155  : 	int	len, i;
; 156  : 	// 파일명만 추출.
; 157  : 	i	= len	= strlen( szSrc );		// 풀네임 길이 읽음

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _szSrc$[esp-4]
  00004	8b c2		 mov	 eax, edx
  00006	56		 push	 esi
  00007	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000a	8d 9b 00 00 00
	00		 npad	 6
$L187101:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L187101
  00017	2b c6		 sub	 eax, esi
  00019	5e		 pop	 esi

; 158  : 	while( i-- )

  0001a	74 2f		 je	 SHORT $L187100
  0001c	8d 64 24 00	 npad	 4
$L186807:

; 159  : 	{	// 스트링 뒤에서 부터 훑으며 \가 나오는곳을 찾는다.
; 160  : 		if( szSrc[i] == '\\' )

  00020	8a 4c 10 ff	 mov	 cl, BYTE PTR [eax+edx-1]
  00024	48		 dec	 eax
  00025	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00028	74 11		 je	 SHORT $L187099

; 163  : 			break;
; 164  : 		}
; 165  : 		if( i == 0 )		// 끝까지 검색했는데도 \가 나오지 않았으면 그대로 씀

  0002a	85 c0		 test	 eax, eax
  0002c	75 f2		 jne	 SHORT $L186807

; 166  : 			lstrcpy( szFileName, szSrc );

  0002e	8b 44 24 08	 mov	 eax, DWORD PTR _szFileName$[esp-4]
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 167  : 	}
; 168  : }

  0003a	c3		 ret	 0
$L187099:

; 161  : 		{
; 162  : 			lstrcpy( szFileName, szSrc + i + 1 );	// \가 나온 다음 칸부터 파일명으로 씀

  0003b	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0003f	8b 54 24 08	 mov	 edx, DWORD PTR _szFileName$[esp-4]
  00043	51		 push	 ecx
  00044	52		 push	 edx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
$L187100:

; 167  : 	}
; 168  : }

  0004b	c3		 ret	 0
?GetFileName@@YAXPBDPAD@Z ENDP				; GetFileName
_TEXT	ENDS
PUBLIC	?GetFileTitle@@YAXPBDPAD@Z			; GetFileTitle
; Function compile flags: /Ogty
;	COMDAT ?GetFileTitle@@YAXPBDPAD@Z
_TEXT	SEGMENT
_szSrc$ = 8						; size = 4
_szFileTitle$ = 12					; size = 4
?GetFileTitle@@YAXPBDPAD@Z PROC NEAR			; GetFileTitle, COMDAT

; 196  : 	int		len, i;
; 197  : 	GetFileName( szSrc, szFileTitle );		// 패스 분리

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _szSrc$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _szFileTitle$[esp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?GetFileName@@YAXPBDPAD@Z ; GetFileName

; 198  : 
; 199  : 	// 파일명 추출.
; 200  : 	len	= strlen( szFileTitle );	// 풀네임 길이 읽음

  00010	8b c6		 mov	 eax, esi
  00012	83 c4 08	 add	 esp, 8
  00015	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L187108:
  00018	8a 08		 mov	 cl, BYTE PTR [eax]
  0001a	40		 inc	 eax
  0001b	84 c9		 test	 cl, cl
  0001d	75 f9		 jne	 SHORT $L187108
  0001f	2b c2		 sub	 eax, edx

; 201  : 	for( i = 0; i < len; i ++ )

  00021	33 c9		 xor	 ecx, ecx
  00023	85 c0		 test	 eax, eax
  00025	7e 0b		 jle	 SHORT $L187110
$L186817:

; 202  : 	{
; 203  : 		if( szFileTitle[i] == '.' )

  00027	80 3c 31 2e	 cmp	 BYTE PTR [ecx+esi], 46	; 0000002eH
  0002b	74 05		 je	 SHORT $L187110
  0002d	41		 inc	 ecx
  0002e	3b c8		 cmp	 ecx, eax
  00030	7c f5		 jl	 SHORT $L186817
$L187110:

; 204  : 			break;
; 205  : 	}
; 206  : 	szFileTitle[i]	= '\0';

  00032	c6 04 31 00	 mov	 BYTE PTR [ecx+esi], 0
  00036	5e		 pop	 esi

; 207  : }

  00037	c3		 ret	 0
?GetFileTitle@@YAXPBDPAD@Z ENDP				; GetFileTitle
_TEXT	ENDS
PUBLIC	?GetFileExt@@YAXPBDPAD@Z			; GetFileExt
; Function compile flags: /Ogty
;	COMDAT ?GetFileExt@@YAXPBDPAD@Z
_TEXT	SEGMENT
_szSrc$ = 8						; size = 4
_szFileExt$ = 12					; size = 4
?GetFileExt@@YAXPBDPAD@Z PROC NEAR			; GetFileExt, COMDAT

; 235  : 	int		len, i;
; 236  : 	len	= strlen( szSrc );		// 풀네임 길이 읽음

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _szSrc$[esp-4]
  00004	8b c2		 mov	 eax, edx
  00006	56		 push	 esi
  00007	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000a	8d 9b 00 00 00
	00		 npad	 6
$L187116:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L187116
  00017	2b c6		 sub	 eax, esi
  00019	5e		 pop	 esi

; 237  : 	i	= len;
; 238  : 	while( i-- )

  0001a	74 23		 je	 SHORT $L187115
  0001c	8d 64 24 00	 npad	 4
$L186828:

; 239  : 	{	// 스트링 뒤에서 부터 훑으며 .이 나오는곳을 찾는다.
; 240  : 		if( szSrc[i] == '.' )

  00020	8a 4c 10 ff	 mov	 cl, BYTE PTR [eax+edx-1]
  00024	48		 dec	 eax
  00025	80 f9 2e	 cmp	 cl, 46			; 0000002eH
  00028	74 05		 je	 SHORT $L187114

; 237  : 	i	= len;
; 238  : 	while( i-- )

  0002a	85 c0		 test	 eax, eax
  0002c	75 f2		 jne	 SHORT $L186828

; 243  : 			break;
; 244  : 		}
; 245  : 	}
; 246  : }

  0002e	c3		 ret	 0
$L187114:

; 241  : 		{
; 242  : 			lstrcpy( szFileExt, szSrc + i + 1 );	// .가 나온 다음 칸부터 확장자로 씀

  0002f	8b 4c 24 08	 mov	 ecx, DWORD PTR _szFileExt$[esp-4]
  00033	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
$L187115:

; 243  : 			break;
; 244  : 		}
; 245  : 	}
; 246  : }

  0003f	c3		 ret	 0
?GetFileExt@@YAXPBDPAD@Z ENDP				; GetFileExt
_TEXT	ENDS
PUBLIC	?GetFilePath@@YAXPBDPAD@Z			; GetFilePath
EXTRN	_strncpy:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetFilePath@@YAXPBDPAD@Z
_TEXT	SEGMENT
_szSrc$ = 8						; size = 4
_szFilePath$ = 12					; size = 4
?GetFilePath@@YAXPBDPAD@Z PROC NEAR			; GetFilePath, COMDAT

; 268  : 	int len	= strlen( szSrc );	// 풀네임 길이구함

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _szSrc$[esp-4]
  00004	56		 push	 esi
  00005	8b c2		 mov	 eax, edx
  00007	57		 push	 edi
  00008	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L187122:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L187122
  00017	2b c6		 sub	 eax, esi

; 269  : 	// 마지막 \찾음
; 270  : 	for( int i = len-1; i >= 0; i -- )

  00019	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  0001c	85 f6		 test	 esi, esi
  0001e	7c 09		 jl	 SHORT $L187120
$L186837:

; 271  : 	{
; 272  : 		if( szSrc[i] == '\\' )

  00020	80 3c 16 5c	 cmp	 BYTE PTR [esi+edx], 92	; 0000005cH
  00024	74 03		 je	 SHORT $L187120

; 269  : 	// 마지막 \찾음
; 270  : 	for( int i = len-1; i >= 0; i -- )

  00026	4e		 dec	 esi
  00027	79 f7		 jns	 SHORT $L186837
$L187120:

; 273  : 			break;
; 274  : 	}
; 275  : 	strncpy( szFilePath, szSrc, i+1 );		// 패스 부분만 카피

  00029	8b 7c 24 10	 mov	 edi, DWORD PTR _szFilePath$[esp+4]
  0002d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00030	50		 push	 eax
  00031	52		 push	 edx
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 _strncpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 276  : 	szFilePath[i+1] = '\0';

  0003b	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 277  : }

  00042	c3		 ret	 0
?GetFilePath@@YAXPBDPAD@Z ENDP				; GetFilePath
_TEXT	ENDS
PUBLIC	?StringFind@@YAHPBDH@Z				; StringFind
EXTRN	_strchr:NEAR
; Function compile flags: /Ogty
;	COMDAT ?StringFind@@YAHPBDH@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
_c$ = 12						; size = 4
?StringFind@@YAHPBDH@Z PROC NEAR			; StringFind, COMDAT

; 367  : 	char* pdest;
; 368  : 	return ( pdest = strchr( string, c ) ) ? pdest - string : -1;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _c$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _string$[esp]
  00009	50		 push	 eax
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 _strchr
  00010	83 c4 08	 add	 esp, 8
  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $L187125
  00017	2b c6		 sub	 eax, esi
  00019	5e		 pop	 esi

; 369  : }

  0001a	c3		 ret	 0
$L187125:

; 367  : 	char* pdest;
; 368  : 	return ( pdest = strchr( string, c ) ) ? pdest - string : -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	5e		 pop	 esi

; 369  : }

  0001f	c3		 ret	 0
?StringFind@@YAHPBDH@Z ENDP				; StringFind
_TEXT	ENDS
PUBLIC	?MakeEven@@YAXAAJ@Z				; MakeEven
; Function compile flags: /Ogty
;	COMDAT ?MakeEven@@YAXAAJ@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?MakeEven@@YAXAAJ@Z PROC NEAR				; MakeEven, COMDAT

; 414  : 	x ++;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _x$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	41		 inc	 ecx

; 415  : 	x &= (~0x01);

  00007	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 416  : }

  0000c	c3		 ret	 0
?MakeEven@@YAXAAJ@Z ENDP				; MakeEven
_TEXT	ENDS
PUBLIC	?SetLanguageInfo@@YAXHH@Z			; SetLanguageInfo
; Function compile flags: /Ogty
;	COMDAT ?SetLanguageInfo@@YAXHH@Z
_TEXT	SEGMENT
_nLanguage$ = 8						; size = 4
_nSubLanguage$ = 12					; size = 4
?SetLanguageInfo@@YAXHH@Z PROC NEAR			; SetLanguageInfo, COMDAT

; 422  : 	g_nLanguage = nLanguage;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLanguage$[esp-4]

; 423  : 	g_nSubLanguage = nSubLanguage;

  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _nSubLanguage$[esp-4]
  00008	a3 00 00 00 00	 mov	 DWORD PTR _g_nLanguage, eax
  0000d	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_nSubLanguage, ecx

; 424  : }

  00013	c3		 ret	 0
?SetLanguageInfo@@YAXHH@Z ENDP				; SetLanguageInfo
_TEXT	ENDS
PUBLIC	?GetLanguage@@YAHXZ				; GetLanguage
; Function compile flags: /Ogty
;	COMDAT ?GetLanguage@@YAHXZ
_TEXT	SEGMENT
?GetLanguage@@YAHXZ PROC NEAR				; GetLanguage, COMDAT

; 428  : 	ASSERT( g_nLanguage >= 0 );
; 429  : 	return g_nLanguage;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_nLanguage

; 430  : }

  00005	c3		 ret	 0
?GetLanguage@@YAHXZ ENDP				; GetLanguage
_TEXT	ENDS
PUBLIC	?GetSubLanguage@@YAHXZ				; GetSubLanguage
; Function compile flags: /Ogty
;	COMDAT ?GetSubLanguage@@YAHXZ
_TEXT	SEGMENT
?GetSubLanguage@@YAHXZ PROC NEAR			; GetSubLanguage, COMDAT

; 434  : 	return g_nSubLanguage;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_nSubLanguage

; 435  : }

  00005	c3		 ret	 0
?GetSubLanguage@@YAHXZ ENDP				; GetSubLanguage
_TEXT	ENDS
PUBLIC	?SetUse2ndPassWord@@YAXH@Z			; SetUse2ndPassWord
; Function compile flags: /Ogty
;	COMDAT ?SetUse2ndPassWord@@YAXH@Z
_TEXT	SEGMENT
_bUse$ = 8						; size = 4
?SetUse2ndPassWord@@YAXH@Z PROC NEAR			; SetUse2ndPassWord, COMDAT

; 440  : 	g_b2ndPassWord = bUse;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bUse$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR _g_b2ndPassWord, eax

; 441  : }

  00009	c3		 ret	 0
?SetUse2ndPassWord@@YAXH@Z ENDP				; SetUse2ndPassWord
_TEXT	ENDS
PUBLIC	?IsUse2ndPassWord@@YAHXZ			; IsUse2ndPassWord
; Function compile flags: /Ogty
;	COMDAT ?IsUse2ndPassWord@@YAHXZ
_TEXT	SEGMENT
?IsUse2ndPassWord@@YAHXZ PROC NEAR			; IsUse2ndPassWord, COMDAT

; 445  : 	return g_b2ndPassWord;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_b2ndPassWord

; 446  : }

  00005	c3		 ret	 0
?IsUse2ndPassWord@@YAHXZ ENDP				; IsUse2ndPassWord
_TEXT	ENDS
PUBLIC	__tcsinc
EXTRN	__mbsinc:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\tchar.h
;	COMDAT __tcsinc
_TEXT	SEGMENT
__s1$ = 8						; size = 4
__tcsinc PROC NEAR					; COMDAT

; 880  : __inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}

  00000	e9 00 00 00 00	 jmp	 __mbsinc
__tcsinc ENDP
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L39166

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L39166:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L187144:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 66   : 		return (this+1);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 67   : 	}

  00003	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
; Function compile flags: /Ogty
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?AddRef@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 71   : 		ATLASSERT(nRefs > 0);
; 72   : 		_InterlockedIncrement(&nRefs);

  00000	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 73   : 	}

  0000c	c3		 ret	 0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 76   : 		return nRefs < 0;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 9c c0	 setl	 al

; 77   : 	}

  0000a	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Ogty
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 80   : 		return( nRefs > 1 ); 

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 01	 cmp	 edx, 1
  00008	0f 9f c0	 setg	 al

; 81   : 	}

  0000b	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Ogty
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	4a		 dec	 edx
  0000b	85 d2		 test	 edx, edx
  0000d	7f 0a		 jg	 SHORT $L39883

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b c8		 mov	 ecx, eax
  00016	ff 52 04	 call	 DWORD PTR [edx+4]
$L39883:

; 98   : 		}
; 99   : 	}

  00019	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	?xRand@@YAKXZ					; xRand
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\xutil.h
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT
?xRand@@YAKXZ PROC NEAR					; xRand, COMDAT

; 16   : 	g_next = g_next * 1103515245 + 12345;// + nRandomSeed[ i++ ];

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next

; 17   : 	return g_next;	// 억단위 확률이 필요해서바꿈.
; 18   : }

  00015	c3		 ret	 0
?xRand@@YAKXZ ENDP					; xRand
_TEXT	ENDS
PUBLIC	?xRandom@@YAKK@Z				; xRandom
; Function compile flags: /Ogty
;	COMDAT ?xRandom@@YAKK@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
?xRandom@@YAKK@Z PROC NEAR				; xRandom, COMDAT

; 22   : 	return  xRand() % num;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  00015	33 d2		 xor	 edx, edx
  00017	f7 74 24 04	 div	 DWORD PTR _num$[esp-4]
  0001b	8b c2		 mov	 eax, edx

; 23   : }

  0001d	c3		 ret	 0
?xRandom@@YAKK@Z ENDP					; xRandom
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  00005	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Ogty
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L184241
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L184241

; 794  : 			AtlThrow(E_INVALIDARG);
; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 797  : 		m_pszData[nLength] = 0;

  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 798  : 	}

  00018	c2 04 00	 ret	 4
$L184241:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187172:
  00025	cc		 int	 3
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
EXTRN	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ:NEAR ; AfxGetStringManager
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\afxstr.h
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 50   : 		return( AfxGetStringManager() );

  00000	e9 00 00 00 00	 jmp	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pData$[esp-4]
  00004	83 c0 10	 add	 eax, 16			; 00000010H
  00007	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00009	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Ogty
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nChars$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp]
  00009	8b c1		 mov	 eax, ecx
  0000b	57		 push	 edi
  0000c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pchDest$[esp+4]
  00010	c1 e9 02	 shr	 ecx, 2
  00013	f3 a5		 rep movsd
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	f3 a4		 rep movsb
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 654  : 	}

  0001e	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Ogty
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00000	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00005	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187185:
  0000a	cc		 int	 3
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Ogty
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv181 = 8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 716  : 		CStringData* pOldData = GetData();

  00002	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00004	83 eb 10	 sub	 ebx, 16			; 00000010H
  00007	55		 push	 ebp

; 717  : 		int nOldLength = pOldData->nDataLength;

  00008	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$[esp+12], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0000f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 10	 call	 DWORD PTR [eax+16]
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _nLength$[esp+12]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	6a 01		 push	 1
  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	ff 12		 call	 DWORD PTR [edx]

; 719  : 		if( pNewData == NULL )

  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $L185534

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00028	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L185534:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0002d	3b ee		 cmp	 ebp, esi
  0002f	7d 02		 jge	 SHORT $L187189
  00031	8b f5		 mov	 esi, ebp
$L187189:
  00033	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  00036	8b d1		 mov	 edx, ecx
  00038	57		 push	 edi
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	89 7c 24 18	 mov	 DWORD PTR tv181[esp+16], edi
  00043	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00046	f3 a5		 rep movsd
  00048	8b ca		 mov	 ecx, edx
  0004a	83 e1 03	 and	 ecx, 3
  0004d	f3 a4		 rep movsb

; 725  : 		pNewData->nDataLength = nOldLength;

  0004f	89 68 04	 mov	 DWORD PTR [eax+4], ebp

; 726  : 		pOldData->Release();

  00052	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00055	83 c9 ff	 or	 ecx, -1
  00058	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0005c	49		 dec	 ecx
  0005d	85 c9		 test	 ecx, ecx
  0005f	5f		 pop	 edi
  00060	7f 08		 jg	 SHORT $L187205
  00062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	53		 push	 ebx
  00067	ff 52 04	 call	 DWORD PTR [edx+4]
$L187205:

; 727  : 		Attach( pNewData );

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR tv181[esp+12]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	5b		 pop	 ebx

; 728  : 	}

  00077	59		 pop	 ecx
  00078	c2 04 00	 ret	 4
$L187214:
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Ogty
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 777  : 		CStringData* pOldData = GetData();
; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nLength$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	83 e8 10	 sub	 eax, 16			; 00000010H
  00012	6a 01		 push	 1
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	ff 52 08	 call	 DWORD PTR [edx+8]

; 781  : 		if( pNewData == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L185543

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0001d	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L185543:

; 784  : 		}
; 785  : 		Attach( pNewData );

  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	5f		 pop	 edi
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	5e		 pop	 esi

; 786  : 	}

  00029	c2 04 00	 ret	 4
$L187228:
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?xRandom@@YAKKK@Z				; xRandom
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\xutil.cpp
;	COMDAT ?xRandom@@YAKKK@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?xRandom@@YAKKK@Z PROC NEAR				; xRandom, COMDAT

; 47   : 	if( max > min )

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _max$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _min$[esp]
  00009	3b ce		 cmp	 ecx, esi
  0000b	76 21		 jbe	 SHORT $L186772

; 48   : 		return min + xRandom( max - min );

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00012	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  00018	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  0001d	2b ce		 sub	 ecx, esi
  0001f	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  00024	33 d2		 xor	 edx, edx
  00026	f7 f1		 div	 ecx
  00028	8b c2		 mov	 eax, edx
  0002a	03 c6		 add	 eax, esi
  0002c	5e		 pop	 esi

; 51   : }

  0002d	c3		 ret	 0
$L186772:

; 49   : 	else
; 50   : 		return min;

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 51   : }

  00031	c3		 ret	 0
?xRandom@@YAKKK@Z ENDP					; xRandom
_TEXT	ENDS
PUBLIC	?StringTrimRight@@YAXPAD@Z			; StringTrimRight
EXTRN	__ismbcspace:NEAR
; Function compile flags: /Ogty
;	COMDAT ?StringTrimRight@@YAXPAD@Z
_TEXT	SEGMENT
_szString$ = 8						; size = 4
?StringTrimRight@@YAXPAD@Z PROC NEAR			; StringTrimRight, COMDAT

; 372  : {

  00000	56		 push	 esi

; 373  : 	// find beginning of trailing spaces by starting at beginning (DBCS aware)
; 374  : 	LPTSTR lpsz = szString;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _szString$[esp]

; 375  : 	LPTSTR lpszLast = NULL;
; 376  : 
; 377  : 	while (*lpsz != '\0')

  00005	8a 06		 mov	 al, BYTE PTR [esi]
  00007	57		 push	 edi
  00008	33 ff		 xor	 edi, edi
  0000a	84 c0		 test	 al, al
  0000c	74 34		 je	 SHORT $L186857
  0000e	8b ff		 npad	 2
$L186852:

; 378  : 	{
; 379  : 		if (_istspace(*lpsz))

  00010	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 __ismbcspace
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c0		 test	 eax, eax
  0001e	74 08		 je	 SHORT $L186854

; 380  : 		{
; 381  : 			if (lpszLast == NULL)

  00020	85 ff		 test	 edi, edi
  00022	75 06		 jne	 SHORT $L186856

; 382  : 				lpszLast = lpsz;

  00024	8b fe		 mov	 edi, esi

; 383  : 		}
; 384  : 		else

  00026	eb 02		 jmp	 SHORT $L186856
$L186854:

; 385  : 			lpszLast = NULL;

  00028	33 ff		 xor	 edi, edi
$L186856:

; 386  : 		lpsz = _tcsinc(lpsz);

  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 __mbsinc
  00030	8b f0		 mov	 esi, eax
  00032	8a 06		 mov	 al, BYTE PTR [esi]
  00034	83 c4 04	 add	 esp, 4
  00037	84 c0		 test	 al, al
  00039	75 d5		 jne	 SHORT $L186852

; 387  : 	}
; 388  : 
; 389  : 	if (lpszLast != NULL)

  0003b	85 ff		 test	 edi, edi
  0003d	74 03		 je	 SHORT $L186857

; 390  : 	{
; 391  : 		// truncate at trailing space start
; 392  : 		*lpszLast = '\0';

  0003f	c6 07 00	 mov	 BYTE PTR [edi], 0
$L186857:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 393  : 	}
; 394  : }

  00044	c3		 ret	 0
?StringTrimRight@@YAXPAD@Z ENDP				; StringTrimRight
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 501  : 		return( GetData()->nDataLength );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]

; 502  : 	}

  00005	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 210  : 	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 211  : 	{
; 212  : 		ATLASSERT( pStringMgr != NULL );
; 213  : 		CStringData* pData = pStringMgr->GetNilString();

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _pStringMgr$[esp]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 0c	 call	 DWORD PTR [eax+12]

; 214  : 		Attach( pData );

  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 06		 mov	 DWORD PTR [esi], eax

; 215  : 	}

  00011	8b c6		 mov	 eax, esi
  00013	5e		 pop	 esi
  00014	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 263  : 		CStringData* pData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 264  : 		pData->Release();

  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L187269
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L187269:

; 265  : 	}

  0001c	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
; Function compile flags: /Ogty
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nNewLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L187286
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L187286
  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 549  : 	}

  00018	c2 04 00	 ret	 4
$L187286:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187288:
  00025	cc		 int	 3
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 747  : 		CStringData* pOldData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 748  : 		if( pOldData->nDataLength > nLength )

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _nLength$[esp-4]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7e 02		 jle	 SHORT $L184961

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  00011	8b d6		 mov	 edx, esi
$L184961:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00013	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00017	5e		 pop	 esi
  00018	7e 09		 jle	 SHORT $L184962

; 753  : 		{
; 754  : 			Fork( nLength );

  0001a	89 54 24 04	 mov	 DWORD PTR _nLength$[esp-4], edx
  0001e	e9 00 00 00 00	 jmp	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L184962:

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00023	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00026	3b c2		 cmp	 eax, edx
  00028	7d 1f		 jge	 SHORT $L184964

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;
; 760  : 			if( nNewLength > 1024 )

  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7e 07		 jle	 SHORT $L184966

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00031	05 00 04 00 00	 add	 eax, 1024		; 00000400H

; 763  : 			}
; 764  : 			else

  00036	eb 02		 jmp	 SHORT $L184967
$L184966:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00038	03 c0		 add	 eax, eax
$L184967:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 02		 jge	 SHORT $L184968

; 769  : 			{
; 770  : 				nNewLength = nLength;

  0003e	8b c2		 mov	 eax, edx
$L184968:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00040	89 44 24 04	 mov	 DWORD PTR _nLength$[esp-4], eax
  00044	e9 00 00 00 00	 jmp	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L184964:

; 773  : 		}
; 774  : 	}

  00049	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
PUBLIC	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
; Function compile flags: /Ogty
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CloneData, COMDAT

; 801  : 	{

  00000	56		 push	 esi

; 802  : 		CStringData* pNewData = NULL;
; 803  : 
; 804  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pData$[esp]
  00005	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 10	 call	 DWORD PTR [eax+16]

; 805  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

  0000c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0000f	85 d2		 test	 edx, edx
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	7c 11		 jl	 SHORT $L184972
  00016	3b 06		 cmp	 eax, DWORD PTR [esi]
  00018	75 0d		 jne	 SHORT $L184972

; 806  : 		{
; 807  : 			pNewData = pData;

  0001a	8b c6		 mov	 eax, esi

; 808  : 			pNewData->AddRef();

  0001c	ba 01 00 00 00	 mov	 edx, 1
  00021	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00025	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  00026	c3		 ret	 0
$L184972:

; 809  : 		}
; 810  : 		else
; 811  : 		{
; 812  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	6a 01		 push	 1
  0002e	51		 push	 ecx
  0002f	8b c8		 mov	 ecx, eax
  00031	ff 12		 call	 DWORD PTR [edx]

; 813  : 			if( pNewData == NULL )

  00033	85 c0		 test	 eax, eax
  00035	75 05		 jne	 SHORT $L184975

; 814  : 			{
; 815  : 				ThrowMemoryException();

  00037	e9 00 00 00 00	 jmp	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L184975:

; 816  : 			}
; 817  : 			pNewData->nDataLength = pData->nDataLength;

  0003c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 818  : 			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'

  00042	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00045	41		 inc	 ecx
  00046	8b d1		 mov	 edx, ecx
  00048	57		 push	 edi
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	83 c6 10	 add	 esi, 16			; 00000010H
  0004f	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  00052	f3 a5		 rep movsd
  00054	8b ca		 mov	 ecx, edx
  00056	83 e1 03	 and	 ecx, 3
  00059	f3 a4		 rep movsb
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  0005d	c3		 ret	 0
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ENDP ; ATL::CSimpleStringT<char,0>::CloneData
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 796  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	8b c8		 mov	 ecx, eax
  0000c	ff 52 0c	 call	 DWORD PTR [edx+12]
  0000f	83 c0 10	 add	 eax, 16			; 00000010H
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 797  : 	}

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	c3		 ret	 0
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 963  : 	}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H
  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L187354
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L187354:
  0001c	c3		 ret	 0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H

; 220  : 		CStringData* pNewData = CloneData( pSrcData );

  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData

; 221  : 		Attach( pNewData );

  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 222  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 735  : 		CStringData* pOldData = GetData();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nLength$[esp]
  00019	2b d0		 sub	 edx, eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L187374

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L187374:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 744  : 	}

  0002a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 814  : 	{

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 815  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nMinBufferLength$[esp]
  00019	2b d0		 sub	 edx, eax
  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L187415
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L187415:
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 491  : 	}

  0002a	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	?Insert@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Insert
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?Insert@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHD@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_ch$ = 12						; size = 1
?Insert@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Insert, COMDAT
; _this$ = ecx

; 1140 : 	{

  00000	53		 push	 ebx

; 1141 : 		if( iIndex < 0 )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _iIndex$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b e9		 mov	 ebp, ecx
  0000c	7d 02		 jge	 SHORT $L186889

; 1142 : 			iIndex = 0;

  0000e	33 db		 xor	 ebx, ebx
$L186889:

; 1143 : 			
; 1144 : 		if( iIndex > GetLength() )

  00010	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00013	8b 70 f4	 mov	 esi, DWORD PTR [eax-12]
  00016	3b de		 cmp	 ebx, esi
  00018	7e 02		 jle	 SHORT $L187434

; 1145 : 		{
; 1146 : 			iIndex = GetLength();

  0001a	8b de		 mov	 ebx, esi
$L187434:

; 1147 : 		}
; 1148 : 		int nNewLength = GetLength()+1;
; 1149 : 
; 1150 : 		PXSTR pszBuffer = GetBuffer( nNewLength );

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	2b ca		 sub	 ecx, edx
  00026	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00029	46		 inc	 esi
  0002a	2b d6		 sub	 edx, esi
  0002c	0b ca		 or	 ecx, edx
  0002e	7d 08		 jge	 SHORT $L187466
  00030	56		 push	 esi
  00031	8b cd		 mov	 ecx, ebp
  00033	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L187466:
  00038	8b 7d 00	 mov	 edi, DWORD PTR [ebp]

; 1151 : 
; 1152 : 		// move existing bytes down
; 1153 : 		memmove( pszBuffer+iIndex+1, pszBuffer+iIndex, (nNewLength-iIndex)*sizeof( XCHAR ) );

  0003b	8b c6		 mov	 eax, esi
  0003d	2b c3		 sub	 eax, ebx
  0003f	50		 push	 eax
  00040	03 fb		 add	 edi, ebx
  00042	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00045	57		 push	 edi
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _memmove

; 1154 : 		pszBuffer[iIndex] = ch;

  0004c	8a 54 24 24	 mov	 dl, BYTE PTR _ch$[esp+24]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1155 : 
; 1156 : 		ReleaseBufferSetLength( nNewLength );

  00053	85 f6		 test	 esi, esi
  00055	88 17		 mov	 BYTE PTR [edi], dl
  00057	7c 1b		 jl	 SHORT $L187493
  00059	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0005c	3b 70 f8	 cmp	 esi, DWORD PTR [eax-8]
  0005f	7f 13		 jg	 SHORT $L187493
  00061	89 70 f4	 mov	 DWORD PTR [eax-12], esi
  00064	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00067	5f		 pop	 edi
  00068	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 1157 : 
; 1158 : 		return( nNewLength );

  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi
  0006f	5d		 pop	 ebp
  00070	5b		 pop	 ebx

; 1159 : 	}

  00071	c2 08 00	 ret	 8
$L187493:
  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L187496:
  0007e	cc		 int	 3
?Insert@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Insert
_TEXT	ENDS
PUBLIC	?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; GetNumberFormatEx
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T187917 DD	0ffffffffH
	DD	FLAT:$L187499
$T187907 DD	019930520H
	DD	01H
	DD	FLAT:$T187917
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\xutil.cpp
xdata$x	ENDS
;	COMDAT ?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
_TEXT	SEGMENT
$T187651 = -28						; size = 1
_str$ = -24						; size = 4
_i$186865 = -20						; size = 4
tv569 = -16						; size = 4
$T187501 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szNumber$ = 12						; size = 4
?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z PROC NEAR ; GetNumberFormatEx, COMDAT

; 397  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 398  : 	ASSERT( szNumber );
; 399  : 
; 400  : 	CString str;
; 401  : 
; 402  : 	int nLength = lstrlen( szNumber );	
; 403  : 	for( int i=nLength-1; i>=0; --i)

  0001c	33 ff		 xor	 edi, edi
  0001e	89 7c 24 1c	 mov	 DWORD PTR $T187501[esp+44], edi
  00022	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	8b c8		 mov	 ecx, eax
  0002b	ff 52 0c	 call	 DWORD PTR [edx+12]
  0002e	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  00031	89 74 24 14	 mov	 DWORD PTR _str$[esp+44], esi
  00035	8b 44 24 34	 mov	 eax, DWORD PTR _szNumber$[esp+40]
  00039	50		 push	 eax
  0003a	89 7c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], edi
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00044	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00047	3b cf		 cmp	 ecx, edi
  00049	89 4c 24 18	 mov	 DWORD PTR _i$186865[esp+44], ecx
  0004d	0f 8c 03 01 00
	00		 jl	 $L186868

; 406  : 		if( ((nLength-i) % 3) == 0 && i != 0 )

  00053	2b c1		 sub	 eax, ecx
  00055	89 44 24 1c	 mov	 DWORD PTR tv569[esp+44], eax
  00059	eb 05		 jmp	 SHORT $L186866
$L187912:
  0005b	8b 4c 24 18	 mov	 ecx, DWORD PTR _i$186865[esp+44]
  0005f	90		 npad	 1
$L186866:

; 404  : 	{
; 405  : 		str.Insert(0, szNumber[i]);

  00060	8b 54 24 34	 mov	 edx, DWORD PTR _szNumber$[esp+40]
  00064	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]
  00067	88 44 24 10	 mov	 BYTE PTR $T187651[esp+44], al
  0006b	8b 46 f4	 mov	 eax, DWORD PTR [esi-12]
  0006e	33 db		 xor	 ebx, ebx
  00070	85 c0		 test	 eax, eax
  00072	7d 02		 jge	 SHORT $L187621
  00074	8b d8		 mov	 ebx, eax
$L187621:
  00076	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00079	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	2b c8		 sub	 ecx, eax
  00083	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00086	2b c7		 sub	 eax, edi
  00088	0b c1		 or	 eax, ecx
  0008a	7d 0e		 jge	 SHORT $L187634
  0008c	57		 push	 edi
  0008d	8d 4c 24 18	 lea	 ecx, DWORD PTR _str$[esp+48]
  00091	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  00096	8b 74 24 14	 mov	 esi, DWORD PTR _str$[esp+44]
$L187634:
  0009a	8b cf		 mov	 ecx, edi
  0009c	2b cb		 sub	 ecx, ebx
  0009e	51		 push	 ecx
  0009f	8d 2c 33	 lea	 ebp, DWORD PTR [ebx+esi]
  000a2	8d 55 01	 lea	 edx, DWORD PTR [ebp+1]
  000a5	55		 push	 ebp
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 _memmove
  000ac	8a 44 24 1c	 mov	 al, BYTE PTR $T187651[esp+56]
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	85 ff		 test	 edi, edi
  000b5	88 45 00	 mov	 BYTE PTR [ebp], al
  000b8	0f 8c bf 00 00
	00		 jl	 $L187644
  000be	3b 7e f8	 cmp	 edi, DWORD PTR [esi-8]
  000c1	0f 8f b6 00 00
	00		 jg	 $L187644

; 406  : 		if( ((nLength-i) % 3) == 0 && i != 0 )

  000c7	8b 44 24 1c	 mov	 eax, DWORD PTR tv569[esp+44]
  000cb	99		 cdq
  000cc	b9 03 00 00 00	 mov	 ecx, 3
  000d1	f7 f9		 idiv	 ecx
  000d3	89 7e f4	 mov	 DWORD PTR [esi-12], edi
  000d6	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  000da	85 d2		 test	 edx, edx
  000dc	75 5e		 jne	 SHORT $L186867
  000de	8b 44 24 18	 mov	 eax, DWORD PTR _i$186865[esp+44]
  000e2	85 c0		 test	 eax, eax
  000e4	74 56		 je	 SHORT $L186867

; 407  : 			str.Insert(0, ',' );

  000e6	8b 7e f4	 mov	 edi, DWORD PTR [esi-12]
  000e9	33 db		 xor	 ebx, ebx
  000eb	85 ff		 test	 edi, edi
  000ed	7d 02		 jge	 SHORT $L187740
  000ef	8b df		 mov	 ebx, edi
$L187740:
  000f1	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  000f4	b9 01 00 00 00	 mov	 ecx, 1
  000f9	2b c8		 sub	 ecx, eax
  000fb	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  000fe	47		 inc	 edi
  000ff	2b c7		 sub	 eax, edi
  00101	0b c1		 or	 eax, ecx
  00103	7d 0e		 jge	 SHORT $L187753
  00105	57		 push	 edi
  00106	8d 4c 24 18	 lea	 ecx, DWORD PTR _str$[esp+48]
  0010a	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  0010f	8b 74 24 14	 mov	 esi, DWORD PTR _str$[esp+44]
$L187753:
  00113	8b d7		 mov	 edx, edi
  00115	2b d3		 sub	 edx, ebx
  00117	52		 push	 edx
  00118	8d 2c 33	 lea	 ebp, DWORD PTR [ebx+esi]
  0011b	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  0011e	55		 push	 ebp
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _memmove
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
  00128	85 ff		 test	 edi, edi
  0012a	c6 45 00 2c	 mov	 BYTE PTR [ebp], 44	; 0000002cH
  0012e	7c 4d		 jl	 SHORT $L187644
  00130	3b 7e f8	 cmp	 edi, DWORD PTR [esi-8]
  00133	7f 48		 jg	 SHORT $L187644
  00135	89 7e f4	 mov	 DWORD PTR [esi-12], edi
  00138	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
$L186867:
  0013c	8b 44 24 18	 mov	 eax, DWORD PTR _i$186865[esp+44]
  00140	8b 54 24 1c	 mov	 edx, DWORD PTR tv569[esp+44]
  00144	48		 dec	 eax
  00145	42		 inc	 edx
  00146	85 c0		 test	 eax, eax
  00148	89 44 24 18	 mov	 DWORD PTR _i$186865[esp+44], eax
  0014c	89 54 24 1c	 mov	 DWORD PTR tv569[esp+44], edx
  00150	0f 8d 05 ff ff
	ff		 jge	 $L187912
$L186868:

; 408  : 	}
; 409  : 	return str;

  00156	8b 4e f0	 mov	 ecx, DWORD PTR [esi-16]
  00159	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015b	8d 6e f0	 lea	 ebp, DWORD PTR [esi-16]
  0015e	ff 52 10	 call	 DWORD PTR [edx+16]
  00161	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  00164	85 d2		 test	 edx, edx
  00166	8d 4d 0c	 lea	 ecx, DWORD PTR [ebp+12]
  00169	7c 1c		 jl	 SHORT $L187866
  0016b	3b 45 00	 cmp	 eax, DWORD PTR [ebp]
  0016e	75 17		 jne	 SHORT $L187866
  00170	8b c5		 mov	 eax, ebp
  00172	ba 01 00 00 00	 mov	 edx, 1
  00177	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0017b	eb 3d		 jmp	 SHORT $L187861

; 404  : 	{
; 405  : 		str.Insert(0, szNumber[i]);

$L187644:
  0017d	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00182	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow

; 408  : 	}
; 409  : 	return str;

$L187866:
  00187	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  0018a	8b 10		 mov	 edx, DWORD PTR [eax]
  0018c	6a 01		 push	 1
  0018e	51		 push	 ecx
  0018f	8b c8		 mov	 ecx, eax
  00191	ff 12		 call	 DWORD PTR [edx]
  00193	85 c0		 test	 eax, eax
  00195	75 05		 jne	 SHORT $L187868
  00197	e9 00 00 00 00	 jmp	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L187868:
  0019c	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  0019f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001a2	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001a5	41		 inc	 ecx
  001a6	8b d1		 mov	 edx, ecx
  001a8	c1 e9 02	 shr	 ecx, 2
  001ab	8d 75 10	 lea	 esi, DWORD PTR [ebp+16]
  001ae	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  001b1	f3 a5		 rep movsd
  001b3	8b ca		 mov	 ecx, edx
  001b5	83 e1 03	 and	 ecx, 3
  001b8	f3 a4		 rep movsb
$L187861:
  001ba	8b 74 24 30	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+40]
  001be	83 c0 10	 add	 eax, 16			; 00000010H
  001c1	89 06		 mov	 DWORD PTR [esi], eax
  001c3	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+52], -1
  001cb	8d 45 0c	 lea	 eax, DWORD PTR [ebp+12]
  001ce	83 c9 ff	 or	 ecx, -1
  001d1	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  001d5	49		 dec	 ecx
  001d6	85 c9		 test	 ecx, ecx
  001d8	7f 09		 jg	 SHORT $L187900
  001da	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  001dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  001df	55		 push	 ebp
  001e0	ff 52 04	 call	 DWORD PTR [edx+4]
$L187900:

; 410  : }

  001e3	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  001e7	5f		 pop	 edi
  001e8	8b c6		 mov	 eax, esi
  001ea	5e		 pop	 esi
  001eb	5d		 pop	 ebp
  001ec	5b		 pop	 ebx
  001ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001f4	83 c4 1c	 add	 esp, 28			; 0000001cH
  001f7	c3		 ret	 0
$L187916:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L187499:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T187907
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetNumberFormatEx@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ENDP ; GetNumberFormatEx
END
