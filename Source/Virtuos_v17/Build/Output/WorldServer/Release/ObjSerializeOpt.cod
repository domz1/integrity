; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\ObjSerializeOpt.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?Init@HonorData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObj@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnApplySM@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CMover@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__ForceSetState@CAction@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearStateFlag@CAction@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEquipableNPC@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPetId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMethod@CObj@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStateFlag@CAction@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CAction@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ	; CItemContainer<CItemElem>::GetMax
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ PROC NEAR	; CItemContainer<CItemElem>::GetMax, COMDAT
; _this$ = ecx

; 412  : 	int		GetMax() { return int( m_dwItemMax ); }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ ENDP	; CItemContainer<CItemElem>::GetMax
_TEXT	ENDS
PUBLIC	?GetMethod@CObj@@SAHXZ				; CObj::GetMethod
EXTRN	?m_nMethod@CObj@@2HA:DWORD			; CObj::m_nMethod
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?GetMethod@CObj@@SAHXZ
_TEXT	SEGMENT
?GetMethod@CObj@@SAHXZ PROC NEAR			; CObj::GetMethod, COMDAT

; 159  : 	static int		GetMethod()						{ return m_nMethod;	}

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nMethod@CObj@@2HA ; CObj::m_nMethod
  00005	c3		 ret	 0
?GetMethod@CObj@@SAHXZ ENDP				; CObj::GetMethod
_TEXT	ENDS
PUBLIC	?LOG_RANGE@@YAXPBDHHH@Z				; LOG_RANGE
PUBLIC	??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ ; `string'
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	SEGMENT
??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ DB '%'
	DB	's min:%d, max:%d, index:%d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT
_szMsg$ = 8						; size = 4
_nMin$ = 12						; size = 4
_nMax$ = 16						; size = 4
_nIndex$ = 20						; size = 4
?LOG_RANGE@@YAXPBDHHH@Z PROC NEAR			; LOG_RANGE, COMDAT

; 559  : 	LPCTSTR szErr = Error( _T( "%s min:%d, max:%d, index:%d" ), szMsg, nMin, nMax, nIndex ); 

  00000	8b 44 24 10	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMax$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR _nMin$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR _szMsg$[esp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00019	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 560  : 	ADDERRORMSG( szErr ); 
; 561  : }

  00021	c3		 ret	 0
?LOG_RANGE@@YAXPBDHHH@Z ENDP				; LOG_RANGE
_TEXT	ENDS
PUBLIC	?LOG_CALLSTACK@@YAXXZ				; LOG_CALLSTACK
; Function compile flags: /Ogty
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT
?LOG_CALLSTACK@@YAXXZ PROC NEAR				; LOG_CALLSTACK, COMDAT

; 565  : #ifdef _DEBUG
; 566  : 	__asm int 3
; 567  : #endif
; 568  : 
; 569  : #if defined(__INTERNALSERVER)
; 570  : 	int *p = NULL;		// 콜스택을 추적하기 위해 죽인다
; 571  : 	*p = 1;
; 572  : #endif
; 573  : }

  00000	c3		 ret	 0
?LOG_CALLSTACK@@YAXXZ ENDP				; LOG_CALLSTACK
_TEXT	ENDS
PUBLIC	?GetLevel@CPet@@QAEEXZ				; CPet::GetLevel
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT
?GetLevel@CPet@@QAEEXZ PROC NEAR			; CPet::GetLevel, COMDAT
; _this$ = ecx

; 134  : 	BYTE	GetLevel( void )	{	return m_nLevel;	}

  00000	8a 41 05	 mov	 al, BYTE PTR [ecx+5]
  00003	c3		 ret	 0
?GetLevel@CPet@@QAEEXZ ENDP				; CPet::GetLevel
_TEXT	ENDS
PUBLIC	?GetName@CPet@@QAEPBDXZ				; CPet::GetName
; Function compile flags: /Ogty
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT
?GetName@CPet@@QAEPBDXZ PROC NEAR			; CPet::GetName, COMDAT
; _this$ = ecx

; 149  : 	const char*	GetName()	{	return m_szName;	}

  00000	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]
  00003	c3		 ret	 0
?GetName@CPet@@QAEPBDXZ ENDP				; CPet::GetName
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 48   : 	BOOL			IsEmpty() { return m_dwItemId ? FALSE : TRUE; }

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	?IsStoring@CAr@@QBEHXZ				; CAr::IsStoring
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT
?IsStoring@CAr@@QBEHXZ PROC NEAR			; CAr::IsStoring, COMDAT
; _this$ = ecx

; 96   : 	{ return (m_nMode & CAr::load) == 0; }

  00000	33 c0		 xor	 eax, eax
  00002	8a 01		 mov	 al, BYTE PTR [ecx]
  00004	f7 d0		 not	 eax
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsStoring@CAr@@QBEHXZ ENDP				; CAr::IsStoring
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@E@Z				; CAr::operator<<
EXTRN	?CheckBuf@CAr@@QAEXI@Z:NEAR			; CAr::CheckBuf
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@E@Z
_TEXT	SEGMENT
_by$ = 8						; size = 1
??6CAr@@QAEAAV0@E@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 107  : 	{ CheckBuf( sizeof(BYTE) );

  00000	56		 push	 esi
  00001	6a 01		 push	 1
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 108  : 		*(UNALIGNED BYTE*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8a 4c 24 08	 mov	 cl, BYTE PTR _by$[esp]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	ff 46 08	 inc	 DWORD PTR [esi+8]
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@E@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@G@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@G@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 110  : 	{ CheckBuf( sizeof( WORD ) );

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 111  : 		*(UNALIGNED WORD*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@G@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@J@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??6CAr@@QAEAAV0@J@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 113  : 	{ CheckBuf( sizeof(LONG) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 114  : 		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _l$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@J@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@K@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??6CAr@@QAEAAV0@K@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 116  : 	{ CheckBuf( sizeof(DWORD) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 117  : 		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@K@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@M@Z				; CAr::operator<<
EXTRN	__fltused:NEAR
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??6CAr@@QAEAAV0@M@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 119  : 	{ CheckBuf( sizeof(float) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 120  : 		*(UNALIGNED FLOAT*)m_lpBufCur = *(FLOAT*)&f; m_lpBufCur += sizeof(float); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _f$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@M@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAE@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAE@Z
_TEXT	SEGMENT
_by$ = 8						; size = 4
??5CAr@@QAEAAV0@AAE@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 142  : 	{	CAR_SAFE_READ( BYTE, by );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0e		 ja	 SHORT $L205448
  00011	8a 09		 mov	 cl, BYTE PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _by$[esp-4]
  00017	88 0a		 mov	 BYTE PTR [edx], cl
  00019	ff 40 08	 inc	 DWORD PTR [eax+8]
  0001c	c2 04 00	 ret	 4
$L205448:
  0001f	8b 4c 24 04	 mov	 ecx, DWORD PTR _by$[esp-4]
  00023	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002c	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAE@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAG@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??5CAr@@QAEAAV0@AAG@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 144  : 	{	CAR_SAFE_READ( WORD, w );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 11		 ja	 SHORT $L205458
  00011	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00014	8b 54 24 04	 mov	 edx, DWORD PTR _w$[esp-4]
  00018	66 89 0a	 mov	 WORD PTR [edx], cx
  0001b	83 40 08 02	 add	 DWORD PTR [eax+8], 2
  0001f	c2 04 00	 ret	 4
$L205458:
  00022	8b 4c 24 04	 mov	 ecx, DWORD PTR _w$[esp-4]
  00026	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  0002b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00031	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAG@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAK@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??5CAr@@QAEAAV0@AAK@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 146  : 	{	CAR_SAFE_READ( DWORD, dw );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L205468
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _dw$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L205468:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _dw$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAK@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAM@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??5CAr@@QAEAAV0@AAM@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 148  : 	{	CAR_SAFE_READ( float, f );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L205478
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _f$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L205478:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _f$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAM@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAJ@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??5CAr@@QAEAAV0@AAJ@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 152  : 	{	CAR_SAFE_READ( LONG, l );	}

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L205498
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _l$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L205498:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _l$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAJ@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z		; operator<<
EXTRN	?Write@CAr@@QAEXPBXI@Z:NEAR			; CAr::Write
; Function compile flags: /Ogty
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_v$ = 12						; size = 12
??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z PROC NEAR		; operator<<, COMDAT

; 157  : 	{	ar.Write( &v, sizeof(D3DXVECTOR3) );	return ar;	}

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	6a 0c		 push	 12			; 0000000cH
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _v$[esp+4]
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z		; operator>>
EXTRN	?Read@CAr@@QAEXPAXI@Z:NEAR			; CAr::Read
; Function compile flags: /Ogty
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_v$ = 12						; size = 4
??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z PROC NEAR		; operator>>, COMDAT

; 160  : 	{	ar.Read( &v, sizeof(D3DXVECTOR3) );		return ar;	}

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _v$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVCAr@@AAV0@_J@Z				; operator<<
; Function compile flags: /Ogty
;	COMDAT ??6@YAAAVCAr@@AAV0@_J@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_i$ = 12						; size = 8
??6@YAAAVCAr@@AAV0@_J@Z PROC NEAR			; operator<<, COMDAT

; 163  : 	{	ar.Write( &i, sizeof(__int64) );	return ar;	}

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00005	6a 08		 push	 8
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _i$[esp+4]
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??6@YAAAVCAr@@AAV0@_J@Z ENDP				; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVCAr@@AAV0@AA_J@Z			; operator>>
; Function compile flags: /Ogty
;	COMDAT ??5@YAAAVCAr@@AAV0@AA_J@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_i$ = 12						; size = 4
??5@YAAAVCAr@@AAV0@AA_J@Z PROC NEAR			; operator>>, COMDAT

; 166  : 	{	ar.Read( &i, sizeof(__int64) );	return ar;	}

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _i$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _ar$[esp]
  00009	6a 08		 push	 8
  0000b	50		 push	 eax
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??5@YAAAVCAr@@AAV0@AA_J@Z ENDP				; operator>>
_TEXT	ENDS
PUBLIC	?GetOffset@CAr@@QAEKXZ				; CAr::GetOffset
; Function compile flags: /Ogty
;	COMDAT ?GetOffset@CAr@@QAEKXZ
_TEXT	SEGMENT
?GetOffset@CAr@@QAEKXZ PROC NEAR			; CAr::GetOffset, COMDAT
; _this$ = ecx

; 190  : 	ASSERT( IsStoring() );
; 191  : 	return( m_lpBufCur - m_lpBufStart );

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]

; 192  : }

  00006	c3		 ret	 0
?GetOffset@CAr@@QAEKXZ ENDP				; CAr::GetOffset
_TEXT	ENDS
PUBLIC	?__ForceSetState@CAction@@QAEXK@Z		; CAction::__ForceSetState
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\action.h
;	COMDAT ?__ForceSetState@CAction@@QAEXK@Z
_TEXT	SEGMENT
_dwState$ = 8						; size = 4
?__ForceSetState@CAction@@QAEXK@Z PROC NEAR		; CAction::__ForceSetState, COMDAT
; _this$ = ecx

; 282  : 	void			__ForceSetState( DWORD dwState ) { m_dwState = dwState; }		// dwState값으로 강제로 세팅. 서버와 동기화때 외엔 사용하지 말것.

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwState$[esp-4]
  00004	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00007	c2 04 00	 ret	 4
?__ForceSetState@CAction@@QAEXK@Z ENDP			; CAction::__ForceSetState
_TEXT	ENDS
PUBLIC	?ClearStateFlag@CAction@@QAEXXZ			; CAction::ClearStateFlag
; Function compile flags: /Ogty
;	COMDAT ?ClearStateFlag@CAction@@QAEXXZ
_TEXT	SEGMENT
?ClearStateFlag@CAction@@QAEXXZ PROC NEAR		; CAction::ClearStateFlag, COMDAT
; _this$ = ecx

; 283  : 	void			ClearStateFlag() { m_dwStateFlag = 0; }

  00000	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00007	c3		 ret	 0
?ClearStateFlag@CAction@@QAEXXZ ENDP			; CAction::ClearStateFlag
_TEXT	ENDS
PUBLIC	?GetStateFlag@CAction@@QAEKXZ			; CAction::GetStateFlag
; Function compile flags: /Ogty
;	COMDAT ?GetStateFlag@CAction@@QAEKXZ
_TEXT	SEGMENT
?GetStateFlag@CAction@@QAEKXZ PROC NEAR			; CAction::GetStateFlag, COMDAT
; _this$ = ecx

; 288  : 	DWORD			GetStateFlag() { return m_dwStateFlag; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetStateFlag@CAction@@QAEKXZ ENDP			; CAction::GetStateFlag
_TEXT	ENDS
PUBLIC	?GetState@CAction@@QAEKXZ			; CAction::GetState
; Function compile flags: /Ogty
;	COMDAT ?GetState@CAction@@QAEKXZ
_TEXT	SEGMENT
?GetState@CAction@@QAEKXZ PROC NEAR			; CAction::GetState, COMDAT
; _this$ = ecx

; 291  : 	DWORD			GetState() { return m_dwState; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetState@CAction@@QAEKXZ ENDP				; CAction::GetState
_TEXT	ENDS
PUBLIC	?GetPetId@CMover@@QAEKXZ			; CMover::GetPetId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
;	COMDAT ?GetPetId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPetId@CMover@@QAEKXZ PROC NEAR			; CMover::GetPetId, COMDAT
; _this$ = ecx

; 831  : 	DWORD	GetPetId( void )	{	return m_dwPetId;	}

  00000	8b 81 8c 11 00
	00		 mov	 eax, DWORD PTR [ecx+4492]
  00006	c3		 ret	 0
?GetPetId@CMover@@QAEKXZ ENDP				; CMover::GetPetId
_TEXT	ENDS
PUBLIC	?SetPetId@CMover@@QAEXK@Z			; CMover::SetPetId
; Function compile flags: /Ogty
;	COMDAT ?SetPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwPetId$ = 8						; size = 4
?SetPetId@CMover@@QAEXK@Z PROC NEAR			; CMover::SetPetId, COMDAT
; _this$ = ecx

; 832  : 	void	SetPetId( DWORD dwPetId )		{	m_dwPetId	= dwPetId;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwPetId$[esp-4]
  00004	89 81 8c 11 00
	00		 mov	 DWORD PTR [ecx+4492], eax
  0000a	c2 04 00	 ret	 4
?SetPetId@CMover@@QAEXK@Z ENDP				; CMover::SetPetId
_TEXT	ENDS
PUBLIC	?IsEquipableNPC@CMover@@QAEHXZ			; CMover::IsEquipableNPC
EXTRN	?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ:NEAR ; CMover::GetCharacter
; Function compile flags: /Ogty
;	COMDAT ?IsEquipableNPC@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsEquipableNPC@CMover@@QAEHXZ PROC NEAR		; CMover::IsEquipableNPC, COMDAT
; _this$ = ecx

; 1043 : 	BOOL			IsEquipableNPC()	{	return( GetCharacter() && GetCharacter()->m_nEquipNum > 0 );	}

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  00008	85 c0		 test	 eax, eax
  0000a	74 18		 je	 SHORT $L227848
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  00013	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  00019	85 c9		 test	 ecx, ecx
  0001b	7e 07		 jle	 SHORT $L227848
  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	5e		 pop	 esi
  00023	c3		 ret	 0
$L227848:
  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi
  00027	c3		 ret	 0
?IsEquipableNPC@CMover@@QAEHXZ ENDP			; CMover::IsEquipableNPC
_TEXT	ENDS
PUBLIC	?GetSex@CMover@@QAEEXZ				; CMover::GetSex
; Function compile flags: /Ogty
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT
?GetSex@CMover@@QAEEXZ PROC NEAR			; CMover::GetSex, COMDAT
; _this$ = ecx

; 1144 : 	BYTE			GetSex() { return m_bySex; }

  00000	8a 81 20 06 00
	00		 mov	 al, BYTE PTR [ecx+1568]
  00006	c3		 ret	 0
?GetSex@CMover@@QAEEXZ ENDP				; CMover::GetSex
_TEXT	ENDS
PUBLIC	?SetSex@CMover@@QAEXE@Z				; CMover::SetSex
; Function compile flags: /Ogty
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT
_bySex$ = 8						; size = 1
?SetSex@CMover@@QAEXE@Z PROC NEAR			; CMover::SetSex, COMDAT
; _this$ = ecx

; 1145 : 	void			SetSex( BYTE bySex ) { m_bySex = bySex; }

  00000	8a 44 24 04	 mov	 al, BYTE PTR _bySex$[esp-4]
  00004	88 81 20 06 00
	00		 mov	 BYTE PTR [ecx+1568], al
  0000a	c2 04 00	 ret	 4
?SetSex@CMover@@QAEXE@Z ENDP				; CMover::SetSex
_TEXT	ENDS
PUBLIC	?GetGold@CMover@@QAEHXZ				; CMover::GetGold
; Function compile flags: /Ogty
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetGold@CMover@@QAEHXZ PROC NEAR			; CMover::GetGold, COMDAT
; _this$ = ecx

; 1829 : 	int nGold = m_dwGold;
; 1830 : //	nGold -= m_vtInfo.TradeGetGold();
; 1831 : 	ASSERT( nGold >= 0 );
; 1832 : 	return nGold;

  00000	8b 81 84 16 00
	00		 mov	 eax, DWORD PTR [ecx+5764]

; 1833 : }

  00006	c3		 ret	 0
?GetGold@CMover@@QAEHXZ ENDP				; CMover::GetGold
_TEXT	ENDS
PUBLIC	?SetGold@CMover@@QAEXH@Z			; CMover::SetGold
; Function compile flags: /Ogty
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nGold$ = 8						; size = 4
?SetGold@CMover@@QAEXH@Z PROC NEAR			; CMover::SetGold, COMDAT
; _this$ = ecx

; 1837 : 	ASSERT( nGold >= 0 );
; 1838 : 	m_dwGold = (DWORD)nGold;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nGold$[esp-4]
  00004	89 81 84 16 00
	00		 mov	 DWORD PTR [ecx+5764], eax

; 1839 : }

  0000a	c2 04 00	 ret	 4
?SetGold@CMover@@QAEXH@Z ENDP				; CMover::SetGold
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ	; CFixedArray<ItemProp>::GetSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ PROC NEAR	; CFixedArray<ItemProp>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ ENDP		; CFixedArray<ItemProp>::GetSize
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ; CFixedArray<ItemProp>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z PROC NEAR ; CFixedArray<ItemProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224299

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224299:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ENDP ; CFixedArray<ItemProp>::GetAt
_TEXT	ENDS
PUBLIC	?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwId$ = 8						; size = 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtId, COMDAT
; _this$ = ecx

; 518  : 	if( dwId >= (DWORD)( GetMax() ) ) return NULL;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwId$[esp-4]
  00004	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00007	72 05		 jb	 SHORT $L224421
  00009	33 c0		 xor	 eax, eax

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  0000b	c2 04 00	 ret	 4
$L224421:

; 519  : 	T* pItemElem = &m_apItem[ dwId ];

  0000e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00011	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00017	03 c2		 add	 eax, edx
  00019	8b c8		 mov	 ecx, eax

; 520  : 	if( pItemElem->IsEmpty() ) 

  0001b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001e	f7 d8		 neg	 eax
  00020	1b c0		 sbb	 eax, eax
  00022	23 c1		 and	 eax, ecx

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  00024	c2 04 00	 ret	 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAtId
_TEXT	ENDS
PUBLIC	?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
EXTRN	?GetBuffer@CAr@@QAEPAEPAH@Z:NEAR		; CAr::GetBuffer
; Function compile flags: /Ogty
;	COMDAT ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
_chSize$ = -525						; size = 1
tv342 = -524						; size = 4
_uOffset$226722 = -520					; size = 4
_nBufSize$226729 = -516					; size = 4
_adwObjIndex$ = -512					; size = 512
_ar$ = 8						; size = 4
?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z PROC NEAR ; CItemContainer<CItemElem>::Serialize, COMDAT
; _this$ = ecx

; 899  : {

  00000	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi

; 900  : 	DWORD	adwObjIndex[128];
; 901  : 
; 902  : 	unsigned char chSize	= 0;
; 903  : 
; 904  : 	if( ar.IsStoring() )

  00009	8b b4 24 20 02
	00 00		 mov	 esi, DWORD PTR _ar$[esp+536]
  00010	33 c0		 xor	 eax, eax
  00012	8a 06		 mov	 al, BYTE PTR [esi]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx
  00017	c6 44 24 13 00	 mov	 BYTE PTR _chSize$[esp+544], 0
  0001c	f7 d0		 not	 eax
  0001e	a8 01		 test	 al, 1
  00020	0f 84 d5 00 00
	00		 je	 $L226720

; 905  : 	{
; 906  : 		
; 907  : 		ar.Write( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  00026	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00029	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0002c	c1 e1 02	 shl	 ecx, 2
  0002f	51		 push	 ecx
  00030	52		 push	 edx
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 908  : 		
; 909  : 		u_long uOffset	= ar.GetOffset();

  00038	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0003b	2b 6e 10	 sub	 ebp, DWORD PTR [esi+16]

; 910  : 		ar << chSize;

  0003e	6a 01		 push	 1
  00040	8b ce		 mov	 ecx, esi
  00042	89 6c 24 1c	 mov	 DWORD PTR _uOffset$226722[esp+548], ebp
  00046	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00051	ff 46 08	 inc	 DWORD PTR [esi+8]

; 911  : 
; 912  : 		for( u_char ch = 0; ch < m_dwItemMax; ch++ )	// 0-504

  00054	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00057	32 db		 xor	 bl, bl
  00059	85 c0		 test	 eax, eax
  0005b	76 6b		 jbe	 SHORT $L226726
  0005d	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR tv342[esp+544], 0
  00065	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$L227916:

; 913  : 		{
; 914  : 			if( m_apItem[ch].IsEmpty() == FALSE )

  00070	8b 6c 24 14	 mov	 ebp, DWORD PTR tv342[esp+544]
  00074	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00077	69 ed b8 00 00
	00		 imul	 ebp, 184		; 000000b8H
  0007d	8b 44 29 0c	 mov	 eax, DWORD PTR [ecx+ebp+12]
  00081	85 c0		 test	 eax, eax
  00083	74 22		 je	 SHORT $L226727

; 915  : 			{
; 916  : 				ar << ch;

  00085	6a 01		 push	 1
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0008e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00091	88 1a		 mov	 BYTE PTR [edx], bl
  00093	ff 46 08	 inc	 DWORD PTR [esi+8]

; 917  : 				m_apItem[ch].Serialize( ar );

  00096	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00099	8b 14 28	 mov	 edx, DWORD PTR [eax+ebp]
  0009c	8d 0c 28	 lea	 ecx, DWORD PTR [eax+ebp]
  0009f	56		 push	 esi
  000a0	ff 52 08	 call	 DWORD PTR [edx+8]

; 918  : 				chSize++;

  000a3	fe 44 24 13	 inc	 BYTE PTR _chSize$[esp+544]
$L226727:

; 919  : 			}
; 920  : 			adwObjIndex[ch]		= m_apItem[ch].m_dwObjIndex;

  000a7	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000aa	8b 4c 28 08	 mov	 ecx, DWORD PTR [eax+ebp+8]
  000ae	8b 54 24 14	 mov	 edx, DWORD PTR tv342[esp+544]
  000b2	fe c3		 inc	 bl
  000b4	0f b6 c3	 movzx	 eax, bl
  000b7	89 4c 94 20	 mov	 DWORD PTR _adwObjIndex$[esp+edx*4+544], ecx
  000bb	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  000be	89 44 24 14	 mov	 DWORD PTR tv342[esp+544], eax
  000c2	72 ac		 jb	 SHORT $L227916

; 911  : 
; 912  : 		for( u_char ch = 0; ch < m_dwItemMax; ch++ )	// 0-504

  000c4	8b 6c 24 18	 mov	 ebp, DWORD PTR _uOffset$226722[esp+544]
$L226726:

; 921  : 		}
; 922  : 
; 923  : 		ar.Write( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  000c8	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000cb	c1 e0 02	 shl	 eax, 2
  000ce	50		 push	 eax
  000cf	8d 4c 24 24	 lea	 ecx, DWORD PTR _adwObjIndex$[esp+548]
  000d3	51		 push	 ecx
  000d4	8b ce		 mov	 ecx, esi
  000d6	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 924  : 
; 925  : 		int nBufSize;
; 926  : 		LPBYTE lpBuf	= ar.GetBuffer( &nBufSize );

  000db	8d 54 24 1c	 lea	 edx, DWORD PTR _nBufSize$226729[esp+544]
  000df	52		 push	 edx
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 927  : 		*( lpBuf + uOffset )	= chSize;

  000e7	8a 4c 24 13	 mov	 cl, BYTE PTR _chSize$[esp+544]
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  000f0	5d		 pop	 ebp
  000f1	5b		 pop	 ebx

; 949  : 		}
; 950  : 	}
; 951  : }

  000f2	81 c4 10 02 00
	00		 add	 esp, 528		; 00000210H
  000f8	c2 04 00	 ret	 4
$L226720:

; 928  : 	}
; 929  : 	else
; 930  : 	{
; 931  : 		ar.Read( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  000fb	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  000fe	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00101	c1 e2 02	 shl	 edx, 2
  00104	52		 push	 edx
  00105	50		 push	 eax
  00106	8b ce		 mov	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 932  : 		// Clear
; 933  : 		for( u_long i = 0; i < m_dwItemMax; i++ )

  0010d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00110	33 db		 xor	 ebx, ebx
  00112	85 c0		 test	 eax, eax
  00114	76 1b		 jbe	 SHORT $L226736

; 928  : 	}
; 929  : 	else
; 930  : 	{
; 931  : 		ar.Read( m_apIndex, sizeof(DWORD) * m_dwItemMax );

  00116	33 ed		 xor	 ebp, ebp
$L226734:

; 934  : 			m_apItem[i].Empty();

  00118	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0011b	8b 14 29	 mov	 edx, DWORD PTR [ecx+ebp]
  0011e	03 cd		 add	 ecx, ebp
  00120	ff 52 0c	 call	 DWORD PTR [edx+12]
  00123	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00126	43		 inc	 ebx
  00127	81 c5 b8 00 00
	00		 add	 ebp, 184		; 000000b8H
  0012d	3b d8		 cmp	 ebx, eax
  0012f	72 e7		 jb	 SHORT $L226734
$L226736:

; 935  : 
; 936  : 		ar >> chSize;

  00131	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00134	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00137	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0013a	3b ca		 cmp	 ecx, edx
  0013c	77 07		 ja	 SHORT $L227900
  0013e	8a 00		 mov	 al, BYTE PTR [eax]
  00140	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00143	eb 05		 jmp	 SHORT $L227901
$L227900:
  00145	32 c0		 xor	 al, al
  00147	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L227901:

; 946  : 		for( i = 0; i < m_dwItemMax; i++ )

  0014a	0f b6 c0	 movzx	 eax, al
  0014d	85 c0		 test	 eax, eax
  0014f	76 33		 jbe	 SHORT $L226740

; 937  : 
; 938  : 		unsigned char ch;
; 939  : 		for( i = 0; i < chSize; i++ )

  00151	8b d8		 mov	 ebx, eax
$L226738:

; 940  : 		{
; 941  : 			ar >> ch;

  00153	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00156	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00159	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0015c	3b ca		 cmp	 ecx, edx
  0015e	77 07		 ja	 SHORT $L227905
  00160	8a 00		 mov	 al, BYTE PTR [eax]
  00162	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00165	eb 05		 jmp	 SHORT $L227906
$L227905:
  00167	32 c0		 xor	 al, al
  00169	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L227906:

; 942  : 			m_apItem[ch].Serialize( ar );

  0016c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0016f	0f b6 c0	 movzx	 eax, al
  00172	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00178	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0017b	03 c8		 add	 ecx, eax
  0017d	56		 push	 esi
  0017e	ff 52 08	 call	 DWORD PTR [edx+8]
  00181	4b		 dec	 ebx
  00182	75 cf		 jne	 SHORT $L226738
$L226740:

; 943  : 		}
; 944  : 
; 945  : 		ar.Read( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  00184	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00187	c1 e0 02	 shl	 eax, 2
  0018a	50		 push	 eax
  0018b	8d 4c 24 24	 lea	 ecx, DWORD PTR _adwObjIndex$[esp+548]
  0018f	51		 push	 ecx
  00190	8b ce		 mov	 ecx, esi
  00192	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 946  : 		for( i = 0; i < m_dwItemMax; i++ )

  00197	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0019a	33 c0		 xor	 eax, eax
  0019c	85 c9		 test	 ecx, ecx
  0019e	76 1b		 jbe	 SHORT $L226744

; 943  : 		}
; 944  : 
; 945  : 		ar.Read( adwObjIndex, sizeof(DWORD) * m_dwItemMax );

  001a0	33 c9		 xor	 ecx, ecx
$L226742:

; 947  : 		{
; 948  : 			m_apItem[i].m_dwObjIndex	= adwObjIndex[i];

  001a2	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  001a5	8b 74 84 20	 mov	 esi, DWORD PTR _adwObjIndex$[esp+eax*4+544]
  001a9	89 74 11 08	 mov	 DWORD PTR [ecx+edx+8], esi
  001ad	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  001b0	40		 inc	 eax
  001b1	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  001b7	3b c2		 cmp	 eax, edx
  001b9	72 e7		 jb	 SHORT $L226742
$L226744:
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5d		 pop	 ebp
  001be	5b		 pop	 ebx

; 949  : 		}
; 950  : 	}
; 951  : }

  001bf	81 c4 10 02 00
	00		 add	 esp, 528		; 00000210H
  001c5	c2 04 00	 ret	 4
?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ENDP ; CItemContainer<CItemElem>::Serialize
_TEXT	ENDS
PUBLIC	?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAt, COMDAT
; _this$ = ecx

; 826  : 	DWORD dwIdx = m_apIndex[ dwIndex ];

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR _dwIndex$[esp-4]
  00007	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 827  : 	if( dwIdx == NULL_ID )

  0000a	83 f8 ff	 cmp	 eax, -1
  0000d	75 05		 jne	 SHORT $L227073

; 828  : 		return NULL;

  0000f	33 c0		 xor	 eax, eax

; 831  : 		return NULL;
; 832  : 	return pItemElem;
; 833  : }

  00011	c2 04 00	 ret	 4
$L227073:

; 829  : 	T* pItemElem = &m_apItem[ dwIdx ];

  00014	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00017	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  0001d	03 c2		 add	 eax, edx
  0001f	8b c8		 mov	 ecx, eax

; 830  : 	if( pItemElem->IsEmpty() ) 

  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	f7 d8		 neg	 eax
  00026	1b c0		 sbb	 eax, eax
  00028	23 c1		 and	 eax, ecx

; 831  : 		return NULL;
; 832  : 	return pItemElem;
; 833  : }

  0002a	c2 04 00	 ret	 4
?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAt
_TEXT	ENDS
PUBLIC	??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ ; `string'
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetItemProp
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ DB 'GetItemProp range_er'
	DB	'ror', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 1a		 jl	 SHORT $L197914
  00008	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 10		 jge	 SHORT $L197914

; 1365 : 	return m_aPropItem.GetAt( nIndex ); 

  00012	3b c2		 cmp	 eax, edx
  00014	73 28		 jae	 SHORT $L227947
  00016	8b 89 4c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+588]
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1366 : }

  0001f	c2 04 00	 ret	 4
$L197914:

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00022	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00036	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$L227947:
  0003e	33 c0		 xor	 eax, eax

; 1366 : }

  00040	c2 04 00	 ret	 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ENDP		; CProject::GetItemProp
_TEXT	ENDS
PUBLIC	?GetPropA@CItemElem@@QAEPAUItemProp@@XZ		; CItemElem::GetPropA
EXTRN	?prj@@3VCProject@@A:BYTE			; prj
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ PROC NEAR	; CItemElem::GetPropA, COMDAT
; _this$ = ecx

; 229  : 	ItemProp*	GetProp()	{	return prj.GetItemProp( m_dwItemId );	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000b	7c 10		 jl	 SHORT $L227978
  0000d	3b c1		 cmp	 eax, ecx
  0000f	7d 0c		 jge	 SHORT $L227978
  00011	73 20		 jae	 SHORT $L227994
  00013	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00019	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001c	c3		 ret	 0
$L227978:
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0002b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$L227994:
  00033	33 c0		 xor	 eax, eax
  00035	c3		 ret	 0
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ENDP		; CItemElem::GetPropA
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@H@Z				; CAr::operator<<
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??6CAr@@QAEAAV0@H@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 99   : 	{ return CAr::operator<<((LONG)i); }

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _i$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@H@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@F@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@F@Z
_TEXT	SEGMENT
_w$ = 8							; size = 2
??6CAr@@QAEAAV0@F@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 103  : 	{ return CAr::operator<<((WORD)w); }

  00000	56		 push	 esi
  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	66 8b 4c 24 08	 mov	 cx, WORD PTR _w$[esp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx
  00015	83 46 08 02	 add	 DWORD PTR [esi+8], 2
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@F@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@D@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@D@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
??6CAr@@QAEAAV0@D@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 105  : 	{ return CAr::operator<<((BYTE)ch); }

  00000	56		 push	 esi
  00001	6a 01		 push	 1
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8a 4c 24 08	 mov	 cl, BYTE PTR _ch$[esp]
  00011	88 08		 mov	 BYTE PTR [eax], cl
  00013	ff 46 08	 inc	 DWORD PTR [esi+8]
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@D@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAH@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??5CAr@@QAEAAV0@AAH@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 126  : 	{ return CAr::operator>>((LONG&)i); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0f		 ja	 SHORT $L228019
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _i$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	83 40 08 04	 add	 DWORD PTR [eax+8], 4
  0001d	c2 04 00	 ret	 4
$L228019:
  00020	8b 4c 24 04	 mov	 ecx, DWORD PTR _i$[esp-4]
  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0002a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAH@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAF@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAF@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
??5CAr@@QAEAAV0@AAF@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 130  : 	{ return CAr::operator>>((WORD&)w); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 11		 ja	 SHORT $L228026
  00011	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00014	8b 54 24 04	 mov	 edx, DWORD PTR _w$[esp-4]
  00018	66 89 0a	 mov	 WORD PTR [edx], cx
  0001b	83 40 08 02	 add	 DWORD PTR [eax+8], 2
  0001f	c2 04 00	 ret	 4
$L228026:
  00022	8b 4c 24 04	 mov	 ecx, DWORD PTR _w$[esp-4]
  00026	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
  0002b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0002e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00031	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAF@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	??5CAr@@QAEAAV0@AAD@Z				; CAr::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CAr@@QAEAAV0@AAD@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 4
??5CAr@@QAEAAV0@AAD@Z PROC NEAR				; CAr::operator>>, COMDAT
; _this$ = ecx

; 132  : 	{ return CAr::operator>>((BYTE&)ch); }

  00000	8b c1		 mov	 eax, ecx
  00002	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000c	3b d6		 cmp	 edx, esi
  0000e	5e		 pop	 esi
  0000f	77 0e		 ja	 SHORT $L228034
  00011	8a 09		 mov	 cl, BYTE PTR [ecx]
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _ch$[esp-4]
  00017	88 0a		 mov	 BYTE PTR [edx], cl
  00019	ff 40 08	 inc	 DWORD PTR [eax+8]
  0001c	c2 04 00	 ret	 4
$L228034:
  0001f	8b 4c 24 04	 mov	 ecx, DWORD PTR _ch$[esp-4]
  00023	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002c	c2 04 00	 ret	 4
??5CAr@@QAEAAV0@AAD@Z ENDP				; CAr::operator>>
_TEXT	ENDS
PUBLIC	?Serialize@CObj@@UAEXAAVCAr@@@Z			; CObj::Serialize
PUBLIC	__real@42c80000
PUBLIC	__real@41200000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
EXTRN	?SetAngle@CObj@@QAEXM@Z:NEAR			; CObj::SetAngle
EXTRN	__ftol2:NEAR
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\objserializeopt.cpp
CONST	ENDS
;	COMDAT ?Serialize@CObj@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
$T228058 = -12						; size = 12
tv325 = 8						; size = 4
tv320 = 8						; size = 4
tv312 = 8						; size = 4
_ar$ = 8						; size = 4
?Serialize@CObj@@UAEXAAVCAr@@@Z PROC NEAR		; CObj::Serialize, COMDAT
; _this$ = ecx

; 25   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 26   : 	if( ar.IsStoring() )

  00006	8b 74 24 1c	 mov	 esi, DWORD PTR _ar$[esp+20]
  0000a	33 c0		 xor	 eax, eax
  0000c	8a 06		 mov	 al, BYTE PTR [esi]
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	f7 d0		 not	 eax
  00013	a8 01		 test	 al, 1
  00015	0f 84 b2 00 00
	00		 je	 $L226211

; 27   : 	{
; 28   : 		ar << (u_char)m_dwType;

  0001b	8a 9f 70 01 00
	00		 mov	 bl, BYTE PTR [edi+368]
  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0002a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002d	88 19		 mov	 BYTE PTR [ecx], bl
  0002f	ff 46 08	 inc	 DWORD PTR [esi+8]

; 29   : 
; 30   : 		// mirchang_100513 type cast fix
; 31   : 		//ar << (u_short)m_dwIndex;
; 32   : 		ar << m_dwIndex;

  00032	8b 9f 74 01 00
	00		 mov	 ebx, DWORD PTR [edi+372]
  00038	6a 04		 push	 4
  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00041	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00044	89 1a		 mov	 DWORD PTR [edx], ebx
  00046	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00049	83 c3 04	 add	 ebx, 4
  0004c	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 33   : 		// mirchang_100513 type cast fix
; 34   : 
; 35   : 		ar << (u_short)( m_vScale.x * 100.0f );

  0004f	d9 47 0c	 fld	 DWORD PTR [edi+12]
  00052	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42c80000
  00058	e8 00 00 00 00	 call	 __ftol2
  0005d	bd 02 00 00 00	 mov	 ebp, 2
  00062	55		 push	 ebp
  00063	8b ce		 mov	 ecx, esi
  00065	8b d8		 mov	 ebx, eax
  00067	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006f	66 89 18	 mov	 WORD PTR [eax], bx
  00072	01 6e 08	 add	 DWORD PTR [esi+8], ebp

; 36   : 		ar << m_vPos;

  00075	8d 8f 60 01 00
	00		 lea	 ecx, DWORD PTR [edi+352]
  0007b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00080	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00083	89 54 24 10	 mov	 DWORD PTR $T228058[esp+28], edx
  00087	6a 0c		 push	 12			; 0000000cH
  00089	8d 54 24 14	 lea	 edx, DWORD PTR $T228058[esp+32]
  0008d	89 4c 24 1c	 mov	 DWORD PTR $T228058[esp+40], ecx
  00091	52		 push	 edx
  00092	8b ce		 mov	 ecx, esi
  00094	89 44 24 1c	 mov	 DWORD PTR $T228058[esp+40], eax
  00098	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 37   : 		ar << (short)( m_fAngle * 10.0f );

  0009d	d9 47 18	 fld	 DWORD PTR [edi+24]
  000a0	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41200000
  000a6	e8 00 00 00 00	 call	 __ftol2
  000ab	55		 push	 ebp
  000ac	8b ce		 mov	 ecx, esi
  000ae	8b f8		 mov	 edi, eax
  000b0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000b5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b8	66 89 38	 mov	 WORD PTR [eax], di
  000bb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000be	03 c5		 add	 eax, ebp
  000c0	5f		 pop	 edi
  000c1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000c4	5e		 pop	 esi
  000c5	5d		 pop	 ebp
  000c6	5b		 pop	 ebx

; 64   : 	#endif	// __WORLDSERVER
; 65   : 	}
; 66   : }

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	c2 04 00	 ret	 4
$L226211:

; 38   : 	}
; 39   : 	else
; 40   : 	{
; 41   : 		u_short u2;
; 42   : 		short i2;
; 43   : 		m_dwType = m_dwIndex = 0; 

  000cd	33 db		 xor	 ebx, ebx
  000cf	89 9f 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebx
  000d5	89 9f 70 01 00
	00		 mov	 DWORD PTR [edi+368], ebx

; 44   : 		
; 45   : 		ar >> (u_char&)m_dwType;				// m_dwType

  000db	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000de	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000e1	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  000e4	3b ca		 cmp	 ecx, edx
  000e6	77 0e		 ja	 SHORT $L228070
  000e8	8a 10		 mov	 dl, BYTE PTR [eax]
  000ea	88 97 70 01 00
	00		 mov	 BYTE PTR [edi+368], dl
  000f0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f3	40		 inc	 eax
  000f4	eb 09		 jmp	 SHORT $L228109
$L228070:
  000f6	88 9f 70 01 00
	00		 mov	 BYTE PTR [edi+368], bl
  000fc	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L228109:

; 46   : 
; 47   : 		// mirchang_100513 type cast fix
; 48   : 		//ar >> u2;								// m_dwIndex
; 49   : 		//m_dwIndex	= (DWORD)u2;
; 50   : 		ar >> m_dwIndex;

  000ff	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00102	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00105	3b ca		 cmp	 ecx, edx
  00107	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0010a	77 10		 ja	 SHORT $L228076
  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
  0010e	89 97 74 01 00
	00		 mov	 DWORD PTR [edi+372], edx
  00114	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00117	83 c0 04	 add	 eax, 4
  0011a	eb 09		 jmp	 SHORT $L228110
$L228076:
  0011c	89 9f 74 01 00
	00		 mov	 DWORD PTR [edi+372], ebx
  00122	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L228110:

; 51   : 		// mirchang_100513 type cast fix
; 52   : 
; 53   : 		ar >> u2;								// m_vScale.x * 100.0f

  00125	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00128	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0012b	3b ca		 cmp	 ecx, edx
  0012d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00130	77 08		 ja	 SHORT $L228082
  00132	66 8b 00	 mov	 ax, WORD PTR [eax]
  00135	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00138	eb 05		 jmp	 SHORT $L228083
$L228082:
  0013a	33 c0		 xor	 eax, eax
  0013c	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228083:

; 54   : 		m_vScale.x	=	m_vScale.y	=	m_vScale.z	= (float)u2 / 100.0f;

  0013f	0f b7 c8	 movzx	 ecx, ax
  00142	89 4c 24 20	 mov	 DWORD PTR tv325[esp+24], ecx

; 55   : 		ar >> m_vPos;							// m_vPos

  00146	6a 0c		 push	 12			; 0000000cH
  00148	8d af 60 01 00
	00		 lea	 ebp, DWORD PTR [edi+352]
  0014e	db 44 24 24	 fild	 DWORD PTR tv325[esp+28]
  00152	55		 push	 ebp
  00153	8b ce		 mov	 ecx, esi
  00155	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0015b	d9 57 14	 fst	 DWORD PTR [edi+20]
  0015e	d9 57 10	 fst	 DWORD PTR [edi+16]
  00161	d9 5f 0c	 fstp	 DWORD PTR [edi+12]
  00164	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 56   : 		ar >> i2;								// m_fAngle * 10.0f

  00169	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0016f	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  00172	3b ca		 cmp	 ecx, edx
  00174	77 08		 ja	 SHORT $L228097
  00176	66 8b 00	 mov	 ax, WORD PTR [eax]
  00179	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0017c	eb 05		 jmp	 SHORT $L228098
$L228097:
  0017e	33 c0		 xor	 eax, eax
  00180	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228098:

; 57   : 		m_fAngle	= (float)i2 / 10.0f;

  00183	0f bf d0	 movsx	 edx, ax
  00186	89 54 24 20	 mov	 DWORD PTR tv320[esp+24], edx

; 58   : 	#if defined(__WORLDSERVER) || defined(__CLIENT)
; 59   : 		SetAngle( m_fAngle );

  0018a	8b cf		 mov	 ecx, edi
  0018c	db 44 24 20	 fild	 DWORD PTR tv320[esp+24]
  00190	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3dcccccd
  00196	d9 54 24 20	 fst	 DWORD PTR tv312[esp+24]
  0019a	8b 44 24 20	 mov	 eax, DWORD PTR tv312[esp+24]
  0019e	d9 5f 18	 fstp	 DWORD PTR [edi+24]
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle

; 60   : 	#endif
; 61   : 
; 62   : 	#ifdef __WORLDSERVER
; 63   : 		m_vLink		= m_vPos;

  001a7	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  001aa	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  001ad	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  001b0	81 c7 ac 01 00
	00		 add	 edi, 428		; 000001acH
  001b6	89 0f		 mov	 DWORD PTR [edi], ecx
  001b8	89 57 04	 mov	 DWORD PTR [edi+4], edx
  001bb	89 47 08	 mov	 DWORD PTR [edi+8], eax
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5d		 pop	 ebp
  001c1	5b		 pop	 ebx

; 64   : 	#endif	// __WORLDSERVER
; 65   : 	}
; 66   : }

  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c5	c2 04 00	 ret	 4
?Serialize@CObj@@UAEXAAVCAr@@@Z ENDP			; CObj::Serialize
_TEXT	ENDS
PUBLIC	?OnApplySM@CMover@@QAEXXZ			; CMover::OnApplySM
EXTRN	?SetDestParam@CMover@@QAEXHHHH@Z:NEAR		; CMover::SetDestParam
EXTRN	?g_AddSMMode@@3U_ADDSMMODE@@A:BYTE		; g_AddSMMode
; Function compile flags: /Ogty
;	COMDAT ?OnApplySM@CMover@@QAEXXZ
_TEXT	SEGMENT
?OnApplySM@CMover@@QAEXXZ PROC NEAR			; CMover::OnApplySM, COMDAT
; _this$ = ecx

; 71   : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 72   : 	ItemProp* aItemprop;
; 73   : 	int nAdjParamVal;
; 74   : 
; 75   : 	if( m_dwSMTime[SM_MAX_HP] > 0 )

  00003	8b 87 24 03 00
	00		 mov	 eax, DWORD PTR [edi+804]
  00009	85 c0		 test	 eax, eax
  0000b	76 53		 jbe	 SHORT $L226226

; 76   : 	{
; 77   : 		aItemprop = prj.GetItemProp( II_CHR_FOO_COO_BULLHAMS );

  0000d	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  00012	3d e1 27 00 00	 cmp	 eax, 10209		; 000027e1H
  00017	7e 0f		 jle	 SHORT $L228141
  00019	76 27		 jbe	 SHORT $L228241
  0001b	a1 4c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+588
  00020	8b 80 84 9f 00
	00		 mov	 eax, DWORD PTR [eax+40836]
  00026	eb 1c		 jmp	 SHORT $L228136
$L228141:
  00028	68 e1 27 00 00	 push	 10209			; 000027e1H
  0002d	50		 push	 eax
  0002e	6a 00		 push	 0
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0003a	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003f	83 c4 14	 add	 esp, 20			; 00000014H
$L228241:
  00042	33 c0		 xor	 eax, eax
$L228136:

; 78   : 		nAdjParamVal = aItemprop->nAdjParamVal2;
; 79   : 		SetDestParam( aItemprop->dwDestParam1, nAdjParamVal, NULL_CHGPARAM, 1 );	// fixed by jeff

  00044	8b 88 5c 01 00
	00		 mov	 ecx, DWORD PTR [eax+348]
  0004a	8b 90 40 01 00
	00		 mov	 edx, DWORD PTR [eax+320]
  00050	6a 01		 push	 1
  00052	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00057	51		 push	 ecx
  00058	52		 push	 edx
  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L226226:

; 80   : 	}
; 81   : 
; 82   : 	if( m_dwSMTime[SM_MAX_HP50] > 0 )

  00060	8b 87 28 03 00
	00		 mov	 eax, DWORD PTR [edi+808]
  00066	85 c0		 test	 eax, eax
  00068	76 53		 jbe	 SHORT $L226227

; 83   : 	{
; 84   : 		aItemprop = prj.GetItemProp( II_CHR_FOO_COO_GRILLEDEEL );

  0006a	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  0006f	3d e2 27 00 00	 cmp	 eax, 10210		; 000027e2H
  00074	7e 0f		 jle	 SHORT $L228183
  00076	76 27		 jbe	 SHORT $L228242
  00078	a1 4c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+588
  0007d	8b 80 88 9f 00
	00		 mov	 eax, DWORD PTR [eax+40840]
  00083	eb 1c		 jmp	 SHORT $L228178
$L228183:
  00085	68 e2 27 00 00	 push	 10210			; 000027e2H
  0008a	50		 push	 eax
  0008b	6a 00		 push	 0
  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00097	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
$L228242:
  0009f	33 c0		 xor	 eax, eax
$L228178:

; 85   : 		nAdjParamVal = m_nPlusMaxHitPoint;
; 86   : 		SetDestParam( aItemprop->dwDestParam1, nAdjParamVal, NULL_CHGPARAM, 1 );	// fixed by jeff

  000a1	8b 8f b8 06 00
	00		 mov	 ecx, DWORD PTR [edi+1720]
  000a7	8b 90 40 01 00
	00		 mov	 edx, DWORD PTR [eax+320]
  000ad	6a 01		 push	 1
  000af	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  000b4	51		 push	 ecx
  000b5	52		 push	 edx
  000b6	8b cf		 mov	 ecx, edi
  000b8	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L226227:

; 87   : 	}
; 88   : 
; 89   : 	if( m_dwSMTime[SM_VELOCIJUMP] > 0 )

  000bd	8b 87 58 03 00
	00		 mov	 eax, DWORD PTR [edi+856]
  000c3	85 c0		 test	 eax, eax
  000c5	76 66		 jbe	 SHORT $L226231

; 90   : 	{
; 91   : 		aItemprop = prj.GetItemProp( g_AddSMMode.dwSMItemID[SM_VELOCIJUMP] );

  000c7	a1 bc 00 00 00	 mov	 eax, DWORD PTR ?g_AddSMMode@@3U_ADDSMMODE@@A+188
  000cc	85 c0		 test	 eax, eax
  000ce	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  000d4	7c 59		 jl	 SHORT $L228225
  000d6	3b c1		 cmp	 eax, ecx
  000d8	7d 55		 jge	 SHORT $L228225
  000da	73 51		 jae	 SHORT $L226231
  000dc	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  000e2	56		 push	 esi
  000e3	8b 34 81	 mov	 esi, DWORD PTR [ecx+eax*4]

; 92   : 		if( aItemprop )

  000e6	85 f6		 test	 esi, esi
  000e8	74 42		 je	 SHORT $L228240

; 93   : 		{
; 94   : 			if( aItemprop->dwDestParam1 != -1 )

  000ea	8b 86 40 01 00
	00		 mov	 eax, DWORD PTR [esi+320]
  000f0	83 f8 ff	 cmp	 eax, -1
  000f3	74 16		 je	 SHORT $L226230

; 95   : 				SetDestParam( aItemprop->dwDestParam1, aItemprop->nAdjParamVal1, NULL_CHGPARAM );

  000f5	8b 96 58 01 00
	00		 mov	 edx, DWORD PTR [esi+344]
  000fb	6a 01		 push	 1
  000fd	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	8b cf		 mov	 ecx, edi
  00106	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L226230:

; 96   : 			if( aItemprop->dwDestParam2 != -1 )

  0010b	8b 86 44 01 00
	00		 mov	 eax, DWORD PTR [esi+324]
  00111	83 f8 ff	 cmp	 eax, -1
  00114	74 16		 je	 SHORT $L228240

; 97   : 				SetDestParam( aItemprop->dwDestParam2, aItemprop->nAdjParamVal2, NULL_CHGPARAM );

  00116	8b 8e 5c 01 00
	00		 mov	 ecx, DWORD PTR [esi+348]
  0011c	6a 01		 push	 1
  0011e	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00123	51		 push	 ecx
  00124	50		 push	 eax
  00125	8b cf		 mov	 ecx, edi
  00127	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L228240:
  0012c	5e		 pop	 esi
$L226231:
  0012d	5f		 pop	 edi

; 98   : 		}
; 99   : 	}
; 100  : }

  0012e	c3		 ret	 0

; 90   : 	{
; 91   : 		aItemprop = prj.GetItemProp( g_AddSMMode.dwSMItemID[SM_VELOCIJUMP] );

$L228225:
  0012f	50		 push	 eax
  00130	51		 push	 ecx
  00131	6a 00		 push	 0
  00133	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0013d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00142	83 c4 14	 add	 esp, 20			; 00000014H
  00145	5f		 pop	 edi

; 98   : 		}
; 99   : 	}
; 100  : }

  00146	c3		 ret	 0
?OnApplySM@CMover@@QAEXXZ ENDP				; CMover::OnApplySM
_TEXT	ENDS
PUBLIC	??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
PUBLIC	?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetEquip
EXTRN	?WriteError@@YAXPBDZZ:NEAR			; WriteError
;	COMDAT ??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
CONST	SEGMENT
??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@ DB 'GETEQUIP/'
	DB	'/%d, %d, %d', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetEquip, COMDAT
; _this$ = ecx

; 617  : {

  00000	56		 push	 esi

; 618  : 	if( m_dwIndexNum )

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	85 f6		 test	 esi, esi
  00006	74 32		 je	 SHORT $L226709

; 619  : 	{
; 620  : 		if( dwIndex < 0 || dwIndex >= ( m_dwItemMax - m_dwIndexNum ) )

  00008	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR _dwIndex$[esp]
  0000f	57		 push	 edi
  00010	8b f8		 mov	 edi, eax
  00012	2b fe		 sub	 edi, esi
  00014	3b d7		 cmp	 edx, edi
  00016	5f		 pop	 edi
  00017	73 0c		 jae	 SHORT $L226711

; 623  : 			return NULL;
; 624  : 		}
; 625  : 		return GetAt( m_dwIndexNum + dwIndex );

  00019	03 f2		 add	 esi, edx
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAt
  00021	5e		 pop	 esi

; 628  : }

  00022	c2 04 00	 ret	 4
$L226711:

; 621  : 		{
; 622  : 			WriteError( "GETEQUIP//%d, %d, %d", m_dwIndexNum, m_dwItemMax - m_dwIndexNum, dwIndex );

  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00028	52		 push	 edx
  00029	2b c1		 sub	 eax, ecx
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
  00032	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  00037	83 c4 10	 add	 esp, 16			; 00000010H
$L226709:

; 626  : 	}
; 627  : 	return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	5e		 pop	 esi

; 628  : }

  0003d	c2 04 00	 ret	 4
?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetEquip
_TEXT	ENDS
PUBLIC	?Serialize@CMover@@UAEXAAVCAr@@@Z		; CMover::Serialize
PUBLIC	__real@3e4ccccd
PUBLIC	__real@4f800000
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	?ClearEquipInfo@CMover@@QAEXXZ:NEAR		; CMover::ClearEquipInfo
EXTRN	?GetTitle@CVTInfo@@QAEPBDXZ:NEAR		; CVTInfo::GetTitle
EXTRN	?SetTitle@CVTInfo@@QAEXPBD@Z:NEAR		; CVTInfo::SetTitle
EXTRN	?Serialize@CCtrl@@UAEXAAVCAr@@@Z:NEAR		; CCtrl::Serialize
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	?Serialize@CBuffMgr@@QAEXAAVCAr@@@Z:NEAR	; CBuffMgr::Serialize
EXTRN	?SetHairColor@CMover@@QAEXK@Z:NEAR		; CMover::SetHairColor
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	?GetIndex@CPet@@QAEKXZ:NEAR			; CPet::GetIndex
EXTRN	?GetPetItem@CMover@@QAEPAVCItemElem@@XZ:NEAR	; CMover::GetPetItem
EXTRN	?WriteString@CAr@@QAEXPBD@Z:NEAR		; CAr::WriteString
EXTRN	?ReadString@CAr@@QAEPADPADH@Z:NEAR		; CAr::ReadString
EXTRN	?AddStateFlag@CAction@@QAEXK@Z:NEAR		; CAction::AddStateFlag
EXTRN	?Serialize@CPocketController@@QAEXAAVCAr@@@Z:NEAR ; CPocketController::Serialize
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\objserializeopt.cpp
CONST	ENDS
;	COMDAT ?Serialize@CMover@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT
$T228737 = -256						; size = 1
$T228643 = -256						; size = 1
$T228639 = -256						; size = 1
$T228635 = -256						; size = 1
$T228619 = -256						; size = 1
$T228611 = -256						; size = 1
_uParts$226341 = -256					; size = 1
_uSize$226309 = -256					; size = 1
_uSize$226337 = -249					; size = 1
_uParts$226311 = -249					; size = 1
tv5012 = -248						; size = 4
tv4993 = -248						; size = 4
tv3219 = -248						; size = 4
tv3208 = -248						; size = 4
tv2986 = -248						; size = 4
tv2638 = -248						; size = 4
tv2629 = -248						; size = 4
tv2618 = -248						; size = 4
tv2585 = -248						; size = 4
_pszPetName$226322 = -248				; size = 4
$T228729 = -244						; size = 2
$T228321 = -244						; size = 2
$T228325 = -244						; size = 2
$T228329 = -244						; size = 2
$T228333 = -244						; size = 2
$T228337 = -244						; size = 2
$T228671 = -244						; size = 4
$T228627 = -244						; size = 4
$T228623 = -244						; size = 4
$T228607 = -244						; size = 4
$T228499 = -244						; size = 4
$T228486 = -244						; size = 4
tv937 = -244						; size = 4
_pItemElem$226340 = -244				; size = 4
tv4889 = -240						; size = 4
_pItemElem$226323 = -240				; size = 4
_uOffset$226310 = -240					; size = 4
$T228808 = -236						; size = 4
_uOffset$226338 = -236					; size = 4
_nBlockSize$226318 = -236				; size = 4
_dwJobLv$226390 = -232					; size = 160
_dwJobLv$226278 = -232					; size = 160
tv4960 = -72						; size = 4
$T228647 = -72						; size = 8
$T228569 = -72						; size = 12
$T228557 = -72						; size = 8
$T228535 = -72						; size = 8
_szPetName$226439 = -72					; size = 17
_nBlockSize$226347 = -72				; size = 4
_szPVendor$226424 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_ar$ = 8						; size = 4
?Serialize@CMover@@UAEXAAVCAr@@@Z PROC NEAR		; CMover::Serialize, COMDAT
; _this$ = ecx

; 104  : {

  00000	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8b b4 24 10 01
	00 00		 mov	 esi, DWORD PTR _ar$[esp+264]
  00017	57		 push	 edi

; 105  : 	CCtrl::Serialize( ar );	//	25

  00018	56		 push	 esi
  00019	89 84 24 10 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+276], eax
  00020	8b e9		 mov	 ebp, ecx
  00022	e8 00 00 00 00	 call	 ?Serialize@CCtrl@@UAEXAAVCAr@@@Z ; CCtrl::Serialize

; 106  : 	DWORD dwGold;
; 107  : 
; 108  : 	if( ar.IsStoring() )	// STORING

  00027	33 c0		 xor	 eax, eax
  00029	8a 06		 mov	 al, BYTE PTR [esi]
  0002b	f7 d0		 not	 eax
  0002d	a8 01		 test	 al, 1
  0002f	0f 84 c0 0d 00
	00		 je	 $L226237

; 109  : 	{
; 110  : 		ar << (u_short)m_dwMotion;

  00035	66 8b bd dc 02
	00 00		 mov	 di, WORD PTR [ebp+732]
  0003c	6a 02		 push	 2
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00045	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00048	66 89 39	 mov	 WORD PTR [ecx], di
  0004b	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 111  : 		ar << (u_char)m_bPlayer;

  0004f	8a 9d 34 02 00
	00		 mov	 bl, BYTE PTR [ebp+564]
  00055	6a 01		 push	 1
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	88 1a		 mov	 BYTE PTR [edx], bl
  00063	ff 46 08	 inc	 DWORD PTR [esi+8]

; 112  : 		ar << m_nHitPoint;

  00066	8b 9d 00 06 00
	00		 mov	 ebx, DWORD PTR [ebp+1536]
  0006c	bf 04 00 00 00	 mov	 edi, 4
  00071	57		 push	 edi
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00079	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007c	89 18		 mov	 DWORD PTR [eax], ebx
  0007e	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 113  : 		ar << m_pActMover->GetState();

  00081	8b 8d 3c 02 00
	00		 mov	 ecx, DWORD PTR [ebp+572]
  00087	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  0008a	57		 push	 edi
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00092	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00095	89 1a		 mov	 DWORD PTR [edx], ebx
  00097	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 114  : 		ar << m_pActMover->GetStateFlag();

  0009a	8b 85 3c 02 00
	00		 mov	 eax, DWORD PTR [ebp+572]
  000a0	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  000a3	57		 push	 edi
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000ab	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ae	89 19		 mov	 DWORD PTR [ecx], ebx
  000b0	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 115  : 		ar << (u_char)m_dwBelligerence;

  000b3	8a 9d 6c 06 00
	00		 mov	 bl, BYTE PTR [ebp+1644]
  000b9	6a 01		 push	 1
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000c2	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c5	88 1a		 mov	 BYTE PTR [edx], bl
  000c7	ff 46 08	 inc	 DWORD PTR [esi+8]

; 116  : #if __VER >= 15 // __PETVIS
; 117  : 		ar << m_dwMoverSfxId;

  000ca	8b 9d 90 11 00
	00		 mov	 ebx, DWORD PTR [ebp+4496]
  000d0	57		 push	 edi
  000d1	8b ce		 mov	 ecx, esi
  000d3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000db	89 18		 mov	 DWORD PTR [eax], ebx
  000dd	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 118  : #endif // __PETVIS
; 119  : 		if( m_bPlayer )	// PLAYER

  000e0	8b 85 34 02 00
	00		 mov	 eax, DWORD PTR [ebp+564]
  000e6	85 c0		 test	 eax, eax
  000e8	0f 84 0a 0b 00
	00		 je	 $L226241

; 120  : 		{
; 121  : 			ar.WriteString( m_szName );

  000ee	8d 8d 90 16 00
	00		 lea	 ecx, DWORD PTR [ebp+5776]
  000f4	51		 push	 ecx
  000f5	8b ce		 mov	 ecx, esi
  000f7	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 122  : 			ar << GetSex();

  000fc	8a 9d 20 06 00
	00		 mov	 bl, BYTE PTR [ebp+1568]
  00102	6a 01		 push	 1
  00104	8b ce		 mov	 ecx, esi
  00106	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0010b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0010e	88 1a		 mov	 BYTE PTR [edx], bl
  00110	ff 46 08	 inc	 DWORD PTR [esi+8]

; 123  : 			ar << (u_char)m_dwSkinSet;

  00113	8a 9d 24 06 00
	00		 mov	 bl, BYTE PTR [ebp+1572]
  00119	6a 01		 push	 1
  0011b	8b ce		 mov	 ecx, esi
  0011d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00122	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00125	88 18		 mov	 BYTE PTR [eax], bl
  00127	ff 46 08	 inc	 DWORD PTR [esi+8]

; 124  : 			ar << (u_char)m_dwHairMesh;

  0012a	8a 9d 2c 06 00
	00		 mov	 bl, BYTE PTR [ebp+1580]
  00130	6a 01		 push	 1
  00132	8b ce		 mov	 ecx, esi
  00134	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00139	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0013c	88 19		 mov	 BYTE PTR [ecx], bl
  0013e	ff 46 08	 inc	 DWORD PTR [esi+8]

; 125  : 			ar << m_dwHairColor;

  00141	8b 9d 30 06 00
	00		 mov	 ebx, DWORD PTR [ebp+1584]
  00147	57		 push	 edi
  00148	8b ce		 mov	 ecx, esi
  0014a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0014f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00152	89 1a		 mov	 DWORD PTR [edx], ebx
  00154	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 126  : 			ar << (u_char)m_dwHeadMesh;

  00157	8a 9d 34 06 00
	00		 mov	 bl, BYTE PTR [ebp+1588]
  0015d	6a 01		 push	 1
  0015f	8b ce		 mov	 ecx, esi
  00161	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00166	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00169	88 18		 mov	 BYTE PTR [eax], bl
  0016b	ff 46 08	 inc	 DWORD PTR [esi+8]

; 127  : 			ar << m_idPlayer;

  0016e	8b 9d 38 02 00
	00		 mov	 ebx, DWORD PTR [ebp+568]
  00174	57		 push	 edi
  00175	8b ce		 mov	 ecx, esi
  00177	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0017c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0017f	89 19		 mov	 DWORD PTR [ecx], ebx
  00181	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 128  : 			ar << (u_char)m_nJob;

  00184	8a 9d 44 06 00
	00		 mov	 bl, BYTE PTR [ebp+1604]
  0018a	6a 01		 push	 1
  0018c	8b ce		 mov	 ecx, esi
  0018e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00193	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00196	88 1a		 mov	 BYTE PTR [edx], bl
  00198	ff 46 08	 inc	 DWORD PTR [esi+8]

; 129  : 			ar << (u_short)m_nStr;

  0019b	66 8b 85 d0 05
	00 00		 mov	 ax, WORD PTR [ebp+1488]
  001a2	bb 02 00 00 00	 mov	 ebx, 2
  001a7	53		 push	 ebx
  001a8	8b ce		 mov	 ecx, esi
  001aa	66 89 44 24 20	 mov	 WORD PTR $T228321[esp+276], ax
  001af	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001b4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001b7	66 8b 54 24 1c	 mov	 dx, WORD PTR $T228321[esp+272]
  001bc	66 89 11	 mov	 WORD PTR [ecx], dx
  001bf	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 130  : 			ar << (u_short)m_nSta;

  001c2	66 8b 85 d4 05
	00 00		 mov	 ax, WORD PTR [ebp+1492]
  001c9	66 89 44 24 1c	 mov	 WORD PTR $T228325[esp+272], ax
  001ce	53		 push	 ebx
  001cf	8b ce		 mov	 ecx, esi
  001d1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001d6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001d9	66 8b 54 24 1c	 mov	 dx, WORD PTR $T228325[esp+272]
  001de	66 89 11	 mov	 WORD PTR [ecx], dx
  001e1	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 131  : 			ar << (u_short)m_nDex;

  001e4	66 8b 85 d8 05
	00 00		 mov	 ax, WORD PTR [ebp+1496]
  001eb	53		 push	 ebx
  001ec	8b ce		 mov	 ecx, esi
  001ee	66 89 44 24 20	 mov	 WORD PTR $T228329[esp+276], ax
  001f3	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001f8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001fb	66 8b 54 24 1c	 mov	 dx, WORD PTR $T228329[esp+272]
  00200	66 89 11	 mov	 WORD PTR [ecx], dx
  00203	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 132  : 			ar << (u_short)m_nInt;

  00206	66 8b 85 dc 05
	00 00		 mov	 ax, WORD PTR [ebp+1500]
  0020d	53		 push	 ebx
  0020e	8b ce		 mov	 ecx, esi
  00210	66 89 44 24 20	 mov	 WORD PTR $T228333[esp+276], ax
  00215	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0021a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0021d	66 8b 54 24 1c	 mov	 dx, WORD PTR $T228333[esp+272]
  00222	66 89 11	 mov	 WORD PTR [ecx], dx
  00225	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 133  : 			ar << (u_short)m_nLevel;

  00228	66 8b 85 e0 05
	00 00		 mov	 ax, WORD PTR [ebp+1504]
  0022f	53		 push	 ebx
  00230	8b ce		 mov	 ecx, esi
  00232	66 89 44 24 20	 mov	 WORD PTR $T228337[esp+276], ax
  00237	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0023c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0023f	66 8b 54 24 1c	 mov	 dx, WORD PTR $T228337[esp+272]
  00244	66 89 11	 mov	 WORD PTR [ecx], dx
  00247	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 134  : 			ar << m_nFuel;

  0024a	8b 9d 80 06 00
	00		 mov	 ebx, DWORD PTR [ebp+1664]
  00250	57		 push	 edi
  00251	8b ce		 mov	 ecx, esi
  00253	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00258	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0025b	89 18		 mov	 DWORD PTR [eax], ebx
  0025d	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 135  : 			ar << m_tmAccFuel;

  00260	8b 9d 84 06 00
	00		 mov	 ebx, DWORD PTR [ebp+1668]
  00266	57		 push	 edi
  00267	8b ce		 mov	 ecx, esi
  00269	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0026e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00271	89 19		 mov	 DWORD PTR [ecx], ebx
  00273	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 136  : 			if( m_idGuild > 0 )

  00276	8b 85 1c 07 00
	00		 mov	 eax, DWORD PTR [ebp+1820]
  0027c	85 c0		 test	 eax, eax

; 137  : 			{
; 138  : 				ar << (u_char)1;

  0027e	8b ce		 mov	 ecx, esi
  00280	6a 01		 push	 1
  00282	76 3e		 jbe	 SHORT $L226251
  00284	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00289	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0028c	c6 02 01	 mov	 BYTE PTR [edx], 1
  0028f	ff 46 08	 inc	 DWORD PTR [esi+8]

; 139  : 				ar << m_idGuild;

  00292	8b 9d 1c 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1820]
  00298	57		 push	 edi
  00299	8b ce		 mov	 ecx, esi
  0029b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002a0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002a3	89 18		 mov	 DWORD PTR [eax], ebx
  002a5	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 140  : 				ar << m_idWar;

  002a8	8b 9d 28 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1832]
  002ae	57		 push	 edi
  002af	8b ce		 mov	 ecx, esi
  002b1	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002b6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  002b9	89 19		 mov	 DWORD PTR [ecx], ebx
  002bb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002be	03 c7		 add	 eax, edi

; 141  : 			}
; 142  : 			else

  002c0	eb 0f		 jmp	 SHORT $L229590
$L226251:

; 143  : 			{
; 144  : 				ar << (u_char)0;

  002c2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002c7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  002ca	c6 02 00	 mov	 BYTE PTR [edx], 0
  002cd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002d0	40		 inc	 eax
$L229590:
  002d1	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 145  : 			}
; 146  : 			ar << m_idGuildCloak;

  002d4	8b 9d 24 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1828]
  002da	57		 push	 edi
  002db	8b ce		 mov	 ecx, esi
  002dd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002e5	89 18		 mov	 DWORD PTR [eax], ebx
  002e7	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 147  : 
; 148  : 			if( m_idparty > 0 )

  002ea	8b 85 18 07 00
	00		 mov	 eax, DWORD PTR [ebp+1816]
  002f0	85 c0		 test	 eax, eax

; 149  : 			{
; 150  : 				ar << (u_char)1;

  002f2	8b ce		 mov	 ecx, esi
  002f4	6a 01		 push	 1
  002f6	76 3e		 jbe	 SHORT $L226255
  002f8	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  002fd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00300	c6 01 01	 mov	 BYTE PTR [ecx], 1
  00303	ff 46 08	 inc	 DWORD PTR [esi+8]

; 151  : 				ar << m_idparty;

  00306	8b 9d 18 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1816]
  0030c	57		 push	 edi
  0030d	8b ce		 mov	 ecx, esi
  0030f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00314	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00317	89 1a		 mov	 DWORD PTR [edx], ebx
  00319	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 152  : 				ar << m_idDuelParty;

  0031c	8b 9d 4c 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1868]
  00322	57		 push	 edi
  00323	8b ce		 mov	 ecx, esi
  00325	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0032a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0032d	89 18		 mov	 DWORD PTR [eax], ebx
  0032f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00332	03 c7		 add	 eax, edi

; 153  : 			}
; 154  : 			else

  00334	eb 0f		 jmp	 SHORT $L229591
$L226255:

; 155  : 			{
; 156  : 				ar << (u_char)0;

  00336	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0033b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0033e	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00341	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00344	40		 inc	 eax
$L229591:
  00345	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 157  : 			}
; 158  : 
; 159  : 			ar << (char)m_dwAuthorization;

  00348	8a 9d 48 06 00
	00		 mov	 bl, BYTE PTR [ebp+1608]
  0034e	6a 01		 push	 1
  00350	8b ce		 mov	 ecx, esi
  00352	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00357	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0035a	88 1a		 mov	 BYTE PTR [edx], bl
  0035c	ff 46 08	 inc	 DWORD PTR [esi+8]

; 160  : 			ar << m_dwMode;

  0035f	8b 9d 44 02 00
	00		 mov	 ebx, DWORD PTR [ebp+580]
  00365	57		 push	 edi
  00366	8b ce		 mov	 ecx, esi
  00368	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0036d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00370	89 18		 mov	 DWORD PTR [eax], ebx
  00372	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 161  : 			ar << m_dwStateMode;

  00375	8b 9d 4c 02 00
	00		 mov	 ebx, DWORD PTR [ebp+588]
  0037b	57		 push	 edi
  0037c	8b ce		 mov	 ecx, esi
  0037e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00383	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00386	89 19		 mov	 DWORD PTR [ecx], ebx
  00388	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 162  :  #ifdef __WORLDSERVER
; 163  : 			CItemElem* pItemElem = m_Inventory.GetAtId( m_dwUseItemId );

  0038b	8b 85 90 06 00
	00		 mov	 eax, DWORD PTR [ebp+1680]
  00391	3b 85 9c 0b 00
	00		 cmp	 eax, DWORD PTR [ebp+2972]
  00397	73 2e		 jae	 SHORT $L229583
  00399	8b 95 a0 0b 00
	00		 mov	 edx, DWORD PTR [ebp+2976]
  0039f	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  003a5	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  003a9	03 c2		 add	 eax, edx
  003ab	85 c9		 test	 ecx, ecx
  003ad	74 18		 je	 SHORT $L229583

; 164  : 			if( pItemElem )
; 165  : 				ar << pItemElem->GetProp()->dwID;

  003af	8b c8		 mov	 ecx, eax
  003b1	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  003b6	8b 18		 mov	 ebx, DWORD PTR [eax]
  003b8	57		 push	 edi
  003b9	8b ce		 mov	 ecx, esi
  003bb	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  003c0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  003c3	89 1a		 mov	 DWORD PTR [edx], ebx

; 166  : 			else

  003c5	eb 11		 jmp	 SHORT $L229592
$L229583:

; 167  : 				ar << (OBJID)0;

  003c7	57		 push	 edi
  003c8	8b ce		 mov	 ecx, esi
  003ca	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  003cf	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003d2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L229592:
  003d8	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 168  :  #else // __WORLDSERVER
; 169  : 			ar << m_dwUseItemId;
; 170  :  #endif // __WORLDSERVER
; 171  : #if __VER >= 8 // __S8_PK
; 172  : 			if( m_dwPKTime > 0 )

  003db	8b 9d 58 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1880]
  003e1	85 db		 test	 ebx, ebx
  003e3	76 1d		 jbe	 SHORT $L226264

; 173  : 	#ifdef __WORLDSERVER
; 174  : 				ar << ( m_dwPKTime - GetTickCount() );

  003e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003eb	8b 9d 58 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1880]
  003f1	57		 push	 edi
  003f2	8b ce		 mov	 ecx, esi
  003f4	2b d8		 sub	 ebx, eax
  003f6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  003fb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  003fe	89 19		 mov	 DWORD PTR [ecx], ebx

; 175  : 	#else // __WORLDSERVER
; 176  : 				ar << m_dwPKTime;
; 177  : 	#endif // __WORLDSERVER
; 178  : 			else

  00400	eb 0d		 jmp	 SHORT $L229593
$L226264:

; 179  : 				ar << m_dwPKTime;

  00402	57		 push	 edi
  00403	8b ce		 mov	 ecx, esi
  00405	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0040a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0040d	89 1a		 mov	 DWORD PTR [edx], ebx
$L229593:
  0040f	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 180  : 			ar << m_nPKValue;

  00412	8b 9d 5c 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1884]
  00418	57		 push	 edi
  00419	8b ce		 mov	 ecx, esi
  0041b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00420	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00423	89 18		 mov	 DWORD PTR [eax], ebx
  00425	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 181  : 			ar << m_dwPKPropensity;

  00428	8b 9d 60 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1888]
  0042e	57		 push	 edi
  0042f	8b ce		 mov	 ecx, esi
  00431	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00436	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00439	89 19		 mov	 DWORD PTR [ecx], ebx
  0043b	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 182  : 			ar << m_dwPKExp;

  0043e	8b 9d 64 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1892]
  00444	57		 push	 edi
  00445	8b ce		 mov	 ecx, esi
  00447	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0044c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0044f	89 1a		 mov	 DWORD PTR [edx], ebx
  00451	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 183  : #else // __VER >= 8 // __S8_PK
; 184  : 			ar << (u_short)m_nNumKill;
; 185  : 			ar << m_nSlaughter;
; 186  : #endif // __VER >= 8 // __S8_PK
; 187  : 			ar << m_nFame;

  00454	8b 9d 50 07 00
	00		 mov	 ebx, DWORD PTR [ebp+1872]
  0045a	57		 push	 edi
  0045b	8b ce		 mov	 ecx, esi
  0045d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00462	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00465	89 18		 mov	 DWORD PTR [eax], ebx
  00467	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 188  : 			ar << (u_char)m_nDuel;

  0046a	8a 9d 44 07 00
	00		 mov	 bl, BYTE PTR [ebp+1860]
  00470	6a 01		 push	 1
  00472	8b ce		 mov	 ecx, esi
  00474	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00479	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0047c	88 19		 mov	 BYTE PTR [ecx], bl
  0047e	ff 46 08	 inc	 DWORD PTR [esi+8]

; 189  : #if __VER >= 13 // __HONORABLE_TITLE			// 달인
; 190  : 			ar << m_nHonor;					// 달인선택 

  00481	8b 9d 04 09 00
	00		 mov	 ebx, DWORD PTR [ebp+2308]
  00487	57		 push	 edi
  00488	8b ce		 mov	 ecx, esi
  0048a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0048f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00492	89 1a		 mov	 DWORD PTR [edx], ebx
  00494	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00497	8d 9d 0c 0c 00
	00		 lea	 ebx, DWORD PTR [ebp+3084]
  0049d	c7 44 24 18 1f
	00 00 00	 mov	 DWORD PTR tv2638[esp+272], 31 ; 0000001fH
$L226268:

; 191  : #endif	// __HONORABLE_TITLE			// 달인
; 192  : 			{
; 193  : 				int i;
; 194  : 				for( i = 0; i < MAX_HUMAN_PARTS; i ++ )
; 195  : 				{
; 196  : 					ar << m_aEquipInfo[i].nOption;

  004a5	8b 03		 mov	 eax, DWORD PTR [ebx]
  004a7	57		 push	 edi
  004a8	8b ce		 mov	 ecx, esi
  004aa	89 44 24 20	 mov	 DWORD PTR $T228486[esp+276], eax
  004ae	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  004b3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004b6	8b 54 24 1c	 mov	 edx, DWORD PTR $T228486[esp+272]
  004ba	8b 44 24 18	 mov	 eax, DWORD PTR tv2638[esp+272]
  004be	89 11		 mov	 DWORD PTR [ecx], edx
  004c0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  004c3	03 d7		 add	 edx, edi
  004c5	83 c3 0c	 add	 ebx, 12			; 0000000cH
  004c8	48		 dec	 eax
  004c9	89 56 08	 mov	 DWORD PTR [esi+8], edx
  004cc	89 44 24 18	 mov	 DWORD PTR tv2638[esp+272], eax
  004d0	75 d3		 jne	 SHORT $L226268

; 197  : 				}
; 198  : 			}
; 199  : 			ar << m_nGuildCombatState;

  004d2	8b 9d 98 0e 00
	00		 mov	 ebx, DWORD PTR [ebp+3736]
  004d8	57		 push	 edi
  004d9	8b ce		 mov	 ecx, esi
  004db	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  004e0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  004e3	89 18		 mov	 DWORD PTR [eax], ebx
  004e5	01 7e 08	 add	 DWORD PTR [esi+8], edi
  004e8	8d 9d 04 03 00
	00		 lea	 ebx, DWORD PTR [ebp+772]
  004ee	c7 44 24 18 1a
	00 00 00	 mov	 DWORD PTR tv2629[esp+272], 26 ; 0000001aH
$L226272:

; 200  : 			
; 201  : 			for( int j = 0 ; j < SM_MAX ; ++j )
; 202  : 				ar << m_dwSMTime[j];

  004f6	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  004f8	89 4c 24 1c	 mov	 DWORD PTR $T228499[esp+272], ecx
  004fc	57		 push	 edi
  004fd	8b ce		 mov	 ecx, esi
  004ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00504	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00507	8b 44 24 1c	 mov	 eax, DWORD PTR $T228499[esp+272]
  0050b	89 02		 mov	 DWORD PTR [edx], eax
  0050d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00510	8b 44 24 18	 mov	 eax, DWORD PTR tv2629[esp+272]
  00514	03 d7		 add	 edx, edi
  00516	03 df		 add	 ebx, edi
  00518	48		 dec	 eax
  00519	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0051c	89 44 24 18	 mov	 DWORD PTR tv2629[esp+272], eax
  00520	75 d4		 jne	 SHORT $L226272

; 203  : 
; 204  : 			if( CObj::GetMethod() == METHOD_NONE )

  00522	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nMethod@CObj@@2HA ; CObj::m_nMethod
  00527	85 c0		 test	 eax, eax
  00529	0f 85 1f 05 00
	00		 jne	 $L226275

; 205  : 			{
; 206  : 				ar << (u_short)m_nManaPoint;

  0052f	66 8b bd 04 06
	00 00		 mov	 di, WORD PTR [ebp+1540]
  00536	bb 02 00 00 00	 mov	 ebx, 2
  0053b	53		 push	 ebx
  0053c	8b ce		 mov	 ecx, esi
  0053e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00543	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00546	66 89 39	 mov	 WORD PTR [ecx], di
  00549	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 207  : 				ar << (u_short)m_nFatiguePoint;

  0054c	66 8b bd 08 06
	00 00		 mov	 di, WORD PTR [ebp+1544]
  00553	53		 push	 ebx
  00554	8b ce		 mov	 ecx, esi
  00556	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0055b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0055e	66 89 3a	 mov	 WORD PTR [edx], di
  00561	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 208  : #if __VER >= 12 // __MOD_TUTORIAL
; 209  : 				ar << m_nTutorialState;

  00564	8b bd f8 05 00
	00		 mov	 edi, DWORD PTR [ebp+1528]
  0056a	bb 04 00 00 00	 mov	 ebx, 4
  0056f	53		 push	 ebx
  00570	8b ce		 mov	 ecx, esi
  00572	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00577	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0057a	89 38		 mov	 DWORD PTR [eax], edi
  0057c	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 210  : #else	// __MOD_TUTORIAL
; 211  : 				ar << (u_short)m_nFlightLv;
; 212  : #endif	// __MOD_TUTORIAL
; 213  : 				ar << m_nFxp;

  0057f	8b bd fc 05 00
	00		 mov	 edi, DWORD PTR [ebp+1532]
  00585	53		 push	 ebx
  00586	8b ce		 mov	 ecx, esi
  00588	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0058d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00590	89 39		 mov	 DWORD PTR [ecx], edi
  00592	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 214  : 				
; 215  : 				dwGold = GetGold();
; 216  : 				ar << dwGold;

  00595	8b bd 84 16 00
	00		 mov	 edi, DWORD PTR [ebp+5764]
  0059b	53		 push	 ebx
  0059c	8b ce		 mov	 ecx, esi
  0059e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  005a3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  005a6	89 3a		 mov	 DWORD PTR [edx], edi
  005a8	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 217  : 				ar << m_nExp1;

  005ab	8b 8d ec 05 00
	00		 mov	 ecx, DWORD PTR [ebp+1516]
  005b1	8b 85 e8 05 00
	00		 mov	 eax, DWORD PTR [ebp+1512]
  005b7	6a 08		 push	 8
  005b9	8d 94 24 cc 00
	00 00		 lea	 edx, DWORD PTR $T228535[esp+276]
  005c0	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR $T228535[esp+280], ecx
  005c7	52		 push	 edx
  005c8	8b ce		 mov	 ecx, esi
  005ca	89 84 24 d0 00
	00 00		 mov	 DWORD PTR $T228535[esp+280], eax
  005d1	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 218  : 				ar << m_nSkillLevel;

  005d6	8b bd a0 11 00
	00		 mov	 edi, DWORD PTR [ebp+4512]
  005dc	53		 push	 ebx
  005dd	8b ce		 mov	 ecx, esi
  005df	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  005e4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  005e7	89 38		 mov	 DWORD PTR [eax], edi
  005e9	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 219  : 				ar << m_nSkillPoint;

  005ec	8b bd a4 11 00
	00		 mov	 edi, DWORD PTR [ebp+4516]
  005f2	53		 push	 ebx
  005f3	8b ce		 mov	 ecx, esi
  005f5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  005fa	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  005fd	89 39		 mov	 DWORD PTR [ecx], edi
  005ff	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 220  : 				ar << m_nDeathExp;

  00602	8b 95 f0 05 00
	00		 mov	 edx, DWORD PTR [ebp+1520]
  00608	8b 85 f4 05 00
	00		 mov	 eax, DWORD PTR [ebp+1524]
  0060e	6a 08		 push	 8
  00610	8d 8c 24 cc 00
	00 00		 lea	 ecx, DWORD PTR $T228557[esp+276]
  00617	89 94 24 cc 00
	00 00		 mov	 DWORD PTR $T228557[esp+276], edx
  0061e	89 84 24 d0 00
	00 00		 mov	 DWORD PTR $T228557[esp+280], eax
  00625	51		 push	 ecx
  00626	8b ce		 mov	 ecx, esi
  00628	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 221  : 				ar << m_nDeathLevel;

  0062d	8b bd e4 05 00
	00		 mov	 edi, DWORD PTR [ebp+1508]
  00633	53		 push	 ebx
  00634	8b ce		 mov	 ecx, esi
  00636	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0063b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0063e	89 3a		 mov	 DWORD PTR [edx], edi
  00640	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 222  : 				DWORD dwJobLv[MAX_JOB] = {0, };

  00643	33 c0		 xor	 eax, eax
  00645	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _dwJobLv$226278[esp+272], 0
  0064d	b9 27 00 00 00	 mov	 ecx, 39			; 00000027H
  00652	8d 7c 24 2c	 lea	 edi, DWORD PTR _dwJobLv$226278[esp+276]
  00656	f3 ab		 rep stosd

; 223  : 				ar.Write( (void*)dwJobLv, sizeof(DWORD) * MAX_JOB );

  00658	68 a0 00 00 00	 push	 160			; 000000a0H
  0065d	8d 44 24 2c	 lea	 eax, DWORD PTR _dwJobLv$226278[esp+276]
  00661	50		 push	 eax
  00662	8b ce		 mov	 ecx, esi
  00664	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 224  : 				ar << m_idMarkingWorld;

  00669	8b bd a8 0e 00
	00		 mov	 edi, DWORD PTR [ebp+3752]
  0066f	53		 push	 ebx
  00670	8b ce		 mov	 ecx, esi
  00672	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00677	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0067a	89 39		 mov	 DWORD PTR [ecx], edi
  0067c	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 225  : 				ar << m_vMarkingPos;

  0067f	8d 95 9c 0e 00
	00		 lea	 edx, DWORD PTR [ebp+3740]
  00685	8b 02		 mov	 eax, DWORD PTR [edx]
  00687	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0068a	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0068d	89 84 24 c8 00
	00 00		 mov	 DWORD PTR $T228569[esp+272], eax
  00694	6a 0c		 push	 12			; 0000000cH
  00696	8d 84 24 cc 00
	00 00		 lea	 eax, DWORD PTR $T228569[esp+276]
  0069d	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR $T228569[esp+280], ecx
  006a4	50		 push	 eax
  006a5	8b ce		 mov	 ecx, esi
  006a7	89 94 24 d8 00
	00 00		 mov	 DWORD PTR $T228569[esp+288], edx
  006ae	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 226  : 				ar << m_nQuestSize;

  006b3	8a 9d 7e 0e 00
	00		 mov	 bl, BYTE PTR [ebp+3710]
  006b9	6a 01		 push	 1
  006bb	8b ce		 mov	 ecx, esi
  006bd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  006c2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006c5	88 19		 mov	 BYTE PTR [ecx], bl
  006c7	ff 46 08	 inc	 DWORD PTR [esi+8]

; 227  : 				ar.Write( m_aQuest, sizeof(QUEST) * m_nQuestSize );

  006ca	0f b6 95 7e 0e
	00 00		 movzx	 edx, BYTE PTR [ebp+3710]
  006d1	8b 85 80 0e 00
	00		 mov	 eax, DWORD PTR [ebp+3712]
  006d7	6b d2 0e	 imul	 edx, 14			; 0000000eH
  006da	52		 push	 edx
  006db	50		 push	 eax
  006dc	8b ce		 mov	 ecx, esi
  006de	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 228  : 				ar << m_nCompleteQuestSize;

  006e3	8a 9d 84 0e 00
	00		 mov	 bl, BYTE PTR [ebp+3716]
  006e9	6a 01		 push	 1
  006eb	8b ce		 mov	 ecx, esi
  006ed	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  006f2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006f5	88 19		 mov	 BYTE PTR [ecx], bl
  006f7	ff 46 08	 inc	 DWORD PTR [esi+8]

; 229  : 				ar.Write( m_aCompleteQuest, sizeof(WORD) * m_nCompleteQuestSize ); 

  006fa	0f b6 95 84 0e
	00 00		 movzx	 edx, BYTE PTR [ebp+3716]
  00701	8b 85 88 0e 00
	00		 mov	 eax, DWORD PTR [ebp+3720]
  00707	d1 e2		 shl	 edx, 1
  00709	52		 push	 edx
  0070a	50		 push	 eax
  0070b	8b ce		 mov	 ecx, esi
  0070d	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 230  : 
; 231  : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 232  : 				ar << m_nCheckedQuestSize;

  00712	8a 9d 8c 0e 00
	00		 mov	 bl, BYTE PTR [ebp+3724]
  00718	6a 01		 push	 1
  0071a	8b ce		 mov	 ecx, esi
  0071c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00721	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00724	88 19		 mov	 BYTE PTR [ecx], bl
  00726	ff 46 08	 inc	 DWORD PTR [esi+8]

; 233  : 				ar.Write( m_aCheckedQuest, sizeof(WORD) * m_nCheckedQuestSize ); 

  00729	0f b6 95 8c 0e
	00 00		 movzx	 edx, BYTE PTR [ebp+3724]
  00730	8b 85 90 0e 00
	00		 mov	 eax, DWORD PTR [ebp+3728]
  00736	d1 e2		 shl	 edx, 1
  00738	52		 push	 edx
  00739	50		 push	 eax
  0073a	8b ce		 mov	 ecx, esi
  0073c	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 234  : #endif // __IMPROVE_QUEST_INTERFACE
; 235  : 
; 236  : 				ar << m_idMurderer;

  00741	8b bd 54 07 00
	00		 mov	 edi, DWORD PTR [ebp+1876]
  00747	6a 04		 push	 4
  00749	8b ce		 mov	 ecx, esi
  0074b	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00750	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00753	89 39		 mov	 DWORD PTR [ecx], edi
  00755	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 237  : 				ar << (short)m_nRemainGP;

  00759	66 8b bd 0c 06
	00 00		 mov	 di, WORD PTR [ebp+1548]
  00760	bb 02 00 00 00	 mov	 ebx, 2
  00765	53		 push	 ebx
  00766	8b ce		 mov	 ecx, esi
  00768	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0076d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00770	66 89 3a	 mov	 WORD PTR [edx], di
  00773	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00776	03 d3		 add	 edx, ebx

; 238  : 				ar << (short)0;

  00778	53		 push	 ebx
  00779	8b ce		 mov	 ecx, esi
  0077b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0077e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00783	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00786	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
  0078b	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0078e	8d bd 08 0c 00
	00		 lea	 edi, DWORD PTR [ebp+3080]
  00794	c7 44 24 18 1f
	00 00 00	 mov	 DWORD PTR tv2618[esp+272], 31 ; 0000001fH
  0079c	bb 04 00 00 00	 mov	 ebx, 4
$L226287:

; 239  : 				{
; 240  : 					for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 241  : 						ar << m_aEquipInfo[i].dwId;

  007a1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  007a3	89 4c 24 1c	 mov	 DWORD PTR $T228607[esp+272], ecx
  007a7	53		 push	 ebx
  007a8	8b ce		 mov	 ecx, esi
  007aa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  007af	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  007b2	8b 44 24 1c	 mov	 eax, DWORD PTR $T228607[esp+272]
  007b6	89 02		 mov	 DWORD PTR [edx], eax
  007b8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  007bb	8b 44 24 18	 mov	 eax, DWORD PTR tv2618[esp+272]
  007bf	03 d3		 add	 edx, ebx
  007c1	83 c7 0c	 add	 edi, 12			; 0000000cH
  007c4	48		 dec	 eax
  007c5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  007c8	89 44 24 18	 mov	 DWORD PTR tv2618[esp+272], eax
  007cc	75 d3		 jne	 SHORT $L226287

; 242  : 				}
; 243  : 				ar.Write( (void*)m_aJobSkill, sizeof(SKILL) *  ( MAX_SKILL_JOB ) );

  007ce	68 98 01 00 00	 push	 408			; 00000198H
  007d3	8d 8d 6c 03 00
	00		 lea	 ecx, DWORD PTR [ebp+876]
  007d9	51		 push	 ecx
  007da	8b ce		 mov	 ecx, esi
  007dc	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 244  : 				
; 245  : 				ar << (BYTE)m_nCheerPoint << m_dwTickCheer - GetTickCount();

  007e1	8a 95 34 07 00
	00		 mov	 dl, BYTE PTR [ebp+1844]
  007e7	6a 01		 push	 1
  007e9	8b ce		 mov	 ecx, esi
  007eb	88 54 24 14	 mov	 BYTE PTR $T228611[esp+276], dl
  007ef	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  007f4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  007f7	8a 4c 24 10	 mov	 cl, BYTE PTR $T228611[esp+272]
  007fb	88 08		 mov	 BYTE PTR [eax], cl
  007fd	ff 46 08	 inc	 DWORD PTR [esi+8]
  00800	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00806	8b bd 30 07 00
	00		 mov	 edi, DWORD PTR [ebp+1840]
  0080c	53		 push	 ebx
  0080d	8b ce		 mov	 ecx, esi
  0080f	2b f8		 sub	 edi, eax
  00811	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00816	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00819	89 3a		 mov	 DWORD PTR [edx], edi
  0081b	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 246  : 
; 247  : 				ar << m_nSlot;

  0081e	8a 85 20 0e 00
	00		 mov	 al, BYTE PTR [ebp+3616]
  00824	6a 01		 push	 1
  00826	8b ce		 mov	 ecx, esi
  00828	88 44 24 14	 mov	 BYTE PTR $T228619[esp+276], al
  0082c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00831	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00834	8a 54 24 10	 mov	 dl, BYTE PTR $T228619[esp+272]
  00838	88 11		 mov	 BYTE PTR [ecx], dl
  0083a	ff 46 08	 inc	 DWORD PTR [esi+8]
  0083d	8d bd 34 0e 00
	00		 lea	 edi, DWORD PTR [ebp+3636]
  00843	c7 44 24 18 03
	00 00 00	 mov	 DWORD PTR tv2986[esp+272], 3
  0084b	eb 03 8d 49 00	 npad	 5
$L226294:

; 248  : 				for( int k = 0 ; k < 3 ; ++k )
; 249  : 					ar << m_dwGoldBank[k];

  00850	8b 07		 mov	 eax, DWORD PTR [edi]
  00852	53		 push	 ebx
  00853	8b ce		 mov	 ecx, esi
  00855	89 44 24 20	 mov	 DWORD PTR $T228623[esp+276], eax
  00859	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0085e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00861	8b 54 24 1c	 mov	 edx, DWORD PTR $T228623[esp+272]
  00865	8b 44 24 18	 mov	 eax, DWORD PTR tv2986[esp+272]
  00869	89 11		 mov	 DWORD PTR [ecx], edx
  0086b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0086e	03 d3		 add	 edx, ebx
  00870	03 fb		 add	 edi, ebx
  00872	48		 dec	 eax
  00873	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00876	89 44 24 18	 mov	 DWORD PTR tv2986[esp+272], eax
  0087a	75 d4		 jne	 SHORT $L226294

; 250  : 				for( k = 0 ; k < 3 ; ++k )

  0087c	8d bd 28 0e 00
	00		 lea	 edi, DWORD PTR [ebp+3624]
  00882	c7 44 24 18 03
	00 00 00	 mov	 DWORD PTR tv2585[esp+272], 3
  0088a	8d 9b 00 00 00
	00		 npad	 6
$L226297:

; 251  : 					ar << m_idPlayerBank[k];

  00890	8b 07		 mov	 eax, DWORD PTR [edi]
  00892	53		 push	 ebx
  00893	8b ce		 mov	 ecx, esi
  00895	89 44 24 20	 mov	 DWORD PTR $T228627[esp+276], eax
  00899	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0089e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  008a1	8b 54 24 1c	 mov	 edx, DWORD PTR $T228627[esp+272]
  008a5	8b 44 24 18	 mov	 eax, DWORD PTR tv2585[esp+272]
  008a9	89 11		 mov	 DWORD PTR [ecx], edx
  008ab	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  008ae	03 d3		 add	 edx, ebx
  008b0	03 fb		 add	 edi, ebx
  008b2	48		 dec	 eax
  008b3	89 56 08	 mov	 DWORD PTR [esi+8], edx
  008b6	89 44 24 18	 mov	 DWORD PTR tv2585[esp+272], eax
  008ba	75 d4		 jne	 SHORT $L226297

; 252  : 				ar << m_nPlusMaxHitPoint;

  008bc	8b bd b8 06 00
	00		 mov	 edi, DWORD PTR [ebp+1720]
  008c2	53		 push	 ebx
  008c3	8b ce		 mov	 ecx, esi
  008c5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  008ca	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  008cd	89 38		 mov	 DWORD PTR [eax], edi
  008cf	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 253  : 				ar << m_nAttackResistLeft;

  008d2	8a 8d 14 07 00
	00		 mov	 cl, BYTE PTR [ebp+1812]
  008d8	88 4c 24 10	 mov	 BYTE PTR $T228635[esp+272], cl
  008dc	6a 01		 push	 1
  008de	8b ce		 mov	 ecx, esi
  008e0	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  008e5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  008e8	8a 44 24 10	 mov	 al, BYTE PTR $T228635[esp+272]
  008ec	88 02		 mov	 BYTE PTR [edx], al
  008ee	ff 46 08	 inc	 DWORD PTR [esi+8]

; 254  : 				ar << m_nAttackResistRight;

  008f1	8a 8d 15 07 00
	00		 mov	 cl, BYTE PTR [ebp+1813]
  008f7	88 4c 24 10	 mov	 BYTE PTR $T228639[esp+272], cl
  008fb	6a 01		 push	 1
  008fd	8b ce		 mov	 ecx, esi
  008ff	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00904	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00907	8a 44 24 10	 mov	 al, BYTE PTR $T228639[esp+272]
  0090b	88 02		 mov	 BYTE PTR [edx], al
  0090d	ff 46 08	 inc	 DWORD PTR [esi+8]

; 255  : 				ar << m_nDefenseResist;

  00910	8a 8d 16 07 00
	00		 mov	 cl, BYTE PTR [ebp+1814]
  00916	88 4c 24 10	 mov	 BYTE PTR $T228643[esp+272], cl
  0091a	6a 01		 push	 1
  0091c	8b ce		 mov	 ecx, esi
  0091e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00923	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00926	8a 44 24 10	 mov	 al, BYTE PTR $T228643[esp+272]
  0092a	88 02		 mov	 BYTE PTR [edx], al
  0092c	ff 46 08	 inc	 DWORD PTR [esi+8]

; 256  : #if __VER >= 8 // __CSC_VER8_5
; 257  : 				ar << m_nAngelExp;

  0092f	8b 8d 68 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1896]
  00935	8b 95 6c 07 00
	00		 mov	 edx, DWORD PTR [ebp+1900]
  0093b	6a 08		 push	 8
  0093d	8d 84 24 cc 00
	00 00		 lea	 eax, DWORD PTR $T228647[esp+276]
  00944	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR $T228647[esp+276], ecx
  0094b	50		 push	 eax
  0094c	8b ce		 mov	 ecx, esi
  0094e	89 94 24 d4 00
	00 00		 mov	 DWORD PTR $T228647[esp+284], edx
  00955	e8 00 00 00 00	 call	 ?Write@CAr@@QAEXPBXI@Z	; CAr::Write

; 258  : 				ar << m_nAngelLevel;

  0095a	8b bd 70 07 00
	00		 mov	 edi, DWORD PTR [ebp+1904]
  00960	53		 push	 ebx
  00961	8b ce		 mov	 ecx, esi
  00963	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00968	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0096b	89 39		 mov	 DWORD PTR [ecx], edi
  0096d	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 259  : #endif // __CSC_VER8_5
; 260  : 				m_Inventory.Serialize( ar );

  00970	56		 push	 esi
  00971	8d 8d 90 0b 00
	00		 lea	 ecx, DWORD PTR [ebp+2960]
  00977	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  0097c	8d bd 40 0e 00
	00		 lea	 edi, DWORD PTR [ebp+3648]
  00982	c7 44 24 18 03
	00 00 00	 mov	 DWORD PTR tv3219[esp+272], 3
  0098a	8d 9b 00 00 00
	00		 npad	 6
$L226300:

; 261  : 				for( k = 0 ; k < 3 ; ++k )
; 262  : 					m_Bank[k].Serialize( ar );

  00990	56		 push	 esi
  00991	8b cf		 mov	 ecx, edi
  00993	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  00998	8b 44 24 18	 mov	 eax, DWORD PTR tv3219[esp+272]
  0099c	83 c7 14	 add	 edi, 20			; 00000014H
  0099f	48		 dec	 eax
  009a0	89 44 24 18	 mov	 DWORD PTR tv3219[esp+272], eax
  009a4	75 ea		 jne	 SHORT $L226300

; 263  : #if __VER >= 9	// __PET_0410
; 264  : 				ar << GetPetId();	// 소환 중인 펫 인벤토리 위치

  009a6	8b bd 8c 11 00
	00		 mov	 edi, DWORD PTR [ebp+4492]
  009ac	53		 push	 ebx
  009ad	8b ce		 mov	 ecx, esi
  009af	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  009b4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  009b7	89 3a		 mov	 DWORD PTR [edx], edi
  009b9	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  009bc	03 fb		 add	 edi, ebx

; 265  : #endif	// __PET_0410
; 266  : #if __VER >= 11 // __SYS_POCKET
; 267  : 				m_Pocket.Serialize( ar );

  009be	56		 push	 esi
  009bf	8d 8d f4 0b 00
	00		 lea	 ecx, DWORD PTR [ebp+3060]
  009c5	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  009c8	e8 00 00 00 00	 call	 ?Serialize@CPocketController@@QAEXAAVCAr@@@Z ; CPocketController::Serialize

; 268  : #endif	// __SYS_POCKET
; 269  : #ifdef __JEFF_9_20
; 270  : 				ar << m_dwMute;

  009cd	8b bd 68 0b 00
	00		 mov	 edi, DWORD PTR [ebp+2920]
  009d3	53		 push	 ebx
  009d4	8b ce		 mov	 ecx, esi
  009d6	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  009db	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  009de	89 38		 mov	 DWORD PTR [eax], edi
  009e0	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  009e3	8d bd 0c 09 00
	00		 lea	 edi, DWORD PTR [ebp+2316]
  009e9	c7 44 24 18 96
	00 00 00	 mov	 DWORD PTR tv3208[esp+272], 150 ; 00000096H
$L226304:

; 271  : #endif	// __JEFF_9_20
; 272  : #if __VER >= 13 // __HONORABLE_TITLE			// 달인
; 273  : 				for( int i = 0 ; i < MAX_HONOR_TITLE ; ++i )
; 274  : 				{
; 275  : 					ar << m_aHonorTitle[i];

  009f1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  009f3	89 4c 24 1c	 mov	 DWORD PTR $T228671[esp+272], ecx
  009f7	53		 push	 ebx
  009f8	8b ce		 mov	 ecx, esi
  009fa	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  009ff	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00a02	8b 44 24 1c	 mov	 eax, DWORD PTR $T228671[esp+272]
  00a06	89 02		 mov	 DWORD PTR [edx], eax
  00a08	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00a0b	8b 44 24 18	 mov	 eax, DWORD PTR tv3208[esp+272]
  00a0f	03 d3		 add	 edx, ebx
  00a11	03 fb		 add	 edi, ebx
  00a13	48		 dec	 eax
  00a14	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00a17	89 44 24 18	 mov	 DWORD PTR tv3208[esp+272], eax
  00a1b	75 d4		 jne	 SHORT $L226304

; 276  : 
; 277  : 				}
; 278  : #endif	// __HONORABLE_TITLE			// 달인
; 279  : #if __VER >= 15 // __CAMPUS
; 280  : 				ar << m_idCampus;

  00a1d	8b bd 70 16 00
	00		 mov	 edi, DWORD PTR [ebp+5744]
  00a23	53		 push	 ebx
  00a24	8b ce		 mov	 ecx, esi
  00a26	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a2b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00a2e	89 39		 mov	 DWORD PTR [ecx], edi
  00a30	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 281  : 				ar << m_nCampusPoint;

  00a33	8b bd 74 16 00
	00		 mov	 edi, DWORD PTR [ebp+5748]
  00a39	53		 push	 ebx
  00a3a	8b ce		 mov	 ecx, esi
  00a3c	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a41	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00a44	89 3a		 mov	 DWORD PTR [edx], edi
  00a46	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 357  : #endif	// __AI_0509
; 358  : 		}
; 359  : #ifdef __BUFF_1107
; 360  : 		m_buffs.Serialize( ar );
; 361  : #else	// __BUFF_1107
; 362  : 		m_SkillState.Serialize( ar );
; 363  : #endif	// __BUFF_1107
; 364  : 	}
; 365  : 	else	// LOADING

  00a49	e9 ac 14 00 00	 jmp	 $L229530
$L226275:

; 282  : #endif // __CAMPUS
; 283  : 			}
; 284  : 			else if( CObj::GetMethod() == METHOD_EXCLUDE_ITEM )

  00a4e	83 f8 01	 cmp	 eax, 1
  00a51	0f 85 a3 14 00
	00		 jne	 $L229530

; 285  : 			{
; 286  : #	if defined (__WORLDSERVER) || defined(__CLIENT)
; 287  : 				ar.WriteString( m_vtInfo.GetTitle() );

  00a57	8d 8d 7c 0d 00
	00		 lea	 ecx, DWORD PTR [ebp+3452]
  00a5d	e8 00 00 00 00	 call	 ?GetTitle@CVTInfo@@QAEPBDXZ ; CVTInfo::GetTitle
  00a62	50		 push	 eax
  00a63	8b ce		 mov	 ecx, esi
  00a65	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 288  : #	endif
; 289  : 				u_char uSize	= 0;
; 290  : 				u_long uOffset	= ar.GetOffset();

  00a6a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00a6d	2b 46 10	 sub	 eax, DWORD PTR [esi+16]

; 291  : 				ar << uSize;

  00a70	6a 01		 push	 1
  00a72	8b ce		 mov	 ecx, esi
  00a74	c6 44 24 14 00	 mov	 BYTE PTR _uSize$226309[esp+276], 0
  00a79	89 44 24 24	 mov	 DWORD PTR _uOffset$226310[esp+276], eax
  00a7d	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00a82	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00a85	c6 00 00	 mov	 BYTE PTR [eax], 0
  00a88	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00a8b	40		 inc	 eax
  00a8c	33 c9		 xor	 ecx, ecx
  00a8e	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 292  : 				for( u_char uParts = 0; uParts < MAX_HUMAN_PARTS; uParts++ )

  00a91	c6 44 24 17 00	 mov	 BYTE PTR _uParts$226311[esp+272], 0
  00a96	89 4c 24 18	 mov	 DWORD PTR tv4993[esp+272], ecx
  00a9a	8d 9b 00 00 00
	00		 npad	 6
$L229578:

; 293  : 				{
; 294  : 					CItemElem* pItemElem	= m_Inventory.GetEquip( uParts );

  00aa0	8b 95 98 0b 00
	00		 mov	 edx, DWORD PTR [ebp+2968]
  00aa6	85 d2		 test	 edx, edx
  00aa8	0f 84 90 00 00
	00		 je	 $L226313
  00aae	8b 85 9c 0b 00
	00		 mov	 eax, DWORD PTR [ebp+2972]
  00ab4	8b d8		 mov	 ebx, eax
  00ab6	2b da		 sub	 ebx, edx
  00ab8	3b cb		 cmp	 ecx, ebx
  00aba	0f 83 1b 01 00
	00		 jae	 $L228720
  00ac0	03 ca		 add	 ecx, edx
  00ac2	8b 95 94 0b 00
	00		 mov	 edx, DWORD PTR [ebp+2964]
  00ac8	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00acb	83 f8 ff	 cmp	 eax, -1
  00ace	74 6e		 je	 SHORT $L226313
  00ad0	8b 8d a0 0b 00
	00		 mov	 ecx, DWORD PTR [ebp+2976]
  00ad6	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00adc	03 c1		 add	 eax, ecx
  00ade	8b d8		 mov	 ebx, eax
  00ae0	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00ae3	85 c0		 test	 eax, eax
  00ae5	74 57		 je	 SHORT $L226313

; 295  : 					if( pItemElem )
; 296  : 					{
; 297  : 						uSize++;

  00ae7	8a 44 24 10	 mov	 al, BYTE PTR _uSize$226309[esp+272]
  00aeb	fe c0		 inc	 al

; 298  : 						ar << uParts;

  00aed	6a 01		 push	 1
  00aef	8b ce		 mov	 ecx, esi
  00af1	88 44 24 14	 mov	 BYTE PTR _uSize$226309[esp+276], al
  00af5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00afa	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00afd	8a 4c 24 17	 mov	 cl, BYTE PTR _uParts$226311[esp+272]
  00b01	88 08		 mov	 BYTE PTR [eax], cl
  00b03	ff 46 08	 inc	 DWORD PTR [esi+8]

; 299  : 						ar << (u_short)pItemElem->m_dwItemId;

  00b06	66 8b 53 0c	 mov	 dx, WORD PTR [ebx+12]
  00b0a	6a 02		 push	 2
  00b0c	8b ce		 mov	 ecx, esi
  00b0e	66 89 54 24 20	 mov	 WORD PTR $T228729[esp+276], dx
  00b13	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00b18	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00b1b	66 8b 4c 24 1c	 mov	 cx, WORD PTR $T228729[esp+272]
  00b20	66 89 08	 mov	 WORD PTR [eax], cx
  00b23	83 46 08 02	 add	 DWORD PTR [esi+8], 2

; 300  : 						ar << pItemElem->m_byFlag;

  00b27	8a 9b 82 00 00
	00		 mov	 bl, BYTE PTR [ebx+130]
  00b2d	6a 01		 push	 1
  00b2f	8b ce		 mov	 ecx, esi
  00b31	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00b36	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00b39	88 1a		 mov	 BYTE PTR [edx], bl
  00b3b	ff 46 08	 inc	 DWORD PTR [esi+8]
$L226313:
  00b3e	8a 44 24 17	 mov	 al, BYTE PTR _uParts$226311[esp+272]
  00b42	8b 4c 24 18	 mov	 ecx, DWORD PTR tv4993[esp+272]
  00b46	fe c0		 inc	 al
  00b48	41		 inc	 ecx
  00b49	3c 1f		 cmp	 al, 31			; 0000001fH
  00b4b	88 44 24 17	 mov	 BYTE PTR _uParts$226311[esp+272], al
  00b4f	89 4c 24 18	 mov	 DWORD PTR tv4993[esp+272], ecx
  00b53	0f 82 47 ff ff
	ff		 jb	 $L229578

; 301  : 					}
; 302  : 				}
; 303  : 				GETBLOCK( ar, pBlock, nBlockSize );

  00b59	8d 44 24 24	 lea	 eax, DWORD PTR _nBlockSize$226318[esp+272]
  00b5d	50		 push	 eax
  00b5e	8b ce		 mov	 ecx, esi
  00b60	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 304  : 				*(UNALIGNED u_char*)( pBlock + uOffset )	= uSize;

  00b65	8b 4c 24 20	 mov	 ecx, DWORD PTR _uOffset$226310[esp+272]
  00b69	8a 54 24 10	 mov	 dl, BYTE PTR _uSize$226309[esp+272]
  00b6d	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 305  : #if __VER >= 9	// __PET_0410
; 306  : 				DWORD dwPetId	= NULL_ID;
; 307  : #ifdef __PET_1024
; 308  : 				char* pszPetName	= "";
; 309  : #endif	// __PET_1024
; 310  : 				CItemElem* pItemElem	= GetPetItem();

  00b70	8b cd		 mov	 ecx, ebp
  00b72	83 cb ff	 or	 ebx, -1
  00b75	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _pszPetName$226322[esp+272], OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00b7d	e8 00 00 00 00	 call	 ?GetPetItem@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetPetItem

; 311  : 				if( pItemElem )

  00b82	85 c0		 test	 eax, eax
  00b84	89 44 24 20	 mov	 DWORD PTR _pItemElem$226323[esp+272], eax
  00b88	74 30		 je	 SHORT $L226324

; 312  : 				{
; 313  : 					dwPetId		= MAKELONG( (WORD)pItemElem->m_pPet->GetIndex(), (WORD)pItemElem->m_pPet->GetLevel() );

  00b8a	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00b90	8a 41 05	 mov	 al, BYTE PTR [ecx+5]
  00b93	88 44 24 10	 mov	 BYTE PTR $T228737[esp+272], al
  00b97	e8 00 00 00 00	 call	 ?GetIndex@CPet@@QAEKXZ	; CPet::GetIndex
  00b9c	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR $T228737[esp+272]

; 314  : #ifdef __PET_1024
; 315  : 					pszPetName	= const_cast<char*>( pItemElem->m_pPet->GetName() );

  00ba1	8b 54 24 20	 mov	 edx, DWORD PTR _pItemElem$226323[esp+272]
  00ba5	0f b7 d8	 movzx	 ebx, ax
  00ba8	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00bae	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00bb1	0b d9		 or	 ebx, ecx
  00bb3	83 c0 16	 add	 eax, 22			; 00000016H
  00bb6	89 44 24 18	 mov	 DWORD PTR _pszPetName$226322[esp+272], eax
$L226324:

; 316  : #endif	// __PET_1024
; 317  : 				}
; 318  : 				ar << dwPetId;

  00bba	57		 push	 edi
  00bbb	8b ce		 mov	 ecx, esi
  00bbd	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00bc2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00bc5	89 18		 mov	 DWORD PTR [eax], ebx
  00bc7	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 319  : #ifdef __PET_1024
; 320  : 				ar.WriteString( pszPetName );

  00bca	8b 4c 24 18	 mov	 ecx, DWORD PTR _pszPetName$226322[esp+272]
  00bce	51		 push	 ecx
  00bcf	8b ce		 mov	 ecx, esi
  00bd1	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 321  : #endif	// __PET_1024
; 322  : #endif	// __PET_0410
; 323  : 			}
; 324  : 		}
; 325  : 		else	// NPC

  00bd6	e9 1f 13 00 00	 jmp	 $L229530

; 293  : 				{
; 294  : 					CItemElem* pItemElem	= m_Inventory.GetEquip( uParts );

$L228720:
  00bdb	8b 95 98 0b 00
	00		 mov	 edx, DWORD PTR [ebp+2968]
  00be1	51		 push	 ecx
  00be2	2b c2		 sub	 eax, edx
  00be4	50		 push	 eax
  00be5	52		 push	 edx
  00be6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
  00beb	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  00bf0	83 c4 10	 add	 esp, 16			; 00000010H
  00bf3	e9 46 ff ff ff	 jmp	 $L226313
$L226241:

; 326  : 		{
; 327  : 			ar << (u_char)m_dwHairMesh << m_dwHairColor << (u_char)m_dwHeadMesh;

  00bf8	8a 9d 2c 06 00
	00		 mov	 bl, BYTE PTR [ebp+1580]
  00bfe	6a 01		 push	 1
  00c00	8b ce		 mov	 ecx, esi
  00c02	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c07	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00c0a	88 1a		 mov	 BYTE PTR [edx], bl
  00c0c	ff 46 08	 inc	 DWORD PTR [esi+8]
  00c0f	8b 9d 30 06 00
	00		 mov	 ebx, DWORD PTR [ebp+1584]
  00c15	57		 push	 edi
  00c16	8b ce		 mov	 ecx, esi
  00c18	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c1d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00c20	89 18		 mov	 DWORD PTR [eax], ebx
  00c22	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00c25	8a 9d 34 06 00
	00		 mov	 bl, BYTE PTR [ebp+1588]
  00c2b	6a 01		 push	 1
  00c2d	8b ce		 mov	 ecx, esi
  00c2f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c34	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00c37	88 19		 mov	 BYTE PTR [ecx], bl
  00c39	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 328  : 			ar.WriteString( m_szCharacterKey );

  00c3c	8d 95 4c 06 00
	00		 lea	 edx, DWORD PTR [ebp+1612]
  00c42	40		 inc	 eax
  00c43	52		 push	 edx
  00c44	8b ce		 mov	 ecx, esi
  00c46	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00c49	e8 00 00 00 00	 call	 ?WriteString@CAr@@QAEXPBD@Z ; CAr::WriteString

; 329  : 
; 330  : 			u_char uSize	= 0;
; 331  : 			u_long uOffset	= ar.GetOffset();

  00c4e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00c51	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00c54	2b d9		 sub	 ebx, ecx

; 332  : 			ar << uSize;

  00c56	6a 01		 push	 1
  00c58	8b ce		 mov	 ecx, esi
  00c5a	c6 44 24 1b 00	 mov	 BYTE PTR _uSize$226337[esp+276], 0
  00c5f	89 5c 24 28	 mov	 DWORD PTR _uOffset$226338[esp+276], ebx
  00c63	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00c68	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00c6b	c6 00 00	 mov	 BYTE PTR [eax], 0
  00c6e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00c71	42		 inc	 edx

; 333  : 			if( IsEquipableNPC() )

  00c72	8b cd		 mov	 ecx, ebp
  00c74	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00c77	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  00c7c	85 c0		 test	 eax, eax
  00c7e	0f 84 c3 00 00
	00		 je	 $L226344
  00c84	8b cd		 mov	 ecx, ebp
  00c86	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  00c8b	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  00c91	85 c9		 test	 ecx, ecx
  00c93	0f 8e ae 00 00
	00		 jle	 $L226344

; 334  : 			{
; 335  : 				CItemElem* pItemElem;
; 336  : 				for( u_char uParts = 0; uParts < MAX_HUMAN_PARTS; uParts++ )

  00c99	33 db		 xor	 ebx, ebx
  00c9b	c6 44 24 10 00	 mov	 BYTE PTR _uParts$226341[esp+272], 0
  00ca0	89 5c 24 18	 mov	 DWORD PTR tv5012[esp+272], ebx
  00ca4	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$L226342:

; 337  : 				{
; 338  : 					pItemElem	= m_Inventory.GetEquip( uParts );

  00cb0	8b 95 98 0b 00
	00		 mov	 edx, DWORD PTR [ebp+2968]
  00cb6	85 d2		 test	 edx, edx
  00cb8	8d 8d 90 0b 00
	00		 lea	 ecx, DWORD PTR [ebp+2960]
  00cbe	74 6c		 je	 SHORT $L226343
  00cc0	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00cc3	8b d8		 mov	 ebx, eax
  00cc5	2b da		 sub	 ebx, edx
  00cc7	8b d3		 mov	 edx, ebx
  00cc9	8b 5c 24 18	 mov	 ebx, DWORD PTR tv5012[esp+272]
  00ccd	3b da		 cmp	 ebx, edx
  00ccf	0f 83 06 01 00
	00		 jae	 $L228773
  00cd5	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00cd8	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
  00cdb	52		 push	 edx
  00cdc	e8 00 00 00 00	 call	 ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAt

; 339  : 					if( pItemElem )

  00ce1	85 c0		 test	 eax, eax
  00ce3	89 44 24 1c	 mov	 DWORD PTR _pItemElem$226340[esp+272], eax
  00ce7	74 43		 je	 SHORT $L226343

; 340  : 					{
; 341  : 						uSize++;

  00ce9	8a 44 24 17	 mov	 al, BYTE PTR _uSize$226337[esp+272]
  00ced	fe c0		 inc	 al

; 342  : 						ar << uParts;

  00cef	6a 01		 push	 1
  00cf1	8b ce		 mov	 ecx, esi
  00cf3	88 44 24 1b	 mov	 BYTE PTR _uSize$226337[esp+276], al
  00cf7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00cfc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00cff	8a 4c 24 10	 mov	 cl, BYTE PTR _uParts$226341[esp+272]
  00d03	88 08		 mov	 BYTE PTR [eax], cl
  00d05	ff 46 08	 inc	 DWORD PTR [esi+8]

; 343  : 						ar << (u_short)pItemElem->m_dwItemId;

  00d08	8b 54 24 1c	 mov	 edx, DWORD PTR _pItemElem$226340[esp+272]
  00d0c	66 8b 5a 0c	 mov	 bx, WORD PTR [edx+12]
  00d10	6a 02		 push	 2
  00d12	8b ce		 mov	 ecx, esi
  00d14	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00d19	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00d1c	66 89 18	 mov	 WORD PTR [eax], bx
  00d1f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00d22	8b 5c 24 18	 mov	 ebx, DWORD PTR tv5012[esp+272]
  00d26	83 c0 02	 add	 eax, 2
  00d29	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L226343:
  00d2c	8a 44 24 10	 mov	 al, BYTE PTR _uParts$226341[esp+272]
  00d30	fe c0		 inc	 al
  00d32	43		 inc	 ebx
  00d33	3c 1f		 cmp	 al, 31			; 0000001fH
  00d35	88 44 24 10	 mov	 BYTE PTR _uParts$226341[esp+272], al
  00d39	89 5c 24 18	 mov	 DWORD PTR tv5012[esp+272], ebx
  00d3d	0f 82 6d ff ff
	ff		 jb	 $L226342

; 334  : 			{
; 335  : 				CItemElem* pItemElem;
; 336  : 				for( u_char uParts = 0; uParts < MAX_HUMAN_PARTS; uParts++ )

  00d43	8b 5c 24 24	 mov	 ebx, DWORD PTR _uOffset$226338[esp+272]
$L226344:

; 344  : 					}
; 345  : 				}
; 346  : 			}
; 347  : 			GETBLOCK( ar, pBlock, nBlockSize );

  00d47	8d 8c 24 c8 00
	00 00		 lea	 ecx, DWORD PTR _nBlockSize$226347[esp+272]
  00d4e	51		 push	 ecx
  00d4f	8b ce		 mov	 ecx, esi
  00d51	e8 00 00 00 00	 call	 ?GetBuffer@CAr@@QAEPAEPAH@Z ; CAr::GetBuffer

; 348  : 			*(UNALIGNED u_char*)( pBlock + uOffset )	= uSize;

  00d56	8a 54 24 17	 mov	 dl, BYTE PTR _uSize$226337[esp+272]
  00d5a	88 14 18	 mov	 BYTE PTR [eax+ebx], dl

; 349  : 
; 350  : 
; 351  : 			ar << (u_char)m_bActiveAttack;

  00d5d	8a 9d 70 06 00
	00		 mov	 bl, BYTE PTR [ebp+1648]
  00d63	6a 01		 push	 1
  00d65	8b ce		 mov	 ecx, esi
  00d67	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00d6c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00d6f	88 18		 mov	 BYTE PTR [eax], bl
  00d71	ff 46 08	 inc	 DWORD PTR [esi+8]

; 352  : 			ar << (u_char)m_nMovePattern;

  00d74	8a 9d 64 16 00
	00		 mov	 bl, BYTE PTR [ebp+5732]
  00d7a	6a 01		 push	 1
  00d7c	8b ce		 mov	 ecx, esi
  00d7e	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00d83	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00d86	88 19		 mov	 BYTE PTR [ecx], bl
  00d88	ff 46 08	 inc	 DWORD PTR [esi+8]

; 353  : 			ar << (u_char)m_nMoveEvent;

  00d8b	8a 9d 68 16 00
	00		 mov	 bl, BYTE PTR [ebp+5736]
  00d91	6a 01		 push	 1
  00d93	8b ce		 mov	 ecx, esi
  00d95	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00d9a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00d9d	88 1a		 mov	 BYTE PTR [edx], bl
  00d9f	ff 46 08	 inc	 DWORD PTR [esi+8]

; 354  : 			ar << m_nMoveEventCnt;

  00da2	8b 9d 6c 16 00
	00		 mov	 ebx, DWORD PTR [ebp+5740]
  00da8	57		 push	 edi
  00da9	8b ce		 mov	 ecx, esi
  00dab	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00db0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00db3	89 18		 mov	 DWORD PTR [eax], ebx
  00db5	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 355  : #if __VER >= 9	//__AI_0509
; 356  : 			ar << m_fSpeedFactor;

  00db8	8b 8d 10 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1808]
  00dbe	89 4c 24 24	 mov	 DWORD PTR $T228808[esp+272], ecx
  00dc2	57		 push	 edi
  00dc3	8b ce		 mov	 ecx, esi
  00dc5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00dca	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00dcd	8b 44 24 24	 mov	 eax, DWORD PTR $T228808[esp+272]
  00dd1	89 02		 mov	 DWORD PTR [edx], eax
  00dd3	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 357  : #endif	// __AI_0509
; 358  : 		}
; 359  : #ifdef __BUFF_1107
; 360  : 		m_buffs.Serialize( ar );
; 361  : #else	// __BUFF_1107
; 362  : 		m_SkillState.Serialize( ar );
; 363  : #endif	// __BUFF_1107
; 364  : 	}
; 365  : 	else	// LOADING

  00dd6	e9 1f 11 00 00	 jmp	 $L229530

; 337  : 				{
; 338  : 					pItemElem	= m_Inventory.GetEquip( uParts );

$L228773:
  00ddb	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00dde	53		 push	 ebx
  00ddf	2b c1		 sub	 eax, ecx
  00de1	50		 push	 eax
  00de2	51		 push	 ecx
  00de3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
  00de8	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  00ded	83 c4 10	 add	 esp, 16			; 00000010H
  00df0	e9 37 ff ff ff	 jmp	 $L226343
$L226237:

; 366  : 	{
; 367  : 		m_dwMotion = 0;

  00df5	33 db		 xor	 ebx, ebx
  00df7	89 9d dc 02 00
	00		 mov	 DWORD PTR [ebp+732], ebx

; 368  : 
; 369  : 		u_short nMotion;
; 370  : 		ar >> nMotion;							// m_dwMotion

  00dfd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00e00	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00e03	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  00e06	3b ca		 cmp	 ecx, edx
  00e08	77 08		 ja	 SHORT $L228812
  00e0a	66 8b 00	 mov	 ax, WORD PTR [eax]
  00e0d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00e10	eb 05		 jmp	 SHORT $L228813
$L228812:
  00e12	33 c0		 xor	 eax, eax
  00e14	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228813:

; 371  : 
; 372  : 		#if defined(__WORLDSERVER) || defined(__CLIENT)
; 373  : 				m_dwMotion = (DWORD)nMotion;	// 성별도 정해지지 않는 상태에서는 SetMotion호출하지 않는다.

  00e17	0f b7 c8	 movzx	 ecx, ax
  00e1a	89 8d dc 02 00
	00		 mov	 DWORD PTR [ebp+732], ecx

; 374  : 		#else	// defined(__WORLDSERVER) || defined(__CLIENT)
; 375  : 			m_dwMotion = (DWORD)nMotion;
; 376  : 		#endif
; 377  : 
; 378  : 		m_bPlayer	=
; 379  : 		m_dwBelligerence	=
; 380  : 		m_idGuild	=
; 381  : 		m_idWar	=
; 382  : 		m_idparty	=
; 383  : 		m_idDuelParty	=
; 384  : 		m_nDuel		= 
; 385  : 		m_dwRideItemIdx		= 0;

  00e20	8d bd 28 07 00
	00		 lea	 edi, DWORD PTR [ebp+1832]

; 386  : 
; 387  : 		ClearEquipInfo();

  00e26	8b cd		 mov	 ecx, ebp
  00e28	89 9d 88 16 00
	00		 mov	 DWORD PTR [ebp+5768], ebx
  00e2e	89 9d 44 07 00
	00		 mov	 DWORD PTR [ebp+1860], ebx
  00e34	89 9d 4c 07 00
	00		 mov	 DWORD PTR [ebp+1868], ebx
  00e3a	89 9d 18 07 00
	00		 mov	 DWORD PTR [ebp+1816], ebx
  00e40	89 1f		 mov	 DWORD PTR [edi], ebx
  00e42	89 9d 1c 07 00
	00		 mov	 DWORD PTR [ebp+1820], ebx
  00e48	89 9d 6c 06 00
	00		 mov	 DWORD PTR [ebp+1644], ebx
  00e4e	89 9d 34 02 00
	00		 mov	 DWORD PTR [ebp+564], ebx
  00e54	e8 00 00 00 00	 call	 ?ClearEquipInfo@CMover@@QAEXXZ ; CMover::ClearEquipInfo

; 388  : 		
; 389  : 		ar >> (u_char&)m_bPlayer;

  00e59	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00e5c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00e5f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00e62	3b d1		 cmp	 edx, ecx
  00e64	77 0d		 ja	 SHORT $L228817
  00e66	8a 00		 mov	 al, BYTE PTR [eax]
  00e68	88 85 34 02 00
	00		 mov	 BYTE PTR [ebp+564], al
  00e6e	ff 46 08	 inc	 DWORD PTR [esi+8]
  00e71	eb 0d		 jmp	 SHORT $L228818
$L228817:
  00e73	c6 85 34 02 00
	00 00		 mov	 BYTE PTR [ebp+564], 0
  00e7a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00e7d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228818:

; 390  : 
; 391  : #ifdef __SKILL_0205
; 392  : 		SKILL	aJobSkill[MAX_SKILL_JOB];
; 393  : 		memcpy( aJobSkill, m_aJobSkill, sizeof(aJobSkill) );
; 394  : #endif	// __SKILL_0205
; 395  : 
; 396  : 		InitProp();

  00e80	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00e83	6a 01		 push	 1
  00e85	8b cd		 mov	 ecx, ebp
  00e87	ff 52 10	 call	 DWORD PTR [edx+16]

; 397  : 
; 398  : 		m_nHitPoint	= 0;

  00e8a	89 9d 00 06 00
	00		 mov	 DWORD PTR [ebp+1536], ebx

; 399  : 
; 400  : 		ar >> m_nHitPoint;

  00e90	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00e93	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00e96	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00e99	3b ca		 cmp	 ecx, edx
  00e9b	77 10		 ja	 SHORT $L228823
  00e9d	8b 10		 mov	 edx, DWORD PTR [eax]
  00e9f	89 95 00 06 00
	00		 mov	 DWORD PTR [ebp+1536], edx
  00ea5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00ea8	83 c0 04	 add	 eax, 4
  00eab	eb 09		 jmp	 SHORT $L229595
$L228823:
  00ead	89 9d 00 06 00
	00		 mov	 DWORD PTR [ebp+1536], ebx
  00eb3	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229595:

; 401  : 		DWORD dw1, dw2;
; 402  : 		ar >> dw1;

  00eb6	8b c8		 mov	 ecx, eax
  00eb8	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00ebb	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00ebe	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00ec1	3b d0		 cmp	 edx, eax
  00ec3	77 07		 ja	 SHORT $L228829
  00ec5	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00ec7	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00eca	eb 05		 jmp	 SHORT $L228830
$L228829:
  00ecc	33 db		 xor	 ebx, ebx
  00ece	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L228830:

; 403  : 		ar >> dw2;

  00ed1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00ed4	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00ed7	3b d0		 cmp	 edx, eax
  00ed9	77 07		 ja	 SHORT $L228834
  00edb	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00edd	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00ee0	eb 05		 jmp	 SHORT $L228835
$L228834:
  00ee2	33 c9		 xor	 ecx, ecx
  00ee4	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L228835:

; 404  : 		m_pActMover->ClearStateFlag();

  00ee7	8b 95 3c 02 00
	00		 mov	 edx, DWORD PTR [ebp+572]
  00eed	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 405  : 		m_pActMover->AddStateFlag( dw2 );

  00ef4	51		 push	 ecx
  00ef5	8b 8d 3c 02 00
	00		 mov	 ecx, DWORD PTR [ebp+572]
  00efb	e8 00 00 00 00	 call	 ?AddStateFlag@CAction@@QAEXK@Z ; CAction::AddStateFlag

; 406  : 		m_pActMover->__ForceSetState( dw1 );

  00f00	8b 85 3c 02 00
	00		 mov	 eax, DWORD PTR [ebp+572]
  00f06	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 407  : 		ar >> (u_char&)m_dwBelligerence;

  00f09	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00f0c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00f0f	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00f12	3b ca		 cmp	 ecx, edx
  00f14	77 0e		 ja	 SHORT $L228848
  00f16	8a 10		 mov	 dl, BYTE PTR [eax]
  00f18	88 95 6c 06 00
	00		 mov	 BYTE PTR [ebp+1644], dl
  00f1e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00f21	40		 inc	 eax
  00f22	eb 0a		 jmp	 SHORT $L229596
$L228848:
  00f24	c6 85 6c 06 00
	00 00		 mov	 BYTE PTR [ebp+1644], 0
  00f2b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229596:

; 408  : #if __VER >= 15 // __PETVIS
; 409  : 		ar >> m_dwMoverSfxId;

  00f2e	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00f31	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00f34	3b ca		 cmp	 ecx, edx
  00f36	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00f39	77 10		 ja	 SHORT $L228854
  00f3b	8b 10		 mov	 edx, DWORD PTR [eax]
  00f3d	89 95 90 11 00
	00		 mov	 DWORD PTR [ebp+4496], edx
  00f43	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00f46	83 c0 04	 add	 eax, 4
  00f49	eb 0d		 jmp	 SHORT $L229597
$L228854:
  00f4b	c7 85 90 11 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+4496], 0
  00f55	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229597:
  00f58	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 410  : #endif // __PETVIS
; 411  : 		if( m_bPlayer )	// PLAYER

  00f5b	8b 85 34 02 00
	00		 mov	 eax, DWORD PTR [ebp+564]
  00f61	33 db		 xor	 ebx, ebx
  00f63	3b c3		 cmp	 eax, ebx
  00f65	0f 84 85 0d 00
	00		 je	 $L226360

; 412  : 		{
; 413  : 			m_dwSkinSet		=
; 414  : 			m_dwHairMesh	=
; 415  : 			m_dwHeadMesh	=
; 416  : 			m_idPlayer	=
; 417  : 			m_nJob	=
; 418  : 			m_nStr	=
; 419  : 			m_nSta	=
; 420  : 			m_nDex	=
; 421  : 			m_nInt	=
; 422  : 			m_nLevel	=
; 423  : 			m_dwAuthorization	=
; 424  : #if __VER < 8 // __S8_PK
; 425  : 			m_nNumKill	=
; 426  : #endif // __VER < 8 // __S8_PK
; 427  : 									0;
; 428  : 
; 429  : 			BYTE bySex;
; 430  : 			ar.ReadString( m_szName, 32 );

  00f6b	6a 20		 push	 32			; 00000020H
  00f6d	8d 8d 90 16 00
	00		 lea	 ecx, DWORD PTR [ebp+5776]
  00f73	51		 push	 ecx
  00f74	8b ce		 mov	 ecx, esi
  00f76	89 9d 48 06 00
	00		 mov	 DWORD PTR [ebp+1608], ebx
  00f7c	89 9d e0 05 00
	00		 mov	 DWORD PTR [ebp+1504], ebx
  00f82	89 9d dc 05 00
	00		 mov	 DWORD PTR [ebp+1500], ebx
  00f88	89 9d d8 05 00
	00		 mov	 DWORD PTR [ebp+1496], ebx
  00f8e	89 9d d4 05 00
	00		 mov	 DWORD PTR [ebp+1492], ebx
  00f94	89 9d d0 05 00
	00		 mov	 DWORD PTR [ebp+1488], ebx
  00f9a	89 9d 44 06 00
	00		 mov	 DWORD PTR [ebp+1604], ebx
  00fa0	89 9d 38 02 00
	00		 mov	 DWORD PTR [ebp+568], ebx
  00fa6	89 9d 34 06 00
	00		 mov	 DWORD PTR [ebp+1588], ebx
  00fac	89 9d 2c 06 00
	00		 mov	 DWORD PTR [ebp+1580], ebx
  00fb2	89 9d 24 06 00
	00		 mov	 DWORD PTR [ebp+1572], ebx
  00fb8	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString

; 431  : 			ar >> bySex;

  00fbd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00fc0	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00fc3	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00fc6	3b ca		 cmp	 ecx, edx
  00fc8	77 07		 ja	 SHORT $L228860
  00fca	8a 00		 mov	 al, BYTE PTR [eax]
  00fcc	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00fcf	eb 05		 jmp	 SHORT $L228861
$L228860:
  00fd1	32 c0		 xor	 al, al
  00fd3	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228861:

; 432  : 			SetSex( bySex );

  00fd6	88 85 20 06 00
	00		 mov	 BYTE PTR [ebp+1568], al

; 433  : 			ar >> (u_char&)m_dwSkinSet;

  00fdc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00fdf	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00fe2	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00fe5	3b d1		 cmp	 edx, ecx
  00fe7	77 0d		 ja	 SHORT $L228869
  00fe9	8a 00		 mov	 al, BYTE PTR [eax]
  00feb	88 85 24 06 00
	00		 mov	 BYTE PTR [ebp+1572], al
  00ff1	ff 46 08	 inc	 DWORD PTR [esi+8]
  00ff4	eb 0d		 jmp	 SHORT $L228870
$L228869:
  00ff6	c6 85 24 06 00
	00 00		 mov	 BYTE PTR [ebp+1572], 0
  00ffd	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01000	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228870:

; 434  : 			ar >> (u_char&)m_dwHairMesh;

  01003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01006	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01009	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0100c	3b d1		 cmp	 edx, ecx
  0100e	77 0d		 ja	 SHORT $L228875
  01010	8a 00		 mov	 al, BYTE PTR [eax]
  01012	88 85 2c 06 00
	00		 mov	 BYTE PTR [ebp+1580], al
  01018	ff 46 08	 inc	 DWORD PTR [esi+8]
  0101b	eb 0d		 jmp	 SHORT $L228876
$L228875:
  0101d	c6 85 2c 06 00
	00 00		 mov	 BYTE PTR [ebp+1580], 0
  01024	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01027	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228876:

; 435  : 			ar >> m_dwHairColor;

  0102a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0102d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01030	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01033	3b d1		 cmp	 edx, ecx
  01035	77 0e		 ja	 SHORT $L228881
  01037	8b 00		 mov	 eax, DWORD PTR [eax]
  01039	89 85 30 06 00
	00		 mov	 DWORD PTR [ebp+1584], eax
  0103f	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  01043	eb 0c		 jmp	 SHORT $L228882
$L228881:
  01045	89 9d 30 06 00
	00		 mov	 DWORD PTR [ebp+1584], ebx
  0104b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0104e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228882:

; 436  : 			ar >> (u_char&)m_dwHeadMesh;

  01051	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01054	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01057	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0105a	3b d1		 cmp	 edx, ecx
  0105c	77 0d		 ja	 SHORT $L228887
  0105e	8a 00		 mov	 al, BYTE PTR [eax]
  01060	88 85 34 06 00
	00		 mov	 BYTE PTR [ebp+1588], al
  01066	ff 46 08	 inc	 DWORD PTR [esi+8]
  01069	eb 0d		 jmp	 SHORT $L228888
$L228887:
  0106b	c6 85 34 06 00
	00 00		 mov	 BYTE PTR [ebp+1588], 0
  01072	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01075	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228888:

; 437  : #	if defined (__WORLDSERVER) || defined(__CLIENT)
; 438  : 			SetHairColor( m_dwHairColor );

  01078	8b 95 30 06 00
	00		 mov	 edx, DWORD PTR [ebp+1584]
  0107e	52		 push	 edx
  0107f	8b cd		 mov	 ecx, ebp
  01081	e8 00 00 00 00	 call	 ?SetHairColor@CMover@@QAEXK@Z ; CMover::SetHairColor

; 439  : #	endif	// __WORLDSERVER	//__CLIENT
; 440  : 			ar >> m_idPlayer;

  01086	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01089	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0108c	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0108f	3b ca		 cmp	 ecx, edx
  01091	77 10		 ja	 SHORT $L228893
  01093	8b 10		 mov	 edx, DWORD PTR [eax]
  01095	89 95 38 02 00
	00		 mov	 DWORD PTR [ebp+568], edx
  0109b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0109e	83 c0 04	 add	 eax, 4
  010a1	eb 09		 jmp	 SHORT $L229598
$L228893:
  010a3	89 9d 38 02 00
	00		 mov	 DWORD PTR [ebp+568], ebx
  010a9	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229598:

; 441  : 			ar >> (u_char&)m_nJob;

  010ac	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  010af	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  010b2	3b ca		 cmp	 ecx, edx
  010b4	89 46 08	 mov	 DWORD PTR [esi+8], eax
  010b7	77 0e		 ja	 SHORT $L228899
  010b9	8a 10		 mov	 dl, BYTE PTR [eax]
  010bb	88 95 44 06 00
	00		 mov	 BYTE PTR [ebp+1604], dl
  010c1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  010c4	40		 inc	 eax
  010c5	eb 0a		 jmp	 SHORT $L229599
$L228899:
  010c7	c6 85 44 06 00
	00 00		 mov	 BYTE PTR [ebp+1604], 0
  010ce	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229599:

; 442  : 			ar >> (u_short&)m_nStr;

  010d1	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  010d4	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  010d7	3b ca		 cmp	 ecx, edx
  010d9	89 46 08	 mov	 DWORD PTR [esi+8], eax
  010dc	bb 02 00 00 00	 mov	 ebx, 2
  010e1	77 13		 ja	 SHORT $L228905
  010e3	66 8b 10	 mov	 dx, WORD PTR [eax]
  010e6	66 89 95 d0 05
	00 00		 mov	 WORD PTR [ebp+1488], dx
  010ed	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  010f0	03 c3		 add	 eax, ebx
  010f2	33 c9		 xor	 ecx, ecx
  010f4	eb 0c		 jmp	 SHORT $L229600
$L228905:
  010f6	33 c9		 xor	 ecx, ecx
  010f8	66 89 8d d0 05
	00 00		 mov	 WORD PTR [ebp+1488], cx
  010ff	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229600:

; 443  : 			ar >> (u_short&)m_nSta;

  01102	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  01105	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  01108	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0110b	77 0f		 ja	 SHORT $L228911
  0110d	66 8b 00	 mov	 ax, WORD PTR [eax]
  01110	66 89 85 d4 05
	00 00		 mov	 WORD PTR [ebp+1492], ax
  01117	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0111a	eb 0d		 jmp	 SHORT $L228912
$L228911:
  0111c	66 89 8d d4 05
	00 00		 mov	 WORD PTR [ebp+1492], cx
  01123	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01126	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228912:

; 444  : 			ar >> (u_short&)m_nDex;

  01129	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0112c	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0112f	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  01132	77 0f		 ja	 SHORT $L228917
  01134	66 8b 00	 mov	 ax, WORD PTR [eax]
  01137	66 89 85 d8 05
	00 00		 mov	 WORD PTR [ebp+1496], ax
  0113e	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  01141	eb 0d		 jmp	 SHORT $L228918
$L228917:
  01143	66 89 8d d8 05
	00 00		 mov	 WORD PTR [ebp+1496], cx
  0114a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0114d	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228918:

; 445  : 			ar >> (u_short&)m_nInt;

  01150	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01153	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  01156	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  01159	77 0f		 ja	 SHORT $L228923
  0115b	66 8b 00	 mov	 ax, WORD PTR [eax]
  0115e	66 89 85 dc 05
	00 00		 mov	 WORD PTR [ebp+1500], ax
  01165	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  01168	eb 0d		 jmp	 SHORT $L228924
$L228923:
  0116a	66 89 8d dc 05
	00 00		 mov	 WORD PTR [ebp+1500], cx
  01171	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01174	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228924:

; 446  : 			ar >> (u_short&)m_nLevel;

  01177	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0117a	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0117d	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  01180	77 0f		 ja	 SHORT $L228929
  01182	66 8b 00	 mov	 ax, WORD PTR [eax]
  01185	66 89 85 e0 05
	00 00		 mov	 WORD PTR [ebp+1504], ax
  0118c	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0118f	eb 0d		 jmp	 SHORT $L228930
$L228929:
  01191	66 89 8d e0 05
	00 00		 mov	 WORD PTR [ebp+1504], cx
  01198	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0119b	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228930:

; 447  : 			ar >> m_nFuel;

  0119e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  011a1	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  011a4	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  011a7	77 0e		 ja	 SHORT $L228941
  011a9	8b 00		 mov	 eax, DWORD PTR [eax]
  011ab	89 85 80 06 00
	00		 mov	 DWORD PTR [ebp+1664], eax
  011b1	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  011b5	eb 0c		 jmp	 SHORT $L228942
$L228941:
  011b7	89 8d 80 06 00
	00		 mov	 DWORD PTR [ebp+1664], ecx
  011bd	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  011c0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L228942:

; 448  : 			ar >> m_tmAccFuel;

  011c3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  011c6	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  011c9	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  011cc	77 0e		 ja	 SHORT $L228954
  011ce	8b 00		 mov	 eax, DWORD PTR [eax]
  011d0	89 85 84 06 00
	00		 mov	 DWORD PTR [ebp+1668], eax
  011d6	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  011da	eb 0c		 jmp	 SHORT $L228955
$L228954:
  011dc	89 8d 84 06 00
	00		 mov	 DWORD PTR [ebp+1668], ecx
  011e2	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  011e5	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228955:

; 449  : 
; 450  : 			u_char u1;
; 451  : 			ar >> u1;

  011e8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  011eb	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  011ee	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  011f1	3b ca		 cmp	 ecx, edx
  011f3	77 3a		 ja	 SHORT $L228961
  011f5	8a 00		 mov	 al, BYTE PTR [eax]

; 452  : 			if( u1 == 1 )

  011f7	3c 01		 cmp	 al, 1
  011f9	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  011fc	75 16		 jne	 SHORT $L226372

; 453  : 			{
; 454  : 				ar >> m_idGuild;

  011fe	8d 85 1c 07 00
	00		 lea	 eax, DWORD PTR [ebp+1820]
  01204	50		 push	 eax
  01205	8b ce		 mov	 ecx, esi
  01207	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>

; 455  : 				ar >> m_idWar;

  0120c	57		 push	 edi
  0120d	8b ce		 mov	 ecx, esi
  0120f	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>
$L226372:

; 456  : 			}
; 457  : 			ar >> m_idGuildCloak;

  01214	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01217	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0121a	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0121d	3b d1		 cmp	 edx, ecx
  0121f	77 13		 ja	 SHORT $L228966
  01221	8b 00		 mov	 eax, DWORD PTR [eax]
  01223	89 85 24 07 00
	00		 mov	 DWORD PTR [ebp+1828], eax
  01229	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  0122d	eb 15		 jmp	 SHORT $L228967

; 449  : 
; 450  : 			u_char u1;
; 451  : 			ar >> u1;

$L228961:
  0122f	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 452  : 			if( u1 == 1 )

  01232	eb e0		 jmp	 SHORT $L226372

; 456  : 			}
; 457  : 			ar >> m_idGuildCloak;

$L228966:
  01234	c7 85 24 07 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+1828], 0
  0123e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01241	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228967:

; 458  : 
; 459  : 			ar >> u1;

  01244	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01247	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0124a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0124d	3b ca		 cmp	 ecx, edx
  0124f	77 3f		 ja	 SHORT $L228972
  01251	8a 00		 mov	 al, BYTE PTR [eax]

; 460  : 			if( u1 == 1 )

  01253	3c 01		 cmp	 al, 1
  01255	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01258	75 1c		 jne	 SHORT $L226373

; 461  : 			{
; 462  : 				ar >> m_idparty;

  0125a	8d 85 18 07 00
	00		 lea	 eax, DWORD PTR [ebp+1816]
  01260	50		 push	 eax
  01261	8b ce		 mov	 ecx, esi
  01263	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>

; 463  : 				ar >> m_idDuelParty;

  01268	8d 85 4c 07 00
	00		 lea	 eax, DWORD PTR [ebp+1868]
  0126e	50		 push	 eax
  0126f	8b ce		 mov	 ecx, esi
  01271	e8 00 00 00 00	 call	 ??5CAr@@QAEAAV0@AAK@Z	; CAr::operator>>
$L226373:

; 464  : 			}
; 465  : 
; 466  : 			ar >> (char&)m_dwAuthorization;

  01276	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01279	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0127c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0127f	3b d1		 cmp	 edx, ecx
  01281	77 12		 ja	 SHORT $L228983
  01283	8a 00		 mov	 al, BYTE PTR [eax]
  01285	88 85 48 06 00
	00		 mov	 BYTE PTR [ebp+1608], al
  0128b	ff 46 08	 inc	 DWORD PTR [esi+8]
  0128e	eb 12		 jmp	 SHORT $L228984

; 458  : 
; 459  : 			ar >> u1;

$L228972:
  01290	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 460  : 			if( u1 == 1 )

  01293	eb e1		 jmp	 SHORT $L226373

; 464  : 			}
; 465  : 
; 466  : 			ar >> (char&)m_dwAuthorization;

$L228983:
  01295	c6 85 48 06 00
	00 00		 mov	 BYTE PTR [ebp+1608], 0
  0129c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0129f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228984:

; 467  : 			ar >> m_dwMode;

  012a2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  012a5	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  012a8	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  012ab	3b d1		 cmp	 edx, ecx
  012ad	bf 04 00 00 00	 mov	 edi, 4
  012b2	77 0d		 ja	 SHORT $L228990
  012b4	8b 00		 mov	 eax, DWORD PTR [eax]
  012b6	89 85 44 02 00
	00		 mov	 DWORD PTR [ebp+580], eax
  012bc	01 7e 08	 add	 DWORD PTR [esi+8], edi
  012bf	eb 10		 jmp	 SHORT $L228991
$L228990:
  012c1	c7 85 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+580], 0
  012cb	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  012ce	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228991:

; 468  : 			ar >> m_dwStateMode;

  012d1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  012d4	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  012d7	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  012da	3b d1		 cmp	 edx, ecx
  012dc	77 0d		 ja	 SHORT $L228996
  012de	8b 00		 mov	 eax, DWORD PTR [eax]
  012e0	89 85 4c 02 00
	00		 mov	 DWORD PTR [ebp+588], eax
  012e6	01 7e 08	 add	 DWORD PTR [esi+8], edi
  012e9	eb 10		 jmp	 SHORT $L228997
$L228996:
  012eb	c7 85 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+588], 0
  012f5	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  012f8	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L228997:

; 469  : #ifdef __WORLDSERVER
; 470  : 			OBJID dwItemTem;
; 471  : 			ar >> dwItemTem;

  012fb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  012fe	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01301	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  01304	3b c8		 cmp	 ecx, eax
  01306	77 05		 ja	 SHORT $L229002
  01308	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0130b	eb 03		 jmp	 SHORT $L229003
$L229002:
  0130d	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L229003:

; 472  : #else // __WORLDSERVER
; 473  : 			ar >> m_dwUseItemId;
; 474  : #endif // __WORLDSERVER
; 475  : #if __VER >= 8 // __S8_PK
; 476  : 			ar >> m_dwPKTime;

  01310	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01313	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  01316	3b d0		 cmp	 edx, eax
  01318	77 0f		 ja	 SHORT $L229007
  0131a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0131c	89 85 58 07 00
	00		 mov	 DWORD PTR [ebp+1880], eax
  01322	01 7e 08	 add	 DWORD PTR [esi+8], edi
  01325	33 c9		 xor	 ecx, ecx
  01327	eb 0e		 jmp	 SHORT $L229008
$L229007:
  01329	33 c9		 xor	 ecx, ecx
  0132b	89 8d 58 07 00
	00		 mov	 DWORD PTR [ebp+1880], ecx
  01331	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01334	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229008:

; 477  : 	#ifdef __WORLDSERVER
; 478  : 			if( m_dwPKTime > 0 )

  01337	39 8d 58 07 00
	00		 cmp	 DWORD PTR [ebp+1880], ecx
  0133d	76 0e		 jbe	 SHORT $L226376

; 479  : 				m_dwPKTime = GetTickCount() + m_dwPKTime;

  0133f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01345	01 85 58 07 00
	00		 add	 DWORD PTR [ebp+1880], eax
  0134b	33 c9		 xor	 ecx, ecx
$L226376:

; 480  : 	#endif // __WORLDSERVER
; 481  : 			ar >> m_nPKValue;

  0134d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01350	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01353	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  01356	77 0d		 ja	 SHORT $L229020
  01358	8b 00		 mov	 eax, DWORD PTR [eax]
  0135a	89 85 5c 07 00
	00		 mov	 DWORD PTR [ebp+1884], eax
  01360	01 7e 08	 add	 DWORD PTR [esi+8], edi
  01363	eb 0c		 jmp	 SHORT $L229021
$L229020:
  01365	89 8d 5c 07 00
	00		 mov	 DWORD PTR [ebp+1884], ecx
  0136b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0136e	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229021:

; 482  : 			ar >> m_dwPKPropensity;

  01371	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01374	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01377	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  0137a	77 0d		 ja	 SHORT $L229025
  0137c	8b 00		 mov	 eax, DWORD PTR [eax]
  0137e	89 85 60 07 00
	00		 mov	 DWORD PTR [ebp+1888], eax
  01384	01 7e 08	 add	 DWORD PTR [esi+8], edi
  01387	eb 0c		 jmp	 SHORT $L229027
$L229025:
  01389	89 8d 60 07 00
	00		 mov	 DWORD PTR [ebp+1888], ecx
  0138f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01392	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229027:

; 483  : 			ar >> m_dwPKExp;

  01395	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01398	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0139b	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  0139e	77 0d		 ja	 SHORT $L229031
  013a0	8b 00		 mov	 eax, DWORD PTR [eax]
  013a2	89 85 64 07 00
	00		 mov	 DWORD PTR [ebp+1892], eax
  013a8	01 7e 08	 add	 DWORD PTR [esi+8], edi
  013ab	eb 0c		 jmp	 SHORT $L229032
$L229031:
  013ad	89 8d 64 07 00
	00		 mov	 DWORD PTR [ebp+1892], ecx
  013b3	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  013b6	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229032:

; 484  : #else // __VER >= 8 // __S8_PK
; 485  : 			ar >> (u_short&)m_nNumKill;
; 486  : 			ar >> m_nSlaughter;
; 487  : #endif // __VER >= 8 // __S8_PK
; 488  : 			ar >> m_nFame;

  013b9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  013bc	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  013bf	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  013c2	77 0d		 ja	 SHORT $L229045
  013c4	8b 00		 mov	 eax, DWORD PTR [eax]
  013c6	89 85 50 07 00
	00		 mov	 DWORD PTR [ebp+1872], eax
  013cc	01 7e 08	 add	 DWORD PTR [esi+8], edi
  013cf	eb 0c		 jmp	 SHORT $L229046
$L229045:
  013d1	89 8d 50 07 00
	00		 mov	 DWORD PTR [ebp+1872], ecx
  013d7	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  013da	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229046:

; 489  : 			ar >> (u_char&)m_nDuel;

  013dd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  013e0	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  013e3	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  013e6	3b d1		 cmp	 edx, ecx
  013e8	77 0d		 ja	 SHORT $L229050
  013ea	8a 00		 mov	 al, BYTE PTR [eax]
  013ec	88 85 44 07 00
	00		 mov	 BYTE PTR [ebp+1860], al
  013f2	ff 46 08	 inc	 DWORD PTR [esi+8]
  013f5	eb 0d		 jmp	 SHORT $L229051
$L229050:
  013f7	c6 85 44 07 00
	00 00		 mov	 BYTE PTR [ebp+1860], 0
  013fe	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01401	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229051:

; 490  : #if __VER >= 13 // __HONORABLE_TITLE			// 달인
; 491  : 			int nTemp = -1;
; 492  : 			ar >> nTemp;

  01404	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01407	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0140a	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0140d	3b ca		 cmp	 ecx, edx
  0140f	77 07		 ja	 SHORT $L229063
  01411	8b 00		 mov	 eax, DWORD PTR [eax]
  01413	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01416	eb 05		 jmp	 SHORT $L229064
$L229063:
  01418	33 c0		 xor	 eax, eax
  0141a	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229064:

; 493  : #ifdef __CLIENT
; 494  : 			if(m_nHonor != nTemp)// 달인선택 
; 495  : 			{
; 496  : 				m_nHonor = nTemp;
; 497  : 				SetTitle(CTitleManager::Instance()->GetTitle(m_nHonor));
; 498  : 			}
; 499  : #else	// __CLIENT
; 500  : 			m_nHonor = nTemp;

  0141d	89 85 04 09 00
	00		 mov	 DWORD PTR [ebp+2308], eax
  01423	8d 85 0c 0c 00
	00		 lea	 eax, DWORD PTR [ebp+3084]
  01429	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  0142e	8b ff		 npad	 2
$L226380:

; 501  : #endif	// __CLIENT
; 502  : #endif	// __HONORABLE_TITLE			// 달인
; 503  : 			{
; 504  : 				for( int i = 0; i < MAX_HUMAN_PARTS; i ++ )
; 505  : 				{
; 506  : 					ar >> m_aEquipInfo[i].nOption;

  01430	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01433	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01436	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  01439	77 0c		 ja	 SHORT $L229075
  0143b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0143d	89 08		 mov	 DWORD PTR [eax], ecx
  0143f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01442	83 c1 04	 add	 ecx, 4
  01445	eb 09		 jmp	 SHORT $L229601
$L229075:
  01447	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0144d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L229601:
  01450	83 c0 0c	 add	 eax, 12			; 0000000cH
  01453	4a		 dec	 edx
  01454	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01457	75 d7		 jne	 SHORT $L226380

; 507  : 				}
; 508  : 			}
; 509  : 			ar >> m_nGuildCombatState;

  01459	8b c1		 mov	 eax, ecx
  0145b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0145e	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01461	3b d1		 cmp	 edx, ecx
  01463	77 0e		 ja	 SHORT $L229088
  01465	8b 00		 mov	 eax, DWORD PTR [eax]
  01467	89 85 98 0e 00
	00		 mov	 DWORD PTR [ebp+3736], eax
  0146d	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  01471	eb 10		 jmp	 SHORT $L229089
$L229088:
  01473	c7 85 98 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+3736], 0
  0147d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01480	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229089:

; 510  : 			
; 511  : 			for( int j = 0 ; j < SM_MAX ; ++j )

  01483	8d 85 04 03 00
	00		 lea	 eax, DWORD PTR [ebp+772]
  01489	ba 1a 00 00 00	 mov	 edx, 26			; 0000001aH
  0148e	8b ff		 npad	 2
$L226384:

; 512  : 				ar >> m_dwSMTime[j];

  01490	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01493	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  01496	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  01499	bf 04 00 00 00	 mov	 edi, 4
  0149e	77 0b		 ja	 SHORT $L229094
  014a0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  014a2	89 08		 mov	 DWORD PTR [eax], ecx
  014a4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  014a7	03 cf		 add	 ecx, edi
  014a9	eb 09		 jmp	 SHORT $L229602
$L229094:
  014ab	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  014b1	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L229602:
  014b4	03 c7		 add	 eax, edi
  014b6	4a		 dec	 edx
  014b7	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  014ba	75 d4		 jne	 SHORT $L226384

; 513  : 			// 장어구이, 신속의 두루마리 등의 예외처리는 m_nPlusMaxHitPoint등이 세트되고 OnApplySM() 실행한다.
; 514  : 
; 515  : 			if( CObj::GetMethod() == METHOD_NONE )

  014bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nMethod@CObj@@2HA ; CObj::m_nMethod
  014c1	33 c9		 xor	 ecx, ecx
  014c3	3b c1		 cmp	 eax, ecx
  014c5	0f 85 47 06 00
	00		 jne	 $L226387

; 516  : 			{
; 517  : 				m_nManaPoint	= 0;

  014cb	89 8d 04 06 00
	00		 mov	 DWORD PTR [ebp+1540], ecx

; 518  : 				m_nFatiguePoint	= 0;

  014d1	89 8d 08 06 00
	00		 mov	 DWORD PTR [ebp+1544], ecx

; 519  : #if __VER < 12 // __MOD_TUTORIAL
; 520  : 				m_nFlightLv		= 0;
; 521  : #endif	// __MOD_TUTORIAL
; 522  : 				m_nRemainGP		= 0;

  014d7	89 8d 0c 06 00
	00		 mov	 DWORD PTR [ebp+1548], ecx

; 523  : 
; 524  : 				ar >> (u_short&)m_nManaPoint;

  014dd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  014e0	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  014e3	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  014e6	77 0f		 ja	 SHORT $L229103
  014e8	66 8b 00	 mov	 ax, WORD PTR [eax]
  014eb	66 89 85 04 06
	00 00		 mov	 WORD PTR [ebp+1540], ax
  014f2	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  014f5	eb 0d		 jmp	 SHORT $L229104
$L229103:
  014f7	66 89 8d 04 06
	00 00		 mov	 WORD PTR [ebp+1540], cx
  014fe	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01501	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229104:

; 525  : 				ar >> (u_short&)m_nFatiguePoint;

  01504	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01507	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  0150a	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  0150d	77 0f		 ja	 SHORT $L229109
  0150f	66 8b 00	 mov	 ax, WORD PTR [eax]
  01512	66 89 85 08 06
	00 00		 mov	 WORD PTR [ebp+1544], ax
  01519	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0151c	eb 0d		 jmp	 SHORT $L229110
$L229109:
  0151e	66 89 8d 08 06
	00 00		 mov	 WORD PTR [ebp+1544], cx
  01525	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01528	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229110:

; 526  : #if __VER >= 12 // __MOD_TUTORIAL
; 527  : 				ar >> m_nTutorialState;

  0152b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0152e	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  01531	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01534	3b d3		 cmp	 edx, ebx
  01536	77 0d		 ja	 SHORT $L229122
  01538	8b 00		 mov	 eax, DWORD PTR [eax]
  0153a	89 85 f8 05 00
	00		 mov	 DWORD PTR [ebp+1528], eax
  01540	01 7e 08	 add	 DWORD PTR [esi+8], edi
  01543	eb 0c		 jmp	 SHORT $L229123
$L229122:
  01545	89 8d f8 05 00
	00		 mov	 DWORD PTR [ebp+1528], ecx
  0154b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0154e	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229123:

; 528  : #ifdef __CLIENT
; 529  : 				g_Option.m_nTutorialLv	= m_nTutorialState;
; 530  : #endif	// __CLIENT
; 531  : #else	// __MOD_TUTORIAL
; 532  : 				ar >> (u_short&)m_nFlightLv;
; 533  : #endif	// __MOD_TUTORIAL
; 534  : 				ar >> m_nFxp;

  01551	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01554	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  01557	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0155a	3b d3		 cmp	 edx, ebx
  0155c	77 0d		 ja	 SHORT $L229128
  0155e	8b 00		 mov	 eax, DWORD PTR [eax]
  01560	89 85 fc 05 00
	00		 mov	 DWORD PTR [ebp+1532], eax
  01566	01 7e 08	 add	 DWORD PTR [esi+8], edi
  01569	eb 0c		 jmp	 SHORT $L229129
$L229128:
  0156b	89 8d fc 05 00
	00		 mov	 DWORD PTR [ebp+1532], ecx
  01571	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01574	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229129:

; 535  : 
; 536  : 				ar >> dwGold;

  01577	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0157a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0157d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01580	33 db		 xor	 ebx, ebx
  01582	3b ca		 cmp	 ecx, edx
  01584	77 07		 ja	 SHORT $L229134
  01586	8b 00		 mov	 eax, DWORD PTR [eax]
  01588	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0158b	eb 05		 jmp	 SHORT $L229135
$L229134:
  0158d	33 c0		 xor	 eax, eax
  0158f	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229135:

; 537  : 				SetGold( dwGold );
; 538  : 
; 539  : 				ar >> m_nExp1;

  01592	6a 08		 push	 8
  01594	8d 95 e8 05 00
	00		 lea	 edx, DWORD PTR [ebp+1512]
  0159a	52		 push	 edx
  0159b	8b ce		 mov	 ecx, esi
  0159d	89 85 84 16 00
	00		 mov	 DWORD PTR [ebp+5764], eax
  015a3	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 540  : 				ar >> m_nSkillLevel;

  015a8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  015ab	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  015ae	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  015b1	3b ca		 cmp	 ecx, edx
  015b3	77 0f		 ja	 SHORT $L229153
  015b5	8b 10		 mov	 edx, DWORD PTR [eax]
  015b7	89 95 a0 11 00
	00		 mov	 DWORD PTR [ebp+4512], edx
  015bd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  015c0	03 c7		 add	 eax, edi
  015c2	eb 09		 jmp	 SHORT $L229603
$L229153:
  015c4	89 9d a0 11 00
	00		 mov	 DWORD PTR [ebp+4512], ebx
  015ca	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229603:

; 541  : 				ar >> m_nSkillPoint;

  015cd	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  015d0	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  015d3	3b ca		 cmp	 ecx, edx
  015d5	89 46 08	 mov	 DWORD PTR [esi+8], eax
  015d8	77 0f		 ja	 SHORT $L229166
  015da	8b 10		 mov	 edx, DWORD PTR [eax]
  015dc	89 95 a4 11 00
	00		 mov	 DWORD PTR [ebp+4516], edx
  015e2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  015e5	03 c7		 add	 eax, edi
  015e7	eb 09		 jmp	 SHORT $L229604
$L229166:
  015e9	89 9d a4 11 00
	00		 mov	 DWORD PTR [ebp+4516], ebx
  015ef	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229604:

; 542  : 				ar >> m_nDeathExp;

  015f2	6a 08		 push	 8
  015f4	8d 8d f0 05 00
	00		 lea	 ecx, DWORD PTR [ebp+1520]
  015fa	51		 push	 ecx
  015fb	8b ce		 mov	 ecx, esi
  015fd	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01600	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 543  : 				ar >> m_nDeathLevel; 

  01605	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01608	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0160b	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0160e	3b d1		 cmp	 edx, ecx
  01610	77 0d		 ja	 SHORT $L229175
  01612	8b 00		 mov	 eax, DWORD PTR [eax]
  01614	89 85 e4 05 00
	00		 mov	 DWORD PTR [ebp+1508], eax
  0161a	01 7e 08	 add	 DWORD PTR [esi+8], edi
  0161d	eb 0c		 jmp	 SHORT $L229176
$L229175:
  0161f	89 9d e4 05 00
	00		 mov	 DWORD PTR [ebp+1508], ebx
  01625	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01628	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229176:

; 544  : 				DWORD dwJobLv[MAX_JOB];		// 사용하지 않음 
; 545  : 				ar.Read( (void*)dwJobLv, sizeof(DWORD) * MAX_JOB );

  0162b	68 a0 00 00 00	 push	 160			; 000000a0H
  01630	8d 54 24 2c	 lea	 edx, DWORD PTR _dwJobLv$226390[esp+276]
  01634	52		 push	 edx
  01635	8b ce		 mov	 ecx, esi
  01637	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 546  : 				ar >> m_idMarkingWorld;

  0163c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0163f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01642	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01645	3b ca		 cmp	 ecx, edx
  01647	77 0f		 ja	 SHORT $L229181
  01649	8b 10		 mov	 edx, DWORD PTR [eax]
  0164b	89 95 a8 0e 00
	00		 mov	 DWORD PTR [ebp+3752], edx
  01651	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01654	03 c7		 add	 eax, edi
  01656	eb 09		 jmp	 SHORT $L229605
$L229181:
  01658	89 9d a8 0e 00
	00		 mov	 DWORD PTR [ebp+3752], ebx
  0165e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229605:

; 547  : 				ar >> m_vMarkingPos;

  01661	6a 0c		 push	 12			; 0000000cH
  01663	8d 8d 9c 0e 00
	00		 lea	 ecx, DWORD PTR [ebp+3740]
  01669	51		 push	 ecx
  0166a	8b ce		 mov	 ecx, esi
  0166c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0166f	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 548  : 				ar >> m_nQuestSize;

  01674	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01677	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0167a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0167d	3b d1		 cmp	 edx, ecx
  0167f	77 0d		 ja	 SHORT $L229190
  01681	8a 00		 mov	 al, BYTE PTR [eax]
  01683	88 85 7e 0e 00
	00		 mov	 BYTE PTR [ebp+3710], al
  01689	ff 46 08	 inc	 DWORD PTR [esi+8]
  0168c	eb 0d		 jmp	 SHORT $L229191
$L229190:
  0168e	c6 85 7e 0e 00
	00 00		 mov	 BYTE PTR [ebp+3710], 0
  01695	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01698	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229191:

; 549  : 				ar.Read( m_aQuest, sizeof(QUEST) * m_nQuestSize ); 

  0169b	0f b6 95 7e 0e
	00 00		 movzx	 edx, BYTE PTR [ebp+3710]
  016a2	8b 85 80 0e 00
	00		 mov	 eax, DWORD PTR [ebp+3712]
  016a8	6b d2 0e	 imul	 edx, 14			; 0000000eH
  016ab	52		 push	 edx
  016ac	50		 push	 eax
  016ad	8b ce		 mov	 ecx, esi
  016af	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 550  : 				ar >> m_nCompleteQuestSize;

  016b4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  016b7	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  016ba	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  016bd	3b ca		 cmp	 ecx, edx
  016bf	77 0e		 ja	 SHORT $L229196
  016c1	8a 10		 mov	 dl, BYTE PTR [eax]
  016c3	88 95 84 0e 00
	00		 mov	 BYTE PTR [ebp+3716], dl
  016c9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  016cc	40		 inc	 eax
  016cd	eb 0a		 jmp	 SHORT $L229606
$L229196:
  016cf	c6 85 84 0e 00
	00 00		 mov	 BYTE PTR [ebp+3716], 0
  016d6	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229606:
  016d9	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 551  : 				ar.Read( m_aCompleteQuest, sizeof(WORD) * m_nCompleteQuestSize ); 

  016dc	0f b6 8d 84 0e
	00 00		 movzx	 ecx, BYTE PTR [ebp+3716]
  016e3	8b 95 88 0e 00
	00		 mov	 edx, DWORD PTR [ebp+3720]
  016e9	d1 e1		 shl	 ecx, 1
  016eb	51		 push	 ecx
  016ec	52		 push	 edx
  016ed	8b ce		 mov	 ecx, esi
  016ef	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 552  : 
; 553  : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 554  : 				ar >> m_nCheckedQuestSize;

  016f4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  016f7	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  016fa	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  016fd	3b ca		 cmp	 ecx, edx
  016ff	77 0e		 ja	 SHORT $L229202
  01701	8a 10		 mov	 dl, BYTE PTR [eax]
  01703	88 95 8c 0e 00
	00		 mov	 BYTE PTR [ebp+3724], dl
  01709	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0170c	40		 inc	 eax
  0170d	eb 0a		 jmp	 SHORT $L229607
$L229202:
  0170f	c6 85 8c 0e 00
	00 00		 mov	 BYTE PTR [ebp+3724], 0
  01716	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229607:
  01719	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 555  : 				ar.Read( m_aCheckedQuest, sizeof(WORD) * m_nCheckedQuestSize );

  0171c	0f b6 8d 8c 0e
	00 00		 movzx	 ecx, BYTE PTR [ebp+3724]
  01723	8b 95 90 0e 00
	00		 mov	 edx, DWORD PTR [ebp+3728]
  01729	d1 e1		 shl	 ecx, 1
  0172b	51		 push	 ecx
  0172c	52		 push	 edx
  0172d	8b ce		 mov	 ecx, esi
  0172f	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 556  : #endif // __IMPROVE_QUEST_INTERFACE
; 557  : 
; 558  : 				ar >> m_idMurderer;

  01734	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01737	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0173a	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0173d	3b ca		 cmp	 ecx, edx
  0173f	77 0f		 ja	 SHORT $L229208
  01741	8b 10		 mov	 edx, DWORD PTR [eax]
  01743	89 95 54 07 00
	00		 mov	 DWORD PTR [ebp+1876], edx
  01749	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0174c	03 c7		 add	 eax, edi
  0174e	eb 09		 jmp	 SHORT $L229608
$L229208:
  01750	89 9d 54 07 00
	00		 mov	 DWORD PTR [ebp+1876], ebx
  01756	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229608:

; 559  : 				short n1, n2;		// n2는 사용하지 않는다.
; 560  : 				ar >> n1 >> n2;		

  01759	8b c8		 mov	 ecx, eax
  0175b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0175e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  01761	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  01764	3b d0		 cmp	 edx, eax
  01766	77 08		 ja	 SHORT $L229221
  01768	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0176b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0176e	eb 05		 jmp	 SHORT $L229222
$L229221:
  01770	33 c9		 xor	 ecx, ecx
  01772	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L229222:
  01775	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01778	83 c2 02	 add	 edx, 2
  0177b	3b d0		 cmp	 edx, eax
  0177d	77 05		 ja	 SHORT $L229233
  0177f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  01782	eb 03		 jmp	 SHORT $L229234
$L229233:
  01784	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L229234:

; 561  : 				m_nRemainGP	= n1;

  01787	0f bf c9	 movsx	 ecx, cx
  0178a	89 8d 0c 06 00
	00		 mov	 DWORD PTR [ebp+1548], ecx
  01790	8d 85 08 0c 00
	00		 lea	 eax, DWORD PTR [ebp+3080]
  01796	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  0179b	eb 03 8d 49 00	 npad	 5
$L226399:

; 562  : 				{
; 563  : 					for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 564  : 						ar >> m_aEquipInfo[i].dwId;

  017a0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  017a3	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  017a6	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  017a9	77 0b		 ja	 SHORT $L229238
  017ab	8b 09		 mov	 ecx, DWORD PTR [ecx]
  017ad	89 08		 mov	 DWORD PTR [eax], ecx
  017af	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  017b2	03 cf		 add	 ecx, edi
  017b4	eb 09		 jmp	 SHORT $L229609
$L229238:
  017b6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  017bc	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L229609:
  017bf	83 c0 0c	 add	 eax, 12			; 0000000cH
  017c2	4a		 dec	 edx
  017c3	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  017c6	75 d8		 jne	 SHORT $L226399

; 565  : 				}
; 566  : #ifdef __SKILL_0205
; 567  : 				ar.Read( (void*)m_aJobSkill, sizeof(SKILL) *  ( MAX_SKILL_JOB ) );
; 568  : 				for( int i = 0 ; i < MAX_SKILL_JOB; i++)
; 569  : 					m_abUpdateSkill[i]	= (BOOL)( memcmp( &m_aJobSkill[i], &aJobSkill[i], sizeof(SKILL) ) != 0 );
; 570  : #else	// __SKILL_0205
; 571  : 				ar.Read( (void*)m_aJobSkill, sizeof(SKILL) *  ( MAX_SKILL_JOB ) );

  017c8	68 98 01 00 00	 push	 408			; 00000198H
  017cd	8d 95 6c 03 00
	00		 lea	 edx, DWORD PTR [ebp+876]
  017d3	52		 push	 edx
  017d4	8b ce		 mov	 ecx, esi
  017d6	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 572  : #endif	// __SKILL_0205
; 573  : 
; 574  : 				m_nCheerPoint	= 0;

  017db	33 c9		 xor	 ecx, ecx
  017dd	89 8d 34 07 00
	00		 mov	 DWORD PTR [ebp+1844], ecx

; 575  : 				ar >> (BYTE&)m_nCheerPoint >> m_dwTickCheer;

  017e3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  017e6	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  017e9	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  017ec	3b d3		 cmp	 edx, ebx
  017ee	77 0d		 ja	 SHORT $L229244
  017f0	8a 00		 mov	 al, BYTE PTR [eax]
  017f2	88 85 34 07 00
	00		 mov	 BYTE PTR [ebp+1844], al
  017f8	ff 46 08	 inc	 DWORD PTR [esi+8]
  017fb	eb 0d		 jmp	 SHORT $L229245
$L229244:
  017fd	c6 85 34 07 00
	00 00		 mov	 BYTE PTR [ebp+1844], 0
  01804	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01807	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229245:
  0180a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0180d	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  01810	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01813	3b d3		 cmp	 edx, ebx
  01815	77 0d		 ja	 SHORT $L229250
  01817	8b 00		 mov	 eax, DWORD PTR [eax]
  01819	89 85 30 07 00
	00		 mov	 DWORD PTR [ebp+1840], eax
  0181f	01 7e 08	 add	 DWORD PTR [esi+8], edi
  01822	eb 0c		 jmp	 SHORT $L229251
$L229250:
  01824	89 8d 30 07 00
	00		 mov	 DWORD PTR [ebp+1840], ecx
  0182a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0182d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229251:

; 576  : 				m_dwTickCheer	+= GetTickCount();

  01830	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01836	01 85 30 07 00
	00		 add	 DWORD PTR [ebp+1840], eax

; 577  : 				ar >> m_nSlot;

  0183c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0183f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01842	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01845	3b d1		 cmp	 edx, ecx
  01847	77 0d		 ja	 SHORT $L229256
  01849	8a 00		 mov	 al, BYTE PTR [eax]
  0184b	88 85 20 0e 00
	00		 mov	 BYTE PTR [ebp+3616], al
  01851	ff 46 08	 inc	 DWORD PTR [esi+8]
  01854	eb 0d		 jmp	 SHORT $L229257
$L229256:
  01856	c6 85 20 0e 00
	00 00		 mov	 BYTE PTR [ebp+3616], 0
  0185d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01860	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229257:

; 578  : 				for( int k = 0 ; k < 3 ; ++k )

  01863	8d 85 34 0e 00
	00		 lea	 eax, DWORD PTR [ebp+3636]
  01869	ba 03 00 00 00	 mov	 edx, 3
  0186e	8b ff		 npad	 2
$L226406:

; 579  : 					ar >> m_dwGoldBank[k];

  01870	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01873	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  01876	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  01879	77 0b		 ja	 SHORT $L229262
  0187b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0187d	89 08		 mov	 DWORD PTR [eax], ecx
  0187f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01882	03 cf		 add	 ecx, edi
  01884	eb 09		 jmp	 SHORT $L229610
$L229262:
  01886	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0188c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L229610:
  0188f	03 c7		 add	 eax, edi
  01891	4a		 dec	 edx
  01892	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01895	75 d9		 jne	 SHORT $L226406

; 580  : 				for( k = 0 ; k < 3 ; ++k )

  01897	8d 85 28 0e 00
	00		 lea	 eax, DWORD PTR [ebp+3624]
  0189d	ba 03 00 00 00	 mov	 edx, 3
$L226409:

; 581  : 					ar >> m_idPlayerBank[k];

  018a2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  018a5	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  018a8	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  018ab	77 0b		 ja	 SHORT $L229268
  018ad	8b 09		 mov	 ecx, DWORD PTR [ecx]
  018af	89 08		 mov	 DWORD PTR [eax], ecx
  018b1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  018b4	03 cf		 add	 ecx, edi
  018b6	eb 09		 jmp	 SHORT $L229611
$L229268:
  018b8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  018be	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L229611:
  018c1	03 c7		 add	 eax, edi
  018c3	4a		 dec	 edx
  018c4	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  018c7	75 d9		 jne	 SHORT $L226409

; 582  : 
; 583  : 				ar >> m_nPlusMaxHitPoint;

  018c9	8b c1		 mov	 eax, ecx
  018cb	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  018ce	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  018d1	3b d1		 cmp	 edx, ecx
  018d3	77 0d		 ja	 SHORT $L229274
  018d5	8b 00		 mov	 eax, DWORD PTR [eax]
  018d7	89 85 b8 06 00
	00		 mov	 DWORD PTR [ebp+1720], eax
  018dd	01 7e 08	 add	 DWORD PTR [esi+8], edi
  018e0	eb 10		 jmp	 SHORT $L229275
$L229274:
  018e2	c7 85 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+1720], 0
  018ec	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  018ef	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229275:

; 584  : 				ar >> m_nAttackResistLeft;

  018f2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  018f5	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  018f8	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  018fb	3b d1		 cmp	 edx, ecx
  018fd	77 0d		 ja	 SHORT $L229280
  018ff	8a 00		 mov	 al, BYTE PTR [eax]
  01901	88 85 14 07 00
	00		 mov	 BYTE PTR [ebp+1812], al
  01907	ff 46 08	 inc	 DWORD PTR [esi+8]
  0190a	eb 0d		 jmp	 SHORT $L229281
$L229280:
  0190c	c6 85 14 07 00
	00 00		 mov	 BYTE PTR [ebp+1812], 0
  01913	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01916	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229281:

; 585  : 				ar >> m_nAttackResistRight;

  01919	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0191c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0191f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01922	3b d1		 cmp	 edx, ecx
  01924	77 0d		 ja	 SHORT $L229286
  01926	8a 00		 mov	 al, BYTE PTR [eax]
  01928	88 85 15 07 00
	00		 mov	 BYTE PTR [ebp+1813], al
  0192e	ff 46 08	 inc	 DWORD PTR [esi+8]
  01931	eb 0d		 jmp	 SHORT $L229287
$L229286:
  01933	c6 85 15 07 00
	00 00		 mov	 BYTE PTR [ebp+1813], 0
  0193a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0193d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229287:

; 586  : 				ar >> m_nDefenseResist;

  01940	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01943	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01946	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01949	3b d1		 cmp	 edx, ecx
  0194b	77 0d		 ja	 SHORT $L229292
  0194d	8a 00		 mov	 al, BYTE PTR [eax]
  0194f	88 85 16 07 00
	00		 mov	 BYTE PTR [ebp+1814], al
  01955	ff 46 08	 inc	 DWORD PTR [esi+8]
  01958	eb 0d		 jmp	 SHORT $L229293
$L229292:
  0195a	c6 85 16 07 00
	00 00		 mov	 BYTE PTR [ebp+1814], 0
  01961	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01964	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229293:

; 587  : #if __VER >= 8 //__CSC_VER8_5
; 588  : 				ar >> m_nAngelExp;

  01967	6a 08		 push	 8
  01969	8d 95 68 07 00
	00		 lea	 edx, DWORD PTR [ebp+1896]
  0196f	52		 push	 edx
  01970	8b ce		 mov	 ecx, esi
  01972	e8 00 00 00 00	 call	 ?Read@CAr@@QAEXPAXI@Z	; CAr::Read

; 589  : 				ar >> m_nAngelLevel;

  01977	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0197a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0197d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01980	3b ca		 cmp	 ecx, edx
  01982	77 0f		 ja	 SHORT $L229301
  01984	8b 10		 mov	 edx, DWORD PTR [eax]
  01986	89 95 70 07 00
	00		 mov	 DWORD PTR [ebp+1904], edx
  0198c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0198f	03 c7		 add	 eax, edi
  01991	eb 0d		 jmp	 SHORT $L229612
$L229301:
  01993	c7 85 70 07 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+1904], 0
  0199d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229612:

; 590  : #endif // __CSC_VER8_5
; 591  : 				m_Inventory.Serialize( ar );

  019a0	8d bd 90 0b 00
	00		 lea	 edi, DWORD PTR [ebp+2960]
  019a6	56		 push	 esi
  019a7	8b cf		 mov	 ecx, edi
  019a9	89 46 08	 mov	 DWORD PTR [esi+8], eax
  019ac	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  019b1	8d 9d 40 0e 00
	00		 lea	 ebx, DWORD PTR [ebp+3648]
  019b7	c7 44 24 1c 03
	00 00 00	 mov	 DWORD PTR tv937[esp+272], 3
  019bf	90		 npad	 1
$L226412:

; 592  : 				for( k = 0 ; k < 3 ; ++k )
; 593  : 					m_Bank[k].Serialize( ar );

  019c0	56		 push	 esi
  019c1	8b cb		 mov	 ecx, ebx
  019c3	e8 00 00 00 00	 call	 ?Serialize@?$CItemContainer@VCItemElem@@@@QAEXAAVCAr@@@Z ; CItemContainer<CItemElem>::Serialize
  019c8	8b 44 24 1c	 mov	 eax, DWORD PTR tv937[esp+272]
  019cc	83 c3 14	 add	 ebx, 20			; 00000014H
  019cf	48		 dec	 eax
  019d0	89 44 24 1c	 mov	 DWORD PTR tv937[esp+272], eax
  019d4	75 ea		 jne	 SHORT $L226412

; 594  : 
; 595  : 				CItemElem* pItemElem	= m_Inventory.GetEquip( PARTS_RIDE );

  019d6	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  019d9	85 c9		 test	 ecx, ecx
  019db	74 48		 je	 SHORT $L226416
  019dd	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  019e0	8b d0		 mov	 edx, eax
  019e2	2b d1		 sub	 edx, ecx
  019e4	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  019e7	77 17		 ja	 SHORT $L229321
  019e9	8b f9		 mov	 edi, ecx
  019eb	6a 0d		 push	 13			; 0000000dH
  019ed	2b c7		 sub	 eax, edi
  019ef	50		 push	 eax
  019f0	57		 push	 edi
  019f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
  019f6	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  019fb	83 c4 10	 add	 esp, 16			; 00000010H
  019fe	eb 25		 jmp	 SHORT $L226416
$L229321:
  01a00	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  01a03	8b 44 88 34	 mov	 eax, DWORD PTR [eax+ecx*4+52]
  01a07	83 f8 ff	 cmp	 eax, -1
  01a0a	74 19		 je	 SHORT $L226416
  01a0c	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  01a0f	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  01a15	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  01a19	03 c2		 add	 eax, edx
  01a1b	85 c9		 test	 ecx, ecx
  01a1d	74 06		 je	 SHORT $L226416

; 596  : 				if( pItemElem )
; 597  : 					m_dwRideItemIdx		= pItemElem->m_dwItemId;

  01a1f	89 8d 88 16 00
	00		 mov	 DWORD PTR [ebp+5768], ecx
$L226416:

; 598  : 
; 599  : #if __VER >= 9	// __PET_0410
; 600  : 				DWORD dwPetId;
; 601  : 				ar >> dwPetId;

  01a25	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01a28	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01a2b	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01a2e	3b ca		 cmp	 ecx, edx
  01a30	77 07		 ja	 SHORT $L229335
  01a32	8b 00		 mov	 eax, DWORD PTR [eax]
  01a34	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01a37	eb 05		 jmp	 SHORT $L229336
$L229335:
  01a39	33 c0		 xor	 eax, eax
  01a3b	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229336:

; 602  : 				SetPetId( dwPetId );
; 603  : 	#ifdef __PET_1024
; 604  : 	#ifdef __CLIENT
; 605  : 				CPet* pPet	= GetPet();
; 606  : 				if( pPet )
; 607  : 					m_pet.SetName( const_cast<char*>( pPet->GetName() ) );
; 608  : 	#endif	// __CLIENT
; 609  : 	#endif	// __PET_1024
; 610  : #endif	// __PET_0410
; 611  : #if __VER >= 11 // __SYS_POCKET
; 612  : 				m_Pocket.Serialize( ar );

  01a3e	56		 push	 esi
  01a3f	8d 8d f4 0b 00
	00		 lea	 ecx, DWORD PTR [ebp+3060]
  01a45	89 85 8c 11 00
	00		 mov	 DWORD PTR [ebp+4492], eax
  01a4b	e8 00 00 00 00	 call	 ?Serialize@CPocketController@@QAEXAAVCAr@@@Z ; CPocketController::Serialize

; 613  : #endif	// __SYS_POCKET
; 614  : 
; 615  : #ifdef __JEFF_9_20
; 616  : 				ar >> m_dwMute;

  01a50	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01a53	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01a56	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01a59	3b d1		 cmp	 edx, ecx
  01a5b	ba 04 00 00 00	 mov	 edx, 4
  01a60	77 0d		 ja	 SHORT $L229344
  01a62	8b 00		 mov	 eax, DWORD PTR [eax]
  01a64	89 85 68 0b 00
	00		 mov	 DWORD PTR [ebp+2920], eax
  01a6a	01 56 08	 add	 DWORD PTR [esi+8], edx
  01a6d	eb 10		 jmp	 SHORT $L229345
$L229344:
  01a6f	c7 85 68 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+2920], 0
  01a79	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01a7c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229345:

; 617  : #endif	// __JEFF_9_20
; 618  : #if __VER >= 13 // __HONORABLE_TITLE	// 달인
; 619  : #ifdef __CLIENT
; 620  : 				CTitleManager::Instance()->InitEarned();
; 621  : #endif	// __CLIENT
; 622  : 				for( int l = 0 ; l < MAX_HONOR_TITLE ; ++l )

  01a7f	8d 85 0c 09 00
	00		 lea	 eax, DWORD PTR [ebp+2316]
  01a85	bf 96 00 00 00	 mov	 edi, 150		; 00000096H
  01a8a	8d 9b 00 00 00
	00		 npad	 6
$L226419:

; 623  : 				{
; 624  : 					ar >> m_aHonorTitle[l];

  01a90	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01a93	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  01a96	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  01a99	77 0b		 ja	 SHORT $L229357
  01a9b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01a9d	89 08		 mov	 DWORD PTR [eax], ecx
  01a9f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01aa2	03 ca		 add	 ecx, edx
  01aa4	eb 09		 jmp	 SHORT $L229613
$L229357:
  01aa6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  01aac	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$L229613:
  01aaf	03 c2		 add	 eax, edx
  01ab1	4f		 dec	 edi
  01ab2	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01ab5	75 d9		 jne	 SHORT $L226419

; 625  : #ifdef __CLIENT
; 626  : 					int nNeed = CTitleManager::Instance()->GetNeedCount(l, -1);
; 627  : 					if(m_aHonorTitle[l] >= nNeed && nNeed > 0)
; 628  : 					{
; 629  : 						CTitleManager::Instance()->AddEarned(l);	
; 630  : 					}
; 631  : 					else
; 632  : 					{
; 633  : 						// 획득된 타이틀이지만 요구사항을 충족못하게 될때
; 634  : 						if(CTitleManager::Instance()->IsEarned(l))
; 635  : 						{
; 636  : 							CTitleManager::Instance()->RemoveEarned(l);
; 637  : 						}
; 638  : 					}
; 639  : #endif	// __CLIENT
; 640  : 				}
; 641  : #endif	// __HONORABLE_TITLE			// 달인
; 642  : #if __VER >= 15 // __CAMPUS
; 643  : 				ar >> m_idCampus;

  01ab7	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  01aba	8b c1		 mov	 eax, ecx
  01abc	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01abf	3b cf		 cmp	 ecx, edi
  01ac1	77 0d		 ja	 SHORT $L229363
  01ac3	8b 00		 mov	 eax, DWORD PTR [eax]
  01ac5	89 85 70 16 00
	00		 mov	 DWORD PTR [ebp+5744], eax
  01acb	01 56 08	 add	 DWORD PTR [esi+8], edx
  01ace	eb 10		 jmp	 SHORT $L229364
$L229363:
  01ad0	c7 85 70 16 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+5744], 0
  01ada	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01add	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229364:

; 644  : 				ar >> m_nCampusPoint;

  01ae0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01ae3	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  01ae6	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01ae9	3b cf		 cmp	 ecx, edi
  01aeb	77 10		 ja	 SHORT $L229376
  01aed	8b 00		 mov	 eax, DWORD PTR [eax]
  01aef	89 85 74 16 00
	00		 mov	 DWORD PTR [ebp+5748], eax
  01af5	01 56 08	 add	 DWORD PTR [esi+8], edx
  01af8	e9 68 01 00 00	 jmp	 $L229582
$L229376:
  01afd	c7 85 74 16 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+5748], 0
  01b07	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01b0a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 645  : #endif // __CAMPUS
; 646  : 			}
; 647  : 			else if( CObj::GetMethod() == METHOD_EXCLUDE_ITEM )

  01b0d	e9 53 01 00 00	 jmp	 $L229582
$L226387:
  01b12	83 f8 01	 cmp	 eax, 1
  01b15	0f 85 4a 01 00
	00		 jne	 $L229582

; 648  : 			{
; 649  : 			#if defined (__WORLDSERVER) || defined(__CLIENT)
; 650  : 				char szPVendor[MAX_VENDORNAME] = {0, };

  01b1b	c6 84 24 dc 00
	00 00 00	 mov	 BYTE PTR _szPVendor$226424[esp+272], 0
  01b23	33 c0		 xor	 eax, eax
  01b25	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  01b2a	8d bc 24 dd 00
	00 00		 lea	 edi, DWORD PTR _szPVendor$226424[esp+273]
  01b31	f3 ab		 rep stosd
  01b33	66 ab		 stosw

; 651  : 				ar.ReadString( szPVendor, MAX_VENDORNAME );

  01b35	6a 30		 push	 48			; 00000030H
  01b37	8d 94 24 e0 00
	00 00		 lea	 edx, DWORD PTR _szPVendor$226424[esp+276]
  01b3e	52		 push	 edx
  01b3f	8b ce		 mov	 ecx, esi
  01b41	aa		 stosb
  01b42	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString

; 652  : 				m_vtInfo.SetTitle( szPVendor );

  01b47	8d 84 24 dc 00
	00 00		 lea	 eax, DWORD PTR _szPVendor$226424[esp+272]
  01b4e	50		 push	 eax
  01b4f	8d 8d 7c 0d 00
	00		 lea	 ecx, DWORD PTR [ebp+3452]
  01b55	e8 00 00 00 00	 call	 ?SetTitle@CVTInfo@@QAEXPBD@Z ; CVTInfo::SetTitle
  01b5a	8d 85 08 0c 00
	00		 lea	 eax, DWORD PTR [ebp+3080]
  01b60	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
$L226426:

; 653  : 			#endif
; 654  : 				for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 655  : 					m_aEquipInfo[i].dwId	= NULL_ID;

  01b65	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  01b6b	83 c0 0c	 add	 eax, 12			; 0000000cH
  01b6e	49		 dec	 ecx
  01b6f	75 f4		 jne	 SHORT $L226426

; 656  : 
; 657  : 				u_char uSize;
; 658  : 				ar >> uSize;

  01b71	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01b74	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01b77	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01b7a	3b ca		 cmp	 ecx, edx
  01b7c	77 07		 ja	 SHORT $L229386
  01b7e	8a 00		 mov	 al, BYTE PTR [eax]
  01b80	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01b83	eb 05		 jmp	 SHORT $L229387
$L229386:
  01b85	32 c0		 xor	 al, al
  01b87	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229387:

; 659  : 				u_char uParts;
; 660  : 				u_short	u2;
; 661  : 				for( u_char uCount = 0; uCount < uSize; uCount++ )

  01b8a	84 c0		 test	 al, al
  01b8c	76 70		 jbe	 SHORT $L226435
  01b8e	0f b6 f8	 movzx	 edi, al
$L226433:

; 662  : 				{
; 663  : 					ar >> uParts;

  01b91	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01b94	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  01b97	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01b9a	3b d0		 cmp	 edx, eax
  01b9c	77 07		 ja	 SHORT $L229391
  01b9e	8a 19		 mov	 bl, BYTE PTR [ecx]
  01ba0	89 56 08	 mov	 DWORD PTR [esi+8], edx
  01ba3	eb 05		 jmp	 SHORT $L229392
$L229391:
  01ba5	32 db		 xor	 bl, bl
  01ba7	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L229392:

; 664  : 					ar >> u2;

  01baa	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01bad	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  01bb0	3b d0		 cmp	 edx, eax
  01bb2	77 08		 ja	 SHORT $L229396
  01bb4	66 8b 09	 mov	 cx, WORD PTR [ecx]
  01bb7	89 56 08	 mov	 DWORD PTR [esi+8], edx
  01bba	eb 05		 jmp	 SHORT $L229397
$L229396:
  01bbc	33 c9		 xor	 ecx, ecx
  01bbe	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L229397:

; 665  : 					m_aEquipInfo[uParts].dwId	= (DWORD)u2;

  01bc1	0f b6 c3	 movzx	 eax, bl
  01bc4	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  01bc7	0f b7 c9	 movzx	 ecx, cx
  01bca	8d 44 95 00	 lea	 eax, DWORD PTR [ebp+edx*4]
  01bce	89 88 08 0c 00
	00		 mov	 DWORD PTR [eax+3080], ecx

; 666  : 					ar >> m_aEquipInfo[uParts].byFlag;

  01bd4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01bd7	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  01bda	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01bdd	3b d3		 cmp	 edx, ebx
  01bdf	77 0d		 ja	 SHORT $L229401
  01be1	8a 09		 mov	 cl, BYTE PTR [ecx]
  01be3	88 88 10 0c 00
	00		 mov	 BYTE PTR [eax+3088], cl
  01be9	ff 46 08	 inc	 DWORD PTR [esi+8]
  01bec	eb 0d		 jmp	 SHORT $L226434
$L229401:
  01bee	c6 80 10 0c 00
	00 00		 mov	 BYTE PTR [eax+3088], 0
  01bf5	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01bf8	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L226434:

; 659  : 				u_char uParts;
; 660  : 				u_short	u2;
; 661  : 				for( u_char uCount = 0; uCount < uSize; uCount++ )

  01bfb	4f		 dec	 edi
  01bfc	75 93		 jne	 SHORT $L226433
$L226435:

; 667  : 				}
; 668  : 				if( m_aEquipInfo[PARTS_RIDE].dwId != NULL_ID )

  01bfe	8b 85 a4 0c 00
	00		 mov	 eax, DWORD PTR [ebp+3236]
  01c04	83 f8 ff	 cmp	 eax, -1
  01c07	74 06		 je	 SHORT $L226437

; 669  : 					m_dwRideItemIdx		= m_aEquipInfo[PARTS_RIDE].dwId;

  01c09	89 85 88 16 00
	00		 mov	 DWORD PTR [ebp+5768], eax
$L226437:

; 670  : #if __VER >= 9	// __PET_0410
; 671  : 				DWORD dwPetId;
; 672  : 				ar >> dwPetId;

  01c0f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01c12	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01c15	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01c18	3b ca		 cmp	 ecx, edx
  01c1a	77 07		 ja	 SHORT $L229407
  01c1c	8b 00		 mov	 eax, DWORD PTR [eax]
  01c1e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01c21	eb 05		 jmp	 SHORT $L229408
$L229407:
  01c23	33 c0		 xor	 eax, eax
  01c25	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229408:

; 673  : 				SetPetId( dwPetId );

  01c28	89 85 8c 11 00
	00		 mov	 DWORD PTR [ebp+4492], eax

; 674  : 	#ifdef __PET_1024
; 675  : 				char szPetName[MAX_PET_NAME]	= { 0,};

  01c2e	33 c0		 xor	 eax, eax
  01c30	89 84 24 c9 00
	00 00		 mov	 DWORD PTR _szPetName$226439[esp+273], eax
  01c37	89 84 24 cd 00
	00 00		 mov	 DWORD PTR _szPetName$226439[esp+277], eax

; 676  : 				ar.ReadString( szPetName, MAX_PET_NAME );

  01c3e	6a 11		 push	 17			; 00000011H
  01c40	8d 8c 24 cc 00
	00 00		 lea	 ecx, DWORD PTR _szPetName$226439[esp+276]
  01c47	89 84 24 d5 00
	00 00		 mov	 DWORD PTR _szPetName$226439[esp+285], eax
  01c4e	51		 push	 ecx
  01c4f	8b ce		 mov	 ecx, esi
  01c51	c6 84 24 d0 00
	00 00 00	 mov	 BYTE PTR _szPetName$226439[esp+280], 0
  01c59	89 84 24 dd 00
	00 00		 mov	 DWORD PTR _szPetName$226439[esp+293], eax
  01c60	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString
$L229582:

; 677  : 	#ifdef __CLIENT
; 678  : 				m_pet.SetName( szPetName );
; 679  : 	#endif	// __CLIENT
; 680  : 	#endif	// __PET_1024
; 681  : #endif	// __PET_0410
; 682  : 			}
; 683  : 
; 684  : 		#if defined(__WORLDSERVER) || defined(__CLIENT)
; 685  : 			if( m_dwRideItemIdx )

  01c65	8b 85 88 16 00
	00		 mov	 eax, DWORD PTR [ebp+5768]
  01c6b	85 c0		 test	 eax, eax
  01c6d	74 53		 je	 SHORT $L226442

; 686  : 			{
; 687  : 				ItemProp *pItemProp	= prj.GetItemProp( m_dwRideItemIdx );

  01c6f	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  01c75	7c 57		 jl	 SHORT $L229453
  01c77	3b c1		 cmp	 eax, ecx
  01c79	7d 53		 jge	 SHORT $L229453
  01c7b	73 45		 jae	 SHORT $L226442
  01c7d	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  01c83	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]

; 688  : 				if( pItemProp && m_nFuel == -1 )

  01c86	85 c0		 test	 eax, eax
  01c88	74 38		 je	 SHORT $L226442
  01c8a	83 bd 80 06 00
	00 ff		 cmp	 DWORD PTR [ebp+1664], -1
  01c91	75 2f		 jne	 SHORT $L226442

; 689  : 					m_nFuel		= (int)( pItemProp->dwFFuelReMax * 0.2f );

  01c93	8b 80 5c 02 00
	00		 mov	 eax, DWORD PTR [eax+604]
  01c99	85 c0		 test	 eax, eax
  01c9b	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv4960[esp+272], eax
  01ca2	db 84 24 c8 00
	00 00		 fild	 DWORD PTR tv4960[esp+272]
  01ca9	7d 06		 jge	 SHORT $L229587
  01cab	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L229587:
  01cb1	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e4ccccd
  01cb7	e8 00 00 00 00	 call	 __ftol2
  01cbc	89 85 80 06 00
	00		 mov	 DWORD PTR [ebp+1664], eax
$L226442:

; 690  : 			}
; 691  : 			OnApplySM();

  01cc2	8b cd		 mov	 ecx, ebp
  01cc4	e8 00 00 00 00	 call	 ?OnApplySM@CMover@@QAEXXZ ; CMover::OnApplySM

; 692  : 		#endif	// __WORLDSERVER	// __CLIENT
; 693  : 
; 694  : 		}
; 695  : 		else	// NPC

  01cc9	e9 2c 02 00 00	 jmp	 $L229530

; 686  : 			{
; 687  : 				ItemProp *pItemProp	= prj.GetItemProp( m_dwRideItemIdx );

$L229453:
  01cce	50		 push	 eax
  01ccf	51		 push	 ecx
  01cd0	6a 00		 push	 0
  01cd2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  01cd7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  01cdc	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  01ce1	83 c4 14	 add	 esp, 20			; 00000014H

; 690  : 			}
; 691  : 			OnApplySM();

  01ce4	8b cd		 mov	 ecx, ebp
  01ce6	e8 00 00 00 00	 call	 ?OnApplySM@CMover@@QAEXXZ ; CMover::OnApplySM

; 692  : 		#endif	// __WORLDSERVER	// __CLIENT
; 693  : 
; 694  : 		}
; 695  : 		else	// NPC

  01ceb	e9 0a 02 00 00	 jmp	 $L229530
$L226360:

; 696  : 		{
; 697  : 			ar >> (u_char&)m_dwHairMesh >> m_dwHairColor >> (u_char&)m_dwHeadMesh;

  01cf0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01cf3	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01cf6	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01cf9	3b ca		 cmp	 ecx, edx
  01cfb	77 0e		 ja	 SHORT $L229458
  01cfd	8a 10		 mov	 dl, BYTE PTR [eax]
  01cff	88 95 2c 06 00
	00		 mov	 BYTE PTR [ebp+1580], dl
  01d05	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01d08	40		 inc	 eax
  01d09	eb 0a		 jmp	 SHORT $L229614
$L229458:
  01d0b	c6 85 2c 06 00
	00 00		 mov	 BYTE PTR [ebp+1580], 0
  01d12	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229614:
  01d15	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01d18	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01d1b	3b ca		 cmp	 ecx, edx
  01d1d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d20	77 10		 ja	 SHORT $L229464
  01d22	8b 10		 mov	 edx, DWORD PTR [eax]
  01d24	89 95 30 06 00
	00		 mov	 DWORD PTR [ebp+1584], edx
  01d2a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01d2d	83 c0 04	 add	 eax, 4
  01d30	eb 09		 jmp	 SHORT $L229615
$L229464:
  01d32	89 9d 30 06 00
	00		 mov	 DWORD PTR [ebp+1584], ebx
  01d38	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229615:
  01d3b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01d3e	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01d41	3b ca		 cmp	 ecx, edx
  01d43	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d46	77 0e		 ja	 SHORT $L229470
  01d48	8a 10		 mov	 dl, BYTE PTR [eax]
  01d4a	88 95 34 06 00
	00		 mov	 BYTE PTR [ebp+1588], dl
  01d50	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01d53	40		 inc	 eax
  01d54	eb 0a		 jmp	 SHORT $L229616
$L229470:
  01d56	c6 85 34 06 00
	00 00		 mov	 BYTE PTR [ebp+1588], 0
  01d5d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
$L229616:

; 698  : 			ar.ReadString( m_szCharacterKey, 32 );

  01d60	6a 20		 push	 32			; 00000020H
  01d62	8d 8d 4c 06 00
	00		 lea	 ecx, DWORD PTR [ebp+1612]
  01d68	51		 push	 ecx
  01d69	8b ce		 mov	 ecx, esi
  01d6b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d6e	e8 00 00 00 00	 call	 ?ReadString@CAr@@QAEPADPADH@Z ; CAr::ReadString

; 699  : 		#if defined (__WORLDSERVER) || defined(__CLIENT)
; 700  : 			SetHairColor( m_dwHairColor );

  01d73	8b 95 30 06 00
	00		 mov	 edx, DWORD PTR [ebp+1584]
  01d79	52		 push	 edx
  01d7a	8b cd		 mov	 ecx, ebp
  01d7c	e8 00 00 00 00	 call	 ?SetHairColor@CMover@@QAEXK@Z ; CMover::SetHairColor
  01d81	8d 85 08 0c 00
	00		 lea	 eax, DWORD PTR [ebp+3080]
  01d87	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  01d8c	8d 64 24 00	 npad	 4
$L226448:

; 701  : 		#endif	// __WORLDSERVER	//__CLIENT
; 702  : 			{
; 703  : 				for( int i = 0; i < MAX_HUMAN_PARTS; i++ )
; 704  : 					m_aEquipInfo[i].dwId	= NULL_ID;

  01d90	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  01d96	83 c0 0c	 add	 eax, 12			; 0000000cH
  01d99	49		 dec	 ecx
  01d9a	75 f4		 jne	 SHORT $L226448

; 705  : 			}
; 706  : 			u_char uSize;
; 707  : 			ar >> uSize;

  01d9c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01d9f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01da2	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01da5	3b ca		 cmp	 ecx, edx
  01da7	77 07		 ja	 SHORT $L229476
  01da9	8a 18		 mov	 bl, BYTE PTR [eax]
  01dab	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  01dae	eb 05		 jmp	 SHORT $L229477
$L229476:
  01db0	32 db		 xor	 bl, bl
  01db2	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229477:

; 708  : 			if( IsEquipableNPC() )

  01db5	8b cd		 mov	 ecx, ebp
  01db7	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  01dbc	85 c0		 test	 eax, eax
  01dbe	74 63		 je	 SHORT $L226458
  01dc0	8b cd		 mov	 ecx, ebp
  01dc2	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  01dc7	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  01dcd	85 c9		 test	 ecx, ecx
  01dcf	7e 52		 jle	 SHORT $L226458

; 709  : 			{
; 710  : 				u_char uParts;
; 711  : 				u_short	u2;
; 712  : 				for( u_char uCount = 0; uCount < uSize; uCount++ )

  01dd1	84 db		 test	 bl, bl
  01dd3	76 4e		 jbe	 SHORT $L226458
  01dd5	0f b6 fb	 movzx	 edi, bl
  01dd8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L226456:

; 713  : 				{
; 714  : 					ar >> uParts;

  01de0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01de3	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  01de6	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01de9	3b d0		 cmp	 edx, eax
  01deb	77 07		 ja	 SHORT $L229488
  01ded	8a 19		 mov	 bl, BYTE PTR [ecx]
  01def	89 56 08	 mov	 DWORD PTR [esi+8], edx
  01df2	eb 05		 jmp	 SHORT $L229489
$L229488:
  01df4	32 db		 xor	 bl, bl
  01df6	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L229489:

; 715  : 					ar >> u2;

  01df9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01dfc	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  01dff	3b d0		 cmp	 edx, eax
  01e01	77 08		 ja	 SHORT $L229493
  01e03	66 8b 09	 mov	 cx, WORD PTR [ecx]
  01e06	89 56 08	 mov	 DWORD PTR [esi+8], edx
  01e09	eb 05		 jmp	 SHORT $L229494
$L229493:
  01e0b	33 c9		 xor	 ecx, ecx
  01e0d	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L229494:
  01e10	4f		 dec	 edi

; 716  : 					m_aEquipInfo[uParts].dwId	= (DWORD)u2;

  01e11	0f b6 c3	 movzx	 eax, bl
  01e14	0f b7 c9	 movzx	 ecx, cx
  01e17	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  01e1a	89 8c 95 08 0c
	00 00		 mov	 DWORD PTR [ebp+edx*4+3080], ecx
  01e21	75 bd		 jne	 SHORT $L226456
$L226458:

; 717  : 					/*
; 718  : #ifdef __PERF_0229
; 719  : 					if( GetIndex() == 11 || GetIndex() == 12 )
; 720  : 					{
; 721  : 						int nAttr	= 0; //xRandom( 0,  5 );
; 722  : 						int nAttrLevel	= 0;
; 723  : 						//if( nAttr > 0 )
; 724  : 						//	nAttrLevel= xRandom( 8, 10 );
; 725  : 						int nLevel	= 0;
; 726  : 						//if( nAttr < 3 )
; 727  : 								nLevel	= xRandom( 9, 10 );
; 728  : 						int nOption	= nLevel;
; 729  : 						nOption	|= ( nAttrLevel << 24 );
; 730  : 						nOption	|= (nAttr << 16 );
; 731  : 						m_aEquipInfo[uParts].nOption	= nOption;
; 732  : 					}
; 733  : #endif	// __PERF_0229
; 734  : 					*/
; 735  : 				}
; 736  : 			}
; 737  : 
; 738  : 			m_bActiveAttack	=
; 739  : 			m_nMovePattern	=
; 740  : 			m_nMoveEvent	=
; 741  : 									0;

  01e23	33 c9		 xor	 ecx, ecx
  01e25	89 8d 68 16 00
	00		 mov	 DWORD PTR [ebp+5736], ecx
  01e2b	89 8d 64 16 00
	00		 mov	 DWORD PTR [ebp+5732], ecx
  01e31	89 8d 70 06 00
	00		 mov	 DWORD PTR [ebp+1648], ecx

; 742  : 
; 743  : 			ar >> (u_char&)m_bActiveAttack;

  01e37	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01e3a	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  01e3d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01e40	3b d7		 cmp	 edx, edi
  01e42	77 0d		 ja	 SHORT $L229498
  01e44	8a 00		 mov	 al, BYTE PTR [eax]
  01e46	88 85 70 06 00
	00		 mov	 BYTE PTR [ebp+1648], al
  01e4c	ff 46 08	 inc	 DWORD PTR [esi+8]
  01e4f	eb 0d		 jmp	 SHORT $L229499
$L229498:
  01e51	c6 85 70 06 00
	00 00		 mov	 BYTE PTR [ebp+1648], 0
  01e58	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01e5b	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229499:

; 744  : 			ar >> (u_char&)m_nMovePattern;

  01e5e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01e61	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  01e64	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01e67	3b d7		 cmp	 edx, edi
  01e69	77 0d		 ja	 SHORT $L229504
  01e6b	8a 00		 mov	 al, BYTE PTR [eax]
  01e6d	88 85 64 16 00
	00		 mov	 BYTE PTR [ebp+5732], al
  01e73	ff 46 08	 inc	 DWORD PTR [esi+8]
  01e76	eb 0d		 jmp	 SHORT $L229505
$L229504:
  01e78	c6 85 64 16 00
	00 00		 mov	 BYTE PTR [ebp+5732], 0
  01e7f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01e82	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229505:

; 745  : 			ar >> (u_char&)m_nMoveEvent;

  01e85	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01e88	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  01e8b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01e8e	3b d7		 cmp	 edx, edi
  01e90	77 0d		 ja	 SHORT $L229510
  01e92	8a 00		 mov	 al, BYTE PTR [eax]
  01e94	88 85 68 16 00
	00		 mov	 BYTE PTR [ebp+5736], al
  01e9a	ff 46 08	 inc	 DWORD PTR [esi+8]
  01e9d	eb 0d		 jmp	 SHORT $L229511
$L229510:
  01e9f	c6 85 68 16 00
	00 00		 mov	 BYTE PTR [ebp+5736], 0
  01ea6	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01ea9	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229511:

; 746  : 			ar >> m_nMoveEventCnt;

  01eac	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01eaf	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  01eb2	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01eb5	3b d7		 cmp	 edx, edi
  01eb7	77 0e		 ja	 SHORT $L229522
  01eb9	8b 00		 mov	 eax, DWORD PTR [eax]
  01ebb	89 85 6c 16 00
	00		 mov	 DWORD PTR [ebp+5740], eax
  01ec1	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  01ec5	eb 0c		 jmp	 SHORT $L229523
$L229522:
  01ec7	89 8d 6c 16 00
	00		 mov	 DWORD PTR [ebp+5740], ecx
  01ecd	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01ed0	89 56 08	 mov	 DWORD PTR [esi+8], edx
$L229523:

; 747  : 		#ifdef __CLIENT
; 748  : 			if( *m_szCharacterKey )
; 749  : 			{
; 750  : 				LPCHARACTER pCharacter	= prj.GetCharacter( m_szCharacterKey );
; 751  : 				if( pCharacter )
; 752  : 				{
; 753  : 					_tcscpy( m_szName, pCharacter->m_strName );
; 754  : 					AllocShopInventory( pCharacter );
; 755  : 				}
; 756  : 			}
; 757  : 		#endif	// __CLIENT
; 758  : #if __VER >= 9	//__AI_0509
; 759  : 			ar >> m_fSpeedFactor;

  01ed3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01ed6	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  01ed9	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01edc	3b d7		 cmp	 edx, edi
  01ede	77 0e		 ja	 SHORT $L229529
  01ee0	8b 00		 mov	 eax, DWORD PTR [eax]
  01ee2	89 85 10 07 00
	00		 mov	 DWORD PTR [ebp+1808], eax
  01ee8	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  01eec	eb 0c		 jmp	 SHORT $L229530
$L229529:
  01eee	89 8d 10 07 00
	00		 mov	 DWORD PTR [ebp+1808], ecx
  01ef4	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01ef7	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$L229530:

; 760  : #endif	// __AI_0509
; 761  : 		}
; 762  : 
; 763  : #ifdef __BUFF_1107
; 764  : 		m_buffs.Serialize( ar );

  01efa	8d 8d f0 02 00
	00		 lea	 ecx, DWORD PTR [ebp+752]
  01f00	56		 push	 esi
  01f01	e8 00 00 00 00	 call	 ?Serialize@CBuffMgr@@QAEXAAVCAr@@@Z ; CBuffMgr::Serialize

; 765  : #else	// __BUFF_1107
; 766  : 		m_SkillState.Serialize( ar );
; 767  : #endif	// __BUFF_1107
; 768  : 
; 769  : 	#ifdef __CLIENT
; 770  : 		InitInterpolation();
; 771  : 	#endif	// __CLIENT
; 772  : 
; 773  : 	} // LOADING
; 774  : 
; 775  : #ifdef __CLIENT	
; 776  : 	m_fDestScale = GetScale().x;
; 777  : 	if( m_fDestScale > 10.0f )
; 778  : 	{
; 779  : 		LPCTSTR szErr = Error( "SerializeOpt:%f %s", m_fDestScale, GetName() );
; 780  : 		ADDERRORMSG( szErr );
; 781  : 	}
; 782  : #endif
; 783  : }

  01f06	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  01f0d	5f		 pop	 edi
  01f0e	5e		 pop	 esi
  01f0f	5d		 pop	 ebp
  01f10	5b		 pop	 ebx
  01f11	33 cc		 xor	 ecx, esp
  01f13	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01f18	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  01f1e	c2 04 00	 ret	 4
?Serialize@CMover@@UAEXAAVCAr@@@Z ENDP			; CMover::Serialize
_TEXT	ENDS
END
