; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\eveschool.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ILPKKCFD@GUILDCOMBAT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01ELNMCGJD@W?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BBHEADKN@GUILDBANK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PKCFHHL@?5?5?9?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDOEFPGE@GUILDCOMBAT_NOT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@MCMLJPCC@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@COFMEPEI@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@KEJMOH@GuildCombatResultRanking?$CI?$CJ?5?9?5pJo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IBCONAGB@GUILDCOMBAT_CHIP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CENMBALP@GUILDCOMBAT_CHIP_POST?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NDLDHKAP@flaris?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCJEOMMC@Mada_Guildcombatshop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FDHBDNOH@AUTO_OPEN_IDC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@NCAENAAF@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$MA?Z?$LF?$LP?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@GBPJBNHC@CGuildCombat?3?3LoadScript?$CI?$CJ?5Day?5E@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@JHIMENAO@CGuildCombat?3?3LoadScript?$CI?$CJ?5Time?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NLHJIAGP@JOINPENYA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KEADDOJF@GUILDLEVEL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNHLKBCP@MINJOINGUILDSIZE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIPAHFNN@MAXJOINGUILDSIZE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CIKALLAC@MAXPLAYERLIFE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JALGJDBE@MAXWARPLAYER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LDPPOPGC@MAXMAPTIME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@OKCODEAA@MAXJOINMEMBERSIZE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@IIOAOPHP@MAXGUILDPERCENT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@CBMJGLHF@MAXPLAYERPERCENT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAJOIMN@REQUESTCANCLEPERCENT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@OALCKFDK@NOTREQUESTPERCENT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIJMOIBC@ITEMPENYA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFBBGIIM@MAX_GCSIENDITEM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JGNDNFBG@GCSENDITEM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@LMCCKBLL@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$LO?F?$MA?L?E@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DANIOFHI@OPEN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FKFIKHIO@MAINTENANCE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HBLEMPNJ@WAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NNMKOINI@ALLMSG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CAFLFMC@GUILDMSG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OHOLIPGE@JOINMSG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CGGHBCGE@WORLDMSG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MMKHEPHK@STATE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NMCCOMCF@WARSTATE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DBNKAKHO@WAIT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EK@GINEPMCL@template?5?$DMclass?5T?$DO?5BOOL?5CItemCon@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?IsMaster@CGuild@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_SCHOOL_ENTRY@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CEveSchool@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__JOINPLAYER@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__GCSENDITEM@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__GCGETPOINT@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__GCPLAYERPOINT@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChild@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChild@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChildE@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChildE@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRecvHandle@CDPSock@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__MINIGAME_PACKET@@QAE@GHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MINIGMAME_PRIZE_LIST@CRainbowRaceMng@@QAE@KHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerId2CampusId@CCampusMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CEveSchool@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Ready@CEveSchool@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Start@CEveSchool@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Start2@CEveSchool@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Report@CEveSchool@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?End@CEveSchool@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadPos@CEveSchool@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPos@CEveSchool@@QAE?AUD3DXVECTOR3@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInstance@CEveSchool@@SAPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0CGuildCombat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCGuildCombat@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGuildCombat@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatClear@CGuildCombat@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G__GuildCombatMember@CGuildCombat@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1__GuildCombatMember@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatGameClear@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddvecGCGetPoint@CGuildCombat@@QAEXKKKKHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddvecGCPlayerPoint@CGuildCombat@@QAEXKHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectPlayerClear@CGuildCombat@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?JoinGuildCombat@CGuildCombat@@QAEXKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__GuildCombatMember@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OutGuildCombat@CGuildCombat@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSelectPlayer@CGuildCombat@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSelectPlayer@CGuildCombat@@QAEXKAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?JoinWar@CGuildCombat@@QAEXPAVCUser@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?JoinObserver@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatRequest@CGuildCombat@@QAEXPAVCUser@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatCancel@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UserOutGuildCombatResult@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatResult@CGuildCombat@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatResultRanking@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatCloseTeleport@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNpc@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatOpen@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRequestRanking@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDefender@CGuildCombat@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefender@CGuildCombat@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPrizePenya@CGuildCombat@@QAE_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRequstPenya@CGuildCombat@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextGuildCobmatTime@CGuildCombat@@QAE?AVCTime@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSelectMap@CGuildCombat@@QAEXPAVCUser@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GuildCombatEnter@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMaintenance@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEnter@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGuildCombatStart@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGuildCombatClose@CGuildCombat@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGuildCombatCloseWait@CGuildCombat@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRequestWarGuild@CGuildCombat@@QAEHKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSelectPlayer@CGuildCombat@@QAEHPAVCUser@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Process@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessJoinWar@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCommand@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadScript@CGuildCombat@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendGCLog@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendJoinMsg@CGuildCombat@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendGuildCombatEnterTime@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPlayerChange@CGuildCombat@@QAEXPAVCUser@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPoint@CGuildCombat@@QAEXPAVCUser@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E3
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E4
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAEAAPAVCCtrl@@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKH@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXABQAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAU__GCSENDITEM@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXABU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXABU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAU_PlayerData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAU_PlayerData@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEXABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAPAVCMiniGameBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampusMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampusMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuild@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compare@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBKPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKH@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCGETPOINT@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@V312@ABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV34@IABV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCSENDITEM@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE@V?$allocator@U__SECRETROOM_MONSTER@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@V312@ABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuild@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEAAU__GCSENDITEM@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEAAPAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringCompare@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKH@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCGETPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEPAU__GCGETPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCPLAYERPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEPAU__GCPLAYERPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXPAPAU__GuildCombatMember@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEXPAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEPAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXPAU__GCSENDITEM@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEPAU__GCSENDITEM@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEPAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSock@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSock@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSockE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSockE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildHouseBase@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXViterator@12@IABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuild@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEABU__GCSENDITEM@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEABUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEABQAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKH@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKH@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuild@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__SECRETROOM_MONSTER@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKU_Friend@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKK@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAEPAF1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$make_pair@KPAVCGuildHouseBase@@@std@@YA?AU?$pair@KPAVCGuildHouseBase@@@0@KPAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0KPAVCGuildHouseBase@@@?$pair@$$CBKPAVCGuildHouseBase@@@std@@QAE@ABU?$pair@KPAVCGuildHouseBase@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CFixedArray@UtagWORLD@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UtagWORLD@@@@QAEPAUtagWORLD@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$make_pair@KH@std@@YA?AU?$pair@KH@0@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0KH@?$pair@$$CBKH@std@@QAE@ABU?$pair@KH@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU__REQUESTGUILD@CGuildCombat@@@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAU__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAKK@std@@YAXPAK0ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPAU__JOINPLAYER@CGuildCombat@@@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAPAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0ABQAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAU__JOINPLAYER@CGuildCombat@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@IPAPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU__GCGETPOINT@CGuildCombat@@@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAU__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__GCGETPOINT@CGuildCombat@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU__GCPLAYERPOINT@CGuildCombat@@@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAU__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPAU__GuildCombatMember@CGuildCombat@@@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAPAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0ABQAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAU__GuildCombatMember@CGuildCombat@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@IPAPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU__GCSENDITEM@CGuildCombat@@@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAU__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__GCSENDITEM@CGuildCombat@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__REQUESTGUILD@CGuildCombat@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEGUILD@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__SECRETROOM_MONSTER@@@std@@YAPAU__SECRETROOM_MONSTER@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU__JOINPLAYER@CGuildCombat@@@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAU__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__JOINPLAYER@CGuildCombat@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CFixedArray@UtagWORLD@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCGuildHouseBase@@@std@@QAE@ABKABQAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KH@std@@QAE@ABKABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAUItemProp@@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCGETPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCPLAYERPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U__GuildCombatMember@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__GuildCombatMember@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCSENDITEM@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__GCRESULTVALUEGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__GCRESULTVALUEPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SECRETROOM_MONSTER@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAKIK@std@@YAXPAKIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__GCGETPOINT@CGuildCombat@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__GCSENDITEM@CGuildCombat@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SECRETROOM_MONSTER@@@std@@YAXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__JOINPLAYER@CGuildCombat@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CFixedArray@UtagWORLD@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTimeOut@CTimer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetYear@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMonth@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDay@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??NCTimeSpan@ATL@@QBE_NV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHour@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMinute@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSecond@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDayOfWeek@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPartyId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUserByID@CProject@@QAEPAVCMover@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xRandom@@YAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetText@CProject@@QAEPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTimer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTimer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCTimer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CGuildCombat@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?sEveSchool@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4V2@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?$S1@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4IA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?SetMode@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRegionAttr@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNotMode@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_EXT_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMapChildE@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMapChild@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBuffer2@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __P$[esp-4]
  00004	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogty
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?IsMaster@CGuild@@QAEHK@Z			; CGuild::IsMaster
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\guild.h
;	COMDAT ?IsMaster@CGuild@@QAEHK@Z
_TEXT	SEGMENT
_idPlayer$ = 8						; size = 4
?IsMaster@CGuild@@QAEHK@Z PROC NEAR			; CGuild::IsMaster, COMDAT
; _this$ = ecx

; 309  : 	BOOL	IsMaster( u_long idPlayer )	{	return( m_idMaster == idPlayer );	}

  00000	8b 49 44	 mov	 ecx, DWORD PTR [ecx+68]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR _idPlayer$[esp-4]
  00007	33 c0		 xor	 eax, eax
  00009	3b ca		 cmp	 ecx, edx
  0000b	0f 94 c0	 sete	 al
  0000e	c2 04 00	 ret	 4
?IsMaster@CGuild@@QAEHK@Z ENDP				; CGuild::IsMaster
_TEXT	ENDS
PUBLIC	??0_SCHOOL_ENTRY@@QAE@XZ			; _SCHOOL_ENTRY::_SCHOOL_ENTRY
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.h
;	COMDAT ??0_SCHOOL_ENTRY@@QAE@XZ
_TEXT	SEGMENT
??0_SCHOOL_ENTRY@@QAE@XZ PROC NEAR			; _SCHOOL_ENTRY::_SCHOOL_ENTRY, COMDAT
; _this$ = ecx

; 21   : 	_SCHOOL_ENTRY()

  00000	8b c1		 mov	 eax, ecx

; 22   : 		{	
; 23   : 			id	= 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 24   : 			*lpName	= '\0';

  00006	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 25   : 			nSurvivor	= 0;

  00009	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 26   : 			nSize	= 0;

  0000c	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 27   : 			nLevel = 0;

  0000f	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 28   : 			nDead	= 0;

  00012	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 29   : 		};

  00015	c3		 ret	 0
??0_SCHOOL_ENTRY@@QAE@XZ ENDP				; _SCHOOL_ENTRY::_SCHOOL_ENTRY
_TEXT	ENDS
PUBLIC	??1CEveSchool@@QAE@XZ				; CEveSchool::~CEveSchool
; Function compile flags: /Ogty
;	COMDAT ??1CEveSchool@@QAE@XZ
_TEXT	SEGMENT
??1CEveSchool@@QAE@XZ PROC NEAR				; CEveSchool::~CEveSchool, COMDAT
; _this$ = ecx

; 44   : 	~CEveSchool()	{}

  00000	c3		 ret	 0
??1CEveSchool@@QAE@XZ ENDP				; CEveSchool::~CEveSchool
_TEXT	ENDS
PUBLIC	??0__JOINPLAYER@CGuildCombat@@QAE@XZ		; CGuildCombat::__JOINPLAYER::__JOINPLAYER
; Function compile flags: /Ogty
;	COMDAT ??0__JOINPLAYER@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT
??0__JOINPLAYER@CGuildCombat@@QAE@XZ PROC NEAR		; CGuildCombat::__JOINPLAYER::__JOINPLAYER, COMDAT
; _this$ = ecx

; 91   : 		__JOINPLAYER()

  00000	8b c1		 mov	 eax, ecx

; 92   : 		{
; 93   : 			uidPlayer	= 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 94   : 			nlife	= 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 95   : 			nPoint	= 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 96   : 			uKillidGuild	= 0;

  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 97   : 			nMap	= 0;

  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 98   : 			dwTelTime	= 0;

  00012	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 99   : 		}

  00015	c3		 ret	 0
??0__JOINPLAYER@CGuildCombat@@QAE@XZ ENDP		; CGuildCombat::__JOINPLAYER::__JOINPLAYER
_TEXT	ENDS
PUBLIC	??0__GCSENDITEM@CGuildCombat@@QAE@XZ		; CGuildCombat::__GCSENDITEM::__GCSENDITEM
; Function compile flags: /Ogty
;	COMDAT ??0__GCSENDITEM@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT
??0__GCSENDITEM@CGuildCombat@@QAE@XZ PROC NEAR		; CGuildCombat::__GCSENDITEM::__GCSENDITEM, COMDAT
; _this$ = ecx

; 106  : 		__GCSENDITEM()

  00000	8b c1		 mov	 eax, ecx

; 107  : 		{
; 108  : 			nWinCount = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 109  : 			dwItemId = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 110  : 			nItemNum = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 111  : 		}

  0000c	c3		 ret	 0
??0__GCSENDITEM@CGuildCombat@@QAE@XZ ENDP		; CGuildCombat::__GCSENDITEM::__GCSENDITEM
_TEXT	ENDS
PUBLIC	??0__GCGETPOINT@CGuildCombat@@QAE@XZ		; CGuildCombat::__GCGETPOINT::__GCGETPOINT
; Function compile flags: /Ogty
;	COMDAT ??0__GCGETPOINT@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT
??0__GCGETPOINT@CGuildCombat@@QAE@XZ PROC NEAR		; CGuildCombat::__GCGETPOINT::__GCGETPOINT, COMDAT
; _this$ = ecx

; 187  : 		__GCGETPOINT()

  00000	8b c1		 mov	 eax, ecx

; 188  : 		{
; 189  : 			uidGuildAttack = uidGuildDefence = uidPlayerAttack = uidPlayerDefence = nPoint = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00007	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 190  : 			bKillDiffernceGuild = bMaster = bDefender = bLastLife = FALSE;

  00012	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00015	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00018	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0001b	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 191  : 		}

  0001e	c3		 ret	 0
??0__GCGETPOINT@CGuildCombat@@QAE@XZ ENDP		; CGuildCombat::__GCGETPOINT::__GCGETPOINT
_TEXT	ENDS
PUBLIC	??0__GCPLAYERPOINT@CGuildCombat@@QAE@XZ		; CGuildCombat::__GCPLAYERPOINT::__GCPLAYERPOINT
; Function compile flags: /Ogty
;	COMDAT ??0__GCPLAYERPOINT@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT
??0__GCPLAYERPOINT@CGuildCombat@@QAE@XZ PROC NEAR	; CGuildCombat::__GCPLAYERPOINT::__GCPLAYERPOINT, COMDAT
; _this$ = ecx

; 199  : 		__GCPLAYERPOINT()

  00000	8b c1		 mov	 eax, ecx

; 200  : 		{
; 201  : 			uidPlayer = nJob = nPoint = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 202  : 		}

  0000c	c3		 ret	 0
??0__GCPLAYERPOINT@CGuildCombat@@QAE@XZ ENDP		; CGuildCombat::__GCPLAYERPOINT::__GCPLAYERPOINT
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__InterlockedExchange@8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_szACP$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax

; 102  : 	UINT nACP = 0;

  0000f	33 f6		 xor	 esi, esi

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  00017	6a 07		 push	 7
  00019	8d 4c 24 08	 lea	 ecx, DWORD PTR _szACP$[esp+20]
  0001d	51		 push	 ecx
  0001e	68 04 10 00 00	 push	 4100			; 00001004H
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  0002a	85 c0		 test	 eax, eax
  0002c	74 27		 je	 SHORT $L281731

; 111  : 	{
; 112  : 		char* pch = szACP;
; 113  : 		while (*pch != '\0')

  0002e	8a 44 24 04	 mov	 al, BYTE PTR _szACP$[esp+16]
  00032	84 c0		 test	 al, al
  00034	8d 4c 24 04	 lea	 ecx, DWORD PTR _szACP$[esp+16]
  00038	74 1b		 je	 SHORT $L281731
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L38556:

; 114  : 		{
; 115  : 			nACP *= 10;
; 116  : 			nACP += *pch++ - '0';

  00040	0f be c0	 movsx	 eax, al
  00043	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  00046	41		 inc	 ecx
  00047	8d 74 50 d0	 lea	 esi, DWORD PTR [eax+edx*2-48]
  0004b	8a 01		 mov	 al, BYTE PTR [ecx]
  0004d	84 c0		 test	 al, al
  0004f	75 ef		 jne	 SHORT $L38556

; 117  : 		}
; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  00051	85 f6		 test	 esi, esi
  00053	75 16		 jne	 SHORT $L281732
$L281731:

; 121  : 		nACP = ::GetACP();

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  0005b	5e		 pop	 esi

; 122  : 
; 123  : 	return nACP;
; 124  : }

  0005c	8b 4c 24 08	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+12]
  00060	33 cc		 xor	 ecx, esp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	c3		 ret	 0
$L281732:
  0006b	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16]
  0006f	8b c6		 mov	 eax, esi
  00071	5e		 pop	 esi
  00072	33 cc		 xor	 ecx, esp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 128  : 	return( CP_THREAD_ACP );

  00000	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00005	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_ver$ = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 94 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+152], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );
; 139  : 	::GetVersionEx( &ver );

  00014	8d 04 24	 lea	 eax, DWORD PTR _ver$[esp+152]
  00017	50		 push	 eax
  00018	c7 44 24 04 94
	00 00 00	 mov	 DWORD PTR _ver$[esp+156], 148 ; 00000094H
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00026	83 7c 24 10 02	 cmp	 DWORD PTR _ver$[esp+168], 2
  0002b	75 0c		 jne	 SHORT $L38566
  0002d	83 7c 24 04 05	 cmp	 DWORD PTR _ver$[esp+156], 5

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  00032	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal
  00037	73 05		 jae	 SHORT $L38567
$L38566:

; 144  : 	}
; 145  : 	else
; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L38567:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00050	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  00057	33 cc		 xor	 ecx, esp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00064	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 158  : 	return( g_pfnGetThreadACP() );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L39168

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L281755:
$L39168:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L281756:
$L281754:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
EXTRN	__imp__LockResource@4:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_hResource$ = 12					; size = 4
_id$ = 16						; size = 4
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z PROC NEAR ; ATL::_AtlGetStringResourceImage, COMDAT

; 239  : {

  00000	53		 push	 ebx

; 240  : 	const ATLSTRINGRESOURCEIMAGE* pImage;
; 241  : 	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
; 242  : 	ULONG nResourceSize;
; 243  : 	HGLOBAL hGlobal;
; 244  : 	UINT iIndex;
; 245  : 
; 246  : 	hGlobal = ::LoadResource( hInstance, hResource );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _hInstance$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR _hResource$[esp+4]
  0000a	57		 push	 edi
  0000b	53		 push	 ebx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8

; 247  : 	if( hGlobal == NULL )

  00012	85 c0		 test	 eax, eax
  00014	75 03		 jne	 SHORT $L39522
  00016	5f		 pop	 edi
  00017	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  00018	c3		 ret	 0
$L39522:
  00019	56		 push	 esi

; 248  : 	{
; 249  : 		return( NULL );
; 250  : 	}
; 251  : 
; 252  : 	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );

  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  00021	8b f0		 mov	 esi, eax

; 253  : 	if( pImage == NULL )

  00023	85 f6		 test	 esi, esi
  00025	75 06		 jne	 SHORT $L39524
$L281762:
  00027	5e		 pop	 esi
  00028	5f		 pop	 edi

; 254  : 	{
; 255  : 		return( NULL );

  00029	33 c0		 xor	 eax, eax
  0002b	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  0002c	c3		 ret	 0
$L39524:

; 256  : 	}
; 257  : 
; 258  : 	nResourceSize = ::SizeofResource( hInstance, hResource );

  0002d	57		 push	 edi
  0002e	53		 push	 ebx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8

; 259  : 	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);
; 260  : 	iIndex = id&0x000f;

  00035	8b 4c 24 18	 mov	 ecx, DWORD PTR _id$[esp+8]
  00039	03 c6		 add	 eax, esi
  0003b	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 261  : 
; 262  : 	while( (iIndex > 0) && (pImage < pImageEnd) )

  0003e	76 0e		 jbe	 SHORT $L39528
$L39527:
  00040	3b f0		 cmp	 esi, eax
  00042	73 e3		 jae	 SHORT $L281762

; 263  : 	{
; 264  : 		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));
; 265  : 		iIndex--;

  00044	49		 dec	 ecx
  00045	0f b7 16	 movzx	 edx, WORD PTR [esi]
  00048	8d 74 56 02	 lea	 esi, DWORD PTR [esi+edx*2+2]
  0004c	75 f2		 jne	 SHORT $L39527
$L39528:

; 266  : 	}
; 267  : 	if( pImage >= pImageEnd )

  0004e	3b f0		 cmp	 esi, eax

; 268  : 	{
; 269  : 		return( NULL );

  00050	73 d5		 jae	 SHORT $L281762

; 270  : 	}
; 271  : 	if( pImage->nLength == 0 )

  00052	66 8b 06	 mov	 ax, WORD PTR [esi]
  00055	66 f7 d8	 neg	 ax
  00058	1b c0		 sbb	 eax, eax
  0005a	23 c6		 and	 eax, esi
  0005c	5e		 pop	 esi
  0005d	5f		 pop	 edi
  0005e	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  0005f	c3		 ret	 0
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ENDP ; ATL::_AtlGetStringResourceImage
_TEXT	ENDS
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
EXTRN	__imp__FindResourceA@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_id$ = 12						; size = 4
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z PROC NEAR ; ATL::AtlGetStringResourceImage, COMDAT

; 280  : {

  00000	56		 push	 esi

; 281  : 	HRSRC hResource;
; 282  : 
; 283  : 	hResource = ::FindResource( hInstance, MAKEINTRESOURCE( ((id>>4)+1) ), RT_STRING );

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _id$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	c1 e8 04	 shr	 eax, 4
  0000a	57		 push	 edi
  0000b	8b 7c 24 0c	 mov	 edi, DWORD PTR _hInstance$[esp+4]
  0000f	40		 inc	 eax
  00010	0f b7 c8	 movzx	 ecx, ax
  00013	6a 06		 push	 6
  00015	51		 push	 ecx
  00016	57		 push	 edi
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12

; 284  : 	if( hResource == NULL )

  0001d	85 c0		 test	 eax, eax
  0001f	75 03		 jne	 SHORT $L39545
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 290  : }

  00023	c3		 ret	 0
$L39545:

; 285  : 	{
; 286  : 		return( NULL );
; 287  : 	}
; 288  : 
; 289  : 	return _AtlGetStringResourceImage( hInstance, hResource, id );

  00024	56		 push	 esi
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 290  : }

  00031	c3		 ret	 0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ENDP ; ATL::AtlGetStringResourceImage
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 66   : 		return (this+1);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 67   : 	}

  00003	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
; Function compile flags: /Ogty
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?AddRef@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 71   : 		ATLASSERT(nRefs > 0);
; 72   : 		_InterlockedIncrement(&nRefs);

  00000	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 73   : 	}

  0000c	c3		 ret	 0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 76   : 		return nRefs < 0;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 9c c0	 setl	 al

; 77   : 	}

  0000a	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Ogty
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 80   : 		return( nRefs > 1 ); 

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 01	 cmp	 edx, 1
  00008	0f 9f c0	 setg	 al

; 81   : 	}

  0000b	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Ogty
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	4a		 dec	 edx
  0000b	85 d2		 test	 edx, edx
  0000d	7f 0a		 jg	 SHORT $L39885

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b c8		 mov	 ecx, eax
  00016	ff 52 04	 call	 DWORD PTR [edx+4]
$L39885:

; 98   : 		}
; 99   : 	}

  00019	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	?Start@CEveSchool@@QAEHXZ			; CEveSchool::Start
EXTRN	?AddSetLocalEvent@CUserMng@@QAEXFE@Z:NEAR	; CUserMng::AddSetLocalEvent
EXTRN	?g_UserMng@@3VCUserMng@@A:BYTE			; g_UserMng
EXTRN	?SetState@CFlyffEvent@@QAEHHE@Z:NEAR		; CFlyffEvent::SetState
EXTRN	?GetState@CFlyffEvent@@QAEEH@Z:NEAR		; CFlyffEvent::GetState
EXTRN	?g_eLocal@@3VCFlyffEvent@@A:BYTE		; g_eLocal
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ?Start@CEveSchool@@QAEHXZ
_TEXT	SEGMENT
?Start@CEveSchool@@QAEHXZ PROC NEAR			; CEveSchool::Start, COMDAT
; _this$ = ecx

; 68   : // "/sbstart"
; 69   : 	if( g_eLocal.GetState( EVE_SCHOOL_BATTLE ) != SBS_READY )

  00000	6a 05		 push	 5
  00002	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00007	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  0000c	3c 01		 cmp	 al, 1
  0000e	74 03		 je	 SHORT $L268150

; 70   : 		return FALSE;

  00010	33 c0		 xor	 eax, eax

; 75   : }

  00012	c3		 ret	 0
$L268150:

; 71   : 
; 72   : 	if( g_eLocal.SetState( EVE_SCHOOL_BATTLE, SBS_START ) )

  00013	6a 02		 push	 2
  00015	6a 05		 push	 5
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0001c	e8 00 00 00 00	 call	 ?SetState@CFlyffEvent@@QAEHHE@Z ; CFlyffEvent::SetState
  00021	85 c0		 test	 eax, eax
  00023	74 0e		 je	 SHORT $L268151

; 73   : 		g_UserMng.AddSetLocalEvent( EVE_SCHOOL_BATTLE, SBS_START );

  00025	6a 02		 push	 2
  00027	6a 05		 push	 5
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0002e	e8 00 00 00 00	 call	 ?AddSetLocalEvent@CUserMng@@QAEXFE@Z ; CUserMng::AddSetLocalEvent
$L268151:

; 74   : 	return TRUE;

  00033	b8 01 00 00 00	 mov	 eax, 1

; 75   : }

  00038	c3		 ret	 0
?Start@CEveSchool@@QAEHXZ ENDP				; CEveSchool::Start
_TEXT	ENDS
PUBLIC	?Start2@CEveSchool@@QAEHXZ			; CEveSchool::Start2
EXTRN	__imp__GetTickCount@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Start2@CEveSchool@@QAEHXZ
_TEXT	SEGMENT
?Start2@CEveSchool@@QAEHXZ PROC NEAR			; CEveSchool::Start2, COMDAT
; _this$ = ecx

; 78   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 79   : // "/sbstart2"
; 80   : 	if( g_eLocal.GetState( EVE_SCHOOL_BATTLE ) != SBS_START )

  00003	6a 05		 push	 5
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0000a	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  0000f	3c 02		 cmp	 al, 2
  00011	74 04		 je	 SHORT $L268156

; 81   : 		return FALSE;

  00013	33 c0		 xor	 eax, eax
  00015	5e		 pop	 esi

; 88   : }

  00016	c3		 ret	 0
$L268156:

; 82   : 
; 83   : 	if( g_eLocal.SetState( EVE_SCHOOL_BATTLE, SBS_START2 ) )

  00017	6a 03		 push	 3
  00019	6a 05		 push	 5
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00020	e8 00 00 00 00	 call	 ?SetState@CFlyffEvent@@QAEHHE@Z ; CFlyffEvent::SetState
  00025	85 c0		 test	 eax, eax
  00027	74 0e		 je	 SHORT $L268157

; 84   : 		g_UserMng.AddSetLocalEvent( EVE_SCHOOL_BATTLE, SBS_START2 );

  00029	6a 03		 push	 3
  0002b	6a 05		 push	 5
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00032	e8 00 00 00 00	 call	 ?AddSetLocalEvent@CUserMng@@QAEXFE@Z ; CUserMng::AddSetLocalEvent
$L268157:

; 85   : 
; 86   : 	m_dwsbstart2	= GetTickCount();

  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003d	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax

; 87   : 	return TRUE;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	5e		 pop	 esi

; 88   : }

  00049	c3		 ret	 0
?Start2@CEveSchool@@QAEHXZ ENDP				; CEveSchool::Start2
_TEXT	ENDS
PUBLIC	?GetPos@CEveSchool@@QAE?AUD3DXVECTOR3@@K@Z	; CEveSchool::GetPos
; Function compile flags: /Ogty
;	COMDAT ?GetPos@CEveSchool@@QAE?AUD3DXVECTOR3@@K@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_id$ = 12						; size = 4
?GetPos@CEveSchool@@QAE?AUD3DXVECTOR3@@K@Z PROC NEAR	; CEveSchool::GetPos, COMDAT
; _this$ = ecx

; 266  : 	if( id > MAX_SCHOOL || id < 1 )

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _id$[esp-4]
  00004	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00007	56		 push	 esi
  00008	77 0e		 ja	 SHORT $L268304
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	72 09		 jb	 SHORT $L268304

; 269  : 	return m_avPos[id-1];

  0000f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00012	8d 4c 81 f8	 lea	 ecx, DWORD PTR [ecx+eax*4-8]
  00016	eb 03		 jmp	 SHORT $L281791
$L268304:

; 267  : //		return D3DXVECTOR3( 0, 0, 0 );
; 268  : 		return m_vDefault;

  00018	83 c1 7c	 add	 ecx, 124		; 0000007cH
$L281791:
  0001b	8b 31		 mov	 esi, DWORD PTR [ecx]
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp]
  00021	8b d0		 mov	 edx, eax
  00023	89 32		 mov	 DWORD PTR [edx], esi
  00025	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00028	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0002e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00031	5e		 pop	 esi

; 270  : }

  00032	c2 08 00	 ret	 8
?GetPos@CEveSchool@@QAE?AUD3DXVECTOR3@@K@Z ENDP		; CEveSchool::GetPos
_TEXT	ENDS
PUBLIC	??0CTimeSpan@ATL@@QAE@JHHH@Z			; ATL::CTimeSpan::CTimeSpan
EXTRN	__allmul:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT
_lDays$ = 8						; size = 4
_nHours$ = 12						; size = 4
_nMins$ = 16						; size = 4
_nSecs$ = 20						; size = 4
??0CTimeSpan@ATL@@QAE@JHHH@Z PROC NEAR			; ATL::CTimeSpan::CTimeSpan, COMDAT
; _this$ = ecx

; 38   :  	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lDays$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	6a 00		 push	 0
  00008	99		 cdq
  00009	6a 18		 push	 24			; 00000018H
  0000b	52		 push	 edx
  0000c	50		 push	 eax
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 __allmul
  00014	8b c8		 mov	 ecx, eax
  00016	8b 44 24 10	 mov	 eax, DWORD PTR _nHours$[esp+4]
  0001a	8b fa		 mov	 edi, edx
  0001c	99		 cdq
  0001d	6a 00		 push	 0
  0001f	03 c8		 add	 ecx, eax
  00021	6a 3c		 push	 60			; 0000003cH
  00023	13 fa		 adc	 edi, edx
  00025	57		 push	 edi
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 __allmul
  0002c	8b c8		 mov	 ecx, eax
  0002e	8b 44 24 14	 mov	 eax, DWORD PTR _nMins$[esp+4]
  00032	8b fa		 mov	 edi, edx
  00034	99		 cdq
  00035	6a 00		 push	 0
  00037	03 c8		 add	 ecx, eax
  00039	6a 3c		 push	 60			; 0000003cH
  0003b	13 fa		 adc	 edi, edx
  0003d	57		 push	 edi
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 __allmul
  00044	8b c8		 mov	 ecx, eax
  00046	8b 44 24 18	 mov	 eax, DWORD PTR _nSecs$[esp+4]
  0004a	8b fa		 mov	 edi, edx
  0004c	99		 cdq
  0004d	03 c8		 add	 ecx, eax
  0004f	13 fa		 adc	 edi, edx
  00051	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00054	5f		 pop	 edi
  00055	89 0e		 mov	 DWORD PTR [esi], ecx

; 39   : }

  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	c2 10 00	 ret	 16			; 00000010H
??0CTimeSpan@ATL@@QAE@JHHH@Z ENDP			; ATL::CTimeSpan::CTimeSpan
_TEXT	ENDS
PUBLIC	?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ		; ATL::CTimeSpan::GetTimeSpan
; Function compile flags: /Ogty
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ PROC NEAR		; ATL::CTimeSpan::GetTimeSpan, COMDAT
; _this$ = ecx

; 78   : 	return( m_timeSpan );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 79   : }

  00005	c3		 ret	 0
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ ENDP		; ATL::CTimeSpan::GetTimeSpan
_TEXT	ENDS
PUBLIC	??NCTimeSpan@ATL@@QBE_NV01@@Z			; ATL::CTimeSpan::operator<=
; Function compile flags: /Ogty
;	COMDAT ??NCTimeSpan@ATL@@QBE_NV01@@Z
_TEXT	SEGMENT
_span$ = 8						; size = 8
??NCTimeSpan@ATL@@QBE_NV01@@Z PROC NEAR			; ATL::CTimeSpan::operator<=, COMDAT
; _this$ = ecx

; 125  : 	return( m_timeSpan <= span.m_timeSpan );

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	3b 44 24 08	 cmp	 eax, DWORD PTR _span$[esp]
  00007	7f 12		 jg	 SHORT $L281802
  00009	7c 08		 jl	 SHORT $L281804
  0000b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000d	3b 4c 24 04	 cmp	 ecx, DWORD PTR _span$[esp-4]
  00011	77 08		 ja	 SHORT $L281802
$L281804:
  00013	b8 01 00 00 00	 mov	 eax, 1

; 126  : }

  00018	c2 08 00	 ret	 8
$L281802:

; 125  : 	return( m_timeSpan <= span.m_timeSpan );

  0001b	33 c0		 xor	 eax, eax

; 126  : }

  0001d	c2 08 00	 ret	 8
??NCTimeSpan@ATL@@QBE_NV01@@Z ENDP			; ATL::CTimeSpan::operator<=
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@XZ				; ATL::CTime::CTime
; Function compile flags: /Ogty
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CTime@ATL@@QAE@XZ PROC NEAR				; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 162  : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 163  : }

  0000f	c3		 ret	 0
??0CTime@ATL@@QAE@XZ ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
; Function compile flags: /Ogty
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 167  : {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _time$[esp]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _time$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 168  : }

  0000f	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@HHHHHHH@Z			; ATL::CTime::CTime
EXTRN	__mktime64:NEAR
; Function compile flags: /Ogty
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT
_atm$ = -36						; size = 36
_nYear$ = 8						; size = 4
_nMonth$ = 12						; size = 4
_nDay$ = 16						; size = 4
_nHour$ = 20						; size = 4
_nMin$ = 24						; size = 4
_nSec$ = 28						; size = 4
_nDST$ = 32						; size = 4
??0CTime@ATL@@QAE@HHHHHHH@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 172  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H

; 173  : 	struct tm atm;
; 174  : 	atm.tm_sec = nSec;

  00003	8b 44 24 3c	 mov	 eax, DWORD PTR _nSec$[esp+32]

; 175  : 	atm.tm_min = nMin;
; 176  : 	atm.tm_hour = nHour;

  00007	8b 54 24 34	 mov	 edx, DWORD PTR _nHour$[esp+32]
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _nMin$[esp+36]
  00012	89 4c 24 08	 mov	 DWORD PTR _atm$[esp+44], ecx

; 177  : 	ATLASSERT(nDay >= 1 && nDay <= 31);
; 178  : 	atm.tm_mday = nDay;
; 179  : 	ATLASSERT(nMonth >= 1 && nMonth <= 12);
; 180  : 	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based

  00016	8b 4c 24 30	 mov	 ecx, DWORD PTR _nMonth$[esp+36]
  0001a	89 44 24 04	 mov	 DWORD PTR _atm$[esp+40], eax
  0001e	8b 44 24 34	 mov	 eax, DWORD PTR _nDay$[esp+36]
  00022	49		 dec	 ecx
  00023	89 54 24 0c	 mov	 DWORD PTR _atm$[esp+48], edx

; 181  : 	ATLASSERT(nYear >= 1900);
; 182  : 	atm.tm_year = nYear - 1900;     // tm_year is 1900 based

  00027	8b 54 24 2c	 mov	 edx, DWORD PTR _nYear$[esp+36]
  0002b	89 4c 24 14	 mov	 DWORD PTR _atm$[esp+56], ecx
  0002f	89 44 24 10	 mov	 DWORD PTR _atm$[esp+52], eax

; 183  : 	atm.tm_isdst = nDST;

  00033	8b 44 24 44	 mov	 eax, DWORD PTR _nDST$[esp+36]

; 184  : 	m_time = _mktime64(&atm);

  00037	8d 4c 24 04	 lea	 ecx, DWORD PTR _atm$[esp+40]
  0003b	81 c2 94 f8 ff
	ff		 add	 edx, -1900		; fffff894H
  00041	51		 push	 ecx
  00042	89 54 24 1c	 mov	 DWORD PTR _atm$[esp+64], edx
  00046	89 44 24 28	 mov	 DWORD PTR _atm$[esp+76], eax
  0004a	e8 00 00 00 00	 call	 __mktime64
  0004f	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 185  : 	ATLASSERT(m_time != -1);       // indicates an illegal input time
; 186  : 	
; 187  : 	if(m_time == -1)

  00052	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00055	8b d0		 mov	 edx, eax
  00057	23 d1		 and	 edx, ecx
  00059	83 c4 04	 add	 esp, 4
  0005c	83 fa ff	 cmp	 edx, -1
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	75 0a		 jne	 SHORT $L42612

; 188  : 		AtlThrow(E_INVALIDARG);

  00063	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00068	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L281815:
$L42612:

; 189  : }

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	83 c4 24	 add	 esp, 36			; 00000024H
  00073	c2 1c 00	 ret	 28			; 0000001cH
$L281814:
??0CTime@ATL@@QAE@HHHHHHH@Z ENDP			; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z		; ATL::CTime::operator+
; Function compile flags: /Ogty
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_span$ = 12						; size = 8
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z PROC NEAR	; ATL::CTime::operator+, COMDAT
; _this$ = ecx

; 286  : 	return( CTime( m_time+span.GetTimeSpan() ) );

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 44 24 08	 mov	 eax, DWORD PTR _span$[esp-4]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	03 d0		 add	 edx, eax
  0000b	13 4c 24 0c	 adc	 ecx, DWORD PTR _span$[esp]
  0000f	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00013	89 10		 mov	 DWORD PTR [eax], edx
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 287  : }

  00018	c2 0c 00	 ret	 12			; 0000000cH
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z ENDP		; ATL::CTime::operator+
_TEXT	ENDS
PUBLIC	?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z	; ATL::CTime::GetLocalTm
EXTRN	__localtime64:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z
_TEXT	SEGMENT
_ptm$ = 8						; size = 4
?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z PROC NEAR	; ATL::CTime::GetLocalTm, COMDAT
; _this$ = ecx

; 338  : {

  00000	53		 push	 ebx

; 339  : 	if (ptm != NULL)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _ptm$[esp]

; 340  : 	{
; 341  : 		struct tm* ptmTemp = _localtime64(&m_time);

  00005	51		 push	 ecx
  00006	e8 00 00 00 00	 call	 __localtime64
  0000b	83 c4 04	 add	 esp, 4
  0000e	85 db		 test	 ebx, ebx
  00010	74 19		 je	 SHORT $L42721

; 342  : 		if (ptmTemp == NULL)

  00012	85 c0		 test	 eax, eax
  00014	75 04		 jne	 SHORT $L42720
  00016	5b		 pop	 ebx

; 347  : 	}
; 348  : 	else
; 349  : 		return _localtime64(&m_time);
; 350  : }

  00017	c2 04 00	 ret	 4
$L42720:
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 343  : 			return NULL;    // indicates the m_time was not initialized!
; 344  : 
; 345  : 		*ptm = *ptmTemp;

  0001c	8b f0		 mov	 esi, eax
  0001e	b9 09 00 00 00	 mov	 ecx, 9
  00023	8b fb		 mov	 edi, ebx
  00025	f3 a5		 rep movsd
  00027	5f		 pop	 edi

; 346  : 		return ptm;

  00028	8b c3		 mov	 eax, ebx
  0002a	5e		 pop	 esi
$L42721:
  0002b	5b		 pop	 ebx

; 347  : 	}
; 348  : 	else
; 349  : 		return _localtime64(&m_time);
; 350  : }

  0002c	c2 04 00	 ret	 4
?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z ENDP		; ATL::CTime::GetLocalTm
_TEXT	ENDS
PUBLIC	?GetYear@CTime@ATL@@QBEHXZ			; ATL::CTime::GetYear
; Function compile flags: /Ogty
;	COMDAT ?GetYear@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetYear@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetYear, COMDAT
; _this$ = ecx

; 377  : 	struct tm * ptm;
; 378  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 379  : 	return ptm ? (ptm->tm_year) + 1900 : 0 ; 

  00009	85 c0		 test	 eax, eax
  0000b	74 09		 je	 SHORT $L281832
  0000d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00010	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH

; 380  : }

  00015	c3		 ret	 0
$L281832:

; 379  : 	return ptm ? (ptm->tm_year) + 1900 : 0 ; 

  00016	33 c0		 xor	 eax, eax

; 380  : }

  00018	c3		 ret	 0
?GetYear@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetYear
_TEXT	ENDS
PUBLIC	?GetMonth@CTime@ATL@@QBEHXZ			; ATL::CTime::GetMonth
; Function compile flags: /Ogty
;	COMDAT ?GetMonth@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetMonth@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetMonth, COMDAT
; _this$ = ecx

; 384  : 	struct tm * ptm;
; 385  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 386  : 	return ptm ? ptm->tm_mon + 1 : 0;

  00009	85 c0		 test	 eax, eax
  0000b	74 05		 je	 SHORT $L281845
  0000d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00010	40		 inc	 eax

; 387  : }

  00011	c3		 ret	 0
$L281845:

; 386  : 	return ptm ? ptm->tm_mon + 1 : 0;

  00012	33 c0		 xor	 eax, eax

; 387  : }

  00014	c3		 ret	 0
?GetMonth@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetMonth
_TEXT	ENDS
PUBLIC	?GetDay@CTime@ATL@@QBEHXZ			; ATL::CTime::GetDay
; Function compile flags: /Ogty
;	COMDAT ?GetDay@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetDay@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetDay, COMDAT
; _this$ = ecx

; 391  : 	struct tm * ptm;
; 392  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 393  : 	return ptm ? ptm->tm_mday : 0 ; 

  00009	85 c0		 test	 eax, eax
  0000b	74 04		 je	 SHORT $L281858
  0000d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 394  : }

  00010	c3		 ret	 0
$L281858:

; 393  : 	return ptm ? ptm->tm_mday : 0 ; 

  00011	33 c0		 xor	 eax, eax

; 394  : }

  00013	c3		 ret	 0
?GetDay@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetDay
_TEXT	ENDS
PUBLIC	?GetHour@CTime@ATL@@QBEHXZ			; ATL::CTime::GetHour
; Function compile flags: /Ogty
;	COMDAT ?GetHour@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetHour@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetHour, COMDAT
; _this$ = ecx

; 398  : 	struct tm * ptm;
; 399  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 400  : 	return ptm ? ptm->tm_hour : -1 ; 

  00009	85 c0		 test	 eax, eax
  0000b	74 04		 je	 SHORT $L281871
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 401  : }

  00010	c3		 ret	 0
$L281871:

; 400  : 	return ptm ? ptm->tm_hour : -1 ; 

  00011	83 c8 ff	 or	 eax, -1

; 401  : }

  00014	c3		 ret	 0
?GetHour@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetHour
_TEXT	ENDS
PUBLIC	?GetMinute@CTime@ATL@@QBEHXZ			; ATL::CTime::GetMinute
; Function compile flags: /Ogty
;	COMDAT ?GetMinute@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetMinute@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetMinute, COMDAT
; _this$ = ecx

; 405  : 	struct tm * ptm;
; 406  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 407  : 	return ptm ? ptm->tm_min : -1 ; 

  00009	85 c0		 test	 eax, eax
  0000b	74 04		 je	 SHORT $L281884
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 408  : }

  00010	c3		 ret	 0
$L281884:

; 407  : 	return ptm ? ptm->tm_min : -1 ; 

  00011	83 c8 ff	 or	 eax, -1

; 408  : }

  00014	c3		 ret	 0
?GetMinute@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetMinute
_TEXT	ENDS
PUBLIC	?GetSecond@CTime@ATL@@QBEHXZ			; ATL::CTime::GetSecond
; Function compile flags: /Ogty
;	COMDAT ?GetSecond@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSecond@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetSecond, COMDAT
; _this$ = ecx

; 412  : 	struct tm * ptm;
; 413  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 414  : 	return ptm ? ptm->tm_sec : -1 ;

  00009	85 c0		 test	 eax, eax
  0000b	74 03		 je	 SHORT $L281897
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 415  : }

  0000f	c3		 ret	 0
$L281897:

; 414  : 	return ptm ? ptm->tm_sec : -1 ;

  00010	83 c8 ff	 or	 eax, -1

; 415  : }

  00013	c3		 ret	 0
?GetSecond@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetSecond
_TEXT	ENDS
PUBLIC	?GetDayOfWeek@CTime@ATL@@QBEHXZ			; ATL::CTime::GetDayOfWeek
; Function compile flags: /Ogty
;	COMDAT ?GetDayOfWeek@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetDayOfWeek@CTime@ATL@@QBEHXZ PROC NEAR		; ATL::CTime::GetDayOfWeek, COMDAT
; _this$ = ecx

; 419  : 	struct tm * ptm;
; 420  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 421  : 	return ptm ? ptm->tm_wday + 1 : 0 ;

  00009	85 c0		 test	 eax, eax
  0000b	74 05		 je	 SHORT $L281910
  0000d	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00010	40		 inc	 eax

; 422  : }

  00011	c3		 ret	 0
$L281910:

; 421  : 	return ptm ? ptm->tm_wday + 1 : 0 ;

  00012	33 c0		 xor	 eax, eax

; 422  : }

  00014	c3		 ret	 0
?GetDayOfWeek@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetDayOfWeek
_TEXT	ENDS
PUBLIC	?SendJoinMsg@CGuildCombat@@QAEXPBD@Z		; CGuildCombat::SendJoinMsg
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ?SendJoinMsg@CGuildCombat@@QAEXPBD@Z
_TEXT	SEGMENT
_lpszString$ = 8					; size = 4
?SendJoinMsg@CGuildCombat@@QAEXPBD@Z PROC NEAR		; CGuildCombat::SendJoinMsg, COMDAT
; _this$ = ecx

; 3261 : 
; 3262 : }

  00000	c2 04 00	 ret	 4
?SendJoinMsg@CGuildCombat@@QAEXPBD@Z ENDP		; CGuildCombat::SendJoinMsg
_TEXT	ENDS
PUBLIC	?SendGuildCombatEnterTime@CGuildCombat@@QAEXXZ	; CGuildCombat::SendGuildCombatEnterTime
EXTRN	?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z:NEAR	; CUserMng::AddGuildCombatEnterTime
; Function compile flags: /Ogty
;	COMDAT ?SendGuildCombatEnterTime@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
?SendGuildCombatEnterTime@CGuildCombat@@QAEXXZ PROC NEAR ; CGuildCombat::SendGuildCombatEnterTime, COMDAT
; _this$ = ecx

; 3266 : 	g_UserMng.AddGuildCombatEnterTime( GuildCombatProcess[m_nProcessGo].dwTime );

  00000	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  00006	83 c0 0f	 add	 eax, 15			; 0000000fH
  00009	c1 e0 04	 shl	 eax, 4
  0000c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0000f	51		 push	 ecx
  00010	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00015	e8 00 00 00 00	 call	 ?AddGuildCombatEnterTime@CUserMng@@QAEXK@Z ; CUserMng::AddGuildCombatEnterTime

; 3267 : /*	for( map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.begin() ; ita != m_GuildCombatMem.end() ; ++ita )
; 3268 : 	{
; 3269 : 		CGuild* pGuild = g_GuildMng.GetGuild( ita->first );
; 3270 : 		if( pGuild )
; 3271 : 		{
; 3272 : 			CGuildMember*	pMember;
; 3273 : 			CUser*			pUsertmp;
; 3274 : 			for( map<u_long, CGuildMember*>::iterator i = pGuild->m_mapPMember.begin();
; 3275 : 			i != pGuild->m_mapPMember.end(); ++i )
; 3276 : 			{
; 3277 : 				pMember		= i->second;
; 3278 : 				pUsertmp	= (CUser*)prj.GetUserByID( pMember->m_idPlayer );
; 3279 : 				if( IsValidObj( pUsertmp ) )
; 3280 : 				{
; 3281 : 					pUsertmp->AddGuildCombatEnterTime( GuildCombatProcess[m_nProcessGo].dwTime );
; 3282 : 				}
; 3283 : 			}
; 3284 : 		}
; 3285 : 	}
; 3286 : */
; 3287 : }

  0001a	c3		 ret	 0
?SendGuildCombatEnterTime@CGuildCombat@@QAEXXZ ENDP	; CGuildCombat::SendGuildCombatEnterTime
_TEXT	ENDS
PUBLIC	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281929
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L281929:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281934
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L281934:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281939
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L281939:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
_TEXT	ENDS
PUBLIC	?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size, COMDAT
; _this$ = ecx

; 431  : 		return (_Mysize);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 432  : 		}

  00003	c3		 ret	 0
?size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281947
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L281947:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281952
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L281952:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L281957

; 517  : 		}

  00007	c3		 ret	 0
$L281957:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	d1 fa		 sar	 edx, 1
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 517  : 		}

  0001d	c3		 ret	 0
?size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281962
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L281962:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 03	 sar	 eax, 3

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::size
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 230  : 			++this->_Myptr;

  00002	83 00 08	 add	 DWORD PTR [eax], 8

; 231  : 			return (*this);
; 232  : 			}

  00005	c3		 ret	 0
??Eiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Fiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator--
; Function compile flags: /Ogty
;	COMDAT ??Fiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator--, COMDAT
; _this$ = ecx

; 242  : 			{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 243  : 			--this->_Myptr;

  00002	83 00 f8	 add	 DWORD PTR [eax], -8	; fffffff8H

; 244  : 			return (*this);
; 245  : 			}

  00005	c3		 ret	 0
??Fiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 156  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??9const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 160  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 161  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
; Function compile flags: /Ogty
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281982
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L281982:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogty
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281987
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L281987:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKH@2@@Z ; std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKH@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKH@2@@Z ENDP ; std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned long const ,int> >::allocator<std::pair<unsigned long const ,int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<unsigned long const ,int> >::allocator<std::pair<unsigned long const ,int> >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned long const ,int> >::allocator<std::pair<unsigned long const ,int> >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L281998
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L281998:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Nextnode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Nextnode, COMDAT

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 109  : 		}

  00004	c3		 ret	 0
?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Prevnode
; Function compile flags: /Ogty
;	COMDAT ?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Prevnode, COMDAT

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 114  : 		}

  00007	c3		 ret	 0
?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Prevnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L282015

; 459  : 		}

  00007	c3		 ret	 0
$L282015:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00008	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 03	 sar	 edx, 3
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 459  : 		}

  0001e	c3		 ret	 0
?capacity@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L282020

; 517  : 		}

  00007	c3		 ret	 0
$L282020:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 03	 sar	 edx, 3
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 517  : 		}

  0001e	c3		 ret	 0
?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::size
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__GCGETPOINT>::allocator<CGuildCombat::__GCGETPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__GCGETPOINT>::allocator<CGuildCombat::__GCGETPOINT>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__GCGETPOINT>::allocator<CGuildCombat::__GCGETPOINT>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L282028

; 459  : 		}

  00007	c3		 ret	 0
$L282028:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00008	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	d1 fa		 sar	 edx, 1
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 459  : 		}

  0001d	c3		 ret	 0
?capacity@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L282033

; 517  : 		}

  00007	c3		 ret	 0
$L282033:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	d1 fa		 sar	 edx, 1
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 517  : 		}

  0001d	c3		 ret	 0
?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::size
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocator<CGuildCombat::__GCPLAYERPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocator<CGuildCombat::__GCPLAYERPOINT>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocator<CGuildCombat::__GCPLAYERPOINT>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L282041
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L282041:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocator<CGuildCombat::__GuildCombatMember *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocator<CGuildCombat::__GuildCombatMember *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocator<CGuildCombat::__GuildCombatMember *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L282049
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L282049:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@XZ ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@XZ PROC NEAR ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@XZ ENDP ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L282057

; 459  : 		}

  00007	c3		 ret	 0
$L282057:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00008	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	d1 fa		 sar	 edx, 1
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx

; 459  : 		}

  0001d	c3		 ret	 0
?capacity@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__GCSENDITEM>::allocator<CGuildCombat::__GCSENDITEM>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__GCSENDITEM>::allocator<CGuildCombat::__GCSENDITEM>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__GCSENDITEM>::allocator<CGuildCombat::__GCSENDITEM>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L282065
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L282065:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 03	 sar	 eax, 3

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocator<CGuildCombat::__REQUESTGUILD>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocator<CGuildCombat::__REQUESTGUILD>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocator<CGuildCombat::__REQUESTGUILD>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__REQUESTGUILD>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocator<CGuildCombat::__GCRESULTVALUEGUILD>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocator<CGuildCombat::__GCRESULTVALUEGUILD>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocator<CGuildCombat::__GCRESULTVALUEGUILD>
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@XZ ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@XZ PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@XZ ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L282088

; 459  : 		}

  00007	c3		 ret	 0
$L282088:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00008	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 02	 sar	 edx, 2
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 459  : 		}

  0001e	c3		 ret	 0
?capacity@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::size
; Function compile flags: /Ogty
;	COMDAT ?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L282093

; 517  : 		}

  00007	c3		 ret	 0
$L282093:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000b	2b c8		 sub	 ecx, eax
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	f7 e9		 imul	 ecx
  00014	c1 fa 02	 sar	 edx, 2
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx

; 517  : 		}

  0001e	c3		 ret	 0
?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::size
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEABU__REQUESTGUILD@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator,bool>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00010	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 172  : 			return (*this);
; 173  : 			}

  00008	c3		 ret	 0
??Econst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 197  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 198  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?StringCompare@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z	; ATL::ChTraitsCRT<char>::StringCompare
EXTRN	__mbscmp:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?StringCompare@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z
_TEXT	SEGMENT
_pszA$ = 8						; size = 4
_pszB$ = 12						; size = 4
?StringCompare@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z PROC NEAR	; ATL::ChTraitsCRT<char>::StringCompare, COMDAT

; 336  : 		return _mbscmp( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );

  00000	e9 00 00 00 00	 jmp	 __mbscmp
?StringCompare@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z ENDP	; ATL::ChTraitsCRT<char>::StringCompare
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned long const ,int> >::allocator<std::pair<unsigned long const ,int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<unsigned long const ,int> >::allocator<std::pair<unsigned long const ,int> >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBKH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned long const ,int> >::allocator<std::pair<unsigned long const ,int> >
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Left
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocator<CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__JOINPLAYER *>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Myval, COMDAT

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 119  : 		}

  00007	c3		 ret	 0
?_Myval@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU__JOINPLAYER@CGuildCombat@@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__GCGETPOINT>::allocator<CGuildCombat::__GCGETPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCGETPOINT>::allocator<CGuildCombat::__GCGETPOINT>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__GCGETPOINT>::allocator<CGuildCombat::__GCGETPOINT>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCGETPOINT>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCGETPOINT>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCGETPOINT>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocator<CGuildCombat::__GCPLAYERPOINT>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocator<CGuildCombat::__GCPLAYERPOINT>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocator<CGuildCombat::__GCPLAYERPOINT>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocator<CGuildCombat::__GuildCombatMember *>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocator<CGuildCombat::__GuildCombatMember *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocator<CGuildCombat::__GuildCombatMember *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEXPAPAU__GuildCombatMember@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GuildCombatMember *>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEXPAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEXPAPAU__GuildCombatMember@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GuildCombatMember *>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEXPAPAU__GuildCombatMember@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GuildCombatMember *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@ABV01@@Z ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z PROC NEAR ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z ENDP ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__GCSENDITEM>::allocator<CGuildCombat::__GCSENDITEM>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCSENDITEM>::allocator<CGuildCombat::__GCSENDITEM>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__GCSENDITEM>::allocator<CGuildCombat::__GCSENDITEM>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCSENDITEM>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCSENDITEM>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCSENDITEM>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocator<CGuildCombat::__REQUESTGUILD>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocator<CGuildCombat::__REQUESTGUILD>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocator<CGuildCombat::__REQUESTGUILD>
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocator<CGuildCombat::__GCRESULTVALUEGUILD>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocator<CGuildCombat::__GCRESULTVALUEGUILD>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocator<CGuildCombat::__GCRESULTVALUEGUILD>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::deallocate
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 331  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl

; 332  : 		}

  0000c	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogty
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 352  : 		return (::strlen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L282187:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $L282187
  0000e	2b c2		 sub	 eax, edx

; 353  : 		}

  00010	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Ogty
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __First2$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __First1$[esp+4]
  0000e	8b c1		 mov	 eax, ecx
  00010	8b d7		 mov	 edx, edi
  00012	c1 e9 02	 shr	 ecx, 2
  00015	f3 a5		 rep movsd
  00017	8b c8		 mov	 ecx, eax
  00019	83 e1 03	 and	 ecx, 3
  0001c	f3 a4		 rep movsb
  0001e	5f		 pop	 edi
  0001f	8b c2		 mov	 eax, edx
  00021	5e		 pop	 esi

; 359  : 		}

  00022	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

  00000	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 335  : 	{	// return pointer category from pointer to int arguments

  00000	51		 push	 ecx

; 336  : 	_Scalar_ptr_iterator_tag _Cat;
; 337  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 338  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 371  : 	{	// return pointer category from pointer to unsigned long arguments

  00000	51		 push	 ecx

; 372  : 	_Scalar_ptr_iterator_tag _Cat;
; 373  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 374  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 03	 sar	 eax, 3

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 207  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 208  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@3@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@KV?$allocator@K@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEABKXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEABQAU__GuildCombatMember@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV012@H@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 02	 shl	 ecx, 2
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEABU__GCSENDITEM@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEABU__GCSENDITEM@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEABU__GCSENDITEM@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEABU__GCSENDITEM@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBKH@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned long const ,int> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBKH@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<unsigned long const ,int> >::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBKH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned long const ,int> >::max_size
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node::_Node
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKH@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 40   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  00010	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00013	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0001f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00022	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00026	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00029	88 50 14	 mov	 BYTE PTR [eax+20], dl
  0002c	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00030	c2 14 00	 ret	 20			; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildMember@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L275112
  0000d	8d 49 00	 npad	 3
$L275111:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L275111
$L275112:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuild@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuild@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuild@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuild@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L275124
  0000d	8d 49 00	 npad	 3
$L275123:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L275123
$L275124:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__JOINPLAYER *>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size, COMDAT
; _this$ = ecx

; 436  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 437  : 		}

  00005	c3		 ret	 0
?max_size@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__GCGETPOINT>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__GCGETPOINT>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__GCGETPOINT>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__GuildCombatMember *>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__GuildCombatMember *>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__GuildCombatMember *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QBEIXZ ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QBEIXZ PROC NEAR ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QBEIXZ ENDP ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__GCSENDITEM>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__GCSENDITEM>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__GCSENDITEM>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__REQUESTGUILD>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::max_size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__JOINPLAYER>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c c9	 lea	 ecx, DWORD PTR [ecx+ecx*8]
  0000b	c1 e1 02	 shl	 ecx, 2
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	2b ca		 sub	 ecx, edx
  0000a	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000f	f7 e9		 imul	 ecx
  00011	c1 fa 03	 sar	 edx, 3
  00014	8b c2		 mov	 eax, edx
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	03 c2		 add	 eax, edx

; 144  : 			}

  0001b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 02	 shl	 ecx, 2
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	2b ca		 sub	 ecx, edx
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	d1 fa		 sar	 edx, 1
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx

; 144  : 			}

  0001a	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABV012@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  0000b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	2b ca		 sub	 ecx, edx
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	d1 fa		 sar	 edx, 1
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx

; 144  : 			}

  0001a	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0000b	c1 e1 03	 shl	 ecx, 3
  0000e	03 d1		 add	 edx, ecx
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  00012	c2 04 00	 ret	 4
??Yiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Gconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	2b ca		 sub	 ecx, edx
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	c1 fa 02	 sar	 edx, 2
  00014	8b c2		 mov	 eax, edx
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	03 c2		 add	 eax, edx

; 144  : 			}

  0001b	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node::_Node
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Nextarg$ = 8						; size = 4
__Prevarg$ = 12						; size = 4
__Myvalarg$ = 16					; size = 4
??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node::_Node, COMDAT
; _this$ = ecx

; 34   : 			{	// construct a node with value

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Prevarg$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR __Nextarg$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Myvalarg$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 35   : 			}

  00018	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU012@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ ; std::allocator<CGuildCombat::__JOINPLAYER>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QBEIXZ ENDP ; std::allocator<CGuildCombat::__JOINPLAYER>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z ; std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ??0?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 39   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@QAE@U?$less@K@1@@Z ENDP ; std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$?0KH@?$pair@$$CBKH@std@@QAE@ABU?$pair@KH@1@@Z ; std::pair<unsigned long const ,int>::pair<unsigned long const ,int><unsigned long,int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$?0KH@?$pair@$$CBKH@std@@QAE@ABU?$pair@KH@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0KH@?$pair@$$CBKH@std@@QAE@ABU?$pair@KH@1@@Z PROC NEAR ; std::pair<unsigned long const ,int>::pair<unsigned long const ,int><unsigned long,int>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct from compatible pair

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 42   : 		}

  00010	c2 04 00	 ret	 4
??$?0KH@?$pair@$$CBKH@std@@QAE@ABU?$pair@KH@1@@Z ENDP	; std::pair<unsigned long const ,int>::pair<unsigned long const ,int><unsigned long,int>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
_TEXT	ENDS
PUBLIC	??$fill@PAU__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAU__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0ABU12@@Z PROC NEAR ; std::fill<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b c2		 cmp	 eax, edx
  0000a	74 17		 je	 SHORT $L277348
  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L277346:

; 1136 : 		*_First = _Val;

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c0 08	 add	 eax, 8
  0001e	3b c2		 cmp	 eax, edx
  00020	75 ef		 jne	 SHORT $L277346
  00022	5e		 pop	 esi
$L277348:

; 1137 : 	}

  00023	c3		 ret	 0
??$fill@PAU__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0ABU12@@Z ENDP ; std::fill<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD>
_TEXT	ENDS
PUBLIC	??$fill@PAKK@std@@YAXPAK0ABK@Z			; std::fill<unsigned long *,unsigned long>
; Function compile flags: /Ogty
;	COMDAT ??$fill@PAKK@std@@YAXPAK0ABK@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAKK@std@@YAXPAK0ABK@Z PROC NEAR		; std::fill<unsigned long *,unsigned long>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L277771
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L277769:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L277769
  0001c	5e		 pop	 esi
$L277771:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAKK@std@@YAXPAK0ABK@Z ENDP			; std::fill<unsigned long *,unsigned long>
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogty
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC NEAR		; std::fill<int *,int>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L277804
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L277802:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L277802
  0001c	5e		 pop	 esi
$L277804:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$fill@PAPAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0ABQAU12@@Z ; std::fill<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$fill@PAPAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0ABQAU12@@Z PROC NEAR ; std::fill<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER *>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L277861
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L277859:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L277859
  0001c	5e		 pop	 esi
$L277861:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAPAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0ABQAU12@@Z ENDP ; std::fill<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAU__JOINPLAYER@CGuildCombat@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@IPAPAU12@@Z ; std::_Allocate<CGuildCombat::__JOINPLAYER *>
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@PAU__JOINPLAYER@CGuildCombat@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@IPAPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAU__JOINPLAYER@CGuildCombat@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@IPAPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__JOINPLAYER *>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@PAU__JOINPLAYER@CGuildCombat@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@IPAPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *><CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *><CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *><CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *,std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *,std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L282498
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L282498:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *,std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$fill@PAU__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAU__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0ABU12@@Z PROC NEAR ; std::fill<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b c2		 cmp	 eax, edx
  0000a	74 1c		 je	 SHORT $L277925
  0000c	53		 push	 ebx
  0000d	8b 5c 24 10	 mov	 ebx, DWORD PTR __Val$[esp]
  00011	56		 push	 esi
  00012	57		 push	 edi
$L277923:

; 1136 : 		*_First = _Val;

  00013	8b f8		 mov	 edi, eax
  00015	83 c0 24	 add	 eax, 36			; 00000024H
  00018	3b c2		 cmp	 eax, edx
  0001a	b9 09 00 00 00	 mov	 ecx, 9
  0001f	8b f3		 mov	 esi, ebx
  00021	f3 a5		 rep movsd
  00023	75 ee		 jne	 SHORT $L277923
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
$L277925:

; 1137 : 	}

  00028	c3		 ret	 0
??$fill@PAU__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0ABU12@@Z ENDP ; std::fill<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__GCGETPOINT@CGuildCombat@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@IPAU12@@Z ; std::_Allocate<CGuildCombat::__GCGETPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@U__GCGETPOINT@CGuildCombat@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__GCGETPOINT@CGuildCombat@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@IPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__GCGETPOINT>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U__GCGETPOINT@CGuildCombat@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@IPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__GCGETPOINT>
_TEXT	ENDS
PUBLIC	??$fill@PAU__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAU__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0ABU12@@Z PROC NEAR ; std::fill<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 25		 je	 SHORT $L277979
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L277977:

; 1136 : 		*_First = _Val;

  00013	8b f2		 mov	 esi, edx
  00015	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00017	8b f8		 mov	 edi, eax
  00019	89 1f		 mov	 DWORD PTR [edi], ebx
  0001b	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001e	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00021	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00024	83 c0 0c	 add	 eax, 12			; 0000000cH
  00027	3b c1		 cmp	 eax, ecx
  00029	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002c	75 e5		 jne	 SHORT $L277977
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
$L277979:

; 1137 : 	}

  00031	c3		 ret	 0
??$fill@PAU__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0ABU12@@Z ENDP ; std::fill<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@IPAU12@@Z ; std::_Allocate<CGuildCombat::__GCPLAYERPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@IPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__GCPLAYERPOINT>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@IPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__GCPLAYERPOINT>
_TEXT	ENDS
PUBLIC	??$fill@PAPAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0ABQAU12@@Z ; std::fill<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAPAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0ABQAU12@@Z PROC NEAR ; std::fill<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember *>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L278033
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L278031:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L278031
  0001c	5e		 pop	 esi
$L278033:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAPAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0ABQAU12@@Z ENDP ; std::fill<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAU__GuildCombatMember@CGuildCombat@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@IPAPAU12@@Z ; std::_Allocate<CGuildCombat::__GuildCombatMember *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@PAU__GuildCombatMember@CGuildCombat@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@IPAPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAU__GuildCombatMember@CGuildCombat@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@IPAPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__GuildCombatMember *>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@PAU__GuildCombatMember@CGuildCombat@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@IPAPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__GuildCombatMember *>
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IPAV12@@Z ; std::_Allocate<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IPAV12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IPAV12@@Z PROC NEAR ; std::_Allocate<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IPAV12@@Z ENDP ; std::_Allocate<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
_TEXT	ENDS
PUBLIC	??$fill@PAU__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAU__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0ABU12@@Z PROC NEAR ; std::fill<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 25		 je	 SHORT $L278141
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L278139:

; 1136 : 		*_First = _Val;

  00013	8b f2		 mov	 esi, edx
  00015	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00017	8b f8		 mov	 edi, eax
  00019	89 1f		 mov	 DWORD PTR [edi], ebx
  0001b	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001e	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00021	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00024	83 c0 0c	 add	 eax, 12			; 0000000cH
  00027	3b c1		 cmp	 eax, ecx
  00029	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002c	75 e5		 jne	 SHORT $L278139
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
$L278141:

; 1137 : 	}

  00031	c3		 ret	 0
??$fill@PAU__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0ABU12@@Z ENDP ; std::fill<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__GCSENDITEM@CGuildCombat@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@IPAU12@@Z ; std::_Allocate<CGuildCombat::__GCSENDITEM>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@U__GCSENDITEM@CGuildCombat@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__GCSENDITEM@CGuildCombat@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@IPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__GCSENDITEM>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U__GCSENDITEM@CGuildCombat@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@IPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__GCSENDITEM>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__REQUESTGUILD@CGuildCombat@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@IPAU12@@Z ; std::_Allocate<CGuildCombat::__REQUESTGUILD>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U__REQUESTGUILD@CGuildCombat@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__REQUESTGUILD@CGuildCombat@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@IPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__REQUESTGUILD>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@U__REQUESTGUILD@CGuildCombat@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@IPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__REQUESTGUILD>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEGUILD@CGuildCombat@@IPAU12@@Z ; std::_Allocate<CGuildCombat::__GCRESULTVALUEGUILD>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEGUILD@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEGUILD@CGuildCombat@@IPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__GCRESULTVALUEGUILD>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEGUILD@CGuildCombat@@IPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__GCRESULTVALUEGUILD>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@IPAU12@@Z ; std::_Allocate<CGuildCombat::__GCRESULTVALUEPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@IPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__GCRESULTVALUEPLAYER>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@IPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__GCRESULTVALUEPLAYER>
_TEXT	ENDS
PUBLIC	??$fill@PAU__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAU__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0ABU12@@Z PROC NEAR ; std::fill<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 37		 je	 SHORT $L278347
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L278345:

; 1136 : 		*_First = _Val;

  00013	8b f2		 mov	 esi, edx
  00015	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00017	8b f8		 mov	 edi, eax
  00019	89 1f		 mov	 DWORD PTR [edi], ebx
  0001b	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001e	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00021	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00024	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00027	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0002a	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  0002d	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00030	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  00033	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  00036	83 c0 18	 add	 eax, 24			; 00000018H
  00039	3b c1		 cmp	 eax, ecx
  0003b	89 77 14	 mov	 DWORD PTR [edi+20], esi
  0003e	75 d3		 jne	 SHORT $L278345
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
$L278347:

; 1137 : 	}

  00043	c3		 ret	 0
??$fill@PAU__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0ABU12@@Z ENDP ; std::fill<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *><std::pair<unsigned long const ,int> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBKH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *><std::pair<unsigned long const ,int> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *><std::pair<unsigned long const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node><CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node><CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAU__JOINPLAYER@CGuildCombat@@@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAE@ABV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node><CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Allocate@U__JOINPLAYER@CGuildCombat@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@Z ; std::_Allocate<CGuildCombat::__JOINPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@U__JOINPLAYER@CGuildCombat@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U__JOINPLAYER@CGuildCombat@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@Z PROC NEAR ; std::_Allocate<CGuildCombat::__JOINPLAYER>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 35   : 	}

  00013	c3		 ret	 0
??$_Allocate@U__JOINPLAYER@CGuildCombat@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@Z ENDP ; std::_Allocate<CGuildCombat::__JOINPLAYER>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBKH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node><std::pair<unsigned long const ,int> >
; Function compile flags: /Ogty
;	COMDAT ??$?0U?$pair@$$CBKH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBKH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node><std::pair<unsigned long const ,int> >, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

  00000	8b c1		 mov	 eax, ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBKH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node><std::pair<unsigned long const ,int> >
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L282574
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L282574:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??0?$pair@KH@std@@QAE@ABKABH@Z			; std::pair<unsigned long,int>::pair<unsigned long,int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??0?$pair@KH@std@@QAE@ABKABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@KH@std@@QAE@ABKABH@Z PROC NEAR		; std::pair<unsigned long,int>::pair<unsigned long,int>, COMDAT
; _this$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 35   : 		}

  00013	c2 08 00	 ret	 8
??0?$pair@KH@std@@QAE@ABKABH@Z ENDP			; std::pair<unsigned long,int>::pair<unsigned long,int>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<unsigned long *,unsigned long *>, COMDAT

; 1031 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 1032 : 	return ((_OutIt)::memmove(&*_Dest, &*_First,
; 1033 : 		_Off * sizeof (*_First)) + _Off);

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1034 : 	}

  00027	c3		 ret	 0
??$_Copy_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__REQUESTGUILD@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>, COMDAT

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b ca		 cmp	 ecx, edx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 16		 je	 SHORT $L278669
  00010	56		 push	 esi
$L278667:

; 1022 : 		*_Dest = *_First;

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $L278667
  00025	5e		 pop	 esi
$L278669:

; 1023 : 	return (_Dest);
; 1024 : 	}

  00026	c3		 ret	 0
??$_Copy_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__JOINPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__JOINPLAYER>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

  00000	51		 push	 ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 221  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__JOINPLAYER>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCGETPOINT@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCGETPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCGETPOINT@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCGETPOINT@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCPLAYERPOINT@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCPLAYERPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCPLAYERPOINT@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCPLAYERPOINT@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@U__GuildCombatMember@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__GuildCombatMember@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__GuildCombatMember>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@U__GuildCombatMember@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__GuildCombatMember@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U__GuildCombatMember@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__GuildCombatMember@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__GuildCombatMember>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

  00000	51		 push	 ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 221  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@U__GuildCombatMember@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__GuildCombatMember@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__GuildCombatMember>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; std::_Ptr_cat<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z PROC NEAR ; std::_Ptr_cat<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ENDP ; std::_Ptr_cat<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCSENDITEM@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCSENDITEM@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCSENDITEM@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCSENDITEM@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>, COMDAT

; 1049 : 	while (_First != _Last)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b d1		 cmp	 edx, ecx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 17		 je	 SHORT $L278815
  00010	56		 push	 esi
$L278814:

; 1050 : 		*--_Dest = *--_Last;

  00011	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  00014	83 e9 08	 sub	 ecx, 8
  00017	83 e8 08	 sub	 eax, 8
  0001a	3b ca		 cmp	 ecx, edx
  0001c	89 30		 mov	 DWORD PTR [eax], esi
  0001e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00021	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00024	75 eb		 jne	 SHORT $L278814
  00026	5e		 pop	 esi
$L278815:

; 1051 : 	return (_Dest);
; 1052 : 	}

  00027	c3		 ret	 0
??$_Copy_backward_opt@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__JOINPLAYER@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__JOINPLAYER@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__JOINPLAYER@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<unsigned long *,unsigned long *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAKPAK@std@@YAPAKPAK00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<int *,int *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>, COMDAT

; 1049 : 	while (_First != _Last)

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00004	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  00008	53		 push	 ebx
  00009	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]
  0000d	3b da		 cmp	 ebx, edx
  0000f	74 19		 je	 SHORT $L278995
  00011	56		 push	 esi
  00012	57		 push	 edi
$L278994:

; 1050 : 		*--_Dest = *--_Last;

  00013	83 ea 24	 sub	 edx, 36			; 00000024H
  00016	83 e8 24	 sub	 eax, 36			; 00000024H
  00019	3b d3		 cmp	 edx, ebx
  0001b	b9 09 00 00 00	 mov	 ecx, 9
  00020	8b f2		 mov	 esi, edx
  00022	8b f8		 mov	 edi, eax
  00024	f3 a5		 rep movsd
  00026	75 eb		 jne	 SHORT $L278994
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$L278995:
  0002a	5b		 pop	 ebx

; 1051 : 	return (_Dest);
; 1052 : 	}

  0002b	c3		 ret	 0
??$_Copy_backward_opt@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>, COMDAT

; 1049 : 	while (_First != _Last)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b d1		 cmp	 edx, ecx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 24		 je	 SHORT $L279043
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L279042:

; 1050 : 		*--_Dest = *--_Last;

  00013	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  00016	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00019	3b ca		 cmp	 ecx, edx
  0001b	8b f1		 mov	 esi, ecx
  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001f	8b f8		 mov	 edi, eax
  00021	89 1f		 mov	 DWORD PTR [edi], ebx
  00023	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00026	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00029	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	75 e2		 jne	 SHORT $L279042
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
$L279043:

; 1051 : 	return (_Dest);
; 1052 : 	}

  00034	c3		 ret	 0
??$_Copy_backward_opt@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>, COMDAT

; 1049 : 	while (_First != _Last)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b d1		 cmp	 edx, ecx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 24		 je	 SHORT $L279183
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L279182:

; 1050 : 		*--_Dest = *--_Last;

  00013	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  00016	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00019	3b ca		 cmp	 ecx, edx
  0001b	8b f1		 mov	 esi, ecx
  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001f	8b f8		 mov	 edi, eax
  00021	89 1f		 mov	 DWORD PTR [edi], ebx
  00023	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00026	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00029	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002c	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002f	75 e2		 jne	 SHORT $L279182
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
$L279183:

; 1051 : 	return (_Dest);
; 1052 : 	}

  00034	c3		 ret	 0
??$_Copy_backward_opt@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__GCRESULTVALUEGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__GCRESULTVALUEGUILD *,CGuildCombat::__GCRESULTVALUEGUILD *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__GCRESULTVALUEGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__GCRESULTVALUEGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__GCRESULTVALUEGUILD *,CGuildCombat::__GCRESULTVALUEGUILD *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__GCRESULTVALUEGUILD@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__GCRESULTVALUEGUILD *,CGuildCombat::__GCRESULTVALUEGUILD *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU__GCRESULTVALUEPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z ; std::_Ptr_cat<CGuildCombat::__GCRESULTVALUEPLAYER *,CGuildCombat::__GCRESULTVALUEPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@PAU__GCRESULTVALUEPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU__GCRESULTVALUEPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z PROC NEAR ; std::_Ptr_cat<CGuildCombat::__GCRESULTVALUEPLAYER *,CGuildCombat::__GCRESULTVALUEPLAYER *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAU__GCRESULTVALUEPLAYER@CGuildCombat@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z ENDP ; std::_Ptr_cat<CGuildCombat::__GCRESULTVALUEPLAYER *,CGuildCombat::__GCRESULTVALUEPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>, COMDAT

; 1049 : 	while (_First != _Last)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b d1		 cmp	 edx, ecx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 36		 je	 SHORT $L279337
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L279336:

; 1050 : 		*--_Dest = *--_Last;

  00013	83 e9 18	 sub	 ecx, 24			; 00000018H
  00016	83 e8 18	 sub	 eax, 24			; 00000018H
  00019	3b ca		 cmp	 ecx, edx
  0001b	8b f1		 mov	 esi, ecx
  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001f	8b f8		 mov	 edi, eax
  00021	89 1f		 mov	 DWORD PTR [edi], ebx
  00023	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00026	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00029	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002c	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0002f	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00032	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00035	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00038	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  0003b	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  0003e	89 77 14	 mov	 DWORD PTR [edi+20], esi
  00041	75 d0		 jne	 SHORT $L279336
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
$L279337:

; 1051 : 	return (_Dest);
; 1052 : 	}

  00046	c3		 ret	 0
??$_Copy_backward_opt@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned long,unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<unsigned long,unsigned long>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@KK@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned long,unsigned long>
_TEXT	ENDS
PUBLIC	??$fill_n@PAKIK@std@@YAXPAKIABK@Z		; std::fill_n<unsigned long *,unsigned int,unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill_n@PAKIK@std@@YAXPAKIABK@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAKIK@std@@YAXPAKIABK@Z PROC NEAR		; std::fill_n<unsigned long *,unsigned int,unsigned long>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L279595
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L279593:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L279593
  0001b	5e		 pop	 esi
$L279595:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAKIK@std@@YAXPAKIABK@Z ENDP			; std::fill_n<unsigned long *,unsigned int,unsigned long>
_TEXT	ENDS
PUBLIC	??$fill_n@PAHIH@std@@YAXPAHIABH@Z		; std::fill_n<int *,unsigned int,int>
; Function compile flags: /Ogty
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAHIH@std@@YAXPAHIABH@Z PROC NEAR		; std::fill_n<int *,unsigned int,int>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L279599
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L279597:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L279597
  0001b	5e		 pop	 esi
$L279599:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAHIH@std@@YAXPAHIABH@Z ENDP			; std::fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@@Z ; std::fill_n<CGuildCombat::__JOINPLAYER * *,unsigned int,CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@@Z PROC NEAR ; std::fill_n<CGuildCombat::__JOINPLAYER * *,unsigned int,CGuildCombat::__JOINPLAYER *>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L279603
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L279601:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L279601
  0001b	5e		 pop	 esi
$L279603:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@@Z ENDP ; std::fill_n<CGuildCombat::__JOINPLAYER * *,unsigned int,CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@@Z ; std::fill_n<CGuildCombat::__GuildCombatMember * *,unsigned int,CGuildCombat::__GuildCombatMember *>
; Function compile flags: /Ogty
;	COMDAT ??$fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@@Z PROC NEAR ; std::fill_n<CGuildCombat::__GuildCombatMember * *,unsigned int,CGuildCombat::__GuildCombatMember *>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L279607
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L279605:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L279605
  0001b	5e		 pop	 esi
$L279607:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@@Z ENDP ; std::fill_n<CGuildCombat::__GuildCombatMember * *,unsigned int,CGuildCombat::__GuildCombatMember *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<int,int>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GuildCombatMember *,CGuildCombat::__GuildCombatMember *>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_copy@PAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CGuildCombat::__GuildCombatMember *,CGuildCombat::__GuildCombatMember *>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@PAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGuildCombat::__GuildCombatMember *,CGuildCombat::__GuildCombatMember *>
_TEXT	ENDS
PUBLIC	??$_Construct@U__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@ABU12@@Z ; std::_Construct<CGuildCombat::__GCGETPOINT,CGuildCombat::__GCGETPOINT>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@U__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@ABU12@@Z PROC NEAR ; std::_Construct<CGuildCombat::__GCGETPOINT,CGuildCombat::__GCGETPOINT>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	57		 push	 edi

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00001	8b 7c 24 08	 mov	 edi, DWORD PTR __Ptr$[esp]
  00005	85 ff		 test	 edi, edi
  00007	74 0d		 je	 SHORT $L282705
  00009	56		 push	 esi
  0000a	8b 74 24 10	 mov	 esi, DWORD PTR __Val$[esp+4]
  0000e	b9 09 00 00 00	 mov	 ecx, 9
  00013	f3 a5		 rep movsd
  00015	5e		 pop	 esi
$L282705:
  00016	5f		 pop	 edi

; 43   : 	}

  00017	c3		 ret	 0
??$_Construct@U__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@ABU12@@Z ENDP ; std::_Construct<CGuildCombat::__GCGETPOINT,CGuildCombat::__GCGETPOINT>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__GCGETPOINT@CGuildCombat@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__GCGETPOINT>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__GCGETPOINT@CGuildCombat@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__GCGETPOINT@CGuildCombat@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__GCGETPOINT>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__GCGETPOINT@CGuildCombat@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__GCGETPOINT>
_TEXT	ENDS
PUBLIC	??$_Construct@U__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@ABU12@@Z ; std::_Construct<CGuildCombat::__GCPLAYERPOINT,CGuildCombat::__GCPLAYERPOINT>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@U__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@ABU12@@Z PROC NEAR ; std::_Construct<CGuildCombat::__GCPLAYERPOINT,CGuildCombat::__GCPLAYERPOINT>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 14		 je	 SHORT $L282717
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L282717:

; 43   : 	}

  0001c	c3		 ret	 0
??$_Construct@U__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@ABU12@@Z ENDP ; std::_Construct<CGuildCombat::__GCPLAYERPOINT,CGuildCombat::__GCPLAYERPOINT>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__GCPLAYERPOINT>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__GCPLAYERPOINT>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__GCPLAYERPOINT@CGuildCombat@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__GCPLAYERPOINT>
_TEXT	ENDS
PUBLIC	??$_Construct@U__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@ABU12@@Z ; std::_Construct<CGuildCombat::__GCSENDITEM,CGuildCombat::__GCSENDITEM>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@U__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@ABU12@@Z PROC NEAR ; std::_Construct<CGuildCombat::__GCSENDITEM,CGuildCombat::__GCSENDITEM>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 14		 je	 SHORT $L282729
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L282729:

; 43   : 	}

  0001c	c3		 ret	 0
??$_Construct@U__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@ABU12@@Z ENDP ; std::_Construct<CGuildCombat::__GCSENDITEM,CGuildCombat::__GCSENDITEM>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__GCSENDITEM@CGuildCombat@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__GCSENDITEM>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__GCSENDITEM@CGuildCombat@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__GCSENDITEM@CGuildCombat@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__GCSENDITEM>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__GCSENDITEM@CGuildCombat@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__GCSENDITEM>
_TEXT	ENDS
PUBLIC	??$_Construct@U__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@ABU12@@Z ; std::_Construct<CGuildCombat::__REQUESTGUILD,CGuildCombat::__REQUESTGUILD>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@U__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@ABU12@@Z PROC NEAR ; std::_Construct<CGuildCombat::__REQUESTGUILD,CGuildCombat::__REQUESTGUILD>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 0e		 je	 SHORT $L282741
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L282741:

; 43   : 	}

  00016	c3		 ret	 0
??$_Construct@U__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@ABU12@@Z ENDP ; std::_Construct<CGuildCombat::__REQUESTGUILD,CGuildCombat::__REQUESTGUILD>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__REQUESTGUILD>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__REQUESTGUILD>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__REQUESTGUILD@CGuildCombat@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__REQUESTGUILD>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__GCRESULTVALUEGUILD>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__GCRESULTVALUEGUILD>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__GCRESULTVALUEGUILD>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__GCRESULTVALUEPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__GCRESULTVALUEPLAYER>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__GCRESULTVALUEPLAYER>
_TEXT	ENDS
PUBLIC	??$_Construct@U__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@ABU12@@Z ; std::_Construct<CGuildCombat::__JOINPLAYER,CGuildCombat::__JOINPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??$_Construct@U__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@ABU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@ABU12@@Z PROC NEAR ; std::_Construct<CGuildCombat::__JOINPLAYER,CGuildCombat::__JOINPLAYER>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 26		 je	 SHORT $L282759
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001f	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00022	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00025	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00028	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002b	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$L282759:

; 43   : 	}

  0002e	c3		 ret	 0
??$_Construct@U__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@ABU12@@Z ENDP ; std::_Construct<CGuildCombat::__JOINPLAYER,CGuildCombat::__JOINPLAYER>
_TEXT	ENDS
PUBLIC	??$_Destroy@U__JOINPLAYER@CGuildCombat@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@@Z ; std::_Destroy<CGuildCombat::__JOINPLAYER>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U__JOINPLAYER@CGuildCombat@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U__JOINPLAYER@CGuildCombat@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::_Destroy<CGuildCombat::__JOINPLAYER>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U__JOINPLAYER@CGuildCombat@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::_Destroy<CGuildCombat::__JOINPLAYER>
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
EXTRN	__fltused:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 300  :     x = fx;
; 301  :     y = fy;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _fy$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _fx$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 302  :     z = fz;

  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _fz$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 303  : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0_LogItemInfo@@QAE@XZ				; _LogItemInfo::_LogItemInfo
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\cmnhdr.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT
??0_LogItemInfo@@QAE@XZ PROC NEAR			; _LogItemInfo::_LogItemInfo, COMDAT
; _this$ = ecx

; 641  : 	_LogItemInfo()

  00000	8b c1		 mov	 eax, ecx
  00002	56		 push	 esi

; 642  : 	{
; 643  : 		Action = _T("");
; 644  : 		SendName = _T("");
; 645  : 		RecvName = _T("");
; 646  : 		WorldId = Gold = Gold2 = 0;
; 647  : 		Negudo = 0;
; 648  : 		MaxNegudo = 0;
; 649  : 		ItemNo = 0;
; 650  : 		//ItemName = _T("");
; 651  : 		::memset( szItemName, 0, sizeof(szItemName) );

  00003	33 d2		 xor	 edx, edx
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00012	33 c9		 xor	 ecx, ecx
  00014	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00017	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001d	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00020	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00023	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00026	8d 70 24	 lea	 esi, DWORD PTR [eax+36]
  00029	89 16		 mov	 DWORD PTR [esi], edx
  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0002e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00031	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00034	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00037	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0003a	89 56 18	 mov	 DWORD PTR [esi+24], edx
  0003d	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 652  : 		itemNumber = 0;

  00040	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 653  : 		nAbilityOption = 0;

  00043	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 654  : 		Gold_1 = 0;

  00046	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 655  : 		nSlot = 100;
; 656  : 		nSlot1 = 100;
; 657  : 		nItemResist = 0;

  00049	89 48 58	 mov	 DWORD PTR [eax+88], ecx

; 658  : 		nResistAbilityOption = 0;

  0004c	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 659  : 		m_bCharged = FALSE;

  0004f	89 48 60	 mov	 DWORD PTR [eax+96], ecx

; 660  : 		m_dwKeepTime = 0;

  00052	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 661  : #if __VER >= 11 // __SYS_IDENTIFY
; 662  : 		m_iRandomOptItemId = 0;

  00055	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00058	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 663  : #else	//__SYS_IDENTIFY
; 664  : 		m_nRandomOptItemId = 0;
; 665  : #endif	// __SYS_IDENTIFY
; 666  : #if __VER >= 12 // __EXT_PIERCING
; 667  : 		nPiercedSize = 0;

  0005b	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  0005e	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00063	89 50 50	 mov	 DWORD PTR [eax+80], edx
  00066	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 668  : //		for( int i=0; i<MAX_PIERCING_WEAPON; i++ )
; 669  : //			adwItemId[i] = 0;
; 670  : 		memset( adwItemId, 0, sizeof(adwItemId) );

  00069	33 d2		 xor	 edx, edx
  0006b	8d 70 74	 lea	 esi, DWORD PTR [eax+116]
  0006e	89 16		 mov	 DWORD PTR [esi], edx
  00070	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00073	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00076	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00079	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0007c	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0007f	89 56 18	 mov	 DWORD PTR [esi+24], edx
  00082	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  00085	89 56 20	 mov	 DWORD PTR [esi+32], edx
  00088	89 56 24	 mov	 DWORD PTR [esi+36], edx

; 671  : 		nUMPiercedSize = 0;

  0008b	89 88 9c 00 00
	00		 mov	 DWORD PTR [eax+156], ecx

; 672  : //		for( i=0; i<MAX_PIERCING_ULTIMATE; i++ )
; 673  : //	adwUMItemId[i] = 0;
; 674  : 		memset( adwUMItemId, 0, sizeof(adwUMItemId) );

  00091	8d b0 a0 00 00
	00		 lea	 esi, DWORD PTR [eax+160]
  00097	89 16		 mov	 DWORD PTR [esi], edx
  00099	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0009c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009f	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000a2	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 675  : #else // __EXT_PIERCING
; 676  : 		nPiercedSize = 0;
; 677  : 		adwItemId0 = 0;
; 678  : 		adwItemId1 = 0;
; 679  : 		adwItemId2 = 0;
; 680  : 		adwItemId3 = 0;
; 681  : #if __VER >= 9 // __ULTIMATE
; 682  : 		adwItemId4 = 0;
; 683  : #endif // __ULTIMATE
; 684  : #endif // __EXT_PIERCING
; 685  : #if __VER >= 9 // __PET_0410
; 686  : 		nPetKind = 0;

  000a5	88 88 b4 00 00
	00		 mov	 BYTE PTR [eax+180], cl

; 687  : 		nPetLevel = 0;

  000ab	88 88 b5 00 00
	00		 mov	 BYTE PTR [eax+181], cl

; 688  : 		dwPetExp = 0;

  000b1	89 88 b8 00 00
	00		 mov	 DWORD PTR [eax+184], ecx

; 689  : 		wPetEnergy = 0;

  000b7	66 89 88 bc 00
	00 00		 mov	 WORD PTR [eax+188], cx

; 690  : 		wPetLife = 0;

  000be	66 89 88 be 00
	00 00		 mov	 WORD PTR [eax+190], cx

; 691  : 		nPetAL_D = 0;

  000c5	88 88 c0 00 00
	00		 mov	 BYTE PTR [eax+192], cl

; 692  : 		nPetAL_C = 0;

  000cb	88 88 c1 00 00
	00		 mov	 BYTE PTR [eax+193], cl

; 693  : 		nPetAL_B = 0;

  000d1	88 88 c2 00 00
	00		 mov	 BYTE PTR [eax+194], cl

; 694  : 		nPetAL_A = 0;

  000d7	88 88 c3 00 00
	00		 mov	 BYTE PTR [eax+195], cl

; 695  : 		nPetAL_S = 0;

  000dd	88 88 c4 00 00
	00		 mov	 BYTE PTR [eax+196], cl
  000e3	5e		 pop	 esi

; 696  : #endif // __PET_0410
; 697  : 	}

  000e4	c3		 ret	 0
??0_LogItemInfo@@QAE@XZ ENDP				; _LogItemInfo::_LogItemInfo
_TEXT	ENDS
PUBLIC	??1CTimer@@UAE@XZ				; CTimer::~CTimer
PUBLIC	??_7CTimer@@6B@					; CTimer::`vftable'
PUBLIC	??_GCTimer@@UAEPAXI@Z				; CTimer::`scalar deleting destructor'
EXTRN	?Reset@CTimer@@UAEXXZ:NEAR			; CTimer::Reset
EXTRN	?Over@CTimer@@UAEHXZ:NEAR			; CTimer::Over
EXTRN	??_ECTimer@@UAEPAXI@Z:NEAR			; CTimer::`vector deleting destructor'
;	COMDAT ??_7CTimer@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\timer.h
CONST	SEGMENT
??_7CTimer@@6B@ DD FLAT:??_ECTimer@@UAEPAXI@Z		; CTimer::`vftable'
	DD	FLAT:?Reset@CTimer@@UAEXXZ
	DD	FLAT:?Over@CTimer@@UAEHXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1CTimer@@UAE@XZ
_TEXT	SEGMENT
??1CTimer@@UAE@XZ PROC NEAR				; CTimer::~CTimer, COMDAT
; _this$ = ecx

; 19   : 	virtual ~CTimer()	{}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CTimer@@6B@
  00006	c3		 ret	 0
??1CTimer@@UAE@XZ ENDP					; CTimer::~CTimer
_TEXT	ENDS
PUBLIC	?IsTimeOut@CTimer@@QAEHXZ			; CTimer::IsTimeOut
; Function compile flags: /Ogty
;	COMDAT ?IsTimeOut@CTimer@@QAEHXZ
_TEXT	SEGMENT
?IsTimeOut@CTimer@@QAEHXZ PROC NEAR			; CTimer::IsTimeOut, COMDAT
; _this$ = ecx

; 28   : 	BOOL	IsTimeOut( void )	{	return Over();	}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 08	 jmp	 DWORD PTR [eax+8]
?IsTimeOut@CTimer@@QAEHXZ ENDP				; CTimer::IsTimeOut
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTimer@@UAEPAXI@Z PROC NEAR				; CTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTimer@@6B@
  0000e	74 09		 je	 SHORT $L282790
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$L282790:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_GCTimer@@UAEPAXI@Z ENDP				; CTimer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	8b 44 24 0c	 mov	 eax, DWORD PTR ___n$[esp-4]
  00004	48		 dec	 eax
  00005	78 26		 js	 SHORT $L171564
  00007	53		 push	 ebx
  00008	8b 5c 24 14	 mov	 ebx, DWORD PTR ___f$[esp]
  0000c	55		 push	 ebp
  0000d	8b 6c 24 10	 mov	 ebp, DWORD PTR ___s$[esp+4]
  00011	56		 push	 esi
  00012	8b 74 24 10	 mov	 esi, DWORD PTR ___t$[esp+8]
  00016	57		 push	 edi
  00017	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$L171563:
  00020	8b ce		 mov	 ecx, esi
  00022	ff d3		 call	 ebx
  00024	03 f5		 add	 esi, ebp
  00026	4f		 dec	 edi
  00027	75 f7		 jne	 SHORT $L171563
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	5b		 pop	 ebx
$L171564:
  0002d	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?xRand@@YAKXZ					; xRand
EXTRN	?g_next@@3KA:DWORD				; g_next
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\xutil.h
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT
?xRand@@YAKXZ PROC NEAR					; xRand, COMDAT

; 16   : 	g_next = g_next * 1103515245 + 12345;// + nRandomSeed[ i++ ];

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next

; 17   : 	return g_next;	//   .
; 18   : }

  00015	c3		 ret	 0
?xRand@@YAKXZ ENDP					; xRand
_TEXT	ENDS
PUBLIC	?xRandom@@YAKK@Z				; xRandom
; Function compile flags: /Ogty
;	COMDAT ?xRandom@@YAKK@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
?xRandom@@YAKK@Z PROC NEAR				; xRandom, COMDAT

; 22   : 	return  xRand() % num;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  00015	33 d2		 xor	 edx, edx
  00017	f7 74 24 04	 div	 DWORD PTR _num$[esp-4]
  0001b	8b c2		 mov	 eax, edx

; 23   : }

  0001d	c3		 ret	 0
?xRandom@@YAKK@Z ENDP					; xRandom
_TEXT	ENDS
PUBLIC	?IsDelete@CObj@@QAEHXZ				; CObj::IsDelete
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT
?IsDelete@CObj@@QAEHXZ PROC NEAR			; CObj::IsDelete, COMDAT
; _this$ = ecx

; 180  : 	BOOL			IsDelete()	{ return (m_dwFlags & OBJ_FLAG_DELETE);  }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e0 01	 and	 eax, 1
  00006	c3		 ret	 0
?IsDelete@CObj@@QAEHXZ ENDP				; CObj::IsDelete
_TEXT	ENDS
PUBLIC	?GetWorld@CObj@@QAEPAVCWorld@@XZ		; CObj::GetWorld
; Function compile flags: /Ogty
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT
?GetWorld@CObj@@QAEPAVCWorld@@XZ PROC NEAR		; CObj::GetWorld, COMDAT
; _this$ = ecx

; 221  : 	CWorld*			GetWorld()	{ return m_pWorld; }

  00000	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00006	c3		 ret	 0
?GetWorld@CObj@@QAEPAVCWorld@@XZ ENDP			; CObj::GetWorld
_TEXT	ENDS
PUBLIC	?IsValidObj@@YAHPAVCObj@@@Z			; IsValidObj
; Function compile flags: /Ogty
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?IsValidObj@@YAHPAVCObj@@@Z PROC NEAR			; IsValidObj, COMDAT

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pObj$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 0c		 je	 SHORT $L282814
  00008	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0000c	75 06		 jne	 SHORT $L282814
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 328  : }

  00013	c3		 ret	 0
$L282814:

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00014	33 c0		 xor	 eax, eax

; 328  : }

  00016	c3		 ret	 0
?IsValidObj@@YAHPAVCObj@@@Z ENDP			; IsValidObj
_TEXT	ENDS
PUBLIC	?LOG_RANGE@@YAXPBDHHH@Z				; LOG_RANGE
PUBLIC	??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ ; `string'
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	SEGMENT
??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ DB '%'
	DB	's min:%d, max:%d, index:%d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT
_szMsg$ = 8						; size = 4
_nMin$ = 12						; size = 4
_nMax$ = 16						; size = 4
_nIndex$ = 20						; size = 4
?LOG_RANGE@@YAXPBDHHH@Z PROC NEAR			; LOG_RANGE, COMDAT

; 559  : 	LPCTSTR szErr = Error( _T( "%s min:%d, max:%d, index:%d" ), szMsg, nMin, nMax, nIndex ); 

  00000	8b 44 24 10	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMax$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR _nMin$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR _szMsg$[esp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00019	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 560  : 	ADDERRORMSG( szErr ); 
; 561  : }

  00021	c3		 ret	 0
?LOG_RANGE@@YAXPBDHHH@Z ENDP				; LOG_RANGE
_TEXT	ENDS
PUBLIC	?LOG_CALLSTACK@@YAXXZ				; LOG_CALLSTACK
; Function compile flags: /Ogty
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT
?LOG_CALLSTACK@@YAXXZ PROC NEAR				; LOG_CALLSTACK, COMDAT

; 565  : #ifdef _DEBUG
; 566  : 	__asm int 3
; 567  : #endif
; 568  : 
; 569  : #if defined(__INTERNALSERVER)
; 570  : 	int *p = NULL;		//    
; 571  : 	*p = 1;
; 572  : #endif
; 573  : }

  00000	c3		 ret	 0
?LOG_CALLSTACK@@YAXXZ ENDP				; LOG_CALLSTACK
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 48   : 	BOOL			IsEmpty() { return m_dwItemId ? FALSE : TRUE; }

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@J@Z				; CAr::operator<<
EXTRN	?CheckBuf@CAr@@QAEXI@Z:NEAR			; CAr::CheckBuf
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
??6CAr@@QAEAAV0@J@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 113  : 	{ CheckBuf( sizeof(LONG) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 114  : 		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _l$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@J@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@K@Z				; CAr::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
??6CAr@@QAEAAV0@K@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 116  : 	{ CheckBuf( sizeof(DWORD) );

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf

; 117  : 		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; }

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _dw$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@K@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	?GetPartyId@CMover@@QAEKXZ			; CMover::GetPartyId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
;	COMDAT ?GetPartyId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPartyId@CMover@@QAEKXZ PROC NEAR			; CMover::GetPartyId, COMDAT
; _this$ = ecx

; 1025 : 	u_long			GetPartyId() { return m_idparty; }

  00000	8b 81 18 07 00
	00		 mov	 eax, DWORD PTR [ecx+1816]
  00006	c3		 ret	 0
?GetPartyId@CMover@@QAEKXZ ENDP				; CMover::GetPartyId
_TEXT	ENDS
PUBLIC	?SetMode@CMover@@QAEXK@Z			; CMover::SetMode
; Function compile flags: /Ogty
;	COMDAT ?SetMode@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?SetMode@CMover@@QAEXK@Z PROC NEAR			; CMover::SetMode, COMDAT
; _this$ = ecx

; 1027 : 	void			SetMode( DWORD dwMode )		{ m_dwMode |= dwMode; }	//  V

  00000	8b 91 44 02 00
	00		 mov	 edx, DWORD PTR [ecx+580]
  00006	8b 44 24 04	 mov	 eax, DWORD PTR _dwMode$[esp-4]
  0000a	0b d0		 or	 edx, eax
  0000c	89 91 44 02 00
	00		 mov	 DWORD PTR [ecx+580], edx
  00012	c2 04 00	 ret	 4
?SetMode@CMover@@QAEXK@Z ENDP				; CMover::SetMode
_TEXT	ENDS
PUBLIC	?SetNotMode@CMover@@QAEXK@Z			; CMover::SetNotMode
; Function compile flags: /Ogty
;	COMDAT ?SetNotMode@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?SetNotMode@CMover@@QAEXK@Z PROC NEAR			; CMover::SetNotMode, COMDAT
; _this$ = ecx

; 1028 : 	void			SetNotMode( DWORD dwMode )	{ m_dwMode &= (~dwMode); } //  V

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwMode$[esp-4]
  00004	8b 91 44 02 00
	00		 mov	 edx, DWORD PTR [ecx+580]
  0000a	f7 d0		 not	 eax
  0000c	23 d0		 and	 edx, eax
  0000e	89 91 44 02 00
	00		 mov	 DWORD PTR [ecx+580], edx
  00014	c2 04 00	 ret	 4
?SetNotMode@CMover@@QAEXK@Z ENDP			; CMover::SetNotMode
_TEXT	ENDS
PUBLIC	?IsRegionAttr@CMover@@QAEHK@Z			; CMover::IsRegionAttr
; Function compile flags: /Ogty
;	COMDAT ?IsRegionAttr@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwAttribite$ = 8					; size = 4
?IsRegionAttr@CMover@@QAEHK@Z PROC NEAR			; CMover::IsRegionAttr, COMDAT
; _this$ = ecx

; 1066 : 	BOOL			IsRegionAttr( DWORD dwAttribite ) { return ( m_dwRegionAttr & dwAttribite ) == dwAttribite ? TRUE : FALSE; }

  00000	8b 81 d4 02 00
	00		 mov	 eax, DWORD PTR [ecx+724]
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwAttribite$[esp-4]
  0000a	23 c1		 and	 eax, ecx
  0000c	2b c1		 sub	 eax, ecx
  0000e	f7 d8		 neg	 eax
  00010	1b c0		 sbb	 eax, eax
  00012	40		 inc	 eax
  00013	c2 04 00	 ret	 4
?IsRegionAttr@CMover@@QAEHK@Z ENDP			; CMover::IsRegionAttr
_TEXT	ENDS
PUBLIC	?GetLevel@CMover@@QAEHXZ			; CMover::GetLevel
; Function compile flags: /Ogty
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetLevel@CMover@@QAEHXZ PROC NEAR			; CMover::GetLevel, COMDAT
; _this$ = ecx

; 1159 : 	int				GetLevel() { return m_nLevel; }

  00000	8b 81 e0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1504]
  00006	c3		 ret	 0
?GetLevel@CMover@@QAEHXZ ENDP				; CMover::GetLevel
_TEXT	ENDS
PUBLIC	?GetExp1@CMover@@QAE_JXZ			; CMover::GetExp1
; Function compile flags: /Ogty
;	COMDAT ?GetExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT
?GetExp1@CMover@@QAE_JXZ PROC NEAR			; CMover::GetExp1, COMDAT
; _this$ = ecx

; 1162 : 	EXPINTEGER		GetExp1()	{	return m_nExp1;	}

  00000	8b 81 e8 05 00
	00		 mov	 eax, DWORD PTR [ecx+1512]
  00006	8b 91 ec 05 00
	00		 mov	 edx, DWORD PTR [ecx+1516]
  0000c	c3		 ret	 0
?GetExp1@CMover@@QAE_JXZ ENDP				; CMover::GetExp1
_TEXT	ENDS
PUBLIC	?IsMode@CMover@@QAEHK@Z				; CMover::IsMode
EXTRN	?GetAdjParam@CMover@@QAEHH@Z:NEAR		; CMover::GetAdjParam
; Function compile flags: /Ogty
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?IsMode@CMover@@QAEHK@Z PROC NEAR			; CMover::IsMode, COMDAT
; _this$ = ecx

; 1762 : { 

  00000	53		 push	 ebx

; 1763 : #ifdef __HACK_0516
; 1764 : 	switch( dwMode )
; 1765 : 	{
; 1766 : 		case MATCHLESS_MODE:		//  
; 1767 : 		case ONEKILL_MODE:		//  
; 1768 : 		case MATCHLESS2_MODE:	//  2
; 1769 : 			if( m_dwAuthorization == AUTH_GENERAL )
; 1770 : 				return FALSE;
; 1771 : 			break;
; 1772 : 	}
; 1773 : #endif	// __HACK_0516
; 1774 : 	if( (dwMode & TRANSPARENT_MODE) )	//   

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _dwMode$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 16		 je	 SHORT $L212480

; 1775 : 		if( GetAdjParam(DST_CHRSTATE) & CHS_INVISIBILITY )	//  ?

  0000d	6a 40		 push	 64			; 00000040H
  0000f	e8 00 00 00 00	 call	 ?GetAdjParam@CMover@@QAEHH@Z ; CMover::GetAdjParam
  00014	f6 c4 04	 test	 ah, 4
  00017	74 0a		 je	 SHORT $L212480
  00019	5e		 pop	 esi

; 1776 : 			return TRUE;

  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	5b		 pop	 ebx

; 1778 : }	

  00020	c2 04 00	 ret	 4
$L212480:

; 1777 : 	return ( ( m_dwMode & dwMode ) == dwMode ) ? TRUE : FALSE; 

  00023	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  00029	23 c3		 and	 eax, ebx
  0002b	2b c3		 sub	 eax, ebx
  0002d	f7 d8		 neg	 eax
  0002f	1b c0		 sbb	 eax, eax
  00031	5e		 pop	 esi
  00032	40		 inc	 eax
  00033	5b		 pop	 ebx

; 1778 : }	

  00034	c2 04 00	 ret	 4
?IsMode@CMover@@QAEHK@Z ENDP				; CMover::IsMode
_TEXT	ENDS
PUBLIC	?GetGold@CMover@@QAEHXZ				; CMover::GetGold
; Function compile flags: /Ogty
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetGold@CMover@@QAEHXZ PROC NEAR			; CMover::GetGold, COMDAT
; _this$ = ecx

; 1829 : 	int nGold = m_dwGold;
; 1830 : //	nGold -= m_vtInfo.TradeGetGold();
; 1831 : 	ASSERT( nGold >= 0 );
; 1832 : 	return nGold;

  00000	8b 81 84 16 00
	00		 mov	 eax, DWORD PTR [ecx+5764]

; 1833 : }

  00006	c3		 ret	 0
?GetGold@CMover@@QAEHXZ ENDP				; CMover::GetGold
_TEXT	ENDS
PUBLIC	?GetID@CWorld@@QAEKXZ				; CWorld::GetID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\world.h
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT
?GetID@CWorld@@QAEKXZ PROC NEAR				; CWorld::GetID, COMDAT
; _this$ = ecx

; 413  : 	DWORD			GetID()	{ return m_dwWorldID; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetID@CWorld@@QAEKXZ ENDP				; CWorld::GetID
_TEXT	ENDS
PUBLIC	??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ		; ATL::CSimpleStringT<char,0>::operator char const *
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::operator char const *, COMDAT
; _this$ = ecx

; 379  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 380  : 	}

  00002	c3		 ret	 0
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP		; ATL::CSimpleStringT<char,0>::operator char const *
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1109 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1110 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ	; CFixedArray<ItemProp>::GetSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ PROC NEAR	; CFixedArray<ItemProp>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ ENDP		; CFixedArray<ItemProp>::GetSize
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ	; CFixedArray<tagColorText>::GetSize
; Function compile flags: /Ogty
;	COMDAT ?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ PROC NEAR ; CFixedArray<tagColorText>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ ENDP	; CFixedArray<tagColorText>::GetSize
_TEXT	ENDS
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 510  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 511  : 	}

  00002	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
PUBLIC	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
; Function compile flags: /Ogty
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::StringLength, COMDAT

; 678  : 		if( psz == NULL )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _psz$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 01		 jne	 SHORT $L219971

; 683  : 	}

  00008	c3		 ret	 0
$L219971:

; 679  : 		{
; 680  : 			return( 0 );
; 681  : 		}
; 682  : 		return( int( strlen( psz ) ) );

  00009	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$L282879:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L282879
  00017	2b c2		 sub	 eax, edx

; 683  : 	}

  00019	c3		 ret	 0
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::StringLength
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
; Function compile flags: /Ogty
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  00005	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Ogty
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L219986
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L219986

; 794  : 			AtlThrow(E_INVALIDARG);
; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 797  : 		m_pszData[nLength] = 0;

  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 798  : 	}

  00018	c2 04 00	 ret	 4
$L219986:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L282893:
$L282892:
  00025	cc		 int	 3
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
EXTRN	?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z:NEAR ; AfxFindStringResourceHandle
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\afxstr.h
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance, COMDAT

; 45   : 		return( AfxFindStringResourceHandle( nID ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nID$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle

; 46   : 	}

  0000a	c3		 ret	 0
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
_TEXT	ENDS
PUBLIC	?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
EXTRN	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ:NEAR ; AfxGetStringManager
; Function compile flags: /Ogty
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 50   : 		return( AfxGetStringManager() );

  00000	e9 00 00 00 00	 jmp	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L282904
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  00009	c3		 ret	 0
$L282904:

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??R?$less@K@std@@QBE_NABK0@Z			; std::less<unsigned long>::operator()
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@K@std@@QBE_NABK0@Z PROC NEAR			; std::less<unsigned long>::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (_Left < _Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 54 24 08	 mov	 edx, DWORD PTR __Right$[esp-4]
  0000a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000c	1b c0		 sbb	 eax, eax
  0000e	f7 d8		 neg	 eax

; 140  : 		}

  00010	c2 08 00	 ret	 8
??R?$less@K@std@@QBE_NABK0@Z ENDP			; std::less<unsigned long>::operator()
_TEXT	ENDS
PUBLIC	??0?$allocator@K@std@@QAE@XZ			; std::allocator<unsigned long>::allocator<unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@XZ PROC NEAR			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC NEAR			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pData$[esp-4]
  00004	83 c0 10	 add	 eax, 16			; 00000010H
  00007	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00009	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ; ATL::ChTraitsCRT<char>::GetFormattedLength
EXTRN	__vscprintf:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetFormattedLength, COMDAT

; 408  : 		return _vscprintf( pszFormat, args );

  00000	e9 00 00 00 00	 jmp	 __vscprintf
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ENDP ; ATL::ChTraitsCRT<char>::GetFormattedLength
_TEXT	ENDS
PUBLIC	?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z	; ATL::ChTraitsCRT<char>::Format
EXTRN	_vsprintf:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT
_pszBuffer$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
_args$ = 16						; size = 4
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z PROC NEAR	; ATL::ChTraitsCRT<char>::Format, COMDAT

; 413  : 		return vsprintf( pszBuffer, pszFormat, args );

  00000	e9 00 00 00 00	 jmp	 _vsprintf
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z ENDP		; ATL::ChTraitsCRT<char>::Format
_TEXT	ENDS
PUBLIC	?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z ; ATL::ChTraitsCRT<char>::GetBaseTypeLength
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT
_pszSource$ = 8						; size = 4
_nLength$ = 12						; size = 4
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetBaseTypeLength, COMDAT

; 437  : 		// Returns required buffer length in XCHARs
; 438  : 		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, nLength, NULL, 0, NULL, NULL );

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR _nLength$[esp-4]
  0000a	8b 54 24 04	 mov	 edx, DWORD PTR _pszSource$[esp-4]
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	6a 00		 push	 0
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 439  : 	}

  00021	c3		 ret	 0
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z ENDP	; ATL::ChTraitsCRT<char>::GetBaseTypeLength
_TEXT	ENDS
PUBLIC	?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z ; ATL::ChTraitsCRT<char>::ConvertToBaseType
; Function compile flags: /Ogty
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_nDestLength$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nSrcLength$ = 20					; size = 4
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::ConvertToBaseType, COMDAT

; 452  : 		// nLen is in XCHARs
; 453  : 		::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nDestLength$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _pszDest$[esp-4]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR _nSrcLength$[esp-4]
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	8b 44 24 18	 mov	 eax, DWORD PTR _pszSrc$[esp+8]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 454  : 	}

  00027	c3		 ret	 0
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z ENDP ; ATL::ChTraitsCRT<char>::ConvertToBaseType
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L282957
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  00009	c3		 ret	 0
$L282957:

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@K@std@@QAE@ABV01@@Z		; std::allocator<unsigned long>::allocator<unsigned long>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@K@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@K@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@K@std@@QAEXPAKI@Z	; std::allocator<unsigned long>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXPAKI@Z PROC NEAR	; std::allocator<unsigned long>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@K@std@@QAEXPAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC NEAR	; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Left
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z ENDP ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nChars$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp]
  00009	8b c1		 mov	 eax, ecx
  0000b	57		 push	 edi
  0000c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pchDest$[esp+4]
  00010	c1 e9 02	 shr	 ecx, 2
  00013	f3 a5		 rep movsd
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	f3 a4		 rep movsb
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 654  : 	}

  0001e	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
; Function compile flags: /Ogty
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	e9 00 00 00 00	 jmp	 _memmove
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Ogty
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00000	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00005	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L283011:
$L283010:
  0000a	cc		 int	 3
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Ogty
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv181 = 8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 716  : 		CStringData* pOldData = GetData();

  00002	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00004	83 eb 10	 sub	 ebx, 16			; 00000010H
  00007	55		 push	 ebp

; 717  : 		int nOldLength = pOldData->nDataLength;

  00008	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$[esp+12], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0000f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 10	 call	 DWORD PTR [eax+16]
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _nLength$[esp+12]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	6a 01		 push	 1
  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	ff 12		 call	 DWORD PTR [edx]

; 719  : 		if( pNewData == NULL )

  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $L222762

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00028	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L283042:
$L222762:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0002d	3b ee		 cmp	 ebp, esi
  0002f	7d 02		 jge	 SHORT $L283016
  00031	8b f5		 mov	 esi, ebp
$L283016:
  00033	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  00036	8b d1		 mov	 edx, ecx
  00038	57		 push	 edi
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	89 7c 24 18	 mov	 DWORD PTR tv181[esp+16], edi
  00043	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00046	f3 a5		 rep movsd
  00048	8b ca		 mov	 ecx, edx
  0004a	83 e1 03	 and	 ecx, 3
  0004d	f3 a4		 rep movsb

; 725  : 		pNewData->nDataLength = nOldLength;

  0004f	89 68 04	 mov	 DWORD PTR [eax+4], ebp

; 726  : 		pOldData->Release();

  00052	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00055	83 c9 ff	 or	 ecx, -1
  00058	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0005c	49		 dec	 ecx
  0005d	85 c9		 test	 ecx, ecx
  0005f	5f		 pop	 edi
  00060	7f 08		 jg	 SHORT $L283032
  00062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	53		 push	 ebx
  00067	ff 52 04	 call	 DWORD PTR [edx+4]
$L283032:

; 727  : 		Attach( pNewData );

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR tv181[esp+12]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	5b		 pop	 ebx

; 728  : 	}

  00077	59		 pop	 ecx
  00078	c2 04 00	 ret	 4
$L283041:
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Ogty
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 777  : 		CStringData* pOldData = GetData();
; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nLength$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	83 e8 10	 sub	 eax, 16			; 00000010H
  00012	6a 01		 push	 1
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	ff 52 08	 call	 DWORD PTR [edx+8]

; 781  : 		if( pNewData == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L222771

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0001d	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L283058:
$L222771:

; 784  : 		}
; 785  : 		Attach( pNewData );

  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	5f		 pop	 edi
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	5e		 pop	 esi

; 786  : 	}

  00029	c2 04 00	 ret	 4
$L283057:
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00001	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  00004	83 fe 10	 cmp	 esi, 16			; 00000010H
  00007	57		 push	 edi
  00008	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0000b	72 04		 jb	 SHORT $L283067
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	eb 02		 jmp	 SHORT $L283068
$L283067:
  00011	8b d0		 mov	 edx, eax
$L283068:
  00013	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00017	3b fa		 cmp	 edi, edx
  00019	72 17		 jb	 SHORT $L222788
  0001b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0001e	72 02		 jb	 SHORT $L283075
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L283075:
  00022	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00025	03 c8		 add	 ecx, eax
  00027	3b cf		 cmp	 ecx, edi
  00029	76 07		 jbe	 SHORT $L222788
  0002b	5f		 pop	 edi

; 1497 : 		else
; 1498 : 			return (true);

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi

; 1499 : 		}

  0002f	c2 04 00	 ret	 4
$L222788:
  00032	5f		 pop	 edi

; 1496 : 			return (false);	// don't ask

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 1499 : 		}

  00036	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@K@std@@QBEIXZ		; std::allocator<unsigned long>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@K@std@@QBEIXZ PROC NEAR		; std::allocator<unsigned long>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@K@std@@QBEIXZ ENDP		; std::allocator<unsigned long>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC NEAR		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lmost
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 159  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Color
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Color, COMDAT

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00007	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Max
; Function compile flags: /Ogty
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Max, COMDAT

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  0000a	84 d2		 test	 dl, dl
  0000c	75 0e		 jne	 SHORT $L223707
  0000e	8b ff		 npad	 2
$L223706:

; 1036 : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00018	84 d2		 test	 dl, dl
  0001a	74 f4		 je	 SHORT $L223706
$L223707:

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0001c	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L223711
  0000d	8d 49 00	 npad	 3
$L223710:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L223710
$L223711:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rmost
; Function compile flags: /Ogty
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1049 : 		return (_Right(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Root
; Function compile flags: /Ogty
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate
; Function compile flags: /Ogty
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 02		 mov	 eax, DWORD PTR [edx]
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00008	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000b	89 32		 mov	 DWORD PTR [edx], esi

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  0000d	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L223719

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L223719:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0e		 jne	 SHORT $L223720

; 1077 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00032	5b		 pop	 ebx

; 1085 : 		}

  00033	c2 04 00	 ret	 4
$L223720:

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0e		 jne	 SHORT $L223722

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00041	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00042	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00045	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00048	5b		 pop	 ebx

; 1085 : 		}

  00049	c2 04 00	 ret	 4
$L223722:

; 1080 : 		else
; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0004c	89 01		 mov	 DWORD PTR [ecx], eax
  0004e	5e		 pop	 esi

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  0004f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  00052	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00055	5b		 pop	 ebx

; 1085 : 		}

  00056	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L224052

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L283291

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L283272
  0001d	8d 49 00	 npad	 3
$L283271:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L283271
$L283272:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L283291:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L224056
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L224055:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L224056

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L224055
$L224056:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L224052:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ; CFixedArray<ItemProp>::GetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z PROC NEAR ; CFixedArray<ItemProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224299

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224299:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ENDP ; CFixedArray<ItemProp>::GetAt
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z ; CFixedArray<tagColorText>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z PROC NEAR ; CFixedArray<tagColorText>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224363

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224363:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z ENDP ; CFixedArray<tagColorText>::GetAt
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC NEAR			; std::swap<char>, COMDAT

; 15   : 	_Ty _Tmp = _Left;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	56		 push	 esi

; 16   : 	_Left = _Right, _Right = _Tmp;

  00007	8b 74 24 0c	 mov	 esi, DWORD PTR __Right$[esp]
  0000b	8a 16		 mov	 dl, BYTE PTR [esi]
  0000d	88 10		 mov	 BYTE PTR [eax], dl
  0000f	88 0e		 mov	 BYTE PTR [esi], cl
  00011	5e		 pop	 esi

; 17   : 	}

  00012	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??$_Allocate@K@std@@YAPAKIPAK@Z			; std::_Allocate<unsigned long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@K@std@@YAPAKIPAK@Z PROC NEAR		; std::_Allocate<unsigned long>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@K@std@@YAPAKIPAK@Z ENDP			; std::_Allocate<unsigned long>
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC NEAR		; std::_Allocate<int>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z PROC NEAR ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ENDP ; std::_Destroy_range<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??0CEveSchool@@QAE@XZ				; CEveSchool::CEveSchool
EXTRN	?g_GuildMng@@3VCGuildMng@@A:BYTE		; g_GuildMng
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ??0CEveSchool@@QAE@XZ
_TEXT	SEGMENT
??0CEveSchool@@QAE@XZ PROC NEAR				; CEveSchool::CEveSchool, COMDAT
; _this$ = ecx

; 30   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 31   : 	m_pSchoolMng	= &g_GuildMng;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A ; g_GuildMng

; 32   : 	m_dwsbstart2	= GetTickCount();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000f	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax

; 33   : }

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	c3		 ret	 0
??0CEveSchool@@QAE@XZ ENDP				; CEveSchool::CEveSchool
_TEXT	ENDS
PUBLIC	?LoadPos@CEveSchool@@QAEHPBD@Z			; CEveSchool::LoadPos
EXTRN	??0CScanner@@QAE@H@Z:NEAR			; CScanner::CScanner
EXTRN	??1CScanner@@UAE@XZ:NEAR			; CScanner::~CScanner
EXTRN	?Load@CScanner@@QAEHPBDH@Z:NEAR			; CScanner::Load
EXTRN	?GetNumber@CScanner@@QAEHH@Z:NEAR		; CScanner::GetNumber
EXTRN	?GetFloat@CScanner@@QAEMH@Z:NEAR		; CScanner::GetFloat
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
xdata$x	SEGMENT
$T283383 DD	0ffffffffH
	DD	FLAT:$L283368
$T283377 DD	019930520H
	DD	01H
	DD	FLAT:$T283383
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ?LoadPos@CEveSchool@@QAEHPBD@Z
_TEXT	SEGMENT
_vPos$ = -2140						; size = 12
_s$ = -2128						; size = 2112
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lpszFileName$ = 8					; size = 4
?LoadPos@CEveSchool@@QAEHPBD@Z PROC NEAR		; CEveSchool::LoadPos, COMDAT
; _this$ = ecx

; 239  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?LoadPos@CEveSchool@@QAEHPBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 50 08 00
	00		 sub	 esp, 2128		; 00000850H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	56		 push	 esi
  00023	8b b4 24 64 08
	00 00		 mov	 esi, DWORD PTR _lpszFileName$[esp+2140]
  0002a	57		 push	 edi
  0002b	8b f9		 mov	 edi, ecx

; 240  : 	CScanner s;

  0002d	6a 00		 push	 0
  0002f	8d 4c 24 18	 lea	 ecx, DWORD PTR _s$[esp+2152]
  00033	89 84 24 58 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2152], eax
  0003a	e8 00 00 00 00	 call	 ??0CScanner@@QAE@H@Z	; CScanner::CScanner

; 241  : 
; 242  : 	if( !s.Load( lpszFileName ) )

  0003f	6a 01		 push	 1
  00041	56		 push	 esi
  00042	8d 4c 24 1c	 lea	 ecx, DWORD PTR _s$[esp+2156]
  00046	c7 84 24 68 08
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+2164], 0
  00051	e8 00 00 00 00	 call	 ?Load@CScanner@@QAEHPBDH@Z ; CScanner::Load
  00056	85 c0		 test	 eax, eax

; 243  : 		return FALSE;

  00058	8d 4c 24 14	 lea	 ecx, DWORD PTR _s$[esp+2148]
  0005c	75 17		 jne	 SHORT $L268287
  0005e	c7 84 24 60 08
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+2156], -1
  00069	e8 00 00 00 00	 call	 ??1CScanner@@UAE@XZ	; CScanner::~CScanner
  0006e	33 c0		 xor	 eax, eax
  00070	e9 ba 00 00 00	 jmp	 $L268285
$L268287:

; 244  : 	
; 245  : 	u_long id;
; 246  : 	D3DXVECTOR3 vPos;
; 247  : 
; 248  : 	id	= s.GetNumber();

  00075	6a 00		 push	 0
  00077	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  0007c	8b f0		 mov	 esi, eax

; 249  : 	while( s.tok != FINISHED )

  0007e	83 bc 24 40 08
	00 00 15	 cmp	 DWORD PTR _s$[esp+4240], 21 ; 00000015H
  00086	0f 84 8a 00 00
	00		 je	 $L268293
  0008c	8d 64 24 00	 npad	 4
$L268292:

; 250  : 	{
; 251  : 		vPos.x	= s.GetFloat();

  00090	6a 00		 push	 0
  00092	8d 4c 24 18	 lea	 ecx, DWORD PTR _s$[esp+2152]
  00096	e8 00 00 00 00	 call	 ?GetFloat@CScanner@@QAEMH@Z ; CScanner::GetFloat
  0009b	d9 5c 24 08	 fstp	 DWORD PTR _vPos$[esp+2148]

; 252  : 		vPos.y	= s.GetFloat();

  0009f	6a 00		 push	 0
  000a1	8d 4c 24 18	 lea	 ecx, DWORD PTR _s$[esp+2152]
  000a5	e8 00 00 00 00	 call	 ?GetFloat@CScanner@@QAEMH@Z ; CScanner::GetFloat
  000aa	d9 5c 24 0c	 fstp	 DWORD PTR _vPos$[esp+2152]

; 253  : 		vPos.z	= s.GetFloat();

  000ae	6a 00		 push	 0
  000b0	8d 4c 24 18	 lea	 ecx, DWORD PTR _s$[esp+2152]
  000b4	e8 00 00 00 00	 call	 ?GetFloat@CScanner@@QAEMH@Z ; CScanner::GetFloat
  000b9	d9 5c 24 10	 fstp	 DWORD PTR _vPos$[esp+2156]

; 254  : 
; 255  : 		if( id > MAX_SCHOOL || id < 1 )

  000bd	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  000c0	77 22		 ja	 SHORT $L268295
  000c2	83 fe 01	 cmp	 esi, 1
  000c5	72 1d		 jb	 SHORT $L268295

; 257  : 		else
; 258  : 			m_avPos[id-1]	= vPos;

  000c7	8b 54 24 08	 mov	 edx, DWORD PTR _vPos$[esp+2148]
  000cb	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000ce	8d 4c 87 f8	 lea	 ecx, DWORD PTR [edi+eax*4-8]
  000d2	8b 44 24 0c	 mov	 eax, DWORD PTR _vPos$[esp+2152]
  000d6	89 11		 mov	 DWORD PTR [ecx], edx
  000d8	8b 54 24 10	 mov	 edx, DWORD PTR _vPos$[esp+2156]
  000dc	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000df	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000e2	eb 17		 jmp	 SHORT $L268296
$L268295:

; 256  : 			m_vDefault	= vPos;

  000e4	8b 4c 24 08	 mov	 ecx, DWORD PTR _vPos$[esp+2148]
  000e8	8b 54 24 0c	 mov	 edx, DWORD PTR _vPos$[esp+2152]
  000ec	8d 47 7c	 lea	 eax, DWORD PTR [edi+124]
  000ef	89 08		 mov	 DWORD PTR [eax], ecx
  000f1	8b 4c 24 10	 mov	 ecx, DWORD PTR _vPos$[esp+2156]
  000f5	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000f8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L268296:

; 259  : 		id	= s.GetNumber();

  000fb	6a 00		 push	 0
  000fd	8d 4c 24 18	 lea	 ecx, DWORD PTR _s$[esp+2152]
  00101	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  00106	8b f0		 mov	 esi, eax
  00108	83 bc 24 40 08
	00 00 15	 cmp	 DWORD PTR _s$[esp+4240], 21 ; 00000015H
  00110	0f 85 7a ff ff
	ff		 jne	 $L268292
$L268293:

; 260  : 	}
; 261  : 	return TRUE;

  00116	8d 4c 24 14	 lea	 ecx, DWORD PTR _s$[esp+2148]
  0011a	c7 84 24 60 08
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+2156], -1
  00125	e8 00 00 00 00	 call	 ??1CScanner@@UAE@XZ	; CScanner::~CScanner
  0012a	b8 01 00 00 00	 mov	 eax, 1
$L268285:

; 262  : }

  0012f	8b 8c 24 58 08
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+2148]
  00136	5f		 pop	 edi
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0013e	8b 8c 24 50 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2144]
  00145	5e		 pop	 esi
  00146	33 cc		 xor	 ecx, esp
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	81 c4 5c 08 00
	00		 add	 esp, 2140		; 0000085cH
  00153	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L283368:
  00000	8d 8d b0 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CScanner@@UAE@XZ	; CScanner::~CScanner
__ehhandler$?LoadPos@CEveSchool@@QAEHPBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T283377
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadPos@CEveSchool@@QAEHPBD@Z ENDP			; CEveSchool::LoadPos
PUBLIC	?GetInstance@CEveSchool@@SAPAV1@XZ		; CEveSchool::GetInstance
EXTRN	_atexit:NEAR
;	COMDAT ?sEveSchool@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4V2@A
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
_BSS	SEGMENT
?sEveSchool@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4V2@A DB 08cH DUP (?) ; `CEveSchool::GetInstance'::`2'::sEveSchool
_BSS	ENDS
;	COMDAT ?$S1@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4IA
_BSS	SEGMENT
?$S1@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4IA DD 01H DUP (?) ; `CEveSchool::GetInstance'::`2'::$S1
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
_BSS	ENDS
;	COMDAT ?GetInstance@CEveSchool@@SAPAV1@XZ
_TEXT	SEGMENT
?GetInstance@CEveSchool@@SAPAV1@XZ PROC NEAR		; CEveSchool::GetInstance, COMDAT

; 274  : 	static	CEveSchool	sEveSchool;

  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?$S1@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4IA
  00006	b8 01 00 00 00	 mov	 eax, 1
  0000b	84 c8		 test	 cl, al
  0000d	75 28		 jne	 SHORT $L283420
  0000f	09 05 00 00 00
	00		 or	 DWORD PTR ?$S1@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4IA, eax
  00015	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?sEveSchool@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4V2@A, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A ; g_GuildMng
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00025	68 00 00 00 00	 push	 OFFSET FLAT:_$E2
  0002a	a3 88 00 00 00	 mov	 DWORD PTR ?sEveSchool@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4V2@A+136, eax
  0002f	e8 00 00 00 00	 call	 _atexit
  00034	83 c4 04	 add	 esp, 4
$L283420:

; 275  : 	return & sEveSchool;

  00037	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?sEveSchool@?1??GetInstance@CEveSchool@@SAPAV2@XZ@4V2@A

; 276  : }

  0003c	c3		 ret	 0
?GetInstance@CEveSchool@@SAPAV1@XZ ENDP			; CEveSchool::GetInstance
_TEXT	ENDS
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
EXTRN	__time64:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC NEAR		; ATL::CTime::GetTickCount, COMDAT

; 139  : 	return( CTime( ::_time64( NULL ) ) );

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	83 c4 04	 add	 esp, 4
  00010	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00013	8b c1		 mov	 eax, ecx

; 140  : }

  00015	c2 04 00	 ret	 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
_TEXT	ENDS
PUBLIC	?SetNpc@CGuildCombat@@QAEXXZ			; CGuildCombat::SetNpc
PUBLIC	??_C@_0BF@JCJEOMMC@Mada_Guildcombatshop?$AA@	; `string'
EXTRN	?InitCharacter@CMover@@QAEXPAUtagCHARACTER@@@Z:NEAR ; CMover::InitCharacter
EXTRN	?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ:NEAR ; CMover::GetCharacter
EXTRN	?InitNPCProperty@CMover@@QAEXXZ:NEAR		; CMover::InitNPCProperty
EXTRN	?AddObj@CWorld@@QAEHPAVCObj@@HH@Z:NEAR		; CWorld::AddObj
EXTRN	?UpdateLocalMatrix@CObj@@QAEXXZ:NEAR		; CObj::UpdateLocalMatrix
EXTRN	?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z:NEAR	; CObj::SetPos
EXTRN	__imp__lstrcpyA@8:NEAR
EXTRN	?CreateObj@@YAPAVCObj@@PAUIDirect3DDevice9@@KKH@Z:NEAR ; CreateObj
EXTRN	?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z:NEAR	; CWorldMng::GetWorld
EXTRN	?g_WorldMng@@3VCWorldMng@@A:BYTE		; g_WorldMng
;	COMDAT ??_C@_0BF@JCJEOMMC@Mada_Guildcombatshop?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
CONST	SEGMENT
??_C@_0BF@JCJEOMMC@Mada_Guildcombatshop?$AA@ DB 'Mada_Guildcombatshop', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?SetNpc@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
$T283432 = -12						; size = 12
$T283431 = -12						; size = 12
?SetNpc@CGuildCombat@@QAEXXZ PROC NEAR			; CGuildCombat::SetNpc, COMDAT
; _this$ = ecx

; 1663 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1664 : 	CMover* pMover	= (CMover*)CreateObj( D3DDEVICE, OT_MOVER, MI_MADA_ACHABEN );

  00006	6a 01		 push	 1
  00008	68 e5 00 00 00	 push	 229			; 000000e5H
  0000d	6a 05		 push	 5
  0000f	6a 00		 push	 0
  00011	e8 00 00 00 00	 call	 ?CreateObj@@YAPAVCObj@@PAUIDirect3DDevice9@@KKH@Z ; CreateObj

; 1665 : 	lstrcpy( pMover->m_szCharacterKey, "Mada_Guildcombatshop" );

  00016	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__lstrcpyA@8
  0001c	83 c4 10	 add	 esp, 16			; 00000010H
  0001f	8b f0		 mov	 esi, eax
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@JCJEOMMC@Mada_Guildcombatshop?$AA@
  00026	8d 86 4c 06 00
	00		 lea	 eax, DWORD PTR [esi+1612]
  0002c	50		 push	 eax
  0002d	ff d3		 call	 ebx

; 1666 : 	pMover->InitNPCProperty();

  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?InitNPCProperty@CMover@@QAEXXZ ; CMover::InitNPCProperty

; 1667 : 	pMover->InitCharacter( pMover->GetCharacter() );

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  0003d	50		 push	 eax
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?InitCharacter@CMover@@QAEXPAUtagCHARACTER@@@Z ; CMover::InitCharacter

; 1668 : 	pMover->SetPos( D3DXVECTOR3(1343, 94, 1215) );

  00045	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T283431[esp+24]
  00049	51		 push	 ecx
  0004a	8b ce		 mov	 ecx, esi
  0004c	c7 44 24 10 00
	e0 a7 44	 mov	 DWORD PTR $T283431[esp+28], 1151852544 ; 44a7e000H
  00054	c7 44 24 14 00
	00 bc 42	 mov	 DWORD PTR $T283431[esp+32], 1119617024 ; 42bc0000H
  0005c	c7 44 24 18 00
	e0 97 44	 mov	 DWORD PTR $T283431[esp+36], 1150803968 ; 4497e000H
  00064	e8 00 00 00 00	 call	 ?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z ; CObj::SetPos

; 1669 : 	pMover->InitMotion( MTI_STAND );

  00069	8b 16		 mov	 edx, DWORD PTR [esi]
  0006b	6a 00		 push	 0
  0006d	8b ce		 mov	 ecx, esi
  0006f	ff 52 08	 call	 DWORD PTR [edx+8]

; 1670 : 	pMover->UpdateLocalMatrix();

  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?UpdateLocalMatrix@CObj@@QAEXXZ ; CObj::UpdateLocalMatrix

; 1671 : 	CWorld* pWorld	= g_WorldMng.GetWorld( WI_WORLD_GUILDWAR );

  00079	68 ca 00 00 00	 push	 202			; 000000caH
  0007e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00083	e8 00 00 00 00	 call	 ?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z ; CWorldMng::GetWorld
  00088	8b f8		 mov	 edi, eax

; 1672 : 	if( pWorld )

  0008a	85 ff		 test	 edi, edi
  0008c	74 0c		 je	 SHORT $L269069

; 1673 : 		pWorld->ADDOBJ( pMover, TRUE, nDefaultLayer );

  0008e	6a 00		 push	 0
  00090	6a 01		 push	 1
  00092	56		 push	 esi
  00093	8b cf		 mov	 ecx, edi
  00095	e8 00 00 00 00	 call	 ?AddObj@CWorld@@QAEHPAVCObj@@HH@Z ; CWorld::AddObj
$L269069:

; 1674 : 	
; 1675 : 	CMover* pMover1	= (CMover*)CreateObj( D3DDEVICE, OT_MOVER, MI_MADA_ACHABEN );

  0009a	6a 01		 push	 1
  0009c	68 e5 00 00 00	 push	 229			; 000000e5H
  000a1	6a 05		 push	 5
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 ?CreateObj@@YAPAVCObj@@PAUIDirect3DDevice9@@KKH@Z ; CreateObj
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	8b f0		 mov	 esi, eax

; 1676 : 	lstrcpy( pMover1->m_szCharacterKey, "Mada_Guildcombatshop" );

  000af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@JCJEOMMC@Mada_Guildcombatshop?$AA@
  000b4	8d 86 4c 06 00
	00		 lea	 eax, DWORD PTR [esi+1612]
  000ba	50		 push	 eax
  000bb	ff d3		 call	 ebx

; 1677 : 	pMover1->InitNPCProperty();

  000bd	8b ce		 mov	 ecx, esi
  000bf	e8 00 00 00 00	 call	 ?InitNPCProperty@CMover@@QAEXXZ ; CMover::InitNPCProperty

; 1678 : 	pMover1->InitCharacter( pMover1->GetCharacter() );

  000c4	8b ce		 mov	 ecx, esi
  000c6	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  000cb	50		 push	 eax
  000cc	8b ce		 mov	 ecx, esi
  000ce	e8 00 00 00 00	 call	 ?InitCharacter@CMover@@QAEXPAUtagCHARACTER@@@Z ; CMover::InitCharacter

; 1679 : 	pMover1->SetPos( D3DXVECTOR3(1288, 98, 1356) );

  000d3	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T283432[esp+24]
  000d7	51		 push	 ecx
  000d8	8b ce		 mov	 ecx, esi
  000da	c7 44 24 10 00
	00 a1 44	 mov	 DWORD PTR $T283432[esp+28], 1151401984 ; 44a10000H
  000e2	c7 44 24 14 00
	00 c4 42	 mov	 DWORD PTR $T283432[esp+32], 1120141312 ; 42c40000H
  000ea	c7 44 24 18 00
	80 a9 44	 mov	 DWORD PTR $T283432[esp+36], 1151959040 ; 44a98000H
  000f2	e8 00 00 00 00	 call	 ?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z ; CObj::SetPos

; 1680 : 	pMover1->InitMotion( MTI_STAND );

  000f7	8b 16		 mov	 edx, DWORD PTR [esi]
  000f9	6a 00		 push	 0
  000fb	8b ce		 mov	 ecx, esi
  000fd	ff 52 08	 call	 DWORD PTR [edx+8]

; 1681 : 	pMover1->UpdateLocalMatrix();

  00100	8b ce		 mov	 ecx, esi
  00102	e8 00 00 00 00	 call	 ?UpdateLocalMatrix@CObj@@QAEXXZ ; CObj::UpdateLocalMatrix

; 1682 : 	if( pWorld )

  00107	85 ff		 test	 edi, edi
  00109	74 0c		 je	 SHORT $L269073

; 1683 : 		pWorld->ADDOBJ( pMover1, TRUE, nDefaultLayer );

  0010b	6a 00		 push	 0
  0010d	6a 01		 push	 1
  0010f	56		 push	 esi
  00110	8b cf		 mov	 ecx, edi
  00112	e8 00 00 00 00	 call	 ?AddObj@CWorld@@QAEHPAVCObj@@HH@Z ; CWorld::AddObj
$L269073:
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx

; 1684 : }

  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011d	c3		 ret	 0
?SetNpc@CGuildCombat@@QAEXXZ ENDP			; CGuildCombat::SetNpc
_TEXT	ENDS
PUBLIC	?GetNextGuildCobmatTime@CGuildCombat@@QAE?AVCTime@ATL@@XZ ; CGuildCombat::GetNextGuildCobmatTime
; Function compile flags: /Ogty
;	COMDAT ?GetNextGuildCobmatTime@CGuildCombat@@QAE?AVCTime@ATL@@XZ
_TEXT	SEGMENT
_tCurrentTime$ = -32					; size = 8
_tNextCombat$ = -24					; size = 8
_tCTime$269445 = -16					; size = 8
$T283460 = -8						; size = 8
$T283458 = -8						; size = 8
_tNTime$269447 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
?GetNextGuildCobmatTime@CGuildCombat@@QAE?AVCTime@ATL@@XZ PROC NEAR ; CGuildCombat::GetNextGuildCobmatTime, COMDAT
; _this$ = ecx

; 2098 : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2099 : 	CTime tCurrentTime = CTime::GetCurrentTime();

  00006	6a 00		 push	 0
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 __time64
  0000f	89 44 24 10	 mov	 DWORD PTR _tCurrentTime$[esp+48], eax

; 2100 : 	CTime tNextCombat;
; 2101 : 	int nDayofWeek = m_nDay - tCurrentTime.GetDayOfWeek();

  00013	8d 44 24 10	 lea	 eax, DWORD PTR _tCurrentTime$[esp+48]
  00017	50		 push	 eax
  00018	89 54 24 18	 mov	 DWORD PTR _tCurrentTime$[esp+56], edx
  0001c	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _tNextCombat$[esp+52], 0
  00024	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _tNextCombat$[esp+56], 0
  0002c	e8 00 00 00 00	 call	 __localtime64
  00031	83 c4 08	 add	 esp, 8
  00034	85 c0		 test	 eax, eax
  00036	74 06		 je	 SHORT $L283487
  00038	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003b	41		 inc	 ecx
  0003c	eb 02		 jmp	 SHORT $L283488
$L283487:
  0003e	33 c9		 xor	 ecx, ecx
$L283488:
  00040	8b 86 48 11 00
	00		 mov	 eax, DWORD PTR [esi+4424]
  00046	2b c1		 sub	 eax, ecx

; 2102 : 	if( 0 < nDayofWeek )

  00048	85 c0		 test	 eax, eax
  0004a	7e 28		 jle	 SHORT $L283681

; 2103 : 		tNextCombat = tCurrentTime + CTimeSpan( nDayofWeek, 0, 0, 0 ); 

  0004c	6a 00		 push	 0
  0004e	99		 cdq
  0004f	68 80 51 01 00	 push	 86400			; 00015180H
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 __allmul
  0005b	8b 7c 24 0c	 mov	 edi, DWORD PTR _tCurrentTime$[esp+44]
  0005f	8b 4c 24 10	 mov	 ecx, DWORD PTR _tCurrentTime$[esp+48]
  00063	03 c7		 add	 eax, edi
  00065	13 d1		 adc	 edx, ecx
  00067	89 44 24 14	 mov	 DWORD PTR _tNextCombat$[esp+44], eax
  0006b	89 54 24 18	 mov	 DWORD PTR _tNextCombat$[esp+48], edx

; 2104 : 	else if( 0 == nDayofWeek )

  0006f	e9 e6 00 00 00	 jmp	 $L269454
$L283681:
  00074	0f 85 b0 00 00
	00		 jne	 $L269444

; 2105 : 	{
; 2106 : 		CTimeSpan tCTime = CTimeSpan( 0, tCurrentTime.GetHour(), tCurrentTime.GetMinute(), tCurrentTime.GetSecond() );

  0007a	8d 4c 24 0c	 lea	 ecx, DWORD PTR _tCurrentTime$[esp+44]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 __localtime64
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	74 04		 je	 SHORT $L283526
  0008b	8b 18		 mov	 ebx, DWORD PTR [eax]
  0008d	eb 03		 jmp	 SHORT $L283527
$L283526:
  0008f	83 cb ff	 or	 ebx, -1
$L283527:
  00092	8d 54 24 0c	 lea	 edx, DWORD PTR _tCurrentTime$[esp+44]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 __localtime64
  0009c	83 c4 04	 add	 esp, 4
  0009f	85 c0		 test	 eax, eax
  000a1	74 05		 je	 SHORT $L283548
  000a3	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000a6	eb 03		 jmp	 SHORT $L283549
$L283548:
  000a8	83 cf ff	 or	 edi, -1
$L283549:
  000ab	8d 44 24 0c	 lea	 eax, DWORD PTR _tCurrentTime$[esp+44]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 __localtime64
  000b5	83 c4 04	 add	 esp, 4
  000b8	85 c0		 test	 eax, eax
  000ba	74 05		 je	 SHORT $L283570
  000bc	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bf	eb 03		 jmp	 SHORT $L283571
$L283570:
  000c1	83 c8 ff	 or	 eax, -1
$L283571:
  000c4	53		 push	 ebx
  000c5	57		 push	 edi
  000c6	50		 push	 eax
  000c7	6a 00		 push	 0
  000c9	8d 4c 24 2c	 lea	 ecx, DWORD PTR _tCTime$269445[esp+60]
  000cd	e8 00 00 00 00	 call	 ??0CTimeSpan@ATL@@QAE@JHHH@Z ; ATL::CTimeSpan::CTimeSpan

; 2107 : 		CTimeSpan tNTime = CTimeSpan( 0, __AutoOpen[m_nDay-1].nHour, __AutoOpen[m_nDay-1].nMinute, 0 );

  000d2	8b 8e 48 11 00
	00		 mov	 ecx, DWORD PTR [esi+4424]
  000d8	0f b6 54 ce 05	 movzx	 edx, BYTE PTR [esi+ecx*8+5]
  000dd	8d 04 ce	 lea	 eax, DWORD PTR [esi+ecx*8]
  000e0	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  000e4	6a 00		 push	 0
  000e6	52		 push	 edx
  000e7	50		 push	 eax
  000e8	6a 00		 push	 0
  000ea	8d 4c 24 34	 lea	 ecx, DWORD PTR _tNTime$269447[esp+60]
  000ee	e8 00 00 00 00	 call	 ??0CTimeSpan@ATL@@QAE@JHHH@Z ; ATL::CTimeSpan::CTimeSpan

; 2108 : 		if( tCTime <= tNTime )

  000f3	8b 4c 24 20	 mov	 ecx, DWORD PTR _tCTime$269445[esp+48]
  000f7	3b 4c 24 28	 cmp	 ecx, DWORD PTR _tNTime$269447[esp+48]
  000fb	7f 1e		 jg	 SHORT $L269449
  000fd	7c 0a		 jl	 SHORT $L283680
  000ff	8b 54 24 1c	 mov	 edx, DWORD PTR _tCTime$269445[esp+44]
  00103	3b 54 24 24	 cmp	 edx, DWORD PTR _tNTime$269447[esp+44]
  00107	77 12		 ja	 SHORT $L269449
$L283680:

; 2109 : 			tNextCombat = tCurrentTime;

  00109	8b 44 24 0c	 mov	 eax, DWORD PTR _tCurrentTime$[esp+44]
  0010d	8b 4c 24 10	 mov	 ecx, DWORD PTR _tCurrentTime$[esp+48]
  00111	89 44 24 14	 mov	 DWORD PTR _tNextCombat$[esp+44], eax
  00115	89 4c 24 18	 mov	 DWORD PTR _tNextCombat$[esp+48], ecx

; 2110 : 		else

  00119	eb 3f		 jmp	 SHORT $L269454
$L269449:

; 2111 : 			tNextCombat = tCurrentTime + CTimeSpan( m_nDay, 0, 0, 0 );

  0011b	8b 96 48 11 00
	00		 mov	 edx, DWORD PTR [esi+4424]
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	52		 push	 edx

; 2112 : 	}
; 2113 : 	else if( 0 > nDayofWeek )

  00128	eb 0e		 jmp	 SHORT $L283682
$L269444:
  0012a	85 c0		 test	 eax, eax
  0012c	7d 2c		 jge	 SHORT $L269454

; 2114 : 	{
; 2115 : 		nDayofWeek = 7 + nDayofWeek;
; 2116 : 		tNextCombat = tCurrentTime + CTimeSpan( nDayofWeek, 0, 0, 0 ); 

  0012e	6a 00		 push	 0
  00130	6a 00		 push	 0
  00132	83 c0 07	 add	 eax, 7
  00135	6a 00		 push	 0
  00137	50		 push	 eax
$L283682:
  00138	8d 4c 24 34	 lea	 ecx, DWORD PTR $T283458[esp+60]
  0013c	e8 00 00 00 00	 call	 ??0CTimeSpan@ATL@@QAE@JHHH@Z ; ATL::CTimeSpan::CTimeSpan
  00141	8b 08		 mov	 ecx, DWORD PTR [eax]
  00143	8b 7c 24 0c	 mov	 edi, DWORD PTR _tCurrentTime$[esp+44]
  00147	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014a	8b 54 24 10	 mov	 edx, DWORD PTR _tCurrentTime$[esp+48]
  0014e	03 cf		 add	 ecx, edi
  00150	13 c2		 adc	 eax, edx
  00152	89 4c 24 14	 mov	 DWORD PTR _tNextCombat$[esp+44], ecx
  00156	89 44 24 18	 mov	 DWORD PTR _tNextCombat$[esp+48], eax
$L269454:

; 2117 : 	}
; 2118 : 	tNextCombat = CTime( tNextCombat.GetYear(), tNextCombat.GetMonth(), tNextCombat.GetDay(), __AutoOpen[m_nDay-1].nHour, __AutoOpen[m_nDay-1].nMinute, 0 );

  0015a	8d 44 24 14	 lea	 eax, DWORD PTR _tNextCombat$[esp+44]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 __localtime64
  00164	83 c4 04	 add	 esp, 4
  00167	85 c0		 test	 eax, eax
  00169	74 05		 je	 SHORT $L283627
  0016b	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  0016e	eb 02		 jmp	 SHORT $L283628
$L283627:
  00170	33 db		 xor	 ebx, ebx
$L283628:
  00172	8d 4c 24 14	 lea	 ecx, DWORD PTR _tNextCombat$[esp+44]
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 __localtime64
  0017c	83 c4 04	 add	 esp, 4
  0017f	85 c0		 test	 eax, eax
  00181	74 06		 je	 SHORT $L283649
  00183	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00186	47		 inc	 edi
  00187	eb 02		 jmp	 SHORT $L283650
$L283649:
  00189	33 ff		 xor	 edi, edi
$L283650:
  0018b	8d 54 24 14	 lea	 edx, DWORD PTR _tNextCombat$[esp+44]
  0018f	52		 push	 edx
  00190	e8 00 00 00 00	 call	 __localtime64
  00195	83 c4 04	 add	 esp, 4
  00198	85 c0		 test	 eax, eax
  0019a	74 0b		 je	 SHORT $L283669
  0019c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0019f	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  001a5	eb 02		 jmp	 SHORT $L283670
$L283669:
  001a7	33 c9		 xor	 ecx, ecx
$L283670:
  001a9	8b 86 48 11 00
	00		 mov	 eax, DWORD PTR [esi+4424]
  001af	0f b6 54 c6 05	 movzx	 edx, BYTE PTR [esi+eax*8+5]
  001b4	6a ff		 push	 -1
  001b6	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  001b9	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  001bd	6a 00		 push	 0
  001bf	52		 push	 edx
  001c0	50		 push	 eax
  001c1	53		 push	 ebx
  001c2	57		 push	 edi
  001c3	51		 push	 ecx
  001c4	8d 4c 24 40	 lea	 ecx, DWORD PTR $T283460[esp+72]
  001c8	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@HHHHHHH@Z ; ATL::CTime::CTime

; 2119 : 	return tNextCombat;

  001cd	8b 10		 mov	 edx, DWORD PTR [eax]
  001cf	8b 4c 24 30	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp+40]
  001d3	5f		 pop	 edi
  001d4	89 11		 mov	 DWORD PTR [ecx], edx
  001d6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d9	5e		 pop	 esi
  001da	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001dd	8b c1		 mov	 eax, ecx
  001df	5b		 pop	 ebx

; 2120 : }

  001e0	83 c4 20	 add	 esp, 32			; 00000020H
  001e3	c2 04 00	 ret	 4
?GetNextGuildCobmatTime@CGuildCombat@@QAE?AVCTime@ATL@@XZ ENDP ; CGuildCombat::GetNextGuildCobmatTime
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEAAU__REQUESTGUILD@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 250  : 			++(*(const_iterator *)this);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

  00008	c3		 ret	 0
??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 202  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 203  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?Compare@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Compare
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?Compare@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?Compare@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Compare, COMDAT
; _this$ = ecx

; 1088 : 		ATLASSERT( AtlIsValidString( psz ) );
; 1089 : 		return( StringTraits::StringCompare( GetString(), psz ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _psz$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 __mbscmp
  0000d	83 c4 08	 add	 esp, 8

; 1090 : 	}

  00010	c2 04 00	 ret	 4
?Compare@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Compare
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Vector_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Vector_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Vector_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCGETPOINT@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Vector_val<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCGETPOINT@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCGETPOINT@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Vector_val<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCGETPOINT@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Vector_val<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Vector_val<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Vector_val<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Vector_val<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Vector_val<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Vector_val<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Vector_val<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@1@@Z ; std::_Vector_val<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Vector_val<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@1@@Z PROC NEAR ; std::_Vector_val<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Vector_val<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@1@@Z ENDP ; std::_Vector_val<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Vector_val<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCSENDITEM@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Vector_val<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCSENDITEM@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCSENDITEM@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Vector_val<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCSENDITEM@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Vector_val<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Vector_val<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Vector_val<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Vector_val<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Vector_val<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Vector_val<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Vector_val<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@1@@Z ; std::_Vector_val<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Vector_val<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_Vector_val<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Vector_val<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_Vector_val<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Vector_val<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@PAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 03	 sar	 eax, 3

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 236  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 161  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 162  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ
_TEXT	SEGMENT
??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@KV?$allocator@K@std@@@std@@QBEAAKXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@KV?$allocator@K@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEAAPAU__GuildCombatMember@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBE?AV012@H@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEAAU__GCSENDITEM@CGuildCombat@@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEAAU__GCSENDITEM@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEAAU__GCSENDITEM@CGuildCombat@@XZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEAAU__GCSENDITEM@CGuildCombat@@XZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator+
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEPAPAU__JOINPLAYER@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEPAPAU__JOINPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEPAPAU__JOINPLAYER@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER *>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocate
; Function compile flags: /Ogty
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L283980
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L283980:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEPAU__GCGETPOINT@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCGETPOINT>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEPAU__GCGETPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEPAU__GCGETPOINT@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCGETPOINT>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEPAU__GCGETPOINT@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCGETPOINT>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEPAU__GCPLAYERPOINT@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEPAU__GCPLAYERPOINT@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEPAU__GCPLAYERPOINT@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEPAU__GCPLAYERPOINT@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEPAPAU__GuildCombatMember@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEPAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEPAPAU__GuildCombatMember@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@QAEPAPAU__GuildCombatMember@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GuildCombatMember *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEIXZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z PROC NEAR ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z ENDP ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEPAU__GCSENDITEM@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCSENDITEM>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEPAU__GCSENDITEM@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEPAU__GCSENDITEM@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCSENDITEM>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEPAU__GCSENDITEM@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCSENDITEM>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEPAU__REQUESTGUILD@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEPAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEPAU__REQUESTGUILD@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEPAU__REQUESTGUILD@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEGUILD@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEPAU__GCRESULTVALUEPLAYER@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::allocate
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuild@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuild@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuild@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuild@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L274832

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L284179

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L284167
  0001d	8d 49 00	 npad	 3
$L284166:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L284166
$L284167:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L284179:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L274836
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L274835:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L274836

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L274835
$L274836:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L274832:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCGuildMember@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L274846

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L284235

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L284223
  0001d	8d 49 00	 npad	 3
$L284222:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L284222
$L284223:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L284235:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L274850
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L274849:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L274850

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L274849
$L274850:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L274846:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AV012@H@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 256  : 			iterator _Tmp = *this;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]

; 257  : 			++*this;

  00002	8b 02		 mov	 eax, DWORD PTR [edx]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 258  : 			return (_Tmp);

  00006	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 259  : 			}

  0000c	c2 08 00	 ret	 8
??Eiterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@KV?$allocator@K@std@@@std@@QAE@PAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@KV?$allocator@K@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<int,std::allocator<int> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	8b c8		 mov	 ecx, eax
  0000a	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000f	f7 e9		 imul	 ecx
  00011	c1 fa 03	 sar	 edx, 3
  00014	8b c2		 mov	 eax, edx
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	03 c2		 add	 eax, edx

; 280  : 			}

  0001b	c2 04 00	 ret	 4
??Giterator@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@PAU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	8b c8		 mov	 ecx, eax
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	d1 fa		 sar	 edx, 1
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx

; 280  : 			}

  0001a	c2 04 00	 ret	 4
??Giterator@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@PAPAU__GuildCombatMember@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  0000b	c2 04 00	 ret	 4
??Giterator@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@PAU__GCSENDITEM@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	8b c8		 mov	 ecx, eax
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	d1 fa		 sar	 edx, 1
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx

; 280  : 			}

  0001a	c2 04 00	 ret	 4
??Giterator@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::iterator::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  00012	c2 08 00	 ret	 8
??Hiterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator-
; Function compile flags: /Ogty
;	COMDAT ??Giterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Giterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator-, COMDAT
; _this$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	8b c8		 mov	 ecx, eax
  0000a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000f	f7 e9		 imul	 ecx
  00011	c1 fa 02	 sar	 edx, 2
  00014	8b c2		 mov	 eax, edx
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	03 c2		 add	 eax, edx

; 280  : 			}

  0001b	c2 04 00	 ret	 4
??Giterator@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::iterator::operator-
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	74 06		 je	 SHORT $L275086

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  00009	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 263  : 				}
; 264  : 			}

  0000e	c3		 ret	 0
$L275086:

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	53		 push	 ebx
  00012	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00015	84 db		 test	 bl, bl
  00017	75 1a		 jne	 SHORT $L284459

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00019	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001c	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0001f	84 db		 test	 bl, bl
  00021	75 0c		 jne	 SHORT $L284437
$L284436:
  00023	8b d0		 mov	 edx, eax
  00025	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00028	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0002b	84 db		 test	 bl, bl
  0002d	74 f4		 je	 SHORT $L284436
$L284437:
  0002f	89 11		 mov	 DWORD PTR [ecx], edx
  00031	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00032	c3		 ret	 0
$L284459:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00039	84 d2		 test	 dl, dl
  0003b	75 1e		 jne	 SHORT $L284462
  0003d	8d 49 00	 npad	 3
$L275092:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 10		 cmp	 edx, DWORD PTR [eax]
  00044	75 0c		 jne	 SHORT $L275093

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 01		 mov	 DWORD PTR [ecx], eax
  00048	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004b	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004e	84 d2		 test	 dl, dl
  00050	74 ee		 je	 SHORT $L275092
$L275093:

; 261  : 				if (!_Isnil(_Pnode))

  00052	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00055	84 d2		 test	 dl, dl
  00057	75 02		 jne	 SHORT $L284462

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  00059	89 01		 mov	 DWORD PTR [ecx], eax
$L284462:
  0005b	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0005c	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 45   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_nod<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEPAU__JOINPLAYER@CGuildCombat@@I@Z ; std::allocator<CGuildCombat::__JOINPLAYER>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEPAU__JOINPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4

; 138  : 		}

  00013	c2 04 00	 ret	 4
?allocate@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEPAU__JOINPLAYER@CGuildCombat@@I@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >, COMDAT
; _this$ = ecx

; 54   : 		{	// construct traits from _Parg and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 55   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::construct
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L284508
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L284508:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$make_pair@KH@std@@YA?AU?$pair@KH@0@KH@Z	; std::make_pair<unsigned long,int>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$make_pair@KH@std@@YA?AU?$pair@KH@0@KH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@KH@std@@YA?AU?$pair@KH@0@KH@Z PROC NEAR	; std::make_pair<unsigned long,int>, COMDAT

; 108  : 	return (pair<_Ty1, _Ty2>(_Val1, _Val2));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val1$[esp-4]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val2$[esp-4]
  0000c	89 08		 mov	 DWORD PTR [eax], ecx
  0000e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 109  : 	}

  00011	c3		 ret	 0
??$make_pair@KH@std@@YA?AU?$pair@KH@0@KH@Z ENDP		; std::make_pair<unsigned long,int>
_TEXT	ENDS
PUBLIC	??$copy@PAKPAK@std@@YAPAKPAK00@Z		; std::copy<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAKPAK@std@@YAPAKPAK00@Z PROC NEAR		; std::copy<unsigned long *,unsigned long *>, COMDAT

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1041 : 	}

  00027	c3		 ret	 0
??$copy@PAKPAK@std@@YAPAKPAK00@Z ENDP			; std::copy<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	??$copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z ; std::copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
; Function compile flags: /Ogty
;	COMDAT ??$copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z PROC NEAR ; std::copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>, COMDAT

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b ca		 cmp	 ecx, edx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 16		 je	 SHORT $L284543
  00010	56		 push	 esi
$L284541:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $L284541
  00025	5e		 pop	 esi
$L284543:

; 1041 : 	}

  00026	c3		 ret	 0
??$copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z ENDP ; std::copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z ; std::copy_backward<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z PROC NEAR ; std::copy_backward<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00008	3b d1		 cmp	 edx, ecx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 17		 je	 SHORT $L284561
  00010	56		 push	 esi
$L284560:
  00011	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  00014	83 e9 08	 sub	 ecx, 8
  00017	83 e8 08	 sub	 eax, 8
  0001a	3b ca		 cmp	 ecx, edx
  0001c	89 30		 mov	 DWORD PTR [eax], esi
  0001e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00021	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00024	75 eb		 jne	 SHORT $L284560
  00026	5e		 pop	 esi
$L284561:

; 1070 : 	}

  00027	c3		 ret	 0
??$copy_backward@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z ENDP ; std::copy_backward<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z	; std::copy_backward<unsigned long *,unsigned long *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z PROC NEAR	; std::copy_backward<unsigned long *,unsigned long *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::copy_backward<unsigned long *,unsigned long *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z	; std::copy_backward<int *,int *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z PROC NEAR	; std::copy_backward<int *,int *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::copy_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??$copy_backward@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00@Z ; std::copy_backward<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy_backward@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00@Z PROC NEAR ; std::copy_backward<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00@Z ENDP ; std::copy_backward<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00@Z ; std::copy_backward<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00@Z PROC NEAR ; std::copy_backward<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00004	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  00008	53		 push	 ebx
  00009	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]
  0000d	3b da		 cmp	 ebx, edx
  0000f	74 19		 je	 SHORT $L284627
  00011	56		 push	 esi
  00012	57		 push	 edi
$L284626:
  00013	83 ea 24	 sub	 edx, 36			; 00000024H
  00016	83 e8 24	 sub	 eax, 36			; 00000024H
  00019	3b d3		 cmp	 edx, ebx
  0001b	b9 09 00 00 00	 mov	 ecx, 9
  00020	8b f2		 mov	 esi, edx
  00022	8b f8		 mov	 edi, eax
  00024	f3 a5		 rep movsd
  00026	75 eb		 jne	 SHORT $L284626
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$L284627:
  0002a	5b		 pop	 ebx

; 1070 : 	}

  0002b	c3		 ret	 0
??$copy_backward@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00@Z ENDP ; std::copy_backward<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00@Z ; std::copy_backward<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT
__Cat$284641 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00@Z PROC NEAR ; std::copy_backward<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$284641[esp+4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR __Dest$[esp]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>

; 1070 : 	}

  00019	83 c4 14	 add	 esp, 20			; 00000014H
  0001c	c3		 ret	 0
??$copy_backward@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00@Z ENDP ; std::copy_backward<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
_TEXT	ENDS
PUBLIC	??$copy_backward@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00@Z ; std::copy_backward<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy_backward@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00@Z PROC NEAR ; std::copy_backward<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00@Z ENDP ; std::copy_backward<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00@Z ; std::copy_backward<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT
__Cat$284672 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00@Z PROC NEAR ; std::copy_backward<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$284672[esp+4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR __Dest$[esp]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>

; 1070 : 	}

  00019	83 c4 14	 add	 esp, 20			; 00000014H
  0001c	c3		 ret	 0
??$copy_backward@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00@Z ENDP ; std::copy_backward<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00@Z ; std::copy_backward<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00@Z
_TEXT	SEGMENT
__Cat$284681 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00@Z PROC NEAR ; std::copy_backward<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$284681[esp+4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR __Dest$[esp]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>

; 1070 : 	}

  00019	83 c4 14	 add	 esp, 20			; 00000014H
  0001c	c3		 ret	 0
??$copy_backward@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00@Z ENDP ; std::copy_backward<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	?IsFull@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAUItemProp@@F@Z ; CItemContainer<CItemElem>::IsFull
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsFull@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAUItemProp@@F@Z
_TEXT	SEGMENT
_i$278574 = -4						; size = 4
_pElem$ = 8						; size = 4
_pItemProp$ = 12					; size = 4
tv285 = 16						; size = 4
_nNum$ = 16						; size = 2
?IsFull@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAUItemProp@@F@Z PROC NEAR ; CItemContainer<CItemElem>::IsFull, COMDAT
; _this$ = ecx

; 631  : {

  00000	51		 push	 ecx

; 632  : 	int nId;
; 633  : 	short nNumtmp	= nNum;
; 634  : 	CItemElem* pElemtmp;
; 635  : 	for( DWORD i = 0; i < m_dwIndexNum; i++ )

  00001	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00004	85 c0		 test	 eax, eax
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	8b 74 24 1c	 mov	 esi, DWORD PTR _nNum$[esp+12]
  0000d	57		 push	 edi
  0000e	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _i$278574[esp+20], 0
  00016	0f 86 a8 00 00
	00		 jbe	 $L278577
  0001c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001f	8b 7c 24 1c	 mov	 edi, DWORD PTR _pItemProp$[esp+16]
  00023	8b 6c 24 18	 mov	 ebp, DWORD PTR _pElem$[esp+16]
  00027	89 44 24 20	 mov	 DWORD PTR tv285[esp+16], eax
  0002b	eb 03 8d 49 00	 npad	 5
$L284691:

; 636  : 	{
; 637  : 		nId	= m_apIndex[i];

  00030	8b 54 24 20	 mov	 edx, DWORD PTR tv285[esp+16]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]

; 638  : 		if( nId < 0 || nId >= (int)( m_dwItemMax ) )

  00036	85 c0		 test	 eax, eax
  00038	7c 6b		 jl	 SHORT $L278576
  0003a	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0003d	7d 66		 jge	 SHORT $L278576

; 639  : 			continue;
; 640  : 		pElemtmp	= (CItemElem*)&m_apItem[nId];

  0003f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00042	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00048	03 c2		 add	 eax, edx

; 641  : 		if( pElemtmp->IsEmpty() )

  0004a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0004d	85 d2		 test	 edx, edx
  0004f	75 0f		 jne	 SHORT $L278582

; 642  : 		{
; 643  : 			if( nNumtmp > (short)pItemProp->dwPackMax )
; 644  : 				nNumtmp		-= (short)pItemProp->dwPackMax;

  00051	33 c0		 xor	 eax, eax
  00053	66 8b 47 6c	 mov	 ax, WORD PTR [edi+108]
  00057	66 3b f0	 cmp	 si, ax
  0005a	7e 75		 jle	 SHORT $L278590
  0005c	2b f0		 sub	 esi, eax

; 645  : 			else
; 646  : 				return FALSE;
; 647  : 		}
; 648  : 		else if( pElem->m_dwItemId == pElemtmp->m_dwItemId

  0005e	eb 45		 jmp	 SHORT $L278576
$L278582:

; 649  : 				&& pElem->m_byFlag == pElemtmp->m_byFlag && pElem->m_bCharged == pElemtmp->m_bCharged )

  00060	39 55 0c	 cmp	 DWORD PTR [ebp+12], edx
  00063	75 40		 jne	 SHORT $L278576
  00065	8a 95 82 00 00
	00		 mov	 dl, BYTE PTR [ebp+130]
  0006b	3a 90 82 00 00
	00		 cmp	 dl, BYTE PTR [eax+130]
  00071	75 32		 jne	 SHORT $L278576
  00073	8b 95 ac 00 00
	00		 mov	 edx, DWORD PTR [ebp+172]
  00079	3b 90 ac 00 00
	00		 cmp	 edx, DWORD PTR [eax+172]
  0007f	75 24		 jne	 SHORT $L278576

; 650  : 		{
; 651  : 			if( pElemtmp->m_nItemNum + nNumtmp > (short)pItemProp->dwPackMax )

  00081	0f bf 80 80 00
	00 00		 movsx	 eax, WORD PTR [eax+128]
  00088	0f bf ee	 movsx	 ebp, si
  0008b	0f bf d8	 movsx	 ebx, ax

; 652  : 				nNumtmp	-= ( (short)pItemProp->dwPackMax - pElemtmp->m_nItemNum );

  0008e	33 d2		 xor	 edx, edx
  00090	66 8b 57 6c	 mov	 dx, WORD PTR [edi+108]
  00094	03 dd		 add	 ebx, ebp
  00096	0f bf ea	 movsx	 ebp, dx
  00099	3b dd		 cmp	 ebx, ebp
  0009b	7e 34		 jle	 SHORT $L278590
  0009d	8b 6c 24 18	 mov	 ebp, DWORD PTR _pElem$[esp+16]
  000a1	2b c2		 sub	 eax, edx
  000a3	03 f0		 add	 esi, eax
$L278576:
  000a5	8b 44 24 10	 mov	 eax, DWORD PTR _i$278574[esp+20]
  000a9	8b 5c 24 20	 mov	 ebx, DWORD PTR tv285[esp+16]
  000ad	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000b0	40		 inc	 eax
  000b1	83 c3 04	 add	 ebx, 4
  000b4	3b c2		 cmp	 eax, edx
  000b6	89 44 24 10	 mov	 DWORD PTR _i$278574[esp+20], eax
  000ba	89 5c 24 20	 mov	 DWORD PTR tv285[esp+16], ebx
  000be	0f 82 6c ff ff
	ff		 jb	 $L284691
$L278577:
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5d		 pop	 ebp

; 655  : 		}
; 656  : 	}
; 657  : 
; 658  : 	return TRUE;

  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	5b		 pop	 ebx

; 659  : }

  000cd	59		 pop	 ecx
  000ce	c2 0c 00	 ret	 12			; 0000000cH
$L278590:
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5d		 pop	 ebp

; 653  : 			else
; 654  : 				return FALSE;

  000d4	33 c0		 xor	 eax, eax
  000d6	5b		 pop	 ebx

; 659  : }

  000d7	59		 pop	 ecx
  000d8	c2 0c 00	 ret	 12			; 0000000cH
?IsFull@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAUItemProp@@F@Z ENDP ; CItemContainer<CItemElem>::IsFull
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z ; std::_Uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z PROC NEAR ; std::_Uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned long,unsigned int,unsigned long>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<unsigned long,unsigned int,unsigned long>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L284712
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L284710:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L284710
  0001b	5e		 pop	 esi
$L284712:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@KIK@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned long,unsigned int,unsigned long>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,unsigned int,int>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<int,unsigned int,int>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L284724
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L284722:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L284722
  0001b	5e		 pop	 esi
$L284724:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER *>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L284737
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L284735:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L284735
  0001b	5e		 pop	 esi
$L284737:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IPAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GuildCombatMember *,unsigned int,CGuildCombat::__GuildCombatMember *>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@PAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CGuildCombat::__GuildCombatMember *,unsigned int,CGuildCombat::__GuildCombatMember *>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L284750
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L284748:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L284748
  0001b	5e		 pop	 esi
$L284750:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@PAU__GuildCombatMember@CGuildCombat@@IPAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CGuildCombat::__GuildCombatMember *,unsigned int,CGuildCombat::__GuildCombatMember *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z ; std::_Uninitialized_copy<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_copy@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_copy<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z ; std::_Uninitialized_copy<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *,std::allocator<CGuildCombat::__GuildCombatMember *> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_copy@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *,std::allocator<CGuildCombat::__GuildCombatMember *> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_copy<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *,std::allocator<CGuildCombat::__GuildCombatMember *> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@ABU34@@Z ; std::allocator<CGuildCombat::__GCGETPOINT>::construct
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@ABU34@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCGETPOINT>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	57		 push	 edi

; 147  : 		_Construct(_Ptr, _Val);

  00001	8b 7c 24 08	 mov	 edi, DWORD PTR __Ptr$[esp]
  00005	85 ff		 test	 edi, edi
  00007	74 0d		 je	 SHORT $L284804
  00009	56		 push	 esi
  0000a	8b 74 24 10	 mov	 esi, DWORD PTR __Val$[esp+4]
  0000e	b9 09 00 00 00	 mov	 ecx, 9
  00013	f3 a5		 rep movsd
  00015	5e		 pop	 esi
$L284804:
  00016	5f		 pop	 edi

; 148  : 		}

  00017	c2 08 00	 ret	 8
?construct@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@ABU34@@Z ENDP ; std::allocator<CGuildCombat::__GCGETPOINT>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__GCGETPOINT>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCGETPOINT>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@QAEXPAU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__GCGETPOINT>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@ABU34@@Z ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@ABU34@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 14		 je	 SHORT $L284827
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L284827:

; 148  : 		}

  0001c	c2 08 00	 ret	 8
?construct@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@ABU34@@Z ENDP ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@QAEXPAU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__GCPLAYERPOINT>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@ABU34@@Z ; std::allocator<CGuildCombat::__GCSENDITEM>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@ABU34@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCSENDITEM>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 14		 je	 SHORT $L284851
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L284851:

; 148  : 		}

  0001c	c2 08 00	 ret	 8
?construct@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@ABU34@@Z ENDP ; std::allocator<CGuildCombat::__GCSENDITEM>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__GCSENDITEM>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCSENDITEM>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@QAEXPAU__GCSENDITEM@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__GCSENDITEM>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@ABU34@@Z ; std::allocator<CGuildCombat::__REQUESTGUILD>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@ABU34@@Z PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 0e		 je	 SHORT $L284874
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L284874:

; 148  : 		}

  00016	c2 08 00	 ret	 8
?construct@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@ABU34@@Z ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__REQUESTGUILD>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__REQUESTGUILD>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@QAEXPAU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__REQUESTGUILD>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEGUILD>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@QAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@ABU34@@Z ; std::allocator<CGuildCombat::__JOINPLAYER>::construct
; Function compile flags: /Ogty
;	COMDAT ?construct@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@ABU34@@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 26		 je	 SHORT $L284909
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	89 10		 mov	 DWORD PTR [eax], edx
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001f	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00022	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00025	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00028	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002b	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$L284909:

; 148  : 		}

  0002e	c2 08 00	 ret	 8
?construct@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@ABU34@@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@@Z ; std::allocator<CGuildCombat::__JOINPLAYER>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::allocator<CGuildCombat::__JOINPLAYER>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@QAEXPAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::allocator<CGuildCombat::__JOINPLAYER>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >
EXTRN	__CxxThrowException@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN
; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b ca		 cmp	 ecx, edx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 1a		 je	 SHORT $L279588
  00010	56		 push	 esi
$L279586:

; 82   : 		_Al.construct(_Dest, *_First);

  00011	85 c0		 test	 eax, eax
  00013	74 0a		 je	 SHORT $L279587
  00015	8b 31		 mov	 esi, DWORD PTR [ecx]
  00017	89 30		 mov	 DWORD PTR [eax], esi
  00019	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0001c	89 70 04	 mov	 DWORD PTR [eax+4], esi
$L279587:
  0001f	83 c1 08	 add	 ecx, 8
  00022	83 c0 08	 add	 eax, 8
  00025	3b ca		 cmp	 ecx, edx
  00027	75 e8		 jne	 SHORT $L279586
  00029	5e		 pop	 esi
$L279588:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)
; 85   : 		_Al.destroy(_Next);
; 86   : 	_RERAISE;
; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  0002a	c3		 ret	 0
??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN
; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  00008	53		 push	 ebx
  00009	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Last$[esp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 1d		 je	 SHORT $L279621
  00011	56		 push	 esi
  00012	57		 push	 edi
$L279619:

; 82   : 		_Al.construct(_Dest, *_First);

  00013	85 c0		 test	 eax, eax
  00015	74 0b		 je	 SHORT $L279620
  00017	b9 09 00 00 00	 mov	 ecx, 9
  0001c	8b f2		 mov	 esi, edx
  0001e	8b f8		 mov	 edi, eax
  00020	f3 a5		 rep movsd
$L279620:
  00022	83 c2 24	 add	 edx, 36			; 00000024H
  00025	83 c0 24	 add	 eax, 36			; 00000024H
  00028	3b d3		 cmp	 edx, ebx
  0002a	75 e7		 jne	 SHORT $L279619
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
$L279621:
  0002e	5b		 pop	 ebx

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)
; 85   : 		_Al.destroy(_Next);
; 86   : 	_RERAISE;
; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  0002f	c3		 ret	 0
??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN
; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b ca		 cmp	 ecx, edx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 28		 je	 SHORT $L279630
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L279628:

; 82   : 		_Al.construct(_Dest, *_First);

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $L279629
  00017	8b f1		 mov	 esi, ecx
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	8b f8		 mov	 edi, eax
  0001d	89 1f		 mov	 DWORD PTR [edi], ebx
  0001f	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00022	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00025	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00028	89 77 08	 mov	 DWORD PTR [edi+8], esi
$L279629:
  0002b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	3b ca		 cmp	 ecx, edx
  00033	75 de		 jne	 SHORT $L279628
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
$L279630:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)
; 85   : 		_Al.destroy(_Next);
; 86   : 	_RERAISE;
; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  00038	c3		 ret	 0
??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN
; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b ca		 cmp	 ecx, edx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 28		 je	 SHORT $L279652
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L279650:

; 82   : 		_Al.construct(_Dest, *_First);

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $L279651
  00017	8b f1		 mov	 esi, ecx
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	8b f8		 mov	 edi, eax
  0001d	89 1f		 mov	 DWORD PTR [edi], ebx
  0001f	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00022	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00025	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00028	89 77 08	 mov	 DWORD PTR [edi+8], esi
$L279651:
  0002b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	3b ca		 cmp	 ecx, edx
  00033	75 de		 jne	 SHORT $L279650
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
$L279652:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)
; 85   : 		_Al.destroy(_Next);
; 86   : 	_RERAISE;
; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  00038	c3		 ret	 0
??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >, COMDAT

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN
; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	3b ca		 cmp	 ecx, edx
  0000a	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  0000e	74 3a		 je	 SHORT $L279679
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$L279677:

; 82   : 		_Al.construct(_Dest, *_First);

  00013	85 c0		 test	 eax, eax
  00015	74 26		 je	 SHORT $L279678
  00017	8b f1		 mov	 esi, ecx
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	8b f8		 mov	 edi, eax
  0001d	89 1f		 mov	 DWORD PTR [edi], ebx
  0001f	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00022	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00025	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00028	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0002b	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0002e	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00031	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00034	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  00037	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  0003a	89 77 14	 mov	 DWORD PTR [edi+20], esi
$L279678:
  0003d	83 c1 18	 add	 ecx, 24			; 00000018H
  00040	83 c0 18	 add	 eax, 24			; 00000018H
  00043	3b ca		 cmp	 ecx, edx
  00045	75 cc		 jne	 SHORT $L279677
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
$L279679:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)
; 85   : 		_Al.destroy(_Next);
; 86   : 	_RERAISE;
; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  0004a	c3		 ret	 0
??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >
_TEXT	ENDS
PUBLIC	??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ ; `string'
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetItemProp
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ DB 'GetItemProp range_er'
	DB	'ror', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 1a		 jl	 SHORT $L197914
  00008	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 10		 jge	 SHORT $L197914

; 1365 : 	return m_aPropItem.GetAt( nIndex ); 

  00012	3b c2		 cmp	 eax, edx
  00014	73 28		 jae	 SHORT $L285114
  00016	8b 89 4c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+588]
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1366 : }

  0001f	c2 04 00	 ret	 4
$L197914:

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00022	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00036	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$L285114:
  0003e	33 c0		 xor	 eax, eax

; 1366 : }

  00040	c2 04 00	 ret	 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ENDP		; CProject::GetItemProp
_TEXT	ENDS
PUBLIC	??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@	; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	?GetText@CProject@@QAEPBDK@Z			; CProject::GetText
;	COMDAT ??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@ DB 'GetText range_error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetText@CProject@@QAEPBDK@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetText@CProject@@QAEPBDK@Z PROC NEAR			; CProject::GetText, COMDAT
; _this$ = ecx

; 1402 : 	VERIFY_RANGE( (int)( dwIndex ), 0, m_colorText.GetSize(), "GetText range_error", "error" );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 41		 jl	 SHORT $L197970
  00008	8b 91 c8 02 00
	00		 mov	 edx, DWORD PTR [ecx+712]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 37		 jge	 SHORT $L197970

; 1403 : 	if( m_colorText.GetAt( dwIndex ) == NULL )

  00012	3b c2		 cmp	 eax, edx
  00014	73 0c		 jae	 SHORT $L285142
  00016	8b 91 b8 02 00
	00		 mov	 edx, DWORD PTR [ecx+696]
  0001c	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  00020	75 08		 jne	 SHORT $L197974
$L285142:

; 1404 : 		return "";

  00022	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 1406 : }

  00027	c2 04 00	 ret	 4
$L197974:

; 1405 : 	return m_colorText.GetAt( dwIndex )->lpszData; 

  0002a	3b 81 c8 02 00
	00		 cmp	 eax, DWORD PTR [ecx+712]
  00030	72 08		 jb	 SHORT $L285138
  00032	33 c0		 xor	 eax, eax
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1406 : }

  00037	c2 04 00	 ret	 4

; 1405 : 	return m_colorText.GetAt( dwIndex )->lpszData; 

$L285138:
  0003a	8b 89 b8 02 00
	00		 mov	 ecx, DWORD PTR [ecx+696]
  00040	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1406 : }

  00046	c2 04 00	 ret	 4
$L197970:

; 1402 : 	VERIFY_RANGE( (int)( dwIndex ), 0, m_colorText.GetSize(), "GetText range_error", "error" );

  00049	8b 91 c8 02 00
	00		 mov	 edx, DWORD PTR [ecx+712]
  0004f	50		 push	 eax
  00050	52		 push	 edx
  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0005d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00062	83 c4 14	 add	 esp, 20			; 00000014H
  00065	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@

; 1406 : }

  0006a	c2 04 00	 ret	 4
?GetText@CProject@@QAEPBDK@Z ENDP			; CProject::GetText
_TEXT	ENDS
PUBLIC	?GetPropA@CItemElem@@QAEPAUItemProp@@XZ		; CItemElem::GetPropA
EXTRN	?prj@@3VCProject@@A:BYTE			; prj
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ PROC NEAR	; CItemElem::GetPropA, COMDAT
; _this$ = ecx

; 229  : 	ItemProp*	GetProp()	{	return prj.GetItemProp( m_dwItemId );	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000b	7c 10		 jl	 SHORT $L285173
  0000d	3b c1		 cmp	 eax, ecx
  0000f	7d 0c		 jge	 SHORT $L285173
  00011	73 20		 jae	 SHORT $L285189
  00013	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00019	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001c	c3		 ret	 0
$L285173:
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0002b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$L285189:
  00033	33 c0		 xor	 eax, eax
  00035	c3		 ret	 0
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ENDP		; CItemElem::GetPropA
_TEXT	ENDS
PUBLIC	??6CAr@@QAEAAV0@H@Z				; CAr::operator<<
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\misc\include\ar.h
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??6CAr@@QAEAAV0@H@Z PROC NEAR				; CAr::operator<<, COMDAT
; _this$ = ecx

; 99   : 	{ return CAr::operator<<((LONG)i); }

  00000	56		 push	 esi
  00001	6a 04		 push	 4
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _i$[esp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	83 46 08 04	 add	 DWORD PTR [esi+8], 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??6CAr@@QAEAAV0@H@Z ENDP				; CAr::operator<<
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 501  : 		return( GetData()->nDataLength );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]

; 502  : 	}

  00005	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 210  : 	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 211  : 	{
; 212  : 		ATLASSERT( pStringMgr != NULL );
; 213  : 		CStringData* pData = pStringMgr->GetNilString();

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _pStringMgr$[esp]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 0c	 call	 DWORD PTR [eax+12]

; 214  : 		Attach( pData );

  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 06		 mov	 DWORD PTR [esi], eax

; 215  : 	}

  00011	8b c6		 mov	 eax, esi
  00013	5e		 pop	 esi
  00014	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 263  : 		CStringData* pData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 264  : 		pData->Release();

  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L285228
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L285228:

; 265  : 	}

  0001c	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
; Function compile flags: /Ogty
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nNewLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L285246
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L285246
  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 549  : 	}

  00018	c2 04 00	 ret	 4
$L285246:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L285249:
$L285248:
  00025	cc		 int	 3
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 35   : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z PROC NEAR ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ENDP ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC NEAR ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 422  : 		CStringData* pOldData = GetData();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 424  : 		if( pOldData->nDataLength == 0 )

  00005	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  00008	85 d2		 test	 edx, edx
  0000a	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	74 4c		 je	 SHORT $L285327
  00012	53		 push	 ebx

; 425  : 		{
; 426  : 			return;
; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

  00013	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00016	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  00019	85 db		 test	 ebx, ebx
  0001b	5b		 pop	 ebx
  0001c	7d 20		 jge	 SHORT $L221323

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

  0001e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00021	85 c0		 test	 eax, eax
  00023	7d 0a		 jge	 SHORT $L285316
  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L285332:
$L285316:
  0002f	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	5f		 pop	 edi
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003c	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  0003d	c3		 ret	 0
$L221323:

; 433  : 		}
; 434  : 		else
; 435  : 		{
; 436  : 			pOldData->Release();

  0003e	83 c9 ff	 or	 ecx, -1
  00041	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00045	49		 dec	 ecx
  00046	85 c9		 test	 ecx, ecx
  00048	7f 08		 jg	 SHORT $L285322
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	50		 push	 eax
  0004f	ff 52 04	 call	 DWORD PTR [edx+4]
$L285322:

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b cf		 mov	 ecx, edi
  00056	ff 50 0c	 call	 DWORD PTR [eax+12]

; 438  : 			Attach( pNewData );

  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 06		 mov	 DWORD PTR [esi], eax
$L285327:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  00060	c3		 ret	 0
$L285331:
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 747  : 		CStringData* pOldData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 748  : 		if( pOldData->nDataLength > nLength )

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _nLength$[esp-4]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7e 02		 jle	 SHORT $L221345

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  00011	8b d6		 mov	 edx, esi
$L221345:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00013	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00017	5e		 pop	 esi
  00018	7e 09		 jle	 SHORT $L221346

; 753  : 		{
; 754  : 			Fork( nLength );

  0001a	89 54 24 04	 mov	 DWORD PTR _nLength$[esp-4], edx
  0001e	e9 00 00 00 00	 jmp	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L221346:

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00023	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00026	3b c2		 cmp	 eax, edx
  00028	7d 1f		 jge	 SHORT $L221348

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;
; 760  : 			if( nNewLength > 1024 )

  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7e 07		 jle	 SHORT $L221350

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00031	05 00 04 00 00	 add	 eax, 1024		; 00000400H

; 763  : 			}
; 764  : 			else

  00036	eb 02		 jmp	 SHORT $L221351
$L221350:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00038	03 c0		 add	 eax, eax
$L221351:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 02		 jge	 SHORT $L221352

; 769  : 			{
; 770  : 				nNewLength = nLength;

  0003e	8b c2		 mov	 eax, edx
$L221352:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00040	89 44 24 04	 mov	 DWORD PTR _nLength$[esp-4], eax
  00044	e9 00 00 00 00	 jmp	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L221348:

; 773  : 		}
; 774  : 	}

  00049	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
PUBLIC	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
; Function compile flags: /Ogty
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CloneData, COMDAT

; 801  : 	{

  00000	56		 push	 esi

; 802  : 		CStringData* pNewData = NULL;
; 803  : 
; 804  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pData$[esp]
  00005	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 10	 call	 DWORD PTR [eax+16]

; 805  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

  0000c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0000f	85 d2		 test	 edx, edx
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	7c 11		 jl	 SHORT $L221356
  00016	3b 06		 cmp	 eax, DWORD PTR [esi]
  00018	75 0d		 jne	 SHORT $L221356

; 806  : 		{
; 807  : 			pNewData = pData;

  0001a	8b c6		 mov	 eax, esi

; 808  : 			pNewData->AddRef();

  0001c	ba 01 00 00 00	 mov	 edx, 1
  00021	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00025	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  00026	c3		 ret	 0
$L221356:

; 809  : 		}
; 810  : 		else
; 811  : 		{
; 812  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	6a 01		 push	 1
  0002e	51		 push	 ecx
  0002f	8b c8		 mov	 ecx, eax
  00031	ff 12		 call	 DWORD PTR [edx]

; 813  : 			if( pNewData == NULL )

  00033	85 c0		 test	 eax, eax
  00035	75 05		 jne	 SHORT $L221359

; 814  : 			{
; 815  : 				ThrowMemoryException();

  00037	e9 00 00 00 00	 jmp	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L221359:

; 816  : 			}
; 817  : 			pNewData->nDataLength = pData->nDataLength;

  0003c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 818  : 			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'

  00042	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00045	41		 inc	 ecx
  00046	8b d1		 mov	 edx, ecx
  00048	57		 push	 edi
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	83 c6 10	 add	 esi, 16			; 00000010H
  0004f	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  00052	f3 a5		 rep movsd
  00054	8b ca		 mov	 ecx, edx
  00056	83 e1 03	 and	 ecx, 3
  00059	f3 a4		 rep movsb
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  0005d	c3		 ret	 0
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ENDP ; ATL::CSimpleStringT<char,0>::CloneData
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00008	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000b	72 0a		 jb	 SHORT $L285371
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1476 : 		}

  00014	c2 04 00	 ret	 4

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$L285371:
  00017	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 1476 : 		}

  0001c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@K@std@@QAEPAKI@Z		; std::allocator<unsigned long>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@K@std@@QAEPAKI@Z PROC NEAR	; std::allocator<unsigned long>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@K@std@@QAEPAKI@Z ENDP		; std::allocator<unsigned long>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogty
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC NEAR	; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogty
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1116 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 138  : 		}

  0000d	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Wherenode$[esp-4]
  00004	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  0000e	8b 30		 mov	 esi, DWORD PTR [eax]
  00010	8a 5e 15	 mov	 bl, BYTE PTR [esi+21]
  00013	84 db		 test	 bl, bl
  00015	75 03		 jne	 SHORT $L223699

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L223699:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00026	75 0d		 jne	 SHORT $L223700

; 1023 : 			_Root() = _Pnode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00031	5b		 pop	 ebx

; 1031 : 		}

  00032	c2 04 00	 ret	 4
$L223700:

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0c		 jne	 SHORT $L223702

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0003f	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  00041	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00044	5b		 pop	 ebx

; 1031 : 		}

  00045	c2 04 00	 ret	 4
$L223702:

; 1026 : 		else
; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00048	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0004b	5e		 pop	 esi

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  0004c	89 10		 mov	 DWORD PTR [eax], edx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0004e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00051	5b		 pop	 ebx

; 1031 : 		}

  00052	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?JoinWar@CGuildCombat@@QAEXPAVCUser@@HH@Z	; CGuildCombat::JoinWar
EXTRN	?AddText@CUser@@QAEXPBD@Z:NEAR			; CUser::AddText
EXTRN	?SetOther@CVTInfo@@QAEXPAVCMover@@@Z:NEAR	; CVTInfo::SetOther
EXTRN	?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z:NEAR ; CMover::Replace
EXTRN	?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z:NEAR ; CUserMng::AddGuildCombatUserState
EXTRN	?g_uIdofMulti@@3KA:DWORD			; g_uIdofMulti
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ?JoinWar@CGuildCombat@@QAEXPAVCUser@@HH@Z
_TEXT	SEGMENT
$T285541 = -60						; size = 12
$T285540 = -60						; size = 12
$T285539 = -60						; size = 12
$T285538 = -60						; size = 12
_v3Pos$ = -48						; size = 48
_pUser$ = 8						; size = 4
_nMap$ = 12						; size = 4
_bWar$ = 16						; size = 4
?JoinWar@CGuildCombat@@QAEXPAVCUser@@HH@Z PROC NEAR	; CGuildCombat::JoinWar, COMDAT
; _this$ = ecx

; 574  : {

  00000	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 580  : 
; 581  : 	int nPos = xRandom(4);

  00003	56		 push	 esi

; 582  : 	if( nMap == 99 )

  00004	57		 push	 edi

; 575  : 	D3DXVECTOR3 v3Pos[4];
; 576  : 	v3Pos[0] = D3DXVECTOR3(1263, 83, 1303);

  00005	c7 44 24 08 00
	e0 9d 44	 mov	 DWORD PTR $T285538[esp+68], 1151197184 ; 449de000H
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR $T285538[esp+68]
  00011	89 44 24 14	 mov	 DWORD PTR _v3Pos$[esp+68], eax
  00015	c7 44 24 10 00
	e0 a2 44	 mov	 DWORD PTR $T285538[esp+76], 1151524864 ; 44a2e000H
  0001d	8b 44 24 10	 mov	 eax, DWORD PTR $T285538[esp+76]
  00021	89 44 24 1c	 mov	 DWORD PTR _v3Pos$[esp+76], eax
  00025	c7 44 24 0c 00
	00 a6 42	 mov	 DWORD PTR $T285538[esp+72], 1118175232 ; 42a60000H
  0002d	8b 54 24 0c	 mov	 edx, DWORD PTR $T285538[esp+72]
  00031	89 54 24 18	 mov	 DWORD PTR _v3Pos$[esp+72], edx

; 577  : 	v3Pos[1] = D3DXVECTOR3(1310, 83, 1303);

  00035	c7 44 24 0c 00
	00 a6 42	 mov	 DWORD PTR $T285539[esp+72], 1118175232 ; 42a60000H
  0003d	8b 44 24 0c	 mov	 eax, DWORD PTR $T285539[esp+72]
  00041	89 44 24 24	 mov	 DWORD PTR _v3Pos$[esp+84], eax
  00045	c7 44 24 08 00
	c0 a3 44	 mov	 DWORD PTR $T285539[esp+68], 1151582208 ; 44a3c000H
  0004d	8b 54 24 08	 mov	 edx, DWORD PTR $T285539[esp+68]
  00051	89 54 24 20	 mov	 DWORD PTR _v3Pos$[esp+80], edx

; 578  : 	v3Pos[2] = D3DXVECTOR3(1265, 83, 1254);

  00055	c7 44 24 08 00
	20 9e 44	 mov	 DWORD PTR $T285540[esp+68], 1151213568 ; 449e2000H
  0005d	8b 44 24 08	 mov	 eax, DWORD PTR $T285540[esp+68]
  00061	89 44 24 2c	 mov	 DWORD PTR _v3Pos$[esp+92], eax
  00065	c7 44 24 10 00
	e0 a2 44	 mov	 DWORD PTR $T285539[esp+76], 1151524864 ; 44a2e000H
  0006d	8b 54 24 10	 mov	 edx, DWORD PTR $T285539[esp+76]
  00071	89 54 24 28	 mov	 DWORD PTR _v3Pos$[esp+88], edx
  00075	c7 44 24 10 00
	c0 9c 44	 mov	 DWORD PTR $T285540[esp+76], 1151123456 ; 449cc000H
  0007d	8b 44 24 10	 mov	 eax, DWORD PTR $T285540[esp+76]
  00081	c7 44 24 0c 00
	00 a6 42	 mov	 DWORD PTR $T285540[esp+72], 1118175232 ; 42a60000H
  00089	8b 54 24 0c	 mov	 edx, DWORD PTR $T285540[esp+72]
  0008d	89 44 24 34	 mov	 DWORD PTR _v3Pos$[esp+100], eax

; 579  : 	v3Pos[3] = D3DXVECTOR3(1314, 83, 1253);

  00091	c7 44 24 0c 00
	00 a6 42	 mov	 DWORD PTR $T285541[esp+72], 1118175232 ; 42a60000H
  00099	8b 44 24 0c	 mov	 eax, DWORD PTR $T285541[esp+72]
  0009d	89 44 24 3c	 mov	 DWORD PTR _v3Pos$[esp+108], eax

; 580  : 
; 581  : 	int nPos = xRandom(4);

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  000a6	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  000ac	89 54 24 30	 mov	 DWORD PTR _v3Pos$[esp+96], edx
  000b0	c7 44 24 08 00
	40 a4 44	 mov	 DWORD PTR $T285541[esp+68], 1151614976 ; 44a44000H
  000b8	8b 54 24 08	 mov	 edx, DWORD PTR $T285541[esp+68]

; 582  : 	if( nMap == 99 )

  000bc	8b 74 24 4c	 mov	 esi, DWORD PTR _nMap$[esp+64]
  000c0	c7 44 24 10 00
	a0 9c 44	 mov	 DWORD PTR $T285541[esp+76], 1151115264 ; 449ca000H
  000c8	89 54 24 38	 mov	 DWORD PTR _v3Pos$[esp+104], edx
  000cc	8b 54 24 10	 mov	 edx, DWORD PTR $T285541[esp+76]
  000d0	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  000d5	83 fe 63	 cmp	 esi, 99			; 00000063H
  000d8	89 54 24 40	 mov	 DWORD PTR _v3Pos$[esp+112], edx
  000dc	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  000e1	75 05		 jne	 SHORT $L268700
  000e3	83 e0 03	 and	 eax, 3

; 583  : 		nMap = nPos;

  000e6	8b f0		 mov	 esi, eax
$L268700:

; 584  : 
; 585  : 	if( m_nState == WAR_STATE )

  000e8	8b 81 40 11 00
	00		 mov	 eax, DWORD PTR [ecx+4416]
  000ee	8b 7c 24 48	 mov	 edi, DWORD PTR _pUser$[esp+64]
  000f2	ba 02 00 00 00	 mov	 edx, 2
  000f7	3b c2		 cmp	 eax, edx
  000f9	75 3d		 jne	 SHORT $L268705

; 586  : 	{
; 587  : 		if( m_nGCState == WAR_WAR_STATE )

  000fb	8b 81 44 11 00
	00		 mov	 eax, DWORD PTR [ecx+4420]
  00101	83 f8 68	 cmp	 eax, 104		; 00000068H
  00104	75 0c		 jne	 SHORT $L268702

; 588  : 			pUser->m_nGuildCombatState = 1;

  00106	c7 87 98 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+3736], 1

; 589  : 		else if( m_nGCState == MAINTENANCE_STATE )

  00110	eb 0b		 jmp	 SHORT $L268704
$L268702:
  00112	83 f8 67	 cmp	 eax, 103		; 00000067H
  00115	75 06		 jne	 SHORT $L268704

; 590  : 			pUser->m_nGuildCombatState = 2;

  00117	89 97 98 0e 00
	00		 mov	 DWORD PTR [edi+3736], edx
$L268704:

; 591  : 
; 592  : 		if( m_nGCState == WAR_WAR_STATE || m_nGCState == MAINTENANCE_STATE )

  0011d	8b 89 44 11 00
	00		 mov	 ecx, DWORD PTR [ecx+4420]
  00123	83 f9 68	 cmp	 ecx, 104		; 00000068H
  00126	74 05		 je	 SHORT $L268706
  00128	83 f9 67	 cmp	 ecx, 103		; 00000067H
  0012b	75 0b		 jne	 SHORT $L268705
$L268706:

; 593  : 			g_UserMng.AddGuildCombatUserState( pUser );

  0012d	57		 push	 edi
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00133	e8 00 00 00 00	 call	 ?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddGuildCombatUserState
$L268705:

; 594  : 	}
; 595  : 	
; 596  : 	((CMover*)pUser)->REPLACE( g_uIdofMulti, WI_WORLD_GUILDWAR, v3Pos[nMap], REPLACE_NORMAL, nDefaultLayer );

  00138	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  0013e	6a 00		 push	 0
  00140	6a 00		 push	 0
  00142	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00145	8d 4c 84 1c	 lea	 ecx, DWORD PTR _v3Pos$[esp+eax*4+76]
  00149	51		 push	 ecx
  0014a	68 ca 00 00 00	 push	 202			; 000000caH
  0014f	52		 push	 edx
  00150	8b cf		 mov	 ecx, edi
  00152	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 597  : 	pUser->m_vtInfo.SetOther( NULL );

  00157	6a 00		 push	 0
  00159	8d 8f 7c 0d 00
	00		 lea	 ecx, DWORD PTR [edi+3452]
  0015f	e8 00 00 00 00	 call	 ?SetOther@CVTInfo@@QAEXPAVCMover@@@Z ; CVTInfo::SetOther

; 598  : 
; 599  : 	if( bWar )

  00164	8b 44 24 50	 mov	 eax, DWORD PTR _bWar$[esp+64]
  00168	85 c0		 test	 eax, eax
  0016a	0f 85 bd 00 00
	00		 jne	 $L268709

; 600  : 	{
; 601  : 	}
; 602  : 	else
; 603  : 	{
; 604  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_WELCOME) );

  00170	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00175	3d 91 0a 00 00	 cmp	 eax, 2705		; 00000a91H
  0017a	7e 1d		 jle	 SHORT $L285605
  0017c	76 0f		 jbe	 SHORT $L285673
  0017e	a1 b8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+696
  00183	8b 80 44 2a 00
	00		 mov	 eax, DWORD PTR [eax+10820]
  00189	85 c0		 test	 eax, eax
  0018b	75 07		 jne	 SHORT $L285606
$L285673:
  0018d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00192	eb 24		 jmp	 SHORT $L285600
$L285606:
  00194	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00197	eb 1f		 jmp	 SHORT $L285600
$L285605:
  00199	68 91 0a 00 00	 push	 2705			; 00000a91H
  0019e	50		 push	 eax
  0019f	6a 00		 push	 0
  001a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  001a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  001ab	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  001b0	83 c4 14	 add	 esp, 20			; 00000014H
  001b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L285600:
  001b8	50		 push	 eax
  001b9	8b cf		 mov	 ecx, edi
  001bb	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 605  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_MASTER_MAP) );

  001c0	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  001c5	3d a3 0a 00 00	 cmp	 eax, 2723		; 00000aa3H
  001ca	7e 3a		 jle	 SHORT $L285653
  001cc	76 10		 jbe	 SHORT $L285674
  001ce	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  001d4	8b 81 8c 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10892]
  001da	85 c0		 test	 eax, eax
  001dc	75 15		 jne	 SHORT $L285654
$L285674:
  001de	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001e3	50		 push	 eax
  001e4	8b cf		 mov	 ecx, edi
  001e6	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  001eb	5f		 pop	 edi
  001ec	5e		 pop	 esi

; 606  : 	}
; 607  : }

  001ed	83 c4 3c	 add	 esp, 60			; 0000003cH
  001f0	c2 0c 00	 ret	 12			; 0000000cH

; 605  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_MASTER_MAP) );

$L285654:
  001f3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f6	50		 push	 eax
  001f7	8b cf		 mov	 ecx, edi
  001f9	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi

; 606  : 	}
; 607  : }

  00200	83 c4 3c	 add	 esp, 60			; 0000003cH
  00203	c2 0c 00	 ret	 12			; 0000000cH

; 605  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_MASTER_MAP) );

$L285653:
  00206	68 a3 0a 00 00	 push	 2723			; 00000aa3H
  0020b	50		 push	 eax
  0020c	6a 00		 push	 0
  0020e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00213	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00218	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0021d	83 c4 14	 add	 esp, 20			; 00000014H
  00220	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  00225	50		 push	 eax
  00226	8b cf		 mov	 ecx, edi
  00228	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
$L268709:
  0022d	5f		 pop	 edi
  0022e	5e		 pop	 esi

; 606  : 	}
; 607  : }

  0022f	83 c4 3c	 add	 esp, 60			; 0000003cH
  00232	c2 0c 00	 ret	 12			; 0000000cH
?JoinWar@CGuildCombat@@QAEXPAVCUser@@HH@Z ENDP		; CGuildCombat::JoinWar
_TEXT	ENDS
PUBLIC	??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_psz2$ = 12						; size = 4
??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z PROC NEAR ; ATL::operator==, COMDAT

; 2088 : 		return( str1.Compare( psz2 ) == 0 );

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _psz2$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _str1$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	51		 push	 ecx
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __mbscmp
  00011	83 c4 08	 add	 esp, 8
  00014	f7 d8		 neg	 eax
  00016	1b c0		 sbb	 eax, eax
  00018	40		 inc	 eax

; 2089 : 	}

  00019	c3		 ret	 0
??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ENDP ; ATL::operator==
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin, COMDAT
; _this$ = ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 378  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end, COMDAT
; _this$ = ecx

; 387  : 		return (iterator(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : 		}

  00009	c2 04 00	 ret	 4
?end@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end
_TEXT	ENDS
PUBLIC	?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  00008	89 09		 mov	 DWORD PTR [ecx], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	89 49 04	 mov	 DWORD PTR [ecx+4], ecx

; 615  : 		_Mysize = 0;
; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00010	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00013	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001a	74 19		 je	 SHORT $L270795
  0001c	57		 push	 edi
  0001d	8d 49 00	 npad	 3
$L270793:

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00020	8b 38		 mov	 edi, DWORD PTR [eax]

; 620  : 			this->_Alnod.destroy(_Pnode);
; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f9		 cmp	 edi, ecx
  00030	8b c7		 mov	 eax, edi
  00032	75 ec		 jne	 SHORT $L270793
  00034	5f		 pop	 edi
$L270795:
  00035	5e		 pop	 esi

; 622  : 			}
; 623  : 		}

  00036	c3		 ret	 0
?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::end
_TEXT	ENDS
PUBLIC	??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAU__REQUESTGUILD@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator[]
_TEXT	ENDS
PUBLIC	??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 240  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 241  : 			}

  00005	c3		 ret	 0
??Diterator@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::end
_TEXT	ENDS
PUBLIC	?erase@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::erase
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?erase@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::erase, COMDAT
; _this$ = ecx

; 587  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 588  : 		if (_Pnode != _Myhead)

  00007	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0000a	57		 push	 edi
  0000b	8b 38		 mov	 edi, DWORD PTR [eax]
  0000d	74 1f		 je	 SHORT $L286023

; 589  : 			{	// not list head, safe to erase
; 590  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	89 11		 mov	 DWORD PTR [ecx], edx

; 591  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 592  : 			this->_Alnod.destroy(_Pnode);
; 593  : 			this->_Alnod.deallocate(_Pnode, 1);

  0001b	50		 push	 eax
  0001c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 594  : 			--_Mysize;

  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	83 c4 04	 add	 esp, 4
  0002a	48		 dec	 eax
  0002b	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L286023:

; 595  : 			}
; 596  : 		return (_Where);

  0002e	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00032	89 38		 mov	 DWORD PTR [eax], edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 597  : 		}

  00036	c2 08 00	 ret	 8
?erase@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
; Function compile flags: /Ogty
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode, COMDAT
; _this$ = ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 900  : 		int _Linkcnt = 0;
; 901  : 
; 902  : 		_TRY_BEGIN
; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  0000a	85 c0		 test	 eax, eax
  0000c	74 02		 je	 SHORT $L286058
  0000e	89 00		 mov	 DWORD PTR [eax], eax
$L286058:

; 904  : 		++_Linkcnt;
; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	85 c9		 test	 ecx, ecx
  00015	74 02		 je	 SHORT $L286086
  00017	89 01		 mov	 DWORD PTR [ecx], eax
$L286086:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)
; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 909  : 		this->_Alnod.deallocate(_Pnode, 1);
; 910  : 		_RERAISE;
; 911  : 		_CATCH_END
; 912  : 		return (_Pnode);
; 913  : 		}

  00019	c3		 ret	 0
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 930  : 		clear();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4

; 934  : 		_Myhead = 0;

  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	5e		 pop	 esi

; 935  : 		}

  0001c	c3		 ret	 0
?_Tidy@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy
_TEXT	ENDS
PUBLIC	?end@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?end@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuild@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuild@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuild@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuild@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?end@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?end@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::end
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lbound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L273638
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L273637:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $L273639

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  0001c	eb 04		 jmp	 SHORT $L273640
$L273639:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L273640:
  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L273637
  00029	5b		 pop	 ebx
$L273638:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
; Function compile flags: /Ogty
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKH@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000a	85 c0		 test	 eax, eax
  0000c	74 2e		 je	 SHORT $L286296
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Larg$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Rarg$[esp-4]
  0001c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001f	8b 4c 24 10	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00023	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0002b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002e	8a 54 24 14	 mov	 dl, BYTE PTR __Carg$[esp-4]
  00032	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00035	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00038	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0
$L286296:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);
; 1139 : 		}

  0003c	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator--
; Function compile flags: /Ogty
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 227  : 			{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 228  : 			_Dec();

  00003	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 230  : 			}

  0000b	c3		 ret	 0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode, COMDAT
; _this$ = ecx

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 919  : 		_TRY_BEGIN
; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

  0000a	85 c0		 test	 eax, eax
  0000c	74 16		 je	 SHORT $L286332
  0000e	8b 4c 24 04	 mov	 ecx, DWORD PTR __Next$[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR __Prev$[esp-4]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
  00018	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0001c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L286332:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);
; 923  : 		_RERAISE;
; 924  : 		_CATCH_END
; 925  : 		return (_Pnode);
; 926  : 		}

  00024	c2 0c 00	 ret	 12			; 0000000cH
?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 65   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_ptr@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_ptr<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::begin
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXPAPAU__GuildCombatMember@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXPAPAU__GuildCombatMember@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXPAPAU__GuildCombatMember@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXPAPAU__GuildCombatMember@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::begin
; Function compile flags: /Ogty
;	COMDAT ?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::begin
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  0000a	85 c0		 test	 eax, eax
  0000c	74 06		 je	 SHORT $L286454
  0000e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L286454:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00014	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00017	85 c9		 test	 ecx, ecx
  00019	74 06		 je	 SHORT $L286481
  0001b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L286481:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00021	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $L286508
  00028	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L286508:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  0002e	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00032	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00036	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >, COMDAT
; _this$ = ecx

; 76   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 77   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_ptr@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??_C@_0EK@GINEPMCL@template?5?$DMclass?5T?$DO?5BOOL?5CItemCon@ ; `string'
PUBLIC	?Add@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAEPAF1@Z ; CItemContainer<CItemElem>::Add
EXTRN	?SetTexture@CItemBase@@QAEXXZ:NEAR		; CItemBase::SetTexture
;	COMDAT ??_C@_0EK@GINEPMCL@template?5?$DMclass?5T?$DO?5BOOL?5CItemCon@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
CONST	SEGMENT
??_C@_0EK@GINEPMCL@template?5?$DMclass?5T?$DO?5BOOL?5CItemCon@ DB 'templa'
	DB	'te <class T> BOOL CItemContainer<T>::Add( T* pElem... : nNumt'
	DB	'mp > 0', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?Add@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAEPAF1@Z
_TEXT	SEGMENT
_nNumtmp$ = -12						; size = 2
_i$276057 = -12						; size = 4
_this$ = -8						; size = 4
_i$276039 = -4						; size = 4
_pElem$ = 8						; size = 4
_pnId$ = 12						; size = 4
_pnNum$ = 16						; size = 4
$T286580 = 20						; size = 4
_pnCount$ = 20						; size = 4
?Add@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAEPAF1@Z PROC NEAR ; CItemContainer<CItemElem>::Add, COMDAT
; _this$ = ecx

; 662  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 663  : 	if( pnId )

  00003	8b 44 24 14	 mov	 eax, DWORD PTR _pnId$[esp+8]
  00007	85 c0		 test	 eax, eax
  00009	53		 push	 ebx
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	57		 push	 edi
  0000f	8b 7c 24 2c	 mov	 edi, DWORD PTR _pnCount$[esp+24]
  00013	89 74 24 14	 mov	 DWORD PTR _this$[esp+28], esi
  00017	74 03		 je	 SHORT $L276028

; 664  : 		*pnCount	= 0;

  00019	c6 07 00	 mov	 BYTE PTR [edi], 0
$L276028:

; 665  : 	ItemProp* pItemProp		= pElem->GetProp();

  0001c	8b 6c 24 20	 mov	 ebp, DWORD PTR _pElem$[esp+24]
  00020	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00023	85 c0		 test	 eax, eax
  00025	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0002b	7c 48		 jl	 SHORT $L286609
  0002d	3b c1		 cmp	 eax, ecx
  0002f	7d 44		 jge	 SHORT $L286609
  00031	72 31		 jb	 SHORT $L286621
  00033	33 db		 xor	 ebx, ebx
  00035	89 5c 24 2c	 mov	 DWORD PTR $T286580[esp+24], ebx
$L286604:

; 666  : 	if( !pItemProp )

  00039	85 db		 test	 ebx, ebx

; 667  : 		return FALSE;

  0003b	74 1b		 je	 SHORT $L286634

; 668  : 
; 669  : #ifdef __TABBED_INV
; 670  : 	int nIndex = pItemProp->GetInvenIndex();
; 671  : #endif
; 672  : 
; 673  : 	BOOL bPackItem = TRUE;
; 674  : 	int nId;
; 675  : 
; 676  : 	short nNumtmp	= ( (CItemElem*)pElem )->m_nItemNum;

  0003d	33 c0		 xor	 eax, eax
  0003f	66 8b 85 80 00
	00 00		 mov	 ax, WORD PTR [ebp+128]

; 677  : 	if( IsFull( pElem, pItemProp, nNumtmp ) )	//    

  00046	8b ce		 mov	 ecx, esi
  00048	50		 push	 eax
  00049	53		 push	 ebx
  0004a	55		 push	 ebp
  0004b	89 44 24 1c	 mov	 DWORD PTR _nNumtmp$[esp+40], eax
  0004f	e8 00 00 00 00	 call	 ?IsFull@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAUItemProp@@F@Z ; CItemContainer<CItemElem>::IsFull
  00054	85 c0		 test	 eax, eax
  00056	74 3f		 je	 SHORT $L276035
$L286634:
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5d		 pop	 ebp

; 678  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5b		 pop	 ebx

; 765  : }

  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	c2 10 00	 ret	 16			; 00000010H

; 665  : 	ItemProp* pItemProp		= pElem->GetProp();

$L286621:
  00064	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0006a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0006d	89 54 24 2c	 mov	 DWORD PTR $T286580[esp+24], edx
  00071	8b da		 mov	 ebx, edx
  00073	eb c4		 jmp	 SHORT $L286604
$L286609:
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	6a 00		 push	 0
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00083	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00088	83 c4 14	 add	 esp, 20			; 00000014H
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5d		 pop	 ebp

; 678  : 		return FALSE;

  0008e	33 c0		 xor	 eax, eax
  00090	5b		 pop	 ebx

; 765  : }

  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	c2 10 00	 ret	 16			; 00000010H
$L276035:

; 679  : 
; 680  : 	if( pItemProp->dwPackMax == 1 )

  00097	83 7b 6c 01	 cmp	 DWORD PTR [ebx+108], 1

; 681  : 		bPackItem = FALSE;
; 682  : 
; 683  : 	CItemElem* pElemtmp;
; 684  : 	if( bPackItem )

  0009b	0f 84 e5 00 00
	00		 je	 $L286641

; 685  : 	{
; 686  : 		for( DWORD i = 0; i < m_dwIndexNum; i++ )

  000a1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a4	33 c0		 xor	 eax, eax
  000a6	85 c9		 test	 ecx, ecx
  000a8	89 44 24 18	 mov	 DWORD PTR _i$276039[esp+28], eax
  000ac	0f 86 d4 00 00
	00		 jbe	 $L286641
$L276040:

; 687  : 		{
; 688  : 			nId	= m_apIndex[i];

  000b2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b5	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]

; 689  : 			if( nId < 0 || nId >= (int)( m_dwItemMax ) )

  000b8	85 db		 test	 ebx, ebx
  000ba	0f 8c b2 00 00
	00		 jl	 $L276041
  000c0	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  000c3	0f 8d a9 00 00
	00		 jge	 $L276041

; 690  : 				continue;
; 691  : 			pElemtmp	= (CItemElem*)&m_apItem[nId];

  000c9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000cc	8b c3		 mov	 eax, ebx
  000ce	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  000d4	03 c1		 add	 eax, ecx

; 692  : 			
; 693  : 			if( pElemtmp->IsEmpty() == FALSE && pElemtmp->m_dwItemId == pElem->m_dwItemId && pElemtmp->m_nItemNum < (short)pItemProp->dwPackMax 
; 694  : 				&& pElem->m_byFlag == pElemtmp->m_byFlag && pElem->m_bCharged == pElemtmp->m_bCharged )

  000d6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d9	85 c9		 test	 ecx, ecx
  000db	0f 84 91 00 00
	00		 je	 $L276041
  000e1	3b 4d 0c	 cmp	 ecx, DWORD PTR [ebp+12]
  000e4	0f 85 88 00 00
	00		 jne	 $L276041
  000ea	66 8b 88 80 00
	00 00		 mov	 cx, WORD PTR [eax+128]
  000f1	8b 54 24 2c	 mov	 edx, DWORD PTR $T286580[esp+24]
  000f5	66 3b 4a 6c	 cmp	 cx, WORD PTR [edx+108]
  000f9	7d 77		 jge	 SHORT $L276041
  000fb	8a 95 82 00 00
	00		 mov	 dl, BYTE PTR [ebp+130]
  00101	3a 90 82 00 00
	00		 cmp	 dl, BYTE PTR [eax+130]
  00107	75 69		 jne	 SHORT $L276041
  00109	8b 95 ac 00 00
	00		 mov	 edx, DWORD PTR [ebp+172]
  0010f	3b 90 ac 00 00
	00		 cmp	 edx, DWORD PTR [eax+172]
  00115	75 5b		 jne	 SHORT $L276041

; 695  : 			{
; 696  : 				if( pElemtmp->m_nItemNum + nNumtmp > (short)pItemProp->dwPackMax )

  00117	0f bf 6c 24 10	 movsx	 ebp, WORD PTR _nNumtmp$[esp+28]
  0011c	0f bf d1	 movsx	 edx, cx
  0011f	03 d5		 add	 edx, ebp
  00121	8b 6c 24 2c	 mov	 ebp, DWORD PTR $T286580[esp+24]
  00125	0f bf 6d 6c	 movsx	 ebp, WORD PTR [ebp+108]
  00129	3b d5		 cmp	 edx, ebp
  0012b	0f 8e 35 01 00
	00		 jle	 $L276050

; 697  : 				{
; 698  : 					nNumtmp	-= ( (short)pItemProp->dwPackMax - pElemtmp->m_nItemNum );

  00131	8b 54 24 2c	 mov	 edx, DWORD PTR $T286580[esp+24]
  00135	0f bf 52 6c	 movsx	 edx, WORD PTR [edx+108]
  00139	8b 6c 24 10	 mov	 ebp, DWORD PTR _nNumtmp$[esp+28]
  0013d	2b ca		 sub	 ecx, edx
  0013f	03 e9		 add	 ebp, ecx

; 699  : 					pElemtmp->m_nItemNum	= (short)pItemProp->dwPackMax;
; 700  : 					if( pnId )

  00141	8b 4c 24 24	 mov	 ecx, DWORD PTR _pnId$[esp+24]
  00145	85 c9		 test	 ecx, ecx
  00147	89 6c 24 10	 mov	 DWORD PTR _nNumtmp$[esp+28], ebp

; 701  : 					{
; 702  : 						pnId[*pnCount]	= nId;
; 703  : 						pnNum[*pnCount]	= pElemtmp->m_nItemNum;
; 704  : 						( *pnCount )++;

  0014b	8b 6c 24 20	 mov	 ebp, DWORD PTR _pElem$[esp+24]
  0014f	66 89 90 80 00
	00 00		 mov	 WORD PTR [eax+128], dx
  00156	74 1a		 je	 SHORT $L276041
  00158	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  0015b	88 1c 0a	 mov	 BYTE PTR [edx+ecx], bl
  0015e	66 8b 90 80 00
	00 00		 mov	 dx, WORD PTR [eax+128]
  00165	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00168	8b 44 24 28	 mov	 eax, DWORD PTR _pnNum$[esp+24]
  0016c	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  00170	fe 07		 inc	 BYTE PTR [edi]
$L276041:
  00172	8b 44 24 18	 mov	 eax, DWORD PTR _i$276039[esp+28]
  00176	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00179	40		 inc	 eax
  0017a	3b c1		 cmp	 eax, ecx
  0017c	89 44 24 18	 mov	 DWORD PTR _i$276039[esp+28], eax
  00180	0f 82 2c ff ff
	ff		 jb	 $L276040
$L286641:

; 713  : 					}
; 714  : 					nNumtmp = 0;
; 715  : 					break;
; 716  : 				}
; 717  : 			}
; 718  : 			
; 719  : 		}
; 720  : 	}
; 721  : 
; 722  : 	if( nNumtmp > 0 )

  00186	66 8b 6c 24 10	 mov	 bp, WORD PTR _nNumtmp$[esp+28]
  0018b	66 85 ed	 test	 bp, bp
  0018e	0f 8e c3 00 00
	00		 jle	 $L286637

; 723  : 	{
; 724  : 		for( DWORD i = 0; i < m_dwIndexNum; i++ )

  00194	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00197	33 c0		 xor	 eax, eax
  00199	85 c9		 test	 ecx, ecx
  0019b	89 44 24 10	 mov	 DWORD PTR _i$276057[esp+28], eax
  0019f	0f 86 a0 00 00
	00		 jbe	 $L276073
$L276058:

; 725  : 		{
; 726  : 			nId	= m_apIndex[i];

  001a5	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001a8	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]

; 727  : 			if( nId < 0 || nId >= (int)( m_dwItemMax ) )

  001ab	85 db		 test	 ebx, ebx
  001ad	0f 8c 7e 00 00
	00		 jl	 $L276059
  001b3	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  001b6	7d 79		 jge	 SHORT $L276059

; 728  : 				continue;
; 729  : 			pElemtmp	= (CItemElem*)&m_apItem[nId];

  001b8	8b 54 24 14	 mov	 edx, DWORD PTR _this$[esp+28]
  001bc	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  001bf	8b f3		 mov	 esi, ebx
  001c1	69 f6 b8 00 00
	00		 imul	 esi, 184		; 000000b8H

; 730  : 			if( pElemtmp->IsEmpty() )	//  

  001c7	8b 44 0e 0c	 mov	 eax, DWORD PTR [esi+ecx+12]
  001cb	03 f1		 add	 esi, ecx
  001cd	85 c0		 test	 eax, eax
  001cf	75 5c		 jne	 SHORT $L286636

; 731  : 			{
; 732  : 				*pElemtmp	= *( (CItemElem*)pElem );

  001d1	8b 4c 24 20	 mov	 ecx, DWORD PTR _pElem$[esp+24]
  001d5	8b 06		 mov	 eax, DWORD PTR [esi]
  001d7	51		 push	 ecx
  001d8	8b ce		 mov	 ecx, esi
  001da	ff 50 10	 call	 DWORD PTR [eax+16]

; 733  : 				pElemtmp->m_dwObjId	= nId;
; 734  : 				pElemtmp->m_dwObjIndex		= i;

  001dd	8b 54 24 10	 mov	 edx, DWORD PTR _i$276057[esp+28]

; 735  : 				pElemtmp->SetTexture();

  001e1	8b ce		 mov	 ecx, esi
  001e3	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001e6	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001e9	e8 00 00 00 00	 call	 ?SetTexture@CItemBase@@QAEXXZ ; CItemBase::SetTexture

; 736  : 				
; 737  : 				if( nNumtmp > (short)pItemProp->dwPackMax )

  001ee	8b 44 24 2c	 mov	 eax, DWORD PTR $T286580[esp+24]
  001f2	66 3b 68 6c	 cmp	 bp, WORD PTR [eax+108]
  001f6	0f 8e a7 00 00
	00		 jle	 $L276068

; 738  : 				{
; 739  : 					pElemtmp->m_nItemNum	= (short)pItemProp->dwPackMax;

  001fc	66 8b 48 6c	 mov	 cx, WORD PTR [eax+108]
  00200	66 89 8e 80 00
	00 00		 mov	 WORD PTR [esi+128], cx

; 740  : 					nNumtmp		-= (short)pItemProp->dwPackMax;

  00207	66 2b 68 6c	 sub	 bp, WORD PTR [eax+108]

; 741  : 					if( pnId ) {

  0020b	8b 44 24 24	 mov	 eax, DWORD PTR _pnId$[esp+24]
  0020f	85 c0		 test	 eax, eax
  00211	74 1a		 je	 SHORT $L286636

; 742  : 						pnId[*pnCount]	= nId;

  00213	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00216	88 1c 02	 mov	 BYTE PTR [edx+eax], bl

; 743  : 						pnNum[*pnCount]	= pElemtmp->m_nItemNum;

  00219	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0021c	66 8b 96 80 00
	00 00		 mov	 dx, WORD PTR [esi+128]
  00223	8b 44 24 28	 mov	 eax, DWORD PTR _pnNum$[esp+24]
  00227	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 744  : 						( *pnCount )++;

  0022b	fe 07		 inc	 BYTE PTR [edi]
$L286636:
  0022d	8b 74 24 14	 mov	 esi, DWORD PTR _this$[esp+28]
$L276059:

; 723  : 	{
; 724  : 		for( DWORD i = 0; i < m_dwIndexNum; i++ )

  00231	8b 44 24 10	 mov	 eax, DWORD PTR _i$276057[esp+28]
  00235	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00238	40		 inc	 eax
  00239	3b c1		 cmp	 eax, ecx
  0023b	89 44 24 10	 mov	 DWORD PTR _i$276057[esp+28], eax
  0023f	0f 82 60 ff ff
	ff		 jb	 $L276058
$L276073:

; 756  : 					}
; 757  : 					break;
; 758  : 				}
; 759  : 			}
; 760  : 		}
; 761  : 	}
; 762  : 	if( nNumtmp > 0 )

  00245	66 85 ed	 test	 bp, bp
  00248	7e 0d		 jle	 SHORT $L286637

; 763  : 		Error( "template <class T> BOOL CItemContainer<T>::Add( T* pElem... : nNumtmp > 0" );

  0024a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EK@GINEPMCL@template?5?$DMclass?5T?$DO?5BOOL?5CItemCon@
  0024f	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00254	83 c4 04	 add	 esp, 4
$L286637:
  00257	5f		 pop	 edi
  00258	5e		 pop	 esi
  00259	5d		 pop	 ebp

; 764  : 	return TRUE;

  0025a	b8 01 00 00 00	 mov	 eax, 1
  0025f	5b		 pop	 ebx

; 765  : }

  00260	83 c4 0c	 add	 esp, 12			; 0000000cH
  00263	c2 10 00	 ret	 16			; 00000010H
$L276050:

; 705  : 					}
; 706  : 				}
; 707  : 				else {
; 708  : 					pElemtmp->m_nItemNum	+= nNumtmp;

  00266	66 8b 4c 24 10	 mov	 cx, WORD PTR _nNumtmp$[esp+28]
  0026b	66 01 88 80 00
	00 00		 add	 WORD PTR [eax+128], cx

; 709  : 					if( pnId ) {

  00272	8b 4c 24 24	 mov	 ecx, DWORD PTR _pnId$[esp+24]
  00276	85 c9		 test	 ecx, ecx
  00278	74 dd		 je	 SHORT $L286637

; 710  : 						pnId[*pnCount]	= nId;

  0027a	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  0027d	88 1c 0a	 mov	 BYTE PTR [edx+ecx], bl

; 711  : 						pnNum[*pnCount]		= pElemtmp->m_nItemNum;	

  00280	66 8b 90 80 00
	00 00		 mov	 dx, WORD PTR [eax+128]
  00287	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0028a	8b 44 24 28	 mov	 eax, DWORD PTR _pnNum$[esp+24]
  0028e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 712  : 						( *pnCount )++;

  00292	fe 07		 inc	 BYTE PTR [edi]
  00294	5f		 pop	 edi
  00295	5e		 pop	 esi
  00296	5d		 pop	 ebp

; 764  : 	return TRUE;

  00297	b8 01 00 00 00	 mov	 eax, 1
  0029c	5b		 pop	 ebx

; 765  : }

  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a0	c2 10 00	 ret	 16			; 00000010H
$L276068:

; 745  : 					}
; 746  : 				}
; 747  : 				else
; 748  : 				{
; 749  : 					pElemtmp->m_nItemNum	= nNumtmp;
; 750  : 					nNumtmp	= 0;
; 751  : 					if( pnId )

  002a3	8b 44 24 24	 mov	 eax, DWORD PTR _pnId$[esp+24]
  002a7	85 c0		 test	 eax, eax
  002a9	66 89 ae 80 00
	00 00		 mov	 WORD PTR [esi+128], bp
  002b0	74 a5		 je	 SHORT $L286637

; 752  : 					{
; 753  : 						pnId[*pnCount]	= nId;

  002b2	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  002b5	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl

; 754  : 						pnNum[*pnCount]		= pElemtmp->m_nItemNum;

  002b8	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  002bb	66 8b 86 80 00
	00 00		 mov	 ax, WORD PTR [esi+128]
  002c2	8b 4c 24 28	 mov	 ecx, DWORD PTR _pnNum$[esp+24]
  002c6	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 755  : 						( *pnCount )++;

  002ca	fe 07		 inc	 BYTE PTR [edi]
  002cc	5f		 pop	 edi
  002cd	5e		 pop	 esi
  002ce	5d		 pop	 ebp

; 764  : 	return TRUE;

  002cf	b8 01 00 00 00	 mov	 eax, 1
  002d4	5b		 pop	 ebx

; 765  : }

  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d8	c2 10 00	 ret	 16			; 00000010H
?Add@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAEPAF1@Z ENDP ; CItemContainer<CItemElem>::Add
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z ; std::_Uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L286686
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L286684:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L286684
  0001b	5e		 pop	 esi
$L286686:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L286712
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L286710:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L286710
  0001b	5e		 pop	 esi
$L286712:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z ; std::_Uninitialized_fill_n<CGuildCombat::__JOINPLAYER * *,unsigned int,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CGuildCombat::__JOINPLAYER * *,unsigned int,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L286738
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L286736:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L286736
  0001b	5e		 pop	 esi
$L286738:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAPAU__JOINPLAYER@CGuildCombat@@IPAU12@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CGuildCombat::__JOINPLAYER * *,unsigned int,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z ; std::_Uninitialized_fill_n<CGuildCombat::__GuildCombatMember * *,unsigned int,CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CGuildCombat::__GuildCombatMember * *,unsigned int,CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L286764
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L286762:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L286762
  0001b	5e		 pop	 esi
$L286764:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAPAU__GuildCombatMember@CGuildCombat@@IPAU12@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@IABQAU12@AAV?$allocator@PAU__GuildCombatMember@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CGuildCombat::__GuildCombatMember * *,unsigned int,CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAPAU__JOINPLAYER@CGuildCombat@@@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU23@00@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ucopy<CGuildCombat::__JOINPLAYER * *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ucopy@PAPAU__JOINPLAYER@CGuildCombat@@@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAU__JOINPLAYER@CGuildCombat@@@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU23@00@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ucopy<CGuildCombat::__JOINPLAYER * *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAPAU__JOINPLAYER@CGuildCombat@@@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU23@00@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ucopy<CGuildCombat::__JOINPLAYER * *>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAPAU__GuildCombatMember@CGuildCombat@@@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU23@00@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ucopy<CGuildCombat::__GuildCombatMember * *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ucopy@PAPAU__GuildCombatMember@CGuildCombat@@@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAU__GuildCombatMember@CGuildCombat@@@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU23@00@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ucopy<CGuildCombat::__GuildCombatMember * *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAPAU__GuildCombatMember@CGuildCombat@@@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU23@00@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ucopy<CGuildCombat::__GuildCombatMember * *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ; std::_Uninitialized_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$286841 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$286841[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN
; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	76 25		 jbe	 SHORT $L278760
  00008	53		 push	 ebx
  00009	8b 5c 24 10	 mov	 ebx, DWORD PTR __Val$[esp]
  0000d	56		 push	 esi
  0000e	8b d0		 mov	 edx, eax
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00014	57		 push	 edi
$L278758:

; 212  : 		_Al.construct(_First, _Val);

  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $L278759
  00019	b9 09 00 00 00	 mov	 ecx, 9
  0001e	8b f3		 mov	 esi, ebx
  00020	8b f8		 mov	 edi, eax
  00022	f3 a5		 rep movsd
$L278759:
  00024	83 c0 24	 add	 eax, 36			; 00000024H
  00027	4a		 dec	 edx
  00028	75 eb		 jne	 SHORT $L278758
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
$L278760:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)
; 215  : 		_Al.destroy(_Next);
; 216  : 	_RERAISE;
; 217  : 	_CATCH_END
; 218  : 	}

  0002d	c3		 ret	 0
??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN
; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	76 2e		 jbe	 SHORT $L278771
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b c8		 mov	 ecx, eax
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00014	57		 push	 edi
$L278769:

; 212  : 		_Al.construct(_First, _Val);

  00015	85 c0		 test	 eax, eax
  00017	74 14		 je	 SHORT $L278770
  00019	8b f2		 mov	 esi, edx
  0001b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001d	8b f8		 mov	 edi, eax
  0001f	89 1f		 mov	 DWORD PTR [edi], ebx
  00021	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002a	89 77 08	 mov	 DWORD PTR [edi+8], esi
$L278770:
  0002d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00030	49		 dec	 ecx
  00031	75 e2		 jne	 SHORT $L278769
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
$L278771:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)
; 215  : 		_Al.destroy(_Next);
; 216  : 	_RERAISE;
; 217  : 	_CATCH_END
; 218  : 	}

  00036	c3		 ret	 0
??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN
; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	76 2e		 jbe	 SHORT $L278804
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b c8		 mov	 ecx, eax
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00014	57		 push	 edi
$L278802:

; 212  : 		_Al.construct(_First, _Val);

  00015	85 c0		 test	 eax, eax
  00017	74 14		 je	 SHORT $L278803
  00019	8b f2		 mov	 esi, edx
  0001b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001d	8b f8		 mov	 edi, eax
  0001f	89 1f		 mov	 DWORD PTR [edi], ebx
  00021	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002a	89 77 08	 mov	 DWORD PTR [edi+8], esi
$L278803:
  0002d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00030	49		 dec	 ecx
  00031	75 e2		 jne	 SHORT $L278802
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
$L278804:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)
; 215  : 		_Al.destroy(_Next);
; 216  : 	_RERAISE;
; 217  : 	_CATCH_END
; 218  : 	}

  00036	c3		 ret	 0
??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN
; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	76 20		 jbe	 SHORT $L278821
  00008	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8b d0		 mov	 edx, eax
  0000e	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00012	56		 push	 esi
$L278819:

; 212  : 		_Al.construct(_First, _Val);

  00013	85 c0		 test	 eax, eax
  00015	74 0a		 je	 SHORT $L278820
  00017	8b 31		 mov	 esi, DWORD PTR [ecx]
  00019	89 30		 mov	 DWORD PTR [eax], esi
  0001b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0001e	89 70 04	 mov	 DWORD PTR [eax+4], esi
$L278820:
  00021	83 c0 08	 add	 eax, 8
  00024	4a		 dec	 edx
  00025	75 ec		 jne	 SHORT $L278819
  00027	5e		 pop	 esi
$L278821:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)
; 215  : 		_Al.destroy(_Next);
; 216  : 	_RERAISE;
; 217  : 	_CATCH_END
; 218  : 	}

  00028	c3		 ret	 0
??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >, COMDAT

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN
; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	76 40		 jbe	 SHORT $L278854
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b c8		 mov	 ecx, eax
  00010	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00014	57		 push	 edi
$L278852:

; 212  : 		_Al.construct(_First, _Val);

  00015	85 c0		 test	 eax, eax
  00017	74 26		 je	 SHORT $L278853
  00019	8b f2		 mov	 esi, edx
  0001b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001d	8b f8		 mov	 edi, eax
  0001f	89 1f		 mov	 DWORD PTR [edi], ebx
  00021	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002a	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0002d	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00030	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
  00033	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00036	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
  00039	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  0003c	89 77 14	 mov	 DWORD PTR [edi+20], esi
$L278853:
  0003f	83 c0 18	 add	 eax, 24			; 00000018H
  00042	49		 dec	 ecx
  00043	75 d0		 jne	 SHORT $L278852
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
$L278854:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)
; 215  : 		_Al.destroy(_Next);
; 216  : 	_RERAISE;
; 217  : 	_CATCH_END
; 218  : 	}

  00048	c3		 ret	 0
??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z ; std::_Uninitialized_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$287023 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$287023[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z ; std::_Uninitialized_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$287036 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$287036[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z ; std::_Uninitialized_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$287049 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$287049[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z ; std::_Uninitialized_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$287067 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$287067[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >, COMDAT

; 225  : 	for (; _First != _Last; ++_First)
; 226  : 		_Al.destroy(_First);
; 227  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 796  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	8b c8		 mov	 ecx, eax
  0000c	ff 52 0c	 call	 DWORD PTR [edx+12]
  0000f	83 c0 10	 add	 eax, 16			; 00000010H
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 797  : 	}

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	c3		 ret	 0
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 963  : 	}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H
  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L287113
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L287113:
  0001c	c3		 ret	 0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H

; 220  : 		CStringData* pNewData = CloneData( pSrcData );

  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData

; 221  : 		Attach( pNewData );

  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 222  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 735  : 		CStringData* pOldData = GetData();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nLength$[esp]
  00019	2b d0		 sub	 edx, eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L287166

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L287166:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 744  : 	}

  0002a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1510 : 		if (!_Built)

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Built$[esp-4]
  00004	84 c0		 test	 al, al
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Newsize$[esp+4]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	74 2f		 je	 SHORT $L287174

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00010	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00014	72 29		 jb	 SHORT $L287174

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;
; 1515 : 			if (0 < _Newsize)

  00016	85 ed		 test	 ebp, ebp
  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	57		 push	 edi
  0001c	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  0001f	76 14		 jbe	 SHORT $L287171
  00021	56		 push	 esi

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  00022	8b cd		 mov	 ecx, ebp
  00024	8b d1		 mov	 edx, ecx
  00026	c1 e9 02	 shr	 ecx, 2
  00029	8b f0		 mov	 esi, eax
  0002b	f3 a5		 rep movsd
  0002d	8b ca		 mov	 ecx, edx
  0002f	83 e1 03	 and	 ecx, 3
  00032	f3 a4		 rep movsb
  00034	5e		 pop	 esi
$L287171:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
  0003e	5f		 pop	 edi
$L287174:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;
; 1520 : 		_Eos(_Newsize);

  0003f	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00042	c7 43 18 0f 00
	00 00		 mov	 DWORD PTR [ebx+24], 15	; 0000000fH
  00049	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0004e	5d		 pop	 ebp
  0004f	5b		 pop	 ebx

; 1521 : 		}

  00050	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L287202

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L287202:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L287211

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L287211:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp

; 793  : 		if (_Mysize < _Off)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000b	57		 push	 edi
  0000c	73 05		 jae	 SHORT $L221371

; 794  : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L221371:

; 795  : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $L221372

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$L221372:

; 797  : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 47		 jbe	 SHORT $L287256

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002c	53		 push	 ebx
  0002d	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00030	72 04		 jb	 SHORT $L287222
  00032	8b 13		 mov	 edx, DWORD PTR [ebx]
  00034	eb 02		 jmp	 SHORT $L287223
$L287222:
  00036	8b d3		 mov	 edx, ebx
$L287223:
  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	72 04		 jb	 SHORT $L287229
  0003d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0003f	eb 02		 jmp	 SHORT $L287230
$L287229:
  00041	8b cb		 mov	 ecx, ebx
$L287230:
  00043	2b c7		 sub	 eax, edi

; 803  : 			}
; 804  : 		return (*this);

  00045	03 d5		 add	 edx, ebp
  00047	50		 push	 eax
  00048	03 d7		 add	 edx, edi
  0004a	52		 push	 edx
  0004b	03 cd		 add	 ecx, ebp
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _memmove
  00053	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00056	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00059	2b c7		 sub	 eax, edi
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00061	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00064	72 02		 jb	 SHORT $L287253

; 801  : 			size_type _Newsize = _Mysize - _Count;
; 802  : 			_Eos(_Newsize);

  00066	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$L287253:
  00068	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  0006c	5b		 pop	 ebx
$L287256:
  0006d	5f		 pop	 edi

; 803  : 			}
; 804  : 		return (*this);

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp

; 805  : 		}

  00072	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound
; Function compile flags: /Ogty
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L222610
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L222609:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $L222611

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  0001c	eb 04		 jmp	 SHORT $L222612
$L222611:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L222612:
  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L222609
  00029	5b		 pop	 ebx
$L222610:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T287531 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T287533 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L287334
$T287534 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L287332
$T287532 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T287533
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T287534
$T287526 DD	019930520H
	DD	04H
	DD	FLAT:$T287531
	DD	02H
	DD	FLAT:$T287532
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b d8		 mov	 ebx, eax
  00022	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 1446 : 		if (max_size() < _Newres)

  00025	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00028	57		 push	 edi
  00029	8b f1		 mov	 esi, ecx
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00031	76 04		 jbe	 SHORT $L222778

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  00033	8b d8		 mov	 ebx, eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00035	eb 22		 jmp	 SHORT $L222780
$L222778:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00037	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  0003a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0003f	f7 e3		 mul	 ebx
  00041	8b cf		 mov	 ecx, edi
  00043	d1 e9		 shr	 ecx, 1
  00045	d1 ea		 shr	 edx, 1
  00047	3b d1		 cmp	 edx, ecx
  00049	73 0e		 jae	 SHORT $L222780
  0004b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00050	2b c1		 sub	 eax, ecx
  00052	3b f8		 cmp	 edi, eax
  00054	77 03		 ja	 SHORT $L222780

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00056	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
$L222780:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN
; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00059	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0005c	51		 push	 ecx
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00064	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00069	8b d0		 mov	 edx, eax
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
  00071	eb 29		 jmp	 SHORT $L222782
$L287332:

; 1455 : 		_CATCH_ALL
; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN
; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00079	40		 inc	 eax
  0007a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0007d	50		 push	 eax
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00087	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0008a	83 c4 04	 add	 esp, 4

; 1462 : 			_CATCH_END
; 1463 : 		_CATCH_END

  0008d	b8 00 00 00 00	 mov	 eax, $L287527
  00092	c3		 ret	 0
$L287527:
  00093	8b 5d e8	 mov	 ebx, DWORD PTR __Newres$[ebp]
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$L222782:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  0009f	85 c9		 test	 ecx, ecx
  000a1	76 24		 jbe	 SHORT $L287451

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000a3	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000a7	72 05		 jb	 SHORT $L287448
  000a9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000ac	eb 03		 jmp	 SHORT $L287449
$L287448:
  000ae	83 c6 04	 add	 esi, 4
$L287449:
  000b1	8b c1		 mov	 eax, ecx
  000b3	c1 e9 02	 shr	 ecx, 2
  000b6	8b fa		 mov	 edi, edx
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb
  000c1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
$L287451:

; 1467 : 		_Tidy(true);

  000c7	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000cb	72 12		 jb	 SHORT $L287487
  000cd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000dc	83 c4 04	 add	 esp, 4
$L287487:

; 1468 : 		_Bx._Ptr = _Ptr;
; 1469 : 		_Myres = _Newres;
; 1470 : 		_Eos(_Oldlen);

  000df	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000e5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e8	89 10		 mov	 DWORD PTR [eax], edx
  000ea	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000ed	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000f0	72 02		 jb	 SHORT $L287522
  000f2	8b c2		 mov	 eax, edx
$L287522:

; 1471 : 		}

  000f4	5f		 pop	 edi
  000f5	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fc	5e		 pop	 esi
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 08 00	 ret	 8
$L287334:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  0010b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0010e	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00112	72 0c		 jb	 SHORT $L287426
  00114	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011d	83 c4 04	 add	 esp, 4
$L287426:

; 1461 : 			_RERAISE;

  00120	6a 00		 push	 0
  00122	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00129	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00130	6a 00		 push	 0
  00132	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$L287535:
$L287530:
  0013b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T287526
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Erase
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0000a	84 c0		 test	 al, al
  0000c	8b d9		 mov	 ebx, ecx
  0000e	8b f7		 mov	 esi, edi
  00010	75 1f		 jne	 SHORT $L223695
$L223693:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00015	50		 push	 eax
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00028	83 c4 04	 add	 esp, 4
  0002b	84 c0		 test	 al, al
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e1		 je	 SHORT $L223693
$L223695:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?GetPrizePenya@CGuildCombat@@QAE_JH@Z		; CGuildCombat::GetPrizePenya
EXTRN	__imp__MulDiv@12:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ?GetPrizePenya@CGuildCombat@@QAE_JH@Z
_TEXT	SEGMENT
_nResult$ = -8						; size = 8
_nFlag$ = 8						; size = 4
?GetPrizePenya@CGuildCombat@@QAE_JH@Z PROC NEAR		; CGuildCombat::GetPrizePenya, COMDAT
; _this$ = ecx

; 2052 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	8b 99 14 11 00
	00		 mov	 ebx, DWORD PTR [ecx+4372]
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2053 : 	//   ..
; 2054 : 	__int64 nPrizePenya = 0;

  0000c	33 f6		 xor	 esi, esi
  0000e	33 ff		 xor	 edi, edi

; 2055 : 	for( int veci = 0 ; veci < (int)( vecRequestRanking.size() ) ; ++veci )

  00010	33 d2		 xor	 edx, edx
$L269411:
  00012	85 db		 test	 ebx, ebx
  00014	75 04		 jne	 SHORT $L287568
  00016	33 c0		 xor	 eax, eax
  00018	eb 0b		 jmp	 SHORT $L287569
$L287568:
  0001a	8b 81 18 11 00
	00		 mov	 eax, DWORD PTR [ecx+4376]
  00020	2b c3		 sub	 eax, ebx
  00022	c1 f8 03	 sar	 eax, 3
$L287569:
  00025	3b d0		 cmp	 edx, eax
  00027	7d 1c		 jge	 SHORT $L287627

; 2056 : 	{
; 2057 : 		if( veci >= m_nMaxGuild )

  00029	3b 91 a0 10 00
	00		 cmp	 edx, DWORD PTR [ecx+4256]
  0002f	7d 14		 jge	 SHORT $L287627
  00031	8b 81 14 11 00
	00		 mov	 eax, DWORD PTR [ecx+4372]
  00037	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]

; 2058 : 			break;
; 2059 : 		
; 2060 : 		nPrizePenya += vecRequestRanking[veci].dwPenya;

  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	03 f0		 add	 esi, eax
  0003f	83 d7 00	 adc	 edi, 0
  00042	42		 inc	 edx
  00043	eb cd		 jmp	 SHORT $L269411
$L287627:

; 2061 : 	}
; 2062 : 	__int64 nResult;
; 2063 : 
; 2064 : 	switch( nFlag )

  00045	8b 44 24 18	 mov	 eax, DWORD PTR _nFlag$[esp+16]
  00049	83 e8 00	 sub	 eax, 0
  0004c	74 2d		 je	 SHORT $L269420
  0004e	48		 dec	 eax
  0004f	74 10		 je	 SHORT $L269422
  00051	48		 dec	 eax
  00052	75 41		 jne	 SHORT $L287628

; 2071 : 		break;
; 2072 : 	case 2:
; 2073 : 		nResult = nPrizePenya;

  00054	8b d7		 mov	 edx, edi
  00056	5f		 pop	 edi
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 2077 : }

  0005b	83 c4 08	 add	 esp, 8
  0005e	c2 04 00	 ret	 4
$L269422:

; 2068 : 		break;
; 2069 : 	case 1:
; 2070 : 		nResult = MulDiv( (int)( nPrizePenya ), m_nMaxPlayerPercent, 100 );

  00061	8b 89 b8 10 00
	00		 mov	 ecx, DWORD PTR [ecx+4280]
  00067	6a 64		 push	 100			; 00000064H
  00069	51		 push	 ecx
  0006a	56		 push	 esi
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	99		 cdq
  00074	5b		 pop	 ebx

; 2077 : }

  00075	83 c4 08	 add	 esp, 8
  00078	c2 04 00	 ret	 4
$L269420:

; 2065 : 	{
; 2066 : 	case 0:
; 2067 : 		nResult = MulDiv( (int)( nPrizePenya ), m_nMaxGuildPercent, 100 );

  0007b	8b 91 b4 10 00
	00		 mov	 edx, DWORD PTR [ecx+4276]
  00081	6a 64		 push	 100			; 00000064H
  00083	52		 push	 edx
  00084	56		 push	 esi
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	99		 cdq
  0008e	5b		 pop	 ebx

; 2077 : }

  0008f	83 c4 08	 add	 esp, 8
  00092	c2 04 00	 ret	 4
$L287628:

; 2074 : 	}
; 2075 : 
; 2076 : 	return nResult;

  00095	8b 44 24 0c	 mov	 eax, DWORD PTR _nResult$[esp+20]
  00099	8b 54 24 10	 mov	 edx, DWORD PTR _nResult$[esp+24]
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx

; 2077 : }

  000a0	83 c4 08	 add	 esp, 8
  000a3	c2 04 00	 ret	 4
?GetPrizePenya@CGuildCombat@@QAE_JH@Z ENDP		; CGuildCombat::GetPrizePenya
_TEXT	ENDS
PUBLIC	?IsRequestWarGuild@CGuildCombat@@QAEHKH@Z	; CGuildCombat::IsRequestWarGuild
; Function compile flags: /Ogty
;	COMDAT ?IsRequestWarGuild@CGuildCombat@@QAEHKH@Z
_TEXT	SEGMENT
_RequestGuild$269759 = -8				; size = 8
_uidGuild$ = 8						; size = 4
_bAll$ = 12						; size = 4
?IsRequestWarGuild@CGuildCombat@@QAEHKH@Z PROC NEAR	; CGuildCombat::IsRequestWarGuild, COMDAT
; _this$ = ecx

; 2681 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx

; 2682 : 	for( int veci = 0 ; veci < (int)( vecRequestRanking.size() ) ; ++veci )

  00004	8b 5c 24 10	 mov	 ebx, DWORD PTR _uidGuild$[esp+8]
  00008	55		 push	 ebp
  00009	8b 6c 24 18	 mov	 ebp, DWORD PTR _bAll$[esp+12]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b b9 14 11 00
	00		 mov	 edi, DWORD PTR [ecx+4372]
  00015	33 f6		 xor	 esi, esi
$L269754:
  00017	85 ff		 test	 edi, edi
  00019	75 04		 jne	 SHORT $L287637
  0001b	33 c0		 xor	 eax, eax
  0001d	eb 0b		 jmp	 SHORT $L287638
$L287637:
  0001f	8b 81 18 11 00
	00		 mov	 eax, DWORD PTR [ecx+4376]
  00025	2b c7		 sub	 eax, edi
  00027	c1 f8 03	 sar	 eax, 3
$L287638:
  0002a	3b f0		 cmp	 esi, eax
  0002c	7d 35		 jge	 SHORT $L269756

; 2683 : 	{
; 2684 : 		if( bAll == FALSE )

  0002e	85 ed		 test	 ebp, ebp
  00030	75 08		 jne	 SHORT $L269758

; 2685 : 		{
; 2686 : 			if( m_nMaxGuild <= veci )

  00032	39 b1 a0 10 00
	00		 cmp	 DWORD PTR [ecx+4256], esi
  00038	7e 29		 jle	 SHORT $L269756
$L269758:

; 2682 : 	for( int veci = 0 ; veci < (int)( vecRequestRanking.size() ) ; ++veci )

  0003a	8b 81 14 11 00
	00		 mov	 eax, DWORD PTR [ecx+4372]

; 2687 : 				break;
; 2688 : 		}
; 2689 : 
; 2690 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[veci];

  00040	8b 14 f0	 mov	 edx, DWORD PTR [eax+esi*8]

; 2691 : 		if( uidGuild == RequestGuild.uidGuild )

  00043	3b da		 cmp	 ebx, edx
  00045	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  00048	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004b	89 44 24 14	 mov	 DWORD PTR _RequestGuild$269759[esp+28], eax
  0004f	74 03		 je	 SHORT $L287697

; 2682 : 	for( int veci = 0 ; veci < (int)( vecRequestRanking.size() ) ; ++veci )

  00051	46		 inc	 esi
  00052	eb c3		 jmp	 SHORT $L269754
$L287697:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp

; 2692 : 			return TRUE;

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	5b		 pop	 ebx

; 2695 : }

  0005d	83 c4 08	 add	 esp, 8
  00060	c2 08 00	 ret	 8
$L269756:
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5d		 pop	 ebp

; 2693 : 	}
; 2694 : 	return FALSE;

  00066	33 c0		 xor	 eax, eax
  00068	5b		 pop	 ebx

; 2695 : }

  00069	83 c4 08	 add	 esp, 8
  0006c	c2 08 00	 ret	 8
?IsRequestWarGuild@CGuildCombat@@QAEHKH@Z ENDP		; CGuildCombat::IsRequestWarGuild
_TEXT	ENDS
PUBLIC	??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
_TEXT	ENDS
PUBLIC	?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L287748
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L287748:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::clear
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L287799
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L287799:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 365  : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
  00008	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	5e		 pop	 esi

; 366  : 		}

  0001c	c3		 ret	 0
??1?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::front
; Function compile flags: /Ogty
;	COMDAT ?front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT
?front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::front, COMDAT
; _this$ = ecx

; 451  : 		return (*begin());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	83 c0 08	 add	 eax, 8

; 452  : 		}

  00008	c3		 ret	 0
?front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::front
_TEXT	ENDS
PUBLIC	?pop_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::pop_front
; Function compile flags: /Ogty
;	COMDAT ?pop_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::pop_front, COMDAT
; _this$ = ecx

; 475  : 		{	// erase element at beginning

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 476  : 		erase(begin());

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 1f		 je	 SHORT $L288012
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	89 11		 mov	 DWORD PTR [ecx], edx
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00018	50		 push	 eax
  00019	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00024	83 c4 04	 add	 esp, 4
  00027	48		 dec	 eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L288012:
  0002b	5e		 pop	 esi

; 477  : 		}

  0002c	c3		 ret	 0
?pop_front@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::pop_front
_TEXT	ENDS
PUBLIC	??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEAAPAU__GuildCombatMember@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@I@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAU__GCSENDITEM@CGuildCombat@@I@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAU__GCSENDITEM@CGuildCombat@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAU__GCSENDITEM@CGuildCombat@@I@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 556  : 		}

  0000d	c2 04 00	 ret	 4
??A?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEAAU__GCSENDITEM@CGuildCombat@@I@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::operator[]
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuild@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuild@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuild@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuild@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuild *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuild *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCGuildMember@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L288216
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L288210:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L288210
  00021	5b		 pop	 ebx
$L288216:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L288257
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L288251:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L288251
  00021	5b		 pop	 ebx
$L288257:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::lower_bound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L288330
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L288298:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $L288300
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $L288301
$L288300:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L288301:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L288298
  00029	5b		 pop	 ebx
$L288330:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 811  : 		}

  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator--
; Function compile flags: /Ogty
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 339  : 			{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 340  : 			--(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 342  : 			}

  0000b	c3		 ret	 0
??Fiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L288341

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L288341:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU34@IABQAU34@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU34@IABQAU34@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L288385
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L288379:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L288379
  00021	5b		 pop	 ebx
$L288385:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU34@IABQAU34@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ; std::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z PROC NEAR ; std::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 83   : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_val@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@1@@Z ENDP ; std::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_List_val<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Tidy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L288431

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L288431:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU34@IABQAU34@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU34@IABQAU34@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L288475
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L288469:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L288469
  00021	5b		 pop	 ebx
$L288475:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU34@IABQAU34@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Init
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 901  : 		{	// create head/nil node and make tree empty

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 902  : 		_Myhead = _Buynode();

  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 906  : 		_Mysize = 0;

  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00027	5e		 pop	 esi

; 907  : 		}

  00028	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
; Function compile flags: /Ogty
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct base, and allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 96   : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU__REQUESTGUILD@CGuildCombat@@@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU23@00@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ucopy<CGuildCombat::__REQUESTGUILD *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAU__REQUESTGUILD@CGuildCombat@@@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$288568 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU__REQUESTGUILD@CGuildCombat@@@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU23@00@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ucopy<CGuildCombat::__REQUESTGUILD *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$288568[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU__REQUESTGUILD@CGuildCombat@@@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU23@00@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ucopy<CGuildCombat::__REQUESTGUILD *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z ; std::_Uninitialized_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$288578 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$288578[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z ; std::_Uninitialized_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$288586 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$288586[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z ; std::_Uninitialized_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$288594 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$288594[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ; std::_Uninitialized_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$288610 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$288610[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z ; std::_Uninitialized_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??$_Uninitialized_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__Cat$288618 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$288618[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU__GCGETPOINT@CGuildCombat@@@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU23@00@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Ucopy<CGuildCombat::__GCGETPOINT *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAU__GCGETPOINT@CGuildCombat@@@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$288641 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU__GCGETPOINT@CGuildCombat@@@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU23@00@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Ucopy<CGuildCombat::__GCGETPOINT *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$288641[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU__GCGETPOINT@CGuildCombat@@@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU23@00@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Ucopy<CGuildCombat::__GCGETPOINT *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU__GCPLAYERPOINT@CGuildCombat@@@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU23@00@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Ucopy<CGuildCombat::__GCPLAYERPOINT *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAU__GCPLAYERPOINT@CGuildCombat@@@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$288666 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU__GCPLAYERPOINT@CGuildCombat@@@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU23@00@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Ucopy<CGuildCombat::__GCPLAYERPOINT *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$288666[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU__GCPLAYERPOINT@CGuildCombat@@@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU23@00@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Ucopy<CGuildCombat::__GCPLAYERPOINT *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU__GCSENDITEM@CGuildCombat@@@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU23@00@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Ucopy<CGuildCombat::__GCSENDITEM *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAU__GCSENDITEM@CGuildCombat@@@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$288691 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU__GCSENDITEM@CGuildCombat@@@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU23@00@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Ucopy<CGuildCombat::__GCSENDITEM *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$288691[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU__GCSENDITEM@CGuildCombat@@@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU23@00@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Ucopy<CGuildCombat::__GCSENDITEM *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0AAV?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAU__JOINPLAYER@CGuildCombat@@@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU23@00@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Ucopy<CGuildCombat::__JOINPLAYER *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAU__JOINPLAYER@CGuildCombat@@@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$288724 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAU__JOINPLAYER@CGuildCombat@@@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU23@00@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Ucopy<CGuildCombat::__JOINPLAYER *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$288724[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAU__JOINPLAYER@CGuildCombat@@@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU23@00@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Ucopy<CGuildCombat::__JOINPLAYER *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z ; std::_Destroy_range<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z PROC NEAR ; std::_Destroy_range<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@@Z ENDP ; std::_Destroy_range<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
_TEXT	ENDS
PUBLIC	??_G?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEPAXI@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_G?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEPAXI@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L288739
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L288739:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_G?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEPAXI@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 814  : 	{

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 815  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nMinBufferLength$[esp]
  00019	2b d0		 sub	 edx, eax
  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L288782
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L288782:
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 491  : 	}

  0002a	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 457  : 		_Tidy(true);

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $L288820
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$L288820:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi

; 458  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC NEAR	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L288847
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L288847:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L288861
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L288861:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_nID$ = 12						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1981 : 	{

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 1982 : 		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID );

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _nID$[esp+4]
  00006	8b c6		 mov	 eax, esi
  00008	c1 e8 04	 shr	 eax, 4
  0000b	57		 push	 edi
  0000c	8b 7c 24 10	 mov	 edi, DWORD PTR _hInstance$[esp+8]
  00010	40		 inc	 eax
  00011	8b d9		 mov	 ebx, ecx
  00013	0f b7 c8	 movzx	 ecx, ax
  00016	6a 06		 push	 6
  00018	51		 push	 ecx
  00019	57		 push	 edi
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  00020	85 c0		 test	 eax, eax
  00022	74 11		 je	 SHORT $L288943
  00024	56		 push	 esi
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  0002c	8b f8		 mov	 edi, eax
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1983 : 		if( pImage == NULL )

  00031	85 ff		 test	 edi, edi
  00033	75 08		 jne	 SHORT $L219928
$L288943:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 1984 : 		{
; 1985 : 			return( FALSE );

  00037	33 c0		 xor	 eax, eax
  00039	5b		 pop	 ebx

; 1994 : 	}

  0003a	c2 08 00	 ret	 8
$L219928:

; 1986 : 		}
; 1987 : 
; 1988 : 		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );

  0003d	0f b7 37	 movzx	 esi, WORD PTR [edi]
  00040	55		 push	 ebp
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	56		 push	 esi
  00050	8d 6f 02	 lea	 ebp, DWORD PTR [edi+2]
  00053	55		 push	 ebp
  00054	6a 00		 push	 0
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0005d	8b f0		 mov	 esi, eax

; 1989 : 		PXSTR pszBuffer = GetBuffer( nLength );

  0005f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00061	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00064	83 e8 10	 sub	 eax, 16			; 00000010H
  00067	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006a	ba 01 00 00 00	 mov	 edx, 1
  0006f	2b d1		 sub	 edx, ecx
  00071	2b c6		 sub	 eax, esi
  00073	0b d0		 or	 edx, eax
  00075	7d 08		 jge	 SHORT $L288904
  00077	56		 push	 esi
  00078	8b cb		 mov	 ecx, ebx
  0007a	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L288904:
  0007f	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1990 : 		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );

  00081	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	56		 push	 esi
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	55		 push	 ebp
  0008c	6a 00		 push	 0
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 1991 : 		ReleaseBufferSetLength( nLength );

  0009b	85 f6		 test	 esi, esi
  0009d	5d		 pop	 ebp
  0009e	7c 1b		 jl	 SHORT $L288940
  000a0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a2	3b 70 f8	 cmp	 esi, DWORD PTR [eax-8]
  000a5	7f 14		 jg	 SHORT $L288940
  000a7	89 70 f4	 mov	 DWORD PTR [eax-12], esi
  000aa	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ac	5f		 pop	 edi
  000ad	c6 04 0e 00	 mov	 BYTE PTR [esi+ecx], 0
  000b1	5e		 pop	 esi

; 1992 : 
; 1993 : 		return( TRUE );

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	5b		 pop	 ebx

; 1994 : 	}

  000b8	c2 08 00	 ret	 8
$L288940:
  000bb	68 57 00 07 80	 push	 -2147024809		; 80070057H
  000c0	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L288945:
$L288944:
  000c5	cc		 int	 3
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L289018
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L289005:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $L289007
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $L289008
$L289007:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L289008:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L289005
  00029	5b		 pop	 ebx
$L289018:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 811  : 		}

  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	53		 push	 ebx

; 584  : 		if( nLength == 0 )

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nLength$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	8b e9		 mov	 ebp, ecx
  0000a	75 0a		 jne	 SHORT $L221330

; 585  : 		{
; 586  : 			Empty();

  0000c	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty
  00011	5d		 pop	 ebp
  00012	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00013	c2 08 00	 ret	 8
$L221330:

; 587  : 		}
; 588  : 		else
; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

  00016	8b 54 24 0c	 mov	 edx, DWORD PTR _pszSrc$[esp+4]
  0001a	85 d2		 test	 edx, edx
  0001c	75 0a		 jne	 SHORT $L221332

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

$L289090:
  0001e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L289094:
$L221332:

; 597  : 				AtlThrow(E_INVALIDARG);			
; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

  00028	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0002b	56		 push	 esi

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

  0002c	8b f2		 mov	 esi, edx
  0002e	2b f0		 sub	 esi, eax

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  00038	57		 push	 edi
  00039	8b 78 f4	 mov	 edi, DWORD PTR [eax-12]
  0003c	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0003f	2b c3		 sub	 eax, ebx
  00041	0b c8		 or	 ecx, eax
  00043	7d 0c		 jge	 SHORT $L289057
  00045	53		 push	 ebx
  00046	8b cd		 mov	 ecx, ebp
  00048	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  0004d	8b 54 24 14	 mov	 edx, DWORD PTR _pszSrc$[esp+12]
$L289057:

; 605  : 			if( nOffset <= nOldLength )

  00051	3b f7		 cmp	 esi, edi
  00053	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00056	77 10		 ja	 SHORT $L221337

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

  00058	53		 push	 ebx
  00059	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0005c	51		 push	 ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memmove
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 			}
; 609  : 			else

  00066	eb 14		 jmp	 SHORT $L289064
$L221337:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

  00068	8b cb		 mov	 ecx, ebx
  0006a	8b f2		 mov	 esi, edx
  0006c	8b d1		 mov	 edx, ecx
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	8b f8		 mov	 edi, eax
  00073	f3 a5		 rep movsd
  00075	8b ca		 mov	 ecx, edx
  00077	83 e1 03	 and	 ecx, 3
  0007a	f3 a4		 rep movsb
$L289064:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

  0007c	85 db		 test	 ebx, ebx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	7c 9c		 jl	 SHORT $L289090
  00082	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00085	3b 58 f8	 cmp	 ebx, DWORD PTR [eax-8]
  00088	7f 94		 jg	 SHORT $L289090
  0008a	89 58 f4	 mov	 DWORD PTR [eax-12], ebx
  0008d	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00090	5d		 pop	 ebp
  00091	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  00095	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00096	c2 08 00	 ret	 8
$L289093:
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 1481 : 		if (max_size() < _Newsize)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR __Newsize$[esp+4]
  00006	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00009	8b e9		 mov	 ebp, ecx
  0000b	76 05		 jbe	 SHORT $L221380

; 1482 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L221380:

; 1483 : 		if (_Myres < _Newsize)

  00012	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00015	3b c6		 cmp	 eax, esi
  00017	73 19		 jae	 SHORT $L221381

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  00019	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	8b cd		 mov	 ecx, ebp
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  00025	33 c0		 xor	 eax, eax
  00027	3b c6		 cmp	 eax, esi
  00029	1b c0		 sbb	 eax, eax
  0002b	5e		 pop	 esi
  0002c	f7 d8		 neg	 eax
  0002e	5d		 pop	 ebp

; 1491 : 		}

  0002f	c2 08 00	 ret	 8
$L221381:

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00032	8a 4c 24 10	 mov	 cl, BYTE PTR __Trim$[esp+4]
  00036	84 c9		 test	 cl, cl
  00038	74 5c		 je	 SHORT $L221383
  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0003d	73 57		 jae	 SHORT $L221383
  0003f	53		 push	 ebx

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00040	8b 5d 14	 mov	 ebx, DWORD PTR [ebp+20]
  00043	3b f3		 cmp	 esi, ebx
  00045	73 02		 jae	 SHORT $L289099
  00047	8b de		 mov	 ebx, esi
$L289099:
  00049	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004c	72 2b		 jb	 SHORT $L289153
  0004e	85 db		 test	 ebx, ebx
  00050	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00053	57		 push	 edi
  00054	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  00057	76 16		 jbe	 SHORT $L289151
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b d1		 mov	 edx, ecx
  0005d	c1 e9 02	 shr	 ecx, 2
  00060	8b f0		 mov	 esi, eax
  00062	f3 a5		 rep movsd
  00064	8b ca		 mov	 ecx, edx
  00066	83 e1 03	 and	 ecx, 3
  00069	f3 a4		 rep movsb
  0006b	8b 74 24 14	 mov	 esi, DWORD PTR __Newsize$[esp+12]
$L289151:
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00075	83 c4 04	 add	 esp, 4
  00078	5f		 pop	 edi
$L289153:
  00079	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0007c	33 c0		 xor	 eax, eax
  0007e	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00085	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0008a	3b c6		 cmp	 eax, esi
  0008c	5b		 pop	 ebx
  0008d	1b c0		 sbb	 eax, eax
  0008f	5e		 pop	 esi
  00090	f7 d8		 neg	 eax
  00092	5d		 pop	 ebp

; 1491 : 		}

  00093	c2 08 00	 ret	 8
$L221383:

; 1488 : 		else if (_Newsize == 0)

  00096	85 f6		 test	 esi, esi
  00098	75 23		 jne	 SHORT $L289190

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  0009a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009d	89 75 14	 mov	 DWORD PTR [ebp+20], esi
  000a0	72 14		 jb	 SHORT $L289188
  000a2	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000a5	33 c0		 xor	 eax, eax
  000a7	3b c6		 cmp	 eax, esi
  000a9	1b c0		 sbb	 eax, eax
  000ab	5e		 pop	 esi
  000ac	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  000b0	f7 d8		 neg	 eax
  000b2	5d		 pop	 ebp

; 1491 : 		}

  000b3	c2 08 00	 ret	 8

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

$L289188:
  000b6	83 c5 04	 add	 ebp, 4
  000b9	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
$L289190:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000bd	33 c0		 xor	 eax, eax
  000bf	3b c6		 cmp	 eax, esi
  000c1	1b c0		 sbb	 eax, eax
  000c3	5e		 pop	 esi
  000c4	f7 d8		 neg	 eax
  000c6	5d		 pop	 ebp

; 1491 : 		}

  000c7	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::clear
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 780  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 781  : 		_Erase(_Root());

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	51		 push	 ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00026	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00029	5e		 pop	 esi

; 784  : 		}

  0002a	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	8b 44 24 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp]
  0000c	89 30		 mov	 DWORD PTR [eax], esi
  0000e	5e		 pop	 esi

; 336  : 			}

  0000f	c2 08 00	 ret	 8
??Eiterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?Ready@CEveSchool@@QAEHXZ			; CEveSchool::Ready
EXTRN	?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z:NEAR	; CUserMng::AddModifyMode
EXTRN	?ModifyMode@CUserMng@@QAEXK@Z:NEAR		; CUserMng::ModifyMode
EXTRN	?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z:NEAR ; CUserMng::GetUserByPlayerID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ?Ready@CEveSchool@@QAEHXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_pSchool$268010 = -16					; size = 4
$T289245 = -12						; size = 12
?Ready@CEveSchool@@QAEHXZ PROC NEAR			; CEveSchool::Ready, COMDAT
; _this$ = ecx

; 36   : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 37   : // "/sbready
; 38   : 	if( g_eLocal.GetState( EVE_SCHOOL_BATTLE ) != SBS_END )

  00006	6a 05		 push	 5
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0000d	89 74 24 08	 mov	 DWORD PTR _this$[esp+28], esi
  00011	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00016	84 c0		 test	 al, al
  00018	74 07		 je	 SHORT $L267920

; 39   : 		return FALSE;

  0001a	33 c0		 xor	 eax, eax
  0001c	5e		 pop	 esi

; 64   : }

  0001d	83 c4 14	 add	 esp, 20			; 00000014H
  00020	c3		 ret	 0
$L267920:
  00021	55		 push	 ebp

; 40   : 
; 41   : 	g_UserMng.ModifyMode( OBSERVE_MODE );	// Observe mode	// all

  00022	68 c0 00 00 00	 push	 192			; 000000c0H
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0002c	e8 00 00 00 00	 call	 ?ModifyMode@CUserMng@@QAEXK@Z ; CUserMng::ModifyMode

; 42   : 
; 43   : 	for( map<u_long, CGuild*>::iterator i = m_pSchoolMng->m_mapPGuild.begin(); i != m_pSchoolMng->m_mapPGuild.end(); ++i )

  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00036	8b 28		 mov	 ebp, DWORD PTR [eax]
  00038	3b e8		 cmp	 ebp, eax
  0003a	0f 84 6f 01 00
	00		 je	 $L268009
  00040	57		 push	 edi
$L289425:

; 44   : 	{
; 45   : 		CGuild* pSchool	= i->second;

  00041	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]

; 46   : 		pSchool->m_nDead	= 0;

  00044	c7 80 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+320], 0
  0004e	89 44 24 10	 mov	 DWORD PTR _pSchool$268010[esp+32], eax

; 47   : 		for( map<u_long, CGuildMember*>::iterator i2 = pSchool->m_mapPMember.begin(); i2 != pSchool->m_mapPMember.end(); ++i2 )

  00052	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00055	8b 38		 mov	 edi, DWORD PTR [eax]
  00057	3b f8		 cmp	 edi, eax
  00059	0f 84 fc 00 00
	00		 je	 $L268008
  0005f	90		 npad	 1
$L289735:

; 48   : 		{
; 49   : 			CGuildMember* pMember	= i2->second;

  00060	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 50   : 			CUser* pUser	= g_UserMng.GetUserByPlayerID( pMember->m_idPlayer );

  00063	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00066	51		 push	 ecx
  00067	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0006c	e8 00 00 00 00	 call	 ?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z ; CUserMng::GetUserByPlayerID
  00071	8b f0		 mov	 esi, eax

; 51   : 			if( IsValidObj( (CObj*)pUser ) )

  00073	85 f6		 test	 esi, esi
  00075	0f 84 85 00 00
	00		 je	 $L268117
  0007b	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0007f	0f 85 7b 00 00
	00		 jne	 $L268117

; 52   : 			{
; 53   : 				pUser->REPLACE( g_uIdofMulti, WI_WORLD_EVENT01, GetPos( pSchool->m_idGuild ), REPLACE_NORMAL, nDefaultLayer );

  00085	8b 54 24 10	 mov	 edx, DWORD PTR _pSchool$268010[esp+32]
  00089	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0008f	77 26		 ja	 SHORT $L289717
  00091	83 f8 01	 cmp	 eax, 1
  00094	72 21		 jb	 SHORT $L289717
  00096	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+32]
  0009a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0009d	8d 54 81 f8	 lea	 edx, DWORD PTR [ecx+eax*4-8]
  000a1	8b 02		 mov	 eax, DWORD PTR [edx]
  000a3	89 44 24 14	 mov	 DWORD PTR $T289245[esp+32], eax
  000a7	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000aa	89 4c 24 18	 mov	 DWORD PTR $T289245[esp+36], ecx
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000b1	89 54 24 1c	 mov	 DWORD PTR $T289245[esp+40], edx
  000b5	eb 1b		 jmp	 SHORT $L289715
$L289717:
  000b7	8b 44 24 0c	 mov	 eax, DWORD PTR _this$[esp+32]
  000bb	83 c0 7c	 add	 eax, 124		; 0000007cH
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c6	89 4c 24 14	 mov	 DWORD PTR $T289245[esp+32], ecx
  000ca	89 54 24 18	 mov	 DWORD PTR $T289245[esp+36], edx
  000ce	89 44 24 1c	 mov	 DWORD PTR $T289245[esp+40], eax
$L289715:
  000d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  000d8	6a 00		 push	 0
  000da	6a 00		 push	 0
  000dc	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T289245[esp+40]
  000e0	51		 push	 ecx
  000e1	6a 78		 push	 120			; 00000078H
  000e3	52		 push	 edx
  000e4	8b ce		 mov	 ecx, esi
  000e6	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 54   : 				pUser->SetNotMode( OBSERVE_MODE );	// Not observe mode

  000eb	81 a6 44 02 00
	00 3f ff ff ff	 and	 DWORD PTR [esi+580], -193 ; ffffff3fH

; 55   : 				g_UserMng.AddModifyMode( pUser );

  000f5	56		 push	 esi
  000f6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000fb	e8 00 00 00 00	 call	 ?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddModifyMode
$L268117:
  00100	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  00103	84 c0		 test	 al, al
  00105	75 43		 jne	 SHORT $L289624
  00107	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0010a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0010d	84 c9		 test	 cl, cl
  0010f	75 1c		 jne	 SHORT $L289727
  00111	8b f8		 mov	 edi, eax
  00113	8b 07		 mov	 eax, DWORD PTR [edi]
  00115	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00118	84 c9		 test	 cl, cl
  0011a	75 2e		 jne	 SHORT $L289624
  0011c	8d 64 24 00	 npad	 4

; 47   : 		for( map<u_long, CGuildMember*>::iterator i2 = pSchool->m_mapPMember.begin(); i2 != pSchool->m_mapPMember.end(); ++i2 )

$L289638:
  00120	8b f8		 mov	 edi, eax
  00122	8b 07		 mov	 eax, DWORD PTR [edi]
  00124	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00127	84 c9		 test	 cl, cl
  00129	74 f5		 je	 SHORT $L289638
  0012b	eb 1d		 jmp	 SHORT $L289624
$L289727:
  0012d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00130	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00133	84 c9		 test	 cl, cl
  00135	75 11		 jne	 SHORT $L289627
$L289626:
  00137	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  0013a	75 0c		 jne	 SHORT $L289627
  0013c	8b f8		 mov	 edi, eax
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00144	84 c9		 test	 cl, cl
  00146	74 ef		 je	 SHORT $L289626
$L289627:
  00148	8b f8		 mov	 edi, eax
$L289624:
  0014a	8b 44 24 10	 mov	 eax, DWORD PTR _pSchool$268010[esp+32]
  0014e	3b 78 3c	 cmp	 edi, DWORD PTR [eax+60]
  00151	0f 85 09 ff ff
	ff		 jne	 $L289735
  00157	8b 74 24 0c	 mov	 esi, DWORD PTR _this$[esp+32]
$L268008:

; 42   : 
; 43   : 	for( map<u_long, CGuild*>::iterator i = m_pSchoolMng->m_mapPGuild.begin(); i != m_pSchoolMng->m_mapPGuild.end(); ++i )

  0015b	8a 45 15	 mov	 al, BYTE PTR [ebp+21]
  0015e	84 c0		 test	 al, al
  00160	75 41		 jne	 SHORT $L289395
  00162	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00165	8a 41 15	 mov	 al, BYTE PTR [ecx+21]
  00168	84 c0		 test	 al, al
  0016a	75 18		 jne	 SHORT $L289729
  0016c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016e	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00171	84 d2		 test	 dl, dl
  00173	75 0b		 jne	 SHORT $L289417
$L289416:
  00175	8b c8		 mov	 ecx, eax
  00177	8b 01		 mov	 eax, DWORD PTR [ecx]
  00179	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0017c	84 d2		 test	 dl, dl
  0017e	74 f5		 je	 SHORT $L289416
$L289417:
  00180	8b e9		 mov	 ebp, ecx
  00182	eb 1f		 jmp	 SHORT $L289395
$L289729:
  00184	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00187	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0018a	84 c9		 test	 cl, cl
  0018c	75 13		 jne	 SHORT $L289398
  0018e	8b ff		 npad	 2
$L289397:
  00190	3b 68 08	 cmp	 ebp, DWORD PTR [eax+8]
  00193	75 0c		 jne	 SHORT $L289398
  00195	8b e8		 mov	 ebp, eax
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0019d	84 c9		 test	 cl, cl
  0019f	74 ef		 je	 SHORT $L289397
$L289398:
  001a1	8b e8		 mov	 ebp, eax
$L289395:
  001a3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001a5	3b 69 0c	 cmp	 ebp, DWORD PTR [ecx+12]
  001a8	0f 85 93 fe ff
	ff		 jne	 $L289425
  001ae	5f		 pop	 edi
$L268009:

; 56   : 			}
; 57   : 		}
; 58   : 	}
; 59   : 
; 60   : 	if( g_eLocal.SetState( EVE_SCHOOL_BATTLE, SBS_READY ) )

  001af	6a 01		 push	 1
  001b1	6a 05		 push	 5
  001b3	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  001b8	e8 00 00 00 00	 call	 ?SetState@CFlyffEvent@@QAEHHE@Z ; CFlyffEvent::SetState
  001bd	85 c0		 test	 eax, eax
  001bf	5d		 pop	 ebp
  001c0	74 0e		 je	 SHORT $L268145

; 61   : 		g_UserMng.AddSetLocalEvent( EVE_SCHOOL_BATTLE, SBS_READY );

  001c2	6a 01		 push	 1
  001c4	6a 05		 push	 5
  001c6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  001cb	e8 00 00 00 00	 call	 ?AddSetLocalEvent@CUserMng@@QAEXFE@Z ; CUserMng::AddSetLocalEvent
$L268145:

; 62   : 
; 63   : 	return TRUE;

  001d0	b8 01 00 00 00	 mov	 eax, 1
  001d5	5e		 pop	 esi

; 64   : }

  001d6	83 c4 14	 add	 esp, 20			; 00000014H
  001d9	c3		 ret	 0
?Ready@CEveSchool@@QAEHXZ ENDP				; CEveSchool::Ready
_TEXT	ENDS
PUBLIC	?Report@CEveSchool@@QAEHXZ			; CEveSchool::Report
EXTRN	?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z:NEAR ; CUserMng::AddSchoolReport
; Function compile flags: /Ogty
;	COMDAT ?Report@CEveSchool@@QAEHXZ
_TEXT	SEGMENT
tv807 = -784						; size = 4
_nAvg1$268204 = -784					; size = 4
tv916 = -780						; size = 4
tv248 = -776						; size = 4
$T290239 = -772						; size = 4
tv282 = -768						; size = 4
tv918 = -764						; size = 4
_tmp$268212 = -760					; size = 68
_school$ = -688						; size = 680
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?Report@CEveSchool@@QAEHXZ PROC NEAR			; CEveSchool::Report, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 14 03 00
	00		 sub	 esp, 788		; 00000314H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b f1		 mov	 esi, ecx
  00016	33 c5		 xor	 eax, ebp

; 92   : //	"/sbreport"
; 93   : 	if( g_eLocal.GetState( EVE_SCHOOL_BATTLE ) == SBS_END )

  00018	6a 05		 push	 5
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0001f	89 84 24 20 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+804], eax

; 130  : 	{
; 131  : 		for( int k = j + 1; k < MAX_SCHOOL; k++ )

  00026	89 74 24 20	 mov	 DWORD PTR $T290239[esp+804], esi
  0002a	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  0002f	84 c0		 test	 al, al
  00031	75 17		 jne	 SHORT $L268162

; 94   : 		return FALSE;

  00033	33 c0		 xor	 eax, eax

; 156  : 
; 157  : 	return TRUE;
; 158  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b 8c 24 10 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+788]
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$L268162:

; 95   : 
; 96   : 	SCHOOL_ENTRY	school[MAX_SCHOOL];

  0004a	8d 84 24 a4 00
	00 00		 lea	 eax, DWORD PTR _school$[esp+852]
  00051	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
$L289747:
  00056	33 c9		 xor	 ecx, ecx
  00058	89 48 cc	 mov	 DWORD PTR [eax-52], ecx
  0005b	88 48 d0	 mov	 BYTE PTR [eax-48], cl
  0005e	89 08		 mov	 DWORD PTR [eax], ecx
  00060	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00063	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00066	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00069	83 c0 44	 add	 eax, 68			; 00000044H
  0006c	4a		 dec	 edx
  0006d	75 e7		 jne	 SHORT $L289747

; 99   : 	for( map<u_long, CGuild*>::iterator i = m_pSchoolMng->m_mapPGuild.begin();

  0006f	8b 06		 mov	 eax, DWORD PTR [esi]
  00071	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00074	8b 18		 mov	 ebx, DWORD PTR [eax]

; 100  : 		i != m_pSchoolMng->m_mapPGuild.end(); ++i )

  00076	3b d8		 cmp	 ebx, eax
  00078	0f 84 45 01 00
	00		 je	 $L268176

; 97   : 
; 98   : 	int iIndex	= 0;

  0007e	89 4c 24 10	 mov	 DWORD PTR tv807[esp+800], ecx

; 100  : 		i != m_pSchoolMng->m_mapPGuild.end(); ++i )

$L289933:

; 101  : 	{
; 102  : 		CGuild* pSchool	= i->second;

  00082	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 103  : 		
; 104  : 		school[iIndex].id	= pSchool->m_idGuild;

  00085	8b 74 24 10	 mov	 esi, DWORD PTR tv807[esp+800]
  00089	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 105  : 		lstrcpy( school[iIndex].lpName, pSchool->m_szGuild );

  0008c	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  0008f	8d 74 34 74	 lea	 esi, DWORD PTR _school$[esp+esi+804]
  00093	52		 push	 edx
  00094	56		 push	 esi
  00095	89 4e fc	 mov	 DWORD PTR [esi-4], ecx
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 106  : 		school[iIndex].nDead	= pSchool->m_nDead;

  0009e	8b 87 40 01 00
	00		 mov	 eax, DWORD PTR [edi+320]
  000a4	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 107  : 
; 108  : 		for( map<u_long, CGuildMember*>::iterator i2 = pSchool->m_mapPMember.begin();

  000a7	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  000aa	8b 30		 mov	 esi, DWORD PTR [eax]

; 109  : 		i2 != pSchool->m_mapPMember.end(); ++i2 )

  000ac	3b f0		 cmp	 esi, eax
  000ae	0f 84 af 00 00
	00		 je	 $L268188
$L290162:

; 110  : 		{
; 111  : 			CGuildMember* pMember	= i2->second;

  000b4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 112  : 			CUser* pUser	= g_UserMng.GetUserByPlayerID( pMember->m_idPlayer );

  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	51		 push	 ecx
  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000c0	e8 00 00 00 00	 call	 ?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z ; CUserMng::GetUserByPlayerID

; 113  : 			if( IsValidObj( (CObj*)pUser ) )

  000c5	85 c0		 test	 eax, eax
  000c7	74 4a		 je	 SHORT $L268187
  000c9	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000cd	75 44		 jne	 SHORT $L268187

; 114  : 			{
; 115  : 				school[iIndex].nSize++;

  000cf	8b 4c 24 10	 mov	 ecx, DWORD PTR tv807[esp+800]
  000d3	ff 84 0c a8 00
	00 00		 inc	 DWORD PTR _school$[esp+ecx+856]

; 116  : 				if( pUser->IsRegionAttr( RA_FIGHT ) )

  000da	f6 80 d4 02 00
	00 40		 test	 BYTE PTR [eax+724], 64	; 00000040H
  000e1	74 30		 je	 SHORT $L268187

; 117  : 				{
; 118  : 					if( !pUser->IsMode( OBSERVE_MODE ) )

  000e3	8b 90 44 02 00
	00		 mov	 edx, DWORD PTR [eax+580]
  000e9	81 e2 c0 00 00
	00		 and	 edx, 192		; 000000c0H
  000ef	80 fa c0	 cmp	 dl, 192			; 000000c0H
  000f2	74 1f		 je	 SHORT $L268187

; 119  : 					{
; 120  : 						school[iIndex].nSurvivor++;

  000f4	ff 84 0c a4 00
	00 00		 inc	 DWORD PTR _school$[esp+ecx+852]

; 121  : 						school[iIndex].nLevel	+= pUser->GetLevel();

  000fb	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [eax+1504]
  00101	8b 94 0c ac 00
	00 00		 mov	 edx, DWORD PTR _school$[esp+ecx+860]
  00108	8d 8c 0c ac 00
	00 00		 lea	 ecx, DWORD PTR _school$[esp+ecx+860]
  0010f	03 d0		 add	 edx, eax
  00111	89 11		 mov	 DWORD PTR [ecx], edx
$L268187:
  00113	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00116	84 c0		 test	 al, al
  00118	75 40		 jne	 SHORT $L290158
  0011a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0011d	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00120	84 c9		 test	 cl, cl
  00122	75 19		 jne	 SHORT $L290244
  00124	8b f0		 mov	 esi, eax
  00126	8b 06		 mov	 eax, DWORD PTR [esi]
  00128	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0012b	84 c9		 test	 cl, cl
  0012d	75 2b		 jne	 SHORT $L290158
  0012f	90		 npad	 1

; 109  : 		i2 != pSchool->m_mapPMember.end(); ++i2 )

$L290146:
  00130	8b f0		 mov	 esi, eax
  00132	8b 06		 mov	 eax, DWORD PTR [esi]
  00134	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00137	84 c9		 test	 cl, cl
  00139	74 f5		 je	 SHORT $L290146
  0013b	eb 1d		 jmp	 SHORT $L290158
$L290244:
  0013d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00140	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00143	84 c9		 test	 cl, cl
  00145	75 11		 jne	 SHORT $L290161
$L290160:
  00147	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0014a	75 0c		 jne	 SHORT $L290161
  0014c	8b f0		 mov	 esi, eax
  0014e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00151	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00154	84 c9		 test	 cl, cl
  00156	74 ef		 je	 SHORT $L290160
$L290161:
  00158	8b f0		 mov	 esi, eax
$L290158:
  0015a	3b 77 3c	 cmp	 esi, DWORD PTR [edi+60]
  0015d	0f 85 51 ff ff
	ff		 jne	 $L290162
$L268188:

; 122  : 					}
; 123  : 				}
; 124  : 			}
; 125  : 		}
; 126  : 		iIndex++;

  00163	8b 4c 24 10	 mov	 ecx, DWORD PTR tv807[esp+800]
  00167	8a 43 15	 mov	 al, BYTE PTR [ebx+21]
  0016a	83 c1 44	 add	 ecx, 68			; 00000044H
  0016d	84 c0		 test	 al, al
  0016f	89 4c 24 10	 mov	 DWORD PTR tv807[esp+800], ecx
  00173	75 3f		 jne	 SHORT $L289924
  00175	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00178	8a 41 15	 mov	 al, BYTE PTR [ecx+21]
  0017b	84 c0		 test	 al, al
  0017d	75 18		 jne	 SHORT $L290246
  0017f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00181	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00184	84 d2		 test	 dl, dl
  00186	75 0b		 jne	 SHORT $L289913

; 100  : 		i != m_pSchoolMng->m_mapPGuild.end(); ++i )

$L289912:
  00188	8b c8		 mov	 ecx, eax
  0018a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0018f	84 d2		 test	 dl, dl
  00191	74 f5		 je	 SHORT $L289912
$L289913:
  00193	8b d9		 mov	 ebx, ecx
  00195	eb 1d		 jmp	 SHORT $L289924
$L290246:
  00197	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0019a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0019d	84 c9		 test	 cl, cl
  0019f	75 11		 jne	 SHORT $L289927
$L289926:
  001a1	3b 58 08	 cmp	 ebx, DWORD PTR [eax+8]
  001a4	75 0c		 jne	 SHORT $L289927
  001a6	8b d8		 mov	 ebx, eax
  001a8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ab	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001ae	84 c9		 test	 cl, cl
  001b0	74 ef		 je	 SHORT $L289926
$L289927:
  001b2	8b d8		 mov	 ebx, eax
$L289924:
  001b4	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T290239[esp+800]
  001b8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ba	3b 5a 0c	 cmp	 ebx, DWORD PTR [edx+12]
  001bd	0f 85 bf fe ff
	ff		 jne	 $L289933
$L268176:

; 127  : 	}
; 128  : 	// sort
; 129  : 	for( int j = 0; j < MAX_SCHOOL-1; j++ )

  001c3	33 f6		 xor	 esi, esi
  001c5	b9 01 00 00 00	 mov	 ecx, 1
  001ca	89 74 24 14	 mov	 DWORD PTR tv916[esp+800], esi
  001ce	89 4c 24 24	 mov	 DWORD PTR tv918[esp+800], ecx
  001d2	c7 44 24 18 09
	00 00 00	 mov	 DWORD PTR tv248[esp+800], 9
  001da	8d 9b 00 00 00
	00		 npad	 6
$L268197:

; 130  : 	{
; 131  : 		for( int k = j + 1; k < MAX_SCHOOL; k++ )

  001e0	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  001e3	0f 8d 94 00 00
	00		 jge	 $L268198
  001e9	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  001ee	2b c1		 sub	 eax, ecx
  001f0	8d 9c 34 e8 00
	00 00		 lea	 ebx, DWORD PTR _school$[esp+esi+920]
  001f7	89 44 24 20	 mov	 DWORD PTR tv282[esp+800], eax
  001fb	eb 03 8d 49 00	 npad	 5
$L268201:

; 132  : 		{
; 133  : 			int nAvg1, nAvg2;
; 134  : 			if( school[j].nSurvivor == 0 )

  00200	8b bc 34 a4 00
	00 00		 mov	 edi, DWORD PTR _school$[esp+esi+852]
  00207	85 ff		 test	 edi, edi
  00209	75 06		 jne	 SHORT $L268206

; 135  : 				nAvg1	= 0;

  0020b	89 7c 24 10	 mov	 DWORD PTR _nAvg1$268204[esp+800], edi

; 136  : 			else

  0020f	eb 0e		 jmp	 SHORT $L268207
$L268206:

; 137  : 				nAvg1	= school[j].nLevel / school[j].nSurvivor;

  00211	8b 84 34 ac 00
	00 00		 mov	 eax, DWORD PTR _school$[esp+esi+860]
  00218	99		 cdq
  00219	f7 ff		 idiv	 edi
  0021b	89 44 24 10	 mov	 DWORD PTR _nAvg1$268204[esp+800], eax
$L268207:

; 138  : 			if( school[k].nSurvivor == 0 )

  0021f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00221	85 c9		 test	 ecx, ecx
  00223	75 04		 jne	 SHORT $L268208

; 139  : 				nAvg2	= 0;

  00225	33 c0		 xor	 eax, eax

; 140  : 			else

  00227	eb 06		 jmp	 SHORT $L268209
$L268208:

; 141  : 				nAvg2	= school[k].nLevel / school[k].nSurvivor;

  00229	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0022c	99		 cdq
  0022d	f7 f9		 idiv	 ecx
$L268209:

; 142  : 
; 143  : 			if( ( school[j].nSurvivor < school[k].nSurvivor ) ||
; 144  : 				( school[j].nSurvivor == school[k].nSurvivor && nAvg1 < nAvg2 ) )

  0022f	3b f9		 cmp	 edi, ecx
  00231	7c 08		 jl	 SHORT $L268211
  00233	75 36		 jne	 SHORT $L268202
  00235	39 44 24 10	 cmp	 DWORD PTR _nAvg1$268204[esp+800], eax
  00239	7d 30		 jge	 SHORT $L268202
$L268211:

; 145  : 			{	// swap
; 146  : 				SCHOOL_ENTRY tmp;
; 147  : 				memcpy( &tmp, &school[j], sizeof(SCHOOL_ENTRY) );

  0023b	8d 44 34 70	 lea	 eax, DWORD PTR _school$[esp+esi+800]
  0023f	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00244	8b f0		 mov	 esi, eax
  00246	8d 7c 24 28	 lea	 edi, DWORD PTR _tmp$268212[esp+800]
  0024a	f3 a5		 rep movsd

; 148  : 				memcpy( &school[j], &school[k], sizeof(SCHOOL_ENTRY) );

  0024c	8d 53 cc	 lea	 edx, DWORD PTR [ebx-52]
  0024f	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00254	8b f2		 mov	 esi, edx
  00256	8b f8		 mov	 edi, eax
  00258	f3 a5		 rep movsd

; 149  : 				memcpy( &school[k], &tmp, sizeof( SCHOOL_ENTRY) );

  0025a	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  0025f	8d 74 24 28	 lea	 esi, DWORD PTR _tmp$268212[esp+800]
  00263	8b fa		 mov	 edi, edx
  00265	f3 a5		 rep movsd
  00267	8b 74 24 14	 mov	 esi, DWORD PTR tv916[esp+800]
$L268202:
  0026b	8b 44 24 20	 mov	 eax, DWORD PTR tv282[esp+800]
  0026f	83 c3 44	 add	 ebx, 68			; 00000044H
  00272	48		 dec	 eax
  00273	89 44 24 20	 mov	 DWORD PTR tv282[esp+800], eax
  00277	75 87		 jne	 SHORT $L268201

; 130  : 	{
; 131  : 		for( int k = j + 1; k < MAX_SCHOOL; k++ )

  00279	8b 4c 24 24	 mov	 ecx, DWORD PTR tv918[esp+800]
$L268198:

; 127  : 	}
; 128  : 	// sort
; 129  : 	for( int j = 0; j < MAX_SCHOOL-1; j++ )

  0027d	8b 44 24 18	 mov	 eax, DWORD PTR tv248[esp+800]
  00281	41		 inc	 ecx
  00282	83 c6 44	 add	 esi, 68			; 00000044H
  00285	48		 dec	 eax
  00286	89 4c 24 24	 mov	 DWORD PTR tv918[esp+800], ecx
  0028a	89 74 24 14	 mov	 DWORD PTR tv916[esp+800], esi
  0028e	89 44 24 18	 mov	 DWORD PTR tv248[esp+800], eax
  00292	0f 85 48 ff ff
	ff		 jne	 $L268197

; 150  : 			}
; 151  : 		}
; 152  : 	}
; 153  : 
; 154  : 	short nElapse	= (short)( (int)( GetTickCount() - m_dwsbstart2 ) / (int)MIN( 1 ) );

  00298	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0029e	8b c8		 mov	 ecx, eax
  002a0	8b 44 24 1c	 mov	 eax, DWORD PTR $T290239[esp+800]
  002a4	2b 88 88 00 00
	00		 sub	 ecx, DWORD PTR [eax+136]
  002aa	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  002af	f7 e9		 imul	 ecx
  002b1	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  002b4	8b c2		 mov	 eax, edx
  002b6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002b9	03 c2		 add	 eax, edx

; 155  : 	g_UserMng.AddSchoolReport( school, nElapse );	// neuz

  002bb	50		 push	 eax
  002bc	8d 4c 24 74	 lea	 ecx, DWORD PTR _school$[esp+804]
  002c0	51		 push	 ecx
  002c1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  002c6	e8 00 00 00 00	 call	 ?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z ; CUserMng::AddSchoolReport

; 156  : 
; 157  : 	return TRUE;
; 158  : }

  002cb	8b 8c 24 1c 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+800]
  002d2	5f		 pop	 edi
  002d3	5e		 pop	 esi
  002d4	33 cd		 xor	 ecx, ebp
  002d6	b8 01 00 00 00	 mov	 eax, 1
  002db	5b		 pop	 ebx
  002dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c3		 ret	 0
?Report@CEveSchool@@QAEHXZ ENDP				; CEveSchool::Report
_TEXT	ENDS
PUBLIC	?End@CEveSchool@@QAEHXZ				; CEveSchool::End
EXTRN	?SendSchoolReport@CDPDatabaseClient@@QAEXPAU_SCHOOL_ENTRY@@@Z:NEAR ; CDPDatabaseClient::SendSchoolReport
EXTRN	?g_dpDBClient@@3VCDPDatabaseClient@@A:BYTE	; g_dpDBClient
; Function compile flags: /Ogty
;	COMDAT ?End@CEveSchool@@QAEHXZ
_TEXT	SEGMENT
tv799 = -780						; size = 4
_nAvg1$268269 = -780					; size = 4
tv210 = -776						; size = 4
$T290765 = -776						; size = 4
tv908 = -772						; size = 4
tv910 = -768						; size = 4
tv359 = -764						; size = 4
_tmp$268277 = -760					; size = 68
_school$ = -688						; size = 680
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?End@CEveSchool@@QAEHXZ PROC NEAR			; CEveSchool::End, COMDAT
; _this$ = ecx

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 0c 03 00
	00		 sub	 esp, 780		; 0000030cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b f1		 mov	 esi, ecx
  00016	33 c5		 xor	 eax, ebp

; 162  : // "/sbend"
; 163  : 	if( g_eLocal.GetState( EVE_SCHOOL_BATTLE ) != SBS_START2 )	// '/sbstart2'

  00018	6a 05		 push	 5
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0001f	89 84 24 18 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+796], eax

; 170  : 		i != m_pSchoolMng->m_mapPGuild.end(); ++i )

  00026	89 74 24 14	 mov	 DWORD PTR $T290765[esp+796], esi
  0002a	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  0002f	3c 03		 cmp	 al, 3
  00031	74 17		 je	 SHORT $L268225

; 164  : 		return FALSE;

  00033	33 c0		 xor	 eax, eax

; 234  : 
; 235  : 	return TRUE;
; 236  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+780]
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$L268225:

; 165  : 
; 166  : 	SCHOOL_ENTRY	school[MAX_SCHOOL];

  0004a	8d 84 24 9c 00
	00 00		 lea	 eax, DWORD PTR _school$[esp+844]
  00051	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
$L290273:
  00056	33 c9		 xor	 ecx, ecx
  00058	89 48 cc	 mov	 DWORD PTR [eax-52], ecx
  0005b	88 48 d0	 mov	 BYTE PTR [eax-48], cl
  0005e	89 08		 mov	 DWORD PTR [eax], ecx
  00060	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00063	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00066	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00069	83 c0 44	 add	 eax, 68			; 00000044H
  0006c	4a		 dec	 edx
  0006d	75 e7		 jne	 SHORT $L290273

; 169  : 	for( map<u_long, CGuild*>::iterator i = m_pSchoolMng->m_mapPGuild.begin();

  0006f	8b 06		 mov	 eax, DWORD PTR [esi]
  00071	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00074	8b 18		 mov	 ebx, DWORD PTR [eax]

; 170  : 		i != m_pSchoolMng->m_mapPGuild.end(); ++i )

  00076	3b d8		 cmp	 ebx, eax
  00078	0f 84 64 01 00
	00		 je	 $L268239

; 167  : 
; 168  : 	int iIndex	= 0;

  0007e	89 4c 24 0c	 mov	 DWORD PTR tv799[esp+792], ecx

; 170  : 		i != m_pSchoolMng->m_mapPGuild.end(); ++i )

$L290457:

; 171  : 	{
; 172  : 		CGuild* pSchool	= i->second;

  00082	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 173  : 		
; 174  : 		school[iIndex].id	= pSchool->m_idGuild;

  00085	8b 74 24 0c	 mov	 esi, DWORD PTR tv799[esp+792]
  00089	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 175  : 		lstrcpy( school[iIndex].lpName, pSchool->m_szGuild );

  0008c	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  0008f	8d 74 34 6c	 lea	 esi, DWORD PTR _school$[esp+esi+796]
  00093	52		 push	 edx
  00094	56		 push	 esi
  00095	89 4e fc	 mov	 DWORD PTR [esi-4], ecx
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 176  : 		school[iIndex].nDead	= pSchool->m_nDead;

  0009e	8b 87 40 01 00
	00		 mov	 eax, DWORD PTR [edi+320]
  000a4	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 177  : 
; 178  : 		for( map<u_long, CGuildMember*>::iterator i2 = pSchool->m_mapPMember.begin();

  000a7	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  000aa	8b 30		 mov	 esi, DWORD PTR [eax]

; 179  : 		i2 != pSchool->m_mapPMember.end(); ++i2 )

  000ac	3b f0		 cmp	 esi, eax
  000ae	0f 84 c8 00 00
	00		 je	 $L268251
$L290685:

; 180  : 		{
; 181  : 			CGuildMember* pMember	= i2->second;

  000b4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 182  : 			CUser* pUser	= g_UserMng.GetUserByPlayerID( pMember->m_idPlayer );

  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	51		 push	 ecx
  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000c0	e8 00 00 00 00	 call	 ?GetUserByPlayerID@CUserMng@@QAEPAVCUser@@K@Z ; CUserMng::GetUserByPlayerID

; 183  : 			if( IsValidObj( (CObj*)pUser ) )

  000c5	85 c0		 test	 eax, eax
  000c7	74 62		 je	 SHORT $L268250
  000c9	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000cd	75 5c		 jne	 SHORT $L268250

; 184  : 			{
; 185  : 				if( pUser->IsRegionAttr( RA_FIGHT ) )

  000cf	f6 80 d4 02 00
	00 40		 test	 BYTE PTR [eax+724], 64	; 00000040H
  000d6	74 36		 je	 SHORT $L268256

; 186  : 				{
; 187  : 					if( !pUser->IsMode( OBSERVE_MODE ) )

  000d8	8b 90 44 02 00
	00		 mov	 edx, DWORD PTR [eax+580]
  000de	81 e2 c0 00 00
	00		 and	 edx, 192		; 000000c0H
  000e4	80 fa c0	 cmp	 dl, 192			; 000000c0H
  000e7	74 42		 je	 SHORT $L268250

; 188  : 					{
; 189  : 						school[iIndex].nSurvivor++;

  000e9	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv799[esp+792]
  000ed	ff 84 0c 9c 00
	00 00		 inc	 DWORD PTR _school$[esp+ecx+844]

; 190  : 						school[iIndex].nLevel	+= pUser->GetLevel();

  000f4	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [eax+1504]
  000fa	8b 94 0c a4 00
	00 00		 mov	 edx, DWORD PTR _school$[esp+ecx+852]
  00101	8d 8c 0c a4 00
	00 00		 lea	 ecx, DWORD PTR _school$[esp+ecx+852]
  00108	03 d0		 add	 edx, eax
  0010a	89 11		 mov	 DWORD PTR [ecx], edx

; 191  : 					}
; 192  : 				}
; 193  : 				else

  0010c	eb 1d		 jmp	 SHORT $L268250
$L268256:

; 194  : 				{
; 195  : 					pUser->SetMode( OBSERVE_MODE );		// MAKE observe mode

  0010e	8b 90 44 02 00
	00		 mov	 edx, DWORD PTR [eax+580]
  00114	81 ca c0 00 00
	00		 or	 edx, 192		; 000000c0H

; 196  : 					g_UserMng.AddModifyMode( pUser );

  0011a	50		 push	 eax
  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00120	89 90 44 02 00
	00		 mov	 DWORD PTR [eax+580], edx
  00126	e8 00 00 00 00	 call	 ?AddModifyMode@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddModifyMode
$L268250:
  0012b	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  0012e	84 c0		 test	 al, al
  00130	75 41		 jne	 SHORT $L290656
  00132	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00135	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00138	84 c9		 test	 cl, cl
  0013a	75 18		 jne	 SHORT $L290770
  0013c	8b f0		 mov	 esi, eax
  0013e	8b 06		 mov	 eax, DWORD PTR [esi]
  00140	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00143	84 c9		 test	 cl, cl
  00145	75 2c		 jne	 SHORT $L290656

; 179  : 		i2 != pSchool->m_mapPMember.end(); ++i2 )

$L290670:
  00147	8b f0		 mov	 esi, eax
  00149	8b 06		 mov	 eax, DWORD PTR [esi]
  0014b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0014e	84 c9		 test	 cl, cl
  00150	74 f5		 je	 SHORT $L290670
  00152	eb 1f		 jmp	 SHORT $L290656
$L290770:
  00154	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00157	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0015a	84 c9		 test	 cl, cl
  0015c	75 13		 jne	 SHORT $L290659
  0015e	8b ff		 npad	 2
$L290658:
  00160	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00163	75 0c		 jne	 SHORT $L290659
  00165	8b f0		 mov	 esi, eax
  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0016d	84 c9		 test	 cl, cl
  0016f	74 ef		 je	 SHORT $L290658
$L290659:
  00171	8b f0		 mov	 esi, eax
$L290656:
  00173	3b 77 3c	 cmp	 esi, DWORD PTR [edi+60]
  00176	0f 85 38 ff ff
	ff		 jne	 $L290685
$L268251:

; 197  : 				}
; 198  : 			}
; 199  : 		}
; 200  : 		iIndex++;

  0017c	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv799[esp+792]
  00180	8a 43 15	 mov	 al, BYTE PTR [ebx+21]
  00183	83 c1 44	 add	 ecx, 68			; 00000044H
  00186	84 c0		 test	 al, al
  00188	89 4c 24 0c	 mov	 DWORD PTR tv799[esp+792], ecx
  0018c	75 45		 jne	 SHORT $L290427
  0018e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00191	8a 41 15	 mov	 al, BYTE PTR [ecx+21]
  00194	84 c0		 test	 al, al
  00196	75 18		 jne	 SHORT $L290772
  00198	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019a	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0019d	84 d2		 test	 dl, dl
  0019f	75 0b		 jne	 SHORT $L290449

; 170  : 		i != m_pSchoolMng->m_mapPGuild.end(); ++i )

$L290448:
  001a1	8b c8		 mov	 ecx, eax
  001a3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a5	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  001a8	84 d2		 test	 dl, dl
  001aa	74 f5		 je	 SHORT $L290448
$L290449:
  001ac	8b d9		 mov	 ebx, ecx
  001ae	eb 23		 jmp	 SHORT $L290427
$L290772:
  001b0	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  001b3	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001b6	84 c9		 test	 cl, cl
  001b8	75 17		 jne	 SHORT $L290430
  001ba	8d 9b 00 00 00
	00		 npad	 6
$L290429:
  001c0	3b 58 08	 cmp	 ebx, DWORD PTR [eax+8]
  001c3	75 0c		 jne	 SHORT $L290430
  001c5	8b d8		 mov	 ebx, eax
  001c7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ca	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001cd	84 c9		 test	 cl, cl
  001cf	74 ef		 je	 SHORT $L290429
$L290430:
  001d1	8b d8		 mov	 ebx, eax
$L290427:
  001d3	8b 4c 24 10	 mov	 ecx, DWORD PTR $T290765[esp+792]
  001d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d9	3b 5a 0c	 cmp	 ebx, DWORD PTR [edx+12]
  001dc	0f 85 a0 fe ff
	ff		 jne	 $L290457
$L268239:

; 201  : 	}
; 202  : 
; 203  : 	// sort
; 204  : 	for( int j = 0; j < MAX_SCHOOL-1; j++ )

  001e2	33 f6		 xor	 esi, esi
  001e4	b9 01 00 00 00	 mov	 ecx, 1
  001e9	89 74 24 14	 mov	 DWORD PTR tv908[esp+792], esi
  001ed	89 4c 24 18	 mov	 DWORD PTR tv910[esp+792], ecx
  001f1	c7 44 24 10 09
	00 00 00	 mov	 DWORD PTR tv210[esp+792], 9
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$L268262:

; 205  : 	{
; 206  : 		for( int k = j + 1; k < MAX_SCHOOL; k++ )

  00200	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00203	0f 8d 94 00 00
	00		 jge	 $L268263
  00209	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0020e	2b c1		 sub	 eax, ecx
  00210	8d 9c 34 e0 00
	00 00		 lea	 ebx, DWORD PTR _school$[esp+esi+912]
  00217	89 44 24 1c	 mov	 DWORD PTR tv359[esp+792], eax
  0021b	eb 03 8d 49 00	 npad	 5
$L268266:

; 207  : 		{
; 208  : 			int nAvg1, nAvg2;
; 209  : 			if( school[j].nSurvivor == 0 )

  00220	8b bc 34 9c 00
	00 00		 mov	 edi, DWORD PTR _school$[esp+esi+844]
  00227	85 ff		 test	 edi, edi
  00229	75 06		 jne	 SHORT $L268271

; 210  : 				nAvg1	= 0;

  0022b	89 7c 24 0c	 mov	 DWORD PTR _nAvg1$268269[esp+792], edi

; 211  : 			else

  0022f	eb 0e		 jmp	 SHORT $L268272
$L268271:

; 212  : 				nAvg1	= school[j].nLevel / school[j].nSurvivor;

  00231	8b 84 34 a4 00
	00 00		 mov	 eax, DWORD PTR _school$[esp+esi+852]
  00238	99		 cdq
  00239	f7 ff		 idiv	 edi
  0023b	89 44 24 0c	 mov	 DWORD PTR _nAvg1$268269[esp+792], eax
$L268272:

; 213  : 			if( school[k].nSurvivor == 0 )

  0023f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00241	85 c9		 test	 ecx, ecx
  00243	75 04		 jne	 SHORT $L268273

; 214  : 				nAvg2	= 0;

  00245	33 c0		 xor	 eax, eax

; 215  : 			else

  00247	eb 06		 jmp	 SHORT $L268274
$L268273:

; 216  : 				nAvg2	= school[k].nLevel / school[k].nSurvivor;

  00249	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0024c	99		 cdq
  0024d	f7 f9		 idiv	 ecx
$L268274:

; 217  : 
; 218  : 			if( ( school[j].nSurvivor < school[k].nSurvivor ) ||
; 219  : 				( school[j].nSurvivor == school[k].nSurvivor && nAvg1 < nAvg2 ) )

  0024f	3b f9		 cmp	 edi, ecx
  00251	7c 08		 jl	 SHORT $L268276
  00253	75 36		 jne	 SHORT $L268267
  00255	39 44 24 0c	 cmp	 DWORD PTR _nAvg1$268269[esp+792], eax
  00259	7d 30		 jge	 SHORT $L268267
$L268276:

; 220  : 			{	// swap
; 221  : 				SCHOOL_ENTRY tmp;
; 222  : 				memcpy( &tmp, &school[j], sizeof(SCHOOL_ENTRY) );

  0025b	8d 44 34 68	 lea	 eax, DWORD PTR _school$[esp+esi+792]
  0025f	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00264	8b f0		 mov	 esi, eax
  00266	8d 7c 24 20	 lea	 edi, DWORD PTR _tmp$268277[esp+792]
  0026a	f3 a5		 rep movsd

; 223  : 				memcpy( &school[j], &school[k], sizeof(SCHOOL_ENTRY) );

  0026c	8d 53 cc	 lea	 edx, DWORD PTR [ebx-52]
  0026f	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00274	8b f2		 mov	 esi, edx
  00276	8b f8		 mov	 edi, eax
  00278	f3 a5		 rep movsd

; 224  : 				memcpy( &school[k], &tmp, sizeof( SCHOOL_ENTRY) );

  0027a	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  0027f	8d 74 24 20	 lea	 esi, DWORD PTR _tmp$268277[esp+792]
  00283	8b fa		 mov	 edi, edx
  00285	f3 a5		 rep movsd
  00287	8b 74 24 14	 mov	 esi, DWORD PTR tv908[esp+792]
$L268267:
  0028b	8b 44 24 1c	 mov	 eax, DWORD PTR tv359[esp+792]
  0028f	83 c3 44	 add	 ebx, 68			; 00000044H
  00292	48		 dec	 eax
  00293	89 44 24 1c	 mov	 DWORD PTR tv359[esp+792], eax
  00297	75 87		 jne	 SHORT $L268266

; 205  : 	{
; 206  : 		for( int k = j + 1; k < MAX_SCHOOL; k++ )

  00299	8b 4c 24 18	 mov	 ecx, DWORD PTR tv910[esp+792]
$L268263:

; 201  : 	}
; 202  : 
; 203  : 	// sort
; 204  : 	for( int j = 0; j < MAX_SCHOOL-1; j++ )

  0029d	8b 44 24 10	 mov	 eax, DWORD PTR tv210[esp+792]
  002a1	41		 inc	 ecx
  002a2	83 c6 44	 add	 esi, 68			; 00000044H
  002a5	48		 dec	 eax
  002a6	89 4c 24 18	 mov	 DWORD PTR tv910[esp+792], ecx
  002aa	89 74 24 14	 mov	 DWORD PTR tv908[esp+792], esi
  002ae	89 44 24 10	 mov	 DWORD PTR tv210[esp+792], eax
  002b2	0f 85 48 ff ff
	ff		 jne	 $L268262

; 225  : 			}
; 226  : 		}
; 227  : 	}
; 228  : 
; 229  : 	if( g_eLocal.SetState( EVE_SCHOOL_BATTLE, SBS_END ) )

  002b8	6a 00		 push	 0
  002ba	6a 05		 push	 5
  002bc	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  002c1	e8 00 00 00 00	 call	 ?SetState@CFlyffEvent@@QAEHHE@Z ; CFlyffEvent::SetState
  002c6	85 c0		 test	 eax, eax
  002c8	74 0e		 je	 SHORT $L268281

; 230  : 		g_UserMng.AddSetLocalEvent( EVE_SCHOOL_BATTLE, SBS_END );

  002ca	6a 00		 push	 0
  002cc	6a 05		 push	 5
  002ce	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  002d3	e8 00 00 00 00	 call	 ?AddSetLocalEvent@CUserMng@@QAEXFE@Z ; CUserMng::AddSetLocalEvent
$L268281:

; 231  : 
; 232  : 	g_dpDBClient.SendSchoolReport( school );	// log

  002d8	8d 44 24 68	 lea	 eax, DWORD PTR _school$[esp+792]
  002dc	50		 push	 eax
  002dd	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  002e2	e8 00 00 00 00	 call	 ?SendSchoolReport@CDPDatabaseClient@@QAEXPAU_SCHOOL_ENTRY@@@Z ; CDPDatabaseClient::SendSchoolReport

; 233  : 	g_UserMng.AddSchoolReport( school );	// neuz	

  002e7	6a 00		 push	 0
  002e9	8d 4c 24 6c	 lea	 ecx, DWORD PTR _school$[esp+796]
  002ed	51		 push	 ecx
  002ee	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  002f3	e8 00 00 00 00	 call	 ?AddSchoolReport@CUserMng@@QAEXPAU_SCHOOL_ENTRY@@F@Z ; CUserMng::AddSchoolReport

; 234  : 
; 235  : 	return TRUE;
; 236  : }

  002f8	8b 8c 24 14 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+792]
  002ff	5f		 pop	 edi
  00300	5e		 pop	 esi
  00301	33 cd		 xor	 ecx, ebp
  00303	b8 01 00 00 00	 mov	 eax, 1
  00308	5b		 pop	 ebx
  00309	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030e	8b e5		 mov	 esp, ebp
  00310	5d		 pop	 ebp
  00311	c3		 ret	 0
?End@CEveSchool@@QAEHXZ ENDP				; CEveSchool::End
_TEXT	ENDS
PUBLIC	?GuildCombatCloseTeleport@CGuildCombat@@QAEXXZ	; CGuildCombat::GuildCombatCloseTeleport
PUBLIC	??_C@_06NDLDHKAP@flaris?$AA@			; `string'
EXTRN	?SendGuildCombatResult@CDPDatabaseClient@@QAEXXZ:NEAR ; CDPDatabaseClient::SendGuildCombatResult
EXTRN	?ReplaceWorld@CUserMng@@QAEXKKMMH@Z:NEAR	; CUserMng::ReplaceWorld
EXTRN	?AddGuildMsg@CUserMng@@QAEXKPBD@Z:NEAR		; CUserMng::AddGuildMsg
EXTRN	?g_DPCoreClient@@3VCDPCoreClient@@A:BYTE	; g_DPCoreClient
EXTRN	?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z:NEAR ; CWorldMng::GetRevivalPos
EXTRN	?SendGuildCombatState@CDPCoreClient@@QAEXH@Z:NEAR ; CDPCoreClient::SendGuildCombatState
;	COMDAT ??_C@_06NDLDHKAP@flaris?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
CONST	SEGMENT
??_C@_06NDLDHKAP@flaris?$AA@ DB 'flaris', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?GuildCombatCloseTeleport@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
?GuildCombatCloseTeleport@CGuildCombat@@QAEXXZ PROC NEAR ; CGuildCombat::GuildCombatCloseTeleport, COMDAT
; _this$ = ecx

; 1631 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1632 : 	if( m_nStopWar != 200 )

  00003	81 be 8c 10 00
	00 c8 00 00 00	 cmp	 DWORD PTR [esi+4236], 200 ; 000000c8H
  0000d	74 0a		 je	 SHORT $L269050

; 1633 : 		g_dpDBClient.SendGuildCombatResult();

  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00014	e8 00 00 00 00	 call	 ?SendGuildCombatResult@CDPDatabaseClient@@QAEXXZ ; CDPDatabaseClient::SendGuildCombatResult
$L269050:

; 1634 : 	
; 1635 : 	PRegionElem pRgnElem = g_WorldMng.GetRevivalPos( WI_WORLD_MADRIGAL, "flaris" );

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06NDLDHKAP@flaris?$AA@
  0001e	6a 01		 push	 1
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00025	e8 00 00 00 00	 call	 ?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPos

; 1636 : 	if( NULL == pRgnElem )

  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 b2 00 00
	00		 je	 $L269049
  00032	57		 push	 edi

; 1637 : 		return;
; 1638 : 
; 1639 : #ifdef __LAYER_1015
; 1640 : 	g_UserMng.ReplaceWorld( WI_WORLD_GUILDWAR, WI_WORLD_MADRIGAL, 6968.0f, 3328.8f, nDefaultLayer );

  00033	6a 00		 push	 0
  00035	68 cd 0c 50 45	 push	 1162874061		; 45500ccdH
  0003a	68 00 c0 d9 45	 push	 1171898368		; 45d9c000H
  0003f	6a 01		 push	 1
  00041	68 ca 00 00 00	 push	 202			; 000000caH
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0004b	e8 00 00 00 00	 call	 ?ReplaceWorld@CUserMng@@QAEXKKMMH@Z ; CUserMng::ReplaceWorld

; 1641 : #else	// __LAYER_1015
; 1642 : 	g_UserMng.ReplaceWorld( WI_WORLD_GUILDWAR, WI_WORLD_MADRIGAL, 6968.0f, 3328.8f );
; 1643 : #endif	// __LAYER_1015
; 1644 : 
; 1645 : #if __VER >= 8 // __GUILDCOMBAT_85
; 1646 : 	for( int i = 0 ; i < (int)( m_vecstrGuildMsg.size() ) ; ++i )

  00050	33 ff		 xor	 edi, edi
$L269056:
  00052	8b 8e f4 10 00
	00		 mov	 ecx, DWORD PTR [esi+4340]
  00058	85 c9		 test	 ecx, ecx
  0005a	75 04		 jne	 SHORT $L290794
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 0b		 jmp	 SHORT $L290795
$L290794:
  00060	8b 86 f8 10 00
	00		 mov	 eax, DWORD PTR [esi+4344]
  00066	2b c1		 sub	 eax, ecx
  00068	c1 f8 02	 sar	 eax, 2
$L290795:
  0006b	3b f8		 cmp	 edi, eax
  0006d	7d 1e		 jge	 SHORT $L269058
  0006f	8b 86 f4 10 00
	00		 mov	 eax, DWORD PTR [esi+4340]

; 1647 : 		g_UserMng.AddGuildMsg( m_uWinGuildId, m_vecstrGuildMsg[i] );

  00075	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00078	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0007b	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  0007e	51		 push	 ecx
  0007f	52		 push	 edx
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00085	e8 00 00 00 00	 call	 ?AddGuildMsg@CUserMng@@QAEXKPBD@Z ; CUserMng::AddGuildMsg
  0008a	47		 inc	 edi
  0008b	eb c5		 jmp	 SHORT $L269056
$L269058:

; 1648 : #endif // __VER >= 8
; 1649 : 
; 1650 : 	m_nState = CLOSE_STATE;
; 1651 : 	m_nGCState = WAR_CLOSE_STATE;
; 1652 : 	m_dwTime = 0;
; 1653 : 	m_nStopWar = 0;
; 1654 : 	if( g_eLocal.GetState( EVE_GUILDCOMBAT ) )

  0008d	6a 0f		 push	 15			; 0000000fH
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00094	c7 86 40 11 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4416], 1
  0009e	c7 86 44 11 00
	00 69 00 00 00	 mov	 DWORD PTR [esi+4420], 105 ; 00000069H
  000a8	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0
  000b2	c7 86 8c 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4236], 0
  000bc	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  000c1	84 c0		 test	 al, al
  000c3	5f		 pop	 edi
  000c4	74 0c		 je	 SHORT $L269059

; 1655 : 		g_DPCoreClient.SendGuildCombatState( CLOSE_STATE );	

  000c6	6a 01		 push	 1
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  000cd	e8 00 00 00 00	 call	 ?SendGuildCombatState@CDPCoreClient@@QAEXH@Z ; CDPCoreClient::SendGuildCombatState
$L269059:

; 1656 : 
; 1657 : 	m_bMutex = FALSE;	

  000d2	c7 86 c8 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4296], 0

; 1658 : 
; 1659 : 	SetNpc();

  000dc	8b ce		 mov	 ecx, esi
  000de	5e		 pop	 esi
  000df	e9 00 00 00 00	 jmp	 ?SetNpc@CGuildCombat@@QAEXXZ ; CGuildCombat::SetNpc
$L269049:
  000e4	5e		 pop	 esi

; 1660 : }

  000e5	c3		 ret	 0
?GuildCombatCloseTeleport@CGuildCombat@@QAEXXZ ENDP	; CGuildCombat::GuildCombatCloseTeleport
_TEXT	ENDS
PUBLIC	?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
; Function compile flags: /Ogty
;	COMDAT ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z
_TEXT	SEGMENT
_GuildId$ = 8						; size = 4
?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z PROC NEAR ; CGuildCombat::FindGuildCombatMember, COMDAT
; _this$ = ecx

; 2124 : {

  00000	53		 push	 ebx

; 2125 : 	__GuildCombatMember* pGCMem = NULL;
; 2126 : 	for( int i = 0 ; i < (int)( m_vecGuildCombatMem.size() ) ; ++i )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _GuildId$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 79 74	 mov	 edi, DWORD PTR [ecx+116]
  0000a	33 c0		 xor	 eax, eax
  0000c	33 f6		 xor	 esi, esi
  0000e	8b ff		 npad	 2
$L269465:
  00010	85 ff		 test	 edi, edi
  00012	75 04		 jne	 SHORT $L290865
  00014	33 d2		 xor	 edx, edx
  00016	eb 08		 jmp	 SHORT $L290866
$L290865:
  00018	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  0001b	2b d7		 sub	 edx, edi
  0001d	c1 fa 02	 sar	 edx, 2
$L290866:
  00020	3b f2		 cmp	 esi, edx
  00022	7d 17		 jge	 SHORT $L269467
  00024	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00027	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]

; 2127 : 	{
; 2128 : 		if( GuildId == m_vecGuildCombatMem[i]->uGuildId )

  0002a	8b 12		 mov	 edx, DWORD PTR [edx]
  0002c	3b 1a		 cmp	 ebx, DWORD PTR [edx]
  0002e	74 03		 je	 SHORT $L290980

; 2125 : 	__GuildCombatMember* pGCMem = NULL;
; 2126 : 	for( int i = 0 ; i < (int)( m_vecGuildCombatMem.size() ) ; ++i )

  00030	46		 inc	 esi
  00031	eb dd		 jmp	 SHORT $L269465
$L290980:

; 2129 : 		{
; 2130 : 			pGCMem = m_vecGuildCombatMem[i];

  00033	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00036	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]

; 2131 : 			break;
; 2132 : 		}
; 2133 : 	}
; 2134 : 	return pGCMem;

  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$L269467:
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx

; 2135 : }

  0003e	c2 04 00	 ret	 4
?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ENDP ; CGuildCombat::FindGuildCombatMember
_TEXT	ENDS
PUBLIC	?SetSelectMap@CGuildCombat@@QAEXPAVCUser@@H@Z	; CGuildCombat::SetSelectMap
; Function compile flags: /Ogty
;	COMDAT ?SetSelectMap@CGuildCombat@@QAEXPAVCUser@@H@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
_nMap$ = 12						; size = 4
?SetSelectMap@CGuildCombat@@QAEXPAVCUser@@H@Z PROC NEAR	; CGuildCombat::SetSelectMap, COMDAT
; _this$ = ecx

; 2138 : {

  00000	57		 push	 edi

; 2139 : #ifdef __S_BUG_GC
; 2140 : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( pUser->m_idGuild );

  00001	8b 7c 24 08	 mov	 edi, DWORD PTR _pUser$[esp]
  00005	8b 87 1c 07 00
	00		 mov	 eax, DWORD PTR [edi+1820]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 2141 : 	if( pGCMember != NULL )

  00011	85 c0		 test	 eax, eax
  00013	74 40		 je	 SHORT $L269480
  00015	56		 push	 esi
  00016	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00019	53		 push	 ebx

; 2142 : 	{	
; 2143 : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0001a	33 d2		 xor	 edx, edx
  0001c	55		 push	 ebp
  0001d	8d 49 00	 npad	 3
$L269478:
  00020	85 f6		 test	 esi, esi
  00022	75 04		 jne	 SHORT $L290989
  00024	33 c9		 xor	 ecx, ecx
  00026	eb 08		 jmp	 SHORT $L290990
$L290989:
  00028	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002b	2b ce		 sub	 ecx, esi
  0002d	c1 f9 02	 sar	 ecx, 2
$L290990:
  00030	3b d1		 cmp	 edx, ecx
  00032	7d 1e		 jge	 SHORT $L291051
  00034	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 2144 : 		{
; 2145 : 			__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 2146 : 			if( pJoinPlayer->uidPlayer == pUser->m_idPlayer )

  00037	8b af 38 02 00
	00		 mov	 ebp, DWORD PTR [edi+568]
  0003d	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]
  00040	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00042	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00044	3b dd		 cmp	 ebx, ebp
  00046	74 03		 je	 SHORT $L291049

; 2142 : 	{	
; 2143 : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00048	42		 inc	 edx
  00049	eb d5		 jmp	 SHORT $L269478
$L291049:

; 2147 : 			{
; 2148 : 				pJoinPlayer->nMap = nMap;

  0004b	8b 54 24 18	 mov	 edx, DWORD PTR _nMap$[esp+12]
  0004f	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$L291051:
  00052	5d		 pop	 ebp
  00053	5b		 pop	 ebx
  00054	5e		 pop	 esi
$L269480:
  00055	5f		 pop	 edi

; 2149 : 				break;
; 2150 : 			}
; 2151 : 		}
; 2152 : 	}
; 2153 : #else // __S_BUG_GC
; 2154 : 	map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( pUser->m_idGuild );
; 2155 : 	if( it != m_GuildCombatMem.end() )
; 2156 : 	{	
; 2157 : 		__GuildCombatMember* pGCMember = it->second;
; 2158 : 		for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 2159 : 		{
; 2160 : 			__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 2161 : 			if( pJoinPlayer->uidPlayer == pUser->m_idPlayer )
; 2162 : 			{
; 2163 : 				pJoinPlayer->nMap = nMap;
; 2164 : 				break;
; 2165 : 			}
; 2166 : 		}
; 2167 : 	}
; 2168 : #endif // __S_BUG_GC
; 2169 : }

  00056	c2 08 00	 ret	 8
?SetSelectMap@CGuildCombat@@QAEXPAVCUser@@H@Z ENDP	; CGuildCombat::SetSelectMap
_TEXT	ENDS
PUBLIC	?IsSelectPlayer@CGuildCombat@@QAEHPAVCUser@@@Z	; CGuildCombat::IsSelectPlayer
; Function compile flags: /Ogty
;	COMDAT ?IsSelectPlayer@CGuildCombat@@QAEHPAVCUser@@@Z
_TEXT	SEGMENT
_RequestGuild$ = -8					; size = 8
_pUser$ = 8						; size = 4
?IsSelectPlayer@CGuildCombat@@QAEHPAVCUser@@@Z PROC NEAR ; CGuildCombat::IsSelectPlayer, COMDAT
; _this$ = ecx

; 2699 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx

; 2700 : 	__GuildCombatMember* pGuildCombatMem;
; 2701 : 	__JOINPLAYER* pJoinPlayer;
; 2702 : 	__REQUESTGUILD RequestGuild;
; 2703 : 
; 2704 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00004	8b 5c 24 10	 mov	 ebx, DWORD PTR _pUser$[esp+8]
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b b9 14 11 00
	00		 mov	 edi, DWORD PTR [ecx+4372]
  00011	33 f6		 xor	 esi, esi
$L269770:
  00013	85 ff		 test	 edi, edi
  00015	75 04		 jne	 SHORT $L291061
  00017	33 c0		 xor	 eax, eax
  00019	eb 0b		 jmp	 SHORT $L291062
$L291061:
  0001b	8b 81 18 11 00
	00		 mov	 eax, DWORD PTR [ecx+4376]
  00021	2b c7		 sub	 eax, edi
  00023	c1 f8 03	 sar	 eax, 3
$L291062:
  00026	3b f0		 cmp	 esi, eax
  00028	7d 77		 jge	 SHORT $L269782

; 2705 : 	{
; 2706 : 		if( nVeci >= m_nMaxGuild )

  0002a	3b b1 a0 10 00
	00		 cmp	 esi, DWORD PTR [ecx+4256]
  00030	7d 6f		 jge	 SHORT $L269782
  00032	8b 81 14 11 00
	00		 mov	 eax, DWORD PTR [ecx+4372]

; 2707 : 			break;
; 2708 : 
; 2709 : 		RequestGuild = vecRequestRanking[nVeci];

  00038	8b 14 f0	 mov	 edx, DWORD PTR [eax+esi*8]
  0003b	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	89 44 24 14	 mov	 DWORD PTR _RequestGuild$[esp+28], eax

; 2710 : 		if( RequestGuild.uidGuild == pUser->m_idGuild )

  00045	3b 93 1c 07 00
	00		 cmp	 edx, DWORD PTR [ebx+1820]
  0004b	74 03		 je	 SHORT $L291185

; 2700 : 	__GuildCombatMember* pGuildCombatMem;
; 2701 : 	__JOINPLAYER* pJoinPlayer;
; 2702 : 	__REQUESTGUILD RequestGuild;
; 2703 : 
; 2704 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  0004d	46		 inc	 esi
  0004e	eb c3		 jmp	 SHORT $L269770
$L291185:

; 2711 : 		{
; 2712 : #ifdef __S_BUG_GC
; 2713 : 			pGuildCombatMem = FindGuildCombatMember( RequestGuild.uidGuild );

  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 2714 : 			if( pGuildCombatMem != NULL )

  00056	85 c0		 test	 eax, eax
  00058	74 47		 je	 SHORT $L269782
  0005a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 2715 : 			{
; 2716 : 				for( int veci = 0 ; veci < (int)( pGuildCombatMem->vecGCSelectMember.size() ) ; ++veci )

  0005d	33 d2		 xor	 edx, edx
  0005f	90		 npad	 1
$L269778:
  00060	85 f6		 test	 esi, esi
  00062	75 04		 jne	 SHORT $L291124
  00064	33 c9		 xor	 ecx, ecx
  00066	eb 08		 jmp	 SHORT $L291125
$L291124:
  00068	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006b	2b ce		 sub	 ecx, esi
  0006d	c1 f9 02	 sar	 ecx, 2
$L291125:
  00070	3b d1		 cmp	 edx, ecx
  00072	7d 2d		 jge	 SHORT $L269782
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 2717 : 				{
; 2718 : 					pJoinPlayer = pGuildCombatMem->vecGCSelectMember[veci];
; 2719 : 					if( pJoinPlayer->uidPlayer == pUser->m_idPlayer )

  00077	8b ab 38 02 00
	00		 mov	 ebp, DWORD PTR [ebx+568]
  0007d	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]
  00080	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00082	8b 39		 mov	 edi, DWORD PTR [ecx]
  00084	3b fd		 cmp	 edi, ebp
  00086	74 03		 je	 SHORT $L291186

; 2715 : 			{
; 2716 : 				for( int veci = 0 ; veci < (int)( pGuildCombatMem->vecGCSelectMember.size() ) ; ++veci )

  00088	42		 inc	 edx
  00089	eb d5		 jmp	 SHORT $L269778
$L291186:

; 2720 : 					{
; 2721 : 						if( pJoinPlayer->nlife > 0 )

  0008b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008e	85 c0		 test	 eax, eax
  00090	7e 0f		 jle	 SHORT $L269782
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5d		 pop	 ebp

; 2722 : 							return TRUE;

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	5b		 pop	 ebx

; 2749 : }

  0009b	83 c4 08	 add	 esp, 8
  0009e	c2 04 00	 ret	 4
$L269782:
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5d		 pop	 ebp

; 2723 : 						break;
; 2724 : 					}
; 2725 : 				}
; 2726 : 			}
; 2727 : #else // __S_BUG_GC
; 2728 : 			map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2729 : 			if( ita != m_GuildCombatMem.end() )
; 2730 : 			{
; 2731 : 				pGuildCombatMem = ita->second;
; 2732 : 				
; 2733 : 				for( int veci = 0 ; veci < pGuildCombatMem->vecGCSelectMember.size() ; ++veci )
; 2734 : 				{
; 2735 : 					pJoinPlayer = pGuildCombatMem->vecGCSelectMember[veci];
; 2736 : 					if( pJoinPlayer->uidPlayer == pUser->m_idPlayer )
; 2737 : 					{
; 2738 : 						if( pJoinPlayer->nlife > 0 )
; 2739 : 							return TRUE;
; 2740 : 						break;
; 2741 : 					}
; 2742 : 				}
; 2743 : 			}
; 2744 : #endif // __S_BUG_GC
; 2745 : 			break;
; 2746 : 		}
; 2747 : 	}
; 2748 : 	return FALSE;

  000a4	33 c0		 xor	 eax, eax
  000a6	5b		 pop	 ebx

; 2749 : }

  000a7	83 c4 08	 add	 esp, 8
  000aa	c2 04 00	 ret	 4
?IsSelectPlayer@CGuildCombat@@QAEHPAVCUser@@@Z ENDP	; CGuildCombat::IsSelectPlayer
_TEXT	ENDS
PUBLIC	?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z ; CGuildCombat::SerializeGCWarPlayerList
; Function compile flags: /Ogty
;	COMDAT ?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z
_TEXT	SEGMENT
_nVeci$270135 = -16					; size = 4
_this$ = -12						; size = 4
_RequestGuild$270141 = -8				; size = 8
_vecSi$270146 = 8					; size = 4
_ar$ = 8						; size = 4
?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z PROC NEAR ; CGuildCombat::SerializeGCWarPlayerList, COMDAT
; _this$ = ecx

; 3570 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	8b e9		 mov	 ebp, ecx

; 3571 : 	if( m_nMaxGuild <= (int)( vecRequestRanking.size() ) )

  00007	8b 8d 14 11 00
	00		 mov	 ecx, DWORD PTR [ebp+4372]
  0000d	85 c9		 test	 ecx, ecx
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	89 6c 24 14	 mov	 DWORD PTR _this$[esp+32], ebp
  00015	75 04		 jne	 SHORT $L291196
  00017	33 c0		 xor	 eax, eax
  00019	eb 0b		 jmp	 SHORT $L291197
$L291196:
  0001b	8b 85 18 11 00
	00		 mov	 eax, DWORD PTR [ebp+4376]
  00021	2b c1		 sub	 eax, ecx
  00023	c1 f8 03	 sar	 eax, 3
$L291197:
  00026	8b bd a0 10 00
	00		 mov	 edi, DWORD PTR [ebp+4256]
  0002c	3b f8		 cmp	 edi, eax
  0002e	7f 14		 jg	 SHORT $L270132

; 3572 : 		ar << m_nMaxGuild;

  00030	8b 74 24 24	 mov	 esi, DWORD PTR _ar$[esp+28]
  00034	6a 04		 push	 4
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0003d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00040	89 38		 mov	 DWORD PTR [eax], edi

; 3573 : 	else

  00042	eb 2b		 jmp	 SHORT $L291495
$L270132:

; 3574 : 		ar << (int)vecRequestRanking.size();

  00044	8b 85 14 11 00
	00		 mov	 eax, DWORD PTR [ebp+4372]
  0004a	85 c0		 test	 eax, eax
  0004c	75 04		 jne	 SHORT $L291213
  0004e	33 ff		 xor	 edi, edi
  00050	eb 0b		 jmp	 SHORT $L291214
$L291213:
  00052	8b bd 18 11 00
	00		 mov	 edi, DWORD PTR [ebp+4376]
  00058	2b f8		 sub	 edi, eax
  0005a	c1 ff 03	 sar	 edi, 3
$L291214:
  0005d	8b 74 24 24	 mov	 esi, DWORD PTR _ar$[esp+28]
  00061	6a 04		 push	 4
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0006a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006d	89 39		 mov	 DWORD PTR [ecx], edi
$L291495:
  0006f	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3575 : 
; 3576 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00073	33 ff		 xor	 edi, edi
$L291497:
  00075	8b 8d 14 11 00
	00		 mov	 ecx, DWORD PTR [ebp+4372]
  0007b	85 c9		 test	 ecx, ecx
  0007d	89 7c 24 10	 mov	 DWORD PTR _nVeci$270135[esp+32], edi
  00081	75 04		 jne	 SHORT $L291230
  00083	33 c0		 xor	 eax, eax
  00085	eb 0b		 jmp	 SHORT $L291231
$L291230:
  00087	8b 85 18 11 00
	00		 mov	 eax, DWORD PTR [ebp+4376]
  0008d	2b c1		 sub	 eax, ecx
  0008f	c1 f8 03	 sar	 eax, 3
$L291231:
  00092	3b f8		 cmp	 edi, eax
  00094	0f 8d 65 01 00
	00		 jge	 $L291491

; 3577 : 	{
; 3578 : 		if( nVeci >= m_nMaxGuild )

  0009a	3b bd a0 10 00
	00		 cmp	 edi, DWORD PTR [ebp+4256]
  000a0	0f 8d 59 01 00
	00		 jge	 $L291491
  000a6	8b 95 14 11 00
	00		 mov	 edx, DWORD PTR [ebp+4372]

; 3579 : 			break;
; 3580 : 		
; 3581 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  000ac	8b 0c fa	 mov	 ecx, DWORD PTR [edx+edi*8]
  000af	8d 04 fa	 lea	 eax, DWORD PTR [edx+edi*8]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 3582 : #ifdef __S_BUG_GC
; 3583 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  000b5	51		 push	 ecx
  000b6	8b cd		 mov	 ecx, ebp
  000b8	89 44 24 20	 mov	 DWORD PTR _RequestGuild$270141[esp+40], eax
  000bc	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  000c1	8b d8		 mov	 ebx, eax

; 3584 : 		if( pGCMember != NULL )

  000c3	85 db		 test	 ebx, ebx

; 3585 : 		{
; 3586 : 			__JOINPLAYER* pJoinPlayer1;
; 3587 : 
; 3588 : 			ar << pGCMember->m_uidDefender;

  000c5	8b ce		 mov	 ecx, esi
  000c7	0f 84 f2 00 00
	00		 je	 $L270143
  000cd	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  000d0	6a 04		 push	 4
  000d2	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000d7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000da	89 39		 mov	 DWORD PTR [ecx], edi
  000dc	83 46 08 04	 add	 DWORD PTR [esi+8], 4

; 3589 : 			ar << (int)pGCMember->vecGCSelectMember.size();

  000e0	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000e3	85 c0		 test	 eax, eax
  000e5	75 04		 jne	 SHORT $L291297
  000e7	33 ff		 xor	 edi, edi
  000e9	eb 08		 jmp	 SHORT $L291298
$L291297:
  000eb	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  000ee	2b f8		 sub	 edi, eax
  000f0	c1 ff 02	 sar	 edi, 2
$L291298:
  000f3	6a 04		 push	 4
  000f5	8b ce		 mov	 ecx, esi
  000f7	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  000fc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ff	89 3a		 mov	 DWORD PTR [edx], edi
  00101	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00104	83 c0 04	 add	 eax, 4

; 3590 : 			for( int vecSi = 0 ; vecSi < (int)( pGCMember->vecGCSelectMember.size() ) ; ++vecSi )

  00107	33 d2		 xor	 edx, edx
  00109	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0010c	89 54 24 24	 mov	 DWORD PTR _vecSi$270146[esp+28], edx
$L270148:
  00110	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00113	85 c9		 test	 ecx, ecx
  00115	75 04		 jne	 SHORT $L291314
  00117	33 c0		 xor	 eax, eax
  00119	eb 08		 jmp	 SHORT $L291315
$L291314:
  0011b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0011e	2b c1		 sub	 eax, ecx
  00120	c1 f8 02	 sar	 eax, 2
$L291315:
  00123	3b d0		 cmp	 edx, eax
  00125	0f 8d ca 00 00
	00		 jge	 $L291494
  0012b	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 3591 : 			{
; 3592 : 				pJoinPlayer1 = pGCMember->vecGCSelectMember[vecSi];

  0012e	8b 3c 90	 mov	 edi, DWORD PTR [eax+edx*4]

; 3593 : 
; 3594 : 				ar << pJoinPlayer1->uidPlayer;

  00131	8b 2f		 mov	 ebp, DWORD PTR [edi]
  00133	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00136	6a 04		 push	 4
  00138	8b ce		 mov	 ecx, esi
  0013a	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0013f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00142	89 29		 mov	 DWORD PTR [ecx], ebp
  00144	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00147	bd 04 00 00 00	 mov	 ebp, 4
  0014c	03 cd		 add	 ecx, ebp
  0014e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 3595 : 				if( 0 < pJoinPlayer1->nlife )

  00151	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00154	85 c0		 test	 eax, eax
  00156	7e 3a		 jle	 SHORT $L270151

; 3596 : 				{
; 3597 : 					BOOL bFind	= FALSE;
; 3598 : 					for( list<__JOINPLAYER*>::iterator i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )

  00158	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  0015b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015d	3b c1		 cmp	 eax, ecx
  0015f	74 0b		 je	 SHORT $L270161
$L291407:

; 3599 : 					{
; 3600 : 						if( pJoinPlayer1 == *i1 )

  00161	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  00164	74 19		 je	 SHORT $L291490
  00166	8b 00		 mov	 eax, DWORD PTR [eax]
  00168	3b c1		 cmp	 eax, ecx
  0016a	75 f5		 jne	 SHORT $L291407
$L270161:

; 3612 : 					{
; 3613 : 						ar << (int)1;

  0016c	55		 push	 ebp
  0016d	8b ce		 mov	 ecx, esi
  0016f	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00174	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00177	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 3614 : 					}
; 3615 : 				}
; 3616 : 				else // 

  0017d	eb 24		 jmp	 SHORT $L291496
$L291490:

; 3601 : 						{
; 3602 : 							bFind	= TRUE;
; 3603 : 							break;
; 3604 : 						}
; 3605 : 					}
; 3606 : 				
; 3607 : 					if( bFind )	// 
; 3608 : 					{
; 3609 : 						ar << (int)0;

  0017f	55		 push	 ebp
  00180	8b ce		 mov	 ecx, esi
  00182	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  00187	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0018a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 3610 : 					}
; 3611 : 					else // 

  00190	eb 11		 jmp	 SHORT $L291496
$L270151:

; 3617 : 				{
; 3618 : 					ar << (int)0;

  00192	55		 push	 ebp
  00193	8b ce		 mov	 ecx, esi
  00195	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  0019a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0019d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L291496:
  001a3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001a6	03 c5		 add	 eax, ebp
  001a8	8b 6c 24 14	 mov	 ebp, DWORD PTR _this$[esp+32]
  001ac	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001af	8b 44 24 24	 mov	 eax, DWORD PTR _vecSi$270146[esp+28]
  001b3	40		 inc	 eax
  001b4	89 44 24 24	 mov	 DWORD PTR _vecSi$270146[esp+28], eax
  001b8	8b d0		 mov	 edx, eax
  001ba	e9 51 ff ff ff	 jmp	 $L270148
$L270143:

; 3619 : 				}
; 3620 : 			}
; 3621 : 		}
; 3622 : #else // __S_BUG_GC
; 3623 : 		map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 3624 : 		if( it != m_GuildCombatMem.end() )
; 3625 : 		{
; 3626 : 			__GuildCombatMember* pGCMember = it->second;
; 3627 : 			__JOINPLAYER* pJoinPlayer1;
; 3628 : 
; 3629 : 			ar << pGCMember->m_uidDefender;
; 3630 : 			ar << (int)pGCMember->vecGCSelectMember.size();
; 3631 : 			for( int vecSi = 0 ; vecSi < pGCMember->vecGCSelectMember.size() ; ++vecSi )
; 3632 : 			{
; 3633 : 				pJoinPlayer1 = pGCMember->vecGCSelectMember[vecSi];
; 3634 : 
; 3635 : 				ar << pJoinPlayer1->uidPlayer;
; 3636 : 				if( 0 < pJoinPlayer1->nlife )
; 3637 : 				{
; 3638 : 					BOOL bFind	= FALSE;
; 3639 : 					for( list<__JOINPLAYER*>::iterator i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )
; 3640 : 					{
; 3641 : 						if( pJoinPlayer1 == *i1 )
; 3642 : 						{
; 3643 : 							bFind	= TRUE;
; 3644 : 							break;
; 3645 : 						}
; 3646 : 					}
; 3647 : 				
; 3648 : 					if( bFind )	// 
; 3649 : 					{
; 3650 : 						ar << (int)0;
; 3651 : 					}
; 3652 : 					else // 
; 3653 : 					{
; 3654 : 						ar << (int)1;
; 3655 : 					}
; 3656 : 				}
; 3657 : 				else // 
; 3658 : 				{
; 3659 : 					ar << (int)0;
; 3660 : 				}
; 3661 : 			}
; 3662 : 		}
; 3663 : #endif // __S_BUG_GC
; 3664 : 		else
; 3665 : 		{
; 3666 : 			ar << (u_long)0;

  001bf	bb 04 00 00 00	 mov	 ebx, 4
  001c4	53		 push	 ebx
  001c5	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001ca	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001cd	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  001d3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001d6	03 d3		 add	 edx, ebx

; 3667 : 			ar << (int)0;

  001d8	53		 push	 ebx
  001d9	8b ce		 mov	 ecx, esi
  001db	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001de	e8 00 00 00 00	 call	 ?CheckBuf@CAr@@QAEXI@Z	; CAr::CheckBuf
  001e3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001e6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001ec	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  001ef	47		 inc	 edi
  001f0	e9 80 fe ff ff	 jmp	 $L291497
$L291494:
  001f5	8b 7c 24 10	 mov	 edi, DWORD PTR _nVeci$270135[esp+32]
  001f9	47		 inc	 edi
  001fa	e9 76 fe ff ff	 jmp	 $L291497
$L291491:
  001ff	5f		 pop	 edi
  00200	5e		 pop	 esi
  00201	5d		 pop	 ebp
  00202	5b		 pop	 ebx

; 3668 : 		}
; 3669 : 	}
; 3670 : }

  00203	83 c4 10	 add	 esp, 16			; 00000010H
  00206	c2 04 00	 ret	 4
?SerializeGCWarPlayerList@CGuildCombat@@QAEXAAVCAr@@@Z ENDP ; CGuildCombat::SerializeGCWarPlayerList
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
$T291504 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00001	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	53		 push	 ebx
  00008	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000b	84 db		 test	 bl, bl
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Keyval$[esp+12]
  00013	75 17		 jne	 SHORT $L291581
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$L291580:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $L291582
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $L291583
$L291582:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$L291583:
  00025	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00028	84 db		 test	 bl, bl
  0002a	74 eb		 je	 SHORT $L291580
$L291581:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	3b d0		 cmp	 edx, eax
  00031	89 54 24 18	 mov	 DWORD PTR __Where$[esp+12], edx
  00035	74 1a		 je	 SHORT $L291503
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003c	72 13		 jb	 SHORT $L291503
  0003e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$[esp+12]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 10		 mov	 DWORD PTR [eax], edx
  0004c	5b		 pop	 ebx

; 791  : 		}

  0004d	59		 pop	 ecx
  0004e	c2 08 00	 ret	 8
$L291503:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  00051	89 44 24 0c	 mov	 DWORD PTR $T291504[esp+16], eax
  00055	8d 44 24 0c	 lea	 eax, DWORD PTR $T291504[esp+16]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	89 10		 mov	 DWORD PTR [eax], edx
  00063	5b		 pop	 ebx

; 791  : 		}

  00064	59		 pop	 ecx
  00065	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find
_TEXT	ENDS
PUBLIC	??1?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L291674
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L291674:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L291688
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L291688:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
_TEXT	ENDS
PUBLIC	??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 281  : 		}

  00012	8b c6		 mov	 eax, esi
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??0?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::~vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::~vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L291768
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L291768:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::~vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L291782
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L291782:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::clear
_TEXT	ENDS
PUBLIC	?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV, COMDAT
; _this$ = ecx

; 1855 : 	{

  00000	53		 push	 ebx

; 1856 : 		ATLASSERT( AtlIsValidString( pszFormat ) );
; 1857 : 		if(pszFormat == NULL)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _pszFormat$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	75 0a		 jne	 SHORT $L272467

; 1858 : 			AtlThrow(E_INVALIDARG);

  0000c	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00011	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L291847:
$L272467:
  00016	55		 push	 ebp

; 1859 : 
; 1860 : 		int nLength = StringTraits::GetFormattedLength( pszFormat, args );

  00017	8b 6c 24 14	 mov	 ebp, DWORD PTR _args$[esp+8]
  0001b	56		 push	 esi
  0001c	55		 push	 ebp
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 __vscprintf
  00023	8b f0		 mov	 esi, eax

; 1861 : 		PXSTR pszBuffer = GetBuffer( nLength );

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
  00027	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002a	83 e8 10	 sub	 eax, 16			; 00000010H
  0002d	b9 01 00 00 00	 mov	 ecx, 1
  00032	2b ca		 sub	 ecx, edx
  00034	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00037	2b d6		 sub	 edx, esi
  00039	83 c4 08	 add	 esp, 8
  0003c	0b ca		 or	 ecx, edx
  0003e	7d 08		 jge	 SHORT $L291810
  00040	56		 push	 esi
  00041	8b cf		 mov	 ecx, edi
  00043	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L291810:

; 1862 : 		StringTraits::Format( pszBuffer, pszFormat, args );

  00048	8b 07		 mov	 eax, DWORD PTR [edi]
  0004a	55		 push	 ebp
  0004b	53		 push	 ebx
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _vsprintf
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1863 : 		ReleaseBufferSetLength( nLength );

  00055	85 f6		 test	 esi, esi
  00057	7c 17		 jl	 SHORT $L291838
  00059	8b 07		 mov	 eax, DWORD PTR [edi]
  0005b	3b 70 f8	 cmp	 esi, DWORD PTR [eax-8]
  0005e	7f 10		 jg	 SHORT $L291838
  00060	89 70 f4	 mov	 DWORD PTR [eax-12], esi
  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	c6 04 0e 00	 mov	 BYTE PTR [esi+ecx], 0
  00069	5e		 pop	 esi
  0006a	5d		 pop	 ebp
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx

; 1864 : 	}

  0006d	c2 08 00	 ret	 8
$L291838:
  00070	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00075	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L291848:
$L291846:
  0007a	cc		 int	 3
?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >, COMDAT
; _this$ = ecx

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 363  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Ufill
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Ufill@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$291982 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU34@IABU34@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$291982[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >

; 879  : 		return (_Ptr + _Count);

  0001c	8d 14 f6	 lea	 edx, DWORD PTR [esi+esi*8]
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	8d 04 97	 lea	 eax, DWORD PTR [edi+edx*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU34@IABU34@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$291998 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU34@IABU34@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$291998[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 879  : 		return (_Ptr + _Count);

  0001c	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	8d 04 97	 lea	 eax, DWORD PTR [edi+edx*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU34@IABU34@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$292014 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU34@IABU34@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$292014[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >

; 879  : 		return (_Ptr + _Count);

  0001c	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	8d 04 97	 lea	 eax, DWORD PTR [edi+edx*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU34@IABU34@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__REQUESTGUILD@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L292025

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L292025:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$292040 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU34@IABU34@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$292040[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
  0001c	83 c4 14	 add	 esp, 20			; 00000014H

; 879  : 		return (_Ptr + _Count);

  0001f	8d 04 f7	 lea	 eax, DWORD PTR [edi+esi*8]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 880  : 		}

  00024	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU34@IABU34@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU34@IABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$292058 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU34@IABU34@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$292058[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >

; 879  : 		return (_Ptr + _Count);

  0001c	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	8d 04 d7	 lea	 eax, DWORD PTR [edi+edx*8]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU34@IABU34@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCGETPOINT@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCGETPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCGETPOINT@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCGETPOINT@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCPLAYERPOINT@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCPLAYERPOINT@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCPLAYERPOINT@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXPAU__GCPLAYERPOINT@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXPAU__GCSENDITEM@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXPAU__GCSENDITEM@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXPAU__GCSENDITEM@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXPAU__GCSENDITEM@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEGUILD@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__GCRESULTVALUEPLAYER@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Destroy
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L292135
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L292135:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 27   : 		return (_Str.c_str());

  00000	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L292168
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  00009	c3		 ret	 0

; 27   : 		return (_Str.c_str());

$L292168:
  0000a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  0000d	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L292176
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L292176:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__JOINPLAYER@CGuildCombat@@0@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Destroy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Destroy@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__JOINPLAYER@CGuildCombat@@0@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAU__JOINPLAYER@CGuildCombat@@0@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z ; std::_Construct<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T292230 DD	0ffffffffH
	DD	FLAT:$L292187
$T292228 DD	019930520H
	DD	01H
	DD	FLAT:$T292230
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z
_TEXT	SEGMENT
$T292184 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z PROC NEAR ; std::_Construct<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00017	8b 74 24 18	 mov	 esi, DWORD PTR __Ptr$[esp+16]
  0001b	89 74 24 04	 mov	 DWORD PTR $T292184[esp+20], esi
  0001f	85 f6		 test	 esi, esi
  00021	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 0
  00029	74 17		 je	 SHORT $L292185
  0002b	8b 44 24 1c	 mov	 eax, DWORD PTR __Val$[esp+16]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	83 e8 10	 sub	 eax, 16			; 00000010H
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  0003a	83 c4 04	 add	 esp, 4
  0003d	83 c0 10	 add	 eax, 16			; 00000010H
  00040	89 06		 mov	 DWORD PTR [esi], eax
$L292185:

; 43   : 	}

  00042	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00046	5e		 pop	 esi
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L292187:
  00000	8b 45 04	 mov	 eax, DWORD PTR __Ptr$[ebp-4]
  00003	50		 push	 eax
  00004	8b 4d f0	 mov	 ecx, DWORD PTR $T292184[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T292228
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z ENDP ; std::_Construct<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
PUBLIC	??$_Destroy@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::_Destroy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; std::_Destroy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00004	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
??$_Destroy@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; std::_Destroy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
_TEXT	ENDS
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1969 : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1970 : 		HINSTANCE hInst = StringTraits::FindStringResourceInstance( nID );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nID$[esp+4]
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle

; 1971 : 		if( hInst == NULL )

  0000e	85 c0		 test	 eax, eax
  00010	75 05		 jne	 SHORT $L218601
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi

; 1977 : 	}

  00014	c2 04 00	 ret	 4
$L218601:

; 1972 : 		{
; 1973 : 			return( FALSE );
; 1974 : 		}
; 1975 : 
; 1976 : 		return( LoadString( hInst, nID ) );		

  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1977 : 	}

  00022	c2 04 00	 ret	 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
$T292252 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00001	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	53		 push	 ebx
  00008	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000b	84 db		 test	 bl, bl
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Keyval$[esp+12]
  00013	75 17		 jne	 SHORT $L292328
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$L292327:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $L292329
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $L292330
$L292329:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$L292330:
  00025	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00028	84 db		 test	 bl, bl
  0002a	74 eb		 je	 SHORT $L292327
$L292328:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	3b d0		 cmp	 edx, eax
  00031	89 54 24 18	 mov	 DWORD PTR __Where$[esp+12], edx
  00035	74 1a		 je	 SHORT $L292251
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003c	72 13		 jb	 SHORT $L292251
  0003e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$[esp+12]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 10		 mov	 DWORD PTR [eax], edx
  0004c	5b		 pop	 ebx

; 791  : 		}

  0004d	59		 pop	 ecx
  0004e	c2 08 00	 ret	 8
$L292251:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  00051	89 44 24 0c	 mov	 DWORD PTR $T292252[esp+16], eax
  00055	8d 44 24 0c	 lea	 eax, DWORD PTR $T292252[esp+16]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	89 10		 mov	 DWORD PTR [eax], edx
  00063	5b		 pop	 ebx

; 791  : 		}

  00064	59		 pop	 ecx
  00065	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
_TEXT	ENDS
PUBLIC	?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad, COMDAT
; _this$ = ecx

; 2229 : 	{

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2230 : 		bool bRet = false;
; 2231 : 
; 2232 : 		if( (pv != NULL) && IS_INTRESOURCE( pv ) )

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _pv$[esp]
  00007	32 c0		 xor	 al, al
  00009	85 c9		 test	 ecx, ecx
  0000b	74 22		 je	 SHORT $L219935
  0000d	f7 c1 00 00 ff
	ff		 test	 ecx, -65536		; ffff0000H
  00013	75 1a		 jne	 SHORT $L219935
  00015	56		 push	 esi

; 2233 : 		{
; 2234 : 			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );

  00016	0f b7 f1	 movzx	 esi, cx

; 2235 : 			if( !LoadString( nID ) )

  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle
  0001f	85 c0		 test	 eax, eax
  00021	74 09		 je	 SHORT $L292417
  00023	56		 push	 esi
  00024	50		 push	 eax
  00025	8b cf		 mov	 ecx, edi
  00027	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
$L292417:

; 2236 : 			{
; 2237 : 				ATLTRACE( atlTraceString, 2, _T( "Warning: implicit LoadString(%u) failed\n" ), nID );
; 2238 : 			}
; 2239 : 			bRet = true;

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi
$L219935:
  0002f	5f		 pop	 edi

; 2240 : 		}
; 2241 : 
; 2242 : 		return( bRet );
; 2243 : 	}

  00030	c2 04 00	 ret	 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 274  : 		CStringData* pSrcData = strSrc.GetData();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]

; 275  : 		CStringData* pOldData = GetData();

  0000a	8b 37		 mov	 esi, DWORD PTR [edi]
  0000c	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000f	83 ee 10	 sub	 esi, 16			; 00000010H

; 276  : 		if( pSrcData != pOldData)

  00012	3b c6		 cmp	 eax, esi
  00014	74 4d		 je	 SHORT $L292463

; 277  : 		{
; 278  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )

  00016	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00019	85 d2		 test	 edx, edx
  0001b	53		 push	 ebx
  0001c	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  0001f	55		 push	 ebp
  00020	7c 33		 jl	 SHORT $L219958
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	3b 16		 cmp	 edx, DWORD PTR [esi]
  00026	75 2d		 jne	 SHORT $L219958

; 281  : 			}
; 282  : 			else
; 283  : 			{
; 284  : 				CStringData* pNewData = CloneData( pSrcData );

  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  0002e	8b e8		 mov	 ebp, eax
  00030	83 c4 04	 add	 esp, 4

; 285  : 				pOldData->Release();

  00033	83 c8 ff	 or	 eax, -1
  00036	f0 0f c1 03	 lock	  xadd	 DWORD PTR [ebx], eax
  0003a	48		 dec	 eax
  0003b	85 c0		 test	 eax, eax
  0003d	7f 08		 jg	 SHORT $L292454
  0003f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	56		 push	 esi
  00044	ff 52 04	 call	 DWORD PTR [edx+4]
$L292454:

; 286  : 				Attach( pNewData );

  00047	83 c5 10	 add	 ebp, 16			; 00000010H
  0004a	89 2f		 mov	 DWORD PTR [edi], ebp
  0004c	5d		 pop	 ebp
  0004d	5b		 pop	 ebx

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

  0004e	8b c7		 mov	 eax, edi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 291  : 	}

  00052	c2 04 00	 ret	 4
$L219958:

; 279  : 			{
; 280  : 				SetString( strSrc.GetString(), strSrc.GetLength() );

  00055	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  00058	50		 push	 eax
  00059	51		 push	 ecx
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00061	5d		 pop	 ebp
  00062	5b		 pop	 ebx
$L292463:

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

  00063	8b c7		 mov	 eax, edi
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 291  : 	}

  00067	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 591  : 		if (_Right.size() < _Roff)

  00003	8b 74 24 14	 mov	 esi, DWORD PTR __Roff$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 14	 mov	 edi, DWORD PTR __Right$[esp+12]
  0000c	39 77 14	 cmp	 DWORD PTR [edi+20], esi
  0000f	8b d9		 mov	 ebx, ecx
  00011	73 05		 jae	 SHORT $L220001

; 592  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L220001:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 6f 14	 mov	 ebp, DWORD PTR [edi+20]

; 594  : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b ee		 sub	 ebp, esi
  00021	3b c5		 cmp	 eax, ebp
  00023	73 02		 jae	 SHORT $L220003

; 595  : 			_Num = _Count;	// trim _Num to size

  00025	8b e8		 mov	 ebp, eax
$L220003:

; 596  : 
; 597  : 		if (this == &_Right)

  00027	3b df		 cmp	 ebx, edi
  00029	75 1f		 jne	 SHORT $L220004

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 ee		 add	 ebp, esi
  0002f	55		 push	 ebp
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00037	56		 push	 esi
  00038	6a 00		 push	 0
  0003a	8b cb		 mov	 ecx, ebx
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00044	8b c3		 mov	 eax, ebx
  00046	5b		 pop	 ebx

; 605  : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$L220004:

; 599  : 		else if (_Grow(_Num))

  0004a	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  0004d	76 07		 jbe	 SHORT $L292575
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L292575:
  00056	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00059	3b c5		 cmp	 eax, ebp
  0005b	73 21		 jae	 SHORT $L292576
  0005d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00060	50		 push	 eax
  00061	55		 push	 ebp
  00062	8b cb		 mov	 ecx, ebx
  00064	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00069	85 ed		 test	 ebp, ebp
$L292663:
  0006b	76 6d		 jbe	 SHORT $L292662

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0006d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00070	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00075	3b c8		 cmp	 ecx, eax
  00077	72 2f		 jb	 SHORT $L292627
  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	eb 2d		 jmp	 SHORT $L292628

; 599  : 		else if (_Grow(_Num))

$L292576:
  0007e	85 ed		 test	 ebp, ebp
  00080	75 e9		 jne	 SHORT $L292663
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00088	72 0f		 jb	 SHORT $L292619
  0008a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00093	8b c3		 mov	 eax, ebx
  00095	5b		 pop	 ebx

; 605  : 		}

  00096	c2 0c 00	 ret	 12			; 0000000cH

; 599  : 		else if (_Grow(_Num))

$L292619:
  00099	5f		 pop	 edi
  0009a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009d	5e		 pop	 esi
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a1	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000a2	8b c3		 mov	 eax, ebx
  000a4	5b		 pop	 ebx

; 605  : 		}

  000a5	c2 0c 00	 ret	 12			; 0000000cH

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$L292627:
  000a8	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
$L292628:
  000ab	39 43 18	 cmp	 DWORD PTR [ebx+24], eax
  000ae	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000b1	72 04		 jb	 SHORT $L292635
  000b3	8b 38		 mov	 edi, DWORD PTR [eax]
  000b5	eb 02		 jmp	 SHORT $L292636
$L292635:
  000b7	8b f8		 mov	 edi, eax
$L292636:
  000b9	03 f2		 add	 esi, edx
  000bb	8b cd		 mov	 ecx, ebp
  000bd	8b d1		 mov	 edx, ecx
  000bf	c1 e9 02	 shr	 ecx, 2
  000c2	f3 a5		 rep movsd
  000c4	8b ca		 mov	 ecx, edx
  000c6	83 e1 03	 and	 ecx, 3
  000c9	f3 a4		 rep movsb

; 602  : 			_Eos(_Num);

  000cb	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000cf	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000d2	72 02		 jb	 SHORT $L292659
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
$L292659:
  000d6	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L292662:
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000dd	8b c3		 mov	 eax, ebx
  000df	5b		 pop	 ebx

; 605  : 		}

  000e0	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 579  : 	{

  00000	56		 push	 esi

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pszSrc$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 0d		 jne	 SHORT $L292670
  00009	33 c0		 xor	 eax, eax
  0000b	50		 push	 eax
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00012	5e		 pop	 esi

; 581  : 	}

  00013	c2 04 00	 ret	 4

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

$L292670:
  00016	8b c6		 mov	 eax, esi
  00018	57		 push	 edi
  00019	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001c	8d 64 24 00	 npad	 4
$L292672:
  00020	8a 10		 mov	 dl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 d2		 test	 dl, dl
  00025	75 f9		 jne	 SHORT $L292672
  00027	2b c7		 sub	 eax, edi
  00029	5f		 pop	 edi
  0002a	50		 push	 eax
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00031	5e		 pop	 esi

; 581  : 	}

  00032	c2 04 00	 ret	 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 609  : 		if (_Inside(_Ptr))

  00003	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	72 05		 jb	 SHORT $L292698
  0000d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00010	eb 03		 jmp	 SHORT $L292699
$L292698:
  00012	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$L292699:
  00015	8b 74 24 10	 mov	 esi, DWORD PTR __Ptr$[esp+8]
  00019	3b f0		 cmp	 esi, eax
  0001b	72 34		 jb	 SHORT $L221367
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00023	72 04		 jb	 SHORT $L292702
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $L292703
$L292702:
  00029	8b c8		 mov	 ecx, eax
$L292703:
  0002b	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  0002e	03 f9		 add	 edi, ecx
  00030	3b fe		 cmp	 edi, esi
  00032	76 1d		 jbe	 SHORT $L221367

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  00034	83 fa 10	 cmp	 edx, 16			; 00000010H
  00037	72 02		 jb	 SHORT $L292711
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$L292711:
  0003b	8b 4c 24 14	 mov	 ecx, DWORD PTR __Num$[esp+8]
  0003f	51		 push	 ecx
  00040	2b f0		 sub	 esi, eax
  00042	56		 push	 esi
  00043	53		 push	 ebx
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 618  : 		}

  0004e	c2 08 00	 ret	 8
$L221367:
  00051	55		 push	 ebp

; 611  : 
; 612  : 		if (_Grow(_Num))

  00052	8b 6c 24 18	 mov	 ebp, DWORD PTR __Num$[esp+12]
  00056	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  00059	76 07		 jbe	 SHORT $L292809
  0005b	8b cb		 mov	 ecx, ebx
  0005d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L292809:
  00062	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00065	3b c5		 cmp	 eax, ebp
  00067	73 1b		 jae	 SHORT $L292810
  00069	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  0006c	52		 push	 edx
  0006d	55		 push	 ebp
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00075	85 ed		 test	 ebp, ebp
$L292890:
  00077	76 68		 jbe	 SHORT $L292886

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00079	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0007d	72 2f		 jb	 SHORT $L292862
  0007f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00082	eb 2d		 jmp	 SHORT $L292863

; 611  : 
; 612  : 		if (_Grow(_Num))

$L292810:
  00084	85 ed		 test	 ebp, ebp
  00086	75 ef		 jne	 SHORT $L292890
  00088	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008b	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  0008e	72 0f		 jb	 SHORT $L292853
  00090	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00093	5d		 pop	 ebp
  00094	5f		 pop	 edi
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0
  00098	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  00099	8b c3		 mov	 eax, ebx
  0009b	5b		 pop	 ebx

; 618  : 		}

  0009c	c2 08 00	 ret	 8

; 611  : 
; 612  : 		if (_Grow(_Num))

$L292853:
  0009f	5d		 pop	 ebp
  000a0	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000a3	5f		 pop	 edi
  000a4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a7	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx

; 618  : 		}

  000ab	c2 08 00	 ret	 8

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

$L292862:
  000ae	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
$L292863:
  000b1	8b cd		 mov	 ecx, ebp
  000b3	8b c1		 mov	 eax, ecx
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb

; 615  : 			_Eos(_Num);

  000c1	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000c5	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000c8	72 10		 jb	 SHORT $L292883
  000ca	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000cd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  000d1	5d		 pop	 ebp
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000d4	8b c3		 mov	 eax, ebx
  000d6	5b		 pop	 ebx

; 618  : 		}

  000d7	c2 08 00	 ret	 8

; 615  : 			_Eos(_Num);

$L292883:
  000da	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000dd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L292886:
  000e1	5d		 pop	 ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000e4	8b c3		 mov	 eax, ebx
  000e6	5b		 pop	 ebx

; 618  : 		}

  000e7	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ ; CGuildCombat::__GuildCombatMember::SelectMemberClear
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.h
;	COMDAT ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ PROC NEAR ; CGuildCombat::__GuildCombatMember::SelectMemberClear, COMDAT
; _this$ = ecx

; 144  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 145  : 			for( int veci = 0 ; veci < (int)( vecGCSelectMember.size() ) ; ++veci )

  00003	33 db		 xor	 ebx, ebx
  00005	8b f1		 mov	 esi, ecx
  00007	33 ff		 xor	 edi, edi
  00009	8d a4 24 00 00
	00 00		 npad	 7
$L231152:
  00010	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00013	3b cb		 cmp	 ecx, ebx
  00015	75 04		 jne	 SHORT $L292899
  00017	33 c0		 xor	 eax, eax
  00019	eb 08		 jmp	 SHORT $L292900
$L292899:
  0001b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001e	2b c1		 sub	 eax, ecx
  00020	c1 f8 02	 sar	 eax, 2
$L292900:
  00023	3b f8		 cmp	 edi, eax
  00025	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00028	7d 15		 jge	 SHORT $L231154
  0002a	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]

; 146  : 			{
; 147  : 				__JOINPLAYER* pJoinPlayer = vecGCSelectMember[veci];

  0002d	8b 00		 mov	 eax, DWORD PTR [eax]

; 148  : 				SAFE_DELETE( pJoinPlayer );

  0002f	3b c3		 cmp	 eax, ebx
  00031	74 09		 je	 SHORT $L231153
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$L231153:

; 145  : 			for( int veci = 0 ; veci < (int)( vecGCSelectMember.size() ) ; ++veci )

  0003c	47		 inc	 edi
  0003d	eb d1		 jmp	 SHORT $L231152
$L231154:

; 149  : 			}
; 150  : 			vecGCSelectMember.clear();

  0003f	3b c3		 cmp	 eax, ebx
  00041	74 09		 je	 SHORT $L292973
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00049	83 c4 04	 add	 esp, 4
$L292973:
  0004c	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0004f	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00052	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 151  : 			lspFifo.clear();

  00055	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00058	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005a	89 09		 mov	 DWORD PTR [ecx], ecx
  0005c	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0005f	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00062	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  00065	89 5e 34	 mov	 DWORD PTR [esi+52], ebx
  00068	74 1a		 je	 SHORT $L293012
  0006a	8d 9b 00 00 00
	00		 npad	 6
$L293010:
  00070	8b 38		 mov	 edi, DWORD PTR [eax]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00078	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0007b	83 c4 04	 add	 esp, 4
  0007e	3b f9		 cmp	 edi, ecx
  00080	8b c7		 mov	 eax, edi
  00082	75 ec		 jne	 SHORT $L293010
$L293012:
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 152  : 		}

  00087	c3		 ret	 0
?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ ENDP ; CGuildCombat::__GuildCombatMember::SelectMemberClear
_TEXT	ENDS
PUBLIC	??1__GuildCombatMember@CGuildCombat@@QAE@XZ	; CGuildCombat::__GuildCombatMember::~__GuildCombatMember
; Function compile flags: /Ogty
;	COMDAT ??1__GuildCombatMember@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT
??1__GuildCombatMember@CGuildCombat@@QAE@XZ PROC NEAR	; CGuildCombat::__GuildCombatMember::~__GuildCombatMember, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi
  00005	8d 7e 2c	 lea	 edi, DWORD PTR [esi+44]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::clear
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	33 db		 xor	 ebx, ebx
  0001a	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	83 c4 04	 add	 esp, 4
  00023	3b c3		 cmp	 eax, ebx
  00025	74 09		 je	 SHORT $L293069
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
$L293069:
  00030	5f		 pop	 edi
  00031	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00034	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00037	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	c3		 ret	 0
??1__GuildCombatMember@CGuildCombat@@QAE@XZ ENDP	; CGuildCombat::__GuildCombatMember::~__GuildCombatMember
_TEXT	ENDS
PUBLIC	?SelectPlayerClear@CGuildCombat@@QAEXK@Z	; CGuildCombat::SelectPlayerClear
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ?SelectPlayerClear@CGuildCombat@@QAEXK@Z
_TEXT	SEGMENT
_uidGuild$ = 8						; size = 4
?SelectPlayerClear@CGuildCombat@@QAEXK@Z PROC NEAR	; CGuildCombat::SelectPlayerClear, COMDAT
; _this$ = ecx

; 414  : #ifdef __S_BUG_GC
; 415  : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( uidGuild );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _uidGuild$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 416  : 	if( pGCMember != NULL )

  0000a	85 c0		 test	 eax, eax
  0000c	74 07		 je	 SHORT $L268377

; 417  : 		pGCMember->SelectMemberClear();

  0000e	8b c8		 mov	 ecx, eax
  00010	e8 00 00 00 00	 call	 ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ ; CGuildCombat::__GuildCombatMember::SelectMemberClear
$L268377:

; 418  : #else // __S_BUG_GC
; 419  : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( uidGuild );
; 420  : 	if( it != m_GuildCombatMem.end() )
; 421  : 	{
; 422  : 		__GuildCombatMember* pGCMember = it->second;
; 423  : 		pGCMember->SelectMemberClear();
; 424  : 	}	
; 425  : #endif // __S_BUG_GC
; 426  : }

  00015	c2 04 00	 ret	 4
?SelectPlayerClear@CGuildCombat@@QAEXK@Z ENDP		; CGuildCombat::SelectPlayerClear
_TEXT	ENDS
PUBLIC	?JoinObserver@CGuildCombat@@QAEXPAVCUser@@@Z	; CGuildCombat::JoinObserver
EXTRN	?AddDiagText@CUser@@QAEXPBD@Z:NEAR		; CUser::AddDiagText
EXTRN	?RemoveCommonBuffs@CMover@@QAEXXZ:NEAR		; CMover::RemoveCommonBuffs
EXTRN	?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z:NEAR ; CUserMng::AddRemoveAllSkillInfluence
EXTRN	?IsBaseJob@CMover@@QAEHXZ:NEAR			; CMover::IsBaseJob
EXTRN	?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z:NEAR ; CUserMng::AddGCGuildStatus
EXTRN	?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z:NEAR ; CUserMng::AddGCGuildPrecedence
EXTRN	?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z:NEAR ; CUserMng::AddGCPlayerPrecedence
EXTRN	?AddGCWarPlayerlist@CUser@@QAEXXZ:NEAR		; CUser::AddGCWarPlayerlist
EXTRN	?SendGCRemoveParty@CDPCoreClient@@QAEXKK@Z:NEAR	; CDPCoreClient::SendGCRemoveParty
; Function compile flags: /Ogty
;	COMDAT ?JoinObserver@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
$T293080 = -12						; size = 12
_pUser$ = 8						; size = 4
?JoinObserver@CGuildCombat@@QAEXPAVCUser@@@Z PROC NEAR	; CGuildCombat::JoinObserver, COMDAT
; _this$ = ecx

; 700  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi

; 701  : 	if( pUser->IsBaseJob() )

  00004	8b 74 24 14	 mov	 esi, DWORD PTR _pUser$[esp+12]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ?IsBaseJob@CMover@@QAEHXZ ; CMover::IsBaseJob
  00012	85 c0		 test	 eax, eax
  00014	0f 84 97 00 00
	00		 je	 $L268741

; 702  : 	{
; 703  : 		pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_WAR_ENTER) );

  0001a	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0001f	3d 98 0b 00 00	 cmp	 eax, 2968		; 00000b98H
  00024	7e 5c		 jle	 SHORT $L293125
  00026	76 10		 jbe	 SHORT $L293232
  00028	8b 15 b8 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+696
  0002e	8b 8a 60 2e 00
	00		 mov	 ecx, DWORD PTR [edx+11872]
  00034	85 c9		 test	 ecx, ecx
  00036	75 15		 jne	 SHORT $L293126
$L293232:
  00038	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0003d	50		 push	 eax
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 814  : }

  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	c2 04 00	 ret	 4

; 702  : 	{
; 703  : 		pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_WAR_ENTER) );

$L293126:
  0004d	3d 98 0b 00 00	 cmp	 eax, 2968		; 00000b98H
  00052	77 15		 ja	 SHORT $L293118
  00054	33 c0		 xor	 eax, eax
  00056	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00059	50		 push	 eax
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 814  : }

  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	c2 04 00	 ret	 4

; 702  : 	{
; 703  : 		pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_WAR_ENTER) );

$L293118:
  00069	8b 82 60 2e 00
	00		 mov	 eax, DWORD PTR [edx+11872]
  0006f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00072	50		 push	 eax
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 814  : }

  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	c2 04 00	 ret	 4

; 702  : 	{
; 703  : 		pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_WAR_ENTER) );

$L293125:
  00082	68 98 0b 00 00	 push	 2968			; 00000b98H
  00087	50		 push	 eax
  00088	6a 00		 push	 0
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00094	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  000a1	50		 push	 eax
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi

; 814  : }

  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	c2 04 00	 ret	 4
$L268741:

; 704  : 		return;
; 705  : 	}
; 706  : 	
; 707  : 	//  
; 708  : 	pUser->RemoveCommonBuffs();

  000b1	8b ce		 mov	 ecx, esi
  000b3	e8 00 00 00 00	 call	 ?RemoveCommonBuffs@CMover@@QAEXXZ ; CMover::RemoveCommonBuffs

; 709  : 	g_UserMng.AddRemoveAllSkillInfluence( pUser );

  000b8	56		 push	 esi
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000be	e8 00 00 00 00	 call	 ?AddRemoveAllSkillInfluence@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddRemoveAllSkillInfluence

; 710  : 	((CMover*)pUser)->REPLACE( g_uIdofMulti, WI_WORLD_GUILDWAR, D3DXVECTOR3( 1361.6f, 0.0f, 1273.3f ), REPLACE_NORMAL, nDefaultLayer );

  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  000c9	6a 00		 push	 0
  000cb	6a 00		 push	 0
  000cd	8d 44 24 10	 lea	 eax, DWORD PTR $T293080[esp+28]
  000d1	50		 push	 eax
  000d2	68 ca 00 00 00	 push	 202			; 000000caH
  000d7	51		 push	 ecx
  000d8	8b ce		 mov	 ecx, esi
  000da	c7 44 24 1c 33
	33 aa 44	 mov	 DWORD PTR $T293080[esp+40], 1152004915 ; 44aa3333H
  000e2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T293080[esp+44], 0
  000ea	c7 44 24 24 9a
	29 9f 44	 mov	 DWORD PTR $T293080[esp+48], 1151281562 ; 449f299aH
  000f2	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 711  : 	pUser->m_vtInfo.SetOther( NULL );

  000f7	6a 00		 push	 0
  000f9	8d 8e 7c 0d 00
	00		 lea	 ecx, DWORD PTR [esi+3452]
  000ff	e8 00 00 00 00	 call	 ?SetOther@CVTInfo@@QAEXPAVCMover@@@Z ; CVTInfo::SetOther

; 712  : 	//   .
; 713  : 	pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_WELCOME) );

  00104	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00109	3d 91 0a 00 00	 cmp	 eax, 2705		; 00000a91H
  0010e	7e 32		 jle	 SHORT $L293176
  00110	76 10		 jbe	 SHORT $L293233
  00112	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  00118	8b 91 44 2a 00
	00		 mov	 edx, DWORD PTR [ecx+10820]
  0011e	85 d2		 test	 edx, edx
  00120	75 07		 jne	 SHORT $L293177
$L293233:
  00122	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00127	eb 38		 jmp	 SHORT $L293171
$L293177:
  00129	3d 91 0a 00 00	 cmp	 eax, 2705		; 00000a91H
  0012e	77 07		 ja	 SHORT $L293169
  00130	33 c0		 xor	 eax, eax
  00132	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00135	eb 2a		 jmp	 SHORT $L293171
$L293169:
  00137	8b 81 44 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10820]
  0013d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00140	eb 1f		 jmp	 SHORT $L293171
$L293176:
  00142	68 91 0a 00 00	 push	 2705			; 00000a91H
  00147	50		 push	 eax
  00148	6a 00		 push	 0
  0014a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  0014f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00154	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00159	83 c4 14	 add	 esp, 20			; 00000014H
  0015c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L293171:
  00161	50		 push	 eax
  00162	8b ce		 mov	 ecx, esi
  00164	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 714  : 	//   .
; 715  : 	pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_ZOOM_USE) );

  00169	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0016e	3d a6 0a 00 00	 cmp	 eax, 2726		; 00000aa6H
  00173	7e 32		 jle	 SHORT $L293224
  00175	76 10		 jbe	 SHORT $L293234
  00177	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  0017d	8b 91 98 2a 00
	00		 mov	 edx, DWORD PTR [ecx+10904]
  00183	85 d2		 test	 edx, edx
  00185	75 07		 jne	 SHORT $L293225
$L293234:
  00187	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0018c	eb 38		 jmp	 SHORT $L293215
$L293225:
  0018e	3d a6 0a 00 00	 cmp	 eax, 2726		; 00000aa6H
  00193	77 07		 ja	 SHORT $L293221
  00195	33 c0		 xor	 eax, eax
  00197	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019a	eb 2a		 jmp	 SHORT $L293215
$L293221:
  0019c	8b 81 98 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10904]
  001a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a5	eb 1f		 jmp	 SHORT $L293215
$L293224:
  001a7	68 a6 0a 00 00	 push	 2726			; 00000aa6H
  001ac	50		 push	 eax
  001ad	6a 00		 push	 0
  001af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  001b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  001b9	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  001be	83 c4 14	 add	 esp, 20			; 00000014H
  001c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L293215:
  001c6	50		 push	 eax
  001c7	8b ce		 mov	 ecx, esi
  001c9	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 716  : 
; 717  : 	if( m_nGCState <= ENTER_STATE )

  001ce	83 bf 44 11 00
	00 66		 cmp	 DWORD PTR [edi+4420], 102 ; 00000066H
  001d5	7f 07		 jg	 SHORT $L268744

; 718  : 		pUser->AddGCWarPlayerlist();

  001d7	8b ce		 mov	 ecx, esi
  001d9	e8 00 00 00 00	 call	 ?AddGCWarPlayerlist@CUser@@QAEXXZ ; CUser::AddGCWarPlayerlist
$L268744:

; 719  : 
; 720  : 	if( IsSelectPlayer( pUser ) )

  001de	56		 push	 esi
  001df	8b cf		 mov	 ecx, edi
  001e1	e8 00 00 00 00	 call	 ?IsSelectPlayer@CGuildCombat@@QAEHPAVCUser@@@Z ; CGuildCombat::IsSelectPlayer
  001e6	85 c0		 test	 eax, eax
  001e8	74 3d		 je	 SHORT $L268747

; 721  : 	{
; 722  : 		pUser->m_nGuildCombatState		= 2;
; 723  : 		g_UserMng.AddGuildCombatUserState( (CMover*)pUser );

  001ea	56		 push	 esi
  001eb	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  001f0	c7 86 98 0e 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+3736], 2
  001fa	e8 00 00 00 00	 call	 ?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddGuildCombatUserState

; 724  : #if __VER >= 15 // __IMPROVE_SYSTEM_VER15
; 725  : 		if( ENTER_STATE <= m_nGCState && m_nGCState <= WAR_CLOSE_STATE )

  001ff	8b 87 44 11 00
	00		 mov	 eax, DWORD PTR [edi+4420]
  00205	83 f8 66	 cmp	 eax, 102		; 00000066H
  00208	7c 1d		 jl	 SHORT $L268747
  0020a	83 f8 69	 cmp	 eax, 105		; 00000069H
  0020d	7f 18		 jg	 SHORT $L268747

; 726  : 			g_DPCoreClient.SendGCRemoveParty( pUser->GetPartyId(), pUser->m_idPlayer );

  0020f	8b 96 38 02 00
	00		 mov	 edx, DWORD PTR [esi+568]
  00215	8b 86 18 07 00
	00		 mov	 eax, DWORD PTR [esi+1816]
  0021b	52		 push	 edx
  0021c	50		 push	 eax
  0021d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  00222	e8 00 00 00 00	 call	 ?SendGCRemoveParty@CDPCoreClient@@QAEXKK@Z ; CDPCoreClient::SendGCRemoveParty
$L268747:

; 727  : #else // __IMPROVE_SYSTEM_VER15
; 728  : 		//    
; 729  : 		if( m_nGCState == ENTER_STATE )
; 730  : 		{
; 731  : 			g_DPCoreClient.SendGCRemoveParty( pUser->GetPartyId(), pUser->m_idPlayer );
; 732  : 		}
; 733  : 		else if( MAINTENANCE_STATE <= m_nGCState && m_nGCState <= WAR_CLOSE_STATE )
; 734  : 		{
; 735  : #ifdef __S_BUG_GC
; 736  : 			__GuildCombatMember* pGCMember = FindGuildCombatMember( pUser->m_idGuild );
; 737  : 			if( pGCMember != NULL )
; 738  : 			{
; 739  : 				CMover* pLeader = NULL;
; 740  : 				for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 741  : 				{
; 742  : 						__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 743  : 					if( pJoinPlayer->uidPlayer != pUser->m_idPlayer )
; 744  : 					{
; 745  : 						CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );
; 746  : 						if( IsValidObj( pMover ) && pMover->GetWorld() && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )
; 747  : 						{
; 748  : 							if( 0 < pMover->GetPartyId() )
; 749  : 							{
; 750  : 								pLeader = pMover;
; 751  : 								break;
; 752  : 							}
; 753  : 						}
; 754  : 					}
; 755  : 				}
; 756  : 				
; 757  : 				if( pLeader != NULL )
; 758  : 				{
; 759  : 					if( 0 < pUser->GetPartyId() )
; 760  : 					{
; 761  : 						if( pUser->GetPartyId() != pLeader->GetPartyId() )
; 762  : 							g_DPCoreClient.SendGCRemoveParty( pUser->GetPartyId(), pUser->m_idPlayer );
; 763  : 					}
; 764  : 					
; 765  : 					if( pUser->GetPartyId() != pLeader->GetPartyId() )
; 766  : 						g_DPCoreClient.SendGCAddParty( pLeader->m_idPlayer, pLeader->GetLevel(), pLeader->GetJob(), pLeader->GetSex(), 
; 767  : 						pUser->m_idPlayer, pUser->GetLevel(), pUser->GetJob(), pUser->GetSex() );
; 768  : 				}
; 769  : 			}
; 770  : #else // __S_BUG_GC
; 771  : 			map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( pUser->m_idGuild );
; 772  : 			if( ita != m_GuildCombatMem.end() )
; 773  : 			{
; 774  : 				__GuildCombatMember* pGuildCombatMem = ita->second;
; 775  : 				
; 776  : 				CMover* pLeader = NULL;
; 777  : 				for( int veci = 0 ; veci < pGuildCombatMem->vecGCSelectMember.size() ; ++veci )
; 778  : 				{
; 779  : 						__JOINPLAYER* pJoinPlayer = pGuildCombatMem->vecGCSelectMember[veci];
; 780  : 					if( pJoinPlayer->uidPlayer != pUser->m_idPlayer )
; 781  : 					{
; 782  : 						CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );
; 783  : 						if( IsValidObj( pMover ) && pMover->GetWorld() && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )
; 784  : 						{
; 785  : 							if( 0 < pMover->GetPartyId() )
; 786  : 							{
; 787  : 								pLeader = pMover;
; 788  : 								break;
; 789  : 							}
; 790  : 						}
; 791  : 					}
; 792  : 				}
; 793  : 				
; 794  : 				if( pLeader != NULL )
; 795  : 				{
; 796  : 					if( 0 < pUser->GetPartyId() )
; 797  : 					{
; 798  : 						if( pUser->GetPartyId() != pLeader->GetPartyId() )
; 799  : 							g_DPCoreClient.SendGCRemoveParty( pUser->GetPartyId(), pUser->m_idPlayer );
; 800  : 					}
; 801  : 					
; 802  : 					if( pUser->GetPartyId() != pLeader->GetPartyId() )
; 803  : 						g_DPCoreClient.SendGCAddParty( pLeader->m_idPlayer, pLeader->GetLevel(), pLeader->GetJob(), pLeader->GetSex(), 
; 804  : 						pUser->m_idPlayer, pUser->GetLevel(), pUser->GetJob(), pUser->GetSex() );
; 805  : 				}
; 806  : 			}
; 807  : #endif // __S_BUG_GC
; 808  : 		}
; 809  : #endif // __IMPROVE_SYSTEM_VER15
; 810  : 	}
; 811  : 	g_UserMng.AddGCGuildStatus( pUser->m_idGuild, pUser );

  00227	8b 8e 1c 07 00
	00		 mov	 ecx, DWORD PTR [esi+1820]
  0022d	56		 push	 esi
  0022e	51		 push	 ecx
  0022f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00234	e8 00 00 00 00	 call	 ?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z ; CUserMng::AddGCGuildStatus

; 812  : 	g_UserMng.AddGCGuildPrecedence( pUser );

  00239	56		 push	 esi
  0023a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0023f	e8 00 00 00 00	 call	 ?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddGCGuildPrecedence

; 813  : 	g_UserMng.AddGCPlayerPrecedence( pUser );	

  00244	56		 push	 esi
  00245	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0024a	e8 00 00 00 00	 call	 ?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddGCPlayerPrecedence
  0024f	5f		 pop	 edi
  00250	5e		 pop	 esi

; 814  : }

  00251	83 c4 0c	 add	 esp, 12			; 0000000cH
  00254	c2 04 00	 ret	 4
?JoinObserver@CGuildCombat@@QAEXPAVCUser@@@Z ENDP	; CGuildCombat::JoinObserver
_TEXT	ENDS
PUBLIC	?GuildCombatCancel@CGuildCombat@@QAEXPAVCUser@@@Z ; CGuildCombat::GuildCombatCancel
EXTRN	?SendOutGuildCombat@CDPDatabaseClient@@QAEXK@Z:NEAR ; CDPDatabaseClient::SendOutGuildCombat
EXTRN	?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z:NEAR	; CGuildMng::GetGuild
; Function compile flags: /Ogty
;	COMDAT ?GuildCombatCancel@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
?GuildCombatCancel@CGuildCombat@@QAEXPAVCUser@@@Z PROC NEAR ; CGuildCombat::GuildCombatCancel, COMDAT
; _this$ = ecx

; 907  : {

  00000	53		 push	 ebx

; 908  : 	CGuild* pGuild	= g_GuildMng.GetGuild( pUser->m_idGuild );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _pUser$[esp]
  00005	8b 83 1c 07 00
	00		 mov	 eax, DWORD PTR [ebx+1820]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	50		 push	 eax
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00014	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 909  : 	if( pGuild && pGuild->IsMaster( pUser->m_idPlayer ) )

  00019	85 c0		 test	 eax, eax
  0001b	0f 84 f6 00 00
	00		 je	 $L268781
  00021	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00024	3b 8b 38 02 00
	00		 cmp	 ecx, DWORD PTR [ebx+568]
  0002a	0f 85 e7 00 00
	00		 jne	 $L268781
  00030	56		 push	 esi

; 910  : 	{
; 911  : 		//   (  ~  )
; 912  : #ifdef __S_BUG_GC
; 913  : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( pUser->m_idGuild );

  00031	8b b3 1c 07 00
	00		 mov	 esi, DWORD PTR [ebx+1820]
  00037	56		 push	 esi
  00038	8b cf		 mov	 ecx, edi
  0003a	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 914  : 		if( pGCMember != NULL )

  0003f	85 c0		 test	 eax, eax
  00041	74 45		 je	 SHORT $L268783

; 915  : 		{
; 916  : 			if( pGCMember->bRequest )

  00043	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00046	85 c9		 test	 ecx, ecx
  00048	74 37		 je	 SHORT $L268784

; 917  : 			{
; 918  : 				if( m_nState != CGuildCombat::CLOSE_STATE )

  0004a	83 bf 40 11 00
	00 01		 cmp	 DWORD PTR [edi+4416], 1
  00051	74 1d		 je	 SHORT $L268785

; 919  : 				{
; 920  : 					pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_USE));	//      

  00053	68 a0 0a 00 00	 push	 2720			; 00000aa0H
$L293346:
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0005d	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  00062	50		 push	 eax
  00063	8b cb		 mov	 ecx, ebx
  00065	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  0006a	5e		 pop	 esi
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  0006d	c2 04 00	 ret	 4
$L268785:

; 921  : 					return;
; 922  : 				}
; 923  : 				g_dpDBClient.SendOutGuildCombat( pUser->m_idGuild );

  00070	56		 push	 esi
  00071	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00076	e8 00 00 00 00	 call	 ?SendOutGuildCombat@CDPDatabaseClient@@QAEXK@Z ; CDPDatabaseClient::SendOutGuildCombat
  0007b	5e		 pop	 esi
  0007c	5f		 pop	 edi
  0007d	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  0007e	c2 04 00	 ret	 4
$L268784:

; 924  : 			}
; 925  : 			else
; 926  : 			{
; 927  : 				pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOTAPP) );

  00081	68 8d 0a 00 00	 push	 2701			; 00000a8dH

; 928  : 			}
; 929  : 		}
; 930  : #else // __S_BUG_GC
; 931  : 		map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( pUser->m_idGuild );
; 932  : 		if( it != m_GuildCombatMem.end() )
; 933  : 		{
; 934  : 			__GuildCombatMember* pGCMember = it->second;
; 935  : 
; 936  : 			if( pGCMember->bRequest )
; 937  : 			{
; 938  : 				if( m_nState != CGuildCombat::CLOSE_STATE )
; 939  : 				{
; 940  : 					pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_USE));	//      
; 941  : 					return;
; 942  : 				}
; 943  : 				g_dpDBClient.SendOutGuildCombat( pUser->m_idGuild );
; 944  : 			}
; 945  : 			else
; 946  : 			{
; 947  : 				pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOTAPP) );
; 948  : 			}
; 949  : 		}
; 950  : #endif // __S_BUG_GC
; 951  : 		else

  00086	eb d0		 jmp	 SHORT $L293346
$L268783:

; 952  : 		{
; 953  : 			//   .
; 954  : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOTAPP) );

  00088	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0008d	3d 8d 0a 00 00	 cmp	 eax, 2701		; 00000a8dH
  00092	7e 56		 jle	 SHORT $L293277
  00094	76 10		 jbe	 SHORT $L293343
  00096	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  0009c	8b 91 34 2a 00
	00		 mov	 edx, DWORD PTR [ecx+10804]
  000a2	85 d2		 test	 edx, edx
  000a4	75 13		 jne	 SHORT $L293278
$L293343:
  000a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000ab	50		 push	 eax
  000ac	8b cb		 mov	 ecx, ebx
  000ae	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  000b3	5e		 pop	 esi
  000b4	5f		 pop	 edi
  000b5	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  000b6	c2 04 00	 ret	 4

; 952  : 		{
; 953  : 			//   .
; 954  : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOTAPP) );

$L293278:
  000b9	3d 8d 0a 00 00	 cmp	 eax, 2701		; 00000a8dH
  000be	77 13		 ja	 SHORT $L293291
  000c0	33 c0		 xor	 eax, eax
  000c2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c5	50		 push	 eax
  000c6	8b cb		 mov	 ecx, ebx
  000c8	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  000cd	5e		 pop	 esi
  000ce	5f		 pop	 edi
  000cf	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  000d0	c2 04 00	 ret	 4

; 952  : 		{
; 953  : 			//   .
; 954  : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOTAPP) );

$L293291:
  000d3	8b 81 34 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10804]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	50		 push	 eax
  000dd	8b cb		 mov	 ecx, ebx
  000df	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  000e4	5e		 pop	 esi
  000e5	5f		 pop	 edi
  000e6	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  000e7	c2 04 00	 ret	 4

; 952  : 		{
; 953  : 			//   .
; 954  : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOTAPP) );

$L293277:
  000ea	68 8d 0a 00 00	 push	 2701			; 00000a8dH
  000ef	50		 push	 eax
  000f0	6a 00		 push	 0
  000f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  000f7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000fc	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00101	83 c4 14	 add	 esp, 20			; 00000014H
  00104	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  00109	50		 push	 eax
  0010a	8b cb		 mov	 ecx, ebx
  0010c	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  00111	5e		 pop	 esi
  00112	5f		 pop	 edi
  00113	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  00114	c2 04 00	 ret	 4
$L268781:

; 955  : 		}
; 956  : 	}
; 957  : 	else
; 958  : 	{
; 959  : 		//   .
; 960  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_GUILD_LEADER) );

  00117	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0011c	3d 8f 0a 00 00	 cmp	 eax, 2703		; 00000a8fH
  00121	7e 53		 jle	 SHORT $L293325
  00123	76 10		 jbe	 SHORT $L293344
  00125	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  0012b	8b 91 3c 2a 00
	00		 mov	 edx, DWORD PTR [ecx+10812]
  00131	85 d2		 test	 edx, edx
  00133	75 12		 jne	 SHORT $L293326
$L293344:
  00135	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0013a	50		 push	 eax
  0013b	8b cb		 mov	 ecx, ebx
  0013d	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  00142	5f		 pop	 edi
  00143	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  00144	c2 04 00	 ret	 4

; 955  : 		}
; 956  : 	}
; 957  : 	else
; 958  : 	{
; 959  : 		//   .
; 960  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_GUILD_LEADER) );

$L293326:
  00147	3d 8f 0a 00 00	 cmp	 eax, 2703		; 00000a8fH
  0014c	77 12		 ja	 SHORT $L293339
  0014e	33 c0		 xor	 eax, eax
  00150	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00153	50		 push	 eax
  00154	8b cb		 mov	 ecx, ebx
  00156	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  0015b	5f		 pop	 edi
  0015c	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  0015d	c2 04 00	 ret	 4

; 955  : 		}
; 956  : 	}
; 957  : 	else
; 958  : 	{
; 959  : 		//   .
; 960  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_GUILD_LEADER) );

$L293339:
  00160	8b 81 3c 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10812]
  00166	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00169	50		 push	 eax
  0016a	8b cb		 mov	 ecx, ebx
  0016c	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  00171	5f		 pop	 edi
  00172	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  00173	c2 04 00	 ret	 4

; 955  : 		}
; 956  : 	}
; 957  : 	else
; 958  : 	{
; 959  : 		//   .
; 960  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_GUILD_LEADER) );

$L293325:
  00176	68 8f 0a 00 00	 push	 2703			; 00000a8fH
  0017b	50		 push	 eax
  0017c	6a 00		 push	 0
  0017e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00183	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00188	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0018d	83 c4 14	 add	 esp, 20			; 00000014H
  00190	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  00195	50		 push	 eax
  00196	8b cb		 mov	 ecx, ebx
  00198	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  0019d	5f		 pop	 edi
  0019e	5b		 pop	 ebx

; 961  : 	}
; 962  : }

  0019f	c2 04 00	 ret	 4
?GuildCombatCancel@CGuildCombat@@QAEXPAVCUser@@@Z ENDP	; CGuildCombat::GuildCombatCancel
_TEXT	ENDS
PUBLIC	?UserOutGuildCombatResult@CGuildCombat@@QAEXPAVCUser@@@Z ; CGuildCombat::UserOutGuildCombatResult
; Function compile flags: /Ogty
;	COMDAT ?UserOutGuildCombatResult@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_nCount$ = -12						; size = 4
_RequestGuild$268809 = -8				; size = 8
tv290 = 8						; size = 4
_pUser$ = 8						; size = 4
?UserOutGuildCombatResult@CGuildCombat@@QAEXPAVCUser@@@Z PROC NEAR ; CGuildCombat::UserOutGuildCombatResult, COMDAT
; _this$ = ecx

; 965  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 966  : 	int nCount = 0;
; 967  : #ifdef __S_BUG_GC
; 968  : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( pUser->m_idGuild );

  00003	8b 44 24 10	 mov	 eax, DWORD PTR _pUser$[esp+8]
  00007	53		 push	 ebx
  00008	8b 98 1c 07 00
	00		 mov	 ebx, DWORD PTR [eax+1820]
  0000e	55		 push	 ebp
  0000f	33 ed		 xor	 ebp, ebp
  00011	53		 push	 ebx
  00012	89 6c 24 0c	 mov	 DWORD PTR _nCount$[esp+24], ebp
  00016	89 5c 24 1c	 mov	 DWORD PTR tv290[esp+20], ebx
  0001a	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 969  : 	if( pGCMember != NULL )

  0001f	3b c5		 cmp	 eax, ebp
  00021	0f 84 14 01 00
	00		 je	 $L268823
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 970  : 	{
; 971  : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0002c	33 f6		 xor	 esi, esi
  0002e	8b ff		 npad	 2
$L268798:
  00030	3b fd		 cmp	 edi, ebp
  00032	75 04		 jne	 SHORT $L293355
  00034	33 d2		 xor	 edx, edx
  00036	eb 08		 jmp	 SHORT $L293356
$L293355:
  00038	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0003b	2b d7		 sub	 edx, edi
  0003d	c1 fa 02	 sar	 edx, 2
$L293356:
  00040	3b f2		 cmp	 esi, edx
  00042	7d 1c		 jge	 SHORT $L268805
  00044	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00047	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]

; 972  : 		{
; 973  : 			__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 974  : 			//       .
; 975  : 			if( 0 < pJoinPlayer->nlife )

  0004a	8b 12		 mov	 edx, DWORD PTR [edx]
  0004c	39 6a 04	 cmp	 DWORD PTR [edx+4], ebp
  0004f	0f 8f e4 00 00
	00		 jg	 $L293717

; 970  : 	{
; 971  : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00055	46		 inc	 esi
  00056	eb d8		 jmp	 SHORT $L268798
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L268805:

; 976  : 				return;
; 977  : 		}
; 978  : 
; 979  : 		//   (   1  1     )
; 980  : 		for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00060	8b 91 14 11 00
	00		 mov	 edx, DWORD PTR [ecx+4372]
  00066	85 d2		 test	 edx, edx
  00068	75 04		 jne	 SHORT $L293418
  0006a	33 c0		 xor	 eax, eax
  0006c	eb 0b		 jmp	 SHORT $L293419
$L293418:
  0006e	8b 81 18 11 00
	00		 mov	 eax, DWORD PTR [ecx+4376]
  00074	2b c2		 sub	 eax, edx
  00076	c1 f8 03	 sar	 eax, 3
$L293419:
  00079	3b e8		 cmp	 ebp, eax
  0007b	0f 8d a5 00 00
	00		 jge	 $L268807

; 981  : 		{
; 982  : 			if( nVeci >= m_nMaxGuild )

  00081	3b a9 a0 10 00
	00		 cmp	 ebp, DWORD PTR [ecx+4256]
  00087	0f 8d 99 00 00
	00		 jge	 $L268807
  0008d	8b 81 14 11 00
	00		 mov	 eax, DWORD PTR [ecx+4372]

; 983  : 				break;
; 984  : 			
; 985  : 			__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  00093	8b 54 e8 04	 mov	 edx, DWORD PTR [eax+ebp*8+4]
  00097	8b 3c e8	 mov	 edi, DWORD PTR [eax+ebp*8]
  0009a	8b 71 74	 mov	 esi, DWORD PTR [ecx+116]
  0009d	8d 04 e8	 lea	 eax, DWORD PTR [eax+ebp*8]
  000a0	89 54 24 18	 mov	 DWORD PTR _RequestGuild$268809[esp+32], edx

; 986  : 			__GuildCombatMember *pGCMember2 = FindGuildCombatMember( RequestGuild.uidGuild );

  000a4	33 d2		 xor	 edx, edx
$L293598:
  000a6	85 f6		 test	 esi, esi
  000a8	75 04		 jne	 SHORT $L293604
  000aa	33 c0		 xor	 eax, eax
  000ac	eb 08		 jmp	 SHORT $L293605
$L293604:
  000ae	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]
  000b1	2b c6		 sub	 eax, esi
  000b3	c1 f8 02	 sar	 eax, 2
$L293605:
  000b6	3b d0		 cmp	 edx, eax
  000b8	7d 66		 jge	 SHORT $L268806
  000ba	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  000bd	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	3b 38		 cmp	 edi, DWORD PTR [eax]
  000c4	74 03		 je	 SHORT $L293713
  000c6	42		 inc	 edx
  000c7	eb dd		 jmp	 SHORT $L293598
$L293713:
  000c9	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  000cc	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  000cf	8b 10		 mov	 edx, DWORD PTR [eax]

; 987  : 			if( pGCMember2 != NULL )

  000d1	85 d2		 test	 edx, edx
  000d3	74 4b		 je	 SHORT $L268806

; 988  : 			{
; 989  : 				if( pUser->m_idGuild != pGCMember2->uGuildId )

  000d5	3b 1a		 cmp	 ebx, DWORD PTR [edx]
  000d7	74 47		 je	 SHORT $L268806
  000d9	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]

; 990  : 				{
; 991  : 					BOOL bLive = FALSE;

  000dc	33 db		 xor	 ebx, ebx

; 992  : 					for( int veci2 = 0 ; veci2 < (int)( pGCMember2->vecGCSelectMember.size() ) ; ++veci2 )

  000de	33 f6		 xor	 esi, esi
$L268816:
  000e0	85 ff		 test	 edi, edi
  000e2	75 04		 jne	 SHORT $L293650
  000e4	33 c0		 xor	 eax, eax
  000e6	eb 08		 jmp	 SHORT $L293651
$L293650:
  000e8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000eb	2b c7		 sub	 eax, edi
  000ed	c1 f8 02	 sar	 eax, 2
$L293651:
  000f0	3b f0		 cmp	 esi, eax
  000f2	7d 16		 jge	 SHORT $L268818
  000f4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000f7	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]

; 993  : 					{
; 994  : 						__JOINPLAYER* pJoinPlayer = pGCMember2->vecGCSelectMember[veci2];
; 995  : 						if( 0 < pJoinPlayer->nlife )

  000fa	8b 00		 mov	 eax, DWORD PTR [eax]
  000fc	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00100	7e 05		 jle	 SHORT $L268817

; 996  : 							bLive = TRUE;

  00102	bb 01 00 00 00	 mov	 ebx, 1
$L268817:

; 992  : 					for( int veci2 = 0 ; veci2 < (int)( pGCMember2->vecGCSelectMember.size() ) ; ++veci2 )

  00107	46		 inc	 esi
  00108	eb d6		 jmp	 SHORT $L268816
$L268818:

; 997  : 					}
; 998  : 					if( bLive )

  0010a	85 db		 test	 ebx, ebx
  0010c	74 0e		 je	 SHORT $L293716

; 999  : 					{
; 1000 : 						++nCount;

  0010e	8b 44 24 10	 mov	 eax, DWORD PTR _nCount$[esp+28]
  00112	40		 inc	 eax

; 1001 : 						if( nCount == 2 )

  00113	83 f8 02	 cmp	 eax, 2
  00116	89 44 24 10	 mov	 DWORD PTR _nCount$[esp+28], eax
  0011a	74 1d		 je	 SHORT $L293717
$L293716:
  0011c	8b 5c 24 20	 mov	 ebx, DWORD PTR tv290[esp+24]
$L268806:

; 976  : 				return;
; 977  : 		}
; 978  : 
; 979  : 		//   (   1  1     )
; 980  : 		for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00120	45		 inc	 ebp
  00121	e9 3a ff ff ff	 jmp	 $L268805
$L268807:

; 1002 : 						{
; 1003 : 							return; // 2   
; 1004 : 						}
; 1005 : 					}
; 1006 : 				}
; 1007 : 			}
; 1008 : 		}
; 1009 : 		//     
; 1010 : 		if( nCount == 1 )

  00126	8b 54 24 10	 mov	 edx, DWORD PTR _nCount$[esp+28]
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	3b d0		 cmp	 edx, eax
  00131	75 06		 jne	 SHORT $L293717

; 1011 : 			m_nStopWar = 1;

  00133	89 81 8c 10 00
	00		 mov	 DWORD PTR [ecx+4236], eax
$L293717:
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
$L268823:
  0013b	5d		 pop	 ebp
  0013c	5b		 pop	 ebx

; 1012 : 	}
; 1013 : #else // __S_BUG_GC
; 1014 : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( pUser->m_idGuild );
; 1015 : 	if( it != m_GuildCombatMem.end() )
; 1016 : 	{
; 1017 : 		__GuildCombatMember *pGCMember	= it->second;
; 1018 : 		for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 1019 : 		{
; 1020 : 			__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 1021 : 			//       .
; 1022 : 			if( 0 < pJoinPlayer->nlife )
; 1023 : 				return;
; 1024 : 		}
; 1025 : 
; 1026 : 		//   (   1  1     )
; 1027 : 		for( int nVeci = 0 ; nVeci < vecRequestRanking.size() ; ++nVeci )
; 1028 : 		{
; 1029 : 			if( nVeci >= m_nMaxGuild )
; 1030 : 				break;
; 1031 : 			
; 1032 : 			__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];
; 1033 : 			map<u_long, __GuildCombatMember*>::iterator it2 = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 1034 : 			if( it2 != m_GuildCombatMem.end() )
; 1035 : 			{
; 1036 : 				__GuildCombatMember *pGCMember2 = it2->second;
; 1037 : 				if( pUser->m_idGuild != it2->first )
; 1038 : 				{
; 1039 : 					BOOL bLive = FALSE;
; 1040 : 					for( int veci2 = 0 ; veci2 < pGCMember2->vecGCSelectMember.size() ; ++veci2 )
; 1041 : 					{
; 1042 : 						__JOINPLAYER* pJoinPlayer = pGCMember2->vecGCSelectMember[veci2];
; 1043 : 						if( 0 < pJoinPlayer->nlife )
; 1044 : 							bLive = TRUE;
; 1045 : 					}
; 1046 : 					if( bLive )
; 1047 : 					{
; 1048 : 						++nCount;
; 1049 : 						if( nCount == 2 )
; 1050 : 						{
; 1051 : 							return; // 2   
; 1052 : 						}
; 1053 : 					}
; 1054 : 				}
; 1055 : 			}
; 1056 : 		}
; 1057 : 		//     
; 1058 : 		if( nCount == 1 )
; 1059 : 			m_nStopWar = 1;
; 1060 : 	}
; 1061 : #endif // __S_BUG_GC
; 1062 : }

  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	c2 04 00	 ret	 4
?UserOutGuildCombatResult@CGuildCombat@@QAEXPAVCUser@@@Z ENDP ; CGuildCombat::UserOutGuildCombatResult
_TEXT	ENDS
PUBLIC	?SetDefender@CGuildCombat@@QAEXKK@Z		; CGuildCombat::SetDefender
; Function compile flags: /Ogty
;	COMDAT ?SetDefender@CGuildCombat@@QAEXKK@Z
_TEXT	SEGMENT
_uidGuild$ = 8						; size = 4
_uidDefender$ = 12					; size = 4
?SetDefender@CGuildCombat@@QAEXKK@Z PROC NEAR		; CGuildCombat::SetDefender, COMDAT
; _this$ = ecx

; 1860 : #ifdef __S_BUG_GC
; 1861 : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( uidGuild );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _uidGuild$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 1862 : 	if( pGCMember != NULL )

  0000a	85 c0		 test	 eax, eax
  0000c	74 07		 je	 SHORT $L269273

; 1863 : 		pGCMember->m_uidDefender = uidDefender;

  0000e	8b 4c 24 08	 mov	 ecx, DWORD PTR _uidDefender$[esp-4]
  00012	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L269273:

; 1864 : #else // __S_BUG_GC
; 1865 : 	map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( uidGuild );
; 1866 : 	if( it != m_GuildCombatMem.end() )
; 1867 : 	{	
; 1868 : 		__GuildCombatMember* pGCMember = it->second;
; 1869 : 		pGCMember->m_uidDefender = uidDefender;
; 1870 : 	}	
; 1871 : #endif // __S_BUG_GC
; 1872 : }

  00015	c2 08 00	 ret	 8
?SetDefender@CGuildCombat@@QAEXKK@Z ENDP		; CGuildCombat::SetDefender
_TEXT	ENDS
PUBLIC	?GetDefender@CGuildCombat@@QAEKK@Z		; CGuildCombat::GetDefender
; Function compile flags: /Ogty
;	COMDAT ?GetDefender@CGuildCombat@@QAEKK@Z
_TEXT	SEGMENT
_uidGuild$ = 8						; size = 4
?GetDefender@CGuildCombat@@QAEKK@Z PROC NEAR		; CGuildCombat::GetDefender, COMDAT
; _this$ = ecx

; 1875 : 	u_long uidDefender = 0;
; 1876 : #ifdef __S_BUG_GC
; 1877 : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( uidGuild );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _uidGuild$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	33 f6		 xor	 esi, esi
  00008	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 1878 : 	if( pGCMember != NULL )

  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $L293725

; 1879 : 		uidDefender = pGCMember->m_uidDefender;
; 1880 : #else // __S_BUG_GC
; 1881 : 	map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( uidGuild );
; 1882 : 	if( it != m_GuildCombatMem.end() )
; 1883 : 	{	
; 1884 : 		__GuildCombatMember* pGCMember = it->second;
; 1885 : 		uidDefender = pGCMember->m_uidDefender;
; 1886 : 	}
; 1887 : #endif // __S_BUG_GC
; 1888 : 	return uidDefender;

  00011	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00014	5e		 pop	 esi

; 1889 : }

  00015	c2 04 00	 ret	 4
$L293725:

; 1879 : 		uidDefender = pGCMember->m_uidDefender;
; 1880 : #else // __S_BUG_GC
; 1881 : 	map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( uidGuild );
; 1882 : 	if( it != m_GuildCombatMem.end() )
; 1883 : 	{	
; 1884 : 		__GuildCombatMember* pGCMember = it->second;
; 1885 : 		uidDefender = pGCMember->m_uidDefender;
; 1886 : 	}
; 1887 : #endif // __S_BUG_GC
; 1888 : 	return uidDefender;

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi

; 1889 : }

  0001b	c2 04 00	 ret	 4
?GetDefender@CGuildCombat@@QAEKK@Z ENDP			; CGuildCombat::GetDefender
_TEXT	ENDS
PUBLIC	?GetRequstPenya@CGuildCombat@@QAEKK@Z		; CGuildCombat::GetRequstPenya
; Function compile flags: /Ogty
;	COMDAT ?GetRequstPenya@CGuildCombat@@QAEKK@Z
_TEXT	SEGMENT
_uidGuild$ = 8						; size = 4
?GetRequstPenya@CGuildCombat@@QAEKK@Z PROC NEAR		; CGuildCombat::GetRequstPenya, COMDAT
; _this$ = ecx

; 2081 : 	DWORD dwRequestPenya = 0;
; 2082 : #ifdef __S_BUG_GC
; 2083 : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( uidGuild );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _uidGuild$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	33 f6		 xor	 esi, esi
  00008	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 2084 : 	if( pGCMember != NULL )

  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $L293729

; 2085 : 		dwRequestPenya = pGCMember->dwPenya;
; 2086 : #else // __S_BUG_GC
; 2087 : 	map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( uidGuild );
; 2088 : 	if( it != m_GuildCombatMem.end() )
; 2089 : 	{	
; 2090 : 		__GuildCombatMember* pGCMember = it->second;
; 2091 : 		dwRequestPenya = pGCMember->dwPenya;
; 2092 : 	}
; 2093 : #endif // __S_BUG_GC
; 2094 : 	return dwRequestPenya;

  00011	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00014	5e		 pop	 esi

; 2095 : }

  00015	c2 04 00	 ret	 4
$L293729:

; 2085 : 		dwRequestPenya = pGCMember->dwPenya;
; 2086 : #else // __S_BUG_GC
; 2087 : 	map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( uidGuild );
; 2088 : 	if( it != m_GuildCombatMem.end() )
; 2089 : 	{	
; 2090 : 		__GuildCombatMember* pGCMember = it->second;
; 2091 : 		dwRequestPenya = pGCMember->dwPenya;
; 2092 : 	}
; 2093 : #endif // __S_BUG_GC
; 2094 : 	return dwRequestPenya;

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi

; 2095 : }

  0001b	c2 04 00	 ret	 4
?GetRequstPenya@CGuildCombat@@QAEKK@Z ENDP		; CGuildCombat::GetRequstPenya
_TEXT	ENDS
PUBLIC	?GuildCombatEnter@CGuildCombat@@QAEXPAVCUser@@@Z ; CGuildCombat::GuildCombatEnter
EXTRN	?AddGuildCombatNextTime@CUser@@QAEXKK@Z:NEAR	; CUser::AddGuildCombatNextTime
; Function compile flags: /Ogty
;	COMDAT ?GuildCombatEnter@CGuildCombat@@QAEXPAVCUser@@@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
?GuildCombatEnter@CGuildCombat@@QAEXPAVCUser@@@Z PROC NEAR ; CGuildCombat::GuildCombatEnter, COMDAT
; _this$ = ecx

; 2171 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2172 : 	BOOL bJoin = TRUE;
; 2173 : 	if( m_nState == OPEN_STATE || m_nState == CLOSE_STATE || m_nState == WAR_STATE )

  00003	8b 87 40 11 00
	00		 mov	 eax, DWORD PTR [edi+4416]
  00009	85 c0		 test	 eax, eax
  0000b	74 30		 je	 SHORT $L269489
  0000d	83 f8 01	 cmp	 eax, 1
  00010	74 2b		 je	 SHORT $L269489
  00012	83 f8 02	 cmp	 eax, 2
  00015	74 26		 je	 SHORT $L269489

; 2185 : 		}
; 2186 : 	}
; 2187 : 	else if( m_nState == COMPLET_CLOSE_STATE )

  00017	83 f8 03	 cmp	 eax, 3
  0001a	0f 85 00 01 00
	00		 jne	 $L269497

; 2188 : 	{
; 2189 : 		//  ..   
; 2190 : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_OPEN) );

  00020	68 a4 0a 00 00	 push	 2724			; 00000aa4H
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0002a	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0002f	8b 4c 24 08	 mov	 ecx, DWORD PTR _pUser$[esp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  00039	5f		 pop	 edi

; 2203 : 		}
; 2204 : 	}
; 2205 : }

  0003a	c2 04 00	 ret	 4
$L269489:

; 2174 : 	{
; 2175 : 		BOOL bJoin = TRUE;
; 2176 : 		if( m_nState == OPEN_STATE && m_nGCState != ENTER_STATE )

  0003d	85 c0		 test	 eax, eax
  0003f	56		 push	 esi
  00040	0f 85 9c 00 00
	00		 jne	 $L293781
  00046	83 bf 44 11 00
	00 66		 cmp	 DWORD PTR [edi+4420], 102 ; 00000066H
  0004d	0f 84 8f 00 00
	00		 je	 $L293781

; 2177 : 		{
; 2178 : 			bJoin = FALSE;
; 2179 : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_JOIN) );

  00053	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00058	3d a2 0a 00 00	 cmp	 eax, 2722		; 00000aa2H
  0005d	7e 56		 jle	 SHORT $L293763
  0005f	76 10		 jbe	 SHORT $L293782
  00061	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  00067	8b 91 88 2a 00
	00		 mov	 edx, DWORD PTR [ecx+10888]
  0006d	85 d2		 test	 edx, edx
  0006f	75 13		 jne	 SHORT $L293764
$L293782:
  00071	8b 74 24 0c	 mov	 esi, DWORD PTR _pUser$[esp+4]
  00075	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0007a	50		 push	 eax
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 2180 : 		}
; 2181 : 
; 2182 : 		if( bJoin )

  00082	eb 6a		 jmp	 SHORT $L293783

; 2177 : 		{
; 2178 : 			bJoin = FALSE;
; 2179 : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_JOIN) );

$L293764:
  00084	3d a2 0a 00 00	 cmp	 eax, 2722		; 00000aa2H
  00089	77 13		 ja	 SHORT $L293777
  0008b	8b 74 24 0c	 mov	 esi, DWORD PTR _pUser$[esp+4]
  0008f	33 c0		 xor	 eax, eax
  00091	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00094	50		 push	 eax
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 2180 : 		}
; 2181 : 
; 2182 : 		if( bJoin )

  0009c	eb 50		 jmp	 SHORT $L293783

; 2177 : 		{
; 2178 : 			bJoin = FALSE;
; 2179 : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_JOIN) );

$L293777:
  0009e	8b 81 88 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10888]
  000a4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a7	8b 74 24 0c	 mov	 esi, DWORD PTR _pUser$[esp+4]
  000ab	50		 push	 eax
  000ac	8b ce		 mov	 ecx, esi
  000ae	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 2180 : 		}
; 2181 : 
; 2182 : 		if( bJoin )

  000b3	eb 39		 jmp	 SHORT $L293783

; 2177 : 		{
; 2178 : 			bJoin = FALSE;
; 2179 : 			pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_JOIN) );

$L293763:
  000b5	68 a2 0a 00 00	 push	 2722			; 00000aa2H
  000ba	50		 push	 eax
  000bb	6a 00		 push	 0
  000bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000c7	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000cc	8b 74 24 20	 mov	 esi, DWORD PTR _pUser$[esp+24]
  000d0	83 c4 14	 add	 esp, 20			; 00000014H
  000d3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  000d8	50		 push	 eax
  000d9	8b ce		 mov	 ecx, esi
  000db	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 2180 : 		}
; 2181 : 
; 2182 : 		if( bJoin )

  000e0	eb 0c		 jmp	 SHORT $L293783
$L293781:

; 2183 : 		{
; 2184 : 			JoinObserver( pUser );

  000e2	8b 74 24 0c	 mov	 esi, DWORD PTR _pUser$[esp+4]
  000e6	56		 push	 esi
  000e7	8b cf		 mov	 ecx, edi
  000e9	e8 00 00 00 00	 call	 ?JoinObserver@CGuildCombat@@QAEXPAVCUser@@@Z ; CGuildCombat::JoinObserver
$L293783:

; 2191 : 		bJoin = FALSE;
; 2192 : 	}
; 2193 : 	else
; 2194 : 	{
; 2195 : 		bJoin = FALSE;
; 2196 : 	}
; 2197 : 
; 2198 : 	if( bJoin )
; 2199 : 	{
; 2200 : 		if( 0 < m_dwTime )

  000ee	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [edi+128]
  000f4	85 c0		 test	 eax, eax
  000f6	76 27		 jbe	 SHORT $L293784

; 2201 : 		{		
; 2202 : 			pUser->AddGuildCombatNextTime( m_dwTime - GetTickCount(), GuildCombatProcess[m_nProcessGo - 1].dwParam );

  000f8	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  000fe	c1 e0 04	 shl	 eax, 4
  00101	8b 8c 38 e8 00
	00 00		 mov	 ecx, DWORD PTR [eax+edi+232]
  00108	51		 push	 ecx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0010f	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  00115	2b d0		 sub	 edx, eax
  00117	52		 push	 edx
  00118	8b ce		 mov	 ecx, esi
  0011a	e8 00 00 00 00	 call	 ?AddGuildCombatNextTime@CUser@@QAEXKK@Z ; CUser::AddGuildCombatNextTime
$L293784:
  0011f	5e		 pop	 esi
$L269497:
  00120	5f		 pop	 edi

; 2203 : 		}
; 2204 : 	}
; 2205 : }

  00121	c2 04 00	 ret	 4
?GuildCombatEnter@CGuildCombat@@QAEXPAVCUser@@@Z ENDP	; CGuildCombat::GuildCombatEnter
_TEXT	ENDS
PUBLIC	?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format, COMDAT

; 1796 : 		ATLASSERT( AtlIsValidString( pszFormat ) );
; 1797 : 		
; 1798 : 		va_list argList;
; 1799 : 		va_start( argList, pszFormat );
; 1800 : 		FormatV( pszFormat, argList );

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _pszFormat$[esp-4]
  00004	8d 44 24 0c	 lea	 eax, DWORD PTR _pszFormat$[esp]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+4]
  0000e	e8 00 00 00 00	 call	 ?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV

; 1801 : 		va_end( argList );
; 1802 : 	}

  00013	c3		 ret	 0
?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format
_TEXT	ENDS
PUBLIC	??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L293800
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L293800:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L293814
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L293814:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::clear
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L293820

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L293820:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L293828

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L293828:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L293836

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L293836:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L293844

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L293844:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L293852

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L293852:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Tidy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV34@@Z ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::construct
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV34@@Z PROC NEAR ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 ??$_Construct@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV12@@Z ; std::_Construct<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
  0000f	83 c4 08	 add	 esp, 8

; 148  : 		}

  00012	c2 08 00	 ret	 8
?construct@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV34@@Z ENDP ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 153  : 		}

  00009	c2 04 00	 ret	 4
?destroy@?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@QAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T294154 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L293883
	DD	0ffffffffH
	DD	00H
$T294156 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L293876
$T294155 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T294156
$T294148 DD	019930520H
	DD	03H
	DD	FLAT:$T294154
	DD	01H
	DD	FLAT:$T294155
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T294064 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	53		 push	 ebx

; 78   : 	_FwdIt _Next = _Dest;

  0001c	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00024	89 5d ec	 mov	 DWORD PTR __Next$[ebp], ebx

; 79   : 
; 80   : 	_TRY_BEGIN

  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0002e	8b ff		 npad	 2
$L279641:

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00030	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00033	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00036	0f 84 c0 00 00
	00		 je	 $L279643

; 82   : 		_Al.construct(_Dest, *_First);

  0003c	89 5d e8	 mov	 DWORD PTR $T294064[ebp], ebx
  0003f	85 db		 test	 ebx, ebx
  00041	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00045	74 60		 je	 SHORT $L294065
  00047	8b 30		 mov	 esi, DWORD PTR [eax]
  00049	8b 4e f0	 mov	 ecx, DWORD PTR [esi-16]
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	83 ee 10	 sub	 esi, 16			; 00000010H
  00051	ff 50 10	 call	 DWORD PTR [eax+16]
  00054	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00057	85 d2		 test	 edx, edx
  00059	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0005c	7c 11		 jl	 SHORT $L294049
  0005e	3b 06		 cmp	 eax, DWORD PTR [esi]
  00060	75 0d		 jne	 SHORT $L294049
  00062	8b c6		 mov	 eax, esi
  00064	ba 01 00 00 00	 mov	 edx, 1
  00069	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0006d	eb 33		 jmp	 SHORT $L294045
$L294049:
  0006f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00072	8b 10		 mov	 edx, DWORD PTR [eax]
  00074	6a 01		 push	 1
  00076	51		 push	 ecx
  00077	8b c8		 mov	 ecx, eax
  00079	ff 12		 call	 DWORD PTR [edx]
  0007b	85 c0		 test	 eax, eax
  0007d	75 05		 jne	 SHORT $L294051
  0007f	e9 00 00 00 00	 jmp	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L294051:
  00084	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00087	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0008a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008d	41		 inc	 ecx
  0008e	8b d1		 mov	 edx, ecx
  00090	c1 e9 02	 shr	 ecx, 2
  00093	83 c6 10	 add	 esi, 16			; 00000010H
  00096	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  00099	f3 a5		 rep movsd
  0009b	8b ca		 mov	 ecx, edx
  0009d	83 e1 03	 and	 ecx, 3
  000a0	f3 a4		 rep movsb
$L294045:
  000a2	83 c0 10	 add	 eax, 16			; 00000010H
  000a5	89 03		 mov	 DWORD PTR [ebx], eax
$L294065:
  000a7	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000aa	83 c3 04	 add	 ebx, 4
  000ad	83 c0 04	 add	 eax, 4
  000b0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  000b4	89 5d 10	 mov	 DWORD PTR __Dest$[ebp], ebx
  000b7	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
  000ba	e9 71 ff ff ff	 jmp	 $L279641
$L293876:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  000bf	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  000c2	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  000c5	3b f7		 cmp	 esi, edi
  000c7	74 2a		 je	 SHORT $L279646
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$L279644:

; 85   : 		_Al.destroy(_Next);

  000d0	8b 06		 mov	 eax, DWORD PTR [esi]
  000d2	83 e8 10	 sub	 eax, 16			; 00000010H
  000d5	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  000d8	83 ca ff	 or	 edx, -1
  000db	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000df	4a		 dec	 edx
  000e0	85 d2		 test	 edx, edx
  000e2	7f 08		 jg	 SHORT $L294142
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e8	50		 push	 eax
  000e9	ff 52 04	 call	 DWORD PTR [edx+4]
$L294142:
  000ec	83 c6 04	 add	 esi, 4
  000ef	3b f7		 cmp	 esi, edi
  000f1	75 dd		 jne	 SHORT $L279644
$L279646:

; 86   : 	_RERAISE;

  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	e8 00 00 00 00	 call	 __CxxThrowException@8
$L294157:
$L279643:

; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	8b c3		 mov	 eax, ebx
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
$L294153:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L293883:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 4d e8	 mov	 ecx, DWORD PTR $T294064[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T294148
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
PUBLIC	?GetUserByID@CProject@@QAEPAVCMover@@K@Z	; CProject::GetUserByID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
;	COMDAT ?GetUserByID@CProject@@QAEPAVCMover@@K@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_idPlayer$ = 8						; size = 4
?GetUserByID@CProject@@QAEPAVCMover@@K@Z PROC NEAR	; CProject::GetUserByID, COMDAT
; _this$ = ecx

; 1409 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1410 : 	map<u_long, CMover*>::iterator i = m_idPlayerToUserPtr.find( idPlayer );

  00004	8d 44 24 0c	 lea	 eax, DWORD PTR _idPlayer$[esp+4]
  00008	50		 push	 eax
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR _i$[esp+12]
  0000d	51		 push	 ecx
  0000e	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find

; 1411 : 	if( i != m_idPlayerToUserPtr.end() )

  00016	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00019	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp+8]
  0001d	3b c1		 cmp	 eax, ecx
  0001f	5e		 pop	 esi
  00020	74 07		 je	 SHORT $L198064

; 1412 : 		return i->second;

  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1414 : }

  00025	59		 pop	 ecx
  00026	c2 04 00	 ret	 4
$L198064:

; 1413 : 	return NULL;

  00029	33 c0		 xor	 eax, eax

; 1414 : }

  0002b	59		 pop	 ecx
  0002c	c2 04 00	 ret	 4
?GetUserByID@CProject@@QAEPAVCMover@@K@Z ENDP		; CProject::GetUserByID
_TEXT	ENDS
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 968  : 		CThisSimpleString::operator=( strSrc );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=

; 969  : 
; 970  : 		return( *this );

  0000d	8b c6		 mov	 eax, esi
  0000f	5e		 pop	 esi

; 971  : 	}

  00010	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

  00000	56		 push	 esi

; 324  : 		_Tidy();

  00001	33 c0		 xor	 eax, eax
  00003	8b f1		 mov	 esi, ecx

; 325  : 		assign(_Right, 0, npos);

  00005	6a ff		 push	 -1
  00007	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	50		 push	 eax
  00012	88 46 04	 mov	 BYTE PTR [esi+4], al
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Right$[esp+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z	; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 316  : 		SetString( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L294294
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 319  : 	}

  00017	c2 04 00	 ret	 4

; 316  : 		SetString( pszSrc );

$L294294:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L294295:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L294295
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 319  : 	}

  00036	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L294302:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L294302
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 623  : 		}

  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?Clear@__GuildCombatMember@CGuildCombat@@QAEXXZ	; CGuildCombat::__GuildCombatMember::Clear
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.h
;	COMDAT ?Clear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
?Clear@__GuildCombatMember@CGuildCombat@@QAEXXZ PROC NEAR ; CGuildCombat::__GuildCombatMember::Clear, COMDAT
; _this$ = ecx

; 131  : 		{

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 132  : #ifdef __S_BUG_GC
; 133  : 			uGuildId = 0;

  00004	33 ff		 xor	 edi, edi
  00006	89 3e		 mov	 DWORD PTR [esi], edi

; 134  : #endif // __S_BUG_GC
; 135  : 			SelectMemberClear();

  00008	e8 00 00 00 00	 call	 ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ ; CGuildCombat::__GuildCombatMember::SelectMemberClear

; 136  : 			dwPenya = 0;

  0000d	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 137  : 			bRequest = FALSE;

  00010	89 7e 18	 mov	 DWORD PTR [esi+24], edi

; 138  : 			m_uidDefender = 0;

  00013	89 7e 1c	 mov	 DWORD PTR [esi+28], edi

; 139  : 			nJoinCount = 0;

  00016	89 7e 20	 mov	 DWORD PTR [esi+32], edi

; 140  : 			nWarCount = 0;

  00019	89 7e 24	 mov	 DWORD PTR [esi+36], edi

; 141  : 			nGuildPoint = 0;

  0001c	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 142  : 		};

  00021	c3		 ret	 0
?Clear@__GuildCombatMember@CGuildCombat@@QAEXXZ ENDP	; CGuildCombat::__GuildCombatMember::Clear
_TEXT	ENDS
PUBLIC	??_G__GuildCombatMember@CGuildCombat@@QAEPAXI@Z	; CGuildCombat::__GuildCombatMember::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_G__GuildCombatMember@CGuildCombat@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G__GuildCombatMember@CGuildCombat@@QAEPAXI@Z PROC NEAR ; CGuildCombat::__GuildCombatMember::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1__GuildCombatMember@CGuildCombat@@QAE@XZ
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L294309
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L294309:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_G__GuildCombatMember@CGuildCombat@@QAEPAXI@Z ENDP	; CGuildCombat::__GuildCombatMember::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_01LAKCGALK@9?$AA@				; `string'
PUBLIC	??_C@_0M@ILPKKCFD@GUILDCOMBAT?$AA@		; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?GuildCombatRequest@CGuildCombat@@QAEXPAVCUser@@K@Z ; CGuildCombat::GuildCombatRequest
EXTRN	?SendInGuildCombat@CDPDatabaseClient@@QAEXKKK@Z:NEAR ; CDPDatabaseClient::SendInGuildCombat
EXTRN	_sprintf:NEAR
EXTRN	?GetName@CMover@@QAEPBDH@Z:NEAR			; CMover::GetName
EXTRN	?AddGold@CMover@@QAEHHH@Z:NEAR			; CMover::AddGold
EXTRN	?g_DPSrvr@@3VCDPSrvr@@A:BYTE			; g_DPSrvr
EXTRN	?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z:NEAR ; CDPSrvr::OnLogItem
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
xdata$x	SEGMENT
$T294514 DD	0ffffffffH
	DD	FLAT:$L294314
	DD	0ffffffffH
	DD	FLAT:$L294315
	DD	0ffffffffH
	DD	FLAT:$L294316
$T294507 DD	019930520H
	DD	03H
	DD	FLAT:$T294514
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT
??_C@_01LAKCGALK@9?$AA@ DB '9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILPKKCFD@GUILDCOMBAT?$AA@
CONST	SEGMENT
??_C@_0M@ILPKKCFD@GUILDCOMBAT?$AA@ DB 'GUILDCOMBAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?GuildCombatRequest@CGuildCombat@@QAEXPAVCUser@@K@Z
_TEXT	SEGMENT
_strMsg$268766 = -220					; size = 4
_strMsg$268764 = -220					; size = 4
_strMsg$268757 = -220					; size = 4
_aLogItem$268769 = -216					; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pUser$ = 8						; size = 4
_dwPenya$ = 12						; size = 4
?GuildCombatRequest@CGuildCombat@@QAEXPAVCUser@@K@Z PROC NEAR ; CGuildCombat::GuildCombatRequest, COMDAT
; _this$ = ecx

; 817  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GuildCombatRequest@CGuildCombat@@QAEXPAVCUser@@K@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	55		 push	 ebp
  00023	56		 push	 esi
  00024	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _pUser$[esp+224]
  0002b	89 84 24 d4 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+228], eax

; 818  : 	CGuild* pGuild	= g_GuildMng.GetGuild( pUser->m_idGuild );

  00032	8b 86 1c 07 00
	00		 mov	 eax, DWORD PTR [esi+1820]
  00038	57		 push	 edi
  00039	8b e9		 mov	 ebp, ecx
  0003b	50		 push	 eax
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00041	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 819  : 	if( pGuild && pGuild->IsMaster( pUser->m_idPlayer ) )

  00046	33 ff		 xor	 edi, edi
  00048	3b c7		 cmp	 eax, edi
  0004a	0f 84 e8 02 00
	00		 je	 $L268754
  00050	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00053	3b 8e 38 02 00
	00		 cmp	 ecx, DWORD PTR [esi+568]
  00059	0f 85 d9 02 00
	00		 jne	 $L268754

; 820  : 	{
; 821  : 		//   (  ~  )
; 822  : 		//   .
; 823  : 		if( m_nState != CGuildCombat::CLOSE_STATE )

  0005f	83 bd 40 11 00
	00 01		 cmp	 DWORD PTR [ebp+4416], 1
  00066	0f 84 88 00 00
	00		 je	 $L268755

; 824  : 		{
; 825  : 			pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_REQUESTEND) );

  0006c	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00071	3d 97 0b 00 00	 cmp	 eax, 2967		; 00000b97H
  00076	7e 51		 jle	 SHORT $L294350
  00078	76 0e		 jbe	 SHORT $L294508
  0007a	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  00080	39 b9 5c 2e 00
	00		 cmp	 DWORD PTR [ecx+11868], edi
  00086	75 12		 jne	 SHORT $L294351
$L294508:
  00088	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0008d	50		 push	 eax
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 826  : 			return;

  00095	e9 73 01 00 00	 jmp	 $L268775

; 824  : 		{
; 825  : 			pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_REQUESTEND) );

$L294351:
  0009a	3d 97 0b 00 00	 cmp	 eax, 2967		; 00000b97H
  0009f	77 12		 ja	 SHORT $L294364
  000a1	33 c0		 xor	 eax, eax
  000a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a6	50		 push	 eax
  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 826  : 			return;

  000ae	e9 5a 01 00 00	 jmp	 $L268775

; 824  : 		{
; 825  : 			pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_REQUESTEND) );

$L294364:
  000b3	8b 81 5c 2e 00
	00		 mov	 eax, DWORD PTR [ecx+11868]
  000b9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000bc	50		 push	 eax
  000bd	8b ce		 mov	 ecx, esi
  000bf	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 826  : 			return;

  000c4	e9 44 01 00 00	 jmp	 $L268775

; 824  : 		{
; 825  : 			pUser->AddDiagText( prj.GetText(TID_GAME_GUILDCOMBAT_REQUESTEND) );

$L294350:
  000c9	68 97 0b 00 00	 push	 2967			; 00000b97H
  000ce	50		 push	 eax
  000cf	57		 push	 edi
  000d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  000d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000da	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000df	83 c4 14	 add	 esp, 20			; 00000014H
  000e2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  000e7	50		 push	 eax
  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 826  : 			return;

  000ef	e9 19 01 00 00	 jmp	 $L268775
$L268755:

; 827  : 		}
; 828  : 
; 829  : 		//  m_nGuildLevel   
; 830  : 		if( pGuild->m_nLevel < m_nGuildLevel )

  000f4	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  000f7	3b 95 94 10 00
	00		 cmp	 edx, DWORD PTR [ebp+4244]
  000fd	7d 78		 jge	 SHORT $L268756

; 831  : 		{
; 832  : 			CString strMsg;

  000ff	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00104	8b 10		 mov	 edx, DWORD PTR [eax]
  00106	8b c8		 mov	 ecx, eax
  00108	ff 52 0c	 call	 DWORD PTR [edx+12]
  0010b	83 c0 10	 add	 eax, 16			; 00000010H
  0010e	89 44 24 0c	 mov	 DWORD PTR _strMsg$268757[esp+232], eax

; 833  : 			strMsg.Format( prj.GetText( TID_GAME_GUILDCOMBAT_REQUEST_LEVEL ), m_nGuildLevel );

  00112	8b 85 94 10 00
	00		 mov	 eax, DWORD PTR [ebp+4244]
  00118	50		 push	 eax
  00119	68 99 0b 00 00	 push	 2969			; 00000b99H
  0011e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00123	89 bc 24 ec 00
	00 00		 mov	 DWORD PTR __$EHRec$[esp+248], edi
  0012a	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0012f	50		 push	 eax
  00130	8d 4c 24 14	 lea	 ecx, DWORD PTR _strMsg$268757[esp+240]
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 834  : 			pUser->AddDiagText( strMsg );

  0013a	8b 7c 24 18	 mov	 edi, DWORD PTR _strMsg$268757[esp+244]
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00141	57		 push	 edi
  00142	8b ce		 mov	 ecx, esi
  00144	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 835  : 			return;

  00149	8d 47 f0	 lea	 eax, DWORD PTR [edi-16]
  0014c	c7 84 24 e4 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+240], -1
  00157	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  0015a	83 c9 ff	 or	 ecx, -1
  0015d	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00161	49		 dec	 ecx
  00162	85 c9		 test	 ecx, ecx
  00164	0f 8f a3 00 00
	00		 jg	 $L268775
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016e	50		 push	 eax
  0016f	ff 52 04	 call	 DWORD PTR [edx+4]
  00172	e9 96 00 00 00	 jmp	 $L268775
$L268756:

; 836  : 		}
; 837  : 
; 838  : 		//    
; 839  : 		DWORD dwExistingPenya = 0;
; 840  : #ifdef __S_BUG_GC
; 841  : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( pUser->m_idGuild );

  00177	8b 86 1c 07 00
	00		 mov	 eax, DWORD PTR [esi+1820]
  0017d	50		 push	 eax
  0017e	8b cd		 mov	 ecx, ebp
  00180	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 842  : 		if( pGCMember != NULL )

  00185	3b c7		 cmp	 eax, edi
  00187	74 03		 je	 SHORT $L268760

; 843  : 			dwExistingPenya = pGCMember->dwPenya;

  00189	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
$L268760:
  0018c	53		 push	 ebx

; 844  : #else // __S_BUG_GC
; 845  : 		map<u_long, __GuildCombatMember*>::iterator it	= m_GuildCombatMem.find( pUser->m_idGuild );
; 846  : 		if( it != m_GuildCombatMem.end() )
; 847  : 		{
; 848  : 			__GuildCombatMember *pGuildCombatMember	= it->second;
; 849  : 			dwExistingPenya = pGuildCombatMember->dwPenya;
; 850  : 		}
; 851  : #endif // __S_BUG_GC
; 852  : 
; 853  : 		// INT_MAX   
; 854  : 		if( dwPenya > INT_MAX )

  0018d	8b 9c 24 f4 00
	00 00		 mov	 ebx, DWORD PTR _dwPenya$[esp+232]
  00194	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  0019a	77 70		 ja	 SHORT $L294512

; 855  : 			return;
; 856  : 
; 857  : 		//  (m_nJoinPenya)      
; 858  : 		if( (int)( dwPenya ) < m_nJoinPanya )

  0019c	3b 9d 90 10 00
	00		 cmp	 ebx, DWORD PTR [ebp+4240]
  001a2	0f 8d 8d 00 00
	00		 jge	 $L268763

; 859  : 		{
; 860  : 			CString strMsg;

  001a8	8d 4c 24 10	 lea	 ecx, DWORD PTR _strMsg$268764[esp+236]
  001ac	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 861  : 			strMsg.Format( prj.GetText( TID_GAME_GUILDCOMBAT_REQUEST_BASEPENYA ), m_nJoinPanya );

  001b1	8b 8d 90 10 00
	00		 mov	 ecx, DWORD PTR [ebp+4240]
  001b7	51		 push	 ecx
  001b8	68 9a 0b 00 00	 push	 2970			; 00000b9aH
  001bd	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  001c2	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+252], 1
  001cd	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  001d2	50		 push	 eax
  001d3	8d 54 24 18	 lea	 edx, DWORD PTR _strMsg$268764[esp+244]
  001d7	52		 push	 edx
  001d8	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 862  : 			pUser->AddDiagText( strMsg );

  001dd	8b 44 24 1c	 mov	 eax, DWORD PTR _strMsg$268764[esp+248]
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e4	50		 push	 eax
  001e5	8b ce		 mov	 ecx, esi
  001e7	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 863  : 			pUser->AddText( prj.GetText(TID_GAME_LACKMONEY) );	

  001ec	68 71 02 00 00	 push	 625			; 00000271H
  001f1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  001f6	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  001fb	50		 push	 eax
  001fc	8b ce		 mov	 ecx, esi
  001fe	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
$L294513:

; 873  : 			return;

  00203	8d 4c 24 10	 lea	 ecx, DWORD PTR _strMsg$268766[esp+236]
  00207	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L294512:
  0020c	5b		 pop	 ebx
$L268775:

; 903  : 	}
; 904  : }

  0020d	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+232]
  00214	5f		 pop	 edi
  00215	5e		 pop	 esi
  00216	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0021d	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+224]
  00224	5d		 pop	 ebp
  00225	33 cc		 xor	 ecx, esp
  00227	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022c	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00232	c2 08 00	 ret	 8
$L268763:

; 864  : 			return;
; 865  : 		}
; 866  : 		
; 867  : 		//       .
; 868  : 		if( dwPenya <= dwExistingPenya )

  00235	3b df		 cmp	 ebx, edi
  00237	77 40		 ja	 SHORT $L268765

; 869  : 		{
; 870  : 			CString strMsg;

  00239	8d 4c 24 10	 lea	 ecx, DWORD PTR _strMsg$268766[esp+236]
  0023d	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 871  : 			strMsg.Format( prj.GetText( TID_GAME_GUILDCOMBAT_REQUEST_PENYA ), dwPenya );

  00242	53		 push	 ebx
  00243	68 9b 0b 00 00	 push	 2971			; 00000b9bH
  00248	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0024d	c7 84 24 f0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+252], 2
  00258	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0025d	50		 push	 eax
  0025e	8d 4c 24 18	 lea	 ecx, DWORD PTR _strMsg$268766[esp+244]
  00262	51		 push	 ecx
  00263	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 872  : 			pUser->AddDiagText( strMsg );

  00268	8b 54 24 1c	 mov	 edx, DWORD PTR _strMsg$268766[esp+248]
  0026c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026f	52		 push	 edx
  00270	8b ce		 mov	 ecx, esi
  00272	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 873  : 			return;

  00277	eb 8a		 jmp	 SHORT $L294513
$L268765:

; 874  : 		}
; 875  : 
; 876  : 
; 877  : 		//     
; 878  : 		if( pUser->GetGold() < (int)( (dwPenya-dwExistingPenya) ) )

  00279	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  0027f	8b eb		 mov	 ebp, ebx
  00281	2b ef		 sub	 ebp, edi
  00283	3b c5		 cmp	 eax, ebp
  00285	7d 1c		 jge	 SHORT $L268768

; 879  : 		{
; 880  : 			pUser->AddDiagText( prj.GetText( TID_GAME_GUILDCOMBAT_REQUEST_NOTPENYA ) );

  00287	68 9c 0b 00 00	 push	 2972			; 00000b9cH
  0028c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00291	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  00296	50		 push	 eax
  00297	8b ce		 mov	 ecx, esi
  00299	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 881  : 			return;

  0029e	e9 69 ff ff ff	 jmp	 $L294512
$L268768:

; 882  : 		}
; 883  : 
; 884  : 		LogItemInfo aLogItem;

  002a3	8d 4c 24 14	 lea	 ecx, DWORD PTR _aLogItem$268769[esp+236]
  002a7	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 885  : 		aLogItem.Action = "9";
; 886  : 		aLogItem.SendName = pUser->GetName();

  002ac	6a 00		 push	 0
  002ae	8b ce		 mov	 ecx, esi
  002b0	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _aLogItem$268769[esp+240], OFFSET FLAT:??_C@_01LAKCGALK@9?$AA@
  002b8	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  002bd	89 44 24 18	 mov	 DWORD PTR _aLogItem$268769[esp+240], eax

; 887  : 		aLogItem.RecvName = "GUILDCOMBAT";
; 888  : 		aLogItem.WorldId = pUser->GetWorld()->GetID();

  002c1	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  002c7	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _aLogItem$268769[esp+244], OFFSET FLAT:??_C@_0M@ILPKKCFD@GUILDCOMBAT?$AA@
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]

; 889  : 		aLogItem.Gold = pUser->GetGold();

  002d1	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  002d7	89 44 24 24	 mov	 DWORD PTR _aLogItem$268769[esp+252], eax

; 890  : 		aLogItem.Gold2 = pUser->GetGold() -(dwPenya-dwExistingPenya);
; 891  : 		//aLogItem.ItemName = "SEED";
; 892  : 		_stprintf( aLogItem.szItemName, "%d", II_GOLD_SEED1 );

  002db	6a 0c		 push	 12			; 0000000cH
  002dd	2b c3		 sub	 eax, ebx
  002df	8d 54 24 3c	 lea	 edx, DWORD PTR _aLogItem$268769[esp+276]
  002e3	03 c7		 add	 eax, edi
  002e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  002ea	52		 push	 edx
  002eb	89 4c 24 2c	 mov	 DWORD PTR _aLogItem$268769[esp+260], ecx
  002ef	89 44 24 34	 mov	 DWORD PTR _aLogItem$268769[esp+268], eax
  002f3	e8 00 00 00 00	 call	 _sprintf
  002f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 893  : 		aLogItem.itemNumber = dwPenya-dwExistingPenya;
; 894  : 		g_DPSrvr.OnLogItem( aLogItem );

  002fb	6a 00		 push	 0
  002fd	6a 00		 push	 0
  002ff	8d 44 24 1c	 lea	 eax, DWORD PTR _aLogItem$268769[esp+244]
  00303	50		 push	 eax
  00304	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  00309	89 6c 24 64	 mov	 DWORD PTR _aLogItem$268769[esp+316], ebp
  0030d	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 895  : 
; 896  : 		pUser->AddGold( (int)( (-1) * (int)( dwPenya-dwExistingPenya ) ) );

  00312	8b cf		 mov	 ecx, edi
  00314	2b cb		 sub	 ecx, ebx
  00316	6a 01		 push	 1
  00318	51		 push	 ecx
  00319	8b ce		 mov	 ecx, esi
  0031b	e8 00 00 00 00	 call	 ?AddGold@CMover@@QAEHHH@Z ; CMover::AddGold

; 897  : 		g_dpDBClient.SendInGuildCombat( pUser->m_idGuild, dwPenya, dwExistingPenya );

  00320	8b 96 1c 07 00
	00		 mov	 edx, DWORD PTR [esi+1820]
  00326	57		 push	 edi
  00327	53		 push	 ebx
  00328	52		 push	 edx
  00329	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0032e	e8 00 00 00 00	 call	 ?SendInGuildCombat@CDPDatabaseClient@@QAEXKKK@Z ; CDPDatabaseClient::SendInGuildCombat

; 898  : 	}
; 899  : 	else

  00333	e9 d4 fe ff ff	 jmp	 $L294512
$L268754:

; 900  : 	{
; 901  : 		//   .
; 902  : 		pUser->AddText( prj.GetText(TID_GAME_GUILDCOMBAT_NOT_GUILD_LEADER) );

  00338	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0033d	3d 8f 0a 00 00	 cmp	 eax, 2703		; 00000a8fH
  00342	7e 51		 jle	 SHORT $L294486
  00344	76 0e		 jbe	 SHORT $L294509
  00346	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  0034c	39 b9 3c 2a 00
	00		 cmp	 DWORD PTR [ecx+10812], edi
  00352	75 12		 jne	 SHORT $L294487
$L294509:
  00354	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00359	50		 push	 eax
  0035a	8b ce		 mov	 ecx, esi
  0035c	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  00361	e9 a7 fe ff ff	 jmp	 $L268775
$L294487:
  00366	3d 8f 0a 00 00	 cmp	 eax, 2703		; 00000a8fH
  0036b	77 12		 ja	 SHORT $L294500
  0036d	33 c0		 xor	 eax, eax
  0036f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00372	50		 push	 eax
  00373	8b ce		 mov	 ecx, esi
  00375	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  0037a	e9 8e fe ff ff	 jmp	 $L268775
$L294500:
  0037f	8b 81 3c 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10812]
  00385	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00388	50		 push	 eax
  00389	8b ce		 mov	 ecx, esi
  0038b	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  00390	e9 78 fe ff ff	 jmp	 $L268775
$L294486:
  00395	68 8f 0a 00 00	 push	 2703			; 00000a8fH
  0039a	50		 push	 eax
  0039b	57		 push	 edi
  0039c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  003a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  003a6	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  003ab	83 c4 14	 add	 esp, 20			; 00000014H
  003ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  003b3	50		 push	 eax
  003b4	8b ce		 mov	 ecx, esi
  003b6	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  003bb	e9 4d fe ff ff	 jmp	 $L268775
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L294314:
  00000	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _strMsg$268757[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L294315:
  0000b	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _strMsg$268764[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L294316:
  00016	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _strMsg$268766[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?GuildCombatRequest@CGuildCombat@@QAEXPAVCUser@@K@Z:
  00021	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T294507
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GuildCombatRequest@CGuildCombat@@QAEXPAVCUser@@K@Z ENDP ; CGuildCombat::GuildCombatRequest
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	?SetEnter@CGuildCombat@@QAEXXZ			; CGuildCombat::SetEnter
EXTRN	?AddGCTele@CUser@@QAEXPBD@Z:NEAR		; CUser::AddGCTele
EXTRN	?SendSystem@CDPCoreClient@@QAEXPBD@Z:NEAR	; CDPCoreClient::SendSystem
EXTRN	?SendCaption@CDPCoreClient@@QAEXPBDKH@Z:NEAR	; CDPCoreClient::SendCaption
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?SetEnter@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_nVeci$269559 = -540					; size = 4
$T294829 = -536						; size = 4
_i$294746 = -532					; size = 4
$T294768 = -528						; size = 4
_RequestGuild$269565 = -528				; size = 8
_str$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?SetEnter@CGuildCombat@@QAEXXZ PROC NEAR		; CGuildCombat::SetEnter, COMDAT
; _this$ = ecx

; 2415 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c5		 xor	 eax, ebp
  00013	53		 push	 ebx
  00014	89 84 24 1c 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+544], eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b f1		 mov	 esi, ecx

; 2416 : 	char str[512] = {0,};

  0001f	33 c0		 xor	 eax, eax
  00021	c6 44 24 20 00	 mov	 BYTE PTR _str$[esp+552], 0
  00026	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0002b	8d 7c 24 21	 lea	 edi, DWORD PTR _str$[esp+553]
  0002f	f3 ab		 rep stosd
  00031	66 ab		 stosw
  00033	aa		 stosb

; 2417 : 	sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_ENTER) );

  00034	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00039	3d 8c 0b 00 00	 cmp	 eax, 2956		; 00000b8cH

; 2436 : 		{
; 2437 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0003e	89 74 24 10	 mov	 DWORD PTR $T294829[esp+552], esi
  00042	7e 1d		 jle	 SHORT $L294551

; 2417 : 	sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_ENTER) );

  00044	76 0f		 jbe	 SHORT $L294833
  00046	a1 b8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+696
  0004b	8b 80 30 2e 00
	00		 mov	 eax, DWORD PTR [eax+11824]
  00051	85 c0		 test	 eax, eax
  00053	75 07		 jne	 SHORT $L294552
$L294833:
  00055	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0005a	eb 24		 jmp	 SHORT $L294546
$L294552:
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	eb 1f		 jmp	 SHORT $L294546
$L294551:
  00061	68 8c 0b 00 00	 push	 2956			; 00000b8cH
  00066	50		 push	 eax
  00067	6a 00		 push	 0
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00073	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00078	83 c4 14	 add	 esp, 20			; 00000014H
  0007b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L294546:
  00080	50		 push	 eax
  00081	8d 4c 24 24	 lea	 ecx, DWORD PTR _str$[esp+556]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 _sprintf
  0008b	83 c4 08	 add	 esp, 8

; 2418 : 	g_DPCoreClient.SendSystem( str );

  0008e	8d 54 24 20	 lea	 edx, DWORD PTR _str$[esp+552]
  00092	52		 push	 edx
  00093	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  00098	e8 00 00 00 00	 call	 ?SendSystem@CDPCoreClient@@QAEXPBD@Z ; CDPCoreClient::SendSystem

; 2419 : 	g_DPCoreClient.SendCaption( str, 0, TRUE );

  0009d	6a 01		 push	 1
  0009f	6a 00		 push	 0
  000a1	8d 44 24 28	 lea	 eax, DWORD PTR _str$[esp+560]
  000a5	50		 push	 eax
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  000ab	e8 00 00 00 00	 call	 ?SendCaption@CDPCoreClient@@QAEXPBDKH@Z ; CDPCoreClient::SendCaption

; 2420 : #if __VER < 11 // __GUILD_COMBAT_1TO1
; 2421 : 	sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_ENTER1) );
; 2422 : 	g_DPCoreClient.SendSystem( str );
; 2423 : 	g_DPCoreClient.SendCaption( str, 0, TRUE );
; 2424 : #endif // __GUILD_COMBAT_1TO1
; 2425 : 
; 2426 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  000b0	33 db		 xor	 ebx, ebx
$L294840:
  000b2	8b 8e 14 11 00
	00		 mov	 ecx, DWORD PTR [esi+4372]
  000b8	85 c9		 test	 ecx, ecx
  000ba	89 5c 24 0c	 mov	 DWORD PTR _nVeci$269559[esp+552], ebx
  000be	75 04		 jne	 SHORT $L294574
  000c0	33 c0		 xor	 eax, eax
  000c2	eb 0b		 jmp	 SHORT $L294575
$L294574:
  000c4	8b 86 18 11 00
	00		 mov	 eax, DWORD PTR [esi+4376]
  000ca	2b c1		 sub	 eax, ecx
  000cc	c1 f8 03	 sar	 eax, 3
$L294575:
  000cf	3b d8		 cmp	 ebx, eax
  000d1	0f 8d 0c 01 00
	00		 jge	 $L294832

; 2427 : 	{
; 2428 : 		//      
; 2429 : 		if( nVeci >= m_nMaxGuild )

  000d7	3b 9e a0 10 00
	00		 cmp	 ebx, DWORD PTR [esi+4256]
  000dd	0f 8d 00 01 00
	00		 jge	 $L294832
  000e3	8b 8e 14 11 00
	00		 mov	 ecx, DWORD PTR [esi+4372]

; 2430 : 			break;
; 2431 : 		
; 2432 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  000e9	8b 54 d9 04	 mov	 edx, DWORD PTR [ecx+ebx*8+4]
  000ed	8d 04 d9	 lea	 eax, DWORD PTR [ecx+ebx*8]
  000f0	8b 08		 mov	 ecx, DWORD PTR [eax]

; 2433 : #ifdef __S_BUG_GC
; 2434 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  000f2	51		 push	 ecx
  000f3	8b ce		 mov	 ecx, esi
  000f5	89 54 24 20	 mov	 DWORD PTR _RequestGuild$269565[esp+560], edx
  000f9	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  000fe	8b f8		 mov	 edi, eax

; 2435 : 		if( pGCMember != NULL )

  00100	85 ff		 test	 edi, edi
  00102	0f 84 d5 00 00
	00		 je	 $L269562

; 2436 : 		{
; 2437 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00108	33 db		 xor	 ebx, ebx
  0010a	8d 9b 00 00 00
	00		 npad	 6
$L269570:
  00110	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00113	85 c9		 test	 ecx, ecx
  00115	75 04		 jne	 SHORT $L294637
  00117	33 c0		 xor	 eax, eax
  00119	eb 08		 jmp	 SHORT $L294638
$L294637:
  0011b	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0011e	2b c1		 sub	 eax, ecx
  00120	c1 f8 02	 sar	 eax, 2
$L294638:
  00123	3b d8		 cmp	 ebx, eax
  00125	0f 8d ae 00 00
	00		 jge	 $L294838
  0012b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 2438 : 			{
; 2439 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  0012e	8b 0c 98	 mov	 ecx, DWORD PTR [eax+ebx*4]

; 2440 : 				CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );

  00131	8b 11		 mov	 edx, DWORD PTR [ecx]
  00133	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
  00136	8d 44 24 18	 lea	 eax, DWORD PTR $T294768[esp+552]
  0013a	50		 push	 eax
  0013b	8d 4c 24 18	 lea	 ecx, DWORD PTR _i$294746[esp+556]
  0013f	51		 push	 ecx
  00140	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00145	89 54 24 20	 mov	 DWORD PTR $T294768[esp+560], edx
  00149	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  0014e	8b 44 24 14	 mov	 eax, DWORD PTR _i$294746[esp+552]
  00152	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  00158	74 79		 je	 SHORT $L269571
  0015a	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 2441 : 				if( IsValidObj( pMover ) )

  0015d	85 f6		 test	 esi, esi
  0015f	74 6e		 je	 SHORT $L294837
  00161	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00165	75 68		 jne	 SHORT $L294837

; 2442 : 				{
; 2443 : 					sprintf( str, "%s", prj.GetText(TID_GAME_GUILDCOMBAT_TELE) );

  00167	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0016c	3d 91 0b 00 00	 cmp	 eax, 2961		; 00000b91H
  00171	7e 1e		 jle	 SHORT $L294811
  00173	76 10		 jbe	 SHORT $L294835
  00175	8b 15 b8 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+696
  0017b	8b 82 44 2e 00
	00		 mov	 eax, DWORD PTR [edx+11844]
  00181	85 c0		 test	 eax, eax
  00183	75 07		 jne	 SHORT $L294812
$L294835:
  00185	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0018a	eb 24		 jmp	 SHORT $L294806
$L294812:
  0018c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018f	eb 1f		 jmp	 SHORT $L294806
$L294811:
  00191	68 91 0b 00 00	 push	 2961			; 00000b91H
  00196	50		 push	 eax
  00197	6a 00		 push	 0
  00199	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  0019e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  001a3	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  001a8	83 c4 14	 add	 esp, 20			; 00000014H
  001ab	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L294806:
  001b0	50		 push	 eax
  001b1	8d 44 24 24	 lea	 eax, DWORD PTR _str$[esp+556]
  001b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 _sprintf
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2444 : 					((CUser*)pMover)->AddGCTele( str );

  001c3	8d 4c 24 20	 lea	 ecx, DWORD PTR _str$[esp+552]
  001c7	51		 push	 ecx
  001c8	8b ce		 mov	 ecx, esi
  001ca	e8 00 00 00 00	 call	 ?AddGCTele@CUser@@QAEXPBD@Z ; CUser::AddGCTele
$L294837:
  001cf	8b 74 24 10	 mov	 esi, DWORD PTR $T294829[esp+552]
$L269571:

; 2436 : 		{
; 2437 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  001d3	43		 inc	 ebx
  001d4	e9 37 ff ff ff	 jmp	 $L269570
$L294838:
  001d9	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nVeci$269559[esp+552]
$L269562:

; 2420 : #if __VER < 11 // __GUILD_COMBAT_1TO1
; 2421 : 	sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_ENTER1) );
; 2422 : 	g_DPCoreClient.SendSystem( str );
; 2423 : 	g_DPCoreClient.SendCaption( str, 0, TRUE );
; 2424 : #endif // __GUILD_COMBAT_1TO1
; 2425 : 
; 2426 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  001dd	43		 inc	 ebx
  001de	e9 cf fe ff ff	 jmp	 $L294840
$L294832:

; 2445 : 				}
; 2446 : 			}
; 2447 : 		}
; 2448 : #else // __S_BUG_GC
; 2449 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2450 : 		if( ita != m_GuildCombatMem.end() )
; 2451 : 		{
; 2452 : 			__GuildCombatMember* pGCMember = ita->second;
; 2453 : 			for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 2454 : 			{
; 2455 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 2456 : 				CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2457 : 				if( IsValidObj( pMover ) )
; 2458 : 				{
; 2459 : 					sprintf( str, "%s", prj.GetText(TID_GAME_GUILDCOMBAT_TELE) );
; 2460 : 					((CUser*)pMover)->AddGCTele( str );
; 2461 : 				}
; 2462 : 			}
; 2463 : 		}
; 2464 : #endif // __S_BUG_GC
; 2465 : 	}
; 2466 : }

  001e3	8b 8c 24 24 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+552]
  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	33 cd		 xor	 ecx, ebp
  001ee	5b		 pop	 ebx
  001ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c3		 ret	 0
?SetEnter@CGuildCombat@@QAEXXZ ENDP			; CGuildCombat::SetEnter
_TEXT	ENDS
PUBLIC	?SetGuildCombatStart@CGuildCombat@@QAEXXZ	; CGuildCombat::SetGuildCombatStart
; Function compile flags: /Ogty
;	COMDAT ?SetGuildCombatStart@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_nVeci$269583 = -16					; size = 4
$T295119 = -12						; size = 4
_RequestGuild$ = -12					; size = 8
_i$295117 = -4						; size = 4
?SetGuildCombatStart@CGuildCombat@@QAEXXZ PROC NEAR	; CGuildCombat::SetGuildCombatStart, COMDAT
; _this$ = ecx

; 2469 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b d9		 mov	 ebx, ecx

; 2470 : 	__GuildCombatMember* pGuildCombatMem;
; 2471 : 	__JOINPLAYER* pJoinPlayer;
; 2472 : 	__REQUESTGUILD RequestGuild;
; 2473 : 
; 2474 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00009	33 ff		 xor	 edi, edi
$L295140:
  0000b	8b 8b 14 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4372]
  00011	85 c9		 test	 ecx, ecx
  00013	89 7c 24 10	 mov	 DWORD PTR _nVeci$269583[esp+32], edi
  00017	75 04		 jne	 SHORT $L294849
  00019	33 c0		 xor	 eax, eax
  0001b	eb 0b		 jmp	 SHORT $L294850
$L294849:
  0001d	8b 83 18 11 00
	00		 mov	 eax, DWORD PTR [ebx+4376]
  00023	2b c1		 sub	 eax, ecx
  00025	c1 f8 03	 sar	 eax, 3
$L294850:
  00028	3b f8		 cmp	 edi, eax
  0002a	0f 8d d8 00 00
	00		 jge	 $L295136

; 2475 : 	{
; 2476 : 		if( nVeci >= m_nMaxGuild )

  00030	3b bb a0 10 00
	00		 cmp	 edi, DWORD PTR [ebx+4256]
  00036	0f 8d cc 00 00
	00		 jge	 $L295136
  0003c	8b 83 14 11 00
	00		 mov	 eax, DWORD PTR [ebx+4372]

; 2477 : 			break;
; 2478 : 		
; 2479 : 		RequestGuild = vecRequestRanking[nVeci];

  00042	8b 0c f8	 mov	 ecx, DWORD PTR [eax+edi*8]
  00045	8b 54 f8 04	 mov	 edx, DWORD PTR [eax+edi*8+4]
  00049	8d 04 f8	 lea	 eax, DWORD PTR [eax+edi*8]

; 2480 : #ifdef __S_BUG_GC
; 2481 : 		pGuildCombatMem = FindGuildCombatMember( RequestGuild.uidGuild );

  0004c	51		 push	 ecx
  0004d	8b cb		 mov	 ecx, ebx
  0004f	89 54 24 1c	 mov	 DWORD PTR _RequestGuild$[esp+40], edx
  00053	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  00058	8b f0		 mov	 esi, eax

; 2482 : 		if( pGuildCombatMem != NULL )

  0005a	85 f6		 test	 esi, esi
  0005c	0f 84 a0 00 00
	00		 je	 $L269586

; 2483 : 		{
; 2484 : 			for( int veci = 0 ; veci < (int)( pGuildCombatMem->vecGCSelectMember.size() ) ; ++veci )

  00062	33 ed		 xor	 ebp, ebp
$L269592:
  00064	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00067	85 c9		 test	 ecx, ecx
  00069	75 04		 jne	 SHORT $L294912
  0006b	33 c0		 xor	 eax, eax
  0006d	eb 08		 jmp	 SHORT $L294913
$L294912:
  0006f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00072	2b c1		 sub	 eax, ecx
  00074	c1 f8 02	 sar	 eax, 2
$L294913:
  00077	3b e8		 cmp	 ebp, eax
  00079	0f 8d 83 00 00
	00		 jge	 $L269586
  0007f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2485 : 			{
; 2486 : 				pJoinPlayer = pGuildCombatMem->vecGCSelectMember[veci];
; 2487 : 				BOOL bFind	= FALSE;
; 2488 : 				for( list<__JOINPLAYER*>::iterator i1 = pGuildCombatMem->lspFifo.begin(); i1 != pGuildCombatMem->lspFifo.end(); ++i1 )

  00082	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00085	8b 14 a8	 mov	 edx, DWORD PTR [eax+ebp*4]
  00088	8d 04 a8	 lea	 eax, DWORD PTR [eax+ebp*4]
  0008b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008d	33 ff		 xor	 edi, edi
  0008f	3b c1		 cmp	 eax, ecx
  00091	74 12		 je	 SHORT $L269679
$L295001:

; 2489 : 				{
; 2490 : 					if( pJoinPlayer == *i1 )

  00093	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00096	74 08		 je	 SHORT $L295135
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	3b c1		 cmp	 eax, ecx
  0009c	75 f5		 jne	 SHORT $L295001

; 2475 : 	{
; 2476 : 		if( nVeci >= m_nMaxGuild )

  0009e	eb 05		 jmp	 SHORT $L269679
$L295135:

; 2491 : 					{
; 2492 : 						bFind	= TRUE;

  000a0	bf 01 00 00 00	 mov	 edi, 1
$L269679:

; 2493 : 						break;
; 2494 : 					}
; 2495 : 				}				
; 2496 : 				if( pJoinPlayer->nlife > 0 && !bFind )

  000a5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a8	85 c0		 test	 eax, eax
  000aa	7e 4c		 jle	 SHORT $L269593
  000ac	85 ff		 test	 edi, edi
  000ae	75 48		 jne	 SHORT $L269593

; 2497 : 				{
; 2498 : 					CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );

  000b0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000b2	8d 54 24 14	 lea	 edx, DWORD PTR $T295119[esp+32]
  000b6	52		 push	 edx
  000b7	8d 44 24 20	 lea	 eax, DWORD PTR _i$295117[esp+36]
  000bb	89 4c 24 18	 mov	 DWORD PTR $T295119[esp+36], ecx
  000bf	50		 push	 eax
  000c0	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  000c5	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  000ca	8b 44 24 1c	 mov	 eax, DWORD PTR _i$295117[esp+32]
  000ce	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  000d4	74 22		 je	 SHORT $L269593
  000d6	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2499 : 					if( IsValidObj( pMover ) )

  000d9	85 c0		 test	 eax, eax
  000db	74 1b		 je	 SHORT $L269593
  000dd	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000e1	75 15		 jne	 SHORT $L269593

; 2500 : 					{
; 2501 : 						pMover->m_nGuildCombatState		= 1;
; 2502 : 						g_UserMng.AddGuildCombatUserState( pMover );

  000e3	50		 push	 eax
  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000e9	c7 80 98 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3736], 1
  000f3	e8 00 00 00 00	 call	 ?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddGuildCombatUserState
$L269593:
  000f8	8b 7c 24 10	 mov	 edi, DWORD PTR _nVeci$269583[esp+32]
  000fc	45		 inc	 ebp
  000fd	e9 62 ff ff ff	 jmp	 $L269592
$L269586:

; 2470 : 	__GuildCombatMember* pGuildCombatMem;
; 2471 : 	__JOINPLAYER* pJoinPlayer;
; 2472 : 	__REQUESTGUILD RequestGuild;
; 2473 : 
; 2474 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00102	47		 inc	 edi
  00103	e9 03 ff ff ff	 jmp	 $L295140
$L295136:
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5d		 pop	 ebp
  0010b	5b		 pop	 ebx

; 2503 : 					}
; 2504 : 				}
; 2505 : 			}
; 2506 : 		}
; 2507 : #else // __S_BUG_GC
; 2508 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2509 : 		if( ita != m_GuildCombatMem.end() )
; 2510 : 		{
; 2511 : 			pGuildCombatMem = ita->second;
; 2512 : 
; 2513 : 			for( int veci = 0 ; veci < pGuildCombatMem->vecGCSelectMember.size() ; ++veci )
; 2514 : 			{
; 2515 : 				pJoinPlayer = pGuildCombatMem->vecGCSelectMember[veci];
; 2516 : //				if( pJoinPlayer->bEntry == TRUE && 0 < pJoinPlayer->nlife )
; 2517 : 				BOOL bFind	= FALSE;
; 2518 : 				for( list<__JOINPLAYER*>::iterator i1 = pGuildCombatMem->lspFifo.begin(); i1 != pGuildCombatMem->lspFifo.end(); ++i1 )
; 2519 : 				{
; 2520 : 					if( pJoinPlayer == *i1 )
; 2521 : 					{
; 2522 : 						bFind	= TRUE;
; 2523 : 						break;
; 2524 : 					}
; 2525 : 				}				
; 2526 : 				if( pJoinPlayer->nlife > 0 && !bFind )
; 2527 : 				{
; 2528 : 					CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2529 : 					if( IsValidObj( pMover ) )
; 2530 : 					{
; 2531 : 						pMover->m_nGuildCombatState		= 1;
; 2532 : 						g_UserMng.AddGuildCombatUserState( pMover );
; 2533 : 					}
; 2534 : 				}
; 2535 : 			}
; 2536 : 		}
; 2537 : #endif // __S_BUG_GC
; 2538 : 	}
; 2539 : }

  0010c	83 c4 10	 add	 esp, 16			; 00000010H
  0010f	c3		 ret	 0
?SetGuildCombatStart@CGuildCombat@@QAEXXZ ENDP		; CGuildCombat::SetGuildCombatStart
_TEXT	ENDS
PUBLIC	?SetGuildCombatClose@CGuildCombat@@QAEXH@Z	; CGuildCombat::SetGuildCombatClose
EXTRN	?AddDefinedCaption@CUser@@QAAXHHPBDZZ:NEAR	; CUser::AddDefinedCaption
; Function compile flags: /Ogty
;	COMDAT ?SetGuildCombatClose@CGuildCombat@@QAEXH@Z
_TEXT	SEGMENT
$T295952 = -16						; size = 4
_i$295342 = -16						; size = 4
_RequestGuild$269713 = -16				; size = 8
_i$295930 = -8						; size = 4
_RequestGuild$269696 = -8				; size = 8
$T295344 = 8						; size = 4
_nVeci$269707 = 8					; size = 4
_bGM$ = 8						; size = 4
?SetGuildCombatClose@CGuildCombat@@QAEXH@Z PROC NEAR	; CGuildCombat::SetGuildCombatClose, COMDAT
; _this$ = ecx

; 2542 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 2543 : 	if( m_nState == CLOSE_STATE )

  00006	8b 8b 40 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4416]
  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	3b c8		 cmp	 ecx, eax
  00013	0f 84 83 02 00
	00		 je	 $L269687

; 2544 : 		return;
; 2545 : 
; 2546 : 	if( bGM )

  00019	8b 4c 24 18	 mov	 ecx, DWORD PTR _bGM$[esp+16]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0d		 je	 SHORT $L269689

; 2547 : 	{
; 2548 : 		m_nStopWar = 1;	

  00021	89 83 8c 10 00
	00		 mov	 DWORD PTR [ebx+4236], eax
  00027	5b		 pop	 ebx

; 2659 : }

  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	c2 04 00	 ret	 4
$L269689:
  0002e	55		 push	 ebp
  0002f	56		 push	 esi
  00030	57		 push	 edi

; 2549 : 		return;
; 2550 : 	}
; 2551 : 
; 2552 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00031	33 ed		 xor	 ebp, ebp
$L269692:
  00033	8b 8b 14 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4372]
  00039	85 c9		 test	 ecx, ecx
  0003b	75 04		 jne	 SHORT $L295150
  0003d	33 c0		 xor	 eax, eax
  0003f	eb 0b		 jmp	 SHORT $L295151
$L295150:
  00041	8b 83 18 11 00
	00		 mov	 eax, DWORD PTR [ebx+4376]
  00047	2b c1		 sub	 eax, ecx
  00049	c1 f8 03	 sar	 eax, 3
$L295151:
  0004c	3b e8		 cmp	 ebp, eax
  0004e	0f 8d a1 00 00
	00		 jge	 $L295985

; 2553 : 	{
; 2554 : 		if( nVeci >= m_nMaxGuild )

  00054	3b ab a0 10 00
	00		 cmp	 ebp, DWORD PTR [ebx+4256]
  0005a	0f 8d 95 00 00
	00		 jge	 $L295985
  00060	8b 83 14 11 00
	00		 mov	 eax, DWORD PTR [ebx+4372]

; 2555 : 			break;
; 2556 : 		
; 2557 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  00066	8b 0c e8	 mov	 ecx, DWORD PTR [eax+ebp*8]
  00069	8b 54 e8 04	 mov	 edx, DWORD PTR [eax+ebp*8+4]
  0006d	8d 04 e8	 lea	 eax, DWORD PTR [eax+ebp*8]

; 2558 : #ifdef __S_BUG_GC
; 2559 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  00070	51		 push	 ecx
  00071	8b cb		 mov	 ecx, ebx
  00073	89 54 24 20	 mov	 DWORD PTR _RequestGuild$269696[esp+40], edx
  00077	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  0007c	8b f0		 mov	 esi, eax

; 2560 : 		if( pGCMember != NULL )

  0007e	85 f6		 test	 esi, esi
  00080	74 6d		 je	 SHORT $L269693

; 2561 : 		{
; 2562 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00082	33 ff		 xor	 edi, edi
$L269701:
  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	85 c9		 test	 ecx, ecx
  00089	75 04		 jne	 SHORT $L295212
  0008b	33 c0		 xor	 eax, eax
  0008d	eb 08		 jmp	 SHORT $L295214
$L295212:
  0008f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00092	2b c1		 sub	 eax, ecx
  00094	c1 f8 02	 sar	 eax, 2
$L295214:
  00097	3b f8		 cmp	 edi, eax
  00099	7d 54		 jge	 SHORT $L269693
  0009b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2563 : 			{
; 2564 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  0009e	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]

; 2565 : 				CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );

  000a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a3	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  000a6	8d 44 24 24	 lea	 eax, DWORD PTR $T295344[esp+28]
  000aa	50		 push	 eax
  000ab	8d 4c 24 14	 lea	 ecx, DWORD PTR _i$295342[esp+36]
  000af	51		 push	 ecx
  000b0	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  000b5	89 54 24 2c	 mov	 DWORD PTR $T295344[esp+36], edx
  000b9	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  000be	8b 44 24 10	 mov	 eax, DWORD PTR _i$295342[esp+32]
  000c2	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  000c8	74 22		 je	 SHORT $L269702
  000ca	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2566 : 				if( IsValidObj( pMover ) )

  000cd	85 c0		 test	 eax, eax
  000cf	74 1b		 je	 SHORT $L269702
  000d1	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000d5	75 15		 jne	 SHORT $L269702

; 2567 : 				{
; 2568 : 					pMover->m_nGuildCombatState = 0;
; 2569 : 					g_UserMng.AddGuildCombatUserState( pMover );

  000d7	50		 push	 eax
  000d8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000dd	c7 80 98 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3736], 0
  000e7	e8 00 00 00 00	 call	 ?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddGuildCombatUserState
$L269702:

; 2561 : 		{
; 2562 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  000ec	47		 inc	 edi
  000ed	eb 95		 jmp	 SHORT $L269701
$L269693:

; 2549 : 		return;
; 2550 : 	}
; 2551 : 
; 2552 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  000ef	45		 inc	 ebp
  000f0	e9 3e ff ff ff	 jmp	 $L269692
$L295985:

; 2570 : 				}
; 2571 : 			}
; 2572 : 		}
; 2573 : #else // __S_BUG_GC
; 2574 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2575 : 		if( ita != m_GuildCombatMem.end() )
; 2576 : 		{
; 2577 : 			__GuildCombatMember* pGuildCombat = ita->second;
; 2578 : 			for( int veci = 0 ; veci < pGuildCombat->vecGCSelectMember.size() ; ++veci )
; 2579 : 			{
; 2580 : 				__JOINPLAYER* pJoinPlayer = pGuildCombat->vecGCSelectMember[veci];
; 2581 : 				CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2582 : 				if( IsValidObj( pMover ) )
; 2583 : 				{
; 2584 : 					pMover->m_nGuildCombatState = 0;
; 2585 : 					g_UserMng.AddGuildCombatUserState( pMover );
; 2586 : 				}
; 2587 : 			}
; 2588 : 		}
; 2589 : #endif // __S_BUG_GC
; 2590 : 	}
; 2591 : 
; 2592 : 	//      
; 2593 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  000f5	33 f6		 xor	 esi, esi
$L295994:
  000f7	8b 8b 14 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4372]
  000fd	85 c9		 test	 ecx, ecx
  000ff	89 74 24 24	 mov	 DWORD PTR _nVeci$269707[esp+28], esi
  00103	75 04		 jne	 SHORT $L295362
  00105	33 c0		 xor	 eax, eax
  00107	eb 0b		 jmp	 SHORT $L295363
$L295362:
  00109	8b 83 18 11 00
	00		 mov	 eax, DWORD PTR [ebx+4376]
  0010f	2b c1		 sub	 eax, ecx
  00111	c1 f8 03	 sar	 eax, 3
$L295363:
  00114	3b f0		 cmp	 esi, eax
  00116	0f 8d 71 01 00
	00		 jge	 $L295987

; 2594 : 	{
; 2595 : 		if( nVeci >= m_nMaxGuild )

  0011c	3b b3 a0 10 00
	00		 cmp	 esi, DWORD PTR [ebx+4256]
  00122	0f 8d 65 01 00
	00		 jge	 $L295987
  00128	8b 93 14 11 00
	00		 mov	 edx, DWORD PTR [ebx+4372]

; 2596 : 			break;
; 2597 : 		
; 2598 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  0012e	8b 3c f2	 mov	 edi, DWORD PTR [edx+esi*8]
  00131	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  00134	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00137	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  0013a	89 44 24 14	 mov	 DWORD PTR _RequestGuild$269713[esp+36], eax

; 2599 : #ifdef __S_BUG_GC
; 2600 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  0013e	33 c9		 xor	 ecx, ecx
$L295542:
  00140	85 d2		 test	 edx, edx
  00142	75 04		 jne	 SHORT $L295548
  00144	33 c0		 xor	 eax, eax
  00146	eb 08		 jmp	 SHORT $L295549
$L295548:
  00148	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  0014b	2b c2		 sub	 eax, edx
  0014d	c1 f8 02	 sar	 eax, 2
$L295549:
  00150	3b c8		 cmp	 ecx, eax
  00152	0f 8d 2f 01 00
	00		 jge	 $L269710
  00158	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  0015b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0015e	8b 00		 mov	 eax, DWORD PTR [eax]
  00160	3b 38		 cmp	 edi, DWORD PTR [eax]
  00162	74 03		 je	 SHORT $L295986
  00164	41		 inc	 ecx
  00165	eb d9		 jmp	 SHORT $L295542
$L295986:
  00167	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  0016a	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]

; 2601 : 		if( pGCMember != NULL )

  0016f	85 c0		 test	 eax, eax
  00171	0f 84 10 01 00
	00		 je	 $L269710
  00177	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 2602 : 		{
; 2603 : 			int nRevivalPoint = 0;

  0017a	33 ed		 xor	 ebp, ebp

; 2604 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0017c	33 d2		 xor	 edx, edx
  0017e	8b ff		 npad	 2
$L269719:
  00180	85 f6		 test	 esi, esi
  00182	75 04		 jne	 SHORT $L295594
  00184	33 c9		 xor	 ecx, ecx
  00186	eb 08		 jmp	 SHORT $L295595
$L295594:
  00188	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0018b	2b ce		 sub	 ecx, esi
  0018d	c1 f9 02	 sar	 ecx, 2
$L295595:
  00190	3b d1		 cmp	 edx, ecx
  00192	7d 0e		 jge	 SHORT $L269721
  00194	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00197	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]

; 2605 : 			{
; 2606 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 2607 : 				nRevivalPoint += pJoinPlayer->nlife;

  0019a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0019c	03 69 04	 add	 ebp, DWORD PTR [ecx+4]
  0019f	42		 inc	 edx
  001a0	eb de		 jmp	 SHORT $L269719
$L269721:

; 2608 : 			}
; 2609 : 			pGCMember->nGuildPoint += nRevivalPoint;

  001a2	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  001a5	03 d5		 add	 edx, ebp

; 2610 : 
; 2611 : 			CGuild* pGuildMsg;
; 2612 : 			CGuildMember*	pMember;
; 2613 : 			CUser*			pUsertmp;
; 2614 : 			pGuildMsg = g_GuildMng.GetGuild( RequestGuild.uidGuild );

  001a7	57		 push	 edi
  001a8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  001ad	89 50 28	 mov	 DWORD PTR [eax+40], edx
  001b0	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild
  001b5	8b f8		 mov	 edi, eax

; 2615 : 			if( pGuildMsg )

  001b7	85 ff		 test	 edi, edi
  001b9	0f 84 c4 00 00
	00		 je	 $L295993

; 2616 : 			{
; 2617 : 				for( map<u_long, CGuildMember*>::iterator iGuild = pGuildMsg->m_mapPMember.begin();

  001bf	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  001c2	8b 30		 mov	 esi, DWORD PTR [eax]

; 2618 : 				iGuild != pGuildMsg->m_mapPMember.end(); ++iGuild )

  001c4	3b f0		 cmp	 esi, eax
  001c6	0f 84 b7 00 00
	00		 je	 $L295993
  001cc	8d 64 24 00	 npad	 4
$L295830:

; 2619 : 				{
; 2620 : 					pMember		= iGuild->second;
; 2621 : 					pUsertmp	= (CUser*)prj.GetUserByID( pMember->m_idPlayer );

  001d0	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  001d3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001d6	8d 4c 24 10	 lea	 ecx, DWORD PTR $T295952[esp+32]
  001da	51		 push	 ecx
  001db	8d 54 24 1c	 lea	 edx, DWORD PTR _i$295930[esp+36]
  001df	52		 push	 edx
  001e0	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  001e5	89 44 24 18	 mov	 DWORD PTR $T295952[esp+40], eax
  001e9	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  001ee	8b 44 24 18	 mov	 eax, DWORD PTR _i$295930[esp+32]
  001f2	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  001f8	74 35		 je	 SHORT $L269736
  001fa	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2622 : 					if( IsValidObj( pUsertmp ) && pUsertmp->GetWorld() && pUsertmp->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  001fd	85 c0		 test	 eax, eax
  001ff	74 2e		 je	 SHORT $L269736
  00201	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00205	75 28		 jne	 SHORT $L269736
  00207	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  0020d	85 c9		 test	 ecx, ecx
  0020f	74 1e		 je	 SHORT $L269736
  00211	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  00217	75 16		 jne	 SHORT $L269736

; 2623 : 						pUsertmp->AddDefinedCaption( TRUE, TID_GAME_GUILDCOMBAT_POINT_REVIVAL, "%d", nRevivalPoint );

  00219	55		 push	 ebp
  0021a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0021f	68 96 0b 00 00	 push	 2966			; 00000b96H
  00224	6a 01		 push	 1
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 ?AddDefinedCaption@CUser@@QAAXHHPBDZZ ; CUser::AddDefinedCaption
  0022c	83 c4 14	 add	 esp, 20			; 00000014H
$L269736:
  0022f	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00232	84 c0		 test	 al, al
  00234	75 44		 jne	 SHORT $L295801
  00236	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00239	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0023c	84 c9		 test	 cl, cl
  0023e	75 1d		 jne	 SHORT $L295984
  00240	8b f0		 mov	 esi, eax
  00242	8b 06		 mov	 eax, DWORD PTR [esi]
  00244	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00247	84 c9		 test	 cl, cl
  00249	75 2f		 jne	 SHORT $L295801
  0024b	eb 03 8d 49 00	 npad	 5

; 2618 : 				iGuild != pGuildMsg->m_mapPMember.end(); ++iGuild )

$L295815:
  00250	8b f0		 mov	 esi, eax
  00252	8b 06		 mov	 eax, DWORD PTR [esi]
  00254	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00257	84 c9		 test	 cl, cl
  00259	74 f5		 je	 SHORT $L295815
  0025b	eb 1d		 jmp	 SHORT $L295801
$L295984:
  0025d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00260	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00263	84 c9		 test	 cl, cl
  00265	75 11		 jne	 SHORT $L295804
$L295803:
  00267	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0026a	75 0c		 jne	 SHORT $L295804
  0026c	8b f0		 mov	 esi, eax
  0026e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00271	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00274	84 c9		 test	 cl, cl
  00276	74 ef		 je	 SHORT $L295803
$L295804:
  00278	8b f0		 mov	 esi, eax
$L295801:
  0027a	3b 77 3c	 cmp	 esi, DWORD PTR [edi+60]
  0027d	0f 85 4d ff ff
	ff		 jne	 $L295830
$L295993:
  00283	8b 74 24 24	 mov	 esi, DWORD PTR _nVeci$269707[esp+28]
$L269710:

; 2570 : 				}
; 2571 : 			}
; 2572 : 		}
; 2573 : #else // __S_BUG_GC
; 2574 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2575 : 		if( ita != m_GuildCombatMem.end() )
; 2576 : 		{
; 2577 : 			__GuildCombatMember* pGuildCombat = ita->second;
; 2578 : 			for( int veci = 0 ; veci < pGuildCombat->vecGCSelectMember.size() ; ++veci )
; 2579 : 			{
; 2580 : 				__JOINPLAYER* pJoinPlayer = pGuildCombat->vecGCSelectMember[veci];
; 2581 : 				CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2582 : 				if( IsValidObj( pMover ) )
; 2583 : 				{
; 2584 : 					pMover->m_nGuildCombatState = 0;
; 2585 : 					g_UserMng.AddGuildCombatUserState( pMover );
; 2586 : 				}
; 2587 : 			}
; 2588 : 		}
; 2589 : #endif // __S_BUG_GC
; 2590 : 	}
; 2591 : 
; 2592 : 	//      
; 2593 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00287	46		 inc	 esi
  00288	e9 6a fe ff ff	 jmp	 $L295994
$L295987:

; 2624 : 				}
; 2625 : 			}
; 2626 : 		}
; 2627 : #else // __S_BUG_GC
; 2628 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2629 : 		if( ita != m_GuildCombatMem.end() )
; 2630 : 		{
; 2631 : 			int nRevivalPoint = 0;
; 2632 : 			__GuildCombatMember* pGuildCombat = ita->second;
; 2633 : 			for( int veci = 0 ; veci < pGuildCombat->vecGCSelectMember.size() ; ++veci )
; 2634 : 			{
; 2635 : 				__JOINPLAYER* pJoinPlayer = pGuildCombat->vecGCSelectMember[veci];
; 2636 : 				nRevivalPoint += pJoinPlayer->nlife;
; 2637 : 			}
; 2638 : 			pGuildCombat->nGuildPoint += nRevivalPoint;
; 2639 : 
; 2640 : 			CGuild* pGuildMsg;
; 2641 : 			CGuildMember*	pMember;
; 2642 : 			CUser*			pUsertmp;
; 2643 : 			pGuildMsg = g_GuildMng.GetGuild( RequestGuild.uidGuild );
; 2644 : 			if( pGuildMsg )
; 2645 : 			{
; 2646 : 				for( map<u_long, CGuildMember*>::iterator iGuild = pGuildMsg->m_mapPMember.begin();
; 2647 : 				iGuild != pGuildMsg->m_mapPMember.end(); ++iGuild )
; 2648 : 				{
; 2649 : 					pMember		= iGuild->second;
; 2650 : 					pUsertmp	= (CUser*)prj.GetUserByID( pMember->m_idPlayer );
; 2651 : 					if( IsValidObj( pUsertmp ) && pUsertmp->GetWorld() && pUsertmp->GetWorld()->GetID() == WI_WORLD_GUILDWAR )
; 2652 : 						pUsertmp->AddDefinedCaption( TRUE, TID_GAME_GUILDCOMBAT_POINT_REVIVAL, "%d", nRevivalPoint );
; 2653 : 				}
; 2654 : 			}
; 2655 : 		}
; 2656 : #endif // __S_BUG_GC
; 2657 : 	}
; 2658 : 	g_UserMng.AddGCGuildPrecedence();

  0028d	6a 00		 push	 0
  0028f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00294	e8 00 00 00 00	 call	 ?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddGCGuildPrecedence
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5d		 pop	 ebp
$L269687:
  0029c	5b		 pop	 ebx

; 2659 : }

  0029d	83 c4 10	 add	 esp, 16			; 00000010H
  002a0	c2 04 00	 ret	 4
?SetGuildCombatClose@CGuildCombat@@QAEXH@Z ENDP		; CGuildCombat::SetGuildCombatClose
_TEXT	ENDS
PUBLIC	?ProcessJoinWar@CGuildCombat@@QAEXXZ		; CGuildCombat::ProcessJoinWar
EXTRN	__imp__timeGetTime@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ProcessJoinWar@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_nVeci$269801 = -16					; size = 4
$T296197 = -12						; size = 4
_RequestGuild$269807 = -12				; size = 8
_i$296195 = -4						; size = 4
?ProcessJoinWar@CGuildCombat@@QAEXXZ PROC NEAR		; CGuildCombat::ProcessJoinWar, COMDAT
; _this$ = ecx

; 2803 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b e9		 mov	 ebp, ecx

; 2804 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00009	33 f6		 xor	 esi, esi
$L296215:
  0000b	8b 8d 14 11 00
	00		 mov	 ecx, DWORD PTR [ebp+4372]
  00011	85 c9		 test	 ecx, ecx
  00013	89 74 24 10	 mov	 DWORD PTR _nVeci$269801[esp+32], esi
  00017	75 04		 jne	 SHORT $L296002
  00019	33 c0		 xor	 eax, eax
  0001b	eb 0b		 jmp	 SHORT $L296003
$L296002:
  0001d	8b 85 18 11 00
	00		 mov	 eax, DWORD PTR [ebp+4376]
  00023	2b c1		 sub	 eax, ecx
  00025	c1 f8 03	 sar	 eax, 3
$L296003:
  00028	3b f0		 cmp	 esi, eax
  0002a	0f 8d ce 00 00
	00		 jge	 $L296212

; 2805 : 	{
; 2806 : 		if( nVeci >= m_nMaxGuild )

  00030	3b b5 a0 10 00
	00		 cmp	 esi, DWORD PTR [ebp+4256]
  00036	0f 8d c2 00 00
	00		 jge	 $L296212
  0003c	8b 85 14 11 00
	00		 mov	 eax, DWORD PTR [ebp+4372]

; 2807 : 			break;
; 2808 : 		
; 2809 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  00042	8b 0c f0	 mov	 ecx, DWORD PTR [eax+esi*8]
  00045	8b 54 f0 04	 mov	 edx, DWORD PTR [eax+esi*8+4]
  00049	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]

; 2810 : #ifdef __S_BUG_GC
; 2811 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  0004c	51		 push	 ecx
  0004d	8b cd		 mov	 ecx, ebp
  0004f	89 54 24 1c	 mov	 DWORD PTR _RequestGuild$269807[esp+40], edx
  00053	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  00058	8b f8		 mov	 edi, eax

; 2812 : 		if( pGCMember != NULL )

  0005a	85 ff		 test	 edi, edi
  0005c	0f 84 96 00 00
	00		 je	 $L269804

; 2813 : 		{
; 2814 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00062	33 db		 xor	 ebx, ebx
$L269812:
  00064	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00067	85 c9		 test	 ecx, ecx
  00069	75 04		 jne	 SHORT $L296065
  0006b	33 c0		 xor	 eax, eax
  0006d	eb 08		 jmp	 SHORT $L296066
$L296065:
  0006f	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00072	2b c1		 sub	 eax, ecx
  00074	c1 f8 02	 sar	 eax, 2
$L296066:
  00077	3b d8		 cmp	 ebx, eax
  00079	7d 7d		 jge	 SHORT $L269804
  0007b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 2815 : 			{
; 2816 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  0007e	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]
  00081	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]

; 2817 : 				if( pJoinPlayer->dwTelTime != 0 )

  00084	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00087	85 c0		 test	 eax, eax
  00089	74 63		 je	 SHORT $L269813

; 2818 : 				{
; 2819 : 					if( pJoinPlayer->dwTelTime + m_nMaxMapTime * 1000 <= timeGetTime()  )

  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00091	8b 8d b0 10 00
	00		 mov	 ecx, DWORD PTR [ebp+4272]
  00097	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0009a	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  000a0	03 ca		 add	 ecx, edx
  000a2	3b c8		 cmp	 ecx, eax
  000a4	77 48		 ja	 SHORT $L269813

; 2820 : 					{
; 2821 : 						pJoinPlayer->dwTelTime = 0;
; 2822 : 						CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );					

  000a6	8b 16		 mov	 edx, DWORD PTR [esi]
  000a8	8d 44 24 14	 lea	 eax, DWORD PTR $T296197[esp+32]
  000ac	50		 push	 eax
  000ad	8d 4c 24 20	 lea	 ecx, DWORD PTR _i$296195[esp+36]
  000b1	51		 push	 ecx
  000b2	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  000b7	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  000be	89 54 24 1c	 mov	 DWORD PTR $T296197[esp+40], edx
  000c2	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  000c7	8b 44 24 1c	 mov	 eax, DWORD PTR _i$296195[esp+32]
  000cb	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  000d1	74 1b		 je	 SHORT $L269813
  000d3	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2823 : 						if( IsValidObj( pMover ) )

  000d6	85 c0		 test	 eax, eax
  000d8	74 14		 je	 SHORT $L269813
  000da	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000de	75 0e		 jne	 SHORT $L269813

; 2824 : 						{
; 2825 : 							JoinWar( (CUser*)pMover, pJoinPlayer->nMap );

  000e0	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000e3	6a 01		 push	 1
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	8b cd		 mov	 ecx, ebp
  000e9	e8 00 00 00 00	 call	 ?JoinWar@CGuildCombat@@QAEXPAVCUser@@HH@Z ; CGuildCombat::JoinWar
$L269813:
  000ee	8b 74 24 10	 mov	 esi, DWORD PTR _nVeci$269801[esp+32]
  000f2	43		 inc	 ebx
  000f3	e9 6c ff ff ff	 jmp	 $L269812
$L269804:

; 2804 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  000f8	46		 inc	 esi
  000f9	e9 0d ff ff ff	 jmp	 $L296215
$L296212:
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5d		 pop	 ebp
  00101	5b		 pop	 ebx

; 2826 : 						}
; 2827 : 					}
; 2828 : 				}
; 2829 : 			}
; 2830 : 		}
; 2831 : #else // __S_BUG_GC
; 2832 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2833 : 		if( ita != m_GuildCombatMem.end() )
; 2834 : 		{
; 2835 : 			__GuildCombatMember* pGCMember = ita->second;
; 2836 : 			for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 2837 : 			{
; 2838 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 2839 : 				if( pJoinPlayer->dwTelTime != 0 )
; 2840 : 				{
; 2841 : 					if( pJoinPlayer->dwTelTime + m_nMaxMapTime * 1000 <= timeGetTime()  )
; 2842 : 					{
; 2843 : 						pJoinPlayer->dwTelTime = 0;
; 2844 : 						CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );					
; 2845 : 						if( IsValidObj( pMover ) )
; 2846 : 						{
; 2847 : 							JoinWar( (CUser*)pMover, pJoinPlayer->nMap );
; 2848 : 						}
; 2849 : 					}
; 2850 : 				}
; 2851 : 			}
; 2852 : 		}
; 2853 : #endif // __S_BUG_GC
; 2854 : 	}
; 2855 : }

  00102	83 c4 10	 add	 esp, 16			; 00000010H
  00105	c3		 ret	 0
?ProcessJoinWar@CGuildCombat@@QAEXXZ ENDP		; CGuildCombat::ProcessJoinWar
_TEXT	ENDS
PUBLIC	?SendGCLog@CGuildCombat@@QAEXXZ			; CGuildCombat::SendGCLog
EXTRN	?AddGCLog@CUser@@QAEXXZ:NEAR			; CUser::AddGCLog
; Function compile flags: /Ogty
;	COMDAT ?SendGCLog@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
$T296418 = -12						; size = 4
_RequestGuild$269993 = -12				; size = 8
_i$296404 = -4						; size = 4
?SendGCLog@CGuildCombat@@QAEXXZ PROC NEAR		; CGuildCombat::SendGCLog, COMDAT
; _this$ = ecx

; 3219 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b e9		 mov	 ebp, ecx

; 3220 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00009	33 db		 xor	 ebx, ebx
  0000b	eb 03 8d 49 00	 npad	 5
$L269989:
  00010	8b 8d 14 11 00
	00		 mov	 ecx, DWORD PTR [ebp+4372]
  00016	85 c9		 test	 ecx, ecx
  00018	75 04		 jne	 SHORT $L296224
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 0b		 jmp	 SHORT $L296225
$L296224:
  0001e	8b 85 18 11 00
	00		 mov	 eax, DWORD PTR [ebp+4376]
  00024	2b c1		 sub	 eax, ecx
  00026	c1 f8 03	 sar	 eax, 3
$L296225:
  00029	3b d8		 cmp	 ebx, eax
  0002b	0f 8d 91 00 00
	00		 jge	 $L296433

; 3221 : 	{
; 3222 : 		if( nVeci >= m_nMaxGuild )

  00031	3b 9d a0 10 00
	00		 cmp	 ebx, DWORD PTR [ebp+4256]
  00037	0f 8d 85 00 00
	00		 jge	 $L296433
  0003d	8b 85 14 11 00
	00		 mov	 eax, DWORD PTR [ebp+4372]

; 3223 : 			break;
; 3224 : 		
; 3225 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  00043	8b 0c d8	 mov	 ecx, DWORD PTR [eax+ebx*8]
  00046	8b 54 d8 04	 mov	 edx, DWORD PTR [eax+ebx*8+4]
  0004a	8d 04 d8	 lea	 eax, DWORD PTR [eax+ebx*8]

; 3226 : #ifdef __S_BUG_GC
; 3227 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  0004d	51		 push	 ecx
  0004e	8b cd		 mov	 ecx, ebp
  00050	89 54 24 18	 mov	 DWORD PTR _RequestGuild$269993[esp+36], edx
  00054	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  00059	8b f0		 mov	 esi, eax

; 3228 : 		if( pGCMember != NULL )

  0005b	85 f6		 test	 esi, esi
  0005d	74 5d		 je	 SHORT $L269990

; 3229 : 		{
; 3230 : 			int nPoint = 0;
; 3231 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0005f	33 ff		 xor	 edi, edi
$L269999:
  00061	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00064	85 c9		 test	 ecx, ecx
  00066	75 04		 jne	 SHORT $L296287
  00068	33 c0		 xor	 eax, eax
  0006a	eb 08		 jmp	 SHORT $L296288
$L296287:
  0006c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0006f	2b c1		 sub	 eax, ecx
  00071	c1 f8 02	 sar	 eax, 2
$L296288:
  00074	3b f8		 cmp	 edi, eax
  00076	7d 44		 jge	 SHORT $L269990
  00078	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 3232 : 			{
; 3233 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  0007b	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]

; 3234 : 				CUser* pUser = (CUser*)prj.GetUserByID( pJoinPlayer->uidPlayer );

  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00083	8d 44 24 10	 lea	 eax, DWORD PTR $T296418[esp+28]
  00087	50		 push	 eax
  00088	8d 4c 24 1c	 lea	 ecx, DWORD PTR _i$296404[esp+32]
  0008c	51		 push	 ecx
  0008d	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00092	89 54 24 18	 mov	 DWORD PTR $T296418[esp+36], edx
  00096	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  0009b	8b 44 24 18	 mov	 eax, DWORD PTR _i$296404[esp+28]
  0009f	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  000a5	74 12		 je	 SHORT $L270000
  000a7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 3235 : 				if( IsValidObj( pUser ) )

  000aa	85 c9		 test	 ecx, ecx
  000ac	74 0b		 je	 SHORT $L270000
  000ae	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  000b2	75 05		 jne	 SHORT $L270000

; 3236 : 					pUser->AddGCLog();

  000b4	e8 00 00 00 00	 call	 ?AddGCLog@CUser@@QAEXXZ	; CUser::AddGCLog
$L270000:

; 3229 : 		{
; 3230 : 			int nPoint = 0;
; 3231 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  000b9	47		 inc	 edi
  000ba	eb a5		 jmp	 SHORT $L269999
$L269990:

; 3220 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  000bc	43		 inc	 ebx
  000bd	e9 4e ff ff ff	 jmp	 $L269989
$L296433:
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5d		 pop	 ebp
  000c5	5b		 pop	 ebx

; 3237 : 			}
; 3238 : 		}
; 3239 : #else // __S_BUG_GC
; 3240 : 		map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 3241 : 		if( it != m_GuildCombatMem.end() )
; 3242 : 		{
; 3243 : 			int nPoint = 0;
; 3244 : 			__GuildCombatMember* pGCMember = it->second;
; 3245 : 			for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 3246 : 			{
; 3247 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 3248 : 				CUser* pUser = (CUser*)prj.GetUserByID( pJoinPlayer->uidPlayer );
; 3249 : 				if( IsValidObj( pUser ) )
; 3250 : 				{
; 3251 : 					pUser->AddGCLog();
; 3252 : 				}
; 3253 : 			}
; 3254 : 		}
; 3255 : #endif // __S_BUG_GC
; 3256 : 	}
; 3257 : }

  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	c3		 ret	 0
?SendGCLog@CGuildCombat@@QAEXXZ ENDP			; CGuildCombat::SendGCLog
_TEXT	ENDS
PUBLIC	??1?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::~vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::~vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296449
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296449:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::~vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296462
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296462:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::~vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::~vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296477
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296477:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::~vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296491
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296491:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::~vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::~vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296503
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296503:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::~vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296517
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296517:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::~vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::~vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296531
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296531:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::~vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296545
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296545:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::~vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::~vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296559
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296559:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::~vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L296573
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L296573:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 745  : 		}

  00029	c3		 ret	 0
?clear@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::clear
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T296679 DD	0ffffffffH
	DD	FLAT:$L296579
$T296677 DD	019930520H
	DD	01H
	DD	FLAT:$T296679
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	e8 00 00 00 00	 call	 ??0exception@@QAE@XZ	; exception::exception
  00022	33 c0		 xor	 eax, eax
  00024	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	6a ff		 push	 -1
  0002f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00032	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00039	50		 push	 eax
  0003a	89 44 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], eax
  0003e	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00041	8b 44 24 20	 mov	 eax, DWORD PTR __Message$[esp+24]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 20   : 		}

  0004b	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L296579:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T296677
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogty
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L296689
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L296689:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L296777
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L296777:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:NEAR		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 118  : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7out_of_range@std@@6B@

; 119  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogty
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC NEAR		; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1out_of_range@std@@UAE@XZ ; std::out_of_range::~out_of_range
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L296803
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L296803:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC NEAR			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 122  : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L296892
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L296892:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
PUBLIC	??$fill@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABV12@@Z ; std::fill<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABV12@@Z PROC NEAR ; std::fill<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	56		 push	 esi

; 1135 : 	for (; _First != _Last; ++_First)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 15		 je	 SHORT $L278087
  0000e	53		 push	 ebx
  0000f	8b 5c 24 18	 mov	 ebx, DWORD PTR __Val$[esp+8]
$L278085:

; 1136 : 		*_First = _Val;

  00013	53		 push	 ebx
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
  0001b	83 c6 04	 add	 esi, 4
  0001e	3b f7		 cmp	 esi, edi
  00020	75 f1		 jne	 SHORT $L278085
  00022	5b		 pop	 ebx
$L278087:
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 1137 : 	}

  00025	c3		 ret	 0
??$fill@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABV12@@Z ENDP ; std::fill<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T297200 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L296929
	DD	0ffffffffH
	DD	00H
$T297202 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L296922
$T297201 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T297202
$T297194 DD	019930520H
	DD	03H
	DD	FLAT:$T297200
	DD	01H
	DD	FLAT:$T297201
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T297110 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	53		 push	 ebx

; 208  : 	_FwdIt _Next = _First;

  0001c	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00024	89 5d ec	 mov	 DWORD PTR __Next$[ebp], ebx

; 209  : 
; 210  : 	_TRY_BEGIN

  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0002e	8b ff		 npad	 2
$L278791:

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00033	85 c0		 test	 eax, eax
  00035	0f 86 c1 00 00
	00		 jbe	 $L278793

; 212  : 		_Al.construct(_First, _Val);

  0003b	89 5d e8	 mov	 DWORD PTR $T297110[ebp], ebx
  0003e	85 db		 test	 ebx, ebx
  00040	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00044	74 63		 je	 SHORT $L297111
  00046	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00049	8b 30		 mov	 esi, DWORD PTR [eax]
  0004b	8b 4e f0	 mov	 ecx, DWORD PTR [esi-16]
  0004e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00050	83 ee 10	 sub	 esi, 16			; 00000010H
  00053	ff 52 10	 call	 DWORD PTR [edx+16]
  00056	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00059	85 d2		 test	 edx, edx
  0005b	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0005e	7c 11		 jl	 SHORT $L297104
  00060	3b 06		 cmp	 eax, DWORD PTR [esi]
  00062	75 0d		 jne	 SHORT $L297104
  00064	8b c6		 mov	 eax, esi
  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0006f	eb 33		 jmp	 SHORT $L297089
$L297104:
  00071	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	6a 01		 push	 1
  00078	51		 push	 ecx
  00079	8b c8		 mov	 ecx, eax
  0007b	ff 12		 call	 DWORD PTR [edx]
  0007d	85 c0		 test	 eax, eax
  0007f	75 05		 jne	 SHORT $L297079
  00081	e9 00 00 00 00	 jmp	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L297079:
  00086	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00089	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0008c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008f	41		 inc	 ecx
  00090	8b d1		 mov	 edx, ecx
  00092	c1 e9 02	 shr	 ecx, 2
  00095	83 c6 10	 add	 esi, 16			; 00000010H
  00098	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0009b	f3 a5		 rep movsd
  0009d	8b ca		 mov	 ecx, edx
  0009f	83 e1 03	 and	 ecx, 3
  000a2	f3 a4		 rep movsb
$L297089:
  000a4	83 c0 10	 add	 eax, 16			; 00000010H
  000a7	89 03		 mov	 DWORD PTR [ebx], eax
$L297111:
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  000ac	49		 dec	 ecx
  000ad	83 c3 04	 add	 ebx, 4
  000b0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  000b4	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  000b7	89 5d 08	 mov	 DWORD PTR __First$[ebp], ebx
  000ba	e9 71 ff ff ff	 jmp	 $L278791
$L296922:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  000bf	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  000c2	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  000c5	3b f7		 cmp	 esi, edi
  000c7	74 2a		 je	 SHORT $L278796
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$L278794:

; 215  : 		_Al.destroy(_Next);

  000d0	8b 06		 mov	 eax, DWORD PTR [esi]
  000d2	83 e8 10	 sub	 eax, 16			; 00000010H
  000d5	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  000d8	83 ca ff	 or	 edx, -1
  000db	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000df	4a		 dec	 edx
  000e0	85 d2		 test	 edx, edx
  000e2	7f 08		 jg	 SHORT $L297186
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e8	50		 push	 eax
  000e9	ff 52 04	 call	 DWORD PTR [edx+4]
$L297186:
  000ec	83 c6 04	 add	 esi, 4
  000ef	3b f7		 cmp	 esi, edi
  000f1	75 dd		 jne	 SHORT $L278794
$L278796:

; 216  : 	_RERAISE;

  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	e8 00 00 00 00	 call	 __CxxThrowException@8
$L297203:
$L278793:

; 217  : 	_CATCH_END
; 218  : 	}

  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00108	5b		 pop	 ebx
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$L297199:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L296929:
  00000	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00003	50		 push	 eax
  00004	8b 4d e8	 mov	 ecx, DWORD PTR $T297110[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T297194
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
PUBLIC	??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	56		 push	 esi

; 225  : 	for (; _First != _Last; ++_First)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 10		 je	 SHORT $L279091
  0000e	8b ff		 npad	 2
$L279089:

; 226  : 		_Al.destroy(_First);

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  00017	83 c6 04	 add	 esi, 4
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $L279089
$L279091:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 227  : 	}

  00020	c3		 ret	 0
??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z ; std::_Uninitialized_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z
_TEXT	SEGMENT
__Cat$297234 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$297234[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z ENDP ; std::_Uninitialized_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
_pNewData$297331 = 16					; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>, COMDAT

; 1049 : 	while (_First != _Last)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	55		 push	 ebp
  00005	8b 6c 24 0c	 mov	 ebp, DWORD PTR __Last$[esp]
  00009	3b c5		 cmp	 eax, ebp
  0000b	74 72		 je	 SHORT $L297334
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b 7c 24 1c	 mov	 edi, DWORD PTR __Dest$[esp+12]
$L279134:

; 1050 : 		*--_Dest = *--_Last;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR [ebp-4]
  00017	8b 77 fc	 mov	 esi, DWORD PTR [edi-4]
  0001a	83 ed 04	 sub	 ebp, 4
  0001d	83 ef 04	 sub	 edi, 4
  00020	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  00023	83 ee 10	 sub	 esi, 16			; 00000010H
  00026	3b c6		 cmp	 eax, esi
  00028	74 48		 je	 SHORT $L297320
  0002a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0002d	85 d2		 test	 edx, edx
  0002f	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  00032	7c 32		 jl	 SHORT $L297329
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	3b 16		 cmp	 edx, DWORD PTR [esi]
  00038	75 2c		 jne	 SHORT $L297329
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00040	89 44 24 20	 mov	 DWORD PTR _pNewData$297331[esp+16], eax
  00044	83 c4 04	 add	 esp, 4
  00047	83 c8 ff	 or	 eax, -1
  0004a	f0 0f c1 03	 lock	  xadd	 DWORD PTR [ebx], eax
  0004e	48		 dec	 eax
  0004f	85 c0		 test	 eax, eax
  00051	7f 08		 jg	 SHORT $L297319
  00053	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	56		 push	 esi
  00058	ff 52 04	 call	 DWORD PTR [edx+4]
$L297319:
  0005b	8b 44 24 1c	 mov	 eax, DWORD PTR _pNewData$297331[esp+12]
  0005f	83 c0 10	 add	 eax, 16			; 00000010H
  00062	89 07		 mov	 DWORD PTR [edi], eax
  00064	eb 0c		 jmp	 SHORT $L297320
$L297329:
  00066	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  00069	52		 push	 edx
  0006a	51		 push	 ecx
  0006b	8b cf		 mov	 ecx, edi
  0006d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
$L297320:
  00072	3b 6c 24 14	 cmp	 ebp, DWORD PTR __First$[esp+12]
  00076	75 9c		 jne	 SHORT $L279134

; 1051 : 	return (_Dest);

  00078	8b c7		 mov	 eax, edi
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp

; 1052 : 	}

  0007e	c3		 ret	 0
$L297334:

; 1051 : 	return (_Dest);

  0007f	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00083	5d		 pop	 ebp

; 1052 : 	}

  00084	c3		 ret	 0
??$_Copy_backward_opt@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
_TEXT	ENDS
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 983  : 		CThisSimpleString::operator=( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L297355
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 986  : 	}

  00017	c2 04 00	 ret	 4

; 983  : 		CThisSimpleString::operator=( pszSrc );

$L297355:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L297357:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L297357
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 986  : 	}

  00036	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 361  : 		_Tidy();
; 362  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b c2		 mov	 eax, edx
  00009	57		 push	 edi
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$L297433:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L297433
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 363  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T297554 DD	0ffffffffH
	DD	FLAT:$L297439
$T297551 DD	019930520H
	DD	01H
	DD	FLAT:$T297554
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T297438 = -80						; size = 28
$T297437 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T297438[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T297438[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T297438[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T297438[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T297438[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T297437[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T297437[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T297437[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L297555:
$L297553:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L297439:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T297438[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T297551
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
;	COMDAT xdata$x
xdata$x	SEGMENT
$T297661 DD	0ffffffffH
	DD	FLAT:$L297561
$T297659 DD	019930520H
	DD	01H
	DD	FLAT:$T297661
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	e8 00 00 00 00	 call	 ??0exception@@QAE@ABV0@@Z ; exception::exception
  00028	33 c0		 xor	 eax, eax
  0002a	6a ff		 push	 -1
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	50		 push	 eax
  00036	83 c7 0c	 add	 edi, 12			; 0000000cH
  00039	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00040	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00043	57		 push	 edi
  00044	89 44 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], eax
  00048	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00054	5f		 pop	 edi
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L297561:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T297659
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogty
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T297788 DD	0ffffffffH
	DD	FLAT:$L297673
$T297785 DD	019930520H
	DD	01H
	DD	FLAT:$T297788
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T297672 = -80						; size = 28
$T297671 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T297672[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T297672[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T297672[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T297672[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T297672[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T297671[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T297671[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T297671[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L297789:
$L297787:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L297673:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T297672[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T297785
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T298287 DD	0ffffffffH
	DD	FLAT:$L297801
$T298279 DD	019930520H
	DD	01H
	DD	FLAT:$T298287
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_DATA	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T297796 = -80						; size = 28
$T297795 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 590  : 		{	// erase element at _Where

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  0000d	50		 push	 eax

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 44 24 14	 mov	 eax, DWORD PTR __Where$[esp+8]
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	83 ec 48	 sub	 esp, 72			; 00000048H
  0001c	55		 push	 ebp
  0001d	8b e9		 mov	 ebp, ecx
  0001f	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00022	84 c9		 test	 cl, cl
  00024	56		 push	 esi
  00025	74 4c		 je	 SHORT $L223116

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00027	6a 1b		 push	 27			; 0000001bH
  00029	33 f6		 xor	 esi, esi
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00030	8d 4c 24 14	 lea	 ecx, DWORD PTR $T297796[esp+100]
  00034	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T297796[esp+124], 15 ; 0000000fH
  0003c	89 74 24 28	 mov	 DWORD PTR $T297796[esp+120], esi
  00040	c6 44 24 18 00	 mov	 BYTE PTR $T297796[esp+104], 0
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T297796[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T297795[esp+96]
  00053	89 74 24 5c	 mov	 DWORD PTR __$EHRec$[esp+104], esi
  00057	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  00061	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T297795[esp+96]
  00065	51		 push	 ecx
  00066	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T297795[esp+100], OFFSET FLAT:??_7out_of_range@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$L298288:
$L223116:
  00073	53		 push	 ebx

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  00074	8b d8		 mov	 ebx, eax
  00076	57		 push	 edi

; 594  : 		++_Where;	// save successor iterator for return

  00077	8d 4c 24 6c	 lea	 ecx, DWORD PTR __Where$[esp+96]
  0007b	89 5c 24 10	 mov	 DWORD PTR __Erasednode$[esp+100], ebx
  0007f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00084	8b 03		 mov	 eax, DWORD PTR [ebx]
  00086	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00089	84 c9		 test	 cl, cl
  0008b	74 05		 je	 SHORT $L223124

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0008d	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  00090	eb 19		 jmp	 SHORT $L298282
$L223124:
  00092	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00095	8a 4a 15	 mov	 cl, BYTE PTR [edx+21]
  00098	84 c9		 test	 cl, cl
  0009a	74 04		 je	 SHORT $L223126

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  0009c	8b f8		 mov	 edi, eax

; 604  : 		else

  0009e	eb 0b		 jmp	 SHORT $L298282
$L223126:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  000a0	8b 4c 24 6c	 mov	 ecx, DWORD PTR __Where$[esp+96]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  000a4	3b cb		 cmp	 ecx, ebx
  000a6	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  000a9	75 6e		 jne	 SHORT $L223128
$L298282:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  000ab	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000ae	84 c0		 test	 al, al
  000b0	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000b3	75 03		 jne	 SHORT $L223129

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000b5	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L223129:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  000b8	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  000bb	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  000be	75 05		 jne	 SHORT $L223130

; 617  : 				_Root() = _Fixnode;	// link down from root

  000c0	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  000c3	eb 0b		 jmp	 SHORT $L223133
$L223130:
  000c5	39 1e		 cmp	 DWORD PTR [esi], ebx
  000c7	75 04		 jne	 SHORT $L223132

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  000c9	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  000cb	eb 03		 jmp	 SHORT $L223133
$L223132:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  000cd	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L223133:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  000d0	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000d3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d5	3b 44 24 10	 cmp	 eax, DWORD PTR __Erasednode$[esp+100]
  000d9	75 16		 jne	 SHORT $L223134

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000db	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  000de	84 c0		 test	 al, al
  000e0	74 04		 je	 SHORT $L297797
  000e2	8b c6		 mov	 eax, esi
  000e4	eb 09		 jmp	 SHORT $L297798
$L297797:
  000e6	57		 push	 edi
  000e7	e8 00 00 00 00	 call	 ?_Min@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Min
  000ec	83 c4 04	 add	 esp, 4
$L297798:
  000ef	89 03		 mov	 DWORD PTR [ebx], eax
$L223134:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000f1	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  000f4	8b 4c 24 10	 mov	 ecx, DWORD PTR __Erasednode$[esp+100]
  000f8	39 4b 08	 cmp	 DWORD PTR [ebx+8], ecx
  000fb	75 74		 jne	 SHORT $L298116

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000fd	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  00100	84 c0		 test	 al, al
  00102	74 07		 je	 SHORT $L297799
  00104	8b c6		 mov	 eax, esi
  00106	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00109	eb 66		 jmp	 SHORT $L298116
$L297799:

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 ?_Max@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Max
  00111	83 c4 04	 add	 esp, 4
  00114	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

  00117	eb 58		 jmp	 SHORT $L298116
$L223128:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  00119	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  0011c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0011e	89 11		 mov	 DWORD PTR [ecx], edx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  00120	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  00123	75 04		 jne	 SHORT $L223137

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00125	8b f1		 mov	 esi, ecx

; 640  : 			else

  00127	eb 1b		 jmp	 SHORT $L223138
$L223137:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  00129	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0012c	84 c0		 test	 al, al
  0012e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00131	75 03		 jne	 SHORT $L223139

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00133	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L223139:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00136	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  00138	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0013b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  0013e	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00141	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L223138:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00144	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00147	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0014a	75 05		 jne	 SHORT $L223140

; 651  : 				_Root() = _Pnode;	// link down from root

  0014c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  0014f	eb 0e		 jmp	 SHORT $L223143
$L223140:
  00151	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00154	39 18		 cmp	 DWORD PTR [eax], ebx
  00156	75 04		 jne	 SHORT $L223142

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  00158	89 08		 mov	 DWORD PTR [eax], ecx

; 654  : 			else

  0015a	eb 03		 jmp	 SHORT $L223143
$L223142:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  0015c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L223143:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  0015f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00162	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  00165	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  00168	8a 41 14	 mov	 al, BYTE PTR [ecx+20]
  0016b	88 51 14	 mov	 BYTE PTR [ecx+20], dl
  0016e	88 43 14	 mov	 BYTE PTR [ebx+20], al
$L298116:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00171	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00175	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00178	b3 01		 mov	 bl, 1
  0017a	3a cb		 cmp	 cl, bl
  0017c	0f 85 ff 00 00
	00		 jne	 $L223144

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00182	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00185	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  00188	0f 84 f0 00 00
	00		 je	 $L223147
  0018e	8b ff		 npad	 2
$L223145:
  00190	38 5f 14	 cmp	 BYTE PTR [edi+20], bl
  00193	0f 85 e5 00 00
	00		 jne	 $L223147

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00199	8b 06		 mov	 eax, DWORD PTR [esi]
  0019b	3b f8		 cmp	 edi, eax
  0019d	75 67		 jne	 SHORT $L223148

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  0019f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  001a2	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  001a5	84 c9		 test	 cl, cl
  001a7	75 12		 jne	 SHORT $L223149

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;

  001a9	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  001ac	56		 push	 esi
  001ad	8b cd		 mov	 ecx, ebp
  001af	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001b3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  001b8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L223149:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  001bb	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  001be	84 c9		 test	 cl, cl

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  001c0	75 76		 jne	 SHORT $L298285

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  001c2	8b 10		 mov	 edx, DWORD PTR [eax]
  001c4	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  001c7	75 08		 jne	 SHORT $L223152
  001c9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001cc	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001cf	74 63		 je	 SHORT $L298286
$L223152:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  001d1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d4	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  001d7	75 14		 jne	 SHORT $L223154

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001d9	8b 10		 mov	 edx, DWORD PTR [eax]
  001db	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001de	50		 push	 eax
  001df	8b cd		 mov	 ecx, ebp
  001e1	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  001e5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ea	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L223154:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001ed	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  001f0	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 695  : 						_Color(_Fixnodeparent) = _Black;

  001f3	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 696  : 						_Color(_Right(_Pnode)) = _Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 697  : 						_Lrotate(_Fixnodeparent);

  001f9	56		 push	 esi
  001fa	8b cd		 mov	 ecx, ebp
  001fc	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  001ff	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  00204	eb 78		 jmp	 SHORT $L223147
$L223148:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  00206	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00209	84 c9		 test	 cl, cl
  0020b	75 11		 jne	 SHORT $L223156

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;

  0020d	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  00210	56		 push	 esi
  00211	8b cd		 mov	 ecx, ebp
  00213	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00217	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  0021c	8b 06		 mov	 eax, DWORD PTR [esi]
$L223156:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  0021e	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00221	84 c9		 test	 cl, cl

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  00223	75 13		 jne	 SHORT $L298285

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  00225	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00228	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  0022b	75 20		 jne	 SHORT $L223159
  0022d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00232	75 19		 jne	 SHORT $L223159
$L298286:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  00234	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
$L298285:

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00238	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  0023b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 717  : 						_Fixnode = _Fixnodeparent;

  0023e	8b fe		 mov	 edi, esi
  00240	3b f8		 cmp	 edi, eax
  00242	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00245	0f 85 45 ff ff
	ff		 jne	 $L223145

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  0024b	eb 31		 jmp	 SHORT $L223147
$L223159:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  0024d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024f	38 59 14	 cmp	 BYTE PTR [ecx+20], bl
  00252	75 14		 jne	 SHORT $L223161

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00254	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00257	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  0025a	50		 push	 eax
  0025b	8b cd		 mov	 ecx, ebp
  0025d	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  00261	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00266	8b 06		 mov	 eax, DWORD PTR [esi]
$L223161:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00268	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  0026b	88 48 14	 mov	 BYTE PTR [eax+20], cl

; 730  : 						_Color(_Fixnodeparent) = _Black;

  0026e	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 731  : 						_Color(_Left(_Pnode)) = _Black;

  00271	8b 10		 mov	 edx, DWORD PTR [eax]

; 732  : 						_Rrotate(_Fixnodeparent);

  00273	56		 push	 esi
  00274	8b cd		 mov	 ecx, ebp
  00276	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  00279	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate
$L223147:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0027e	88 5f 14	 mov	 BYTE PTR [edi+20], bl
$L223144:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00281	8b 44 24 10	 mov	 eax, DWORD PTR __Erasednode$[esp+100]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 742  : 
; 743  : 		if (0 < _Mysize)

  0028b	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  0028e	83 c4 04	 add	 esp, 4
  00291	85 c0		 test	 eax, eax
  00293	5f		 pop	 edi
  00294	5b		 pop	 ebx
  00295	76 04		 jbe	 SHORT $L223162

; 744  : 			--_Mysize;

  00297	48		 dec	 eax
  00298	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L223162:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0029b	8b 4c 24 64	 mov	 ecx, DWORD PTR __Where$[esp+88]
  0029f	8b 44 24 60	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+88]
  002a3	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  002a5	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  002a9	5e		 pop	 esi
  002aa	5d		 pop	 ebp
  002ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002b2	83 c4 54	 add	 esp, 84			; 00000054H
  002b5	c2 08 00	 ret	 8
$L298284:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L297801:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T297796[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T298279
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
; Function compile flags: /Ogty
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC NEAR		; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7out_of_range@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?GuildCombatClear@CGuildCombat@@QAEXH@Z		; CGuildCombat::GuildCombatClear
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
;	COMDAT ?GuildCombatClear@CGuildCombat@@QAEXH@Z
_TEXT	SEGMENT
_nState$ = 8						; size = 4
?GuildCombatClear@CGuildCombat@@QAEXH@Z PROC NEAR	; CGuildCombat::GuildCombatClear, COMDAT
; _this$ = ecx

; 329  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 330  : 	m_nState = CLOSE_STATE;
; 331  : 	m_nGCState = WAR_CLOSE_STATE;
; 332  : 
; 333  : 	if( nState == 99 || nState == 1 )

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _nState$[esp+8]
  00007	8b f1		 mov	 esi, ecx
  00009	33 db		 xor	 ebx, ebx
  0000b	83 ff 63	 cmp	 edi, 99			; 00000063H
  0000e	c7 86 40 11 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4416], 1
  00018	c7 86 44 11 00
	00 69 00 00 00	 mov	 DWORD PTR [esi+4420], 105 ; 00000069H
  00022	74 05		 je	 SHORT $L268331
  00024	83 ff 01	 cmp	 edi, 1
  00027	75 0c		 jne	 SHORT $L268330
$L268331:

; 334  : 	{
; 335  : 		m_nGuildCombatIndex = 0;

  00029	89 5e 40	 mov	 DWORD PTR [esi+64], ebx

; 336  : 		m_uWinGuildId = 0;

  0002c	89 5e 44	 mov	 DWORD PTR [esi+68], ebx

; 337  : 		m_nWinGuildCount = 0;

  0002f	89 5e 48	 mov	 DWORD PTR [esi+72], ebx

; 338  : 		m_uBestPlayer = 0;

  00032	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
$L268330:

; 339  : 	}	
; 340  : 
; 341  : 	m_vecGCGetPoint.clear();

  00035	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00038	3b c3		 cmp	 eax, ebx
  0003a	74 09		 je	 SHORT $L298317
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00042	83 c4 04	 add	 esp, 4
$L298317:
  00045	55		 push	 ebp
  00046	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  00049	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  0004c	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx

; 342  : #ifdef __WORLDSERVER
; 343  : 
; 344  : #ifdef __S_BUG_GC
; 345  : 	for( int gcmi = 0 ; gcmi < (int)( m_vecGuildCombatMem.size() ) ; ++gcmi )

  0004f	33 ed		 xor	 ebp, ebp
$L268334:
  00051	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00054	3b cb		 cmp	 ecx, ebx
  00056	75 04		 jne	 SHORT $L298326
  00058	33 c0		 xor	 eax, eax
  0005a	eb 08		 jmp	 SHORT $L298327
$L298326:
  0005c	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0005f	2b c1		 sub	 eax, ecx
  00061	c1 f8 02	 sar	 eax, 2
$L298327:
  00064	3b e8		 cmp	 ebp, eax
  00066	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00069	7d 21		 jge	 SHORT $L268336

; 346  : 		safe_delete( m_vecGuildCombatMem[gcmi] );

  0006b	8b 3c a8	 mov	 edi, DWORD PTR [eax+ebp*4]
  0006e	3b fb		 cmp	 edi, ebx
  00070	8d 04 a8	 lea	 eax, DWORD PTR [eax+ebp*4]
  00073	74 10		 je	 SHORT $L268335
  00075	8b cf		 mov	 ecx, edi
  00077	e8 00 00 00 00	 call	 ??1__GuildCombatMember@CGuildCombat@@QAE@XZ
  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00082	83 c4 04	 add	 esp, 4
$L268335:
  00085	8b 7c 24 14	 mov	 edi, DWORD PTR _nState$[esp+12]
  00089	45		 inc	 ebp
  0008a	eb c5		 jmp	 SHORT $L268334
$L268336:

; 347  : 	m_vecGuildCombatMem.clear();

  0008c	3b c3		 cmp	 eax, ebx
  0008e	5d		 pop	 ebp
  0008f	74 09		 je	 SHORT $L298404
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00097	83 c4 04	 add	 esp, 4
$L298404:
  0009a	89 5e 74	 mov	 DWORD PTR [esi+116], ebx
  0009d	89 5e 78	 mov	 DWORD PTR [esi+120], ebx
  000a0	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx

; 348  : #else // __S_BUG_GC
; 349  : 	for( map<u_long, __GuildCombatMember*>::iterator i = m_GuildCombatMem.begin(); i != m_GuildCombatMem.end(); ++i )
; 350  : 		safe_delete( i->second );
; 351  : 	m_GuildCombatMem.clear();
; 352  : #endif // __S_BUG_GC
; 353  : 	vecRequestRanking.clear();

  000a3	8b 86 14 11 00
	00		 mov	 eax, DWORD PTR [esi+4372]
  000a9	3b c3		 cmp	 eax, ebx
  000ab	74 09		 je	 SHORT $L298425
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b3	83 c4 04	 add	 esp, 4
$L298425:
  000b6	89 9e 14 11 00
	00		 mov	 DWORD PTR [esi+4372], ebx
  000bc	89 9e 18 11 00
	00		 mov	 DWORD PTR [esi+4376], ebx
  000c2	89 9e 1c 11 00
	00		 mov	 DWORD PTR [esi+4380], ebx

; 354  : 	m_dwTime = 0;
; 355  : 	m_nStopWar = 0;
; 356  : 	if( g_eLocal.GetState( EVE_GUILDCOMBAT ) )

  000c8	6a 0f		 push	 15			; 0000000fH
  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  000cf	89 9e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ebx
  000d5	89 9e 8c 10 00
	00		 mov	 DWORD PTR [esi+4236], ebx
  000db	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  000e0	84 c0		 test	 al, al
  000e2	74 0c		 je	 SHORT $L268340

; 357  : 		g_DPCoreClient.SendGuildCombatState( CLOSE_STATE );		

  000e4	6a 01		 push	 1
  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  000eb	e8 00 00 00 00	 call	 ?SendGuildCombatState@CDPCoreClient@@QAEXH@Z ; CDPCoreClient::SendGuildCombatState
$L268340:

; 358  : 
; 359  : 	if( nState == 99 || nState == 3 )

  000f0	83 ff 63	 cmp	 edi, 99			; 00000063H
  000f3	74 05		 je	 SHORT $L268342
  000f5	83 ff 03	 cmp	 edi, 3
  000f8	75 3c		 jne	 SHORT $L268341
$L268342:

; 360  : 	{
; 361  : 		m_nJoinPanya = 0;

  000fa	89 9e 90 10 00
	00		 mov	 DWORD PTR [esi+4240], ebx

; 362  : 		m_nGuildLevel = 0;

  00100	89 9e 94 10 00
	00		 mov	 DWORD PTR [esi+4244], ebx

; 363  : 		m_nMaxJoinMember = 0;

  00106	89 9e a4 10 00
	00		 mov	 DWORD PTR [esi+4260], ebx

; 364  : 		m_nMaxPlayerLife = 0;

  0010c	89 9e a8 10 00
	00		 mov	 DWORD PTR [esi+4264], ebx

; 365  : 		m_nMaxWarPlayer = 0;

  00112	89 9e ac 10 00
	00		 mov	 DWORD PTR [esi+4268], ebx

; 366  : 		m_nMaxPlayerPercent = 0;

  00118	89 9e b8 10 00
	00		 mov	 DWORD PTR [esi+4280], ebx

; 367  : 		m_nMaxGuildPercent = 0;

  0011e	89 9e b4 10 00
	00		 mov	 DWORD PTR [esi+4276], ebx

; 368  : 		m_nRequestCanclePercent = 0;

  00124	89 9e bc 10 00
	00		 mov	 DWORD PTR [esi+4284], ebx

; 369  : 		m_nNotRequestPercent = 0;

  0012a	89 9e c0 10 00
	00		 mov	 DWORD PTR [esi+4288], ebx

; 370  : 		m_nItemPenya = 0;

  00130	89 9e c4 10 00
	00		 mov	 DWORD PTR [esi+4292], ebx
$L268341:
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx

; 371  : 	}
; 372  : #endif // __WORLDSERVER
; 373  : #ifdef __CLIENT
; 374  : 	m_bRequest = FALSE;
; 375  : #endif // __CLIENT
; 376  : }

  00139	c2 04 00	 ret	 4
?GuildCombatClear@CGuildCombat@@QAEXH@Z ENDP		; CGuildCombat::GuildCombatClear
_TEXT	ENDS
PUBLIC	?GuildCombatGameClear@CGuildCombat@@QAEXXZ	; CGuildCombat::GuildCombatGameClear
; Function compile flags: /Ogty
;	COMDAT ?GuildCombatGameClear@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
?GuildCombatGameClear@CGuildCombat@@QAEXXZ PROC NEAR	; CGuildCombat::GuildCombatGameClear, COMDAT
; _this$ = ecx

; 380  : 	GuildCombatClear( 2 );

  00000	6a 02		 push	 2
  00002	e8 00 00 00 00	 call	 ?GuildCombatClear@CGuildCombat@@QAEXH@Z ; CGuildCombat::GuildCombatClear

; 381  : }

  00007	c3		 ret	 0
?GuildCombatGameClear@CGuildCombat@@QAEXXZ ENDP		; CGuildCombat::GuildCombatGameClear
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Insert
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T298808 DD	0ffffffffH
	DD	FLAT:$L298438
$T298803 DD	019930520H
	DD	01H
	DD	FLAT:$T298808
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z
_TEXT	SEGMENT
$T298437 = -80						; size = 28
$T298436 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b f9		 mov	 edi, ecx

; 912  : 		if (max_size() - 1 <= _Mysize)

  0001c	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00023	72 4c		 jb	 SHORT $L272611

; 913  : 			_THROW(length_error, "map/set<T> too long");

  00025	6a 13		 push	 19			; 00000013H
  00027	33 f6		 xor	 esi, esi
  00029	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0002e	8d 4c 24 10	 lea	 ecx, DWORD PTR $T298437[esp+96]
  00032	c7 44 24 28 0f
	00 00 00	 mov	 DWORD PTR $T298437[esp+120], 15 ; 0000000fH
  0003a	89 74 24 24	 mov	 DWORD PTR $T298437[esp+116], esi
  0003e	c6 44 24 14 00	 mov	 BYTE PTR $T298437[esp+100], 0
  00043	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00048	8d 44 24 08	 lea	 eax, DWORD PTR $T298437[esp+88]
  0004c	50		 push	 eax
  0004d	8d 4c 24 28	 lea	 ecx, DWORD PTR $T298436[esp+92]
  00051	89 74 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], esi
  00055	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0005f	8d 4c 24 28	 lea	 ecx, DWORD PTR $T298436[esp+92]
  00063	51		 push	 ecx
  00064	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T298436[esp+96], OFFSET FLAT:??_7length_error@std@@6B@
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$L298809:
$L272611:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  00071	8b 54 24 68	 mov	 edx, DWORD PTR __Val$[esp+84]
  00075	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00078	8b 74 24 64	 mov	 esi, DWORD PTR __Wherenode$[esp+84]
  0007c	53		 push	 ebx
  0007d	6a 00		 push	 0
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	56		 push	 esi
  00082	50		 push	 eax
  00083	8b cf		 mov	 ecx, edi
  00085	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0008a	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0008d	8b c8		 mov	 ecx, eax

; 918  : 		if (_Wherenode == _Myhead)

  0008f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00092	43		 inc	 ebx
  00093	3b f0		 cmp	 esi, eax
  00095	89 4c 24 6c	 mov	 DWORD PTR __Newnode$[esp+88], ecx
  00099	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0009c	75 10		 jne	 SHORT $L272616

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  0009e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  000a1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
  000a6	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000a9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 922  : 			}
; 923  : 		else if (_Addleft)

  000ac	eb 23		 jmp	 SHORT $L272621
$L272616:
  000ae	8a 44 24 64	 mov	 al, BYTE PTR __Addleft$[esp+88]
  000b2	84 c0		 test	 al, al
  000b4	74 0d		 je	 SHORT $L272618

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  000b6	89 0e		 mov	 DWORD PTR [esi], ecx

; 926  : 			if (_Wherenode == _Lmost())

  000b8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000bb	3b 30		 cmp	 esi, DWORD PTR [eax]
  000bd	75 12		 jne	 SHORT $L272621

; 927  : 				_Lmost() = _Newnode;

  000bf	89 08		 mov	 DWORD PTR [eax], ecx

; 928  : 			}
; 929  : 		else

  000c1	eb 0e		 jmp	 SHORT $L272621
$L272618:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  000c3	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 932  : 			if (_Wherenode == _Rmost())

  000c6	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c9	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  000cc	75 03		 jne	 SHORT $L272621

; 933  : 				_Rmost() = _Newnode;

  000ce	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L272621:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  000d1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d4	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000d8	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  000db	8b f1		 mov	 esi, ecx
  000dd	b3 01		 mov	 bl, 1
  000df	0f 85 a5 00 00
	00		 jne	 $L272625
  000e5	55		 push	 ebp
$L272624:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  000eb	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  000ee	3b ca		 cmp	 ecx, edx
  000f0	75 50		 jne	 SHORT $L272626

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000f2	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000f5	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000f9	75 18		 jne	 SHORT $L272627
$L298807:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fd	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 943  : 					_Color(_Wherenode) = _Black;

  00100	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00103	8b 10		 mov	 edx, DWORD PTR [eax]
  00105	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00108	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
  0010e	8b 72 04	 mov	 esi, DWORD PTR [edx+4]

; 946  : 					}
; 947  : 				else

  00111	eb 61		 jmp	 SHORT $L272632
$L272627:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  00113	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  00116	75 0a		 jne	 SHORT $L272629

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);

  00118	8b f1		 mov	 esi, ecx

; 952  : 						_Lrotate(_Pnode);

  0011a	56		 push	 esi
  0011b	8b cf		 mov	 ecx, edi
  0011d	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate
$L272629:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  00122	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00125	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00128	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	c6 42 14 00	 mov	 BYTE PTR [edx+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  00132	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00135	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00138	51		 push	 ecx
  00139	8b cf		 mov	 ecx, edi
  0013b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  00140	eb 32		 jmp	 SHORT $L272632
$L272626:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  00142	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00146	74 b3		 je	 SHORT $L298807

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00148	3b 31		 cmp	 esi, DWORD PTR [ecx]
  0014a	75 0a		 jne	 SHORT $L272633

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);

  0014c	8b f1		 mov	 esi, ecx

; 974  : 						_Rrotate(_Pnode);

  0014e	56		 push	 esi
  0014f	8b cf		 mov	 ecx, edi
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Rrotate
$L272633:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  00156	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00159	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  0015c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0015f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00162	c6 42 14 00	 mov	 BYTE PTR [edx+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00166	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00169	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016c	51		 push	 ecx
  0016d	8b cf		 mov	 ecx, edi
  0016f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Lrotate
$L272632:
  00174	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00177	8a 4a 14	 mov	 cl, BYTE PTR [edx+20]
  0017a	84 c9		 test	 cl, cl
  0017c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0017f	0f 84 61 ff ff
	ff		 je	 $L272624
  00185	8b 4c 24 70	 mov	 ecx, DWORD PTR __Newnode$[esp+92]
  00189	5d		 pop	 ebp
$L272625:

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0018a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0018d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));

  00190	8b 44 24 60	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+88]
  00194	88 5a 14	 mov	 BYTE PTR [edx+20], bl
  00197	5b		 pop	 ebx
  00198	89 08		 mov	 DWORD PTR [eax], ecx

; 984  : 		}

  0019a	8b 4c 24 4c	 mov	 ecx, DWORD PTR __$EHRec$[esp+88]
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a7	83 c4 50	 add	 esp, 80			; 00000050H
  001aa	c2 10 00	 ret	 16			; 00000010H
$L298806:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L298438:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T298437[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T298803
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Insert
PUBLIC	?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z
_TEXT	SEGMENT
__Newvec$273563 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L298826
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L298827
$L298826:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L298827:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L273578

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L298848
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L298849
$L298848:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L298849:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L273559

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
$L298980:
$L273559:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L298855
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L298856
$L298855:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L298856:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L273561

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L298815
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L298816
$L298815:
  0007f	03 c1		 add	 eax, ecx
$L298816:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L298878
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L298879
$L298878:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L298879:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L273562

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L298885
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L298886
$L298885:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L298886:
  000a7	03 c7		 add	 eax, edi
$L273562:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$273563[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L298968
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L298969
$L298968:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L298969:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L298971

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L298971:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$273563[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L273561:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L273569
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAKK@std@@YAXPAK0ABK@Z ; std::fill<unsigned long *,unsigned long>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L273569:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAKPAK@std@@YAPAKPAK00@Z ; std::copy_backward<unsigned long *,unsigned long *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAKK@std@@YAXPAK0ABK@Z ; std::fill<unsigned long *,unsigned long>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L273578:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L298979:
?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogty
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT
__Newvec$273597 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L298995
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L298996
$L298995:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L298996:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L273617

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L299017
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L299018
$L299017:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L299018:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L273593

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$L299149:
$L273593:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L299024
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L299025
$L299024:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L299025:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L273595

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L298984
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L298985
$L298984:
  0007f	03 c1		 add	 eax, ecx
$L298985:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L299048
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L299049
$L299048:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L299049:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L273596

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L299055
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L299056
$L299055:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L299056:
  000a7	03 c7		 add	 eax, edi
$L273596:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$273597[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L299137
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L299138
$L299137:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L299138:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L299141

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L299141:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$273597[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L273595:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L273608
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L273608:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ; std::copy_backward<int *,int *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAHH@std@@YAXPAH0ABH@Z ; std::fill<int *,int>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L273617:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L299148:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T299270 DD	0ffffffffH
	DD	FLAT:$L299155
$T299267 DD	019930520H
	DD	01H
	DD	FLAT:$T299270
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T299154 = -80						; size = 28
$T299153 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299154[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T299154[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T299154[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T299154[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T299154[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299153[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299153[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T299153[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L299271:
$L299269:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L299155:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T299154[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T299267
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Xlen
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T299410 DD	0ffffffffH
	DD	FLAT:$L299279
$T299407 DD	019930520H
	DD	01H
	DD	FLAT:$T299410
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
CONST	ENDS
;	COMDAT ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T299278 = -80						; size = 28
$T299277 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize, COMDAT
; _this$ = ecx

; 956  : 		{	// alter element count, with checking

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list

; 957  : 		if (max_size() - _Mysize < _Count)

  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Count$[esp-4]
  0000a	6a ff		 push	 -1
  0000c	68 00 00 00 00	 push	 __ehhandler$?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z
  00011	50		 push	 eax
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	83 ec 44	 sub	 esp, 68			; 00000044H
  0001f	56		 push	 esi
  00020	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00025	2b f0		 sub	 esi, eax
  00027	3b f2		 cmp	 esi, edx
  00029	5e		 pop	 esi
  0002a	73 51		 jae	 SHORT $L273824

; 958  : 			_THROW(length_error, "list<T> too long");

  0002c	6a 10		 push	 16			; 00000010H
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00033	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299278[esp+88]
  00037	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T299278[esp+112], 15 ; 0000000fH
  0003f	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T299278[esp+108], 0
  00047	c6 44 24 0c 00	 mov	 BYTE PTR $T299278[esp+92], 0
  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00051	8d 04 24	 lea	 eax, DWORD PTR $T299278[esp+80]
  00054	50		 push	 eax
  00055	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299277[esp+84]
  00059	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  00061	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00066	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0006b	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299277[esp+84]
  0006f	51		 push	 ecx
  00070	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T299277[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00078	e8 00 00 00 00	 call	 __CxxThrowException@8
$L299411:
$L273824:

; 959  : 		_Mysize += _Count;

  0007d	03 c2		 add	 eax, edx
  0007f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 960  : 		}

  00082	8b 4c 24 44	 mov	 ecx, DWORD PTR __$EHRec$[esp+80]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008d	83 c4 50	 add	 esp, 80			; 00000050H
  00090	c2 04 00	 ret	 4
$L299409:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L299279:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T299278[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T299407
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
PUBLIC	?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T299534 DD	0ffffffffH
	DD	FLAT:$L299419
$T299531 DD	019930520H
	DD	01H
	DD	FLAT:$T299534
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T299418 = -80						; size = 28
$T299417 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299418[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T299418[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T299418[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T299418[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T299418[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299417[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299417[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T299417[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L299535:
$L299533:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L299419:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T299418[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T299531
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Xlen
PUBLIC	?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T299658 DD	0ffffffffH
	DD	FLAT:$L299543
$T299655 DD	019930520H
	DD	01H
	DD	FLAT:$T299658
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T299542 = -80						; size = 28
$T299541 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299542[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T299542[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T299542[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T299542[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T299542[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299541[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299541[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T299541[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L299659:
$L299657:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L299543:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T299542[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T299655
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Xlen
PUBLIC	?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T299782 DD	0ffffffffH
	DD	FLAT:$L299667
$T299779 DD	019930520H
	DD	01H
	DD	FLAT:$T299782
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T299666 = -80						; size = 28
$T299665 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299666[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T299666[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T299666[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T299666[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T299666[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299665[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299665[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T299665[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L299783:
$L299781:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L299667:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T299666[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T299779
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Xlen
PUBLIC	?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T299906 DD	0ffffffffH
	DD	FLAT:$L299791
$T299903 DD	019930520H
	DD	01H
	DD	FLAT:$T299906
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T299790 = -80						; size = 28
$T299789 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299790[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T299790[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T299790[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T299790[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T299790[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299789[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299789[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T299789[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L299907:
$L299905:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L299791:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T299790[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T299903
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Xlen
PUBLIC	?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T300030 DD	0ffffffffH
	DD	FLAT:$L299915
$T300027 DD	019930520H
	DD	01H
	DD	FLAT:$T300030
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T299914 = -80						; size = 28
$T299913 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T299914[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T299914[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T299914[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T299914[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T299914[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299913[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T299913[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T299913[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L300031:
$L300029:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L299915:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T299914[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T300027
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Xlen
PUBLIC	?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T300154 DD	0ffffffffH
	DD	FLAT:$L300039
$T300151 DD	019930520H
	DD	01H
	DD	FLAT:$T300154
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T300038 = -80						; size = 28
$T300037 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T300038[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T300038[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T300038[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T300038[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T300038[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300037[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300037[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T300037[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L300155:
$L300153:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L300039:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T300038[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T300151
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Xlen
PUBLIC	?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T300278 DD	0ffffffffH
	DD	FLAT:$L300163
$T300275 DD	019930520H
	DD	01H
	DD	FLAT:$T300278
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T300162 = -80						; size = 28
$T300161 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T300162[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T300162[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T300162[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T300162[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T300162[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300161[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300161[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T300161[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L300279:
$L300277:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L300163:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T300162[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T300275
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Xlen
PUBLIC	?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T300402 DD	0ffffffffH
	DD	FLAT:$L300287
$T300399 DD	019930520H
	DD	01H
	DD	FLAT:$T300402
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T300286 = -80						; size = 28
$T300285 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T300286[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T300286[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T300286[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T300286[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T300286[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300285[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300285[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T300285[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L300403:
$L300401:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L300287:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T300286[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T300399
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Xlen
PUBLIC	?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T300526 DD	0ffffffffH
	DD	FLAT:$L300411
$T300523 DD	019930520H
	DD	01H
	DD	FLAT:$T300526
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T300410 = -80						; size = 28
$T300409 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T300410[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T300410[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T300410[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T300410[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T300410[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300409[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T300409[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T300409[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L300527:
$L300525:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L300411:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T300410[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T300523
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Xlen
PUBLIC	??$_Uninitialized_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z ; std::_Uninitialized_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z
_TEXT	SEGMENT
__Cat$300536 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	51		 push	 ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$300536[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Val$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Count$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >

; 258  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z ENDP ; std::_Uninitialized_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z ; std::_Destroy_range<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z PROC NEAR ; std::_Destroy_range<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	56		 push	 esi

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 10		 je	 SHORT $L300576
  0000e	8b ff		 npad	 2
$L300574:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  00017	83 c6 04	 add	 esi, 4
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $L300574
$L300576:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 218  : 	}

  00020	c3		 ret	 0
??$_Destroy_range@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@@Z ENDP ; std::_Destroy_range<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV23@00@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Ucopy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$300593 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV23@00@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Ucopy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$300593[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV23@00@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Ucopy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00@Z ; std::copy_backward<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy_backward@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00@Z
_TEXT	SEGMENT
__Cat$300604 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00@Z PROC NEAR ; std::copy_backward<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$300604[esp+4]
  00004	8b 4c 24 10	 mov	 ecx, DWORD PTR __Dest$[esp]
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Last$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR __First$[esp+4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>

; 1070 : 	}

  00019	83 c4 14	 add	 esp, 20			; 00000014H
  0001c	c3		 ret	 0
??$copy_backward@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00@Z ENDP ; std::copy_backward<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T300690 DD	0ffffffffH
	DD	FLAT:$L300609
$T300684 DD	019930520H
	DD	01H
	DD	FLAT:$T300690
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pszSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 830  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	57		 push	 edi
  0001a	89 74 24 08	 mov	 DWORD PTR _this$[esp+24], esi
  0001e	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	8b c8		 mov	 ecx, eax
  00027	ff 52 0c	 call	 DWORD PTR [edx+12]
  0002a	83 c0 10	 add	 eax, 16			; 00000010H
  0002d	89 06		 mov	 DWORD PTR [esi], eax

; 831  : 		if( !CheckImplicitLoad( pszSrc ) )

  0002f	8b 54 24 1c	 mov	 edx, DWORD PTR _pszSrc$[esp+20]
  00033	85 d2		 test	 edx, edx
  00035	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0003d	74 33		 je	 SHORT $L300686
  0003f	f7 c2 00 00 ff
	ff		 test	 edx, -65536		; ffff0000H
  00045	75 2f		 jne	 SHORT $L300681
  00047	0f b7 fa	 movzx	 edi, dx
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle
  00050	85 c0		 test	 eax, eax
  00052	74 3e		 je	 SHORT $L300688
  00054	57		 push	 edi
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
  0005d	5f		 pop	 edi

; 835  : 		}
; 836  : 	}

  0005e	8b c6		 mov	 eax, esi
  00060	5e		 pop	 esi
  00061	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	c2 04 00	 ret	 4
$L300686:

; 832  : 		{
; 833  : 			// nDestLength is in XCHARs
; 834  : 			*this = pszSrc;

  00072	33 c0		 xor	 eax, eax
  00074	eb 13		 jmp	 SHORT $L300680
$L300681:
  00076	8b c2		 mov	 eax, edx
  00078	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0007b	eb 03 8d 49 00	 npad	 5
$L300687:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $L300687
  00087	2b c7		 sub	 eax, edi
$L300680:
  00089	50		 push	 eax
  0008a	52		 push	 edx
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
$L300688:

; 835  : 		}
; 836  : 	}

  00092	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00096	5f		 pop	 edi
  00097	8b c6		 mov	 eax, esi
  00099	5e		 pop	 esi
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a1	83 c4 10	 add	 esp, 16			; 00000010H
  000a4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L300609:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
__ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T300684
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L220539

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L220539:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00021	76 07		 jbe	 SHORT $L220541

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
$L300721:
$L220541:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L300720:
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L220550

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L220550:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00021	76 07		 jbe	 SHORT $L220552

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$L300750:
$L220552:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L300749:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T300757 = 12						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 750  : 		{	// erase [_First, _Last)

  00000	53		 push	 ebx

; 751  : 		if (_First == begin() && _Last == end())

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR __Last$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 10	 mov	 esi, DWORD PTR __First$[esp+4]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00010	3b 30		 cmp	 esi, DWORD PTR [eax]
  00012	75 38		 jne	 SHORT $L301089
  00014	3b d8		 cmp	 ebx, eax
  00016	75 34		 jne	 SHORT $L301089

; 752  : 			{	// erase all
; 753  : 			clear();

  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	50		 push	 eax
  0001c	8b cf		 mov	 ecx, edi
  0001e	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Erase
  00023	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002c	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00033	89 00		 mov	 DWORD PTR [eax], eax
  00035	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00038	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 754  : 			return (begin());

  0003b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 10		 mov	 DWORD PTR [eax], edx
  00048	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  00049	c2 0c 00	 ret	 12			; 0000000cH
$L301089:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  0004c	3b f3		 cmp	 esi, ebx
  0004e	74 5b		 je	 SHORT $L222204
$L222203:

; 759  : 				erase(_First++);

  00050	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00053	84 c0		 test	 al, al
  00055	8b ce		 mov	 ecx, esi
  00057	75 41		 jne	 SHORT $L301060
  00059	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0005f	84 d2		 test	 dl, dl
  00061	75 1a		 jne	 SHORT $L301091
  00063	8b f0		 mov	 esi, eax
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0006a	84 d2		 test	 dl, dl
  0006c	75 2c		 jne	 SHORT $L301060
  0006e	8b ff		 npad	 2
$L301074:
  00070	8b f0		 mov	 esi, eax
  00072	8b 06		 mov	 eax, DWORD PTR [esi]
  00074	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00077	84 d2		 test	 dl, dl
  00079	74 f5		 je	 SHORT $L301074
  0007b	eb 1d		 jmp	 SHORT $L301060
$L301091:
  0007d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00080	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00083	84 d2		 test	 dl, dl
  00085	75 11		 jne	 SHORT $L301063
$L301062:
  00087	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0008a	75 0c		 jne	 SHORT $L301063
  0008c	8b f0		 mov	 esi, eax
  0008e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00091	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00094	84 d2		 test	 dl, dl
  00096	74 ef		 je	 SHORT $L301062
$L301063:
  00098	8b f0		 mov	 esi, eax
$L301060:
  0009a	51		 push	 ecx
  0009b	8d 44 24 18	 lea	 eax, DWORD PTR $T300757[esp+12]
  0009f	50		 push	 eax
  000a0	8b cf		 mov	 ecx, edi
  000a2	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
  000a7	3b f3		 cmp	 esi, ebx
  000a9	75 a5		 jne	 SHORT $L222203
$L222204:

; 760  : 			return (_First);

  000ab	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  000af	5f		 pop	 edi
  000b0	89 30		 mov	 DWORD PTR [eax], esi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx

; 761  : 			}
; 762  : 		}

  000b4	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=, COMDAT
; _this$ = ecx

; 392  : 		{	// assign _Right

  00000	56		 push	 esi
  00001	57		 push	 edi

; 393  : 		if (this != &_Right)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Right$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	3b f7		 cmp	 esi, edi
  0000a	0f 84 2f 01 00
	00		 je	 $L301202
  00010	53		 push	 ebx

; 394  : 			{	// worth doing
; 395  : 
; 396  : 
; 397  : 			if (_Right.size() == 0)

  00011	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00014	55		 push	 ebp
  00015	33 ed		 xor	 ebp, ebp
  00017	3b dd		 cmp	 ebx, ebp
  00019	74 0e		 je	 SHORT $L301200
  0001b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0001e	8b d0		 mov	 edx, eax
  00020	2b d3		 sub	 edx, ebx
  00022	c1 fa 02	 sar	 edx, 2
  00025	3b d5		 cmp	 edx, ebp
  00027	75 22		 jne	 SHORT $L270211
$L301200:

; 398  : 				clear();	// new sequence empty, free storage

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	3b c5		 cmp	 eax, ebp
  0002e	74 09		 je	 SHORT $L301121
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00036	83 c4 04	 add	 esp, 4
$L301121:
  00039	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  0003c	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0003f	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00042	5d		 pop	 ebp
  00043	5b		 pop	 ebx
  00044	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi

; 425  : 		}

  00048	c2 04 00	 ret	 4
$L270211:

; 399  : 			else if (_Right.size() <= size())

  0004b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004e	3b cd		 cmp	 ecx, ebp
  00050	75 04		 jne	 SHORT $L301135
  00052	33 ed		 xor	 ebp, ebp
  00054	eb 08		 jmp	 SHORT $L301136
$L301135:
  00056	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00059	2b e9		 sub	 ebp, ecx
  0005b	c1 fd 02	 sar	 ebp, 2
$L301136:
  0005e	3b d5		 cmp	 edx, ebp
  00060	77 48		 ja	 SHORT $L270213

; 400  : 				{	// enough elements, copy new and destroy old
; 401  : 				pointer _Ptr = copy(_Right._Myfirst, _Right._Mylast,
; 402  : 					_Myfirst);	// copy new

  00062	2b c3		 sub	 eax, ebx
  00064	c1 f8 02	 sar	 eax, 2
  00067	c1 e0 02	 shl	 eax, 2
  0006a	50		 push	 eax
  0006b	53		 push	 ebx
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 _memmove

; 403  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 404  : 				_Mylast = _Myfirst + _Right.size();

  00072	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	85 c0		 test	 eax, eax
  0007a	75 14		 jne	 SHORT $L301164
  0007c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0007f	5d		 pop	 ebp
  00080	33 ff		 xor	 edi, edi
  00082	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00085	5b		 pop	 ebx
  00086	5f		 pop	 edi
  00087	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  0008a	8b c6		 mov	 eax, esi
  0008c	5e		 pop	 esi

; 425  : 		}

  0008d	c2 04 00	 ret	 4

; 403  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 404  : 				_Mylast = _Myfirst + _Right.size();

$L301164:
  00090	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  00093	2b f8		 sub	 edi, eax
  00095	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00098	5d		 pop	 ebp
  00099	c1 ff 02	 sar	 edi, 2
  0009c	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  0009f	5b		 pop	 ebx
  000a0	5f		 pop	 edi
  000a1	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi

; 425  : 		}

  000a7	c2 04 00	 ret	 4
$L270213:

; 405  : 				}
; 406  : 			else if (_Right.size() <= capacity())

  000aa	85 c9		 test	 ecx, ecx
  000ac	75 04		 jne	 SHORT $L301178
  000ae	33 c0		 xor	 eax, eax
  000b0	eb 08		 jmp	 SHORT $L301179
$L301178:
  000b2	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000b5	2b c1		 sub	 eax, ecx
  000b7	c1 f8 02	 sar	 eax, 2
$L301179:
  000ba	3b d0		 cmp	 edx, eax
  000bc	77 3d		 ja	 SHORT $L270223

; 407  : 				{	// enough room, copy and construct new
; 408  : 				pointer _Ptr = _Right._Myfirst + size();

  000be	85 c9		 test	 ecx, ecx
  000c0	75 04		 jne	 SHORT $L301185
  000c2	33 c0		 xor	 eax, eax
  000c4	eb 08		 jmp	 SHORT $L301186
$L301185:
  000c6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c9	2b c1		 sub	 eax, ecx
  000cb	c1 f8 02	 sar	 eax, 2
$L301186:
  000ce	8b 57 04	 mov	 edx, DWORD PTR [edi+4]

; 409  : 				copy(_Right._Myfirst, _Ptr, _Myfirst);

  000d1	51		 push	 ecx
  000d2	8d 1c 82	 lea	 ebx, DWORD PTR [edx+eax*4]
  000d5	53		 push	 ebx
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 ??$copy@PAKPAK@std@@YAPAKPAK00@Z ; std::copy<unsigned long *,unsigned long *>

; 410  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

  000dc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000df	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	53		 push	 ebx
  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
  000ef	5d		 pop	 ebp
  000f0	5b		 pop	 ebx
  000f1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f4	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  000f5	8b c6		 mov	 eax, esi
  000f7	5e		 pop	 esi

; 425  : 		}

  000f8	c2 04 00	 ret	 4
$L270223:

; 411  : 				}
; 412  : 			else
; 413  : 				{	// not enough room, allocate new array and construct new
; 414  : 				if (_Myfirst != 0)

  000fb	85 c9		 test	 ecx, ecx
  000fd	74 09		 je	 SHORT $L301190

; 415  : 					{	// discard old array
; 416  : 					_Destroy(_Myfirst, _Mylast);
; 417  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00105	83 c4 04	 add	 esp, 4
$L301190:

; 418  : 					}
; 419  : 				if (_Buy(_Right.size()))

  00108	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0010b	85 c9		 test	 ecx, ecx
  0010d	75 04		 jne	 SHORT $L301197
  0010f	33 c0		 xor	 eax, eax
  00111	eb 08		 jmp	 SHORT $L301198
$L301197:
  00113	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00116	2b c1		 sub	 eax, ecx
  00118	c1 f8 02	 sar	 eax, 2
$L301198:
  0011b	50		 push	 eax
  0011c	8b ce		 mov	 ecx, esi
  0011e	e8 00 00 00 00	 call	 ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
  00123	84 c0		 test	 al, al
  00125	74 16		 je	 SHORT $L301201

; 420  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 421  : 						_Myfirst);

  00127	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0012a	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0012d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00130	51		 push	 ecx
  00131	52		 push	 edx
  00132	50		 push	 eax
  00133	8b ce		 mov	 ecx, esi
  00135	e8 00 00 00 00	 call	 ??$_Ucopy@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<unsigned long *>
  0013a	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L301201:
  0013d	5d		 pop	 ebp
  0013e	5b		 pop	 ebx
$L301202:
  0013f	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  00140	8b c6		 mov	 eax, esi
  00142	5e		 pop	 esi

; 425  : 		}

  00143	c2 04 00	 ret	 4
??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKH@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T301217 = 12						; size = 4
$T301215 = 12						; size = 4
__Where$270515 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKH@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 477  : 		{	// try to insert node with value _Val

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 478  : 		_Nodeptr _Trynode = _Root();
; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00002	8b 6c 24 10	 mov	 ebp, DWORD PTR __Val$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00013	84 d2		 test	 dl, dl
  00015	b1 01		 mov	 cl, 1
  00017	88 4c 24 0c	 mov	 BYTE PTR __Addleft$[esp+16], cl
  0001b	75 20		 jne	 SHORT $L270505
  0001d	8b 55 00	 mov	 edx, DWORD PTR [ebp]
$L270504:

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));

  00020	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  00023	0f 92 c1	 setb	 cl

; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  00026	84 c9		 test	 cl, cl
  00028	8b f0		 mov	 esi, eax
  0002a	88 4c 24 0c	 mov	 BYTE PTR __Addleft$[esp+16], cl
  0002e	74 04		 je	 SHORT $L301209
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	eb 03		 jmp	 SHORT $L301210
$L301209:
  00034	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L301210:

; 478  : 		_Nodeptr _Trynode = _Root();
; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00037	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003b	74 e3		 je	 SHORT $L270504
$L270505:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  0003d	84 c9		 test	 cl, cl
  0003f	8b d6		 mov	 edx, esi
  00041	89 54 24 18	 mov	 DWORD PTR __Where$270515[esp+12], edx
  00045	74 33		 je	 SHORT $L301309

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00047	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004a	3b 30		 cmp	 esi, DWORD PTR [eax]

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004c	8d 4c 24 18	 lea	 ecx, DWORD PTR $T301215[esp+12]
  00050	75 1f		 jne	 SHORT $L270520
  00052	55		 push	 ebp
  00053	56		 push	 esi
  00054	6a 01		 push	 1
  00056	51		 push	 ecx
  00057	8b cf		 mov	 ecx, edi
  00059	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Insert
  0005e	8b 10		 mov	 edx, DWORD PTR [eax]
  00060	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  0006a	89 10		 mov	 DWORD PTR [eax], edx
  0006c	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  0006d	59		 pop	 ecx
  0006e	c2 08 00	 ret	 8
$L270520:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00071	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::const_iterator::_Dec
  00076	8b 54 24 18	 mov	 edx, DWORD PTR __Where$270515[esp+12]
$L301309:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0007a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007d	3b 45 00	 cmp	 eax, DWORD PTR [ebp]
  00080	73 26		 jae	 SHORT $L270525

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00082	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Addleft$[esp+16]
  00086	55		 push	 ebp
  00087	56		 push	 esi
  00088	51		 push	 ecx
  00089	8d 54 24 24	 lea	 edx, DWORD PTR $T301217[esp+24]
  0008d	52		 push	 edx
  0008e	8b cf		 mov	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBKH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Insert
  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
  0009f	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000a3	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  000a4	59		 pop	 ecx
  000a5	c2 08 00	 ret	 8
$L270525:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  000a8	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000b2	89 10		 mov	 DWORD PTR [eax], edx
  000b4	5d		 pop	 ebp

; 504  : 			}
; 505  : 		}

  000b5	59		 pop	 ecx
  000b6	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L301408
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 02	 sar	 eax, 2
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L301347
$L301408:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L301348
$L301347:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 02	 sar	 esi, 2
$L301348:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@KV?$allocator@K@std@@@std@@QAE?AViterator@12@V312@ABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L301474
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 02	 sar	 eax, 2
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L301413
$L301474:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L301414
$L301413:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 02	 sar	 esi, 2
$L301414:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L272715

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L272715:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00021	76 07		 jbe	 SHORT $L272717

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Xlen
$L301503:
$L272717:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L301502:
?_Buy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert, COMDAT
; _this$ = ecx

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();
; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	8b 5c 24 08	 mov	 ebx, DWORD PTR __Where$[esp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	8b cf		 mov	 ecx, edi
  00015	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode

; 524  : 		_Incsize(1);

  0001a	6a 01		 push	 1
  0001c	8b cf		 mov	 ecx, edi
  0001e	8b f0		 mov	 esi, eax
  00020	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

  00025	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

  00028	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002b	5f		 pop	 edi
  0002c	89 32		 mov	 DWORD PTR [edx], esi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 527  : 		}

  00030	c2 08 00	 ret	 8
?_Insert@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXViterator@12@ABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Buy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L272801

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L272801:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d c7 71 1c 07	 cmp	 eax, 119304647		; 071c71c7H
  00021	76 07		 jbe	 SHORT $L272803

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Xlen
$L301551:
$L272803:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c c0	 lea	 edi, DWORD PTR [eax+eax*8]
  0002e	c1 e7 02	 shl	 edi, 2
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00037	03 f8		 add	 edi, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00045	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 783  : 		}

  00049	c2 04 00	 ret	 4
$L301550:
?_Buy@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L272842

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L272842:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00021	76 07		 jbe	 SHORT $L272844

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Xlen
$L301580:
$L272844:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0002e	c1 e7 02	 shl	 edi, 2
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00037	03 f8		 add	 edi, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00045	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 783  : 		}

  00049	c2 04 00	 ret	 4
$L301579:
?_Buy@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L272885

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L272885:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00021	76 07		 jbe	 SHORT $L272887

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Xlen
$L301609:
$L272887:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L301608:
?_Buy@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE_NI@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L272928

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L272928:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00021	76 07		 jbe	 SHORT $L272930

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Xlen
$L301638:
$L272930:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L301637:
?_Buy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Buy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV34@IABV34@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Ufill
; Function compile flags: /Ogty
;	COMDAT ?_Ufill@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV34@IABV34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$301651 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV34@IABV34@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Ufill, COMDAT
; _this$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$301651[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b 4c 24 1c	 mov	 ecx, DWORD PTR __Val$[esp+12]
  00014	51		 push	 ecx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
  0001c	83 c4 14	 add	 esp, 20			; 00000014H

; 879  : 		return (_Ptr + _Count);

  0001f	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 880  : 		}

  00024	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV34@IABV34@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Ufill
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L272971

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L272971:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00021	76 07		 jbe	 SHORT $L272973

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Xlen
$L301683:
$L272973:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0002e	c1 e7 02	 shl	 edi, 2
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00037	03 f8		 add	 edi, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00045	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 783  : 		}

  00049	c2 04 00	 ret	 4
$L301682:
?_Buy@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L272998

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L272998:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00021	76 07		 jbe	 SHORT $L273000

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Xlen
$L301712:
$L273000:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00038	03 f8		 add	 edi, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00046	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00047	b0 01		 mov	 al, 1
  00049	5e		 pop	 esi

; 783  : 		}

  0004a	c2 04 00	 ret	 4
$L301711:
?_Buy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Buy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T301934 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T301936 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L301719
$T301937 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L301721
$T301935 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T301936
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T301937
$T301931 DD	019930520H
	DD	04H
	DD	FLAT:$T301934
	DD	02H
	DD	FLAT:$T301935
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Tmp$ = -28						; size = 8
__Newvec$273024 = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv446 = 8						; size = 4
__Cat$301902 = 8					; size = 1
__Cat$301840 = 8					; size = 1
__Cat$301863 = 8					; size = 1
__Cat$301817 = 8					; size = 1
__Where$ = 8						; size = 4
tv445 = 12						; size = 4
__Count$ = 12						; size = 4
tv430 = 16						; size = 4
tv220 = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 10	 sub	 esp, 16			; 00000010H

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	8b f1		 mov	 esi, ecx
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	89 4d e4	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 811  : 		size_type _Capacity = capacity();

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	57		 push	 edi
  00030	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00033	89 55 e8	 mov	 DWORD PTR __Tmp$[ebp+4], edx
  00036	75 04		 jne	 SHORT $L301727
  00038	33 c0		 xor	 eax, eax
  0003a	eb 08		 jmp	 SHORT $L301728
$L301727:
  0003c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003f	2b c1		 sub	 eax, ecx
  00041	c1 f8 03	 sar	 eax, 3
$L301728:

; 812  : 
; 813  : 		if (_Count == 0)

  00044	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00047	85 db		 test	 ebx, ebx
  00049	0f 84 e1 01 00
	00		 je	 $L273039

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0004f	85 c9		 test	 ecx, ecx
  00051	75 04		 jne	 SHORT $L301750
  00053	33 d2		 xor	 edx, edx
  00055	eb 08		 jmp	 SHORT $L301751
$L301750:
  00057	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005a	2b d1		 sub	 edx, ecx
  0005c	c1 fa 03	 sar	 edx, 3
$L301751:
  0005f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00064	2b fa		 sub	 edi, edx
  00066	3b fb		 cmp	 edi, ebx
  00068	73 07		 jae	 SHORT $L273020

; 816  : 			_Xlen();	// result too long

  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Xlen
$L301938:
$L273020:

; 817  : 		else if (_Capacity < size() + _Count)

  00071	85 c9		 test	 ecx, ecx
  00073	75 04		 jne	 SHORT $L301757
  00075	33 d2		 xor	 edx, edx
  00077	eb 08		 jmp	 SHORT $L301758
$L301757:
  00079	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0007c	2b d1		 sub	 edx, ecx
  0007e	c1 fa 03	 sar	 edx, 3
$L301758:
  00081	03 d3		 add	 edx, ebx
  00083	3b c2		 cmp	 eax, edx
  00085	0f 83 f8 00 00
	00		 jae	 $L273022

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0008b	8b d0		 mov	 edx, eax
  0008d	d1 ea		 shr	 edx, 1
  0008f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00094	2b fa		 sub	 edi, edx
  00096	3b f8		 cmp	 edi, eax
  00098	73 04		 jae	 SHORT $L301716
  0009a	33 c0		 xor	 eax, eax
  0009c	eb 02		 jmp	 SHORT $L301717
$L301716:
  0009e	03 c2		 add	 eax, edx
$L301717:

; 821  : 			if (_Capacity < size() + _Count)

  000a0	85 c9		 test	 ecx, ecx
  000a2	75 04		 jne	 SHORT $L301780
  000a4	33 d2		 xor	 edx, edx
  000a6	eb 08		 jmp	 SHORT $L301781
$L301780:
  000a8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ab	2b d1		 sub	 edx, ecx
  000ad	c1 fa 03	 sar	 edx, 3
$L301781:
  000b0	03 d3		 add	 edx, ebx
  000b2	3b c2		 cmp	 eax, edx
  000b4	73 12		 jae	 SHORT $L273023

; 822  : 				_Capacity = size() + _Count;

  000b6	85 c9		 test	 ecx, ecx
  000b8	75 04		 jne	 SHORT $L301787
  000ba	33 c0		 xor	 eax, eax
  000bc	eb 08		 jmp	 SHORT $L301788
$L301787:
  000be	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 03	 sar	 eax, 3
$L301788:
  000c6	03 c3		 add	 eax, ebx
$L273023:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000c8	c1 e0 03	 shl	 eax, 3
  000cb	50		 push	 eax
  000cc	89 45 0c	 mov	 DWORD PTR tv445[ebp], eax
  000cf	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000d4	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$301817[ebp]
  000d7	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  000da	51		 push	 ecx
  000db	8b f8		 mov	 edi, eax
  000dd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e0	56		 push	 esi
  000e1	57		 push	 edi
  000e2	52		 push	 edx
  000e3	50		 push	 eax
  000e4	89 7d ec	 mov	 DWORD PTR __Newvec$273024[ebp], edi
  000e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ee	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$301840[ebp]
  000f6	83 c4 18	 add	 esp, 24			; 00000018H
  000f9	51		 push	 ecx
  000fa	56		 push	 esi
  000fb	8d 55 e4	 lea	 edx, DWORD PTR __Tmp$[ebp]
  000fe	52		 push	 edx
  000ff	53		 push	 ebx
  00100	50		 push	 eax
  00101	89 45 10	 mov	 DWORD PTR tv220[ebp], eax
  00104	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00109	8b 55 08	 mov	 edx, DWORD PTR __Cat$301863[ebp]
  0010c	8b 45 10	 mov	 eax, DWORD PTR tv220[ebp]
  0010f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00112	83 c4 14	 add	 esp, 20			; 00000014H
  00115	52		 push	 edx
  00116	8d 04 d8	 lea	 eax, DWORD PTR [eax+ebx*8]
  00119	56		 push	 esi
  0011a	50		 push	 eax
  0011b	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0011e	51		 push	 ecx
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  00125	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00128	83 c4 14	 add	 esp, 20			; 00000014H
  0012b	85 c9		 test	 ecx, ecx
  0012d	75 04		 jne	 SHORT $L301875
  0012f	33 c0		 xor	 eax, eax
  00131	eb 08		 jmp	 SHORT $L301876
$L301875:
  00133	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00136	2b c1		 sub	 eax, ecx
  00138	c1 f8 03	 sar	 eax, 3
$L301876:
  0013b	03 d8		 add	 ebx, eax

; 838  : 			if (_Myfirst != 0)

  0013d	85 c9		 test	 ecx, ecx
  0013f	74 09		 je	 SHORT $L301878

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00147	83 c4 04	 add	 esp, 4
$L301878:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  0014a	8b 4d 0c	 mov	 ecx, DWORD PTR tv445[ebp]
  0014d	03 cf		 add	 ecx, edi

; 844  : 			_Mylast = _Newvec + _Count;

  0014f	8d 14 df	 lea	 edx, DWORD PTR [edi+ebx*8]
  00152	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00155	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 845  : 			_Myfirst = _Newvec;

  00158	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 873  : 			}
; 874  : 		}

  0015b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0015e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c2 0c 00	 ret	 12			; 0000000cH
$L301719:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0016e	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$273024[ebp]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00177	83 c4 04	 add	 esp, 4
$L301721:

; 834  : 			_RERAISE;

  0017a	6a 00		 push	 0
  0017c	6a 00		 push	 0
  0017e	e8 00 00 00 00	 call	 __CxxThrowException@8
$L301939:
$L273022:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00183	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00186	8b 7d 08	 mov	 edi, DWORD PTR __Where$[ebp]
  00189	8b c8		 mov	 ecx, eax
  0018b	2b cf		 sub	 ecx, edi
  0018d	c1 f9 03	 sar	 ecx, 3
  00190	3b cb		 cmp	 ecx, ebx

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00192	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8]
  00199	89 4d 08	 mov	 DWORD PTR tv446[ebp], ecx
  0019c	8b 55 08	 mov	 edx, DWORD PTR __Cat$301902[ebp]
  0019f	52		 push	 edx
  001a0	89 45 10	 mov	 DWORD PTR tv430[ebp], eax
  001a3	56		 push	 esi
  001a4	73 5d		 jae	 SHORT $L273030
  001a6	03 cf		 add	 ecx, edi
  001a8	51		 push	 ecx
  001a9	50		 push	 eax
  001aa	57		 push	 edi
  001ab	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  001b0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001b3	8b d0		 mov	 edx, eax
  001b5	83 c4 14	 add	 esp, 20			; 00000014H
  001b8	2b d7		 sub	 edx, edi
  001ba	8d 4d e4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  001bd	51		 push	 ecx
  001be	c1 fa 03	 sar	 edx, 3
  001c1	2b da		 sub	 ebx, edx
  001c3	53		 push	 ebx
  001c4	50		 push	 eax
  001c5	8b ce		 mov	 ecx, esi
  001c7	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  001ce	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  001d3	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  001d6	8b 45 08	 mov	 eax, DWORD PTR tv446[ebp]
  001d9	03 d8		 add	 ebx, eax
  001db	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  001de	8d 4d e4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  001e1	8b f3		 mov	 esi, ebx
  001e3	51		 push	 ecx
  001e4	2b f0		 sub	 esi, eax
  001e6	56		 push	 esi
  001e7	57		 push	 edi
  001e8	e8 00 00 00 00	 call	 ??$fill@PAU__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD>
  001ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 			}
; 874  : 		}

  001f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001fa	5f		 pop	 edi
  001fb	5e		 pop	 esi
  001fc	5b		 pop	 ebx
  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c2 0c 00	 ret	 12			; 0000000cH
$L273030:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  00203	50		 push	 eax
  00204	8b d8		 mov	 ebx, eax
  00206	2b d9		 sub	 ebx, ecx
  00208	50		 push	 eax
  00209	53		 push	 ebx
  0020a	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >
  0020f	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00212	8b 45 10	 mov	 eax, DWORD PTR tv430[ebp]
  00215	50		 push	 eax
  00216	53		 push	 ebx
  00217	57		 push	 edi
  00218	e8 00 00 00 00	 call	 ??$copy_backward@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z ; std::copy_backward<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0021d	8b 55 08	 mov	 edx, DWORD PTR tv446[ebp]
  00220	8d 4d e4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00223	51		 push	 ecx
  00224	03 d7		 add	 edx, edi
  00226	52		 push	 edx
  00227	57		 push	 edi
  00228	e8 00 00 00 00	 call	 ??$fill@PAU__REQUESTGUILD@CGuildCombat@@U12@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD>
  0022d	83 c4 2c	 add	 esp, 44			; 0000002cH
$L273039:

; 873  : 			}
; 874  : 		}

  00230	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00233	5f		 pop	 edi
  00234	5e		 pop	 esi
  00235	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0023c	5b		 pop	 ebx
  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c2 0c 00	 ret	 12			; 0000000cH
$L301933:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T301931
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Insert_n
PUBLIC	?_Buy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L273068

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L273068:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00021	76 07		 jbe	 SHORT $L273070

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Xlen
$L301969:
$L273070:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0002e	c1 e7 03	 shl	 edi, 3
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00037	03 f8		 add	 edi, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00045	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 783  : 		}

  00049	c2 04 00	 ret	 4
$L301968:
?_Buy@?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Buy
; Function compile flags: /Ogty
;	COMDAT ?_Buy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Buy, COMDAT
; _this$ = ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 772  : 		if (_Capacity == 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Capacity$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c9		 xor	 ecx, ecx
  00009	3b c1		 cmp	 eax, ecx
  0000b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00011	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00014	75 06		 jne	 SHORT $L273081

; 773  : 			return (false);

  00016	32 c0		 xor	 al, al
  00018	5e		 pop	 esi

; 783  : 		}

  00019	c2 04 00	 ret	 4
$L273081:

; 774  : 		else if (max_size() < _Capacity)

  0001c	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00021	76 07		 jbe	 SHORT $L273083

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Xlen
$L301998:
$L273083:
  0002a	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002b	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0002e	c1 e7 03	 shl	 edi, 3
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  00037	03 f8		 add	 edi, eax
  00039	83 c4 04	 add	 esp, 4
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00045	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 783  : 		}

  00049	c2 04 00	 ret	 4
$L301997:
?_Buy@?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::_Buy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert_n
; Function compile flags: /Ogty
;	COMDAT ?_Insert_n@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Newvec$273764 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L302013
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L302014
$L302013:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L302014:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L273784

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L302036
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L302037
$L302036:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L302037:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L273760

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Xlen
$L302167:
$L273760:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L302043
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L302044
$L302043:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L302044:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L273762

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L302002
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L302003
$L302002:
  0007f	03 c1		 add	 eax, ecx
$L302003:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L302066
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L302067
$L302066:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L302067:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L273763

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L302073
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L302074
$L302073:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L302074:
  000a7	03 c7		 add	 eax, edi
$L273763:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$273764[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU34@IABQAU34@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L302154
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L302155
$L302154:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L302155:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L302159

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L302159:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$273764[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L273762:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L273775
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAU__JOINPLAYER@CGuildCombat@@@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU23@00@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ucopy<CGuildCombat::__JOINPLAYER * *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU34@IABQAU34@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAPAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0ABQAU12@@Z ; std::fill<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER *>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L273775:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAU__JOINPLAYER@CGuildCombat@@@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAPAU__JOINPLAYER@CGuildCombat@@PAPAU23@00@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Ucopy<CGuildCombat::__JOINPLAYER * *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@@std@@YAPAPAU__JOINPLAYER@CGuildCombat@@PAPAU12@00@Z ; std::copy_backward<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER * *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAPAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0ABQAU12@@Z ; std::fill<CGuildCombat::__JOINPLAYER * *,CGuildCombat::__JOINPLAYER *>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L273784:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L302166:
?_Insert_n@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T302382 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T302384 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L302174
$T302385 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L302176
$T302383 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T302384
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T302385
$T302379 DD	019930520H
	DD	04H
	DD	FLAT:$T302382
	DD	02H
	DD	FLAT:$T302383
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Tmp$ = -52						; size = 36
__$EHRec$ = -16						; size = 16
tv427 = 8						; size = 4
tv414 = 8						; size = 4
__Cat$302349 = 8					; size = 1
__Cat$302373 = 8					; size = 1
__Cat$302288 = 8					; size = 1
__Cat$302311 = 8					; size = 1
__Cat$302265 = 8					; size = 1
__Where$ = 8						; size = 4
tv220 = 12						; size = 4
__Count$ = 12						; size = 4
tv398 = 16						; size = 4
__Newvec$273882 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0001d	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
  00020	57		 push	 edi
  00021	8b d9		 mov	 ebx, ecx
  00023	b9 09 00 00 00	 mov	 ecx, 9
  00028	8d 7d cc	 lea	 edi, DWORD PTR __Tmp$[ebp]
  0002b	f3 a5		 rep movsd

; 811  : 		size_type _Capacity = capacity();

  0002d	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00030	85 ff		 test	 edi, edi
  00032	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00035	75 04		 jne	 SHORT $L302181
  00037	33 c9		 xor	 ecx, ecx
  00039	eb 16		 jmp	 SHORT $L302182
$L302181:
  0003b	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0003e	2b cf		 sub	 ecx, edi
  00040	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00045	f7 e9		 imul	 ecx
  00047	c1 fa 03	 sar	 edx, 3
  0004a	8b ca		 mov	 ecx, edx
  0004c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0004f	03 ca		 add	 ecx, edx
$L302182:

; 812  : 
; 813  : 		if (_Count == 0)

  00051	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00054	85 f6		 test	 esi, esi
  00056	0f 84 3e 02 00
	00		 je	 $L273902

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0005c	85 ff		 test	 edi, edi
  0005e	75 04		 jne	 SHORT $L302204
  00060	33 c0		 xor	 eax, eax
  00062	eb 16		 jmp	 SHORT $L302205
$L302204:
  00064	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00067	2b d7		 sub	 edx, edi
  00069	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0006e	f7 ea		 imul	 edx
  00070	c1 fa 03	 sar	 edx, 3
  00073	8b c2		 mov	 eax, edx
  00075	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00078	03 c2		 add	 eax, edx
$L302205:
  0007a	ba c7 71 1c 07	 mov	 edx, 119304647		; 071c71c7H
  0007f	2b d0		 sub	 edx, eax
  00081	3b d6		 cmp	 edx, esi
  00083	73 07		 jae	 SHORT $L273878

; 816  : 			_Xlen();	// result too long

  00085	8b cb		 mov	 ecx, ebx
  00087	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Xlen
$L302386:
$L273878:

; 817  : 		else if (_Capacity < size() + _Count)

  0008c	85 ff		 test	 edi, edi
  0008e	75 04		 jne	 SHORT $L302211
  00090	33 c0		 xor	 eax, eax
  00092	eb 16		 jmp	 SHORT $L302212
$L302211:
  00094	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00097	2b d7		 sub	 edx, edi
  00099	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0009e	f7 ea		 imul	 edx
  000a0	c1 fa 03	 sar	 edx, 3
  000a3	8b c2		 mov	 eax, edx
  000a5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a8	03 c2		 add	 eax, edx
$L302212:
  000aa	03 c6		 add	 eax, esi
  000ac	3b c8		 cmp	 ecx, eax
  000ae	0f 83 10 01 00
	00		 jae	 $L273880

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000b4	8b c1		 mov	 eax, ecx
  000b6	d1 e8		 shr	 eax, 1
  000b8	ba c7 71 1c 07	 mov	 edx, 119304647		; 071c71c7H
  000bd	2b d0		 sub	 edx, eax
  000bf	3b d1		 cmp	 edx, ecx
  000c1	73 04		 jae	 SHORT $L302171
  000c3	33 c9		 xor	 ecx, ecx
  000c5	eb 02		 jmp	 SHORT $L302172
$L302171:
  000c7	03 c8		 add	 ecx, eax
$L302172:

; 821  : 			if (_Capacity < size() + _Count)

  000c9	85 ff		 test	 edi, edi
  000cb	75 04		 jne	 SHORT $L302234
  000cd	33 c0		 xor	 eax, eax
  000cf	eb 16		 jmp	 SHORT $L302235
$L302234:
  000d1	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000d4	2b d7		 sub	 edx, edi
  000d6	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  000db	f7 ea		 imul	 edx
  000dd	c1 fa 03	 sar	 edx, 3
  000e0	8b c2		 mov	 eax, edx
  000e2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e5	03 c2		 add	 eax, edx
$L302235:
  000e7	03 c6		 add	 eax, esi
  000e9	3b c8		 cmp	 ecx, eax
  000eb	73 0b		 jae	 SHORT $L273881

; 822  : 				_Capacity = size() + _Count;

  000ed	8b cb		 mov	 ecx, ebx
  000ef	e8 00 00 00 00	 call	 ?size@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::size
  000f4	8b c8		 mov	 ecx, eax
  000f6	03 ce		 add	 ecx, esi
$L273881:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000f8	8d 3c c9	 lea	 edi, DWORD PTR [ecx+ecx*8]
  000fb	c1 e7 02	 shl	 edi, 2
  000fe	57		 push	 edi
  000ff	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00104	8b 55 08	 mov	 edx, DWORD PTR __Cat$302265[ebp]
  00107	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0010a	52		 push	 edx
  0010b	53		 push	 ebx
  0010c	50		 push	 eax
  0010d	89 45 10	 mov	 DWORD PTR __Newvec$273882[ebp], eax
  00110	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00113	50		 push	 eax
  00114	51		 push	 ecx
  00115	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0011c	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00121	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$302288[ebp]
  00124	83 c4 18	 add	 esp, 24			; 00000018H
  00127	51		 push	 ecx
  00128	53		 push	 ebx
  00129	8d 55 cc	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0012c	52		 push	 edx
  0012d	56		 push	 esi
  0012e	50		 push	 eax
  0012f	89 45 0c	 mov	 DWORD PTR tv220[ebp], eax
  00132	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00137	8b 55 08	 mov	 edx, DWORD PTR __Cat$302311[ebp]
  0013a	8b 4d 0c	 mov	 ecx, DWORD PTR tv220[ebp]
  0013d	83 c4 14	 add	 esp, 20			; 00000014H
  00140	52		 push	 edx
  00141	8d 04 f6	 lea	 eax, DWORD PTR [esi+esi*8]
  00144	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00147	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0014a	53		 push	 ebx
  0014b	50		 push	 eax
  0014c	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0014f	51		 push	 ecx
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  00156	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00159	83 c4 14	 add	 esp, 20			; 00000014H
  0015c	85 c0		 test	 eax, eax
  0015e	74 16		 je	 SHORT $L302323
$L302322:
  00160	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00163	2b c8		 sub	 ecx, eax
  00165	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0016a	f7 e9		 imul	 ecx
  0016c	c1 fa 03	 sar	 edx, 3
  0016f	8b c2		 mov	 eax, edx
  00171	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00174	03 c2		 add	 eax, edx
$L302323:
  00176	03 f0		 add	 esi, eax

; 838  : 			if (_Myfirst != 0)

  00178	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0017b	85 c0		 test	 eax, eax
  0017d	74 09		 je	 SHORT $L302327

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00185	83 c4 04	 add	 esp, 4
$L302327:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00188	8b 45 10	 mov	 eax, DWORD PTR __Newvec$273882[ebp]

; 844  : 			_Mylast = _Newvec + _Count;

  0018b	8d 0c f6	 lea	 ecx, DWORD PTR [esi+esi*8]
  0018e	03 f8		 add	 edi, eax
  00190	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00193	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00196	89 53 08	 mov	 DWORD PTR [ebx+8], edx

; 845  : 			_Myfirst = _Newvec;

  00199	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 873  : 			}
; 874  : 		}

  0019c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi
  001a8	5b		 pop	 ebx
  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c2 0c 00	 ret	 12			; 0000000cH
$L302174:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  001af	8b 45 10	 mov	 eax, DWORD PTR __Newvec$273882[ebp]
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001b8	83 c4 04	 add	 esp, 4
$L302176:

; 834  : 			_RERAISE;

  001bb	6a 00		 push	 0
  001bd	6a 00		 push	 0
  001bf	e8 00 00 00 00	 call	 __CxxThrowException@8
$L302387:
$L273880:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001c4	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  001c7	8b 7d 08	 mov	 edi, DWORD PTR __Where$[ebp]
  001ca	8b d1		 mov	 edx, ecx
  001cc	2b d7		 sub	 edx, edi
  001ce	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  001d3	f7 ea		 imul	 edx
  001d5	c1 fa 03	 sar	 edx, 3
  001d8	8b c2		 mov	 eax, edx
  001da	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001dd	03 c2		 add	 eax, edx
  001df	3b c6		 cmp	 eax, esi
  001e1	89 4d 10	 mov	 DWORD PTR tv398[ebp], ecx
  001e4	73 79		 jae	 SHORT $L273893

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001e6	8d 04 f6	 lea	 eax, DWORD PTR [esi+esi*8]
  001e9	c1 e0 02	 shl	 eax, 2
  001ec	89 45 08	 mov	 DWORD PTR tv414[ebp], eax
  001ef	8b 55 08	 mov	 edx, DWORD PTR __Cat$302349[ebp]
  001f2	52		 push	 edx
  001f3	53		 push	 ebx
  001f4	03 c7		 add	 eax, edi
  001f6	50		 push	 eax
  001f7	51		 push	 ecx
  001f8	57		 push	 edi
  001f9	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  001fe	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00201	83 c4 14	 add	 esp, 20			; 00000014H
  00204	8d 45 cc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00207	50		 push	 eax
  00208	8b d1		 mov	 edx, ecx
  0020a	2b d7		 sub	 edx, edi
  0020c	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00211	f7 ea		 imul	 edx
  00213	c1 fa 03	 sar	 edx, 3
  00216	8b c2		 mov	 eax, edx
  00218	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0021b	03 c2		 add	 eax, edx
  0021d	2b f0		 sub	 esi, eax
  0021f	56		 push	 esi
  00220	51		 push	 ecx
  00221	8b cb		 mov	 ecx, ebx
  00223	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0022a	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCGETPOINT@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  0022f	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00232	8b 45 08	 mov	 eax, DWORD PTR tv414[ebp]
  00235	03 f0		 add	 esi, eax
  00237	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  0023a	8d 4d cc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0023d	8b de		 mov	 ebx, esi
  0023f	51		 push	 ecx
  00240	2b d8		 sub	 ebx, eax
  00242	53		 push	 ebx
  00243	57		 push	 edi
  00244	e8 00 00 00 00	 call	 ??$fill@PAU__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT>
  00249	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 			}
; 874  : 		}

  0024c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0024f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00256	5f		 pop	 edi
  00257	5e		 pop	 esi
  00258	5b		 pop	 ebx
  00259	8b e5		 mov	 esp, ebp
  0025b	5d		 pop	 ebp
  0025c	c2 0c 00	 ret	 12			; 0000000cH
$L273893:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  0025f	8d 34 f6	 lea	 esi, DWORD PTR [esi+esi*8]
  00262	8b c1		 mov	 eax, ecx
  00264	c1 e6 02	 shl	 esi, 2
  00267	2b c6		 sub	 eax, esi
  00269	89 45 08	 mov	 DWORD PTR tv427[ebp], eax
  0026c	8b 55 08	 mov	 edx, DWORD PTR __Cat$302373[ebp]
  0026f	52		 push	 edx
  00270	53		 push	 ebx
  00271	51		 push	 ecx
  00272	51		 push	 ecx
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCGETPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *,std::allocator<CGuildCombat::__GCGETPOINT> >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00279	8b 4d 08	 mov	 ecx, DWORD PTR tv427[ebp]
  0027c	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0027f	8b 45 10	 mov	 eax, DWORD PTR tv398[ebp]
  00282	50		 push	 eax
  00283	51		 push	 ecx
  00284	57		 push	 edi
  00285	e8 00 00 00 00	 call	 ??$copy_backward@PAU__GCGETPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCGETPOINT@CGuildCombat@@PAU12@00@Z ; std::copy_backward<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0028a	8d 55 cc	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0028d	52		 push	 edx
  0028e	03 f7		 add	 esi, edi
  00290	56		 push	 esi
  00291	57		 push	 edi
  00292	e8 00 00 00 00	 call	 ??$fill@PAU__GCGETPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCGETPOINT *,CGuildCombat::__GCGETPOINT>
  00297	83 c4 2c	 add	 esp, 44			; 0000002cH
$L273902:

; 873  : 			}
; 874  : 		}

  0029a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0029d	5f		 pop	 edi
  0029e	5e		 pop	 esi
  0029f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002a6	5b		 pop	 ebx
  002a7	8b e5		 mov	 esp, ebp
  002a9	5d		 pop	 ebp
  002aa	c2 0c 00	 ret	 12			; 0000000cH
$L302381:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T302379
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T302617 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T302619 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L302395
$T302620 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L302397
$T302618 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T302619
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T302620
$T302614 DD	019930520H
	DD	04H
	DD	FLAT:$T302617
	DD	02H
	DD	FLAT:$T302618
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Tmp$ = -28						; size = 12
__$EHRec$ = -16						; size = 16
tv427 = 8						; size = 4
tv414 = 8						; size = 4
__Cat$302609 = 8					; size = 1
__Cat$302596 = 8					; size = 1
__Cat$302572 = 8					; size = 1
__Cat$302531 = 8					; size = 1
__Cat$302508 = 8					; size = 1
__Cat$302485 = 8					; size = 1
__Where$ = 8						; size = 4
tv220 = 12						; size = 4
__Count$ = 12						; size = 4
tv398 = 16						; size = 4
__Newvec$273953 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 10	 sub	 esp, 16			; 00000010H

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b f1		 mov	 esi, ecx
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 811  : 		size_type _Capacity = capacity();

  00027	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0002a	85 db		 test	 ebx, ebx
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	57		 push	 edi
  00030	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR __Tmp$[ebp], ecx
  00036	89 55 e8	 mov	 DWORD PTR __Tmp$[ebp+4], edx
  00039	89 45 ec	 mov	 DWORD PTR __Tmp$[ebp+8], eax
  0003c	75 04		 jne	 SHORT $L302402
  0003e	33 c9		 xor	 ecx, ecx
  00040	eb 15		 jmp	 SHORT $L302403
$L302402:
  00042	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00045	2b cb		 sub	 ecx, ebx
  00047	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004c	f7 e9		 imul	 ecx
  0004e	d1 fa		 sar	 edx, 1
  00050	8b ca		 mov	 ecx, edx
  00052	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00055	03 ca		 add	 ecx, edx
$L302403:

; 812  : 
; 813  : 		if (_Count == 0)

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	0f 84 3c 02 00
	00		 je	 $L273973

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00062	85 db		 test	 ebx, ebx
  00064	75 04		 jne	 SHORT $L302425
  00066	33 c0		 xor	 eax, eax
  00068	eb 15		 jmp	 SHORT $L302426
$L302425:
  0006a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006d	2b d3		 sub	 edx, ebx
  0006f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00074	f7 ea		 imul	 edx
  00076	d1 fa		 sar	 edx, 1
  00078	8b c2		 mov	 eax, edx
  0007a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007d	03 c2		 add	 eax, edx
$L302426:
  0007f	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  00084	2b d0		 sub	 edx, eax
  00086	3b d7		 cmp	 edx, edi
  00088	73 07		 jae	 SHORT $L273949

; 816  : 			_Xlen();	// result too long

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Xlen
$L302621:
$L273949:

; 817  : 		else if (_Capacity < size() + _Count)

  00091	85 db		 test	 ebx, ebx
  00093	75 04		 jne	 SHORT $L302432
  00095	33 c0		 xor	 eax, eax
  00097	eb 15		 jmp	 SHORT $L302433
$L302432:
  00099	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009c	2b d3		 sub	 edx, ebx
  0009e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000a3	f7 ea		 imul	 edx
  000a5	d1 fa		 sar	 edx, 1
  000a7	8b c2		 mov	 eax, edx
  000a9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ac	03 c2		 add	 eax, edx
$L302433:
  000ae	03 c7		 add	 eax, edi
  000b0	3b c8		 cmp	 ecx, eax
  000b2	0f 83 0e 01 00
	00		 jae	 $L273951

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000b8	8b c1		 mov	 eax, ecx
  000ba	d1 e8		 shr	 eax, 1
  000bc	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  000c1	2b d0		 sub	 edx, eax
  000c3	3b d1		 cmp	 edx, ecx
  000c5	73 04		 jae	 SHORT $L302392
  000c7	33 c9		 xor	 ecx, ecx
  000c9	eb 02		 jmp	 SHORT $L302393
$L302392:
  000cb	03 c8		 add	 ecx, eax
$L302393:

; 821  : 			if (_Capacity < size() + _Count)

  000cd	85 db		 test	 ebx, ebx
  000cf	75 04		 jne	 SHORT $L302455
  000d1	33 c0		 xor	 eax, eax
  000d3	eb 15		 jmp	 SHORT $L302456
$L302455:
  000d5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d8	2b d3		 sub	 edx, ebx
  000da	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000df	f7 ea		 imul	 edx
  000e1	d1 fa		 sar	 edx, 1
  000e3	8b c2		 mov	 eax, edx
  000e5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e8	03 c2		 add	 eax, edx
$L302456:
  000ea	03 c7		 add	 eax, edi
  000ec	3b c8		 cmp	 ecx, eax
  000ee	73 0b		 jae	 SHORT $L273952

; 822  : 				_Capacity = size() + _Count;

  000f0	8b ce		 mov	 ecx, esi
  000f2	e8 00 00 00 00	 call	 ?size@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::size
  000f7	8b c8		 mov	 ecx, eax
  000f9	03 cf		 add	 ecx, edi
$L273952:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000fb	8d 1c 49	 lea	 ebx, DWORD PTR [ecx+ecx*2]
  000fe	c1 e3 02	 shl	 ebx, 2
  00101	53		 push	 ebx
  00102	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00107	8b 55 08	 mov	 edx, DWORD PTR __Cat$302485[ebp]
  0010a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0010d	52		 push	 edx
  0010e	56		 push	 esi
  0010f	50		 push	 eax
  00110	89 45 10	 mov	 DWORD PTR __Newvec$273953[ebp], eax
  00113	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00116	50		 push	 eax
  00117	51		 push	 ecx
  00118	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0011f	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00124	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$302508[ebp]
  00127	83 c4 18	 add	 esp, 24			; 00000018H
  0012a	51		 push	 ecx
  0012b	56		 push	 esi
  0012c	8d 55 e4	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0012f	52		 push	 edx
  00130	57		 push	 edi
  00131	50		 push	 eax
  00132	89 45 0c	 mov	 DWORD PTR tv220[ebp], eax
  00135	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  0013a	8b 55 08	 mov	 edx, DWORD PTR __Cat$302531[ebp]
  0013d	8b 4d 0c	 mov	 ecx, DWORD PTR tv220[ebp]
  00140	83 c4 14	 add	 esp, 20			; 00000014H
  00143	52		 push	 edx
  00144	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00147	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	56		 push	 esi
  0014e	50		 push	 eax
  0014f	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00152	51		 push	 ecx
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  00159	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0015c	83 c4 14	 add	 esp, 20			; 00000014H
  0015f	85 c0		 test	 eax, eax
  00161	74 15		 je	 SHORT $L302545
$L302544:
  00163	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00166	2b c8		 sub	 ecx, eax
  00168	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0016d	f7 e9		 imul	 ecx
  0016f	d1 fa		 sar	 edx, 1
  00171	8b c2		 mov	 eax, edx
  00173	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00176	03 c2		 add	 eax, edx
$L302545:
  00178	03 f8		 add	 edi, eax

; 838  : 			if (_Myfirst != 0)

  0017a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0017d	85 c0		 test	 eax, eax
  0017f	74 09		 je	 SHORT $L302548

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00187	83 c4 04	 add	 esp, 4
$L302548:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  0018a	8b 45 10	 mov	 eax, DWORD PTR __Newvec$273953[ebp]

; 844  : 			_Mylast = _Newvec + _Count;

  0018d	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00190	03 d8		 add	 ebx, eax
  00192	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00195	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00198	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 845  : 			_Myfirst = _Newvec;

  0019b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 873  : 			}
; 874  : 		}

  0019e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 0c 00	 ret	 12			; 0000000cH
$L302395:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  001b1	8b 45 10	 mov	 eax, DWORD PTR __Newvec$273953[ebp]
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ba	83 c4 04	 add	 esp, 4
$L302397:

; 834  : 			_RERAISE;

  001bd	6a 00		 push	 0
  001bf	6a 00		 push	 0
  001c1	e8 00 00 00 00	 call	 __CxxThrowException@8
$L302622:
$L273951:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001c6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c9	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  001cc	8b d1		 mov	 edx, ecx
  001ce	2b d3		 sub	 edx, ebx
  001d0	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001d5	f7 ea		 imul	 edx
  001d7	d1 fa		 sar	 edx, 1
  001d9	8b c2		 mov	 eax, edx
  001db	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001de	03 c2		 add	 eax, edx
  001e0	3b c7		 cmp	 eax, edi
  001e2	89 4d 10	 mov	 DWORD PTR tv398[ebp], ecx
  001e5	73 78		 jae	 SHORT $L273964

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001e7	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  001ea	c1 e0 02	 shl	 eax, 2
  001ed	89 45 08	 mov	 DWORD PTR tv414[ebp], eax
  001f0	8b 55 08	 mov	 edx, DWORD PTR __Cat$302572[ebp]
  001f3	52		 push	 edx
  001f4	56		 push	 esi
  001f5	03 c3		 add	 eax, ebx
  001f7	50		 push	 eax
  001f8	51		 push	 ecx
  001f9	53		 push	 ebx
  001fa	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  001ff	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00202	83 c4 14	 add	 esp, 20			; 00000014H
  00205	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00208	50		 push	 eax
  00209	8b d1		 mov	 edx, ecx
  0020b	2b d3		 sub	 edx, ebx
  0020d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00212	f7 ea		 imul	 edx
  00214	d1 fa		 sar	 edx, 1
  00216	8b c2		 mov	 eax, edx
  00218	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0021b	03 c2		 add	 eax, edx
  0021d	2b f8		 sub	 edi, eax
  0021f	57		 push	 edi
  00220	51		 push	 ecx
  00221	8b ce		 mov	 ecx, esi
  00223	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0022a	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEPAU__GCPLAYERPOINT@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  0022f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00232	8b 45 08	 mov	 eax, DWORD PTR tv414[ebp]
  00235	03 f8		 add	 edi, eax
  00237	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  0023a	8d 4d e4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0023d	8b f7		 mov	 esi, edi
  0023f	51		 push	 ecx
  00240	2b f0		 sub	 esi, eax
  00242	56		 push	 esi
  00243	53		 push	 ebx
  00244	e8 00 00 00 00	 call	 ??$fill@PAU__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT>
  00249	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 			}
; 874  : 		}

  0024c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0024f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00256	5f		 pop	 edi
  00257	5e		 pop	 esi
  00258	5b		 pop	 ebx
  00259	8b e5		 mov	 esp, ebp
  0025b	5d		 pop	 ebp
  0025c	c2 0c 00	 ret	 12			; 0000000cH
$L273964:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  0025f	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  00262	8b c1		 mov	 eax, ecx
  00264	c1 e7 02	 shl	 edi, 2
  00267	2b c7		 sub	 eax, edi
  00269	89 45 08	 mov	 DWORD PTR tv427[ebp], eax
  0026c	8b 55 08	 mov	 edx, DWORD PTR __Cat$302596[ebp]
  0026f	52		 push	 edx
  00270	56		 push	 esi
  00271	51		 push	 ecx
  00272	51		 push	 ecx
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *,std::allocator<CGuildCombat::__GCPLAYERPOINT> >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00279	8b 4d 10	 mov	 ecx, DWORD PTR tv398[ebp]
  0027c	8b 55 08	 mov	 edx, DWORD PTR tv427[ebp]
  0027f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00282	8b 45 08	 mov	 eax, DWORD PTR __Cat$302609[ebp]
  00285	50		 push	 eax
  00286	51		 push	 ecx
  00287	52		 push	 edx
  00288	53		 push	 ebx
  00289	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__GCPLAYERPOINT@CGuildCombat@@PAU12@@std@@YAPAU__GCPLAYERPOINT@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0028e	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00291	50		 push	 eax
  00292	03 fb		 add	 edi, ebx
  00294	57		 push	 edi
  00295	53		 push	 ebx
  00296	e8 00 00 00 00	 call	 ??$fill@PAU__GCPLAYERPOINT@CGuildCombat@@U12@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCPLAYERPOINT *,CGuildCombat::__GCPLAYERPOINT>
  0029b	83 c4 30	 add	 esp, 48			; 00000030H
$L273973:

; 873  : 			}
; 874  : 		}

  0029e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002a1	5f		 pop	 edi
  002a2	5e		 pop	 esi
  002a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002aa	5b		 pop	 ebx
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c2 0c 00	 ret	 12			; 0000000cH
$L302616:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T302614
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Insert_n
; Function compile flags: /Ogty
;	COMDAT ?_Insert_n@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT
__Newvec$274020 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__GuildCombatMember@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L302638
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L302639
$L302638:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L302639:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L274040

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L302660
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L302661
$L302660:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L302661:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L274016

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Xlen
$L302792:
$L274016:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L302667
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L302668
$L302667:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L302668:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L274018

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L302627
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L302628
$L302627:
  0007f	03 c1		 add	 eax, ecx
$L302628:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L302690
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L302691
$L302690:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L302691:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L274019

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L302697
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L302698
$L302697:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L302698:
  000a7	03 c7		 add	 eax, edi
$L274019:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$274020[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU34@IABQAU34@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L302779
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L302780
$L302779:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L302780:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L302783

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L302783:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$274020[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L274018:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L274031
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAU__GuildCombatMember@CGuildCombat@@@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU23@00@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ucopy<CGuildCombat::__GuildCombatMember * *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU34@IABQAU34@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAPAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0ABQAU12@@Z ; std::fill<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember *>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L274031:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAU__GuildCombatMember@CGuildCombat@@@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEPAPAU__GuildCombatMember@CGuildCombat@@PAPAU23@00@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Ucopy<CGuildCombat::__GuildCombatMember * *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@@std@@YAPAPAU__GuildCombatMember@CGuildCombat@@PAPAU12@00@Z ; std::copy_backward<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember * *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAPAU__GuildCombatMember@CGuildCombat@@PAU12@@std@@YAXPAPAU__GuildCombatMember@CGuildCombat@@0ABQAU12@@Z ; std::fill<CGuildCombat::__GuildCombatMember * *,CGuildCombat::__GuildCombatMember *>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L274040:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L302791:
?_Insert_n@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__GuildCombatMember@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	56		 push	 esi

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 10		 je	 SHORT $L302844
  0000e	8b ff		 npad	 2
$L302842:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  00017	83 c6 04	 add	 esi, 4
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $L302842
$L302844:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 788  : 		}

  00020	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Destroy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T303156 DD	0ffffffffH
	DD	FLAT:$L302866
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T303158 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L302863
$T303159 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L302865
$T303157 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T303158
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T303159
$T303153 DD	019930520H
	DD	05H
	DD	FLAT:$T303156
	DD	02H
	DD	FLAT:$T303157
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
tv433 = -28						; size = 4
__Newvec$274087 = -28					; size = 4
_this$ = -24						; size = 4
tv449 = -20						; size = 4
tv448 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$303121 = 8					; size = 1
__Cat$303108 = 8					; size = 1
__Cat$303084 = 8					; size = 1
__Cat$303045 = 8					; size = 1
__Cat$303022 = 8					; size = 1
__Cat$302999 = 8					; size = 1
__Where$ = 8						; size = 4
__Ptr$274088 = 12					; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 10	 sub	 esp, 16			; 00000010H

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	83 e8 10	 sub	 eax, 16			; 00000010H
  00026	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00029	8b f1		 mov	 esi, ecx
  0002b	50		 push	 eax
  0002c	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0002f	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00034	83 c0 10	 add	 eax, 16			; 00000010H
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 10	 mov	 DWORD PTR __Tmp$[ebp], eax

; 811  : 		size_type _Capacity = capacity();

  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	33 d2		 xor	 edx, edx
  00042	3b ca		 cmp	 ecx, edx
  00044	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edx
  00047	75 04		 jne	 SHORT $L302908
  00049	33 c0		 xor	 eax, eax
  0004b	eb 08		 jmp	 SHORT $L302909
$L302908:
  0004d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00050	2b c1		 sub	 eax, ecx
  00052	c1 f8 02	 sar	 eax, 2
$L302909:

; 812  : 
; 813  : 		if (_Count == 0)

  00055	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00058	3b da		 cmp	 ebx, edx
  0005a	0f 84 0d 02 00
	00		 je	 $L274107

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00060	3b ca		 cmp	 ecx, edx
  00062	74 08		 je	 SHORT $L302931
  00064	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00067	2b d1		 sub	 edx, ecx
  00069	c1 fa 02	 sar	 edx, 2
$L302931:
  0006c	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  00071	2b fa		 sub	 edi, edx
  00073	3b fb		 cmp	 edi, ebx
  00075	73 07		 jae	 SHORT $L274083

; 816  : 			_Xlen();	// result too long

  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?_Xlen@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IBEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Xlen
$L303160:
$L274083:

; 817  : 		else if (_Capacity < size() + _Count)

  0007e	85 c9		 test	 ecx, ecx
  00080	75 04		 jne	 SHORT $L302937
  00082	33 d2		 xor	 edx, edx
  00084	eb 08		 jmp	 SHORT $L302938
$L302937:
  00086	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00089	2b d1		 sub	 edx, ecx
  0008b	c1 fa 02	 sar	 edx, 2
$L302938:
  0008e	03 d3		 add	 edx, ebx
  00090	3b c2		 cmp	 eax, edx
  00092	0f 83 09 01 00
	00		 jae	 $L274085

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00098	8b d0		 mov	 edx, eax
  0009a	d1 ea		 shr	 edx, 1
  0009c	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  000a1	2b fa		 sub	 edi, edx
  000a3	3b f8		 cmp	 edi, eax
  000a5	73 04		 jae	 SHORT $L302860
  000a7	33 c0		 xor	 eax, eax
  000a9	eb 02		 jmp	 SHORT $L302861
$L302860:
  000ab	03 c2		 add	 eax, edx
$L302861:

; 821  : 			if (_Capacity < size() + _Count)

  000ad	85 c9		 test	 ecx, ecx
  000af	75 04		 jne	 SHORT $L302960
  000b1	33 d2		 xor	 edx, edx
  000b3	eb 08		 jmp	 SHORT $L302961
$L302960:
  000b5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b8	2b d1		 sub	 edx, ecx
  000ba	c1 fa 02	 sar	 edx, 2
$L302961:
  000bd	03 d3		 add	 edx, ebx
  000bf	3b c2		 cmp	 eax, edx
  000c1	73 12		 jae	 SHORT $L274086

; 822  : 				_Capacity = size() + _Count;

  000c3	85 c9		 test	 ecx, ecx
  000c5	75 04		 jne	 SHORT $L302968
  000c7	33 c0		 xor	 eax, eax
  000c9	eb 08		 jmp	 SHORT $L302969
$L302968:
  000cb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ce	2b c1		 sub	 eax, ecx
  000d0	c1 f8 02	 sar	 eax, 2
$L302969:
  000d3	03 c3		 add	 eax, ebx
$L274086:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000d5	c1 e0 02	 shl	 eax, 2
  000d8	50		 push	 eax
  000d9	89 45 ec	 mov	 DWORD PTR tv448[ebp], eax
  000dc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000e1	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$302999[ebp]
  000e4	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  000e7	51		 push	 ecx
  000e8	8b f8		 mov	 edi, eax
  000ea	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ed	56		 push	 esi
  000ee	57		 push	 edi
  000ef	52		 push	 edx
  000f0	50		 push	 eax
  000f1	89 7d e4	 mov	 DWORD PTR __Newvec$274087[ebp], edi
  000f4	89 7d 0c	 mov	 DWORD PTR __Ptr$274088[ebp], edi
  000f7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000fb	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00100	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$303022[ebp]
  00103	83 c4 18	 add	 esp, 24			; 00000018H
  00106	51		 push	 ecx
  00107	56		 push	 esi
  00108	8d 55 10	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0010b	52		 push	 edx
  0010c	53		 push	 ebx
  0010d	50		 push	 eax
  0010e	89 45 0c	 mov	 DWORD PTR __Ptr$274088[ebp], eax
  00111	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00116	8b 55 08	 mov	 edx, DWORD PTR __Cat$303045[ebp]
  00119	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$274088[ebp]
  0011c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0011f	83 c4 14	 add	 esp, 20			; 00000014H
  00122	52		 push	 edx
  00123	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
  00126	56		 push	 esi
  00127	50		 push	 eax
  00128	89 45 0c	 mov	 DWORD PTR __Ptr$274088[ebp], eax
  0012b	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0012e	51		 push	 ecx
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  00135	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00138	83 c4 14	 add	 esp, 20			; 00000014H
  0013b	85 c9		 test	 ecx, ecx
  0013d	75 04		 jne	 SHORT $L303056
  0013f	33 c0		 xor	 eax, eax
  00141	eb 08		 jmp	 SHORT $L303057
$L303056:
  00143	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00146	2b c1		 sub	 eax, ecx
  00148	c1 f8 02	 sar	 eax, 2
$L303057:
  0014b	03 d8		 add	 ebx, eax

; 838  : 			if (_Myfirst != 0)

  0014d	85 c9		 test	 ecx, ecx
  0014f	74 18		 je	 SHORT $L303059

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00151	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00154	52		 push	 edx
  00155	51		 push	 ecx
  00156	8b ce		 mov	 ecx, esi
  00158	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0015d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00166	83 c4 04	 add	 esp, 4
$L303059:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00169	8b 45 ec	 mov	 eax, DWORD PTR tv448[ebp]
  0016c	03 c7		 add	 eax, edi

; 844  : 			_Mylast = _Newvec + _Count;

  0016e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]
  00171	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00174	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  00177	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  0017a	e9 ee 00 00 00	 jmp	 $L274107
$L302863:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0017f	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$274088[ebp]
  00182	8b 75 e4	 mov	 esi, DWORD PTR __Newvec$274087[ebp]
  00185	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	52		 push	 edx
  00189	56		 push	 esi
  0018a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0018f	56		 push	 esi
  00190	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00195	83 c4 04	 add	 esp, 4

; 834  : 			_RERAISE;

  00198	6a 00		 push	 0
  0019a	6a 00		 push	 0
  0019c	e8 00 00 00 00	 call	 __CxxThrowException@8
$L303161:
$L274085:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001a1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001a4	8b 7d 08	 mov	 edi, DWORD PTR __Where$[ebp]
  001a7	8b c8		 mov	 ecx, eax
  001a9	2b cf		 sub	 ecx, edi
  001ab	c1 f9 02	 sar	 ecx, 2
  001ae	3b cb		 cmp	 ecx, ebx

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001b0	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  001b7	89 45 e4	 mov	 DWORD PTR tv433[ebp], eax
  001ba	89 4d ec	 mov	 DWORD PTR tv449[ebp], ecx
  001bd	73 78		 jae	 SHORT $L274098
  001bf	8b 55 08	 mov	 edx, DWORD PTR __Cat$303084[ebp]
  001c2	52		 push	 edx
  001c3	56		 push	 esi
  001c4	03 cf		 add	 ecx, edi
  001c6	51		 push	 ecx
  001c7	50		 push	 eax
  001c8	57		 push	 edi
  001c9	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  001ce	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001d1	8b d0		 mov	 edx, eax
  001d3	83 c4 14	 add	 esp, 20			; 00000014H
  001d6	2b d7		 sub	 edx, edi
  001d8	8d 4d 10	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  001db	51		 push	 ecx
  001dc	c1 fa 02	 sar	 edx, 2
  001df	2b da		 sub	 ebx, edx
  001e1	53		 push	 ebx
  001e2	50		 push	 eax
  001e3	8b ce		 mov	 ecx, esi
  001e5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  001e9	e8 00 00 00 00	 call	 ?_Ufill@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV34@IABV34@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Ufill

; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  001ee	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  001f1	8b 45 ec	 mov	 eax, DWORD PTR tv449[ebp]
  001f4	03 d8		 add	 ebx, eax
  001f6	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  001f9	8d 4d 10	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  001fc	8b f3		 mov	 esi, ebx
  001fe	51		 push	 ecx
  001ff	2b f0		 sub	 esi, eax
  00201	56		 push	 esi
  00202	57		 push	 edi
  00203	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0020a	e8 00 00 00 00	 call	 ??$fill@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABV12@@Z ; std::fill<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
  0020f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  00212	eb 59		 jmp	 SHORT $L274107
$L302865:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00214	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0021a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0021d	c1 e0 02	 shl	 eax, 2
  00220	03 d0		 add	 edx, eax
  00222	52		 push	 edx
  00223	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00226	03 c2		 add	 eax, edx
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Destroy

; 857  : 			_RERAISE;

  0022e	6a 00		 push	 0
  00230	6a 00		 push	 0
  00232	e8 00 00 00 00	 call	 __CxxThrowException@8
$L303162:
$L274098:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  00237	8b d8		 mov	 ebx, eax
  00239	2b d9		 sub	 ebx, ecx
  0023b	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$303108[ebp]
  0023e	51		 push	 ecx
  0023f	56		 push	 esi
  00240	50		 push	 eax
  00241	50		 push	 eax
  00242	53		 push	 ebx
  00243	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00248	8b 55 08	 mov	 edx, DWORD PTR __Cat$303121[ebp]
  0024b	52		 push	 edx
  0024c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0024f	8b 45 e4	 mov	 eax, DWORD PTR tv433[ebp]
  00252	50		 push	 eax
  00253	53		 push	 ebx
  00254	57		 push	 edi
  00255	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@@std@@YAPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0025a	8b 55 ec	 mov	 edx, DWORD PTR tv449[ebp]
  0025d	8d 4d 10	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00260	51		 push	 ecx
  00261	03 d7		 add	 edx, edi
  00263	52		 push	 edx
  00264	57		 push	 edi
  00265	e8 00 00 00 00	 call	 ??$fill@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0ABV12@@Z ; std::fill<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > >
  0026a	83 c4 30	 add	 esp, 48			; 00000030H
$L274107:

; 873  : 			}
; 874  : 		}

  0026d	8b 45 10	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00270	83 c0 f0	 add	 eax, -16		; fffffff0H
  00273	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0027a	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0027d	83 ca ff	 or	 edx, -1
  00280	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00284	4a		 dec	 edx
  00285	85 d2		 test	 edx, edx
  00287	7f 08		 jg	 SHORT $L303148
  00289	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0028d	50		 push	 eax
  0028e	ff 52 04	 call	 DWORD PTR [edx+4]
$L303148:
  00291	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00294	5f		 pop	 edi
  00295	5e		 pop	 esi
  00296	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0029d	5b		 pop	 ebx
  0029e	8b e5		 mov	 esp, ebp
  002a0	5d		 pop	 ebp
  002a1	c2 0c 00	 ret	 12			; 0000000cH
$L303155:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L302866:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T303153
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Insert_n
PUBLIC	?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T303392 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T303394 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L303170
$T303395 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L303172
$T303393 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T303394
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T303395
$T303389 DD	019930520H
	DD	04H
	DD	FLAT:$T303392
	DD	02H
	DD	FLAT:$T303393
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT
__Tmp$ = -28						; size = 12
__$EHRec$ = -16						; size = 16
tv427 = 8						; size = 4
tv414 = 8						; size = 4
__Cat$303383 = 8					; size = 1
__Cat$303370 = 8					; size = 1
__Cat$303346 = 8					; size = 1
__Cat$303307 = 8					; size = 1
__Cat$303284 = 8					; size = 1
__Cat$303261 = 8					; size = 1
__Where$ = 8						; size = 4
tv220 = 12						; size = 4
__Count$ = 12						; size = 4
tv398 = 16						; size = 4
__Newvec$274154 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 10	 sub	 esp, 16			; 00000010H

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b f1		 mov	 esi, ecx
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 811  : 		size_type _Capacity = capacity();

  00027	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0002a	85 db		 test	 ebx, ebx
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	57		 push	 edi
  00030	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR __Tmp$[ebp], ecx
  00036	89 55 e8	 mov	 DWORD PTR __Tmp$[ebp+4], edx
  00039	89 45 ec	 mov	 DWORD PTR __Tmp$[ebp+8], eax
  0003c	75 04		 jne	 SHORT $L303177
  0003e	33 c9		 xor	 ecx, ecx
  00040	eb 15		 jmp	 SHORT $L303178
$L303177:
  00042	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00045	2b cb		 sub	 ecx, ebx
  00047	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004c	f7 e9		 imul	 ecx
  0004e	d1 fa		 sar	 edx, 1
  00050	8b ca		 mov	 ecx, edx
  00052	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00055	03 ca		 add	 ecx, edx
$L303178:

; 812  : 
; 813  : 		if (_Count == 0)

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	0f 84 3c 02 00
	00		 je	 $L274174

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00062	85 db		 test	 ebx, ebx
  00064	75 04		 jne	 SHORT $L303200
  00066	33 c0		 xor	 eax, eax
  00068	eb 15		 jmp	 SHORT $L303201
$L303200:
  0006a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0006d	2b d3		 sub	 edx, ebx
  0006f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00074	f7 ea		 imul	 edx
  00076	d1 fa		 sar	 edx, 1
  00078	8b c2		 mov	 eax, edx
  0007a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007d	03 c2		 add	 eax, edx
$L303201:
  0007f	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  00084	2b d0		 sub	 edx, eax
  00086	3b d7		 cmp	 edx, edi
  00088	73 07		 jae	 SHORT $L274150

; 816  : 			_Xlen();	// result too long

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Xlen
$L303396:
$L274150:

; 817  : 		else if (_Capacity < size() + _Count)

  00091	85 db		 test	 ebx, ebx
  00093	75 04		 jne	 SHORT $L303207
  00095	33 c0		 xor	 eax, eax
  00097	eb 15		 jmp	 SHORT $L303208
$L303207:
  00099	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0009c	2b d3		 sub	 edx, ebx
  0009e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000a3	f7 ea		 imul	 edx
  000a5	d1 fa		 sar	 edx, 1
  000a7	8b c2		 mov	 eax, edx
  000a9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ac	03 c2		 add	 eax, edx
$L303208:
  000ae	03 c7		 add	 eax, edi
  000b0	3b c8		 cmp	 ecx, eax
  000b2	0f 83 0e 01 00
	00		 jae	 $L274152

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000b8	8b c1		 mov	 eax, ecx
  000ba	d1 e8		 shr	 eax, 1
  000bc	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  000c1	2b d0		 sub	 edx, eax
  000c3	3b d1		 cmp	 edx, ecx
  000c5	73 04		 jae	 SHORT $L303167
  000c7	33 c9		 xor	 ecx, ecx
  000c9	eb 02		 jmp	 SHORT $L303168
$L303167:
  000cb	03 c8		 add	 ecx, eax
$L303168:

; 821  : 			if (_Capacity < size() + _Count)

  000cd	85 db		 test	 ebx, ebx
  000cf	75 04		 jne	 SHORT $L303230
  000d1	33 c0		 xor	 eax, eax
  000d3	eb 15		 jmp	 SHORT $L303231
$L303230:
  000d5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d8	2b d3		 sub	 edx, ebx
  000da	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000df	f7 ea		 imul	 edx
  000e1	d1 fa		 sar	 edx, 1
  000e3	8b c2		 mov	 eax, edx
  000e5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e8	03 c2		 add	 eax, edx
$L303231:
  000ea	03 c7		 add	 eax, edi
  000ec	3b c8		 cmp	 ecx, eax
  000ee	73 0b		 jae	 SHORT $L274153

; 822  : 				_Capacity = size() + _Count;

  000f0	8b ce		 mov	 ecx, esi
  000f2	e8 00 00 00 00	 call	 ?size@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::size
  000f7	8b c8		 mov	 ecx, eax
  000f9	03 cf		 add	 ecx, edi
$L274153:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000fb	8d 1c 49	 lea	 ebx, DWORD PTR [ecx+ecx*2]
  000fe	c1 e3 02	 shl	 ebx, 2
  00101	53		 push	 ebx
  00102	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00107	8b 55 08	 mov	 edx, DWORD PTR __Cat$303261[ebp]
  0010a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0010d	52		 push	 edx
  0010e	56		 push	 esi
  0010f	50		 push	 eax
  00110	89 45 10	 mov	 DWORD PTR __Newvec$274154[ebp], eax
  00113	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00116	50		 push	 eax
  00117	51		 push	 ecx
  00118	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0011f	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00124	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$303284[ebp]
  00127	83 c4 18	 add	 esp, 24			; 00000018H
  0012a	51		 push	 ecx
  0012b	56		 push	 esi
  0012c	8d 55 e4	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0012f	52		 push	 edx
  00130	57		 push	 edi
  00131	50		 push	 eax
  00132	89 45 0c	 mov	 DWORD PTR tv220[ebp], eax
  00135	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  0013a	8b 55 08	 mov	 edx, DWORD PTR __Cat$303307[ebp]
  0013d	8b 4d 0c	 mov	 ecx, DWORD PTR tv220[ebp]
  00140	83 c4 14	 add	 esp, 20			; 00000014H
  00143	52		 push	 edx
  00144	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00147	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	56		 push	 esi
  0014e	50		 push	 eax
  0014f	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00152	51		 push	 ecx
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  00159	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0015c	83 c4 14	 add	 esp, 20			; 00000014H
  0015f	85 c0		 test	 eax, eax
  00161	74 15		 je	 SHORT $L303319
$L303318:
  00163	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00166	2b c8		 sub	 ecx, eax
  00168	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0016d	f7 e9		 imul	 ecx
  0016f	d1 fa		 sar	 edx, 1
  00171	8b c2		 mov	 eax, edx
  00173	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00176	03 c2		 add	 eax, edx
$L303319:
  00178	03 f8		 add	 edi, eax

; 838  : 			if (_Myfirst != 0)

  0017a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0017d	85 c0		 test	 eax, eax
  0017f	74 09		 je	 SHORT $L303323

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00187	83 c4 04	 add	 esp, 4
$L303323:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  0018a	8b 45 10	 mov	 eax, DWORD PTR __Newvec$274154[ebp]

; 844  : 			_Mylast = _Newvec + _Count;

  0018d	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00190	03 d8		 add	 ebx, eax
  00192	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00195	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00198	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 845  : 			_Myfirst = _Newvec;

  0019b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 873  : 			}
; 874  : 		}

  0019e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 0c 00	 ret	 12			; 0000000cH
$L303170:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  001b1	8b 45 10	 mov	 eax, DWORD PTR __Newvec$274154[ebp]
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ba	83 c4 04	 add	 esp, 4
$L303172:

; 834  : 			_RERAISE;

  001bd	6a 00		 push	 0
  001bf	6a 00		 push	 0
  001c1	e8 00 00 00 00	 call	 __CxxThrowException@8
$L303397:
$L274152:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001c6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c9	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  001cc	8b d1		 mov	 edx, ecx
  001ce	2b d3		 sub	 edx, ebx
  001d0	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001d5	f7 ea		 imul	 edx
  001d7	d1 fa		 sar	 edx, 1
  001d9	8b c2		 mov	 eax, edx
  001db	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001de	03 c2		 add	 eax, edx
  001e0	3b c7		 cmp	 eax, edi
  001e2	89 4d 10	 mov	 DWORD PTR tv398[ebp], ecx
  001e5	73 78		 jae	 SHORT $L274165

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001e7	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  001ea	c1 e0 02	 shl	 eax, 2
  001ed	89 45 08	 mov	 DWORD PTR tv414[ebp], eax
  001f0	8b 55 08	 mov	 edx, DWORD PTR __Cat$303346[ebp]
  001f3	52		 push	 edx
  001f4	56		 push	 esi
  001f5	03 c3		 add	 eax, ebx
  001f7	50		 push	 eax
  001f8	51		 push	 ecx
  001f9	53		 push	 ebx
  001fa	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  001ff	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00202	83 c4 14	 add	 esp, 20			; 00000014H
  00205	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00208	50		 push	 eax
  00209	8b d1		 mov	 edx, ecx
  0020b	2b d3		 sub	 edx, ebx
  0020d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00212	f7 ea		 imul	 edx
  00214	d1 fa		 sar	 edx, 1
  00216	8b c2		 mov	 eax, edx
  00218	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0021b	03 c2		 add	 eax, edx
  0021d	2b f8		 sub	 edi, eax
  0021f	57		 push	 edi
  00220	51		 push	 ecx
  00221	8b ce		 mov	 ecx, esi
  00223	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  0022a	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEPAU__GCSENDITEM@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  0022f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00232	8b 45 08	 mov	 eax, DWORD PTR tv414[ebp]
  00235	03 f8		 add	 edi, eax
  00237	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  0023a	8d 4d e4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0023d	8b f7		 mov	 esi, edi
  0023f	51		 push	 ecx
  00240	2b f0		 sub	 esi, eax
  00242	56		 push	 esi
  00243	53		 push	 ebx
  00244	e8 00 00 00 00	 call	 ??$fill@PAU__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM>
  00249	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 			}
; 874  : 		}

  0024c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0024f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00256	5f		 pop	 edi
  00257	5e		 pop	 esi
  00258	5b		 pop	 ebx
  00259	8b e5		 mov	 esp, ebp
  0025b	5d		 pop	 ebp
  0025c	c2 0c 00	 ret	 12			; 0000000cH
$L274165:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  0025f	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  00262	8b c1		 mov	 eax, ecx
  00264	c1 e7 02	 shl	 edi, 2
  00267	2b c7		 sub	 eax, edi
  00269	89 45 08	 mov	 DWORD PTR tv427[ebp], eax
  0026c	8b 55 08	 mov	 edx, DWORD PTR __Cat$303370[ebp]
  0026f	52		 push	 edx
  00270	56		 push	 esi
  00271	51		 push	 ecx
  00272	51		 push	 ecx
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__GCSENDITEM@CGuildCombat@@PAU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *,std::allocator<CGuildCombat::__GCSENDITEM> >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00279	8b 4d 10	 mov	 ecx, DWORD PTR tv398[ebp]
  0027c	8b 55 08	 mov	 edx, DWORD PTR tv427[ebp]
  0027f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00282	8b 45 08	 mov	 eax, DWORD PTR __Cat$303383[ebp]
  00285	50		 push	 eax
  00286	51		 push	 ecx
  00287	52		 push	 edx
  00288	53		 push	 ebx
  00289	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__GCSENDITEM@CGuildCombat@@PAU12@@std@@YAPAU__GCSENDITEM@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  0028e	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00291	50		 push	 eax
  00292	03 fb		 add	 edi, ebx
  00294	57		 push	 edi
  00295	53		 push	 ebx
  00296	e8 00 00 00 00	 call	 ??$fill@PAU__GCSENDITEM@CGuildCombat@@U12@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__GCSENDITEM *,CGuildCombat::__GCSENDITEM>
  0029b	83 c4 30	 add	 esp, 48			; 00000030H
$L274174:

; 873  : 			}
; 874  : 		}

  0029e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002a1	5f		 pop	 edi
  002a2	5e		 pop	 esi
  002a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002aa	5b		 pop	 ebx
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c2 0c 00	 ret	 12			; 0000000cH
$L303391:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T303389
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T303627 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T303629 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L303405
$T303630 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L303407
$T303628 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T303629
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T303630
$T303624 DD	019930520H
	DD	04H
	DD	FLAT:$T303627
	DD	02H
	DD	FLAT:$T303628
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Tmp$ = -40						; size = 24
__$EHRec$ = -16						; size = 16
tv427 = 8						; size = 4
tv414 = 8						; size = 4
__Cat$303618 = 8					; size = 1
__Cat$303604 = 8					; size = 1
__Cat$303580 = 8					; size = 1
__Cat$303541 = 8					; size = 1
__Cat$303520 = 8					; size = 1
__Cat$303495 = 8					; size = 1
__Where$ = 8						; size = 4
tv220 = 12						; size = 4
__Count$ = 12						; size = 4
tv398 = 16						; size = 4
__Newvec$274865 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b f1		 mov	 esi, ecx
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 811  : 		size_type _Capacity = capacity();

  00027	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0002a	85 db		 test	 ebx, ebx
  0002c	89 4d d8	 mov	 DWORD PTR __Tmp$[ebp], ecx
  0002f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00032	89 55 dc	 mov	 DWORD PTR __Tmp$[ebp+4], edx
  00035	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00038	89 4d e0	 mov	 DWORD PTR __Tmp$[ebp+8], ecx
  0003b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003e	89 55 e4	 mov	 DWORD PTR __Tmp$[ebp+12], edx
  00041	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00044	57		 push	 edi
  00045	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00048	89 4d e8	 mov	 DWORD PTR __Tmp$[ebp+16], ecx
  0004b	89 55 ec	 mov	 DWORD PTR __Tmp$[ebp+20], edx
  0004e	75 04		 jne	 SHORT $L303413
  00050	33 c9		 xor	 ecx, ecx
  00052	eb 16		 jmp	 SHORT $L303414
$L303413:
  00054	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00057	2b cb		 sub	 ecx, ebx
  00059	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005e	f7 e9		 imul	 ecx
  00060	c1 fa 02	 sar	 edx, 2
  00063	8b ca		 mov	 ecx, edx
  00065	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00068	03 ca		 add	 ecx, edx
$L303414:

; 812  : 
; 813  : 		if (_Count == 0)

  0006a	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0006d	85 ff		 test	 edi, edi
  0006f	0f 84 42 02 00
	00		 je	 $L274885

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00075	85 db		 test	 ebx, ebx
  00077	75 04		 jne	 SHORT $L303436
  00079	33 c0		 xor	 eax, eax
  0007b	eb 16		 jmp	 SHORT $L303437
$L303436:
  0007d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00080	2b d3		 sub	 edx, ebx
  00082	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00087	f7 ea		 imul	 edx
  00089	c1 fa 02	 sar	 edx, 2
  0008c	8b c2		 mov	 eax, edx
  0008e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00091	03 c2		 add	 eax, edx
$L303437:
  00093	ba aa aa aa 0a	 mov	 edx, 178956970		; 0aaaaaaaH
  00098	2b d0		 sub	 edx, eax
  0009a	3b d7		 cmp	 edx, edi
  0009c	73 07		 jae	 SHORT $L274861

; 816  : 			_Xlen();	// result too long

  0009e	8b ce		 mov	 ecx, esi
  000a0	e8 00 00 00 00	 call	 ?_Xlen@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IBEXXZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Xlen
$L303631:
$L274861:

; 817  : 		else if (_Capacity < size() + _Count)

  000a5	85 db		 test	 ebx, ebx
  000a7	75 04		 jne	 SHORT $L303443
  000a9	33 c0		 xor	 eax, eax
  000ab	eb 16		 jmp	 SHORT $L303444
$L303443:
  000ad	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b0	2b d3		 sub	 edx, ebx
  000b2	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000b7	f7 ea		 imul	 edx
  000b9	c1 fa 02	 sar	 edx, 2
  000bc	8b c2		 mov	 eax, edx
  000be	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c1	03 c2		 add	 eax, edx
$L303444:
  000c3	03 c7		 add	 eax, edi
  000c5	3b c8		 cmp	 ecx, eax
  000c7	0f 83 10 01 00
	00		 jae	 $L274863

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  000cd	8b c1		 mov	 eax, ecx
  000cf	d1 e8		 shr	 eax, 1
  000d1	ba aa aa aa 0a	 mov	 edx, 178956970		; 0aaaaaaaH
  000d6	2b d0		 sub	 edx, eax
  000d8	3b d1		 cmp	 edx, ecx
  000da	73 04		 jae	 SHORT $L303402
  000dc	33 c9		 xor	 ecx, ecx
  000de	eb 02		 jmp	 SHORT $L303403
$L303402:
  000e0	03 c8		 add	 ecx, eax
$L303403:

; 821  : 			if (_Capacity < size() + _Count)

  000e2	85 db		 test	 ebx, ebx
  000e4	75 04		 jne	 SHORT $L303466
  000e6	33 c0		 xor	 eax, eax
  000e8	eb 16		 jmp	 SHORT $L303467
$L303466:
  000ea	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ed	2b d3		 sub	 edx, ebx
  000ef	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000f4	f7 ea		 imul	 edx
  000f6	c1 fa 02	 sar	 edx, 2
  000f9	8b c2		 mov	 eax, edx
  000fb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000fe	03 c2		 add	 eax, edx
$L303467:
  00100	03 c7		 add	 eax, edi
  00102	3b c8		 cmp	 ecx, eax
  00104	73 0b		 jae	 SHORT $L274864

; 822  : 				_Capacity = size() + _Count;

  00106	8b ce		 mov	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?size@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::size
  0010d	8b c8		 mov	 ecx, eax
  0010f	03 cf		 add	 ecx, edi
$L274864:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  00111	8d 1c 49	 lea	 ebx, DWORD PTR [ecx+ecx*2]
  00114	c1 e3 03	 shl	 ebx, 3
  00117	53		 push	 ebx
  00118	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  0011d	8b 55 08	 mov	 edx, DWORD PTR __Cat$303495[ebp]
  00120	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00123	52		 push	 edx
  00124	56		 push	 esi
  00125	50		 push	 eax
  00126	89 45 10	 mov	 DWORD PTR __Newvec$274865[ebp], eax
  00129	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0012c	50		 push	 eax
  0012d	51		 push	 ecx
  0012e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00135	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  0013a	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$303520[ebp]
  0013d	83 c4 18	 add	 esp, 24			; 00000018H
  00140	51		 push	 ecx
  00141	56		 push	 esi
  00142	8d 55 d8	 lea	 edx, DWORD PTR __Tmp$[ebp]
  00145	52		 push	 edx
  00146	57		 push	 edi
  00147	50		 push	 eax
  00148	89 45 0c	 mov	 DWORD PTR tv220[ebp], eax
  0014b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00150	8b 55 08	 mov	 edx, DWORD PTR __Cat$303541[ebp]
  00153	8b 4d 0c	 mov	 ecx, DWORD PTR tv220[ebp]
  00156	83 c4 14	 add	 esp, 20			; 00000014H
  00159	52		 push	 edx
  0015a	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0015d	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00160	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00163	56		 push	 esi
  00164	50		 push	 eax
  00165	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00168	51		 push	 ecx
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  0016f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00172	83 c4 14	 add	 esp, 20			; 00000014H
  00175	85 c0		 test	 eax, eax
  00177	74 16		 je	 SHORT $L303555
$L303554:
  00179	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0017c	2b c8		 sub	 ecx, eax
  0017e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00183	f7 e9		 imul	 ecx
  00185	c1 fa 02	 sar	 edx, 2
  00188	8b c2		 mov	 eax, edx
  0018a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0018d	03 c2		 add	 eax, edx
$L303555:
  0018f	03 f8		 add	 edi, eax

; 838  : 			if (_Myfirst != 0)

  00191	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00194	85 c0		 test	 eax, eax
  00196	74 09		 je	 SHORT $L303557

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0019e	83 c4 04	 add	 esp, 4
$L303557:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001a1	8b 45 10	 mov	 eax, DWORD PTR __Newvec$274865[ebp]

; 844  : 			_Mylast = _Newvec + _Count;

  001a4	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  001a7	03 d8		 add	 ebx, eax
  001a9	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  001ac	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  001af	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 845  : 			_Myfirst = _Newvec;

  001b2	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 873  : 			}
; 874  : 		}

  001b5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5b		 pop	 ebx
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c2 0c 00	 ret	 12			; 0000000cH
$L303405:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  001c8	8b 45 10	 mov	 eax, DWORD PTR __Newvec$274865[ebp]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d1	83 c4 04	 add	 esp, 4
$L303407:

; 834  : 			_RERAISE;

  001d4	6a 00		 push	 0
  001d6	6a 00		 push	 0
  001d8	e8 00 00 00 00	 call	 __CxxThrowException@8
$L303632:
$L274863:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001dd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001e0	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  001e3	8b d1		 mov	 edx, ecx
  001e5	2b d3		 sub	 edx, ebx
  001e7	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001ec	f7 ea		 imul	 edx
  001ee	c1 fa 02	 sar	 edx, 2
  001f1	8b c2		 mov	 eax, edx
  001f3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001f6	03 c2		 add	 eax, edx
  001f8	3b c7		 cmp	 eax, edi
  001fa	89 4d 10	 mov	 DWORD PTR tv398[ebp], ecx
  001fd	73 79		 jae	 SHORT $L274876

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001ff	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00202	c1 e0 03	 shl	 eax, 3
  00205	89 45 08	 mov	 DWORD PTR tv414[ebp], eax
  00208	8b 55 08	 mov	 edx, DWORD PTR __Cat$303580[ebp]
  0020b	52		 push	 edx
  0020c	56		 push	 esi
  0020d	03 c3		 add	 eax, ebx
  0020f	50		 push	 eax
  00210	51		 push	 ecx
  00211	53		 push	 ebx
  00212	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00217	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0021a	83 c4 14	 add	 esp, 20			; 00000014H
  0021d	8d 45 d8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00220	50		 push	 eax
  00221	8b d1		 mov	 edx, ecx
  00223	2b d3		 sub	 edx, ebx
  00225	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0022a	f7 ea		 imul	 edx
  0022c	c1 fa 02	 sar	 edx, 2
  0022f	8b c2		 mov	 eax, edx
  00231	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00234	03 c2		 add	 eax, edx
  00236	2b f8		 sub	 edi, eax
  00238	57		 push	 edi
  00239	51		 push	 ecx
  0023a	8b ce		 mov	 ecx, esi
  0023c	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  00243	e8 00 00 00 00	 call	 ?_Ufill@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU__JOINPLAYER@CGuildCombat@@PAU34@IABU34@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00248	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0024b	8b 45 08	 mov	 eax, DWORD PTR tv414[ebp]
  0024e	03 f8		 add	 edi, eax
  00250	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00253	8d 4d d8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00256	8b f7		 mov	 esi, edi
  00258	51		 push	 ecx
  00259	2b f0		 sub	 esi, eax
  0025b	56		 push	 esi
  0025c	53		 push	 ebx
  0025d	e8 00 00 00 00	 call	 ??$fill@PAU__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER>
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 			}
; 874  : 		}

  00265	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00268	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0026f	5f		 pop	 edi
  00270	5e		 pop	 esi
  00271	5b		 pop	 ebx
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	c2 0c 00	 ret	 12			; 0000000cH
$L274876:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  00278	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  0027b	8b c1		 mov	 eax, ecx
  0027d	c1 e7 03	 shl	 edi, 3
  00280	2b c7		 sub	 eax, edi
  00282	89 45 08	 mov	 DWORD PTR tv427[ebp], eax
  00285	8b 55 08	 mov	 edx, DWORD PTR __Cat$303604[ebp]
  00288	52		 push	 edx
  00289	56		 push	 esi
  0028a	51		 push	 ecx
  0028b	51		 push	 ecx
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__JOINPLAYER@CGuildCombat@@PAU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER> >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  00292	8b 4d 10	 mov	 ecx, DWORD PTR tv398[ebp]
  00295	8b 55 08	 mov	 edx, DWORD PTR tv427[ebp]
  00298	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0029b	8b 45 08	 mov	 eax, DWORD PTR __Cat$303618[ebp]
  0029e	50		 push	 eax
  0029f	51		 push	 ecx
  002a0	52		 push	 edx
  002a1	53		 push	 ebx
  002a2	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAU__JOINPLAYER@CGuildCombat@@PAU12@@std@@YAPAU__JOINPLAYER@CGuildCombat@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  002a7	8d 45 d8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  002aa	50		 push	 eax
  002ab	03 fb		 add	 edi, ebx
  002ad	57		 push	 edi
  002ae	53		 push	 ebx
  002af	e8 00 00 00 00	 call	 ??$fill@PAU__JOINPLAYER@CGuildCombat@@U12@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@0ABU12@@Z ; std::fill<CGuildCombat::__JOINPLAYER *,CGuildCombat::__JOINPLAYER>
  002b4	83 c4 30	 add	 esp, 48			; 00000030H
$L274885:

; 873  : 			}
; 874  : 		}

  002b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002ba	5f		 pop	 edi
  002bb	5e		 pop	 esi
  002bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002c3	5b		 pop	 ebx
  002c4	8b e5		 mov	 esp, ebp
  002c6	5d		 pop	 ebp
  002c7	c2 0c 00	 ret	 12			; 0000000cH
$L303626:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T303624
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Insert_n
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC NEAR	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T303759 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1143 : 		erase(begin(), end());

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T303759[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4

; 1148 : 		_Myhead = 0, _Mysize = 0;

  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 1149 : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC NEAR ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi

; 580  : 		if (size() < capacity())

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	75 04		 jne	 SHORT $L303828
  00008	33 d2		 xor	 edx, edx
  0000a	eb 08		 jmp	 SHORT $L303829
$L303828:
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	2b d6		 sub	 edx, esi
  00011	c1 fa 02	 sar	 edx, 2
$L303829:
  00014	85 f6		 test	 esi, esi
  00016	74 21		 je	 SHORT $L270357
  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	2b c6		 sub	 eax, esi
  0001d	c1 f8 02	 sar	 eax, 2
  00020	3b d0		 cmp	 edx, eax
  00022	73 15		 jae	 SHORT $L270357

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0002b	8b 12		 mov	 edx, DWORD PTR [edx]
  0002d	89 10		 mov	 DWORD PTR [eax], edx
  0002f	83 c0 04	 add	 eax, 4
  00032	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00035	5e		 pop	 esi

; 584  : 		}

  00036	c2 04 00	 ret	 4
$L270357:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00039	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0003d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00040	52		 push	 edx
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
  00049	5e		 pop	 esi

; 584  : 		}

  0004a	c2 04 00	 ret	 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi

; 580  : 		if (size() < capacity())

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	75 04		 jne	 SHORT $L304015
  00008	33 d2		 xor	 edx, edx
  0000a	eb 08		 jmp	 SHORT $L304016
$L304015:
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	2b d6		 sub	 edx, esi
  00011	c1 fa 02	 sar	 edx, 2
$L304016:
  00014	85 f6		 test	 esi, esi
  00016	74 21		 je	 SHORT $L270487
  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	2b c6		 sub	 eax, esi
  0001d	c1 f8 02	 sar	 eax, 2
  00020	3b d0		 cmp	 edx, eax
  00022	73 15		 jae	 SHORT $L270487

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0002b	8b 12		 mov	 edx, DWORD PTR [edx]
  0002d	89 10		 mov	 DWORD PTR [eax], edx
  0002f	83 c0 04	 add	 eax, 4
  00032	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00035	5e		 pop	 esi

; 584  : 		}

  00036	c2 04 00	 ret	 4
$L270487:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00039	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0003d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00040	52		 push	 edx
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
  00049	5e		 pop	 esi

; 584  : 		}

  0004a	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
_TEXT	ENDS
PUBLIC	?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back, COMDAT
; _this$ = ecx

; 481  : 		_Insert(end(), _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  00019	6a 01		 push	 1
  0001b	8b ce		 mov	 ecx, esi
  0001d	8b d8		 mov	 ebx, eax
  0001f	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00027	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	89 1a		 mov	 DWORD PTR [edx], ebx
  0002e	5b		 pop	 ebx

; 482  : 		}

  0002f	c2 04 00	 ret	 4
?push_back@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
_TEXT	ENDS
PUBLIC	??0?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
_TEXT	ENDS
PUBLIC	??0?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
_TEXT	ENDS
PUBLIC	??0?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
_TEXT	ENDS
PUBLIC	??0?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
_TEXT	ENDS
PUBLIC	??4?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator=
; Function compile flags: /Ogty
;	COMDAT ??4?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Cat$304754 = 8					; size = 1
__Right$ = 8						; size = 4
??4?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator=, COMDAT
; _this$ = ecx

; 392  : 		{	// assign _Right

  00000	56		 push	 esi
  00001	57		 push	 edi

; 393  : 		if (this != &_Right)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR __Right$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	3b f7		 cmp	 esi, edi
  0000a	0f 84 2d 01 00
	00		 je	 $L304773
  00010	53		 push	 ebx

; 394  : 			{	// worth doing
; 395  : 
; 396  : 
; 397  : 			if (_Right.size() == 0)

  00011	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00014	33 d2		 xor	 edx, edx
  00016	3b da		 cmp	 ebx, edx
  00018	55		 push	 ebp
  00019	74 0e		 je	 SHORT $L304771
  0001b	8b 6f 08	 mov	 ebp, DWORD PTR [edi+8]
  0001e	8b cd		 mov	 ecx, ebp
  00020	2b cb		 sub	 ecx, ebx
  00022	c1 f9 03	 sar	 ecx, 3
  00025	3b ca		 cmp	 ecx, edx
  00027	75 24		 jne	 SHORT $L271497
$L304771:

; 398  : 				clear();	// new sequence empty, free storage

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	3b c2		 cmp	 eax, edx
  0002e	74 0b		 je	 SHORT $L304689
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00036	83 c4 04	 add	 esp, 4
  00039	33 d2		 xor	 edx, edx
$L304689:
  0003b	5d		 pop	 ebp
  0003c	5b		 pop	 ebx
  0003d	5f		 pop	 edi
  0003e	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00041	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00044	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 425  : 		}

  0004a	c2 04 00	 ret	 4
$L271497:

; 399  : 			else if (_Right.size() <= size())

  0004d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00050	3b c2		 cmp	 eax, edx
  00052	75 04		 jne	 SHORT $L304704
  00054	33 d2		 xor	 edx, edx
  00056	eb 08		 jmp	 SHORT $L304705
$L304704:
  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	2b d0		 sub	 edx, eax
  0005d	c1 fa 03	 sar	 edx, 3
$L304705:
  00060	3b ca		 cmp	 ecx, edx
  00062	77 40		 ja	 SHORT $L271499

; 400  : 				{	// enough elements, copy new and destroy old
; 401  : 				pointer _Ptr = copy(_Right._Myfirst, _Right._Mylast,
; 402  : 					_Myfirst);	// copy new

  00064	50		 push	 eax
  00065	55		 push	 ebp
  00066	53		 push	 ebx
  00067	e8 00 00 00 00	 call	 ??$copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z ; std::copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>

; 403  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 404  : 				_Mylast = _Myfirst + _Right.size();

  0006c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	85 c0		 test	 eax, eax
  00074	75 14		 jne	 SHORT $L304711
  00076	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00079	5d		 pop	 ebp
  0007a	33 ff		 xor	 edi, edi
  0007c	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  0007f	5b		 pop	 ebx
  00080	5f		 pop	 edi
  00081	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  00084	8b c6		 mov	 eax, esi
  00086	5e		 pop	 esi

; 425  : 		}

  00087	c2 04 00	 ret	 4

; 403  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 404  : 				_Mylast = _Myfirst + _Right.size();

$L304711:
  0008a	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  0008d	2b f8		 sub	 edi, eax
  0008f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00092	5d		 pop	 ebp
  00093	c1 ff 03	 sar	 edi, 3
  00096	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00099	5b		 pop	 ebx
  0009a	5f		 pop	 edi
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi

; 425  : 		}

  000a1	c2 04 00	 ret	 4
$L271499:

; 405  : 				}
; 406  : 			else if (_Right.size() <= capacity())

  000a4	85 c0		 test	 eax, eax
  000a6	75 04		 jne	 SHORT $L304724
  000a8	33 d2		 xor	 edx, edx
  000aa	eb 08		 jmp	 SHORT $L304725
$L304724:
  000ac	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000af	2b d0		 sub	 edx, eax
  000b1	c1 fa 03	 sar	 edx, 3
$L304725:
  000b4	3b ca		 cmp	 ecx, edx
  000b6	77 41		 ja	 SHORT $L271509

; 407  : 				{	// enough room, copy and construct new
; 408  : 				pointer _Ptr = _Right._Myfirst + size();

  000b8	85 c0		 test	 eax, eax
  000ba	75 04		 jne	 SHORT $L304732
  000bc	33 d2		 xor	 edx, edx
  000be	eb 08		 jmp	 SHORT $L304733
$L304732:
  000c0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000c3	2b d0		 sub	 edx, eax
  000c5	c1 fa 03	 sar	 edx, 3
$L304733:
  000c8	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 409  : 				copy(_Right._Myfirst, _Ptr, _Myfirst);

  000cb	50		 push	 eax
  000cc	8d 1c d1	 lea	 ebx, DWORD PTR [ecx+edx*8]
  000cf	53		 push	 ebx
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??$copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00@Z ; std::copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *>

; 410  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

  000d6	8b 54 24 20	 mov	 edx, DWORD PTR __Cat$304754[esp+24]
  000da	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000dd	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000e0	52		 push	 edx
  000e1	56		 push	 esi
  000e2	50		 push	 eax
  000e3	57		 push	 edi
  000e4	53		 push	 ebx
  000e5	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAU__REQUESTGUILD@CGuildCombat@@PAU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAPAU__REQUESTGUILD@CGuildCombat@@PAU12@00AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGuildCombat::__REQUESTGUILD *,CGuildCombat::__REQUESTGUILD *,std::allocator<CGuildCombat::__REQUESTGUILD> >
  000ea	83 c4 20	 add	 esp, 32			; 00000020H
  000ed	5d		 pop	 ebp
  000ee	5b		 pop	 ebx
  000ef	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f2	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  000f3	8b c6		 mov	 eax, esi
  000f5	5e		 pop	 esi

; 425  : 		}

  000f6	c2 04 00	 ret	 4
$L271509:

; 411  : 				}
; 412  : 			else
; 413  : 				{	// not enough room, allocate new array and construct new
; 414  : 				if (_Myfirst != 0)

  000f9	85 c0		 test	 eax, eax
  000fb	74 09		 je	 SHORT $L304761

; 415  : 					{	// discard old array
; 416  : 					_Destroy(_Myfirst, _Mylast);
; 417  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00103	83 c4 04	 add	 esp, 4
$L304761:

; 418  : 					}
; 419  : 				if (_Buy(_Right.size()))

  00106	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00109	85 c9		 test	 ecx, ecx
  0010b	75 04		 jne	 SHORT $L304769
  0010d	33 c0		 xor	 eax, eax
  0010f	eb 08		 jmp	 SHORT $L304770
$L304769:
  00111	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00114	2b c1		 sub	 eax, ecx
  00116	c1 f8 03	 sar	 eax, 3
$L304770:
  00119	50		 push	 eax
  0011a	8b ce		 mov	 ecx, esi
  0011c	e8 00 00 00 00	 call	 ?_Buy@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAE_NI@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Buy
  00121	84 c0		 test	 al, al
  00123	74 16		 je	 SHORT $L304772

; 420  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 421  : 						_Myfirst);

  00125	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00128	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0012b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0012e	50		 push	 eax
  0012f	51		 push	 ecx
  00130	52		 push	 edx
  00131	8b ce		 mov	 ecx, esi
  00133	e8 00 00 00 00	 call	 ??$_Ucopy@PAU__REQUESTGUILD@CGuildCombat@@@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEPAU__REQUESTGUILD@CGuildCombat@@PAU23@00@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Ucopy<CGuildCombat::__REQUESTGUILD *>
  00138	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L304772:
  0013b	5d		 pop	 ebp
  0013c	5b		 pop	 ebx
$L304773:
  0013d	5f		 pop	 edi

; 422  : 				}
; 423  : 			}
; 424  : 		return (*this);

  0013e	8b c6		 mov	 eax, esi
  00140	5e		 pop	 esi

; 425  : 		}

  00141	c2 04 00	 ret	 4
??4?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator=
_TEXT	ENDS
PUBLIC	?insert@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L304842
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 03	 sar	 eax, 3
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L304781
$L304842:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L304782
$L304781:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 03	 sar	 esi, 3
$L304782:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 f1	 lea	 edx, DWORD PTR [ecx+esi*8]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::insert
_TEXT	ENDS
PUBLIC	??0?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
_TEXT	ENDS
PUBLIC	??0?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L305028
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 02	 sar	 eax, 2
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L304967
$L305028:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L304968
$L304967:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 02	 sar	 esi, 2
$L304968:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv90 = 12						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	53		 push	 ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Where$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000c	85 f6		 test	 esi, esi
  0000e	74 1c		 je	 SHORT $L305094
  00010	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00013	2b ce		 sub	 ecx, esi
  00015	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0001a	f7 e9		 imul	 ecx
  0001c	c1 fa 03	 sar	 edx, 3
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
  00026	89 44 24 14	 mov	 DWORD PTR tv90[esp+8], eax
  0002a	75 04		 jne	 SHORT $L305033
$L305094:
  0002c	33 f6		 xor	 esi, esi
  0002e	eb 15		 jmp	 SHORT $L305034
$L305033:
  00030	8b cb		 mov	 ecx, ebx
  00032	2b ce		 sub	 ecx, esi
  00034	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00039	f7 e9		 imul	 ecx
  0003b	c1 fa 03	 sar	 edx, 3
  0003e	8b f2		 mov	 esi, edx
  00040	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00043	03 f2		 add	 esi, edx
$L305034:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00045	8b 4c 24 18	 mov	 ecx, DWORD PTR __Val$[esp+8]
  00049	51		 push	 ecx
  0004a	6a 01		 push	 1
  0004c	53		 push	 ebx
  0004d	8b cf		 mov	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00054	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00057	8d 14 f6	 lea	 edx, DWORD PTR [esi+esi*8]
  0005a	5f		 pop	 edi
  0005b	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0005e	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00062	5e		 pop	 esi
  00063	89 08		 mov	 DWORD PTR [eax], ecx
  00065	5b		 pop	 ebx

; 624  : 		}

  00066	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv90 = 12						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	53		 push	 ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Where$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000c	85 f6		 test	 esi, esi
  0000e	74 1b		 je	 SHORT $L305160
  00010	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00013	2b ce		 sub	 ecx, esi
  00015	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001a	f7 e9		 imul	 ecx
  0001c	d1 fa		 sar	 edx, 1
  0001e	8b c2		 mov	 eax, edx
  00020	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00023	03 c2		 add	 eax, edx
  00025	89 44 24 14	 mov	 DWORD PTR tv90[esp+8], eax
  00029	75 04		 jne	 SHORT $L305099
$L305160:
  0002b	33 f6		 xor	 esi, esi
  0002d	eb 14		 jmp	 SHORT $L305100
$L305099:
  0002f	8b cb		 mov	 ecx, ebx
  00031	2b ce		 sub	 ecx, esi
  00033	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00038	f7 e9		 imul	 ecx
  0003a	d1 fa		 sar	 edx, 1
  0003c	8b f2		 mov	 esi, edx
  0003e	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00041	03 f2		 add	 esi, edx
$L305100:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00043	8b 4c 24 18	 mov	 ecx, DWORD PTR __Val$[esp+8]
  00047	51		 push	 ecx
  00048	6a 01		 push	 1
  0004a	53		 push	 ebx
  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00052	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00055	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  00058	5f		 pop	 edi
  00059	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0005c	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00060	5e		 pop	 esi
  00061	89 08		 mov	 DWORD PTR [eax], ecx
  00063	5b		 pop	 ebx

; 624  : 		}

  00064	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__GuildCombatMember@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L305226
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 02	 sar	 eax, 2
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L305165
$L305226:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L305166
$L305165:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 02	 sar	 esi, 2
$L305166:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABQAU__GuildCombatMember@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@V312@ABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@V312@ABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@V312@ABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::insert, COMDAT
; _this$ = ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Where$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 0c		 je	 SHORT $L305292
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b c1		 sub	 eax, ecx
  00014	c1 f8 02	 sar	 eax, 2
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $L305231
$L305292:
  0001b	33 f6		 xor	 esi, esi
  0001d	eb 07		 jmp	 SHORT $L305232
$L305231:
  0001f	8b f2		 mov	 esi, edx
  00021	2b f1		 sub	 esi, ecx
  00023	c1 fe 02	 sar	 esi, 2
$L305232:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00026	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0002a	50		 push	 eax
  0002b	6a 01		 push	 1
  0002d	52		 push	 edx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Insert_n

; 623  : 		return (begin() + _Off);

  00035	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00038	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0003c	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  0003f	5f		 pop	 edi
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 624  : 		}

  00043	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE?AViterator@12@V312@ABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Tidy
; Function compile flags: /Ogty
;	COMDAT ?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 792  : 		if (_Myfirst != 0)

  00004	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00007	85 f6		 test	 esi, esi
  00009	74 23		 je	 SHORT $L305380
  0000b	57		 push	 edi

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  0000c	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0000f	3b f7		 cmp	 esi, edi
  00011	74 0e		 je	 SHORT $L305373
$L305371:
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  0001a	83 c6 04	 add	 esi, 4
  0001d	3b f7		 cmp	 esi, edi
  0001f	75 f2		 jne	 SHORT $L305371
$L305373:

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00021	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002a	83 c4 04	 add	 esp, 4
  0002d	5f		 pop	 edi
$L305380:
  0002e	5e		 pop	 esi

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0002f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00036	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  0003d	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  00044	5b		 pop	 ebx

; 798  : 		}

  00045	c3		 ret	 0
?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Tidy
_TEXT	ENDS
PUBLIC	?insert@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv90 = 12						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCSENDITEM@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	53		 push	 ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Where$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000c	85 f6		 test	 esi, esi
  0000e	74 1b		 je	 SHORT $L305450
  00010	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00013	2b ce		 sub	 ecx, esi
  00015	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001a	f7 e9		 imul	 ecx
  0001c	d1 fa		 sar	 edx, 1
  0001e	8b c2		 mov	 eax, edx
  00020	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00023	03 c2		 add	 eax, edx
  00025	89 44 24 14	 mov	 DWORD PTR tv90[esp+8], eax
  00029	75 04		 jne	 SHORT $L305389
$L305450:
  0002b	33 f6		 xor	 esi, esi
  0002d	eb 14		 jmp	 SHORT $L305390
$L305389:
  0002f	8b cb		 mov	 ecx, ebx
  00031	2b ce		 sub	 ecx, esi
  00033	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00038	f7 e9		 imul	 ecx
  0003a	d1 fa		 sar	 edx, 1
  0003c	8b f2		 mov	 esi, edx
  0003e	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00041	03 f2		 add	 esi, edx
$L305390:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00043	8b 4c 24 18	 mov	 ecx, DWORD PTR __Val$[esp+8]
  00047	51		 push	 ecx
  00048	6a 01		 push	 1
  0004a	53		 push	 ebx
  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00052	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00055	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  00058	5f		 pop	 edi
  00059	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0005c	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00060	5e		 pop	 esi
  00061	89 08		 mov	 DWORD PTR [eax], ecx
  00063	5b		 pop	 ebx

; 624  : 		}

  00064	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCSENDITEM@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::insert
; Function compile flags: /Ogty
;	COMDAT ?insert@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv90 = 12						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	53		 push	 ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR __Where$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000c	85 f6		 test	 esi, esi
  0000e	74 1c		 je	 SHORT $L305516
  00010	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00013	2b ce		 sub	 ecx, esi
  00015	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001a	f7 e9		 imul	 ecx
  0001c	c1 fa 02	 sar	 edx, 2
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
  00026	89 44 24 14	 mov	 DWORD PTR tv90[esp+8], eax
  0002a	75 04		 jne	 SHORT $L305455
$L305516:
  0002c	33 f6		 xor	 esi, esi
  0002e	eb 15		 jmp	 SHORT $L305456
$L305455:
  00030	8b cb		 mov	 ecx, ebx
  00032	2b ce		 sub	 ecx, esi
  00034	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00039	f7 e9		 imul	 ecx
  0003b	c1 fa 02	 sar	 edx, 2
  0003e	8b f2		 mov	 esi, edx
  00040	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00043	03 f2		 add	 esi, edx
$L305456:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00045	8b 4c 24 18	 mov	 ecx, DWORD PTR __Val$[esp+8]
  00049	51		 push	 ecx
  0004a	6a 01		 push	 1
  0004c	53		 push	 ebx
  0004d	8b cf		 mov	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00054	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00057	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  0005a	5f		 pop	 edi
  0005b	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  0005e	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00062	5e		 pop	 esi
  00063	89 08		 mov	 DWORD PTR [eax], ecx
  00065	5b		 pop	 ebx

; 624  : 		}

  00066	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::insert
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T305586 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >, COMDAT
; _this$ = ecx

; 391  : 		{	// destroy tree

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 392  : 		_Tidy();

  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T305586[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi

; 393  : 		}

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??0__GuildCombatMember@CGuildCombat@@QAE@XZ	; CGuildCombat::__GuildCombatMember::__GuildCombatMember
;	COMDAT xdata$x
xdata$x	SEGMENT
$T305794 DD	0ffffffffH
	DD	FLAT:$L305615
$T305792 DD	019930520H
	DD	01H
	DD	FLAT:$T305794
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0__GuildCombatMember@CGuildCombat@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0__GuildCombatMember@CGuildCombat@@QAE@XZ PROC NEAR	; CGuildCombat::__GuildCombatMember::__GuildCombatMember, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0__GuildCombatMember@CGuildCombat@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	33 db		 xor	 ebx, ebx
  0001c	57		 push	 edi
  0001d	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00021	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00024	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00027	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0002a	8d 7e 2c	 lea	 edi, DWORD PTR [esi+44]
  0002d	8b cf		 mov	 ecx, edi
  0002f	89 5c 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], ebx
  00033	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@XZ ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  00038	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0003c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0003f	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00042	5f		 pop	 edi
  00043	8b c6		 mov	 eax, esi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L305615:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::~vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >
__ehhandler$??0__GuildCombatMember@CGuildCombat@@QAE@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T305792
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0__GuildCombatMember@CGuildCombat@@QAE@XZ ENDP	; CGuildCombat::__GuildCombatMember::__GuildCombatMember
PUBLIC	??_C@_01ELNMCGJD@W?$AA@				; `string'
PUBLIC	??_C@_0DO@MCMLJPCC@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@ ; `string'
PUBLIC	?GuildCombatResultRanking@CGuildCombat@@QAEXXZ	; CGuildCombat::GuildCombatResultRanking
PUBLIC	??_C@_0CP@COFMEPEI@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@ ; `string'
PUBLIC	??_C@_0DB@KEJMOH@GuildCombatResultRanking?$CI?$CJ?5?9?5pJo@ ; `string'
PUBLIC	??_C@_0BB@IBCONAGB@GUILDCOMBAT_CHIP?$AA@	; `string'
PUBLIC	??_C@_0BG@CENMBALP@GUILDCOMBAT_CHIP_POST?$AA@	; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@35719787
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3f333333
PUBLIC	__real@4f800000
EXTRN	?AddDefinedText@CUser@@QAAXHPBDZZ:NEAR		; CUser::AddDefinedText
EXTRN	?CreateItem@CMover@@QAEHPAVCItemBase@@PAEPAFE@Z:NEAR ; CMover::CreateItem
EXTRN	?SendQueryPostMail@CDPDatabaseClient@@QAEXKKAAVCItemElem@@HPAD1@Z:NEAR ; CDPDatabaseClient::SendQueryPostMail
EXTRN	?SetSerialNumber@CItemBase@@QAEXXZ:NEAR		; CItemBase::SetSerialNumber
EXTRN	??0CItemElem@@QAE@XZ:NEAR			; CItemElem::CItemElem
EXTRN	??1CItemElem@@UAE@XZ:NEAR			; CItemElem::~CItemElem
EXTRN	?GetItemNum@CMover@@QAEHK@Z:NEAR		; CMover::GetItemNum
EXTRN	__ftol2:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T308112 DD	0ffffffffH
	DD	FLAT:$L305801
	DD	00H
	DD	FLAT:$L305802
$T308064 DD	019930520H
	DD	02H
	DD	FLAT:$T308112
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0DO@MCMLJPCC@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@
CONST	SEGMENT
??_C@_0DO@MCMLJPCC@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@ DB 'GuildCo'
	DB	'mbatResultRanking() - pGCMember1 or pGCMember2 is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@COFMEPEI@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@
CONST	SEGMENT
??_C@_0CP@COFMEPEI@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@ DB 'GuildCo'
	DB	'mbatResultRanking() - pGCMember is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT __real@35719787
CONST	SEGMENT
__real@35719787 DD 035719787r			; 9e-007
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT ??_C@_01ELNMCGJD@W?$AA@
CONST	SEGMENT
??_C@_01ELNMCGJD@W?$AA@ DB 'W', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KEJMOH@GuildCombatResultRanking?$CI?$CJ?5?9?5pJo@
CONST	SEGMENT
??_C@_0DB@KEJMOH@GuildCombatResultRanking?$CI?$CJ?5?9?5pJo@ DB 'GuildComb'
	DB	'atResultRanking() - pJoinPlayer is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IBCONAGB@GUILDCOMBAT_CHIP?$AA@
CONST	SEGMENT
??_C@_0BB@IBCONAGB@GUILDCOMBAT_CHIP?$AA@ DB 'GUILDCOMBAT_CHIP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CENMBALP@GUILDCOMBAT_CHIP_POST?$AA@
CONST	SEGMENT
??_C@_0BG@CENMBALP@GUILDCOMBAT_CHIP_POST?$AA@ DB 'GUILDCOMBAT_CHIP_POST', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?GuildCombatResultRanking@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_i$269009 = -464					; size = 4
_j$268941 = -464					; size = 4
_pGCMem$307643 = -460					; size = 4
_i$268935 = -460					; size = 4
$T307071 = -456						; size = 4
_pGCMem$306077 = -456					; size = 4
tv2048 = -452						; size = 4
tv2044 = -448						; size = 4
_fAvg1$268979 = -448					; size = 4
_pGCMem$306344 = -444					; size = 4
tv2035 = -440						; size = 4
$T307224 = -440						; size = 4
_nCount$268978 = -440					; size = 4
_RequestGuild2$268948 = -440				; size = 8
_RequestGuild1$268946 = -440				; size = 8
_i$307878 = -432					; size = 4
_i$307203 = -432					; size = 4
_vecGCRanking$ = -428					; size = 16
tv2017 = -412						; size = 4
$T307900 = -412						; size = 4
$T308062 = -412						; size = 4
_RequestGuild$269015 = -412				; size = 8
_i$307049 = -404					; size = 4
_itemElem$269019 = -400					; size = 184
_aLogItem$269030 = -216					; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?GuildCombatResultRanking@CGuildCombat@@QAEXXZ PROC NEAR ; CGuildCombat::GuildCombatResultRanking, COMDAT
; _this$ = ecx

; 1451 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GuildCombatResultRanking@CGuildCombat@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec c4 01 00
	00		 sub	 esp, 452		; 000001c4H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi

; 1452 : 	vector<__REQUESTGUILD> vecGCRanking;

  00025	33 f6		 xor	 esi, esi
  00027	8b d9		 mov	 ebx, ecx
  00029	89 84 24 cc 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+476], eax
  00030	57		 push	 edi

; 1453 : 	vecGCRanking = vecRequestRanking;
; 1454 : 	
; 1455 : 	for( int i=0; i<(int)( vecGCRanking.size()-1 ); i++ )

  00031	89 5c 24 44	 mov	 DWORD PTR $T308062[esp+480], ebx
  00035	89 74 24 38	 mov	 DWORD PTR _vecGCRanking$[esp+484], esi
  00039	89 74 24 3c	 mov	 DWORD PTR _vecGCRanking$[esp+488], esi
  0003d	89 74 24 40	 mov	 DWORD PTR _vecGCRanking$[esp+492], esi
  00041	8d 83 10 11 00
	00		 lea	 eax, DWORD PTR [ebx+4368]
  00047	50		 push	 eax
  00048	8d 4c 24 38	 lea	 ecx, DWORD PTR _vecGCRanking$[esp+484]
  0004c	89 b4 24 e0 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+492], esi
  00053	e8 00 00 00 00	 call	 ??4?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::operator=
  00058	8b 54 24 3c	 mov	 edx, DWORD PTR _vecGCRanking$[esp+488]
  0005c	8b 6c 24 38	 mov	 ebp, DWORD PTR _vecGCRanking$[esp+484]
  00060	33 c9		 xor	 ecx, ecx
$L308108:
  00062	33 ff		 xor	 edi, edi
  00064	3b ef		 cmp	 ebp, edi
  00066	89 4c 24 14	 mov	 DWORD PTR _i$268935[esp+480], ecx
  0006a	75 04		 jne	 SHORT $L305893
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 07		 jmp	 SHORT $L305894
$L305893:
  00070	8b c2		 mov	 eax, edx
  00072	2b c5		 sub	 eax, ebp
  00074	c1 f8 03	 sar	 eax, 3
$L305894:
  00077	48		 dec	 eax
  00078	3b c8		 cmp	 ecx, eax
  0007a	0f 8d 1b 03 00
	00		 jge	 $L268939

; 1456 : 	{
; 1457 : 		if( i >= m_nMaxGuild )

  00080	3b 8b a0 10 00
	00		 cmp	 ecx, DWORD PTR [ebx+4256]
  00086	0f 8d 0f 03 00
	00		 jge	 $L268939

; 1458 : 			break;
; 1459 : 		//  
; 1460 : 		for( int j=0; j<(int)( vecGCRanking.size()-1-i ); j++ )

  0008c	89 7c 24 10	 mov	 DWORD PTR _j$268941[esp+480], edi
  00090	8b fd		 mov	 edi, ebp
  00092	89 7c 24 1c	 mov	 DWORD PTR tv2048[esp+480], edi
$L268943:
  00096	85 ed		 test	 ebp, ebp
  00098	75 04		 jne	 SHORT $L305900
  0009a	33 c0		 xor	 eax, eax
  0009c	eb 07		 jmp	 SHORT $L305901
$L305900:
  0009e	8b c2		 mov	 eax, edx
  000a0	2b c5		 sub	 eax, ebp
  000a2	c1 f8 03	 sar	 eax, 3
$L305901:
  000a5	8b 74 24 10	 mov	 esi, DWORD PTR _j$268941[esp+480]
  000a9	2b c1		 sub	 eax, ecx
  000ab	48		 dec	 eax
  000ac	3b f0		 cmp	 esi, eax
  000ae	0f 8d c2 02 00
	00		 jge	 $L268938

; 1461 : 		{
; 1462 : 			__REQUESTGUILD RequestGuild1 = vecGCRanking[j];

  000b4	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000b7	8b 37		 mov	 esi, DWORD PTR [edi]
  000b9	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  000bc	89 4c 24 2c	 mov	 DWORD PTR _RequestGuild1$268946[esp+484], ecx

; 1463 : 			__GuildCombatMember* pGCMember1 = FindGuildCombatMember( RequestGuild1.uidGuild );

  000c0	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _pGCMem$306077[esp+480], 0
  000c8	33 c9		 xor	 ecx, ecx
  000ca	8d 9b 00 00 00
	00		 npad	 6
$L306079:
  000d0	85 d2		 test	 edx, edx
  000d2	75 04		 jne	 SHORT $L306086
  000d4	33 c0		 xor	 eax, eax
  000d6	eb 08		 jmp	 SHORT $L306087
$L306086:
  000d8	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  000db	2b c2		 sub	 eax, edx
  000dd	c1 f8 02	 sar	 eax, 2
$L306087:
  000e0	3b c8		 cmp	 ecx, eax
  000e2	7d 1b		 jge	 SHORT $L306081
  000e4	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  000e7	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	3b 30		 cmp	 esi, DWORD PTR [eax]
  000ee	74 03		 je	 SHORT $L308076
  000f0	41		 inc	 ecx
  000f1	eb dd		 jmp	 SHORT $L306079
$L308076:
  000f3	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  000f6	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000f9	8b 00		 mov	 eax, DWORD PTR [eax]
  000fb	89 44 24 18	 mov	 DWORD PTR _pGCMem$306077[esp+480], eax
$L306081:

; 1464 : 			__REQUESTGUILD RequestGuild2 = vecGCRanking[j+1];

  000ff	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00102	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00105	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]

; 1465 : 			__GuildCombatMember* pGCMember2 = FindGuildCombatMember( RequestGuild2.uidGuild );

  00108	33 ed		 xor	 ebp, ebp
  0010a	89 4c 24 2c	 mov	 DWORD PTR _RequestGuild2$268948[esp+484], ecx
  0010e	89 6c 24 24	 mov	 DWORD PTR _pGCMem$306344[esp+480], ebp
  00112	33 c9		 xor	 ecx, ecx
$L306346:
  00114	85 d2		 test	 edx, edx
  00116	75 04		 jne	 SHORT $L306302
  00118	33 c0		 xor	 eax, eax
  0011a	eb 08		 jmp	 SHORT $L306303
$L306302:
  0011c	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  0011f	2b c2		 sub	 eax, edx
  00121	c1 f8 02	 sar	 eax, 2
$L306303:
  00124	3b c8		 cmp	 ecx, eax
  00126	7d 1c		 jge	 SHORT $L306348
  00128	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  0012b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0012e	8b 00		 mov	 eax, DWORD PTR [eax]
  00130	3b 30		 cmp	 esi, DWORD PTR [eax]
  00132	74 03		 je	 SHORT $L308077
  00134	41		 inc	 ecx
  00135	eb dd		 jmp	 SHORT $L306346
$L308077:
  00137	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  0013a	8b 2c 8a	 mov	 ebp, DWORD PTR [edx+ecx*4]
  0013d	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00140	89 6c 24 24	 mov	 DWORD PTR _pGCMem$306344[esp+480], ebp
$L306348:

; 1466 : 			
; 1467 : 			if( !pGCMember1 || !pGCMember2 )

  00144	8b 74 24 18	 mov	 esi, DWORD PTR _pGCMem$306077[esp+480]
  00148	85 f6		 test	 esi, esi
  0014a	0f 84 2c 02 00
	00		 je	 $L308078
  00150	85 ed		 test	 ebp, ebp
  00152	0f 84 24 02 00
	00		 je	 $L308078

; 1471 : 			}
; 1472 : 
; 1473 : 			//     
; 1474 : 			if( pGCMember1->nGuildPoint < pGCMember2->nGuildPoint )

  00158	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0015b	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  0015e	3b c1		 cmp	 eax, ecx
  00160	7d 1b		 jge	 SHORT $L308105

; 1475 : 			{
; 1476 : 				__REQUESTGUILD temp = vecGCRanking[j];
; 1477 : 				vecGCRanking[j] = vecGCRanking[j+1];

  00162	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00165	8b 07		 mov	 eax, DWORD PTR [edi]
  00167	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0016a	89 17		 mov	 DWORD PTR [edi], edx
  0016c	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0016f	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 1478 : 				vecGCRanking[j+1] = temp;

  00172	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00175	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx

; 1479 : 			}
; 1480 : 			//       
; 1481 : 			else if( pGCMember1->nGuildPoint == pGCMember2->nGuildPoint )

  00178	e9 ce 01 00 00	 jmp	 $L268944
$L308105:
  0017d	0f 85 c8 01 00
	00		 jne	 $L268944
  00183	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1482 : 			{
; 1483 : 				int nLife1=0, nLife2=0;

  00186	33 db		 xor	 ebx, ebx
  00188	33 ff		 xor	 edi, edi

; 1484 : 				for( int k=0 ; k<(int)( pGCMember1->vecGCSelectMember.size() ); k++ )

  0018a	33 c9		 xor	 ecx, ecx
  0018c	8d 64 24 00	 npad	 4
$L268961:
  00190	85 d2		 test	 edx, edx
  00192	75 04		 jne	 SHORT $L306594
  00194	33 c0		 xor	 eax, eax
  00196	eb 08		 jmp	 SHORT $L306595
$L306594:
  00198	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0019b	2b c2		 sub	 eax, edx
  0019d	c1 f8 02	 sar	 eax, 2
$L306595:
  001a0	3b c8		 cmp	 ecx, eax
  001a2	7d 12		 jge	 SHORT $L268963
  001a4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001a7	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1485 : 				{
; 1486 : 					__JOINPLAYER* pJoinPlayer = pGCMember1->vecGCSelectMember[k];

  001aa	8b 00		 mov	 eax, DWORD PTR [eax]

; 1487 : 					if( pJoinPlayer )

  001ac	85 c0		 test	 eax, eax
  001ae	74 03		 je	 SHORT $L268962

; 1488 : 						nLife1 += pJoinPlayer->nlife;

  001b0	03 58 04	 add	 ebx, DWORD PTR [eax+4]
$L268962:

; 1484 : 				for( int k=0 ; k<(int)( pGCMember1->vecGCSelectMember.size() ); k++ )

  001b3	41		 inc	 ecx
  001b4	eb da		 jmp	 SHORT $L268961
$L268963:

; 1489 : 				}
; 1490 : 				for( int k=0 ; k<(int)( pGCMember2->vecGCSelectMember.size() ); k++ )

  001b6	8b 74 24 24	 mov	 esi, DWORD PTR _pGCMem$306344[esp+480]
  001ba	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001bd	33 c9		 xor	 ecx, ecx
  001bf	90		 npad	 1
$L268968:
  001c0	85 d2		 test	 edx, edx
  001c2	75 04		 jne	 SHORT $L306657
  001c4	33 c0		 xor	 eax, eax
  001c6	eb 08		 jmp	 SHORT $L306658
$L306657:
  001c8	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001cb	2b c2		 sub	 eax, edx
  001cd	c1 f8 02	 sar	 eax, 2
$L306658:
  001d0	3b c8		 cmp	 ecx, eax
  001d2	7d 12		 jge	 SHORT $L268970
  001d4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001d7	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1491 : 				{
; 1492 : 					__JOINPLAYER* pJoinPlayer = pGCMember2->vecGCSelectMember[k];

  001da	8b 00		 mov	 eax, DWORD PTR [eax]

; 1493 : 					if( pJoinPlayer )

  001dc	85 c0		 test	 eax, eax
  001de	74 03		 je	 SHORT $L268969

; 1494 : 						nLife2 += pJoinPlayer->nlife;

  001e0	03 78 04	 add	 edi, DWORD PTR [eax+4]
$L268969:

; 1489 : 				}
; 1490 : 				for( int k=0 ; k<(int)( pGCMember2->vecGCSelectMember.size() ); k++ )

  001e3	41		 inc	 ecx
  001e4	eb da		 jmp	 SHORT $L268968
$L268970:

; 1495 : 				}
; 1496 : 	
; 1497 : 				if( nLife1 < nLife2 )

  001e6	3b df		 cmp	 ebx, edi

; 1498 : 				{
; 1499 : 					__REQUESTGUILD temp = vecGCRanking[j];
; 1500 : 					vecGCRanking[j] = vecGCRanking[j+1];
; 1501 : 					vecGCRanking[j+1] = temp;
; 1502 : 				}
; 1503 : 				//         
; 1504 : 				else if( nLife1 == nLife2 )

  001e8	0f 8c 43 01 00
	00		 jl	 $L308107
  001ee	0f 85 57 01 00
	00		 jne	 $L268944

; 1505 : 				{
; 1506 : 					int nLevel=0, nCount = 0;
; 1507 : 					float fAvg1=0, fAvg2=0;
; 1508 : 					for( int k=0 ; k<(int)( pGCMember1->vecGCSelectMember.size() ); k++ )

  001f4	8b 5c 24 18	 mov	 ebx, DWORD PTR _pGCMem$306077[esp+480]
  001f8	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]
  001fb	33 f6		 xor	 esi, esi
  001fd	33 ff		 xor	 edi, edi
  001ff	89 74 24 28	 mov	 DWORD PTR _nCount$268978[esp+480], esi
$L268983:
  00203	85 ed		 test	 ebp, ebp
  00205	75 04		 jne	 SHORT $L306940
  00207	33 c0		 xor	 eax, eax
  00209	eb 08		 jmp	 SHORT $L306941
$L306940:
  0020b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0020e	2b c5		 sub	 eax, ebp
  00210	c1 f8 02	 sar	 eax, 2
$L306941:
  00213	3b f0		 cmp	 esi, eax
  00215	7d 5a		 jge	 SHORT $L268985
  00217	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0021a	8d 04 b1	 lea	 eax, DWORD PTR [ecx+esi*4]

; 1509 : 					{
; 1510 : 						__JOINPLAYER* pJoinPlayer = pGCMember1->vecGCSelectMember[k];

  0021d	8b 00		 mov	 eax, DWORD PTR [eax]

; 1511 : 						if( pJoinPlayer && 0 < pJoinPlayer->nlife )

  0021f	85 c0		 test	 eax, eax
  00221	74 4b		 je	 SHORT $L268984
  00223	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00226	85 c9		 test	 ecx, ecx
  00228	7e 44		 jle	 SHORT $L268984

; 1512 : 						{
; 1513 : 							CUser* pUsertmp = (CUser*)prj.GetUserByID( pJoinPlayer->uidPlayer );

  0022a	8b 10		 mov	 edx, DWORD PTR [eax]
  0022c	8d 44 24 18	 lea	 eax, DWORD PTR $T307071[esp+480]
  00230	50		 push	 eax
  00231	8d 4c 24 50	 lea	 ecx, DWORD PTR _i$307049[esp+484]
  00235	51		 push	 ecx
  00236	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  0023b	89 54 24 20	 mov	 DWORD PTR $T307071[esp+488], edx
  0023f	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  00244	8b 44 24 4c	 mov	 eax, DWORD PTR _i$307049[esp+480]
  00248	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  0024e	74 1e		 je	 SHORT $L268984
  00250	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1514 : 							if( IsValidObj( pUsertmp ) )

  00253	85 c0		 test	 eax, eax
  00255	74 17		 je	 SHORT $L268984
  00257	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0025b	75 11		 jne	 SHORT $L268984

; 1515 : 							{
; 1516 : 								nLevel += pUsertmp->GetLevel();

  0025d	8b 88 e0 05 00
	00		 mov	 ecx, DWORD PTR [eax+1504]

; 1517 : 								nCount++;

  00263	8b 44 24 28	 mov	 eax, DWORD PTR _nCount$268978[esp+480]
  00267	03 f9		 add	 edi, ecx
  00269	40		 inc	 eax
  0026a	89 44 24 28	 mov	 DWORD PTR _nCount$268978[esp+480], eax
$L268984:

; 1505 : 				{
; 1506 : 					int nLevel=0, nCount = 0;
; 1507 : 					float fAvg1=0, fAvg2=0;
; 1508 : 					for( int k=0 ; k<(int)( pGCMember1->vecGCSelectMember.size() ); k++ )

  0026e	46		 inc	 esi
  0026f	eb 92		 jmp	 SHORT $L268983
$L268985:

; 1518 : 							}
; 1519 : 						}
; 1520 : 					}
; 1521 : 					if( nCount )

  00271	8b 4c 24 28	 mov	 ecx, DWORD PTR _nCount$268978[esp+480]
  00275	85 c9		 test	 ecx, ecx
  00277	74 13		 je	 SHORT $L268991

; 1522 : 						fAvg1 = (float)( nLevel/nCount );

  00279	8b c7		 mov	 eax, edi
  0027b	99		 cdq
  0027c	f7 f9		 idiv	 ecx
  0027e	89 44 24 20	 mov	 DWORD PTR tv2044[esp+480], eax
  00282	db 44 24 20	 fild	 DWORD PTR tv2044[esp+480]
  00286	d9 5c 24 20	 fstp	 DWORD PTR _fAvg1$268979[esp+480]

; 1523 : 					else

  0028a	eb 08		 jmp	 SHORT $L268993
$L268991:

; 1524 : 						fAvg1 = 1.0f;

  0028c	c7 44 24 20 00
	00 80 3f	 mov	 DWORD PTR _fAvg1$268979[esp+480], 1065353216 ; 3f800000H
$L268993:

; 1525 : 					nLevel = nCount = 0;
; 1526 : 					for( int k=0 ; k<(int)( pGCMember2->vecGCSelectMember.size() ); k++ )

  00294	8b 4c 24 24	 mov	 ecx, DWORD PTR _pGCMem$306344[esp+480]
  00298	8b 69 08	 mov	 ebp, DWORD PTR [ecx+8]
  0029b	33 db		 xor	 ebx, ebx
  0029d	33 ff		 xor	 edi, edi
  0029f	33 f6		 xor	 esi, esi
$L268996:
  002a1	85 ed		 test	 ebp, ebp
  002a3	75 04		 jne	 SHORT $L307093
  002a5	33 c0		 xor	 eax, eax
  002a7	eb 08		 jmp	 SHORT $L307094
$L307093:
  002a9	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  002ac	2b c5		 sub	 eax, ebp
  002ae	c1 f8 02	 sar	 eax, 2
$L307094:
  002b1	3b f0		 cmp	 esi, eax
  002b3	7d 54		 jge	 SHORT $L268998
  002b5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b8	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]

; 1527 : 					{
; 1528 : 						__JOINPLAYER* pJoinPlayer = pGCMember2->vecGCSelectMember[k];

  002bb	8b 00		 mov	 eax, DWORD PTR [eax]

; 1529 : 						if( pJoinPlayer && 0 < pJoinPlayer->nlife )

  002bd	85 c0		 test	 eax, eax
  002bf	74 41		 je	 SHORT $L268997
  002c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002c4	85 c9		 test	 ecx, ecx
  002c6	7e 3a		 jle	 SHORT $L268997

; 1530 : 						{
; 1531 : 							CUser* pUsertmp = (CUser*)prj.GetUserByID( pJoinPlayer->uidPlayer );

  002c8	8b 00		 mov	 eax, DWORD PTR [eax]
  002ca	8d 4c 24 28	 lea	 ecx, DWORD PTR $T307224[esp+480]
  002ce	51		 push	 ecx
  002cf	8d 54 24 34	 lea	 edx, DWORD PTR _i$307203[esp+484]
  002d3	52		 push	 edx
  002d4	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  002d9	89 44 24 30	 mov	 DWORD PTR $T307224[esp+488], eax
  002dd	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  002e2	8b 44 24 30	 mov	 eax, DWORD PTR _i$307203[esp+480]
  002e6	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  002ec	74 14		 je	 SHORT $L268997
  002ee	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1532 : 							if( IsValidObj( pUsertmp ) )

  002f1	85 c0		 test	 eax, eax
  002f3	74 0d		 je	 SHORT $L268997
  002f5	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  002f9	75 07		 jne	 SHORT $L268997

; 1533 : 							{
; 1534 : 								nLevel += pUsertmp->GetLevel();

  002fb	03 b8 e0 05 00
	00		 add	 edi, DWORD PTR [eax+1504]

; 1535 : 								nCount++;

  00301	43		 inc	 ebx
$L268997:
  00302	8b 4c 24 24	 mov	 ecx, DWORD PTR _pGCMem$306344[esp+480]
  00306	46		 inc	 esi
  00307	eb 98		 jmp	 SHORT $L268996
$L268998:

; 1536 : 							}
; 1537 : 						}
; 1538 : 					}
; 1539 : 					if( nCount )

  00309	85 db		 test	 ebx, ebx
  0030b	74 0f		 je	 SHORT $L269004

; 1540 : 						fAvg2 = (float)( nLevel/nCount );

  0030d	8b c7		 mov	 eax, edi
  0030f	99		 cdq
  00310	f7 fb		 idiv	 ebx
  00312	89 44 24 28	 mov	 DWORD PTR tv2035[esp+480], eax
  00316	db 44 24 28	 fild	 DWORD PTR tv2035[esp+480]

; 1541 : 					else

  0031a	eb 06		 jmp	 SHORT $L269006
$L269004:

; 1542 : 						fAvg2 = 1.0f;

  0031c	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
$L269006:

; 1543 : 
; 1544 : 					if( fAvg1 < fAvg2 )

  00322	d9 44 24 20	 fld	 DWORD PTR _fAvg1$268979[esp+480]
  00326	d8 d9		 fcomp	 ST(1)
  00328	df e0		 fnstsw	 ax
  0032a	dd d8		 fstp	 ST(0)
  0032c	f6 c4 05	 test	 ah, 5
  0032f	7a 1a		 jp	 SHORT $L268944
$L308107:

; 1545 : 					{
; 1546 : 						__REQUESTGUILD temp = vecGCRanking[j];

  00331	8b 54 24 1c	 mov	 edx, DWORD PTR tv2048[esp+480]

; 1547 : 						vecGCRanking[j] = vecGCRanking[j+1];

  00335	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00338	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0033b	8b 02		 mov	 eax, DWORD PTR [edx]
  0033d	89 32		 mov	 DWORD PTR [edx], esi
  0033f	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  00342	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 1548 : 						vecGCRanking[j+1] = temp;

  00345	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00348	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$L268944:
  0034b	8b 4c 24 10	 mov	 ecx, DWORD PTR _j$268941[esp+480]
  0034f	8b 44 24 1c	 mov	 eax, DWORD PTR tv2048[esp+480]
  00353	8b 5c 24 44	 mov	 ebx, DWORD PTR $T308062[esp+480]
  00357	8b 54 24 3c	 mov	 edx, DWORD PTR _vecGCRanking$[esp+488]
  0035b	8b 6c 24 38	 mov	 ebp, DWORD PTR _vecGCRanking$[esp+484]
  0035f	41		 inc	 ecx
  00360	83 c0 08	 add	 eax, 8
  00363	89 4c 24 10	 mov	 DWORD PTR _j$268941[esp+480], ecx
  00367	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$268935[esp+480]
  0036b	89 44 24 1c	 mov	 DWORD PTR tv2048[esp+480], eax
  0036f	8b f8		 mov	 edi, eax
  00371	e9 20 fd ff ff	 jmp	 $L268943
$L268938:

; 1453 : 	vecGCRanking = vecRequestRanking;
; 1454 : 	
; 1455 : 	for( int i=0; i<(int)( vecGCRanking.size()-1 ); i++ )

  00376	41		 inc	 ecx
  00377	e9 e6 fc ff ff	 jmp	 $L308108
$L308078:

; 1468 : 			{
; 1469 : 				Error( "GuildCombatResultRanking() - pGCMember1 or pGCMember2 is NULL" );

  0037c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@MCMLJPCC@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@
  00381	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 1470 : 				return;

  00386	8b 44 24 3c	 mov	 eax, DWORD PTR _vecGCRanking$[esp+488]
  0038a	83 c4 04	 add	 esp, 4
  0038d	85 c0		 test	 eax, eax
  0038f	0f 84 6d 03 00
	00		 je	 $L308060
  00395	50		 push	 eax
  00396	e9 5f 03 00 00	 jmp	 $L308109
$L268939:

; 1549 : 					}
; 1550 : 				} //if 
; 1551 : 			} //if 
; 1552 : 		} //for j
; 1553 : 	} //for i
; 1554 : 
; 1555 : 	// () 
; 1556 : 	for( int i=0; i<(int)( vecGCRanking.size() ); i++ )

  0039b	85 ed		 test	 ebp, ebp
  0039d	89 7c 24 10	 mov	 DWORD PTR _i$269009[esp+480], edi
  003a1	75 04		 jne	 SHORT $L307466
  003a3	33 c0		 xor	 eax, eax
  003a5	eb 07		 jmp	 SHORT $L307467
$L307466:
  003a7	8b c2		 mov	 eax, edx
  003a9	2b c5		 sub	 eax, ebp
  003ab	c1 f8 03	 sar	 eax, 3
$L307467:
  003ae	3b f8		 cmp	 edi, eax
  003b0	0f 8d 3f 03 00
	00		 jge	 $L308081

; 1557 : 	{
; 1558 : 		if( i >= 3 ) break;

  003b6	83 ff 03	 cmp	 edi, 3
  003b9	0f 8d 36 03 00
	00		 jge	 $L308081

; 1559 : 
; 1560 : 		__REQUESTGUILD RequestGuild = vecGCRanking[i];

  003bf	8b 44 fd 04	 mov	 eax, DWORD PTR [ebp+edi*8+4]
  003c3	8b 74 fd 00	 mov	 esi, DWORD PTR [ebp+edi*8]
  003c7	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  003ca	89 44 24 48	 mov	 DWORD PTR _RequestGuild$269015[esp+484], eax

; 1561 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  003ce	33 c9		 xor	 ecx, ecx
$L307645:
  003d0	85 d2		 test	 edx, edx
  003d2	75 04		 jne	 SHORT $L307651
  003d4	33 c0		 xor	 eax, eax
  003d6	eb 08		 jmp	 SHORT $L307652
$L307651:
  003d8	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  003db	2b c2		 sub	 eax, edx
  003dd	c1 f8 02	 sar	 eax, 2
$L307652:
  003e0	3b c8		 cmp	 ecx, eax
  003e2	7d 1b		 jge	 SHORT $L308085
  003e4	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  003e7	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  003ea	3b 30		 cmp	 esi, DWORD PTR [eax]
  003ec	74 03		 je	 SHORT $L308080
  003ee	41		 inc	 ecx
  003ef	eb df		 jmp	 SHORT $L307645
$L308080:
  003f1	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  003f4	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1562 : 		if( !pGCMember )

  003f7	85 c0		 test	 eax, eax
  003f9	89 44 24 14	 mov	 DWORD PTR _pGCMem$307643[esp+480], eax
  003fd	75 14		 jne	 SHORT $L269017
$L308085:

; 1563 : 		{
; 1564 : 			Error( "GuildCombatResultRanking() - pGCMember is NULL" );

  003ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@COFMEPEI@GuildCombatResultRanking?$CI?$CJ?5?9?5pGC@
  00404	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00409	8b 54 24 40	 mov	 edx, DWORD PTR _vecGCRanking$[esp+492]
  0040d	83 c4 04	 add	 esp, 4
  00410	47		 inc	 edi
  00411	eb 88		 jmp	 SHORT $L268939
$L269017:

; 1565 : 			continue;
; 1566 : 		}
; 1567 : 
; 1568 : 		CItemElem itemElem;

  00413	8d 4c 24 50	 lea	 ecx, DWORD PTR _itemElem$269019[esp+480]
  00417	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 1569 : 		itemElem.m_dwItemId = II_CHP_RED;
; 1570 : 		float fChipNum = m_nJoinPanya * vecGCRanking.size() * 0.9f * 0.00001f * 0.1f;

  0041c	85 ed		 test	 ebp, ebp
  0041e	c6 84 24 dc 01
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+488], 1
  00426	c7 44 24 5c 5c
	67 00 00	 mov	 DWORD PTR _itemElem$269019[esp+492], 26460 ; 0000675cH
  0042e	75 04		 jne	 SHORT $L307697
  00430	33 c0		 xor	 eax, eax
  00432	eb 09		 jmp	 SHORT $L307698
$L307697:
  00434	8b 44 24 3c	 mov	 eax, DWORD PTR _vecGCRanking$[esp+488]
  00438	2b c5		 sub	 eax, ebp
  0043a	c1 f8 03	 sar	 eax, 3
$L307698:
  0043d	8b 8b 90 10 00
	00		 mov	 ecx, DWORD PTR [ebx+4240]
  00443	0f af c8	 imul	 ecx, eax
  00446	85 c9		 test	 ecx, ecx
  00448	89 4c 24 44	 mov	 DWORD PTR tv2017[esp+480], ecx
  0044c	db 44 24 44	 fild	 DWORD PTR tv2017[esp+480]
  00450	7d 06		 jge	 SHORT $L308102
  00452	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L308102:
  00458	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@35719787

; 1571 : 		switch( i )

  0045e	8b c7		 mov	 eax, edi
  00460	83 e8 00	 sub	 eax, 0
  00463	74 16		 je	 SHORT $L269025
  00465	48		 dec	 eax
  00466	74 0b		 je	 SHORT $L269026
  00468	48		 dec	 eax
  00469	75 16		 jne	 SHORT $L269022

; 1579 : 			case 2 :	// 3
; 1580 : 				fChipNum *= 0.1f;

  0046b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3dcccccd

; 1581 : 				break;

  00471	eb 0e		 jmp	 SHORT $L269022
$L269026:

; 1575 : 				break;
; 1576 : 			case 1 :	// 2
; 1577 : 				fChipNum *= 0.2f;

  00473	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e4ccccd

; 1578 : 				break;

  00479	eb 06		 jmp	 SHORT $L269022
$L269025:

; 1572 : 		{
; 1573 : 			case 0 :	// 1 
; 1574 : 				fChipNum *= 0.7f;

  0047b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f333333
$L269022:

; 1582 : 		}
; 1583 : 		itemElem.m_nItemNum = (int)fChipNum;

  00481	e8 00 00 00 00	 call	 __ftol2

; 1584 : 		if( itemElem.m_nItemNum < 1 )

  00486	66 3d 01 00	 cmp	 ax, 1
  0048a	66 89 84 24 d0
	00 00 00	 mov	 WORD PTR _itemElem$269019[esp+608], ax
  00492	7d 0a		 jge	 SHORT $L269029

; 1585 : 			itemElem.m_nItemNum		= 1;

  00494	66 c7 84 24 d0
	00 00 00 01 00	 mov	 WORD PTR _itemElem$269019[esp+608], 1
$L269029:

; 1586 : 		itemElem.m_bCharged = itemElem.GetProp()->bCharged;

  0049e	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  004a3	3d 5c 67 00 00	 cmp	 eax, 26460		; 0000675cH
  004a8	7e 10		 jle	 SHORT $L307749
  004aa	76 28		 jbe	 SHORT $L308110
  004ac	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  004b2	8b 82 70 9d 01
	00		 mov	 eax, DWORD PTR [edx+105840]
  004b8	eb 1c		 jmp	 SHORT $L307744
$L307749:
  004ba	68 5c 67 00 00	 push	 26460			; 0000675cH
  004bf	50		 push	 eax
  004c0	6a 00		 push	 0
  004c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  004c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  004cc	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  004d1	83 c4 14	 add	 esp, 20			; 00000014H
$L308110:
  004d4	33 c0		 xor	 eax, eax
$L307744:
  004d6	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]

; 1587 : 
; 1588 : 		LogItemInfo aLogItem;

  004dc	8d 8c 24 08 01
	00 00		 lea	 ecx, DWORD PTR _aLogItem$269030[esp+480]
  004e3	89 84 24 fc 00
	00 00		 mov	 DWORD PTR _itemElem$269019[esp+652], eax
  004ea	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 1589 : 		aLogItem.Action = "W";
; 1590 : 		aLogItem.Gold_1 = i;

  004ef	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$269009[esp+480]

; 1591 : 					
; 1592 : 		for( int j=0 ; j<(int)( pGCMember->vecGCSelectMember.size() ); j++ )

  004f3	8b 7c 24 14	 mov	 edi, DWORD PTR _pGCMem$307643[esp+480]
  004f7	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$269030[esp+480], OFFSET FLAT:??_C@_01ELNMCGJD@W?$AA@
  00502	89 8c 24 54 01
	00 00		 mov	 DWORD PTR _aLogItem$269030[esp+556], ecx
  00509	33 ed		 xor	 ebp, ebp
  0050b	eb 03 8d 49 00	 npad	 5
$L269033:
  00510	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00513	85 c9		 test	 ecx, ecx
  00515	75 04		 jne	 SHORT $L307769
  00517	33 c0		 xor	 eax, eax
  00519	eb 08		 jmp	 SHORT $L307770
$L307769:
  0051b	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0051e	2b c1		 sub	 eax, ecx
  00520	c1 f8 02	 sar	 eax, 2
$L307770:
  00523	3b e8		 cmp	 ebp, eax
  00525	0f 8d a7 01 00
	00		 jge	 $L269035
  0052b	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0052e	8d 04 aa	 lea	 eax, DWORD PTR [edx+ebp*4]

; 1593 : 		{
; 1594 : 			__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[j];

  00531	8b 00		 mov	 eax, DWORD PTR [eax]

; 1595 : 			if( !pJoinPlayer )

  00533	85 c0		 test	 eax, eax
  00535	75 10		 jne	 SHORT $L269037

; 1596 : 			{
; 1597 : 				Error( "GuildCombatResultRanking() - pJoinPlayer is NULL" );

  00537	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@KEJMOH@GuildCombatResultRanking?$CI?$CJ?5?9?5pJo@
  0053c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00541	83 c4 04	 add	 esp, 4
  00544	45		 inc	 ebp
  00545	eb c9		 jmp	 SHORT $L269033
$L269037:

; 1598 : 				continue;
; 1599 : 			}
; 1600 : 
; 1601 : 			CUser* pUsertmp = (CUser*)prj.GetUserByID( pJoinPlayer->uidPlayer );

  00547	8b 00		 mov	 eax, DWORD PTR [eax]
  00549	8d 4c 24 44	 lea	 ecx, DWORD PTR $T307900[esp+480]
  0054d	51		 push	 ecx
  0054e	8d 54 24 34	 lea	 edx, DWORD PTR _i$307878[esp+484]
  00552	52		 push	 edx
  00553	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00558	89 44 24 4c	 mov	 DWORD PTR $T307900[esp+488], eax
  0055c	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  00561	8b 44 24 30	 mov	 eax, DWORD PTR _i$307878[esp+480]
  00565	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  0056b	0f 84 5b 01 00
	00		 je	 $L269034
  00571	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 1602 : 			if( IsValidObj( pUsertmp ) )

  00574	85 f6		 test	 esi, esi
  00576	0f 84 50 01 00
	00		 je	 $L269034
  0057c	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00580	0f 85 46 01 00
	00		 jne	 $L269034

; 1603 : 			{
; 1604 : 				aLogItem.SendName = pUsertmp->GetName();

  00586	6a 00		 push	 0
  00588	8b ce		 mov	 ecx, esi
  0058a	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 1605 : 				//  
; 1606 : 				itemElem.SetSerialNumber();

  0058f	8d 4c 24 50	 lea	 ecx, DWORD PTR _itemElem$269019[esp+480]
  00593	89 84 24 0c 01
	00 00		 mov	 DWORD PTR _aLogItem$269030[esp+484], eax
  0059a	e8 00 00 00 00	 call	 ?SetSerialNumber@CItemBase@@QAEXXZ ; CItemBase::SetSerialNumber

; 1607 : 				if( pUsertmp->CreateItem( &itemElem ) )

  0059f	6a 00		 push	 0
  005a1	6a 00		 push	 0
  005a3	6a 00		 push	 0
  005a5	8d 44 24 5c	 lea	 eax, DWORD PTR _itemElem$269019[esp+492]
  005a9	50		 push	 eax
  005aa	8b ce		 mov	 ecx, esi
  005ac	e8 00 00 00 00	 call	 ?CreateItem@CMover@@QAEHPAVCItemBase@@PAEPAFE@Z ; CMover::CreateItem
  005b1	85 c0		 test	 eax, eax
  005b3	74 2c		 je	 SHORT $L269042

; 1608 : 				{
; 1609 : 					aLogItem.RecvName = "GUILDCOMBAT_CHIP";
; 1610 : 					pUsertmp->AddDefinedText( TID_GAME_GUILDCOMBAT1TO1_WARGUILDWINCHIP, "%d", itemElem.m_nItemNum );

  005b5	0f bf 8c 24 d0
	00 00 00	 movsx	 ecx, WORD PTR _itemElem$269019[esp+608]
  005bd	51		 push	 ecx
  005be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  005c3	68 67 0d 00 00	 push	 3431			; 00000d67H
  005c8	56		 push	 esi
  005c9	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$269030[esp+504], OFFSET FLAT:??_C@_0BB@IBCONAGB@GUILDCOMBAT_CHIP?$AA@
  005d4	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  005d9	83 c4 10	 add	 esp, 16			; 00000010H

; 1611 : 				}
; 1612 : 				else

  005dc	e9 a7 00 00 00	 jmp	 $L269044
$L269042:

; 1613 : 				{
; 1614 : 					g_dpDBClient.SendQueryPostMail( pUsertmp->m_idPlayer, 0, itemElem, 0, itemElem.GetProp()->szName, itemElem.GetProp()->szName );

  005e1	8b 44 24 5c	 mov	 eax, DWORD PTR _itemElem$269019[esp+492]
  005e5	85 c0		 test	 eax, eax
  005e7	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  005ed	7c 19		 jl	 SHORT $L307963
  005ef	3b c1		 cmp	 eax, ecx
  005f1	7d 15		 jge	 SHORT $L307963
  005f3	72 06		 jb	 SHORT $L307975
  005f5	33 d2		 xor	 edx, edx
  005f7	8b fa		 mov	 edi, edx
  005f9	eb 2f		 jmp	 SHORT $L307958
$L307975:
  005fb	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  00601	8b 14 82	 mov	 edx, DWORD PTR [edx+eax*4]
  00604	8b fa		 mov	 edi, edx
  00606	eb 22		 jmp	 SHORT $L307958
$L307963:
  00608	50		 push	 eax
  00609	51		 push	 ecx
  0060a	6a 00		 push	 0
  0060c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00611	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00616	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0061b	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00621	8b 44 24 70	 mov	 eax, DWORD PTR _itemElem$269019[esp+512]
  00625	83 c4 14	 add	 esp, 20			; 00000014H
  00628	33 ff		 xor	 edi, edi
$L307958:
  0062a	85 c0		 test	 eax, eax
  0062c	7c 11		 jl	 SHORT $L308029
  0062e	3b c1		 cmp	 eax, ecx
  00630	7d 0d		 jge	 SHORT $L308029
  00632	73 21		 jae	 SHORT $L308111
  00634	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0063a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0063d	eb 18		 jmp	 SHORT $L308024
$L308029:
  0063f	50		 push	 eax
  00640	51		 push	 ecx
  00641	6a 00		 push	 0
  00643	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00648	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0064d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00652	83 c4 14	 add	 esp, 20			; 00000014H
$L308111:
  00655	33 c0		 xor	 eax, eax
$L308024:
  00657	83 c7 04	 add	 edi, 4
  0065a	57		 push	 edi
  0065b	83 c0 04	 add	 eax, 4
  0065e	50		 push	 eax
  0065f	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  00665	6a 00		 push	 0
  00667	8d 54 24 5c	 lea	 edx, DWORD PTR _itemElem$269019[esp+492]
  0066b	52		 push	 edx
  0066c	6a 00		 push	 0
  0066e	50		 push	 eax
  0066f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00674	e8 00 00 00 00	 call	 ?SendQueryPostMail@CDPDatabaseClient@@QAEXKKAAVCItemElem@@HPAD1@Z ; CDPDatabaseClient::SendQueryPostMail

; 1615 : 					//pUsertmp->AddDefinedText( TID_GAME_MINIGAME_ITEM_POST, "" );
; 1616 : 					aLogItem.RecvName = "GUILDCOMBAT_CHIP_POST";

  00679	8b 7c 24 14	 mov	 edi, DWORD PTR _pGCMem$307643[esp+480]
  0067d	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$269030[esp+488], OFFSET FLAT:??_C@_0BG@CENMBALP@GUILDCOMBAT_CHIP_POST?$AA@
$L269044:

; 1617 : 				}
; 1618 : 				int cbChip	= pUsertmp->GetItemNum( II_CHP_RED );

  00688	68 5c 67 00 00	 push	 26460			; 0000675cH
  0068d	8b ce		 mov	 ecx, esi
  0068f	e8 00 00 00 00	 call	 ?GetItemNum@CMover@@QAEHK@Z ; CMover::GetItemNum

; 1619 : 				aLogItem.Gold	= cbChip;
; 1620 : 				aLogItem.Gold2	= cbChip + itemElem.m_nItemNum;

  00694	0f bf 8c 24 d0
	00 00 00	 movsx	 ecx, WORD PTR _itemElem$269019[esp+608]
  0069c	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]

; 1621 : 				aLogItem.Gold_1 = itemElem.m_nItemNum;
; 1622 : 				g_DPSrvr.OnLogItem( aLogItem, &itemElem, itemElem.m_nItemNum );

  0069f	51		 push	 ecx
  006a0	89 84 24 1c 01
	00 00		 mov	 DWORD PTR _aLogItem$269030[esp+500], eax
  006a7	89 8c 24 58 01
	00 00		 mov	 DWORD PTR _aLogItem$269030[esp+560], ecx
  006ae	8d 44 24 54	 lea	 eax, DWORD PTR _itemElem$269019[esp+484]
  006b2	50		 push	 eax
  006b3	8d 8c 24 10 01
	00 00		 lea	 ecx, DWORD PTR _aLogItem$269030[esp+488]
  006ba	51		 push	 ecx
  006bb	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  006c0	89 94 24 28 01
	00 00		 mov	 DWORD PTR _aLogItem$269030[esp+512], edx
  006c7	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem
$L269034:

; 1591 : 					
; 1592 : 		for( int j=0 ; j<(int)( pGCMember->vecGCSelectMember.size() ); j++ )

  006cc	45		 inc	 ebp
  006cd	e9 3e fe ff ff	 jmp	 $L269033
$L269035:

; 1623 : 				TRACE( "GC REDCHIP - %s, %d, %s : %d\n", pUsertmp->GetName(), i+1, itemElem.GetProp()->szName, itemElem.m_nItemNum );
; 1624 : 			}
; 1625 : 		}
; 1626 : 	}

  006d2	8d 4c 24 50	 lea	 ecx, DWORD PTR _itemElem$269019[esp+480]
  006d6	c6 84 24 dc 01
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+488], 0
  006de	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  006e3	8b 7c 24 10	 mov	 edi, DWORD PTR _i$269009[esp+480]
  006e7	8b 6c 24 38	 mov	 ebp, DWORD PTR _vecGCRanking$[esp+484]
  006eb	8b 54 24 3c	 mov	 edx, DWORD PTR _vecGCRanking$[esp+488]
  006ef	47		 inc	 edi
  006f0	e9 a6 fc ff ff	 jmp	 $L268939
$L308081:

; 1627 : }

  006f5	85 ed		 test	 ebp, ebp
  006f7	74 09		 je	 SHORT $L308060
  006f9	55		 push	 ebp
$L308109:
  006fa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006ff	83 c4 04	 add	 esp, 4
$L308060:
  00702	8b 8c 24 d4 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+480]
  00709	5f		 pop	 edi
  0070a	5e		 pop	 esi
  0070b	5d		 pop	 ebp
  0070c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00713	8b 8c 24 c4 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+468]
  0071a	5b		 pop	 ebx
  0071b	33 cc		 xor	 ecx, esp
  0071d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00722	81 c4 d0 01 00
	00		 add	 esp, 464		; 000001d0H
  00728	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L305801:
  00000	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _vecGCRanking$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
$L305802:
  0000b	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _itemElem$269019[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
__ehhandler$?GuildCombatResultRanking@CGuildCombat@@QAEXXZ:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T308064
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GuildCombatResultRanking@CGuildCombat@@QAEXXZ ENDP	; CGuildCombat::GuildCombatResultRanking
PUBLIC	?SetPlayerChange@CGuildCombat@@QAEXPAVCUser@@0@Z ; CGuildCombat::SetPlayerChange
EXTRN	?AddGCJoinWarWindow@CUser@@QAEXHH@Z:NEAR	; CUser::AddGCJoinWarWindow
; Function compile flags: /Ogty
;	COMDAT ?SetPlayerChange@CGuildCombat@@QAEXPAVCUser@@0@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$308463 = -8						; size = 4
_pJoinPlayer$270041 = -4				; size = 4
__Newnode$308849 = 8					; size = 4
$T308465 = 8						; size = 4
__Newnode$308329 = 8					; size = 4
_pJoinPlayer$270026 = 8					; size = 4
_pUser$ = 8						; size = 4
_pLeader$ = 12						; size = 4
?SetPlayerChange@CGuildCombat@@QAEXPAVCUser@@0@Z PROC NEAR ; CGuildCombat::SetPlayerChange, COMDAT
; _this$ = ecx

; 3290 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 3291 : #ifdef __S_BUG_GC
; 3292 : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( pUser->m_idGuild );

  00005	8b 6c 24 18	 mov	 ebp, DWORD PTR _pUser$[esp+16]
  00009	8b 85 1c 07 00
	00		 mov	 eax, DWORD PTR [ebp+1820]
  0000f	56		 push	 esi
  00010	8b d9		 mov	 ebx, ecx
  00012	50		 push	 eax
  00013	89 5c 24 10	 mov	 DWORD PTR _this$[esp+28], ebx
  00017	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  0001c	8b f0		 mov	 esi, eax

; 3293 : 	if( pGCMember != NULL )

  0001e	85 f6		 test	 esi, esi
  00020	0f 84 f4 01 00
	00		 je	 $L308867
  00026	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 3294 : 	{
; 3295 : 		for( int i = 0; i < (int)( pGCMember->vecGCSelectMember.size() ) ; ++i )

  00029	33 c9		 xor	 ecx, ecx
  0002b	57		 push	 edi
  0002c	8d 64 24 00	 npad	 4
$L270023:
  00030	85 d2		 test	 edx, edx
  00032	75 04		 jne	 SHORT $L308124
  00034	33 c0		 xor	 eax, eax
  00036	eb 08		 jmp	 SHORT $L308125
$L308124:
  00038	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003b	2b c2		 sub	 eax, edx
  0003d	c1 f8 02	 sar	 eax, 2
$L308125:
  00040	3b c8		 cmp	 ecx, eax
  00042	0f 8d d1 01 00
	00		 jge	 $L308870
  00048	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 3296 : 		{
; 3297 : 			__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[i];

  0004b	8b 3c 88	 mov	 edi, DWORD PTR [eax+ecx*4]
  0004e	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 3298 : 			if( pJoinPlayer->uidPlayer == pUser->m_idPlayer )

  00051	8b 07		 mov	 eax, DWORD PTR [edi]
  00053	3b 85 38 02 00
	00		 cmp	 eax, DWORD PTR [ebp+568]
  00059	89 7c 24 20	 mov	 DWORD PTR _pJoinPlayer$270026[esp+24], edi
  0005d	74 03		 je	 SHORT $L308865

; 3294 : 	{
; 3295 : 		for( int i = 0; i < (int)( pGCMember->vecGCSelectMember.size() ) ; ++i )

  0005f	41		 inc	 ecx
  00060	eb ce		 jmp	 SHORT $L270023
$L308865:

; 3299 : 			{
; 3300 : 				//     pUser   
; 3301 : 				for( list<__JOINPLAYER*>::iterator i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )

  00062	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00065	8b 01		 mov	 eax, DWORD PTR [ecx]
  00067	3b c1		 cmp	 eax, ecx
  00069	74 15		 je	 SHORT $L270034
  0006b	eb 03 8d 49 00	 npad	 5
$L308213:

; 3302 : 				{
; 3303 : 					if( pJoinPlayer == *i1 )

  00070	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  00073	0f 84 a0 01 00
	00		 je	 $L308870
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0007e	75 f0		 jne	 SHORT $L308213
$L270034:

; 3304 : 						return;
; 3305 : 				}
; 3306 : //				pJoinPlayer->bEntry	= FALSE;
; 3307 : 				pJoinPlayer->dwTelTime	= 0;

  00080	33 c0		 xor	 eax, eax
  00082	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 3308 : 				pUser->m_nGuildCombatState	= 0;
; 3309 : 				g_UserMng.AddGuildCombatUserState( pUser );

  00085	55		 push	 ebp
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0008b	89 85 98 0e 00
	00		 mov	 DWORD PTR [ebp+3736], eax
  00091	e8 00 00 00 00	 call	 ?AddGuildCombatUserState@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddGuildCombatUserState

; 3310 : 				--pGCMember->nWarCount;

  00096	ff 4e 24	 dec	 DWORD PTR [esi+36]

; 3311 : 				pJoinPlayer->nlife--;

  00099	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0009c	4a		 dec	 edx
  0009d	8b c2		 mov	 eax, edx

; 3312 : 				if( pJoinPlayer->nlife > 0 )

  0009f	85 c0		 test	 eax, eax
  000a1	89 57 04	 mov	 DWORD PTR [edi+4], edx
  000a4	7e 34		 jle	 SHORT $L308327

; 3313 : 					pGCMember->lspFifo.push_back( pJoinPlayer );

  000a6	8b 5e 30	 mov	 ebx, DWORD PTR [esi+48]
  000a9	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000ac	8d 6e 2c	 lea	 ebp, DWORD PTR [esi+44]
  000af	8d 4c 24 20	 lea	 ecx, DWORD PTR _pJoinPlayer$270026[esp+24]
  000b3	51		 push	 ecx
  000b4	52		 push	 edx
  000b5	53		 push	 ebx
  000b6	8b cd		 mov	 ecx, ebp
  000b8	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  000bd	6a 01		 push	 1
  000bf	8b cd		 mov	 ecx, ebp
  000c1	89 44 24 24	 mov	 DWORD PTR __Newnode$308329[esp+28], eax
  000c5	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  000ca	8b 44 24 20	 mov	 eax, DWORD PTR __Newnode$308329[esp+24]
  000ce	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d4	8b 5c 24 10	 mov	 ebx, DWORD PTR _this$[esp+28]
  000d8	89 01		 mov	 DWORD PTR [ecx], eax
$L308327:

; 3314 : 				if( pJoinPlayer->nlife < 0 )

  000da	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000dd	85 c0		 test	 eax, eax
  000df	7d 07		 jge	 SHORT $L308864

; 3315 : 					pJoinPlayer->nlife	= 0;

  000e1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$L308864:

; 3316 : 
; 3317 : 				while( pGCMember->lspFifo.size() > 0 )

  000e8	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000eb	85 c0		 test	 eax, eax
  000ed	0f 86 26 01 00
	00		 jbe	 $L308870
$L270039:

; 3318 : 				{
; 3319 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->lspFifo.front();

  000f3	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  000f6	8b 02		 mov	 eax, DWORD PTR [edx]
  000f8	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 3320 : 					CMover* pMover	= prj.GetUserByID( pJoinPlayer->uidPlayer );

  000fb	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000fd	8d 54 24 20	 lea	 edx, DWORD PTR $T308465[esp+24]
  00101	52		 push	 edx
  00102	8d 44 24 18	 lea	 eax, DWORD PTR _i$308463[esp+32]
  00106	89 4c 24 24	 mov	 DWORD PTR $T308465[esp+28], ecx
  0010a	50		 push	 eax
  0010b	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00110	89 7c 24 20	 mov	 DWORD PTR _pJoinPlayer$270041[esp+36], edi
  00114	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  00119	8b 44 24 14	 mov	 eax, DWORD PTR _i$308463[esp+28]
  0011d	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  00123	74 67		 je	 SHORT $L270043
  00125	8b 68 10	 mov	 ebp, DWORD PTR [eax+16]

; 3321 : 					if( IsValidObj( pMover ) && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  00128	85 ed		 test	 ebp, ebp
  0012a	74 60		 je	 SHORT $L270043
  0012c	f6 45 04 01	 test	 BYTE PTR [ebp+4], 1
  00130	75 5a		 jne	 SHORT $L270043
  00132	8b 8d 6c 01 00
	00		 mov	 ecx, DWORD PTR [ebp+364]
  00138	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  0013e	75 4c		 jne	 SHORT $L270043

; 3322 : 					{
; 3323 : 						pGCMember->nWarCount++;

  00140	ff 46 24	 inc	 DWORD PTR [esi+36]

; 3324 : //						pJoinPlayer->bEntry	= TRUE;
; 3325 : 						pJoinPlayer->dwTelTime	= timeGetTime();

  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00149	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 3326 : 						((CUser*)pMover)->AddGCJoinWarWindow( pJoinPlayer->nMap, m_nMaxMapTime );

  0014c	8b 93 b0 10 00
	00		 mov	 edx, DWORD PTR [ebx+4272]
  00152	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00155	52		 push	 edx
  00156	50		 push	 eax
  00157	8b cd		 mov	 ecx, ebp
  00159	e8 00 00 00 00	 call	 ?AddGCJoinWarWindow@CUser@@QAEXHH@Z ; CUser::AddGCJoinWarWindow

; 3327 : 						pGCMember->lspFifo.pop_front();

  0015e	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00161	8b 01		 mov	 eax, DWORD PTR [ecx]
  00163	3b c1		 cmp	 eax, ecx
  00165	0f 84 98 00 00
	00		 je	 $L308869
  0016b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016e	8b 10		 mov	 edx, DWORD PTR [eax]
  00170	89 11		 mov	 DWORD PTR [ecx], edx
  00172	8b 08		 mov	 ecx, DWORD PTR [eax]
  00174	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00177	50		 push	 eax
  00178	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0017b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00180	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00183	83 c4 04	 add	 esp, 4
  00186	48		 dec	 eax
  00187	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 3328 : 					}
; 3329 : 					else

  0018a	eb 77		 jmp	 SHORT $L308869
$L270043:

; 3330 : 					{
; 3331 : 						pGCMember->lspFifo.pop_front();

  0018c	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0018f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00191	3b c1		 cmp	 eax, ecx
  00193	8d 6e 2c	 lea	 ebp, DWORD PTR [esi+44]
  00196	74 1f		 je	 SHORT $L308759
  00198	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019b	8b 10		 mov	 edx, DWORD PTR [eax]
  0019d	89 11		 mov	 DWORD PTR [ecx], edx
  0019f	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001a4	50		 push	 eax
  001a5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001a8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ad	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  001b0	83 c4 04	 add	 esp, 4
  001b3	48		 dec	 eax
  001b4	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L308759:

; 3332 : 						pJoinPlayer->nlife--;

  001b7	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  001ba	49		 dec	 ecx

; 3333 : 						if( pJoinPlayer->nlife > 0 )

  001bb	8b c1		 mov	 eax, ecx
  001bd	85 c0		 test	 eax, eax
  001bf	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  001c2	7e 36		 jle	 SHORT $L308871

; 3334 : 							pGCMember->lspFifo.push_back( pJoinPlayer );

  001c4	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  001c7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001ca	8d 44 24 18	 lea	 eax, DWORD PTR _pJoinPlayer$270041[esp+28]
  001ce	50		 push	 eax
  001cf	51		 push	 ecx
  001d0	53		 push	 ebx
  001d1	8b cd		 mov	 ecx, ebp
  001d3	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  001d8	6a 01		 push	 1
  001da	8b cd		 mov	 ecx, ebp
  001dc	89 44 24 24	 mov	 DWORD PTR __Newnode$308849[esp+28], eax
  001e0	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  001e5	8b 44 24 20	 mov	 eax, DWORD PTR __Newnode$308849[esp+24]
  001e9	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  001ec	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ef	8b 5c 24 10	 mov	 ebx, DWORD PTR _this$[esp+28]
  001f3	89 02		 mov	 DWORD PTR [edx], eax

; 3335 : 						if( pJoinPlayer->nlife < 0 )

  001f5	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001f8	85 c0		 test	 eax, eax
$L308871:
  001fa	7d 07		 jge	 SHORT $L308869

; 3336 : 							pJoinPlayer->nlife	= 0;

  001fc	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$L308869:

; 3337 : 					}
; 3338 : 					if( pGCMember->nWarCount == m_nMaxWarPlayer )

  00203	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00206	3b 83 ac 10 00
	00		 cmp	 eax, DWORD PTR [ebx+4268]
  0020c	74 0b		 je	 SHORT $L308870
  0020e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00211	85 c0		 test	 eax, eax
  00213	0f 87 da fe ff
	ff		 ja	 $L270039
$L308870:
  00219	5f		 pop	 edi
$L308867:
  0021a	5e		 pop	 esi
  0021b	5d		 pop	 ebp
  0021c	5b		 pop	 ebx

; 3339 : 						break;
; 3340 : 				}	// while
; 3341 : 				break;
; 3342 : 			}	// if
; 3343 : 		}	// for
; 3344 : 	}	// if
; 3345 : #else // __S_BUG_GC
; 3346 : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( pUser->m_idGuild );
; 3347 : 	if( it != m_GuildCombatMem.end() )
; 3348 : 	{
; 3349 : 		__GuildCombatMember* pGCMember	= it->second;
; 3350 : 		for( int i = 0; i < pGCMember->vecGCSelectMember.size() ; ++i )
; 3351 : 		{
; 3352 : 			__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[i];
; 3353 : 			if( pJoinPlayer->uidPlayer == pUser->m_idPlayer )
; 3354 : 			{
; 3355 : 				//     pUser   
; 3356 : 				for( list<__JOINPLAYER*>::iterator i1 = pGCMember->lspFifo.begin(); i1 != pGCMember->lspFifo.end(); ++i1 )
; 3357 : 				{
; 3358 : 					if( pJoinPlayer == *i1 )
; 3359 : 						return;
; 3360 : 				}
; 3361 : //				pJoinPlayer->bEntry	= FALSE;
; 3362 : 				pJoinPlayer->dwTelTime	= 0;
; 3363 : 				pUser->m_nGuildCombatState	= 0;
; 3364 : 				g_UserMng.AddGuildCombatUserState( pUser );
; 3365 : 				--pGCMember->nWarCount;
; 3366 : 				pJoinPlayer->nlife--;
; 3367 : 				if( pJoinPlayer->nlife > 0 )
; 3368 : 					pGCMember->lspFifo.push_back( pJoinPlayer );
; 3369 : 				if( pJoinPlayer->nlife < 0 )
; 3370 : 					pJoinPlayer->nlife	= 0;
; 3371 : 
; 3372 : 				while( pGCMember->lspFifo.size() > 0 )
; 3373 : 				{
; 3374 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->lspFifo.front();
; 3375 : 					CMover* pMover	= prj.GetUserByID( pJoinPlayer->uidPlayer );
; 3376 : 					if( IsValidObj( pMover ) && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )
; 3377 : 					{
; 3378 : 						pGCMember->nWarCount++;
; 3379 : //						pJoinPlayer->bEntry	= TRUE;
; 3380 : 						pJoinPlayer->dwTelTime	= timeGetTime();
; 3381 : 						((CUser*)pMover)->AddGCJoinWarWindow( pJoinPlayer->nMap, m_nMaxMapTime );
; 3382 : 						pGCMember->lspFifo.pop_front();
; 3383 : 					}
; 3384 : 					else
; 3385 : 					{
; 3386 : 						pGCMember->lspFifo.pop_front();
; 3387 : 						pJoinPlayer->nlife--;
; 3388 : 						if( pJoinPlayer->nlife > 0 )
; 3389 : 							pGCMember->lspFifo.push_back( pJoinPlayer );
; 3390 : 						if( pJoinPlayer->nlife < 0 )
; 3391 : 							pJoinPlayer->nlife	= 0;
; 3392 : 					}
; 3393 : 					if( pGCMember->nWarCount == m_nMaxWarPlayer )
; 3394 : 						break;
; 3395 : 				}	// while
; 3396 : 				break;
; 3397 : 			}	// if
; 3398 : 		}	// for
; 3399 : 	}	// if
; 3400 : #endif // __S_BUG_GC
; 3401 : }

  0021d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00220	c2 08 00	 ret	 8
?SetPlayerChange@CGuildCombat@@QAEXPAVCUser@@0@Z ENDP	; CGuildCombat::SetPlayerChange
_TEXT	ENDS
PUBLIC	??0?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ??0?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ PROC NEAR ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >, COMDAT
; _this$ = ecx

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
  00008	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000b	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 00		 mov	 DWORD PTR [eax], eax
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 103  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	c3		 ret	 0
??0?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?push_back@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi

; 580  : 		if (size() < capacity())

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	75 04		 jne	 SHORT $L309050
  00008	33 d2		 xor	 edx, edx
  0000a	eb 08		 jmp	 SHORT $L309051
$L309050:
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	2b d6		 sub	 edx, esi
  00011	c1 fa 02	 sar	 edx, 2
$L309051:
  00014	85 f6		 test	 esi, esi
  00016	74 21		 je	 SHORT $L270756
  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	2b c6		 sub	 eax, esi
  0001d	c1 f8 02	 sar	 eax, 2
  00020	3b d0		 cmp	 edx, eax
  00022	73 15		 jae	 SHORT $L270756

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0002b	8b 12		 mov	 edx, DWORD PTR [edx]
  0002d	89 10		 mov	 DWORD PTR [eax], edx
  0002f	83 c0 04	 add	 eax, 4
  00032	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00035	5e		 pop	 esi

; 584  : 		}

  00036	c2 04 00	 ret	 4
$L270756:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00039	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0003d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00040	52		 push	 edx
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Insert_n
  00049	5e		 pop	 esi

; 584  : 		}

  0004a	c2 04 00	 ret	 4
?push_back@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCGETPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Cat$309261 = 8					; size = 1
$T309230 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCGETPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 580  : 		if (size() < capacity())

  00004	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00007	85 ff		 test	 edi, edi
  00009	75 04		 jne	 SHORT $L309236
  0000b	33 c9		 xor	 ecx, ecx
  0000d	eb 16		 jmp	 SHORT $L309237
$L309236:
  0000f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00012	2b cf		 sub	 ecx, edi
  00014	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00019	f7 e9		 imul	 ecx
  0001b	c1 fa 03	 sar	 edx, 3
  0001e	8b ca		 mov	 ecx, edx
  00020	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00023	03 ca		 add	 ecx, edx
$L309237:
  00025	85 ff		 test	 edi, edi
  00027	74 3e		 je	 SHORT $L270808
  00029	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0002c	2b d7		 sub	 edx, edi
  0002e	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00033	f7 ea		 imul	 edx
  00035	c1 fa 03	 sar	 edx, 3
  00038	8b c2		 mov	 eax, edx
  0003a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003d	03 c2		 add	 eax, edx
  0003f	3b c8		 cmp	 ecx, eax
  00041	73 24		 jae	 SHORT $L270808

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00043	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$309261[esp+4]
  00047	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp+4]
  0004b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004e	50		 push	 eax
  0004f	56		 push	 esi
  00050	51		 push	 ecx
  00051	6a 01		 push	 1
  00053	57		 push	 edi
  00054	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCGETPOINT@CGuildCombat@@IU12@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCGETPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCGETPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCGETPOINT *,unsigned int,CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
  00059	83 c4 14	 add	 esp, 20			; 00000014H
  0005c	83 c7 24	 add	 edi, 36			; 00000024H
  0005f	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 584  : 		}

  00064	c2 04 00	 ret	 4
$L270808:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00067	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp+4]
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	52		 push	 edx
  0006f	50		 push	 eax
  00070	8d 44 24 14	 lea	 eax, DWORD PTR $T309230[esp+12]
  00074	50		 push	 eax
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?insert@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::insert
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi

; 584  : 		}

  0007e	c2 04 00	 ret	 4
?push_back@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCGETPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCPLAYERPOINT@CGuildCombat@@@Z
_TEXT	SEGMENT
__Cat$309322 = 8					; size = 1
$T309288 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCPLAYERPOINT@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 580  : 		if (size() < capacity())

  00004	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00007	85 ff		 test	 edi, edi
  00009	75 04		 jne	 SHORT $L309293
  0000b	33 c9		 xor	 ecx, ecx
  0000d	eb 15		 jmp	 SHORT $L309294
$L309293:
  0000f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00012	2b cf		 sub	 ecx, edi
  00014	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00019	f7 e9		 imul	 ecx
  0001b	d1 fa		 sar	 edx, 1
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00022	03 ca		 add	 ecx, edx
$L309294:
  00024	85 ff		 test	 edi, edi
  00026	74 3d		 je	 SHORT $L270942
  00028	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0002b	2b d7		 sub	 edx, edi
  0002d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00032	f7 ea		 imul	 edx
  00034	d1 fa		 sar	 edx, 1
  00036	8b c2		 mov	 eax, edx
  00038	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003b	03 c2		 add	 eax, edx
  0003d	3b c8		 cmp	 ecx, eax
  0003f	73 24		 jae	 SHORT $L270942

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00041	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$309322[esp+4]
  00045	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp+4]
  00049	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004c	50		 push	 eax
  0004d	56		 push	 esi
  0004e	51		 push	 ecx
  0004f	6a 01		 push	 1
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCPLAYERPOINT@CGuildCombat@@IU12@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@YAXPAU__GCPLAYERPOINT@CGuildCombat@@IABU12@AAV?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCPLAYERPOINT *,unsigned int,CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
  00057	83 c4 14	 add	 esp, 20			; 00000014H
  0005a	83 c7 0c	 add	 edi, 12			; 0000000cH
  0005d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 584  : 		}

  00062	c2 04 00	 ret	 4
$L270942:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00065	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp+4]
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	52		 push	 edx
  0006d	50		 push	 eax
  0006e	8d 44 24 14	 lea	 eax, DWORD PTR $T309288[esp+12]
  00072	50		 push	 eax
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?insert@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::insert
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 584  : 		}

  0007c	c2 04 00	 ret	 4
?push_back@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCPLAYERPOINT@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXABQAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXABQAU__GuildCombatMember@CGuildCombat@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXABQAU__GuildCombatMember@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi

; 580  : 		if (size() < capacity())

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	75 04		 jne	 SHORT $L309351
  00008	33 d2		 xor	 edx, edx
  0000a	eb 08		 jmp	 SHORT $L309352
$L309351:
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	2b d6		 sub	 edx, esi
  00011	c1 fa 02	 sar	 edx, 2
$L309352:
  00014	85 f6		 test	 esi, esi
  00016	74 21		 je	 SHORT $L271198
  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	2b c6		 sub	 eax, esi
  0001d	c1 f8 02	 sar	 eax, 2
  00020	3b d0		 cmp	 edx, eax
  00022	73 15		 jae	 SHORT $L271198

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0002b	8b 12		 mov	 edx, DWORD PTR [edx]
  0002d	89 10		 mov	 DWORD PTR [eax], edx
  0002f	83 c0 04	 add	 eax, 4
  00032	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00035	5e		 pop	 esi

; 584  : 		}

  00036	c2 04 00	 ret	 4
$L271198:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00039	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0003d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00040	52		 push	 edx
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABQAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::_Insert_n
  00049	5e		 pop	 esi

; 584  : 		}

  0004a	c2 04 00	 ret	 4
?push_back@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXABQAU__GuildCombatMember@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::push_back
_TEXT	ENDS
PUBLIC	??1?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::~vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
; Function compile flags: /Ogty
;	COMDAT ??1?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::~vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >, COMDAT
; _this$ = ecx

; 388  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Tidy
??1?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::~vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Cat$309568 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 580  : 		if (size() < capacity())

  00003	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00006	85 d2		 test	 edx, edx
  00008	75 04		 jne	 SHORT $L309540
  0000a	33 c9		 xor	 ecx, ecx
  0000c	eb 08		 jmp	 SHORT $L309541
$L309540:
  0000e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00011	2b ca		 sub	 ecx, edx
  00013	c1 f9 02	 sar	 ecx, 2
$L309541:
  00016	85 d2		 test	 edx, edx
  00018	74 31		 je	 SHORT $L271338
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
  00022	3b c8		 cmp	 ecx, eax
  00024	73 25		 jae	 SHORT $L271338

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00026	8b 44 24 08	 mov	 eax, DWORD PTR __Cat$309568[esp]
  0002a	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp]
  0002e	57		 push	 edi
  0002f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00032	50		 push	 eax
  00033	56		 push	 esi
  00034	51		 push	 ecx
  00035	6a 01		 push	 1
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
  00040	83 c7 04	 add	 edi, 4
  00043	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 584  : 		}

  00048	c2 04 00	 ret	 4
$L271338:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  0004b	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0004f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00052	52		 push	 edx
  00053	6a 01		 push	 1
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Insert_n
  0005d	5e		 pop	 esi

; 584  : 		}

  0005e	c2 04 00	 ret	 4
?push_back@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::push_back
_TEXT	ENDS
PUBLIC	?clear@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::clear
; Function compile flags: /Ogty
;	COMDAT ?clear@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::clear, COMDAT
; _this$ = ecx

; 744  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Tidy
?clear@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAEXXZ ENDP ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXABU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXABU__GCSENDITEM@CGuildCombat@@@Z
_TEXT	SEGMENT
__Cat$309726 = 8					; size = 1
$T309693 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXABU__GCSENDITEM@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 580  : 		if (size() < capacity())

  00004	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00007	85 ff		 test	 edi, edi
  00009	75 04		 jne	 SHORT $L309698
  0000b	33 c9		 xor	 ecx, ecx
  0000d	eb 15		 jmp	 SHORT $L309699
$L309698:
  0000f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00012	2b cf		 sub	 ecx, edi
  00014	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00019	f7 e9		 imul	 ecx
  0001b	d1 fa		 sar	 edx, 1
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00022	03 ca		 add	 ecx, edx
$L309699:
  00024	85 ff		 test	 edi, edi
  00026	74 3d		 je	 SHORT $L271478
  00028	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0002b	2b d7		 sub	 edx, edi
  0002d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00032	f7 ea		 imul	 edx
  00034	d1 fa		 sar	 edx, 1
  00036	8b c2		 mov	 eax, edx
  00038	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003b	03 c2		 add	 eax, edx
  0003d	3b c8		 cmp	 ecx, eax
  0003f	73 24		 jae	 SHORT $L271478

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00041	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$309726[esp+4]
  00045	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp+4]
  00049	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004c	50		 push	 eax
  0004d	56		 push	 esi
  0004e	51		 push	 ecx
  0004f	6a 01		 push	 1
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__GCSENDITEM@CGuildCombat@@IU12@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@YAXPAU__GCSENDITEM@CGuildCombat@@IABU12@AAV?$allocator@U__GCSENDITEM@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__GCSENDITEM *,unsigned int,CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
  00057	83 c4 14	 add	 esp, 20			; 00000014H
  0005a	83 c7 0c	 add	 edi, 12			; 0000000cH
  0005d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 584  : 		}

  00062	c2 04 00	 ret	 4
$L271478:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00065	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp+4]
  00069	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006c	52		 push	 edx
  0006d	50		 push	 eax
  0006e	8d 44 24 14	 lea	 eax, DWORD PTR $T309693[esp+12]
  00072	50		 push	 eax
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?insert@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::insert
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 584  : 		}

  0007c	c2 04 00	 ret	 4
?push_back@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXABU__GCSENDITEM@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXABU__REQUESTGUILD@CGuildCombat@@@Z
_TEXT	SEGMENT
__Cat$309784 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXABU__REQUESTGUILD@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 580  : 		if (size() < capacity())

  00003	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00006	85 d2		 test	 edx, edx
  00008	75 04		 jne	 SHORT $L309757
  0000a	33 c9		 xor	 ecx, ecx
  0000c	eb 08		 jmp	 SHORT $L309758
$L309757:
  0000e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00011	2b ca		 sub	 ecx, edx
  00013	c1 f9 03	 sar	 ecx, 3
$L309758:
  00016	85 d2		 test	 edx, edx
  00018	74 31		 je	 SHORT $L271535
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 03	 sar	 eax, 3
  00022	3b c8		 cmp	 ecx, eax
  00024	73 25		 jae	 SHORT $L271535

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00026	8b 44 24 08	 mov	 eax, DWORD PTR __Cat$309784[esp]
  0002a	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp]
  0002e	57		 push	 edi
  0002f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00032	50		 push	 eax
  00033	56		 push	 esi
  00034	51		 push	 ecx
  00035	6a 01		 push	 1
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
  0003d	83 c4 14	 add	 esp, 20			; 00000014H
  00040	83 c7 08	 add	 edi, 8
  00043	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 584  : 		}

  00048	c2 04 00	 ret	 4
$L271535:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  0004b	8b 54 24 08	 mov	 edx, DWORD PTR __Val$[esp]
  0004f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00052	52		 push	 edx
  00053	6a 01		 push	 1
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Insert_n
  0005d	5e		 pop	 esi

; 584  : 		}

  0005e	c2 04 00	 ret	 4
?push_back@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXABU__REQUESTGUILD@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::push_back
; Function compile flags: /Ogty
;	COMDAT ?push_back@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT
__Cat$309941 = 8					; size = 1
$T309906 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABU__JOINPLAYER@CGuildCombat@@@Z PROC NEAR ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 580  : 		if (size() < capacity())

  00004	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00007	85 ff		 test	 edi, edi
  00009	75 04		 jne	 SHORT $L309912
  0000b	33 c9		 xor	 ecx, ecx
  0000d	eb 16		 jmp	 SHORT $L309913
$L309912:
  0000f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00012	2b cf		 sub	 ecx, edi
  00014	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00019	f7 e9		 imul	 ecx
  0001b	c1 fa 02	 sar	 edx, 2
  0001e	8b ca		 mov	 ecx, edx
  00020	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00023	03 ca		 add	 ecx, edx
$L309913:
  00025	85 ff		 test	 edi, edi
  00027	74 3e		 je	 SHORT $L272320
  00029	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0002c	2b d7		 sub	 edx, edi
  0002e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00033	f7 ea		 imul	 edx
  00035	c1 fa 02	 sar	 edx, 2
  00038	8b c2		 mov	 eax, edx
  0003a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003d	03 c2		 add	 eax, edx
  0003f	3b c8		 cmp	 ecx, eax
  00041	73 24		 jae	 SHORT $L272320

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00043	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$309941[esp+4]
  00047	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp+4]
  0004b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0004e	50		 push	 eax
  0004f	56		 push	 esi
  00050	51		 push	 ecx
  00051	6a 01		 push	 1
  00053	57		 push	 edi
  00054	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__JOINPLAYER@CGuildCombat@@IU12@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAU__JOINPLAYER@CGuildCombat@@IABU12@AAV?$allocator@U__JOINPLAYER@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__JOINPLAYER *,unsigned int,CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >
  00059	83 c4 14	 add	 esp, 20			; 00000014H
  0005c	83 c7 18	 add	 edi, 24			; 00000018H
  0005f	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 584  : 		}

  00064	c2 04 00	 ret	 4
$L272320:

; 582  : 		else
; 583  : 			insert(end(), _Val);

  00067	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp+4]
  0006b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006e	52		 push	 edx
  0006f	50		 push	 eax
  00070	8d 44 24 14	 lea	 eax, DWORD PTR $T309906[esp+12]
  00074	50		 push	 eax
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?insert@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@V312@ABU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::insert
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi

; 584  : 		}

  0007e	c2 04 00	 ret	 4
?push_back@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABU__JOINPLAYER@CGuildCombat@@@Z ENDP ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::push_back
_TEXT	ENDS
PUBLIC	??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::~map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T310063 = -4						; size = 4
??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ PROC NEAR ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::~map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	8d 44 24 0c	 lea	 eax, DWORD PTR $T310063[esp+16]
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	33 c0		 xor	 eax, eax
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	5e		 pop	 esi
  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::~map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >
_TEXT	ENDS
PUBLIC	??0CGuildCombat@@QAE@XZ				; CGuildCombat::CGuildCombat
PUBLIC	??_7CGuildCombat@@6B@				; CGuildCombat::`vftable'
PUBLIC	??_GCGuildCombat@@UAEPAXI@Z			; CGuildCombat::`scalar deleting destructor'
EXTRN	??0CTimer@@QAE@XZ:NEAR				; CTimer::CTimer
EXTRN	??_ECGuildCombat@@UAEPAXI@Z:NEAR		; CGuildCombat::`vector deleting destructor'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T310884 DD	0ffffffffH
	DD	FLAT:$L310091
	DD	00H
	DD	FLAT:$L310092
	DD	01H
	DD	FLAT:$L310093
	DD	02H
	DD	FLAT:$L310094
	DD	03H
	DD	FLAT:$L310095
	DD	04H
	DD	FLAT:$L310096
	DD	05H
	DD	FLAT:$L310097
	DD	06H
	DD	FLAT:$L310098
$T310882 DD	019930520H
	DD	08H
	DD	FLAT:$T310884
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CGuildCombat@@6B@
CONST	SEGMENT
??_7CGuildCombat@@6B@ DD FLAT:??_ECGuildCombat@@UAEPAXI@Z ; CGuildCombat::`vftable'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ??0CGuildCombat@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CGuildCombat@@QAE@XZ PROC NEAR			; CGuildCombat::CGuildCombat, COMDAT
; _this$ = ecx

; 280  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0CGuildCombat@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	33 db		 xor	 ebx, ebx
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CGuildCombat@@6B@
  00022	57		 push	 edi
  00023	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00027	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  0002a	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  0002d	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  00030	89 5c 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], ebx
  00034	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  00037	89 5e 68	 mov	 DWORD PTR [esi+104], ebx
  0003a	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx
  0003d	89 5e 74	 mov	 DWORD PTR [esi+116], ebx
  00040	89 5e 78	 mov	 DWORD PTR [esi+120], ebx
  00043	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx
  00046	8d 8e d0 10 00
	00		 lea	 ecx, DWORD PTR [esi+4304]
  0004c	c6 44 24 18 02	 mov	 BYTE PTR __$EHRec$[esp+36], 2
  00051	e8 00 00 00 00	 call	 ??0CTimer@@QAE@XZ	; CTimer::CTimer
  00056	89 9e f4 10 00
	00		 mov	 DWORD PTR [esi+4340], ebx
  0005c	89 9e f8 10 00
	00		 mov	 DWORD PTR [esi+4344], ebx
  00062	89 9e fc 10 00
	00		 mov	 DWORD PTR [esi+4348], ebx
  00068	89 9e 04 11 00
	00		 mov	 DWORD PTR [esi+4356], ebx
  0006e	89 9e 08 11 00
	00		 mov	 DWORD PTR [esi+4360], ebx
  00074	89 9e 0c 11 00
	00		 mov	 DWORD PTR [esi+4364], ebx
  0007a	89 9e 14 11 00
	00		 mov	 DWORD PTR [esi+4372], ebx
  00080	89 9e 18 11 00
	00		 mov	 DWORD PTR [esi+4376], ebx
  00086	89 9e 1c 11 00
	00		 mov	 DWORD PTR [esi+4380], ebx
  0008c	89 9e 24 11 00
	00		 mov	 DWORD PTR [esi+4388], ebx
  00092	89 9e 28 11 00
	00		 mov	 DWORD PTR [esi+4392], ebx
  00098	89 9e 2c 11 00
	00		 mov	 DWORD PTR [esi+4396], ebx
  0009e	89 9e 34 11 00
	00		 mov	 DWORD PTR [esi+4404], ebx
  000a4	89 9e 38 11 00
	00		 mov	 DWORD PTR [esi+4408], ebx
  000aa	89 9e 3c 11 00
	00		 mov	 DWORD PTR [esi+4412], ebx

; 281  : 	m_nState = CLOSE_STATE;

  000b0	c7 86 40 11 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4416], 1

; 282  : 	m_nGCState = WAR_CLOSE_STATE;

  000ba	c7 86 44 11 00
	00 69 00 00 00	 mov	 DWORD PTR [esi+4420], 105 ; 00000069H

; 283  : 	m_nGuildCombatIndex = 0;

  000c4	89 5e 40	 mov	 DWORD PTR [esi+64], ebx

; 284  : 	m_uWinGuildId = 0;

  000c7	89 5e 44	 mov	 DWORD PTR [esi+68], ebx

; 285  : 	m_nWinGuildCount = 0;

  000ca	89 5e 48	 mov	 DWORD PTR [esi+72], ebx

; 286  : 	m_uBestPlayer = 0;

  000cd	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx

; 287  : 	m_vecGCGetPoint.clear();

  000d0	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  000d3	3b c3		 cmp	 eax, ebx
  000d5	74 09		 je	 SHORT $L310798
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000dd	83 c4 04	 add	 esp, 4
$L310798:
  000e0	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  000e3	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  000e6	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx

; 288  : 	m_vecGCPlayerPoint.clear();

  000e9	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  000ec	3b c3		 cmp	 eax, ebx
  000ee	74 09		 je	 SHORT $L310818
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f6	83 c4 04	 add	 esp, 4
$L310818:
  000f9	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  000fc	89 5e 68	 mov	 DWORD PTR [esi+104], ebx
  000ff	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx

; 289  : #ifdef __WORLDSERVER
; 290  : #if __VER >= 8 // __GUILDCOMBAT_85
; 291  : 	vecGCSendItem.clear();

  00102	8b 86 04 11 00
	00		 mov	 eax, DWORD PTR [esi+4356]
  00108	3b c3		 cmp	 eax, ebx
  0010a	74 09		 je	 SHORT $L310837
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00112	83 c4 04	 add	 esp, 4
$L310837:
  00115	89 9e 04 11 00
	00		 mov	 DWORD PTR [esi+4356], ebx
  0011b	89 9e 08 11 00
	00		 mov	 DWORD PTR [esi+4360], ebx
  00121	89 9e 0c 11 00
	00		 mov	 DWORD PTR [esi+4364], ebx

; 292  : #endif // __VER >= 8
; 293  : #ifdef __S_BUG_GC
; 294  : 	m_vecGuildCombatMem.clear();

  00127	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0012a	3b c3		 cmp	 eax, ebx
  0012c	74 09		 je	 SHORT $L310858
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00134	83 c4 04	 add	 esp, 4
$L310858:
  00137	89 5e 74	 mov	 DWORD PTR [esi+116], ebx
  0013a	89 5e 78	 mov	 DWORD PTR [esi+120], ebx
  0013d	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx

; 295  : #else // __S_BUG_GC
; 296  : 	m_GuildCombatMem.clear();
; 297  : #endif // __S_BUG_GC
; 298  : 	vecRequestRanking.clear();

  00140	8b 86 14 11 00
	00		 mov	 eax, DWORD PTR [esi+4372]
  00146	3b c3		 cmp	 eax, ebx
  00148	74 09		 je	 SHORT $L310877
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00150	83 c4 04	 add	 esp, 4
$L310877:
  00153	89 9e 14 11 00
	00		 mov	 DWORD PTR [esi+4372], ebx
  00159	89 9e 18 11 00
	00		 mov	 DWORD PTR [esi+4376], ebx
  0015f	89 9e 1c 11 00
	00		 mov	 DWORD PTR [esi+4380], ebx

; 299  : 	m_dwTime = 0;

  00165	89 9e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ebx

; 300  : 	m_nStopWar = 0;

  0016b	89 9e 8c 10 00
	00		 mov	 DWORD PTR [esi+4236], ebx

; 301  : 	m_nJoinPanya = 0;

  00171	89 9e 90 10 00
	00		 mov	 DWORD PTR [esi+4240], ebx

; 302  : 	m_nGuildLevel = 0;

  00177	89 9e 94 10 00
	00		 mov	 DWORD PTR [esi+4244], ebx

; 303  : 	m_nMaxJoinMember = 0;

  0017d	89 9e a4 10 00
	00		 mov	 DWORD PTR [esi+4260], ebx

; 304  : 	m_nMaxPlayerLife = 0;

  00183	89 9e a8 10 00
	00		 mov	 DWORD PTR [esi+4264], ebx

; 305  : 	m_nMaxWarPlayer = 0;

  00189	89 9e ac 10 00
	00		 mov	 DWORD PTR [esi+4268], ebx

; 306  : 	m_nMaxPlayerPercent = 0;

  0018f	89 9e b8 10 00
	00		 mov	 DWORD PTR [esi+4280], ebx

; 307  : 	m_nMaxGuildPercent = 0;

  00195	89 9e b4 10 00
	00		 mov	 DWORD PTR [esi+4276], ebx

; 308  : 	m_nRequestCanclePercent = 0;

  0019b	89 9e bc 10 00
	00		 mov	 DWORD PTR [esi+4284], ebx

; 309  : 	m_nNotRequestPercent = 0;

  001a1	89 9e c0 10 00
	00		 mov	 DWORD PTR [esi+4288], ebx

; 310  : 	m_nItemPenya = 0;

  001a7	89 9e c4 10 00
	00		 mov	 DWORD PTR [esi+4292], ebx

; 311  : 	m_bMutex     = FALSE;

  001ad	89 9e c8 10 00
	00		 mov	 DWORD PTR [esi+4296], ebx

; 312  : 	m_bMutexMsg  = FALSE;

  001b3	89 9e cc 10 00
	00		 mov	 DWORD PTR [esi+4300], ebx

; 313  : 
; 314  : 	memset( __AutoOpen, 0, sizeof(__AUTO_OPEN) * 7 );	

  001b9	33 c0		 xor	 eax, eax
  001bb	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  001be	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  001c3	f3 ab		 rep stosd

; 315  : 
; 316  : 	m_nDay	= 0;
; 317  : #endif // __WORLDSERVER
; 318  : #ifdef __CLIENT
; 319  : 	m_bRequest = FALSE;
; 320  : #endif // __CLIENT
; 321  : }

  001c5	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  001c9	89 9e 48 11 00
	00		 mov	 DWORD PTR [esi+4424], ebx
  001cf	5f		 pop	 edi
  001d0	8b c6		 mov	 eax, esi
  001d2	5e		 pop	 esi
  001d3	5b		 pop	 ebx
  001d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001db	83 c4 10	 add	 esp, 16			; 00000010H
  001de	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L310091:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 50	 add	 ecx, 80			; 00000050H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::~vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
$L310092:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 60	 add	 ecx, 96			; 00000060H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::~vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
$L310093:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 70	 add	 ecx, 112		; 00000070H
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::~vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
$L310094:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 d0 10 00
	00		 add	 ecx, 4304		; 000010d0H
  0002a	e9 00 00 00 00	 jmp	 ??1CTimer@@UAE@XZ	; CTimer::~CTimer
$L310095:
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 f0 10 00
	00		 add	 ecx, 4336		; 000010f0H
  00038	e9 00 00 00 00	 jmp	 ??1?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::~vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
$L310096:
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 00 11 00
	00		 add	 ecx, 4352		; 00001100H
  00046	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::~vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
$L310097:
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 10 11 00
	00		 add	 ecx, 4368		; 00001110H
  00054	e9 00 00 00 00	 jmp	 ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
$L310098:
  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	81 c1 20 11 00
	00		 add	 ecx, 4384		; 00001120H
  00062	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::~vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
__ehhandler$??0CGuildCombat@@QAE@XZ:
  00067	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T310882
  0006c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CGuildCombat@@QAE@XZ ENDP				; CGuildCombat::CGuildCombat
PUBLIC	??1CGuildCombat@@UAE@XZ				; CGuildCombat::~CGuildCombat
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T311048 DD	0ffffffffH
	DD	FLAT:$L310890
	DD	00H
	DD	FLAT:$L310891
	DD	01H
	DD	FLAT:$L310892
	DD	02H
	DD	FLAT:$L310893
	DD	03H
	DD	FLAT:$L310894
	DD	04H
	DD	FLAT:$L310895
	DD	05H
	DD	FLAT:$L310896
	DD	06H
	DD	FLAT:$L310897
	DD	07H
	DD	FLAT:$L310898
$T311046 DD	019930520H
	DD	09H
	DD	FLAT:$T311048
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ??1CGuildCombat@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGuildCombat@@UAE@XZ PROC NEAR			; CGuildCombat::~CGuildCombat, COMDAT
; _this$ = ecx

; 324  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1CGuildCombat@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	57		 push	 edi
  0001a	89 74 24 08	 mov	 DWORD PTR _this$[esp+24], esi
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CGuildCombat@@6B@

; 325  : 	GuildCombatClear( 99 );

  00024	6a 63		 push	 99			; 00000063H
  00026	c7 44 24 18 08
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 8
  0002e	e8 00 00 00 00	 call	 ?GuildCombatClear@CGuildCombat@@QAEXH@Z ; CGuildCombat::GuildCombatClear

; 326  : }

  00033	8b 86 34 11 00
	00		 mov	 eax, DWORD PTR [esi+4404]
  00039	33 ff		 xor	 edi, edi
  0003b	3b c7		 cmp	 eax, edi
  0003d	74 09		 je	 SHORT $L310915
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00045	83 c4 04	 add	 esp, 4
$L310915:
  00048	89 be 34 11 00
	00		 mov	 DWORD PTR [esi+4404], edi
  0004e	89 be 38 11 00
	00		 mov	 DWORD PTR [esi+4408], edi
  00054	89 be 3c 11 00
	00		 mov	 DWORD PTR [esi+4412], edi
  0005a	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  00060	3b c7		 cmp	 eax, edi
  00062	74 09		 je	 SHORT $L310935
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006a	83 c4 04	 add	 esp, 4
$L310935:
  0006d	89 be 24 11 00
	00		 mov	 DWORD PTR [esi+4388], edi
  00073	89 be 28 11 00
	00		 mov	 DWORD PTR [esi+4392], edi
  00079	89 be 2c 11 00
	00		 mov	 DWORD PTR [esi+4396], edi
  0007f	8b 86 14 11 00
	00		 mov	 eax, DWORD PTR [esi+4372]
  00085	3b c7		 cmp	 eax, edi
  00087	74 09		 je	 SHORT $L310957
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$L310957:
  00092	89 be 14 11 00
	00		 mov	 DWORD PTR [esi+4372], edi
  00098	89 be 18 11 00
	00		 mov	 DWORD PTR [esi+4376], edi
  0009e	89 be 1c 11 00
	00		 mov	 DWORD PTR [esi+4380], edi
  000a4	8b 86 04 11 00
	00		 mov	 eax, DWORD PTR [esi+4356]
  000aa	3b c7		 cmp	 eax, edi
  000ac	74 09		 je	 SHORT $L310976
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b4	83 c4 04	 add	 esp, 4
$L310976:
  000b7	8d 8e f0 10 00
	00		 lea	 ecx, DWORD PTR [esi+4336]
  000bd	89 be 04 11 00
	00		 mov	 DWORD PTR [esi+4356], edi
  000c3	89 be 08 11 00
	00		 mov	 DWORD PTR [esi+4360], edi
  000c9	89 be 0c 11 00
	00		 mov	 DWORD PTR [esi+4364], edi
  000cf	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Tidy
  000d4	c7 86 d0 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4304], OFFSET FLAT:??_7CTimer@@6B@
  000de	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  000e1	3b c7		 cmp	 eax, edi
  000e3	74 09		 je	 SHORT $L311001
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000eb	83 c4 04	 add	 esp, 4
$L311001:
  000ee	89 7e 74	 mov	 DWORD PTR [esi+116], edi
  000f1	89 7e 78	 mov	 DWORD PTR [esi+120], edi
  000f4	89 7e 7c	 mov	 DWORD PTR [esi+124], edi
  000f7	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  000fa	3b c7		 cmp	 eax, edi
  000fc	74 09		 je	 SHORT $L311022
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00104	83 c4 04	 add	 esp, 4
$L311022:
  00107	89 7e 64	 mov	 DWORD PTR [esi+100], edi
  0010a	89 7e 68	 mov	 DWORD PTR [esi+104], edi
  0010d	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  00110	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00113	3b c7		 cmp	 eax, edi
  00115	74 09		 je	 SHORT $L311042
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011d	83 c4 04	 add	 esp, 4
$L311042:
  00120	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00124	89 7e 54	 mov	 DWORD PTR [esi+84], edi
  00127	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  0012a	89 7e 5c	 mov	 DWORD PTR [esi+92], edi
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00136	83 c4 10	 add	 esp, 16			; 00000010H
  00139	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L310890:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 50	 add	 ecx, 80			; 00000050H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::~vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >
$L310891:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 60	 add	 ecx, 96			; 00000060H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::~vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >
$L310892:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 70	 add	 ecx, 112		; 00000070H
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::~vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >
$L310893:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 d0 10 00
	00		 add	 ecx, 4304		; 000010d0H
  0002a	e9 00 00 00 00	 jmp	 ??1CTimer@@UAE@XZ	; CTimer::~CTimer
$L310894:
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 f0 10 00
	00		 add	 ecx, 4336		; 000010f0H
  00038	e9 00 00 00 00	 jmp	 ??1?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@QAE@XZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::~vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
$L310895:
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 00 11 00
	00		 add	 ecx, 4352		; 00001100H
  00046	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::~vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >
$L310896:
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 10 11 00
	00		 add	 ecx, 4368		; 00001110H
  00054	e9 00 00 00 00	 jmp	 ??1?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::~vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
$L310897:
  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	81 c1 20 11 00
	00		 add	 ecx, 4384		; 00001120H
  00062	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCRESULTVALUEGUILD@CGuildCombat@@V?$allocator@U__GCRESULTVALUEGUILD@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >::~vector<CGuildCombat::__GCRESULTVALUEGUILD,std::allocator<CGuildCombat::__GCRESULTVALUEGUILD> >
$L310898:
  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	81 c1 30 11 00
	00		 add	 ecx, 4400		; 00001130H
  00070	e9 00 00 00 00	 jmp	 ??1?$vector@U__GCRESULTVALUEPLAYER@CGuildCombat@@V?$allocator@U__GCRESULTVALUEPLAYER@CGuildCombat@@@std@@@std@@QAE@XZ ; std::vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >::~vector<CGuildCombat::__GCRESULTVALUEPLAYER,std::allocator<CGuildCombat::__GCRESULTVALUEPLAYER> >
__ehhandler$??1CGuildCombat@@UAE@XZ:
  00075	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T311046
  0007a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CGuildCombat@@UAE@XZ ENDP				; CGuildCombat::~CGuildCombat
PUBLIC	?AddvecGCGetPoint@CGuildCombat@@QAEXKKKKHHHHH@Z	; CGuildCombat::AddvecGCGetPoint
EXTRN	?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z:NEAR ; CUserMng::AddGCLogRealTimeWorld
; Function compile flags: /Ogty
;	COMDAT ?AddvecGCGetPoint@CGuildCombat@@QAEXKKKKHHHHH@Z
_TEXT	SEGMENT
_GCGetPoint$ = -36					; size = 36
_uidGuildAttack$ = 8					; size = 4
_uidGuildDefence$ = 12					; size = 4
_uidPlayerAttack$ = 16					; size = 4
_uidPlayerDefence$ = 20					; size = 4
_nPoint$ = 24						; size = 4
_bKillDiffernceGuild$ = 28				; size = 4
_bMaster$ = 32						; size = 4
_bDefender$ = 36					; size = 4
_bLastLife$ = 40					; size = 4
?AddvecGCGetPoint@CGuildCombat@@QAEXKKKKHHHHH@Z PROC NEAR ; CGuildCombat::AddvecGCGetPoint, COMDAT
; _this$ = ecx

; 385  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H

; 386  : 	__GCGETPOINT GCGetPoint;
; 387  : 	GCGetPoint.uidGuildAttack = uidGuildAttack;
; 388  : 	GCGetPoint.uidGuildDefence = uidGuildDefence;

  00003	8b 54 24 2c	 mov	 edx, DWORD PTR _uidGuildDefence$[esp+32]
  00007	8b 44 24 28	 mov	 eax, DWORD PTR _uidGuildAttack$[esp+32]
  0000b	89 54 24 04	 mov	 DWORD PTR _GCGetPoint$[esp+40], edx

; 389  : 	GCGetPoint.uidPlayerAttack = uidPlayerAttack;
; 390  : 	GCGetPoint.uidPlayerDefence = uidPlayerDefence;

  0000f	8b 54 24 34	 mov	 edx, DWORD PTR _uidPlayerDefence$[esp+32]
  00013	89 04 24	 mov	 DWORD PTR _GCGetPoint$[esp+36], eax
  00016	8b 44 24 30	 mov	 eax, DWORD PTR _uidPlayerAttack$[esp+32]
  0001a	89 54 24 0c	 mov	 DWORD PTR _GCGetPoint$[esp+48], edx

; 391  : 	GCGetPoint.nPoint = nPoint;
; 392  : 	GCGetPoint.bKillDiffernceGuild = bKillDiffernceGuild;

  0001e	8b 54 24 3c	 mov	 edx, DWORD PTR _bKillDiffernceGuild$[esp+32]
  00022	89 44 24 08	 mov	 DWORD PTR _GCGetPoint$[esp+44], eax
  00026	8b 44 24 38	 mov	 eax, DWORD PTR _nPoint$[esp+32]
  0002a	89 54 24 14	 mov	 DWORD PTR _GCGetPoint$[esp+56], edx

; 393  : 	GCGetPoint.bMaster = bMaster;
; 394  : 	GCGetPoint.bDefender = bDefender;

  0002e	8b 54 24 44	 mov	 edx, DWORD PTR _bDefender$[esp+32]
  00032	89 44 24 10	 mov	 DWORD PTR _GCGetPoint$[esp+52], eax
  00036	8b 44 24 40	 mov	 eax, DWORD PTR _bMaster$[esp+32]
  0003a	56		 push	 esi
  0003b	89 54 24 20	 mov	 DWORD PTR _GCGetPoint$[esp+68], edx
  0003f	57		 push	 edi
  00040	89 44 24 20	 mov	 DWORD PTR _GCGetPoint$[esp+68], eax

; 395  : 	GCGetPoint.bLastLife = bLastLife;

  00044	8b 44 24 50	 mov	 eax, DWORD PTR _bLastLife$[esp+40]

; 396  : 	m_vecGCGetPoint.push_back( GCGetPoint );

  00048	8d 54 24 08	 lea	 edx, DWORD PTR _GCGetPoint$[esp+44]
  0004c	52		 push	 edx
  0004d	83 c1 50	 add	 ecx, 80			; 00000050H
  00050	89 44 24 2c	 mov	 DWORD PTR _GCGetPoint$[esp+80], eax
  00054	e8 00 00 00 00	 call	 ?push_back@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::push_back

; 397  : #ifdef __WORLDSERVER
; 398  : 	g_UserMng.AddGCLogRealTimeWorld( GCGetPoint );

  00059	83 ec 24	 sub	 esp, 36			; 00000024H
  0005c	8b fc		 mov	 edi, esp
  0005e	b9 09 00 00 00	 mov	 ecx, 9
  00063	8d 74 24 2c	 lea	 esi, DWORD PTR _GCGetPoint$[esp+80]
  00067	f3 a5		 rep movsd
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0006e	e8 00 00 00 00	 call	 ?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z ; CUserMng::AddGCLogRealTimeWorld

; 399  : #endif // __WORLDSERVER
; 400  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	83 c4 24	 add	 esp, 36			; 00000024H
  00078	c2 24 00	 ret	 36			; 00000024H
?AddvecGCGetPoint@CGuildCombat@@QAEXKKKKHHHHH@Z ENDP	; CGuildCombat::AddvecGCGetPoint
_TEXT	ENDS
PUBLIC	?AddvecGCPlayerPoint@CGuildCombat@@QAEXKHH@Z	; CGuildCombat::AddvecGCPlayerPoint
; Function compile flags: /Ogty
;	COMDAT ?AddvecGCPlayerPoint@CGuildCombat@@QAEXKHH@Z
_TEXT	SEGMENT
_GCPlayerPoint$ = -12					; size = 12
_uidPlayer$ = 8						; size = 4
_nJob$ = 12						; size = 4
_nPoint$ = 16						; size = 4
?AddvecGCPlayerPoint@CGuildCombat@@QAEXKHH@Z PROC NEAR	; CGuildCombat::AddvecGCPlayerPoint, COMDAT
; _this$ = ecx

; 403  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 404  : 	__GCPLAYERPOINT GCPlayerPoint;
; 405  : 	GCPlayerPoint.uidPlayer = uidPlayer;
; 406  : 	GCPlayerPoint.nJob = nJob;

  00003	8b 54 24 14	 mov	 edx, DWORD PTR _nJob$[esp+8]
  00007	8b 44 24 10	 mov	 eax, DWORD PTR _uidPlayer$[esp+8]
  0000b	89 54 24 04	 mov	 DWORD PTR _GCPlayerPoint$[esp+16], edx
  0000f	89 04 24	 mov	 DWORD PTR _GCPlayerPoint$[esp+12], eax

; 407  : 	GCPlayerPoint.nPoint = nPoint;

  00012	8b 44 24 18	 mov	 eax, DWORD PTR _nPoint$[esp+8]

; 408  : 	m_vecGCPlayerPoint.push_back( GCPlayerPoint );

  00016	8d 14 24	 lea	 edx, DWORD PTR _GCPlayerPoint$[esp+12]
  00019	52		 push	 edx
  0001a	83 c1 60	 add	 ecx, 96			; 00000060H
  0001d	89 44 24 0c	 mov	 DWORD PTR _GCPlayerPoint$[esp+24], eax
  00021	e8 00 00 00 00	 call	 ?push_back@?$vector@U__GCPLAYERPOINT@CGuildCombat@@V?$allocator@U__GCPLAYERPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCPLAYERPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCPLAYERPOINT,std::allocator<CGuildCombat::__GCPLAYERPOINT> >::push_back

; 409  : }

  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	c2 0c 00	 ret	 12			; 0000000cH
?AddvecGCPlayerPoint@CGuildCombat@@QAEXKHH@Z ENDP	; CGuildCombat::AddvecGCPlayerPoint
_TEXT	ENDS
PUBLIC	?AddSelectPlayer@CGuildCombat@@QAEXKK@Z		; CGuildCombat::AddSelectPlayer
; Function compile flags: /Ogty
;	COMDAT ?AddSelectPlayer@CGuildCombat@@QAEXKK@Z
_TEXT	SEGMENT
_pJoinPlayer$268413 = 8					; size = 4
_idGuild$ = 8						; size = 4
_uidPlayer$ = 12					; size = 4
?AddSelectPlayer@CGuildCombat@@QAEXKK@Z PROC NEAR	; CGuildCombat::AddSelectPlayer, COMDAT
; _this$ = ecx

; 517  : #ifdef __S_BUG_GC
; 518  : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( idGuild );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _idGuild$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	50		 push	 eax
  00008	8b f9		 mov	 edi, ecx
  0000a	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  0000f	8b d8		 mov	 ebx, eax

; 519  : 	if( pGCMember != NULL )

  00011	33 f6		 xor	 esi, esi
  00013	3b de		 cmp	 ebx, esi
  00015	74 53		 je	 SHORT $L268412

; 520  : 	{
; 521  : 		__JOINPLAYER* pJoinPlayer = new __JOINPLAYER;

  00017	6a 18		 push	 24			; 00000018H
  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	83 c4 04	 add	 esp, 4
  00021	3b c6		 cmp	 eax, esi
  00023	74 13		 je	 SHORT $L311068
  00025	89 30		 mov	 DWORD PTR [eax], esi
  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0002a	89 70 08	 mov	 DWORD PTR [eax+8], esi
  0002d	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00030	89 70 10	 mov	 DWORD PTR [eax+16], esi
  00033	89 70 14	 mov	 DWORD PTR [eax+20], esi
  00036	eb 02		 jmp	 SHORT $L311069
$L311068:
  00038	33 c0		 xor	 eax, eax
$L311069:

; 522  : 		pJoinPlayer->nlife = m_nMaxPlayerLife;	

  0003a	8b 8f a8 10 00
	00		 mov	 ecx, DWORD PTR [edi+4264]

; 523  : 		pJoinPlayer->uidPlayer = uidPlayer;

  00040	8b 54 24 14	 mov	 edx, DWORD PTR _uidPlayer$[esp+8]
  00044	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00047	89 10		 mov	 DWORD PTR [eax], edx

; 524  : 		pJoinPlayer->nMap = 99;

  00049	c7 40 10 63 00
	00 00		 mov	 DWORD PTR [eax+16], 99	; 00000063H

; 525  : 		pJoinPlayer->nPoint = 0;

  00050	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 526  : 		pJoinPlayer->uKillidGuild = 0;

  00053	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00056	89 44 24 10	 mov	 DWORD PTR _pJoinPlayer$268413[esp+8], eax

; 527  : 		pJoinPlayer->dwTelTime = 0;

  0005a	89 70 14	 mov	 DWORD PTR [eax+20], esi

; 528  : 		pGCMember->vecGCSelectMember.push_back( pJoinPlayer );

  0005d	8d 44 24 10	 lea	 eax, DWORD PTR _pJoinPlayer$268413[esp+8]
  00061	50		 push	 eax
  00062	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00065	e8 00 00 00 00	 call	 ?push_back@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::push_back
$L268412:
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx

; 529  : 	}
; 530  : #else // __S_BUG_GC
; 531  : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( idGuild );
; 532  : 	if( it != m_GuildCombatMem.end() )
; 533  : 	{
; 534  : 		__GuildCombatMember* pGCMember = it->second;
; 535  : 		__JOINPLAYER* pJoinPlayer = new __JOINPLAYER;
; 536  : 		pJoinPlayer->nlife = m_nMaxPlayerLife;	
; 537  : 		pJoinPlayer->uidPlayer = uidPlayer;
; 538  : //		pJoinPlayer->bEntry = FALSE;
; 539  : 		pJoinPlayer->nMap = 99;
; 540  : 		pJoinPlayer->nPoint = 0;
; 541  : 		pJoinPlayer->uKillidGuild = 0;
; 542  : 		pJoinPlayer->dwTelTime = 0;
; 543  : 		pGCMember->vecGCSelectMember.push_back( pJoinPlayer );
; 544  : 	}
; 545  : #endif // __S_BUG_GC
; 546  : }

  0006d	c2 08 00	 ret	 8
?AddSelectPlayer@CGuildCombat@@QAEXKK@Z ENDP		; CGuildCombat::AddSelectPlayer
_TEXT	ENDS
PUBLIC	?GetSelectPlayer@CGuildCombat@@QAEXKAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@@Z ; CGuildCombat::GetSelectPlayer
; Function compile flags: /Ogty
;	COMDAT ?GetSelectPlayer@CGuildCombat@@QAEXKAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@@Z
_TEXT	SEGMENT
_idGuild$ = 8						; size = 4
_vecSelectPlayer$ = 12					; size = 4
?GetSelectPlayer@CGuildCombat@@QAEXKAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@@Z PROC NEAR ; CGuildCombat::GetSelectPlayer, COMDAT
; _this$ = ecx

; 549  : #ifdef __S_BUG_GC
; 550  : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( idGuild );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _idGuild$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  0000b	8b f0		 mov	 esi, eax

; 551  : 	if( pGCMember != NULL )

  0000d	85 f6		 test	 esi, esi
  0000f	74 3c		 je	 SHORT $L268430
  00011	53		 push	 ebx

; 552  : 	{
; 553  : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00012	8b 5c 24 10	 mov	 ebx, DWORD PTR _vecSelectPlayer$[esp+4]
  00016	57		 push	 edi
  00017	33 ff		 xor	 edi, edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$L268428:
  00020	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00023	85 c9		 test	 ecx, ecx
  00025	75 04		 jne	 SHORT $L311082
  00027	33 c0		 xor	 eax, eax
  00029	eb 08		 jmp	 SHORT $L311083
$L311082:
  0002b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002e	2b c1		 sub	 eax, ecx
  00030	c1 f8 02	 sar	 eax, 2
$L311083:
  00033	3b f8		 cmp	 edi, eax
  00035	7d 14		 jge	 SHORT $L311141
  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 554  : 		{
; 555  : 			__JOINPLAYER* pJoinPlayer =  pGCMember->vecGCSelectMember[veci];
; 556  : 			vecSelectPlayer.push_back( *pJoinPlayer );

  0003a	8b 14 b9	 mov	 edx, DWORD PTR [ecx+edi*4]
  0003d	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]
  00040	52		 push	 edx
  00041	8b cb		 mov	 ecx, ebx
  00043	e8 00 00 00 00	 call	 ?push_back@?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXABU__JOINPLAYER@CGuildCombat@@@Z ; std::vector<CGuildCombat::__JOINPLAYER,std::allocator<CGuildCombat::__JOINPLAYER> >::push_back
  00048	47		 inc	 edi
  00049	eb d5		 jmp	 SHORT $L268428
$L311141:
  0004b	5f		 pop	 edi
  0004c	5b		 pop	 ebx
$L268430:
  0004d	5e		 pop	 esi

; 557  : 		}
; 558  : 	}	
; 559  : #else // __S_BUG_GC
; 560  : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( idGuild );
; 561  : 	if( it != m_GuildCombatMem.end() )
; 562  : 	{
; 563  : 		__GuildCombatMember* pGCMember = it->second;
; 564  : 		for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 565  : 		{
; 566  : 			__JOINPLAYER* pJoinPlayer =  pGCMember->vecGCSelectMember[veci];
; 567  : 			vecSelectPlayer.push_back( *pJoinPlayer );
; 568  : 		}
; 569  : 	}	
; 570  : #endif // __S_BUG_GC
; 571  : }

  0004e	c2 08 00	 ret	 8
?GetSelectPlayer@CGuildCombat@@QAEXKAAV?$vector@U__JOINPLAYER@CGuildCombat@@V?$allocator@U__JOINPLAYER@CGuildCombat@@@std@@@std@@@Z ENDP ; CGuildCombat::GetSelectPlayer
_TEXT	ENDS
PUBLIC	?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z	; CGuildCombat::OutWar
EXTRN	?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z:NEAR ; CUserMng::AddGCWarPlayerlist
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T311545 DD	0ffffffffH
	DD	FLAT:$L311146
$T311537 DD	019930520H
	DD	01H
	DD	FLAT:$T311545
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_i$311365 = -32						; size = 4
_vecDefender$268723 = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pUser$ = 8						; size = 4
_vecii0$268724 = 12					; size = 4
_pLeader$ = 12						; size = 4
$T311368 = 16						; size = 4
_bLogOut$ = 16						; size = 4
?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z PROC NEAR	; CGuildCombat::OutWar, COMDAT
; _this$ = ecx

; 610  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 18	 sub	 esp, 24			; 00000018H
  00018	55		 push	 ebp
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 611  : #ifdef __S_BUG_GC
; 612  : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( pUser->m_idGuild );

  0001b	8b 7c 24 34	 mov	 edi, DWORD PTR _pUser$[esp+44]
  0001f	8b 87 1c 07 00
	00		 mov	 eax, DWORD PTR [edi+1820]
  00025	8b e9		 mov	 ebp, ecx
  00027	50		 push	 eax
  00028	89 6c 24 10	 mov	 DWORD PTR _this$[esp+52], ebp
  0002c	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  00031	8b f0		 mov	 esi, eax

; 613  : 	if( pGCMember != NULL )

  00033	85 f6		 test	 esi, esi
  00035	0f 84 38 01 00
	00		 je	 $L311541

; 614  : 	{
; 615  : 		//    
; 616  : 		SetPlayerChange( pUser, pLeader );

  0003b	8b 4c 24 38	 mov	 ecx, DWORD PTR _pLeader$[esp+44]
  0003f	51		 push	 ecx
  00040	57		 push	 edi
  00041	8b cd		 mov	 ecx, ebp
  00043	e8 00 00 00 00	 call	 ?SetPlayerChange@CGuildCombat@@QAEXPAVCUser@@0@Z ; CGuildCombat::SetPlayerChange

; 617  : 		//       
; 618  : 
; 619  : 		if( bLogOut )

  00048	8b 44 24 3c	 mov	 eax, DWORD PTR _bLogOut$[esp+44]
  0004c	85 c0		 test	 eax, eax
  0004e	0f 84 1f 01 00
	00		 je	 $L311541

; 620  : 		{
; 621  : 			if( pUser->m_idPlayer == pGCMember->m_uidDefender )	//  

  00054	8b 97 38 02 00
	00		 mov	 edx, DWORD PTR [edi+568]
  0005a	3b 56 1c	 cmp	 edx, DWORD PTR [esi+28]
  0005d	0f 85 10 01 00
	00		 jne	 $L311541

; 622  : 			{
; 623  : 				CGuild* pGuild = g_GuildMng.GetGuild( pUser->m_idGuild  );

  00063	8b 87 1c 07 00
	00		 mov	 eax, DWORD PTR [edi+1820]
  00069	53		 push	 ebx
  0006a	50		 push	 eax
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00070	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild
  00075	8b d8		 mov	 ebx, eax

; 624  : 				if( pGuild )

  00077	85 db		 test	 ebx, ebx
  00079	0f 84 f3 00 00
	00		 je	 $L311543

; 625  : 				{
; 626  : 					vector<int> vecDefender;

  0007f	33 ed		 xor	 ebp, ebp
  00081	89 6c 24 1c	 mov	 DWORD PTR _vecDefender$268723[esp+56], ebp
  00085	89 6c 24 20	 mov	 DWORD PTR _vecDefender$268723[esp+60], ebp
  00089	89 6c 24 24	 mov	 DWORD PTR _vecDefender$268723[esp+64], ebp

; 627  : 					vecDefender.clear();

  0008d	8d 4c 24 18	 lea	 ecx, DWORD PTR _vecDefender$268723[esp+52]
  00091	89 6c 24 30	 mov	 DWORD PTR __$EHRec$[esp+60], ebp
  00095	e8 00 00 00 00	 call	 ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
$L311544:

; 628  : 					for( int vecii0 = 0 ; vecii0 < (int)( pGCMember->vecGCSelectMember.size() ) ; ++vecii0 )

  0009a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0009d	85 c9		 test	 ecx, ecx
  0009f	89 6c 24 3c	 mov	 DWORD PTR _vecii0$268724[esp+48], ebp
  000a3	75 04		 jne	 SHORT $L311237
  000a5	33 c0		 xor	 eax, eax
  000a7	eb 08		 jmp	 SHORT $L311238
$L311237:
  000a9	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000ac	2b c1		 sub	 eax, ecx
  000ae	c1 f8 02	 sar	 eax, 2
$L311238:
  000b1	3b e8		 cmp	 ebp, eax
  000b3	7d 64		 jge	 SHORT $L268728

; 629  : 					{
; 630  : 						__JOINPLAYER* pJoinPlayer3 = pGCMember->vecGCSelectMember[vecii0];

  000b5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b8	8b 3c a9	 mov	 edi, DWORD PTR [ecx+ebp*4]

; 631  : 						CMover* pMover = prj.GetUserByID( pJoinPlayer3->uidPlayer );

  000bb	8b 17		 mov	 edx, DWORD PTR [edi]
  000bd	8d 04 a9	 lea	 eax, DWORD PTR [ecx+ebp*4]
  000c0	8d 44 24 40	 lea	 eax, DWORD PTR $T311368[esp+48]
  000c4	50		 push	 eax
  000c5	8d 4c 24 18	 lea	 ecx, DWORD PTR _i$311365[esp+56]
  000c9	51		 push	 ecx
  000ca	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  000cf	89 54 24 48	 mov	 DWORD PTR $T311368[esp+56], edx
  000d3	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  000d8	8b 44 24 14	 mov	 eax, DWORD PTR _i$311365[esp+52]
  000dc	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  000e2	74 32		 je	 SHORT $L268727
  000e4	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 632  : 						if( IsValidObj( pMover ) )

  000e7	85 c0		 test	 eax, eax
  000e9	74 2b		 je	 SHORT $L268727
  000eb	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  000ef	75 25		 jne	 SHORT $L268727

; 633  : 						{						
; 634  : 							if( pGuild->IsMaster( pMover->m_idPlayer ) == FALSE && pGCMember->m_uidDefender != pMover->m_idPlayer && 0 < pJoinPlayer3->nlife )

  000f1	8b 80 38 02 00
	00		 mov	 eax, DWORD PTR [eax+568]
  000f7	39 43 44	 cmp	 DWORD PTR [ebx+68], eax
  000fa	74 1a		 je	 SHORT $L268727
  000fc	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  000ff	74 15		 je	 SHORT $L268727
  00101	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00104	85 c0		 test	 eax, eax
  00106	7e 0e		 jle	 SHORT $L268727

; 635  : 							{
; 636  : 								vecDefender.push_back( vecii0 );

  00108	8d 54 24 3c	 lea	 edx, DWORD PTR _vecii0$268724[esp+48]
  0010c	52		 push	 edx
  0010d	8d 4c 24 1c	 lea	 ecx, DWORD PTR _vecDefender$268723[esp+56]
  00111	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$L268727:

; 628  : 					for( int vecii0 = 0 ; vecii0 < (int)( pGCMember->vecGCSelectMember.size() ) ; ++vecii0 )

  00116	45		 inc	 ebp
  00117	eb 81		 jmp	 SHORT $L311544
$L268728:

; 637  : 							}
; 638  : 						}
; 639  : 					}
; 640  : 					if( 0 < vecDefender.size() )

  00119	8b 7c 24 1c	 mov	 edi, DWORD PTR _vecDefender$268723[esp+56]
  0011d	85 ff		 test	 edi, edi
  0011f	74 34		 je	 SHORT $L268733
  00121	8b 4c 24 20	 mov	 ecx, DWORD PTR _vecDefender$268723[esp+60]
  00125	2b cf		 sub	 ecx, edi
  00127	c1 f9 02	 sar	 ecx, 2
  0012a	85 c9		 test	 ecx, ecx
  0012c	76 27		 jbe	 SHORT $L268733

; 641  : 					{
; 642  : 						int nPlayerPos = xRandom( vecDefender.size() );

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00133	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  00139	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  0013e	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  00143	33 d2		 xor	 edx, edx
  00145	f7 f1		 div	 ecx

; 643  : 						int nDefender = vecDefender[nPlayerPos];
; 644  : 						__JOINPLAYER* pJoinPlayer4 = pGCMember->vecGCSelectMember[nDefender];

  00147	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0014a	8b 14 97	 mov	 edx, DWORD PTR [edi+edx*4]
  0014d	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 645  : 						pGCMember->m_uidDefender = pJoinPlayer4->uidPlayer;

  00150	8b 00		 mov	 eax, DWORD PTR [eax]
  00152	89 46 1c	 mov	 DWORD PTR [esi+28], eax
$L268733:

; 646  : 					}
; 647  : 				}

  00155	85 ff		 test	 edi, edi
  00157	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+60], -1
  0015f	74 09		 je	 SHORT $L311540
  00161	57		 push	 edi
  00162	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00167	83 c4 04	 add	 esp, 4
$L311540:
  0016a	8b 6c 24 10	 mov	 ebp, DWORD PTR _this$[esp+52]
  0016e	8b 7c 24 38	 mov	 edi, DWORD PTR _pUser$[esp+48]
$L311543:
  00172	5b		 pop	 ebx
$L311541:

; 648  : 			}	// if( pUser->m_idPlayer == pGCMember->m_uidDefender )	//  
; 649  : 		}	// if( bLogOut )
; 650  : 	}
; 651  : #else __S_BUG_GC
; 652  : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( pUser->m_idGuild );
; 653  : 	if( it != m_GuildCombatMem.end() )
; 654  : 	{
; 655  : 		//    
; 656  : 		SetPlayerChange( pUser, pLeader );
; 657  : 		//       
; 658  : 
; 659  : 		if( bLogOut )
; 660  : 		{
; 661  : 			__GuildCombatMember* pGCMember	= it->second;
; 662  : 			if( pUser->m_idPlayer == pGCMember->m_uidDefender )	//  
; 663  : 			{
; 664  : 				CGuild* pGuild = g_GuildMng.GetGuild( pUser->m_idGuild  );
; 665  : 				if( pGuild )
; 666  : 				{
; 667  : 					vector<int> vecDefender;
; 668  : 					vecDefender.clear();
; 669  : 					for( int vecii0 = 0 ; vecii0 < pGCMember->vecGCSelectMember.size() ; ++vecii0 )
; 670  : 					{
; 671  : 						__JOINPLAYER* pJoinPlayer3 = pGCMember->vecGCSelectMember[vecii0];
; 672  : 						CMover* pMover = prj.GetUserByID( pJoinPlayer3->uidPlayer );
; 673  : 						if( IsValidObj( pMover ) )
; 674  : 						{						
; 675  : 							if( pGuild->IsMaster( pMover->m_idPlayer ) == FALSE && pGCMember->m_uidDefender != pMover->m_idPlayer && 0 < pJoinPlayer3->nlife )
; 676  : 							{
; 677  : 								vecDefender.push_back( vecii0 );
; 678  : 							}
; 679  : 						}
; 680  : 					}
; 681  : 					if( 0 < vecDefender.size() )
; 682  : 					{
; 683  : 						int nPlayerPos = xRandom( vecDefender.size() );
; 684  : 						int nDefender = vecDefender[nPlayerPos];
; 685  : 						__JOINPLAYER* pJoinPlayer4 = pGCMember->vecGCSelectMember[nDefender];
; 686  : 						pGCMember->m_uidDefender = pJoinPlayer4->uidPlayer;
; 687  : 					}
; 688  : 				}
; 689  : 			}	// if( pUser->m_idPlayer == pGCMember->m_uidDefender )	//  
; 690  : 		}	// if( bLogOut )
; 691  : 	}
; 692  : #endif // __S_BUG_GC
; 693  : 	g_UserMng.AddGCGuildStatus( pUser->m_idGuild );

  00173	8b 8f 1c 07 00
	00		 mov	 ecx, DWORD PTR [edi+1820]
  00179	6a 00		 push	 0
  0017b	51		 push	 ecx
  0017c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00181	e8 00 00 00 00	 call	 ?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z ; CUserMng::AddGCGuildStatus

; 694  : 	g_UserMng.AddGCWarPlayerlist();

  00186	6a 00		 push	 0
  00188	6a 00		 push	 0
  0018a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0018f	e8 00 00 00 00	 call	 ?AddGCWarPlayerlist@CUserMng@@QAEXKPAVCUser@@@Z ; CUserMng::AddGCWarPlayerlist

; 695  : 
; 696  : 	//     
; 697  : 	UserOutGuildCombatResult( pUser );

  00194	57		 push	 edi
  00195	8b cd		 mov	 ecx, ebp
  00197	e8 00 00 00 00	 call	 ?UserOutGuildCombatResult@CGuildCombat@@QAEXPAVCUser@@@Z ; CGuildCombat::UserOutGuildCombatResult

; 698  : }

  0019c	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	5d		 pop	 ebp
  001a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001aa	83 c4 24	 add	 esp, 36			; 00000024H
  001ad	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L311146:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _vecDefender$268723[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T311537
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OutWar@CGuildCombat@@QAEXPAVCUser@@0H@Z ENDP		; CGuildCombat::OutWar
PUBLIC	?GuildCombatOpen@CGuildCombat@@QAEXXZ		; CGuildCombat::GuildCombatOpen
EXTRN	?SendGuildCombatStart@CDPDatabaseClient@@QAEXXZ:NEAR ; CDPDatabaseClient::SendGuildCombatStart
EXTRN	?AddGCDiagMessage@CUser@@QAEXPBD@Z:NEAR		; CUser::AddGCDiagMessage
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T312080 DD	0ffffffffH
	DD	FLAT:$L311552
	DD	00H
	DD	FLAT:$L311553
$T312072 DD	019930520H
	DD	02H
	DD	FLAT:$T312080
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ?GuildCombatOpen@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_strCancle$ = -36					; size = 4
_strOK$ = -32						; size = 4
_Guildi$269095 = -28					; size = 4
$T311998 = -24						; size = 4
_RequestGuild$269087 = -24				; size = 8
_i$311976 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GuildCombatOpen@CGuildCombat@@QAEXXZ PROC NEAR		; CGuildCombat::GuildCombatOpen, COMDAT
; _this$ = ecx

; 1687 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GuildCombatOpen@CGuildCombat@@QAEXXZ
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 18	 sub	 esp, 24			; 00000018H
  00018	56		 push	 esi
  00019	8b f1		 mov	 esi, ecx

; 1688 : 	//       ..
; 1689 : 	if( m_nState != CLOSE_STATE )

  0001b	83 be 40 11 00
	00 01		 cmp	 DWORD PTR [esi+4416], 1
  00022	0f 85 9f 02 00
	00		 jne	 $L312068
  00028	53		 push	 ebx
  00029	55		 push	 ebp
  0002a	57		 push	 edi

; 1690 : 		return;
; 1691 : 
; 1692 : #if __VER >= 8 // __GUILDCOMBAT_85
; 1693 : 	m_vecstrGuildMsg.clear();

  0002b	8d 8e f0 10 00
	00		 lea	 ecx, DWORD PTR [esi+4336]
  00031	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXXZ ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Tidy

; 1694 : #endif // __VER >= 8
; 1695 : 	if( g_eLocal.GetState( EVE_GUILDCOMBAT ) )

  00036	6a 0f		 push	 15			; 0000000fH
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0003d	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00042	33 db		 xor	 ebx, ebx
  00044	84 c0		 test	 al, al
  00046	74 0b		 je	 SHORT $L269079

; 1696 : 		g_DPCoreClient.SendGuildCombatState( OPEN_STATE );	

  00048	53		 push	 ebx
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  0004e	e8 00 00 00 00	 call	 ?SendGuildCombatState@CDPCoreClient@@QAEXH@Z ; CDPCoreClient::SendGuildCombatState
$L269079:

; 1697 : 
; 1698 : 	m_vecGCGetPoint.clear();

  00053	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00056	3b c3		 cmp	 eax, ebx
  00058	74 09		 je	 SHORT $L311572
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$L311572:
  00063	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  00066	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  00069	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx

; 1699 : 	m_GCResultValueGuild.clear();

  0006c	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  00072	3b c3		 cmp	 eax, ebx
  00074	74 09		 je	 SHORT $L311593
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007c	83 c4 04	 add	 esp, 4
$L311593:
  0007f	89 9e 24 11 00
	00		 mov	 DWORD PTR [esi+4388], ebx
  00085	89 9e 28 11 00
	00		 mov	 DWORD PTR [esi+4392], ebx
  0008b	89 9e 2c 11 00
	00		 mov	 DWORD PTR [esi+4396], ebx

; 1700 : 	m_GCResultValuePlayer.clear();

  00091	8b 86 34 11 00
	00		 mov	 eax, DWORD PTR [esi+4404]
  00097	3b c3		 cmp	 eax, ebx
  00099	74 09		 je	 SHORT $L311613
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a1	83 c4 04	 add	 esp, 4
$L311613:

; 1701 : 	g_dpDBClient.SendGuildCombatStart();

  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  000a9	89 9e 34 11 00
	00		 mov	 DWORD PTR [esi+4404], ebx
  000af	89 9e 38 11 00
	00		 mov	 DWORD PTR [esi+4408], ebx
  000b5	89 9e 3c 11 00
	00		 mov	 DWORD PTR [esi+4412], ebx
  000bb	e8 00 00 00 00	 call	 ?SendGuildCombatStart@CDPDatabaseClient@@QAEXXZ ; CDPDatabaseClient::SendGuildCombatStart

; 1702 : 	m_nGCState = NOTENTER_STATE;

  000c0	c7 86 44 11 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+4420], 100 ; 00000064H

; 1703 : 	m_nProcessGo	= 0;

  000ca	89 9e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ebx

; 1704 : 	CString strOK;

  000d0	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  000d5	8b 10		 mov	 edx, DWORD PTR [eax]
  000d7	8b c8		 mov	 ecx, eax
  000d9	ff 52 0c	 call	 DWORD PTR [edx+12]
  000dc	83 c0 10	 add	 eax, 16			; 00000010H
  000df	89 44 24 14	 mov	 DWORD PTR _strOK$[esp+52], eax
  000e3	89 5c 24 30	 mov	 DWORD PTR __$EHRec$[esp+60], ebx

; 1705 : 	CString strCancle;

  000e7	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  000ec	8b 10		 mov	 edx, DWORD PTR [eax]
  000ee	8b c8		 mov	 ecx, eax
  000f0	ff 52 0c	 call	 DWORD PTR [edx+12]
  000f3	83 c0 10	 add	 eax, 16			; 00000010H
  000f6	89 44 24 10	 mov	 DWORD PTR _strCancle$[esp+52], eax

; 1706 : 	strOK.Format( "%s", prj.GetText(TID_GAME_GUILDCOMBAT_JOIN_OK) );

  000fa	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  000ff	3d 8f 0b 00 00	 cmp	 eax, 2959		; 00000b8fH
  00104	c6 44 24 30 01	 mov	 BYTE PTR __$EHRec$[esp+60], 1
  00109	7e 1d		 jle	 SHORT $L311711
  0010b	76 0f		 jbe	 SHORT $L312075
  0010d	a1 b8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+696
  00112	8b 80 3c 2e 00
	00		 mov	 eax, DWORD PTR [eax+11836]
  00118	3b c3		 cmp	 eax, ebx
  0011a	75 07		 jne	 SHORT $L311712
$L312075:
  0011c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00121	eb 23		 jmp	 SHORT $L311706
$L311712:
  00123	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00126	eb 1e		 jmp	 SHORT $L311706
$L311711:
  00128	68 8f 0b 00 00	 push	 2959			; 00000b8fH
  0012d	50		 push	 eax
  0012e	53		 push	 ebx
  0012f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00134	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00139	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0013e	83 c4 14	 add	 esp, 20			; 00000014H
  00141	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L311706:
  00146	50		 push	 eax
  00147	8d 4c 24 18	 lea	 ecx, DWORD PTR _strOK$[esp+56]
  0014b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 1707 : 	strCancle.Format( "%s", prj.GetText(TID_GAME_GUILDCOMBAT_JOIN_CANCLE) );

  00156	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015e	3d 90 0b 00 00	 cmp	 eax, 2960		; 00000b90H
  00163	7e 1e		 jle	 SHORT $L311759
  00165	76 10		 jbe	 SHORT $L312076
  00167	8b 15 b8 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+696
  0016d	8b 82 40 2e 00
	00		 mov	 eax, DWORD PTR [edx+11840]
  00173	3b c3		 cmp	 eax, ebx
  00175	75 07		 jne	 SHORT $L311760
$L312076:
  00177	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0017c	eb 23		 jmp	 SHORT $L311754
$L311760:
  0017e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00181	eb 1e		 jmp	 SHORT $L311754
$L311759:
  00183	68 90 0b 00 00	 push	 2960			; 00000b90H
  00188	50		 push	 eax
  00189	53		 push	 ebx
  0018a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  0018f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00194	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00199	83 c4 14	 add	 esp, 20			; 00000014H
  0019c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L311754:
  001a1	50		 push	 eax
  001a2	8d 44 24 14	 lea	 eax, DWORD PTR _strCancle$[esp+56]
  001a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format
  001b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1708 : 
; 1709 : 	for( int veci = 0 ; veci < (int)( vecRequestRanking.size() ) ; ++veci )

  001b4	33 ed		 xor	 ebp, ebp
$L269084:
  001b6	8b 8e 14 11 00
	00		 mov	 ecx, DWORD PTR [esi+4372]
  001bc	3b cb		 cmp	 ecx, ebx
  001be	75 04		 jne	 SHORT $L311782
  001c0	33 c0		 xor	 eax, eax
  001c2	eb 0b		 jmp	 SHORT $L311783
$L311782:
  001c4	8b 86 18 11 00
	00		 mov	 eax, DWORD PTR [esi+4376]
  001ca	2b c1		 sub	 eax, ecx
  001cc	c1 f8 03	 sar	 eax, 3
$L311783:
  001cf	3b e8		 cmp	 ebp, eax
  001d1	0f 8d a5 00 00
	00		 jge	 $L269086
  001d7	8b 8e 14 11 00
	00		 mov	 ecx, DWORD PTR [esi+4372]

; 1710 : 	{
; 1711 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[veci];

  001dd	8b 54 e9 04	 mov	 edx, DWORD PTR [ecx+ebp*8+4]
  001e1	8d 04 e9	 lea	 eax, DWORD PTR [ecx+ebp*8]
  001e4	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1712 : 
; 1713 : 		CGuild* pGuild = g_GuildMng.GetGuild( RequestGuild.uidGuild );

  001e6	51		 push	 ecx
  001e7	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  001ec	89 54 24 24	 mov	 DWORD PTR _RequestGuild$269087[esp+60], edx
  001f0	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild
  001f5	8b f8		 mov	 edi, eax

; 1714 : 		if( pGuild )

  001f7	3b fb		 cmp	 edi, ebx
  001f9	74 7b		 je	 SHORT $L269085

; 1715 : 		{
; 1716 : 			for( map<u_long, CGuildMember*>::iterator Guildi = pGuild->m_mapPMember.begin();	// neuz

  001fb	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  001fe	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1717 : 			Guildi != pGuild->m_mapPMember.end(); ++Guildi )

  00200	3b c1		 cmp	 eax, ecx
  00202	89 44 24 18	 mov	 DWORD PTR _Guildi$269095[esp+52], eax
  00206	74 6e		 je	 SHORT $L269085
$L311876:

; 1718 : 			{
; 1719 : 				CGuildMember* pGuildMember = Guildi->second;

  00208	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1720 : 				if( pGuildMember->m_nMemberLv == GUD_MASTER || pGuildMember->m_nMemberLv == GUD_KINGPIN )

  0020b	8a 48 48	 mov	 cl, BYTE PTR [eax+72]
  0020e	3a cb		 cmp	 cl, bl
  00210	74 05		 je	 SHORT $L269103
  00212	80 f9 01	 cmp	 cl, 1
  00215	75 4d		 jne	 SHORT $L269099
$L269103:

; 1721 : 				{
; 1722 : 					CUser* pUser	= (CUser*)prj.GetUserByID( pGuildMember->m_idPlayer );

  00217	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021a	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T311998[esp+52]
  0021e	51		 push	 ecx
  0021f	8d 54 24 28	 lea	 edx, DWORD PTR _i$311976[esp+56]
  00223	52		 push	 edx
  00224	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00229	89 44 24 24	 mov	 DWORD PTR $T311998[esp+60], eax
  0022d	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  00232	8b 44 24 24	 mov	 eax, DWORD PTR _i$311976[esp+52]
  00236	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  0023c	74 26		 je	 SHORT $L269099
  0023e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 1723 : 					if( IsValidObj( pUser ) )

  00241	3b cb		 cmp	 ecx, ebx
  00243	74 1f		 je	 SHORT $L269099
  00245	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  00249	75 19		 jne	 SHORT $L269099

; 1724 : 					{
; 1725 : 						if( veci < m_nMaxGuild )

  0024b	3b ae a0 10 00
	00		 cmp	 ebp, DWORD PTR [esi+4256]
  00251	7d 07		 jge	 SHORT $L269107

; 1726 : 							pUser->AddGCDiagMessage( strOK );

  00253	8b 44 24 14	 mov	 eax, DWORD PTR _strOK$[esp+52]
  00257	50		 push	 eax

; 1727 : 						else

  00258	eb 05		 jmp	 SHORT $L312079
$L269107:

; 1728 : 							pUser->AddGCDiagMessage( strCancle );

  0025a	8b 54 24 10	 mov	 edx, DWORD PTR _strCancle$[esp+52]
  0025e	52		 push	 edx
$L312079:
  0025f	e8 00 00 00 00	 call	 ?AddGCDiagMessage@CUser@@QAEXPBD@Z ; CUser::AddGCDiagMessage
$L269099:

; 1717 : 			Guildi != pGuild->m_mapPMember.end(); ++Guildi )

  00264	8d 4c 24 18	 lea	 ecx, DWORD PTR _Guildi$269095[esp+52]
  00268	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CGuildMember *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CGuildMember *> >,0> >::const_iterator::_Inc
  0026d	8b 44 24 18	 mov	 eax, DWORD PTR _Guildi$269095[esp+52]
  00271	3b 47 3c	 cmp	 eax, DWORD PTR [edi+60]
  00274	75 92		 jne	 SHORT $L311876
$L269085:

; 1708 : 
; 1709 : 	for( int veci = 0 ; veci < (int)( vecRequestRanking.size() ) ; ++veci )

  00276	45		 inc	 ebp
  00277	e9 3a ff ff ff	 jmp	 $L269084
$L269086:

; 1729 : 					}
; 1730 : 				}
; 1731 : 			}
; 1732 : 		}
; 1733 : 	}
; 1734 : }

  0027c	8b 44 24 10	 mov	 eax, DWORD PTR _strCancle$[esp+52]
  00280	83 c0 f0	 add	 eax, -16		; fffffff0H
  00283	88 5c 24 30	 mov	 BYTE PTR __$EHRec$[esp+60], bl
  00287	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0028a	83 ca ff	 or	 edx, -1
  0028d	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00291	4a		 dec	 edx
  00292	85 d2		 test	 edx, edx
  00294	5f		 pop	 edi
  00295	5d		 pop	 ebp
  00296	5b		 pop	 ebx
  00297	7f 08		 jg	 SHORT $L312041
  00299	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0029d	50		 push	 eax
  0029e	ff 52 04	 call	 DWORD PTR [edx+4]
$L312041:
  002a1	8b 44 24 08	 mov	 eax, DWORD PTR _strOK$[esp+40]
  002a5	83 c0 f0	 add	 eax, -16		; fffffff0H
  002a8	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  002b0	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  002b3	83 ca ff	 or	 edx, -1
  002b6	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  002ba	4a		 dec	 edx
  002bb	85 d2		 test	 edx, edx
  002bd	7f 08		 jg	 SHORT $L312068
  002bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c3	50		 push	 eax
  002c4	ff 52 04	 call	 DWORD PTR [edx+4]
$L312068:
  002c7	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  002cb	5e		 pop	 esi
  002cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002d3	83 c4 24	 add	 esp, 36			; 00000024H
  002d6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L311552:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _strOK$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L311553:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR _strCancle$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?GuildCombatOpen@CGuildCombat@@QAEXXZ:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T312072
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GuildCombatOpen@CGuildCombat@@QAEXXZ ENDP		; CGuildCombat::GuildCombatOpen
PUBLIC	?SetRequestRanking@CGuildCombat@@QAEXXZ		; CGuildCombat::SetRequestRanking
; Function compile flags: /Ogty
;	COMDAT ?SetRequestRanking@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
__Cat$312643 = -20					; size = 1
_gcmi$269113 = -20					; size = 4
_RequstGuild$269120 = -16				; size = 8
$T312091 = -8						; size = 8
$T312088 = -8						; size = 8
$T312087 = -8						; size = 8
?SetRequestRanking@CGuildCombat@@QAEXXZ PROC NEAR	; CGuildCombat::SetRequestRanking, COMDAT
; _this$ = ecx

; 1736 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b d9		 mov	 ebx, ecx

; 1737 : 	vecRequestRanking.clear();

  0000d	8b 83 14 11 00
	00		 mov	 eax, DWORD PTR [ebx+4372]
  00013	85 c0		 test	 eax, eax
  00015	8d b3 10 11 00
	00		 lea	 esi, DWORD PTR [ebx+4368]
  0001b	57		 push	 edi
  0001c	74 09		 je	 SHORT $L312110
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
$L312110:
  00027	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0002e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1738 : #ifdef __S_BUG_GC
; 1739 : 	for( int gcmi = 0 ; gcmi < (int)( m_vecGuildCombatMem.size() ) ; ++gcmi )

  0003c	33 d2		 xor	 edx, edx
$L312700:
  0003e	8b 4b 74	 mov	 ecx, DWORD PTR [ebx+116]
  00041	85 c9		 test	 ecx, ecx
  00043	89 54 24 0c	 mov	 DWORD PTR _gcmi$269113[esp+32], edx
  00047	75 04		 jne	 SHORT $L312118
  00049	33 c0		 xor	 eax, eax
  0004b	eb 08		 jmp	 SHORT $L312119
$L312118:
  0004d	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  00050	2b c1		 sub	 eax, ecx
  00052	c1 f8 02	 sar	 eax, 2
$L312119:
  00055	3b d0		 cmp	 edx, eax
  00057	0f 8d 26 01 00
	00		 jge	 $L269117
  0005d	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  00060	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1740 : 	{
; 1741 : 		__GuildCombatMember* pGCMember = m_vecGuildCombatMem[gcmi];

  00063	8b 00		 mov	 eax, DWORD PTR [eax]

; 1742 : 
; 1743 : 		if( pGCMember->bRequest == FALSE )

  00065	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00068	85 c9		 test	 ecx, ecx
  0006a	0f 84 09 01 00
	00		 je	 $L269116

; 1744 : 			continue;
; 1745 : 		
; 1746 : 		__REQUESTGUILD RequstGuild;
; 1747 : 		RequstGuild.dwPenya = pGCMember->dwPenya;
; 1748 : 		RequstGuild.uidGuild = pGCMember->uGuildId;

  00070	8b 10		 mov	 edx, DWORD PTR [eax]
  00072	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00075	89 54 24 10	 mov	 DWORD PTR _RequstGuild$269120[esp+32], edx

; 1749 : 		if( 0 == vecRequestRanking.size() )

  00079	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0007c	85 d2		 test	 edx, edx
  0007e	89 4c 24 14	 mov	 DWORD PTR _RequstGuild$269120[esp+36], ecx
  00082	74 0c		 je	 SHORT $L312696
  00084	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00087	2b c2		 sub	 eax, edx
  00089	c1 f8 03	 sar	 eax, 3
  0008c	85 c0		 test	 eax, eax
  0008e	75 13		 jne	 SHORT $L269121
$L312696:

; 1750 : 		{
; 1751 : 			vecRequestRanking.push_back( RequstGuild );

  00090	8d 44 24 10	 lea	 eax, DWORD PTR _RequstGuild$269120[esp+32]
  00094	50		 push	 eax
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?push_back@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::push_back
  0009c	8b 54 24 0c	 mov	 edx, DWORD PTR _gcmi$269113[esp+32]
  000a0	42		 inc	 edx
  000a1	eb 9b		 jmp	 SHORT $L312700
$L269121:

; 1752 : 		}
; 1753 : 		else
; 1754 : 		{
; 1755 : 			BOOL bInsert = FALSE;
; 1756 : 			for( vector<__REQUESTGUILD>::iterator  itv = vecRequestRanking.begin() ; itv != vecRequestRanking.end() ; ++itv )

  000a3	8b 83 14 11 00
	00		 mov	 eax, DWORD PTR [ebx+4372]
  000a9	8b 93 18 11 00
	00		 mov	 edx, DWORD PTR [ebx+4376]
  000af	3b c2		 cmp	 eax, edx
  000b1	74 23		 je	 SHORT $L312697
$L312201:

; 1757 : 			{
; 1758 : 				if( ((__REQUESTGUILD)*itv).dwPenya  == pGCMember->dwPenya )

  000b3	8b 38		 mov	 edi, DWORD PTR [eax]
  000b5	89 7c 24 18	 mov	 DWORD PTR $T312087[esp+32], edi
  000b9	39 48 04	 cmp	 DWORD PTR [eax+4], ecx

; 1779 : 					}
; 1780 : 					bInsert = TRUE;
; 1781 : 					break;
; 1782 : 				}
; 1783 : 				else
; 1784 : 				if( ((__REQUESTGUILD)*itv).dwPenya  < pGCMember->dwPenya )

  000bc	8b 38		 mov	 edi, DWORD PTR [eax]
  000be	89 7c 24 18	 mov	 DWORD PTR $T312091[esp+32], edi
  000c2	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000c5	74 1a		 je	 SHORT $L312690
  000c7	3b f9		 cmp	 edi, ecx
  000c9	0f 82 9b 00 00
	00		 jb	 $L312691
  000cf	83 c0 08	 add	 eax, 8
  000d2	3b c2		 cmp	 eax, edx
  000d4	75 dd		 jne	 SHORT $L312201
$L312697:

; 1785 : 				{
; 1786 : 					vecRequestRanking.insert( itv, RequstGuild );
; 1787 : 					bInsert = TRUE;
; 1788 : 					break;
; 1789 : 				}				
; 1790 : 			}
; 1791 : 			if( bInsert == FALSE )
; 1792 : 			{
; 1793 : 				vecRequestRanking.push_back( RequstGuild );

  000d6	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000d9	85 d2		 test	 edx, edx
  000db	75 49		 jne	 SHORT $L312629
  000dd	33 c9		 xor	 ecx, ecx
  000df	eb 4d		 jmp	 SHORT $L312630
$L312690:

; 1759 : 				{
; 1760 : 					BOOL bSamPenya = FALSE;
; 1761 : 					while( ((__REQUESTGUILD)*itv).dwPenya == pGCMember->dwPenya )

  000e1	3b f9		 cmp	 edi, ecx
  000e3	75 12		 jne	 SHORT $L269258
$L269252:

; 1762 : 					{
; 1763 : 						++itv;

  000e5	83 c0 08	 add	 eax, 8

; 1764 : 						if( itv == vecRequestRanking.end() )

  000e8	3b c2		 cmp	 eax, edx
  000ea	74 24		 je	 SHORT $L312692
  000ec	8b 38		 mov	 edi, DWORD PTR [eax]
  000ee	89 7c 24 18	 mov	 DWORD PTR $T312088[esp+32], edi
  000f2	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  000f5	74 ee		 je	 SHORT $L269252
$L269258:

; 1775 : 					}
; 1776 : 					else
; 1777 : 					{
; 1778 : 						vecRequestRanking.insert( itv, RequstGuild );

  000f7	8d 54 24 10	 lea	 edx, DWORD PTR _RequstGuild$269120[esp+32]
  000fb	52		 push	 edx

; 1785 : 				{
; 1786 : 					vecRequestRanking.insert( itv, RequstGuild );
; 1787 : 					bInsert = TRUE;
; 1788 : 					break;
; 1789 : 				}				
; 1790 : 			}
; 1791 : 			if( bInsert == FALSE )
; 1792 : 			{
; 1793 : 				vecRequestRanking.push_back( RequstGuild );

  000fc	6a 01		 push	 1
  000fe	8b ce		 mov	 ecx, esi
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Insert_n
  00106	8b 54 24 0c	 mov	 edx, DWORD PTR _gcmi$269113[esp+32]
  0010a	42		 inc	 edx
  0010b	e9 2e ff ff ff	 jmp	 $L312700
$L312692:

; 1765 : 						{
; 1766 : 							bSamPenya = TRUE; 
; 1767 : 							--itv;
; 1768 : 							break;
; 1769 : 						}							
; 1770 : 					}
; 1771 : 					
; 1772 : 					if( bSamPenya )
; 1773 : 					{
; 1774 : 						vecRequestRanking.push_back( RequstGuild );

  00110	8d 4c 24 10	 lea	 ecx, DWORD PTR _RequstGuild$269120[esp+32]
  00114	51		 push	 ecx
  00115	8b ce		 mov	 ecx, esi
  00117	e8 00 00 00 00	 call	 ?push_back@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@QAEXABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::push_back
  0011c	8b 54 24 0c	 mov	 edx, DWORD PTR _gcmi$269113[esp+32]
  00120	42		 inc	 edx
  00121	e9 18 ff ff ff	 jmp	 $L312700

; 1785 : 				{
; 1786 : 					vecRequestRanking.insert( itv, RequstGuild );
; 1787 : 					bInsert = TRUE;
; 1788 : 					break;
; 1789 : 				}				
; 1790 : 			}
; 1791 : 			if( bInsert == FALSE )
; 1792 : 			{
; 1793 : 				vecRequestRanking.push_back( RequstGuild );

$L312629:
  00126	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00129	2b ca		 sub	 ecx, edx
  0012b	c1 f9 03	 sar	 ecx, 3
$L312630:
  0012e	85 d2		 test	 edx, edx
  00130	74 35		 je	 SHORT $L312637
  00132	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00135	2b c2		 sub	 eax, edx
  00137	c1 f8 03	 sar	 eax, 3
  0013a	3b c8		 cmp	 ecx, eax
  0013c	73 29		 jae	 SHORT $L312637
  0013e	8b 54 24 0c	 mov	 edx, DWORD PTR __Cat$312643[esp+32]
  00142	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00145	52		 push	 edx
  00146	56		 push	 esi
  00147	8d 44 24 18	 lea	 eax, DWORD PTR _RequstGuild$269120[esp+40]
  0014b	50		 push	 eax
  0014c	6a 01		 push	 1
  0014e	57		 push	 edi
  0014f	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAU__REQUESTGUILD@CGuildCombat@@IU12@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@YAXPAU__REQUESTGUILD@CGuildCombat@@IABU12@AAV?$allocator@U__REQUESTGUILD@CGuildCombat@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CGuildCombat::__REQUESTGUILD *,unsigned int,CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >
  00154	8b 54 24 20	 mov	 edx, DWORD PTR _gcmi$269113[esp+52]
  00158	83 c7 08	 add	 edi, 8
  0015b	83 c4 14	 add	 esp, 20			; 00000014H
  0015e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00161	42		 inc	 edx
  00162	e9 d7 fe ff ff	 jmp	 $L312700
$L312637:
  00167	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$L312691:
  0016a	8d 4c 24 10	 lea	 ecx, DWORD PTR _RequstGuild$269120[esp+32]
  0016e	51		 push	 ecx
  0016f	6a 01		 push	 1
  00171	8b ce		 mov	 ecx, esi
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@U__REQUESTGUILD@CGuildCombat@@V?$allocator@U__REQUESTGUILD@CGuildCombat@@@std@@@std@@IAEXViterator@12@IABU__REQUESTGUILD@CGuildCombat@@@Z ; std::vector<CGuildCombat::__REQUESTGUILD,std::allocator<CGuildCombat::__REQUESTGUILD> >::_Insert_n
$L269116:
  00179	8b 54 24 0c	 mov	 edx, DWORD PTR _gcmi$269113[esp+32]
  0017d	42		 inc	 edx
  0017e	e9 bb fe ff ff	 jmp	 $L312700
$L269117:

; 1794 : 			}
; 1795 : 		}
; 1796 : 	}
; 1797 : #else // __S_BUG_GC
; 1798 : 	for( map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.begin() ; ita != m_GuildCombatMem.end() ; ++ita )
; 1799 : 	{
; 1800 : 		__GuildCombatMember* pGCMember = ita->second;
; 1801 : 
; 1802 : 		if( pGCMember->bRequest == FALSE )
; 1803 : 			continue;
; 1804 : 		
; 1805 : 		__REQUESTGUILD RequstGuild;
; 1806 : 		RequstGuild.dwPenya = pGCMember->dwPenya;
; 1807 : 		RequstGuild.uidGuild = ita->first;
; 1808 : 		if( 0 == vecRequestRanking.size() )
; 1809 : 		{
; 1810 : 			vecRequestRanking.push_back( RequstGuild );
; 1811 : 		}
; 1812 : 		else
; 1813 : 		{
; 1814 : 			BOOL bInsert = FALSE;
; 1815 : 			for( vector<__REQUESTGUILD>::iterator  itv = vecRequestRanking.begin() ; itv != vecRequestRanking.end() ; ++itv )
; 1816 : 			{
; 1817 : 				if( ((__REQUESTGUILD)*itv).dwPenya  == pGCMember->dwPenya )
; 1818 : 				{
; 1819 : 					BOOL bSamPenya = FALSE;
; 1820 : 					while( ((__REQUESTGUILD)*itv).dwPenya == pGCMember->dwPenya )
; 1821 : 					{
; 1822 : 						++itv;
; 1823 : 						if( itv == vecRequestRanking.end() )
; 1824 : 						{
; 1825 : 							bSamPenya = TRUE; 
; 1826 : 							--itv;
; 1827 : 							break;
; 1828 : 						}							
; 1829 : 					}
; 1830 : 					
; 1831 : 					if( bSamPenya )
; 1832 : 					{
; 1833 : 						vecRequestRanking.push_back( RequstGuild );
; 1834 : 					}
; 1835 : 					else
; 1836 : 					{
; 1837 : 						vecRequestRanking.insert( itv, RequstGuild );
; 1838 : 					}
; 1839 : 					bInsert = TRUE;
; 1840 : 					break;
; 1841 : 				}
; 1842 : 				else
; 1843 : 				if( ((__REQUESTGUILD)*itv).dwPenya  < pGCMember->dwPenya )
; 1844 : 				{
; 1845 : 					vecRequestRanking.insert( itv, RequstGuild );
; 1846 : 					bInsert = TRUE;
; 1847 : 					break;
; 1848 : 				}				
; 1849 : 			}
; 1850 : 			if( bInsert == FALSE )
; 1851 : 			{
; 1852 : 				vecRequestRanking.push_back( RequstGuild );
; 1853 : 			}
; 1854 : 		}
; 1855 : 	}
; 1856 : #endif // __S_BUG_GC
; 1857 : }

  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c3		 ret	 0
?SetRequestRanking@CGuildCombat@@QAEXXZ ENDP		; CGuildCombat::SetRequestRanking
_TEXT	ENDS
PUBLIC	?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z	; CGuildCombat::GetBestPlayer
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T313784 DD	0ffffffffH
	DD	FLAT:$L312712
$T313757 DD	019930520H
	DD	01H
	DD	FLAT:$T313784
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z
_TEXT	SEGMENT
_uBestPlayer$ = -88					; size = 4
_i$313558 = -84						; size = 4
_veci$269304 = -84					; size = 4
_nMinLevel$ = -80					; size = 4
_nVeci$269295 = -80					; size = 4
$T313560 = -76						; size = 4
_bResult$ = -76						; size = 4
_nVeci$269378 = -72					; size = 4
_nMaxPoint$ = -72					; size = 4
_veci$269387 = -68					; size = 4
_RequestGuild$269384 = -68				; size = 8
_pGCMember$269302 = -68					; size = 4
_this$ = -60						; size = 4
$T313730 = -56						; size = 4
$T312709 = -56						; size = 4
$T312708 = -56						; size = 8
$T312705 = -56						; size = 8
_RequestGuild$269301 = -56				; size = 8
_nMinExp$ = -48						; size = 8
$T312706 = -48						; size = 8
tv699 = -40						; size = 8
$T312703 = -40						; size = 8
_mapSame$ = -28						; size = 12
__$EHRec$ = -12						; size = 12
_dwGetGuildId$ = 8					; size = 4
_nGetPoint$ = 12					; size = 4
?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z PROC NEAR	; CGuildCombat::GetBestPlayer, COMDAT
; _this$ = ecx

; 1891 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	83 ec 50	 sub	 esp, 80			; 00000050H
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b f1		 mov	 esi, ecx

; 1892 : 	u_long uBestPlayer = 0;

  00022	33 db		 xor	 ebx, ebx
  00024	57		 push	 edi

; 1893 : 	map<u_long, int> mapSame;	//     playerId

  00025	8d 4c 24 4c	 lea	 ecx, DWORD PTR _mapSame$[esp+104]
  00029	89 74 24 2c	 mov	 DWORD PTR _this$[esp+104], esi
  0002d	89 5c 24 10	 mov	 DWORD PTR _uBestPlayer$[esp+104], ebx
  00031	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Buynode
  00036	89 44 24 50	 mov	 DWORD PTR _mapSame$[esp+108], eax
  0003a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  0003e	8b 44 24 50	 mov	 eax, DWORD PTR _mapSame$[esp+108]
  00042	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00045	8b 44 24 50	 mov	 eax, DWORD PTR _mapSame$[esp+108]
  00049	89 00		 mov	 DWORD PTR [eax], eax
  0004b	8b 44 24 50	 mov	 eax, DWORD PTR _mapSame$[esp+108]
  0004f	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00052	89 5c 24 54	 mov	 DWORD PTR _mapSame$[esp+112], ebx
  00056	89 5c 24 64	 mov	 DWORD PTR __$EHRec$[esp+112], ebx

; 1894 : 	//  
; 1895 : 	BOOL bResult = FALSE;

  0005a	89 5c 24 1c	 mov	 DWORD PTR _bResult$[esp+104], ebx

; 1896 : 	int nMaxPoint = -1;

  0005e	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR _nMaxPoint$[esp+104], -1

; 1897 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00066	33 ff		 xor	 edi, edi
$L313779:
  00068	8b 8e 14 11 00
	00		 mov	 ecx, DWORD PTR [esi+4372]
  0006e	3b cb		 cmp	 ecx, ebx
  00070	89 7c 24 18	 mov	 DWORD PTR _nVeci$269295[esp+104], edi
  00074	75 04		 jne	 SHORT $L312931
  00076	33 c0		 xor	 eax, eax
  00078	eb 0b		 jmp	 SHORT $L312932
$L312931:
  0007a	8b 86 18 11 00
	00		 mov	 eax, DWORD PTR [esi+4376]
  00080	2b c1		 sub	 eax, ecx
  00082	c1 f8 03	 sar	 eax, 3
$L312932:
  00085	3b f8		 cmp	 edi, eax
  00087	0f 8d 55 01 00
	00		 jge	 $L313764

; 1898 : 	{
; 1899 : 		if( nVeci >= m_nMaxGuild )

  0008d	3b be a0 10 00
	00		 cmp	 edi, DWORD PTR [esi+4256]
  00093	0f 8d 49 01 00
	00		 jge	 $L313764
  00099	8b 86 14 11 00
	00		 mov	 eax, DWORD PTR [esi+4372]

; 1900 : 			break;
; 1901 : 		
; 1902 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  0009f	8b 0c f8	 mov	 ecx, DWORD PTR [eax+edi*8]
  000a2	8b 54 f8 04	 mov	 edx, DWORD PTR [eax+edi*8+4]
  000a6	8d 04 f8	 lea	 eax, DWORD PTR [eax+edi*8]

; 1903 : #ifdef __S_BUG_GC
; 1904 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  000a9	51		 push	 ecx
  000aa	8b ce		 mov	 ecx, esi
  000ac	89 54 24 38	 mov	 DWORD PTR _RequestGuild$269301[esp+112], edx
  000b0	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 1905 : 		if( pGCMember != NULL )

  000b5	3b c3		 cmp	 eax, ebx
  000b7	89 44 24 24	 mov	 DWORD PTR _pGCMember$269302[esp+104], eax
  000bb	0f 84 1b 01 00
	00		 je	 $L269298

; 1906 : 		{
; 1907 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  000c1	89 5c 24 14	 mov	 DWORD PTR _veci$269304[esp+104], ebx
$L269306:
  000c5	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c8	85 d2		 test	 edx, edx
  000ca	75 04		 jne	 SHORT $L312994
  000cc	33 c9		 xor	 ecx, ecx
  000ce	eb 08		 jmp	 SHORT $L312995
$L312994:
  000d0	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d3	2b ca		 sub	 ecx, edx
  000d5	c1 f9 02	 sar	 ecx, 2
$L312995:
  000d8	3b d9		 cmp	 ebx, ecx
  000da	0f 8d fa 00 00
	00		 jge	 $L313774
  000e0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1908 : 			{
; 1909 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 1910 : 				if( nMaxPoint < pJoinPlayer->nPoint )

  000e3	8b 54 24 20	 mov	 edx, DWORD PTR _nMaxPoint$[esp+104]
  000e7	8d 0c 99	 lea	 ecx, DWORD PTR [ecx+ebx*4]
  000ea	8b 19		 mov	 ebx, DWORD PTR [ecx]
  000ec	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000ef	3b d1		 cmp	 edx, ecx
  000f1	0f 8d a8 00 00
	00		 jge	 $L313777

; 1911 : 				{
; 1912 : 					nMaxPoint = pJoinPlayer->nPoint;
; 1913 : 					uBestPlayer = pJoinPlayer->uidPlayer;

  000f7	8b 13		 mov	 edx, DWORD PTR [ebx]
  000f9	89 54 24 10	 mov	 DWORD PTR _uBestPlayer$[esp+104], edx

; 1914 : 					*nGetPoint = pJoinPlayer->nPoint;

  000fd	8b 55 0c	 mov	 edx, DWORD PTR _nGetPoint$[ebp]
  00100	89 0a		 mov	 DWORD PTR [edx], ecx

; 1915 : 					*dwGetGuildId = pGCMember->uGuildId;

  00102	8b 00		 mov	 eax, DWORD PTR [eax]
  00104	89 4c 24 20	 mov	 DWORD PTR _nMaxPoint$[esp+104], ecx
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _dwGetGuildId$[ebp]
  0010b	89 01		 mov	 DWORD PTR [ecx], eax

; 1916 : 					bResult = TRUE;
; 1917 : 					mapSame.clear();

  0010d	8b 44 24 50	 mov	 eax, DWORD PTR _mapSame$[esp+108]
  00111	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00114	8a 4e 15	 mov	 cl, BYTE PTR [esi+21]
  00117	84 c9		 test	 cl, cl
  00119	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bResult$[esp+104], 1
  00121	8b fe		 mov	 edi, esi
  00123	75 25		 jne	 SHORT $L313123
$L313121:
  00125	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00128	52		 push	 edx
  00129	8d 4c 24 50	 lea	 ecx, DWORD PTR _mapSame$[esp+108]
  0012d	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Erase
  00132	8b 3f		 mov	 edi, DWORD PTR [edi]
  00134	56		 push	 esi
  00135	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0013a	8a 47 15	 mov	 al, BYTE PTR [edi+21]
  0013d	83 c4 04	 add	 esp, 4
  00140	84 c0		 test	 al, al
  00142	8b f7		 mov	 esi, edi
  00144	74 df		 je	 SHORT $L313121
  00146	8b 44 24 50	 mov	 eax, DWORD PTR _mapSame$[esp+108]
$L313123:

; 1918 : 					mapSame.insert( make_pair( pJoinPlayer->uidPlayer, nVeci ) );

  0014a	8b 4c 24 18	 mov	 ecx, DWORD PTR _nVeci$269295[esp+104]
  0014e	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00151	8b 44 24 50	 mov	 eax, DWORD PTR _mapSame$[esp+108]
  00155	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR _mapSame$[esp+112], 0
  0015d	89 00		 mov	 DWORD PTR [eax], eax
  0015f	8b 44 24 50	 mov	 eax, DWORD PTR _mapSame$[esp+108]
  00163	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00166	8b 03		 mov	 eax, DWORD PTR [ebx]
  00168	8d 54 24 40	 lea	 edx, DWORD PTR $T312703[esp+104]
  0016c	89 44 24 40	 mov	 DWORD PTR $T312703[esp+104], eax
  00170	52		 push	 edx
  00171	8d 44 24 34	 lea	 eax, DWORD PTR $T312705[esp+108]
  00175	89 4c 24 48	 mov	 DWORD PTR $T312703[esp+112], ecx
  00179	50		 push	 eax
  0017a	8d 4c 24 54	 lea	 ecx, DWORD PTR _mapSame$[esp+112]
  0017e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::insert
  00183	8b 4c 24 14	 mov	 ecx, DWORD PTR _veci$269304[esp+104]

; 1919 : 				}
; 1920 : 				else if( nMaxPoint == pJoinPlayer->nPoint )

  00187	8b 7c 24 18	 mov	 edi, DWORD PTR _nVeci$269295[esp+104]
  0018b	8b 74 24 2c	 mov	 esi, DWORD PTR _this$[esp+104]

; 1921 : 				{
; 1922 : 					bResult = FALSE;
; 1923 : 					mapSame.insert( make_pair( pJoinPlayer->uidPlayer, nVeci ) );

  0018f	8b 44 24 24	 mov	 eax, DWORD PTR _pGCMember$269302[esp+104]
  00193	41		 inc	 ecx
  00194	89 4c 24 14	 mov	 DWORD PTR _veci$269304[esp+104], ecx
  00198	8b d9		 mov	 ebx, ecx
  0019a	e9 26 ff ff ff	 jmp	 $L269306
$L313777:

; 1919 : 				}
; 1920 : 				else if( nMaxPoint == pJoinPlayer->nPoint )

  0019f	75 29		 jne	 SHORT $L269307

; 1921 : 				{
; 1922 : 					bResult = FALSE;
; 1923 : 					mapSame.insert( make_pair( pJoinPlayer->uidPlayer, nVeci ) );

  001a1	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001a3	8d 54 24 38	 lea	 edx, DWORD PTR $T312706[esp+104]
  001a7	52		 push	 edx
  001a8	8d 44 24 34	 lea	 eax, DWORD PTR $T312708[esp+108]
  001ac	89 4c 24 3c	 mov	 DWORD PTR $T312706[esp+108], ecx
  001b0	50		 push	 eax
  001b1	8d 4c 24 54	 lea	 ecx, DWORD PTR _mapSame$[esp+112]
  001b5	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _bResult$[esp+112], 0
  001bd	89 7c 24 44	 mov	 DWORD PTR $T312706[esp+116], edi
  001c1	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKH@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::insert
  001c6	8b 44 24 24	 mov	 eax, DWORD PTR _pGCMember$269302[esp+104]
$L269307:
  001ca	8b 4c 24 14	 mov	 ecx, DWORD PTR _veci$269304[esp+104]
  001ce	41		 inc	 ecx
  001cf	89 4c 24 14	 mov	 DWORD PTR _veci$269304[esp+104], ecx
  001d3	8b d9		 mov	 ebx, ecx
  001d5	e9 eb fe ff ff	 jmp	 $L269306
$L313774:

; 1906 : 		{
; 1907 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  001da	33 db		 xor	 ebx, ebx
$L269298:

; 1897 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  001dc	47		 inc	 edi
  001dd	e9 86 fe ff ff	 jmp	 $L313779
$L313764:

; 1924 : 				}
; 1925 : 			}
; 1926 : 		}
; 1927 : #else // __S_BUG_GC
; 1928 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 1929 : 		if( ita != m_GuildCombatMem.end() )
; 1930 : 		{
; 1931 : 			__GuildCombatMember* pGCMember = ita->second;
; 1932 : 			for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 1933 : 			{
; 1934 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 1935 : 				if( nMaxPoint < pJoinPlayer->nPoint )
; 1936 : 				{
; 1937 : 					nMaxPoint = pJoinPlayer->nPoint;
; 1938 : 					uBestPlayer = pJoinPlayer->uidPlayer;
; 1939 : 					*nGetPoint = pJoinPlayer->nPoint;
; 1940 : 					*dwGetGuildId = ita->first;
; 1941 : 					bResult = TRUE;
; 1942 : 				}
; 1943 : 				else if( nMaxPoint == pJoinPlayer->nPoint )
; 1944 : 				{
; 1945 : 					bResult = FALSE;
; 1946 : 				}
; 1947 : 			}
; 1948 : 		}
; 1949 : #endif // __S_BUG_GC
; 1950 : 	}
; 1951 : 
; 1952 : 	//  &  
; 1953 : #ifdef __S_BUG_GC	//     chipi 080218
; 1954 : 	int nMinLevel = 0x7fffffff;

  001e2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  001e7	89 44 24 18	 mov	 DWORD PTR _nMinLevel$[esp+104], eax

; 1955 : 	EXPINTEGER nMinExp = (EXPINTEGER)0x7fffffffffffffff;

  001eb	89 44 24 3c	 mov	 DWORD PTR _nMinExp$[esp+108], eax

; 1956 : #else // __S_BUG_GC
; 1957 : 	int nMaxLevel = -1;
; 1958 : 	int nMaxExp = -1;
; 1959 : #endif // __S_BUG_GC
; 1960 : 
; 1961 : 	if( bResult == FALSE )

  001ef	39 5c 24 1c	 cmp	 DWORD PTR _bResult$[esp+104], ebx
  001f3	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR _nMinExp$[esp+104], -1
  001fb	0f 85 c5 01 00
	00		 jne	 $L313766
$L313783:

; 1962 : 	{
; 1963 : 		for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00201	8b 8e 14 11 00
	00		 mov	 ecx, DWORD PTR [esi+4372]
  00207	85 c9		 test	 ecx, ecx
  00209	89 5c 24 20	 mov	 DWORD PTR _nVeci$269378[esp+104], ebx
  0020d	75 04		 jne	 SHORT $L313177
  0020f	33 c0		 xor	 eax, eax
  00211	eb 0b		 jmp	 SHORT $L313178
$L313177:
  00213	8b 86 18 11 00
	00		 mov	 eax, DWORD PTR [esi+4376]
  00219	2b c1		 sub	 eax, ecx
  0021b	c1 f8 03	 sar	 eax, 3
$L313178:
  0021e	3b d8		 cmp	 ebx, eax
  00220	0f 8d a0 01 00
	00		 jge	 $L313766

; 1964 : 		{
; 1965 : 			if( nVeci >= m_nMaxGuild )

  00226	3b 9e a0 10 00
	00		 cmp	 ebx, DWORD PTR [esi+4256]
  0022c	0f 8d 94 01 00
	00		 jge	 $L313766
  00232	8b 8e 14 11 00
	00		 mov	 ecx, DWORD PTR [esi+4372]

; 1966 : 				break;
; 1967 : 
; 1968 : 			__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  00238	8b 54 d9 04	 mov	 edx, DWORD PTR [ecx+ebx*8+4]
  0023c	8b 3c d9	 mov	 edi, DWORD PTR [ecx+ebx*8]
  0023f	8d 04 d9	 lea	 eax, DWORD PTR [ecx+ebx*8]
  00242	89 54 24 28	 mov	 DWORD PTR _RequestGuild$269384[esp+108], edx
  00246	8b 56 74	 mov	 edx, DWORD PTR [esi+116]

; 1969 : #ifdef __S_BUG_GC
; 1970 : 			__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  00249	33 c9		 xor	 ecx, ecx
  0024b	eb 03 8d 49 00	 npad	 5
$L313367:
  00250	85 d2		 test	 edx, edx
  00252	75 04		 jne	 SHORT $L313374
  00254	33 c0		 xor	 eax, eax
  00256	eb 08		 jmp	 SHORT $L313375
$L313374:
  00258	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0025b	2b c2		 sub	 eax, edx
  0025d	c1 f8 02	 sar	 eax, 2
$L313375:
  00260	3b c8		 cmp	 ecx, eax
  00262	0f 8d 58 01 00
	00		 jge	 $L269381
  00268	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0026b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0026e	8b 00		 mov	 eax, DWORD PTR [eax]
  00270	3b 38		 cmp	 edi, DWORD PTR [eax]
  00272	74 03		 je	 SHORT $L313765
  00274	41		 inc	 ecx
  00275	eb d9		 jmp	 SHORT $L313367
$L313765:
  00277	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  0027a	8b 3c 8a	 mov	 edi, DWORD PTR [edx+ecx*4]

; 1971 : 			if( pGCMember != NULL )

  0027d	85 ff		 test	 edi, edi
  0027f	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00282	0f 84 38 01 00
	00		 je	 $L269381

; 1972 : 			{
; 1973 : 				for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00288	33 d2		 xor	 edx, edx
$L313782:
  0028a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0028d	85 c9		 test	 ecx, ecx
  0028f	89 54 24 24	 mov	 DWORD PTR _veci$269387[esp+104], edx
  00293	75 04		 jne	 SHORT $L313408
  00295	33 c0		 xor	 eax, eax
  00297	eb 08		 jmp	 SHORT $L313409
$L313408:
  00299	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0029c	2b c1		 sub	 eax, ecx
  0029e	c1 f8 02	 sar	 eax, 2
$L313409:
  002a1	3b d0		 cmp	 edx, eax
  002a3	0f 8d 17 01 00
	00		 jge	 $L269381
  002a9	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1974 : 				{
; 1975 : 					__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  002ac	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]

; 1976 : 					//      continue
; 1977 : 					if( !pJoinPlayer || mapSame.find( pJoinPlayer->uidPlayer ) == mapSame.end() )

  002af	85 f6		 test	 esi, esi
  002b1	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  002b4	0f 84 f4 00 00
	00		 je	 $L269390
  002ba	56		 push	 esi
  002bb	8d 4c 24 34	 lea	 ecx, DWORD PTR $T312709[esp+108]
  002bf	51		 push	 ecx
  002c0	8d 4c 24 54	 lea	 ecx, DWORD PTR _mapSame$[esp+112]
  002c4	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find
  002c9	8b 54 24 50	 mov	 edx, DWORD PTR _mapSame$[esp+108]
  002cd	39 10		 cmp	 DWORD PTR [eax], edx
  002cf	0f 84 d9 00 00
	00		 je	 $L269390

; 1978 : 						continue;
; 1979 : 					
; 1980 : 					CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );

  002d5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  002d7	8d 44 24 1c	 lea	 eax, DWORD PTR $T313560[esp+104]
  002db	50		 push	 eax
  002dc	8d 4c 24 18	 lea	 ecx, DWORD PTR _i$313558[esp+108]
  002e0	51		 push	 ecx
  002e1	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  002e6	89 5c 24 24	 mov	 DWORD PTR $T313560[esp+112], ebx
  002ea	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  002ef	8b 44 24 14	 mov	 eax, DWORD PTR _i$313558[esp+104]
  002f3	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  002f9	0f 84 af 00 00
	00		 je	 $L269390
  002ff	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1981 : 					if( IsValidObj( pMover ) )

  00302	85 c0		 test	 eax, eax
  00304	0f 84 a4 00 00
	00		 je	 $L269390
  0030a	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0030e	0f 85 9a 00 00
	00		 jne	 $L269390

; 1982 : 					{
; 1983 : 						//if( nMaxLevel < pMover->GetLevel() )
; 1984 : 						if( nMinLevel > pMover->GetLevel() )

  00314	8b 88 e0 05 00
	00		 mov	 ecx, DWORD PTR [eax+1504]
  0031a	8b 54 24 18	 mov	 edx, DWORD PTR _nMinLevel$[esp+104]
  0031e	3b d1		 cmp	 edx, ecx
  00320	7e 3d		 jle	 SHORT $L313780

; 1985 : 						{
; 1986 : 							//nMaxLevel = pMover->GetLevel();
; 1987 : 							//nMaxExp = pMover->GetExp1();
; 1988 : 							nMinLevel = pMover->GetLevel();
; 1989 : 							nMinExp = pMover->GetExp1();

  00322	8b 90 e8 05 00
	00		 mov	 edx, DWORD PTR [eax+1512]
  00328	8b 80 ec 05 00
	00		 mov	 eax, DWORD PTR [eax+1516]
  0032e	89 54 24 38	 mov	 DWORD PTR _nMinExp$[esp+104], edx

; 1990 : 							uBestPlayer = pJoinPlayer->uidPlayer;
; 1991 : 							*nGetPoint = pJoinPlayer->nPoint;

  00332	8b 55 0c	 mov	 edx, DWORD PTR _nGetPoint$[ebp]
  00335	89 4c 24 18	 mov	 DWORD PTR _nMinLevel$[esp+104], ecx
  00339	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0033c	8b 74 24 2c	 mov	 esi, DWORD PTR _this$[esp+104]
  00340	89 0a		 mov	 DWORD PTR [edx], ecx

; 1992 : 							*dwGetGuildId = pGCMember->uGuildId;

  00342	8b 4d 08	 mov	 ecx, DWORD PTR _dwGetGuildId$[ebp]
  00345	8b 54 24 24	 mov	 edx, DWORD PTR _veci$269387[esp+104]
  00349	89 44 24 3c	 mov	 DWORD PTR _nMinExp$[esp+108], eax
  0034d	8b 07		 mov	 eax, DWORD PTR [edi]

; 1998 : 							{
; 1999 : 								//nMaxLevel = pMover->GetLevel();
; 2000 : 								//nMaxExp = pMover->GetExp1();
; 2001 : 								nMinLevel = pMover->GetLevel();
; 2002 : 								nMinExp = pMover->GetExp1();
; 2003 : 								uBestPlayer = pJoinPlayer->uidPlayer;

  0034f	89 5c 24 10	 mov	 DWORD PTR _uBestPlayer$[esp+104], ebx
  00353	8b 5c 24 20	 mov	 ebx, DWORD PTR _nVeci$269378[esp+104]
  00357	89 01		 mov	 DWORD PTR [ecx], eax
  00359	42		 inc	 edx
  0035a	e9 2b ff ff ff	 jmp	 $L313782
$L313780:

; 1993 : 						}
; 1994 : 						//else if( nMaxLevel == pMover->GetLevel() )
; 1995 : 						else if( nMinLevel == pMover->GetLevel() )

  0035f	75 4d		 jne	 SHORT $L269390

; 1996 : 						{
; 1997 : 							if( nMinExp > pMover->GetExp1() )

  00361	8b 90 e8 05 00
	00		 mov	 edx, DWORD PTR [eax+1512]
  00367	8b 80 ec 05 00
	00		 mov	 eax, DWORD PTR [eax+1516]
  0036d	89 54 24 40	 mov	 DWORD PTR tv699[esp+104], edx
  00371	39 44 24 3c	 cmp	 DWORD PTR _nMinExp$[esp+108], eax
  00375	89 44 24 44	 mov	 DWORD PTR tv699[esp+108], eax
  00379	7c 33		 jl	 SHORT $L269390
  0037b	7f 0e		 jg	 SHORT $L313769
  0037d	8b 44 24 38	 mov	 eax, DWORD PTR _nMinExp$[esp+104]
  00381	3b 44 24 40	 cmp	 eax, DWORD PTR tv699[esp+104]
  00385	76 27		 jbe	 SHORT $L269390
  00387	8b 44 24 44	 mov	 eax, DWORD PTR tv699[esp+108]
$L313769:

; 2004 : 								*nGetPoint = pJoinPlayer->nPoint;

  0038b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0038e	89 4c 24 18	 mov	 DWORD PTR _nMinLevel$[esp+104], ecx
  00392	8b 4c 24 40	 mov	 ecx, DWORD PTR tv699[esp+104]
  00396	89 44 24 3c	 mov	 DWORD PTR _nMinExp$[esp+108], eax
  0039a	8b 45 0c	 mov	 eax, DWORD PTR _nGetPoint$[ebp]
  0039d	89 10		 mov	 DWORD PTR [eax], edx

; 2005 : 								*dwGetGuildId = pGCMember->uGuildId;

  0039f	8b 55 08	 mov	 edx, DWORD PTR _dwGetGuildId$[ebp]
  003a2	89 4c 24 38	 mov	 DWORD PTR _nMinExp$[esp+104], ecx
  003a6	8b 0f		 mov	 ecx, DWORD PTR [edi]
  003a8	89 0a		 mov	 DWORD PTR [edx], ecx
  003aa	89 5c 24 10	 mov	 DWORD PTR _uBestPlayer$[esp+104], ebx
$L269390:
  003ae	8b 54 24 24	 mov	 edx, DWORD PTR _veci$269387[esp+104]
  003b2	8b 74 24 2c	 mov	 esi, DWORD PTR _this$[esp+104]
  003b6	8b 5c 24 20	 mov	 ebx, DWORD PTR _nVeci$269378[esp+104]
  003ba	42		 inc	 edx
  003bb	e9 ca fe ff ff	 jmp	 $L313782
$L269381:

; 1962 : 	{
; 1963 : 		for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  003c0	43		 inc	 ebx
  003c1	e9 3b fe ff ff	 jmp	 $L313783
$L313766:

; 2006 : 							}
; 2007 : 						}
; 2008 : 					}
; 2009 : 				}
; 2010 : 			}
; 2011 : #else // __S_BUG_GC
; 2012 : 			map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2013 : 			if( ita != m_GuildCombatMem.end() )
; 2014 : 			{
; 2015 : 				__GuildCombatMember* pGCMember = ita->second;
; 2016 : 				for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 2017 : 				{
; 2018 : 					__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 2019 : 					CMover* pMover = prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2020 : 					if( IsValidObj( pMover ) )
; 2021 : 					{
; 2022 : 						if( nMaxLevel < pMover->GetLevel() )
; 2023 : 						{
; 2024 : 							nMaxLevel = pMover->GetLevel();
; 2025 : 							nMaxExp = pMover->GetExp1();
; 2026 : 							uBestPlayer = pJoinPlayer->uidPlayer;
; 2027 : 							*nGetPoint = pJoinPlayer->nPoint;
; 2028 : 							*dwGetGuildId = ita->first;
; 2029 : 						}
; 2030 : 						else if( nMaxLevel == pMover->GetLevel() )
; 2031 : 						{
; 2032 : 							if( nMaxExp < pMover->GetExp1() )
; 2033 : 							{
; 2034 : 								nMaxLevel = pMover->GetLevel();
; 2035 : 								nMaxExp = pMover->GetExp1();
; 2036 : 								uBestPlayer = pJoinPlayer->uidPlayer;
; 2037 : 								*nGetPoint = pJoinPlayer->nPoint;
; 2038 : 								*dwGetGuildId = ita->first;
; 2039 : 							}
; 2040 : 						}
; 2041 : 					}
; 2042 : 				}
; 2043 : 			}
; 2044 : #endif // __S_BUG_GC
; 2045 : 		}
; 2046 : 	}
; 2047 : 	return uBestPlayer;

  003c6	8b 4c 24 50	 mov	 ecx, DWORD PTR _mapSame$[esp+108]
  003ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  003cc	51		 push	 ecx
  003cd	50		 push	 eax
  003ce	8d 44 24 38	 lea	 eax, DWORD PTR $T313730[esp+112]
  003d2	50		 push	 eax
  003d3	8d 4c 24 58	 lea	 ecx, DWORD PTR _mapSame$[esp+116]
  003d7	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+124], -1
  003df	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::erase
  003e4	8b 4c 24 50	 mov	 ecx, DWORD PTR _mapSame$[esp+108]
  003e8	51		 push	 ecx
  003e9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 2048 : }

  003ee	8b 4c 24 60	 mov	 ecx, DWORD PTR __$EHRec$[esp+108]
  003f2	8b 44 24 14	 mov	 eax, DWORD PTR _uBestPlayer$[esp+108]
  003f6	83 c4 04	 add	 esp, 4
  003f9	5f		 pop	 edi
  003fa	5e		 pop	 esi
  003fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00402	5b		 pop	 ebx
  00403	8b e5		 mov	 esp, ebp
  00405	5d		 pop	 ebp
  00406	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L312712:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _mapSame$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ
__ehhandler$?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T313757
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z ENDP		; CGuildCombat::GetBestPlayer
PUBLIC	??_C@_0O@FDHBDNOH@AUTO_OPEN_IDC?$AA@		; `string'
PUBLIC	??_C@_0DI@NCAENAAF@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$MA?Z?$LF?$LP?5@ ; `string'
PUBLIC	??_C@_0CK@GBPJBNHC@CGuildCombat?3?3LoadScript?$CI?$CJ?5Day?5E@ ; `string'
PUBLIC	??_C@_0CL@JHIMENAO@CGuildCombat?3?3LoadScript?$CI?$CJ?5Time?5@ ; `string'
PUBLIC	??_C@_09NLHJIAGP@JOINPENYA?$AA@			; `string'
PUBLIC	??_C@_0L@KEADDOJF@GUILDLEVEL?$AA@		; `string'
PUBLIC	??_C@_0BB@JNHLKBCP@MINJOINGUILDSIZE?$AA@	; `string'
PUBLIC	??_C@_0BB@IIPAHFNN@MAXJOINGUILDSIZE?$AA@	; `string'
PUBLIC	??_C@_0O@CIKALLAC@MAXPLAYERLIFE?$AA@		; `string'
PUBLIC	??_C@_0N@JALGJDBE@MAXWARPLAYER?$AA@		; `string'
PUBLIC	??_C@_0L@LDPPOPGC@MAXMAPTIME?$AA@		; `string'
PUBLIC	??_C@_0BC@OKCODEAA@MAXJOINMEMBERSIZE?$AA@	; `string'
PUBLIC	??_C@_0BA@IIOAOPHP@MAXGUILDPERCENT?$AA@		; `string'
PUBLIC	??_C@_0BB@CBMJGLHF@MAXPLAYERPERCENT?$AA@	; `string'
PUBLIC	??_C@_0BF@IAAJOIMN@REQUESTCANCLEPERCENT?$AA@	; `string'
PUBLIC	??_C@_0BC@OALCKFDK@NOTREQUESTPERCENT?$AA@	; `string'
PUBLIC	??_C@_09HIJMOIBC@ITEMPENYA?$AA@			; `string'
PUBLIC	??_C@_0BA@JFBBGIIM@MAX_GCSIENDITEM?$AA@		; `string'
PUBLIC	??_C@_0L@JGNDNFBG@GCSENDITEM?$AA@		; `string'
PUBLIC	??_C@_0DG@LMCCKBLL@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$LO?F?$MA?L?E@ ; `string'
PUBLIC	?LoadScript@CGuildCombat@@QAEHPBD@Z		; CGuildCombat::LoadScript
PUBLIC	??_C@_04DANIOFHI@OPEN?$AA@			; `string'
PUBLIC	??_C@_0M@FKFIKHIO@MAINTENANCE?$AA@		; `string'
PUBLIC	??_C@_03HBLEMPNJ@WAR?$AA@			; `string'
PUBLIC	??_C@_06NNMKOINI@ALLMSG?$AA@			; `string'
PUBLIC	??_C@_08CAFLFMC@GUILDMSG?$AA@			; `string'
PUBLIC	??_C@_07OHOLIPGE@JOINMSG?$AA@			; `string'
PUBLIC	??_C@_08CGGHBCGE@WORLDMSG?$AA@			; `string'
PUBLIC	??_C@_05MMKHEPHK@STATE?$AA@			; `string'
PUBLIC	??_C@_08NMCCOMCF@WARSTATE?$AA@			; `string'
PUBLIC	??_C@_04DBNKAKHO@WAIT?$AA@			; `string'
EXTRN	_atoi:NEAR
EXTRN	?GetToken@CScanner@@UAEHH@Z:NEAR		; CScanner::GetToken
EXTRN	?GetDefineNum@CScript@@SAHPBD@Z:NEAR		; CScript::GetDefineNum
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	SEGMENT
$T314174 DD	0ffffffffH
	DD	FLAT:$L313797
$T314155 DD	019930520H
	DD	01H
	DD	FLAT:$T314174
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0O@FDHBDNOH@AUTO_OPEN_IDC?$AA@
CONST	SEGMENT
??_C@_0O@FDHBDNOH@AUTO_OPEN_IDC?$AA@ DB 'AUTO_OPEN_IDC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLHJIAGP@JOINPENYA?$AA@
CONST	SEGMENT
??_C@_09NLHJIAGP@JOINPENYA?$AA@ DB 'JOINPENYA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEADDOJF@GUILDLEVEL?$AA@
CONST	SEGMENT
??_C@_0L@KEADDOJF@GUILDLEVEL?$AA@ DB 'GUILDLEVEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNHLKBCP@MINJOINGUILDSIZE?$AA@
CONST	SEGMENT
??_C@_0BB@JNHLKBCP@MINJOINGUILDSIZE?$AA@ DB 'MINJOINGUILDSIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIPAHFNN@MAXJOINGUILDSIZE?$AA@
CONST	SEGMENT
??_C@_0BB@IIPAHFNN@MAXJOINGUILDSIZE?$AA@ DB 'MAXJOINGUILDSIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIKALLAC@MAXPLAYERLIFE?$AA@
CONST	SEGMENT
??_C@_0O@CIKALLAC@MAXPLAYERLIFE?$AA@ DB 'MAXPLAYERLIFE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JALGJDBE@MAXWARPLAYER?$AA@
CONST	SEGMENT
??_C@_0N@JALGJDBE@MAXWARPLAYER?$AA@ DB 'MAXWARPLAYER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LDPPOPGC@MAXMAPTIME?$AA@
CONST	SEGMENT
??_C@_0L@LDPPOPGC@MAXMAPTIME?$AA@ DB 'MAXMAPTIME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OKCODEAA@MAXJOINMEMBERSIZE?$AA@
CONST	SEGMENT
??_C@_0BC@OKCODEAA@MAXJOINMEMBERSIZE?$AA@ DB 'MAXJOINMEMBERSIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IIOAOPHP@MAXGUILDPERCENT?$AA@
CONST	SEGMENT
??_C@_0BA@IIOAOPHP@MAXGUILDPERCENT?$AA@ DB 'MAXGUILDPERCENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CBMJGLHF@MAXPLAYERPERCENT?$AA@
CONST	SEGMENT
??_C@_0BB@CBMJGLHF@MAXPLAYERPERCENT?$AA@ DB 'MAXPLAYERPERCENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAJOIMN@REQUESTCANCLEPERCENT?$AA@
CONST	SEGMENT
??_C@_0BF@IAAJOIMN@REQUESTCANCLEPERCENT?$AA@ DB 'REQUESTCANCLEPERCENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OALCKFDK@NOTREQUESTPERCENT?$AA@
CONST	SEGMENT
??_C@_0BC@OALCKFDK@NOTREQUESTPERCENT?$AA@ DB 'NOTREQUESTPERCENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HIJMOIBC@ITEMPENYA?$AA@
CONST	SEGMENT
??_C@_09HIJMOIBC@ITEMPENYA?$AA@ DB 'ITEMPENYA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFBBGIIM@MAX_GCSIENDITEM?$AA@
CONST	SEGMENT
??_C@_0BA@JFBBGIIM@MAX_GCSIENDITEM?$AA@ DB 'MAX_GCSIENDITEM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JGNDNFBG@GCSENDITEM?$AA@
CONST	SEGMENT
??_C@_0L@JGNDNFBG@GCSENDITEM?$AA@ DB 'GCSENDITEM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DANIOFHI@OPEN?$AA@
CONST	SEGMENT
??_C@_04DANIOFHI@OPEN?$AA@ DB 'OPEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FKFIKHIO@MAINTENANCE?$AA@
CONST	SEGMENT
??_C@_0M@FKFIKHIO@MAINTENANCE?$AA@ DB 'MAINTENANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBLEMPNJ@WAR?$AA@
CONST	SEGMENT
??_C@_03HBLEMPNJ@WAR?$AA@ DB 'WAR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NNMKOINI@ALLMSG?$AA@
CONST	SEGMENT
??_C@_06NNMKOINI@ALLMSG?$AA@ DB 'ALLMSG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CAFLFMC@GUILDMSG?$AA@
CONST	SEGMENT
??_C@_08CAFLFMC@GUILDMSG?$AA@ DB 'GUILDMSG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHOLIPGE@JOINMSG?$AA@
CONST	SEGMENT
??_C@_07OHOLIPGE@JOINMSG?$AA@ DB 'JOINMSG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CGGHBCGE@WORLDMSG?$AA@
CONST	SEGMENT
??_C@_08CGGHBCGE@WORLDMSG?$AA@ DB 'WORLDMSG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MMKHEPHK@STATE?$AA@
CONST	SEGMENT
??_C@_05MMKHEPHK@STATE?$AA@ DB 'STATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NMCCOMCF@WARSTATE?$AA@
CONST	SEGMENT
??_C@_08NMCCOMCF@WARSTATE?$AA@ DB 'WARSTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBNKAKHO@WAIT?$AA@
CONST	SEGMENT
??_C@_04DBNKAKHO@WAIT?$AA@ DB 'WAIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NCAENAAF@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$MA?Z?$LF?$LP?5@
CONST	SEGMENT
??_C@_0DI@NCAENAAF@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$MA?Z?$LF?$LP?5@ DB 'C'
	DB	'GuildCombat::LoadScript() ', 0c0H, 0daH, 0b5H, 0bfH, ' ', 0bdH
	DB	0c3H, 0c0H, 0dbH, ' ', 0bcH, 0b3H, 0c1H, 0a4H, ' ', 0b0H, 0b9H
	DB	0bcH, 0f6H, 0b0H, 0a1H, ' ', 0b3H, 0d1H, 0c0H, 0bdH, '!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JHIMENAO@CGuildCombat?3?3LoadScript?$CI?$CJ?5Time?5@
CONST	SEGMENT
??_C@_0CL@JHIMENAO@CGuildCombat?3?3LoadScript?$CI?$CJ?5Time?5@ DB 'CGuild'
	DB	'Combat::LoadScript() Time Error = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GBPJBNHC@CGuildCombat?3?3LoadScript?$CI?$CJ?5Day?5E@
CONST	SEGMENT
??_C@_0CK@GBPJBNHC@CGuildCombat?3?3LoadScript?$CI?$CJ?5Day?5E@ DB 'CGuild'
	DB	'Combat::LoadScript() Day Error = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LMCCKBLL@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$LO?F?$MA?L?E@
CONST	SEGMENT
??_C@_0DG@LMCCKBLL@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$LO?F?$MA?L?E@ DB 'C'
	DB	'GuildCombat::LoadScript() ', 0beH, 0c6H, 0c0H, 0ccH, 0c5H, 0dbH
	DB	0c0H, 0ccH, ' ', 0beH, 0f8H, 0b4H, 0c2H, 0b0H, 0cdH, 0c0H, 0bbH
	DB	' ', 0bcH, 0b3H, 0c1H, 0a4H, 0c7H, 0dfH, 0c0H, 0bdH, 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?LoadScript@CGuildCombat@@QAEHPBD@Z
_TEXT	SEGMENT
_GCSendItem$269946 = -2140				; size = 12
_s$ = -2128						; size = 2112
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lpszFileName$ = 8					; size = 4
?LoadScript@CGuildCombat@@QAEHPBD@Z PROC NEAR		; CGuildCombat::LoadScript, COMDAT
; _this$ = ecx

; 2970 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?LoadScript@CGuildCombat@@QAEHPBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 50 08 00
	00		 sub	 esp, 2128		; 00000850H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	8b b4 24 6c 08
	00 00		 mov	 esi, DWORD PTR _lpszFileName$[esp+2148]
  0002c	8b d9		 mov	 ebx, ecx

; 2971 : 	CScanner s;

  0002e	33 ed		 xor	 ebp, ebp
  00030	55		 push	 ebp
  00031	8d 4c 24 1c	 lea	 ecx, DWORD PTR _s$[esp+2156]
  00035	89 84 24 5c 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2156], eax
  0003c	e8 00 00 00 00	 call	 ??0CScanner@@QAE@H@Z	; CScanner::CScanner

; 2972 : 	
; 2973 : 	if( !s.Load( lpszFileName ) )

  00041	6a 01		 push	 1
  00043	56		 push	 esi
  00044	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00048	89 ac 24 6c 08
	00 00		 mov	 DWORD PTR __$EHRec$[esp+2168], ebp
  0004f	e8 00 00 00 00	 call	 ?Load@CScanner@@QAEHPBDH@Z ; CScanner::Load
  00054	85 c0		 test	 eax, eax
  00056	75 1b		 jne	 SHORT $L269864

; 2974 : 		return FALSE;

  00058	8d 4c 24 18	 lea	 ecx, DWORD PTR _s$[esp+2152]
  0005c	c7 84 24 64 08
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+2160], -1
  00067	e8 00 00 00 00	 call	 ??1CScanner@@UAE@XZ	; CScanner::~CScanner
  0006c	33 c0		 xor	 eax, eax
  0006e	e9 d2 05 00 00	 jmp	 $L269862
$L269864:
  00073	57		 push	 edi

; 2975 : 
; 2976 : 	ZeroMemory( m_nProcessCount, sizeof( int ) * 25 );

  00074	33 c0		 xor	 eax, eax
  00076	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0007b	8d bb 88 00 00
	00		 lea	 edi, DWORD PTR [ebx+136]
  00081	f3 ab		 rep stosd

; 2977 : 	ZeroMemory( GuildCombatProcess, sizeof( __GuildCombatProcess ) * 250 );

  00083	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00088	8d bb ec 00 00
	00		 lea	 edi, DWORD PTR [ebx+236]
  0008e	f3 ab		 rep stosd

; 2978 : 	int		nCount;
; 2979 : 	int		nAutoOpenCnt = 0;
; 2980 : 
; 2981 : 	while( s.tok != FINISHED )

  00090	83 bc 24 48 08
	00 00 15	 cmp	 DWORD PTR _s$[esp+4248], 21 ; 00000015H
  00098	0f 84 8d 05 00
	00		 je	 $L269872
  0009e	8b ff		 npad	 2
$L269871:

; 2982 : 	{
; 2983 : 		nCount = -1;
; 2984 : 
; 2985 : #if defined(__MAINSERVER)
; 2986 : 		if( s.Token == _T( "AUTO_OPEN_IDC" ) )

  000a0	8b 44 24 3c	 mov	 eax, DWORD PTR _s$[esp+2188]
  000a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@FDHBDNOH@AUTO_OPEN_IDC?$AA@
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 __mbscmp
  000af	83 c4 08	 add	 esp, 8
  000b2	85 c0		 test	 eax, eax
  000b4	0f 85 ba 00 00
	00		 jne	 $L269873

; 2987 : 		{
; 2988 : 			s.GetToken();	// {

  000ba	50		 push	 eax
  000bb	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  000bf	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken

; 2989 : 			s.GetToken();	// {

  000c4	6a 00		 push	 0
  000c6	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  000ca	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken

; 2990 : 			
; 2991 : 			int nDay, nTime1, nTime2;
; 2992 : 			while( *s.token != '}' )

  000cf	8b 4c 24 40	 mov	 ecx, DWORD PTR _s$[esp+2192]
  000d3	80 39 7d	 cmp	 BYTE PTR [ecx], 125	; 0000007dH
  000d6	0f 84 36 05 00
	00		 je	 $L314168
  000dc	8d 64 24 00	 npad	 4
$L269879:

; 2993 : 			{
; 2994 : 				if( nAutoOpenCnt >= 7 )

  000e0	83 fd 07	 cmp	 ebp, 7
  000e3	0f 8d 84 05 00
	00		 jge	 $L314159

; 2998 : 				}
; 2999 : 
; 3000 : 				nDay = atoi( s.Token );

  000e9	8b 54 24 3c	 mov	 edx, DWORD PTR _s$[esp+2188]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _atoi
  000f3	8b f0		 mov	 esi, eax
  000f5	83 c4 04	 add	 esp, 4

; 3001 : 				m_nDay = nDay;
; 3002 : 				if( nDay <= 0 || nDay > 7 )

  000f8	85 f6		 test	 esi, esi
  000fa	89 b3 48 11 00
	00		 mov	 DWORD PTR [ebx+4424], esi
  00100	0f 8e 9c 05 00
	00		 jle	 $L269885
  00106	83 fe 07	 cmp	 esi, 7
  00109	0f 8f 93 05 00
	00		 jg	 $L269885

; 3006 : 				}
; 3007 : 				__AutoOpen[nDay-1].bUseing = TRUE;
; 3008 : 
; 3009 : 				nTime1 = s.GetNumber();

  0010f	6a 00		 push	 0
  00111	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00115	c7 04 f3 01 00
	00 00		 mov	 DWORD PTR [ebx+esi*8], 1
  0011c	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 3010 : 				if( nTime1 < 0 || nTime1 > 24 )

  00121	85 c0		 test	 eax, eax
  00123	0f 8c 69 05 00
	00		 jl	 $L269889
  00129	83 f8 18	 cmp	 eax, 24			; 00000018H
  0012c	0f 8f 60 05 00
	00		 jg	 $L269889

; 3014 : 				}
; 3015 : 				__AutoOpen[nDay-1].nHour = nTime1;
; 3016 : 				
; 3017 : 				nTime2 = s.GetNumber();

  00132	6a 00		 push	 0
  00134	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00138	88 44 f3 04	 mov	 BYTE PTR [ebx+esi*8+4], al
  0013c	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 3018 : 				if( nTime2 < 0 || nTime2 > 59 )

  00141	85 c0		 test	 eax, eax
  00143	0f 8c 49 05 00
	00		 jl	 $L269889
  00149	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0014c	0f 8f 40 05 00
	00		 jg	 $L269889

; 3019 : 				{
; 3020 : 					Error( "CGuildCombat::LoadScript() Time Error = %d", nTime2 );
; 3021 : 					return FALSE;
; 3022 : 				}
; 3023 : 				__AutoOpen[nDay-1].nMinute = nTime2;
; 3024 : 
; 3025 : 				nAutoOpenCnt++;
; 3026 : 
; 3027 : 				s.GetToken();

  00152	6a 00		 push	 0
  00154	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00158	88 44 f3 05	 mov	 BYTE PTR [ebx+esi*8+5], al
  0015c	45		 inc	 ebp
  0015d	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken
  00162	8b 44 24 40	 mov	 eax, DWORD PTR _s$[esp+2192]
  00166	80 38 7d	 cmp	 BYTE PTR [eax], 125	; 0000007dH
  00169	0f 85 71 ff ff
	ff		 jne	 $L269879

; 3028 : 			}		
; 3029 : 		}
; 3030 : #else
; 3031 : 		if( s.Token == _T( "AUTO_OPEN_TEST" ) )
; 3032 : 		{
; 3033 : 			s.GetToken();	// {
; 3034 : 			s.GetToken();	// {
; 3035 : 			
; 3036 : 			int nDay, nTime1, nTime2;
; 3037 : 			while( *s.token != '}' )
; 3038 : 			{
; 3039 : 				if( nAutoOpenCnt >= 7 )
; 3040 : 				{
; 3041 : 					Error( "CGuildCombat::LoadScript()     !!" );
; 3042 : 					return FALSE;
; 3043 : 				}
; 3044 : 				
; 3045 : 				nDay = atoi( s.Token );
; 3046 : 				m_nDay = nDay;
; 3047 : 				if( nDay <= 0 || nDay > 7 )
; 3048 : 				{
; 3049 : 					Error( "CGuildCombat::LoadScript() Day Error = %d", nDay );
; 3050 : 					return FALSE;
; 3051 : 				}
; 3052 : 				__AutoOpen[nDay-1].bUseing = TRUE;
; 3053 : 				
; 3054 : 				nTime1 = s.GetNumber();
; 3055 : 				if( nTime1 < 0 || nTime1 > 24 )
; 3056 : 				{
; 3057 : 					Error( "CGuildCombat::LoadScript() Time Error = %d", nTime1 );
; 3058 : 					return FALSE;
; 3059 : 				}
; 3060 : 				__AutoOpen[nDay-1].nHour = nTime1;
; 3061 : 				
; 3062 : 				nTime2 = s.GetNumber();
; 3063 : 				if( nTime2 < 0 || nTime2 > 59 )
; 3064 : 				{
; 3065 : 					Error( "CGuildCombat::LoadScript() Time Error = %d", nTime2 );
; 3066 : 					return FALSE;
; 3067 : 				}
; 3068 : 				__AutoOpen[nDay-1].nMinute = nTime2;
; 3069 : 				
; 3070 : 				nAutoOpenCnt++;
; 3071 : 				
; 3072 : 				s.GetToken();
; 3073 : 			}		
; 3074 : 		}
; 3075 : #endif
; 3076 : 		else if( s.Token == _T( "JOINPENYA" ) )

  0016f	e9 9e 04 00 00	 jmp	 $L314168
$L269873:
  00174	8b 4c 24 3c	 mov	 ecx, DWORD PTR _s$[esp+2188]
  00178	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09NLHJIAGP@JOINPENYA?$AA@
  0017d	51		 push	 ecx
  0017e	e8 00 00 00 00	 call	 __mbscmp
  00183	83 c4 08	 add	 esp, 8
  00186	85 c0		 test	 eax, eax
  00188	75 15		 jne	 SHORT $L269896

; 3077 : 		{
; 3078 : 			m_nJoinPanya = s.GetNumber();

  0018a	50		 push	 eax
  0018b	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  0018f	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  00194	89 83 90 10 00
	00		 mov	 DWORD PTR [ebx+4240], eax

; 3079 : 		}
; 3080 : 		else if( s.Token == _T( "GUILDLEVEL" ) )

  0019a	e9 73 04 00 00	 jmp	 $L314168
$L269896:
  0019f	8b 54 24 3c	 mov	 edx, DWORD PTR _s$[esp+2188]
  001a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@KEADDOJF@GUILDLEVEL?$AA@
  001a8	52		 push	 edx
  001a9	e8 00 00 00 00	 call	 __mbscmp
  001ae	83 c4 08	 add	 esp, 8
  001b1	85 c0		 test	 eax, eax
  001b3	75 15		 jne	 SHORT $L269899

; 3081 : 		{
; 3082 : 			m_nGuildLevel = s.GetNumber();

  001b5	50		 push	 eax
  001b6	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  001ba	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  001bf	89 83 94 10 00
	00		 mov	 DWORD PTR [ebx+4244], eax

; 3083 : 		}
; 3084 : #if __VER >= 8 // __GUILDCOMBAT_85
; 3085 : 		else if( s.Token == _T( "MINJOINGUILDSIZE" ) )

  001c5	e9 48 04 00 00	 jmp	 $L314168
$L269899:
  001ca	8b 44 24 3c	 mov	 eax, DWORD PTR _s$[esp+2188]
  001ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@JNHLKBCP@MINJOINGUILDSIZE?$AA@
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 __mbscmp
  001d9	83 c4 08	 add	 esp, 8
  001dc	85 c0		 test	 eax, eax
  001de	75 15		 jne	 SHORT $L269902

; 3086 : 		{
; 3087 : 			m_nMinGuild = s.GetNumber();

  001e0	50		 push	 eax
  001e1	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  001e5	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  001ea	89 83 98 10 00
	00		 mov	 DWORD PTR [ebx+4248], eax

; 3088 : 		}
; 3089 : #endif // __VER >= 8
; 3090 : 		else if( s.Token == _T( "MAXJOINGUILDSIZE" ) )

  001f0	e9 1d 04 00 00	 jmp	 $L314168
$L269902:
  001f5	8b 4c 24 3c	 mov	 ecx, DWORD PTR _s$[esp+2188]
  001f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@IIPAHFNN@MAXJOINGUILDSIZE?$AA@
  001fe	51		 push	 ecx
  001ff	e8 00 00 00 00	 call	 __mbscmp
  00204	83 c4 08	 add	 esp, 8
  00207	85 c0		 test	 eax, eax
  00209	75 15		 jne	 SHORT $L269905

; 3091 : 		{
; 3092 : 			m_nMaxGuild = s.GetNumber();

  0020b	50		 push	 eax
  0020c	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00210	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  00215	89 83 a0 10 00
	00		 mov	 DWORD PTR [ebx+4256], eax

; 3093 : 		}
; 3094 : 		else if( s.Token == _T( "MAXPLAYERLIFE" ) )

  0021b	e9 f2 03 00 00	 jmp	 $L314168
$L269905:
  00220	8b 54 24 3c	 mov	 edx, DWORD PTR _s$[esp+2188]
  00224	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@CIKALLAC@MAXPLAYERLIFE?$AA@
  00229	52		 push	 edx
  0022a	e8 00 00 00 00	 call	 __mbscmp
  0022f	83 c4 08	 add	 esp, 8
  00232	85 c0		 test	 eax, eax
  00234	75 15		 jne	 SHORT $L269908

; 3095 : 		{
; 3096 : 			m_nMaxPlayerLife = s.GetNumber();

  00236	50		 push	 eax
  00237	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  0023b	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  00240	89 83 a8 10 00
	00		 mov	 DWORD PTR [ebx+4264], eax

; 3097 : 		}
; 3098 : 		else if( s.Token == _T( "MAXWARPLAYER" ) )

  00246	e9 c7 03 00 00	 jmp	 $L314168
$L269908:
  0024b	8b 44 24 3c	 mov	 eax, DWORD PTR _s$[esp+2188]
  0024f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JALGJDBE@MAXWARPLAYER?$AA@
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 __mbscmp
  0025a	83 c4 08	 add	 esp, 8
  0025d	85 c0		 test	 eax, eax
  0025f	75 15		 jne	 SHORT $L269911

; 3099 : 		{
; 3100 : 			m_nMaxWarPlayer = s.GetNumber();

  00261	50		 push	 eax
  00262	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00266	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  0026b	89 83 ac 10 00
	00		 mov	 DWORD PTR [ebx+4268], eax

; 3101 : 		}
; 3102 : 		else if( s.Token == _T( "MAXMAPTIME" ) )

  00271	e9 9c 03 00 00	 jmp	 $L314168
$L269911:
  00276	8b 4c 24 3c	 mov	 ecx, DWORD PTR _s$[esp+2188]
  0027a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@LDPPOPGC@MAXMAPTIME?$AA@
  0027f	51		 push	 ecx
  00280	e8 00 00 00 00	 call	 __mbscmp
  00285	83 c4 08	 add	 esp, 8
  00288	85 c0		 test	 eax, eax
  0028a	75 15		 jne	 SHORT $L269914

; 3103 : 		{
; 3104 : 			m_nMaxMapTime = s.GetNumber();

  0028c	50		 push	 eax
  0028d	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00291	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  00296	89 83 b0 10 00
	00		 mov	 DWORD PTR [ebx+4272], eax

; 3105 : 		}
; 3106 : 		else if( s.Token == _T( "MAXJOINMEMBERSIZE" ) )

  0029c	e9 71 03 00 00	 jmp	 $L314168
$L269914:
  002a1	8d 54 24 3c	 lea	 edx, DWORD PTR _s$[esp+2188]
  002a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@OKCODEAA@MAXJOINMEMBERSIZE?$AA@
  002aa	52		 push	 edx
  002ab	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  002b0	83 c4 08	 add	 esp, 8
  002b3	84 c0		 test	 al, al
  002b5	74 16		 je	 SHORT $L269917

; 3107 : 		{
; 3108 : 			m_nMaxJoinMember = s.GetNumber();

  002b7	6a 00		 push	 0
  002b9	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  002bd	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  002c2	89 83 a4 10 00
	00		 mov	 DWORD PTR [ebx+4260], eax

; 3109 : 		}
; 3110 : 		else if( s.Token == _T( "MAXGUILDPERCENT" ) )

  002c8	e9 45 03 00 00	 jmp	 $L314168
$L269917:
  002cd	8d 44 24 3c	 lea	 eax, DWORD PTR _s$[esp+2188]
  002d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@IIOAOPHP@MAXGUILDPERCENT?$AA@
  002d6	50		 push	 eax
  002d7	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  002dc	83 c4 08	 add	 esp, 8
  002df	84 c0		 test	 al, al
  002e1	74 16		 je	 SHORT $L269920

; 3111 : 		{
; 3112 : 			m_nMaxGuildPercent = s.GetNumber();

  002e3	6a 00		 push	 0
  002e5	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  002e9	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  002ee	89 83 b4 10 00
	00		 mov	 DWORD PTR [ebx+4276], eax

; 3113 : 		}
; 3114 : 		else if( s.Token == _T( "MAXPLAYERPERCENT" ) )

  002f4	e9 19 03 00 00	 jmp	 $L314168
$L269920:
  002f9	8d 4c 24 3c	 lea	 ecx, DWORD PTR _s$[esp+2188]
  002fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@CBMJGLHF@MAXPLAYERPERCENT?$AA@
  00302	51		 push	 ecx
  00303	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  00308	83 c4 08	 add	 esp, 8
  0030b	84 c0		 test	 al, al
  0030d	74 16		 je	 SHORT $L269923

; 3115 : 		{
; 3116 : 			m_nMaxPlayerPercent = s.GetNumber();

  0030f	6a 00		 push	 0
  00311	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00315	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  0031a	89 83 b8 10 00
	00		 mov	 DWORD PTR [ebx+4280], eax

; 3117 : 		}
; 3118 : 		else if( s.Token == _T( "REQUESTCANCLEPERCENT" ) )

  00320	e9 ed 02 00 00	 jmp	 $L314168
$L269923:
  00325	8d 54 24 3c	 lea	 edx, DWORD PTR _s$[esp+2188]
  00329	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@IAAJOIMN@REQUESTCANCLEPERCENT?$AA@
  0032e	52		 push	 edx
  0032f	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  00334	83 c4 08	 add	 esp, 8
  00337	84 c0		 test	 al, al
  00339	74 16		 je	 SHORT $L269926

; 3119 : 		{
; 3120 : 			m_nRequestCanclePercent = s.GetNumber();

  0033b	6a 00		 push	 0
  0033d	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00341	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  00346	89 83 bc 10 00
	00		 mov	 DWORD PTR [ebx+4284], eax

; 3121 : 		}
; 3122 : 		else if( s.Token == _T( "NOTREQUESTPERCENT" ) )

  0034c	e9 c1 02 00 00	 jmp	 $L314168
$L269926:
  00351	8d 44 24 3c	 lea	 eax, DWORD PTR _s$[esp+2188]
  00355	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@OALCKFDK@NOTREQUESTPERCENT?$AA@
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  00360	83 c4 08	 add	 esp, 8
  00363	84 c0		 test	 al, al
  00365	74 16		 je	 SHORT $L269929

; 3123 : 		{
; 3124 : 			m_nNotRequestPercent = s.GetNumber();

  00367	6a 00		 push	 0
  00369	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  0036d	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  00372	89 83 c0 10 00
	00		 mov	 DWORD PTR [ebx+4288], eax

; 3125 : 		}
; 3126 : 		else if( s.Token == _T( "ITEMPENYA" ) )

  00378	e9 95 02 00 00	 jmp	 $L314168
$L269929:
  0037d	8d 4c 24 3c	 lea	 ecx, DWORD PTR _s$[esp+2188]
  00381	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09HIJMOIBC@ITEMPENYA?$AA@
  00386	51		 push	 ecx
  00387	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  0038c	83 c4 08	 add	 esp, 8
  0038f	84 c0		 test	 al, al
  00391	74 16		 je	 SHORT $L269932

; 3127 : 		{
; 3128 : 			m_nItemPenya = s.GetNumber();

  00393	6a 00		 push	 0
  00395	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00399	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  0039e	89 83 c4 10 00
	00		 mov	 DWORD PTR [ebx+4292], eax

; 3129 : 		}
; 3130 : #if __VER >= 8 // __GUILDCOMBAT_85
; 3131 : 		else if( s.Token == _T( "MAX_GCSIENDITEM" ) )

  003a4	e9 69 02 00 00	 jmp	 $L314168
$L269932:
  003a9	8d 54 24 3c	 lea	 edx, DWORD PTR _s$[esp+2188]
  003ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@JFBBGIIM@MAX_GCSIENDITEM?$AA@
  003b2	52		 push	 edx
  003b3	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  003b8	83 c4 08	 add	 esp, 8
  003bb	84 c0		 test	 al, al
  003bd	74 16		 je	 SHORT $L269935

; 3132 : 		{
; 3133 : 			m_nMaxGCSendItem = s.GetNumber();

  003bf	6a 00		 push	 0
  003c1	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  003c5	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  003ca	89 83 9c 10 00
	00		 mov	 DWORD PTR [ebx+4252], eax

; 3134 : 		}
; 3135 : 		else if( s.Token == _T( "GCSENDITEM" ) )

  003d0	e9 3d 02 00 00	 jmp	 $L314168
$L269935:
  003d5	8d 44 24 3c	 lea	 eax, DWORD PTR _s$[esp+2188]
  003d9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@JGNDNFBG@GCSENDITEM?$AA@
  003de	50		 push	 eax
  003df	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  003e4	83 c4 08	 add	 esp, 8
  003e7	84 c0		 test	 al, al
  003e9	74 5c		 je	 SHORT $L269938

; 3136 : 		{
; 3137 : 			int nWinCount = s.GetNumber();

  003eb	6a 00		 push	 0
  003ed	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  003f1	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 3138 : 			s.GetToken();

  003f6	6a 00		 push	 0
  003f8	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  003fc	8b f8		 mov	 edi, eax
  003fe	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken

; 3139 : 			DWORD dwItemId = CScript::GetDefineNum( s.Token );

  00403	8b 4c 24 3c	 mov	 ecx, DWORD PTR _s$[esp+2188]
  00407	51		 push	 ecx
  00408	e8 00 00 00 00	 call	 ?GetDefineNum@CScript@@SAHPBD@Z ; CScript::GetDefineNum
  0040d	8b f0		 mov	 esi, eax
  0040f	83 c4 04	 add	 esp, 4

; 3140 : 			if( dwItemId == -1 )

  00412	83 fe ff	 cmp	 esi, -1
  00415	0f 84 97 02 00
	00		 je	 $L314163

; 3144 : 			}
; 3145 : 			int nItemNum = s.GetNumber();

  0041b	6a 00		 push	 0
  0041d	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00421	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 3146 : 			__GCSENDITEM GCSendItem;
; 3147 : 			GCSendItem.nWinCount = nWinCount;
; 3148 : 			GCSendItem.dwItemId = dwItemId;
; 3149 : 			GCSendItem.nItemNum = nItemNum;
; 3150 : 			vecGCSendItem.push_back( GCSendItem );

  00426	8d 54 24 10	 lea	 edx, DWORD PTR _GCSendItem$269946[esp+2156]
  0042a	52		 push	 edx
  0042b	8d 8b 00 11 00
	00		 lea	 ecx, DWORD PTR [ebx+4352]
  00431	89 7c 24 14	 mov	 DWORD PTR _GCSendItem$269946[esp+2160], edi
  00435	89 74 24 18	 mov	 DWORD PTR _GCSendItem$269946[esp+2164], esi
  00439	89 44 24 1c	 mov	 DWORD PTR _GCSendItem$269946[esp+2168], eax
  0043d	e8 00 00 00 00	 call	 ?push_back@?$vector@U__GCSENDITEM@CGuildCombat@@V?$allocator@U__GCSENDITEM@CGuildCombat@@@std@@@std@@QAEXABU__GCSENDITEM@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCSENDITEM,std::allocator<CGuildCombat::__GCSENDITEM> >::push_back

; 3151 : 		}
; 3152 : #endif // __VER >= 8
; 3153 : 		else if( s.Token == _T( "OPEN" ) )

  00442	e9 cb 01 00 00	 jmp	 $L314168
$L269938:
  00447	8d 44 24 3c	 lea	 eax, DWORD PTR _s$[esp+2188]
  0044b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04DANIOFHI@OPEN?$AA@
  00450	50		 push	 eax
  00451	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  00456	83 c4 08	 add	 esp, 8
  00459	84 c0		 test	 al, al
  0045b	74 04		 je	 SHORT $L269948

; 3154 : 		{
; 3155 : 			nCount = 0;

  0045d	33 f6		 xor	 esi, esi

; 3156 : 		}
; 3157 : 		else if( s.Token == _T( "MAINTENANCE" ) )

  0045f	eb 3c		 jmp	 SHORT $L314167
$L269948:
  00461	8d 4c 24 3c	 lea	 ecx, DWORD PTR _s$[esp+2188]
  00465	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@FKFIKHIO@MAINTENANCE?$AA@
  0046a	51		 push	 ecx
  0046b	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  00470	83 c4 08	 add	 esp, 8
  00473	84 c0		 test	 al, al
  00475	74 07		 je	 SHORT $L269951

; 3158 : 		{
; 3159 : 			nCount = 1;

  00477	be 01 00 00 00	 mov	 esi, 1

; 3160 : 		}
; 3161 : 		else if( s.Token == _T( "WAR" ) )

  0047c	eb 1f		 jmp	 SHORT $L314167
$L269951:
  0047e	8d 54 24 3c	 lea	 edx, DWORD PTR _s$[esp+2188]
  00482	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03HBLEMPNJ@WAR?$AA@
  00487	52		 push	 edx
  00488	e8 00 00 00 00	 call	 ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
  0048d	83 c4 08	 add	 esp, 8
  00490	84 c0		 test	 al, al
  00492	0f 84 7a 01 00
	00		 je	 $L314168

; 3162 : 		{
; 3163 : 			nCount = 2;

  00498	be 02 00 00 00	 mov	 esi, 2
$L314167:

; 3164 : 		}
; 3165 : 
; 3166 : 		if( nCount != -1 )
; 3167 : 		{
; 3168 : 			m_nProcessCount[nCount] = s.GetNumber();

  0049d	6a 00		 push	 0
  0049f	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  004a3	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 3169 : 			s.GetToken();	// {

  004a8	6a 00		 push	 0
  004aa	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  004ae	89 84 b3 88 00
	00 00		 mov	 DWORD PTR [ebx+esi*4+136], eax
  004b5	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken

; 3170 : 			s.GetToken();	// {

  004ba	6a 00		 push	 0
  004bc	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  004c0	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken

; 3171 : 			int nSoCount = 0;
; 3172 : 			while( *s.token != '}' )

  004c5	8b 44 24 40	 mov	 eax, DWORD PTR _s$[esp+2192]
  004c9	80 38 7d	 cmp	 BYTE PTR [eax], 125	; 0000007dH
  004cc	0f 84 40 01 00
	00		 je	 $L314168
  004d2	8b fe		 mov	 edi, esi
  004d4	6b ff 19	 imul	 edi, 25			; 00000019H
  004d7	69 f6 90 01 00
	00		 imul	 esi, 400		; 00000190H
  004dd	8d b4 1e ec 00
	00 00		 lea	 esi, DWORD PTR [esi+ebx+236]
$L269959:

; 3173 : 			{
; 3174 : 				if( s.Token == _T( "ALLMSG" ) )

  004e4	8b 4c 24 3c	 mov	 ecx, DWORD PTR _s$[esp+2188]
  004e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06NNMKOINI@ALLMSG?$AA@
  004ed	51		 push	 ecx
  004ee	e8 00 00 00 00	 call	 __mbscmp
  004f3	83 c4 08	 add	 esp, 8
  004f6	85 c0		 test	 eax, eax
  004f8	75 0b		 jne	 SHORT $L269961

; 3175 : 				{
; 3176 : 					GuildCombatProcess[25*nCount+nSoCount].nState	= ALLMSG;

  004fa	c7 06 e8 03 00
	00		 mov	 DWORD PTR [esi], 1000	; 000003e8H

; 3177 : 				}
; 3178 : 				else if( s.Token == _T( "GUILDMSG" ) )

  00500	e9 b5 00 00 00	 jmp	 $L269979
$L269961:
  00505	8b 54 24 3c	 mov	 edx, DWORD PTR _s$[esp+2188]
  00509	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08CAFLFMC@GUILDMSG?$AA@
  0050e	52		 push	 edx
  0050f	e8 00 00 00 00	 call	 __mbscmp
  00514	83 c4 08	 add	 esp, 8
  00517	85 c0		 test	 eax, eax
  00519	75 0b		 jne	 SHORT $L269964

; 3179 : 				{
; 3180 : 					GuildCombatProcess[25*nCount+nSoCount].nState	= GUILDMSG;

  0051b	c7 06 e9 03 00
	00		 mov	 DWORD PTR [esi], 1001	; 000003e9H

; 3181 : 				}
; 3182 : 				else if( s.Token == _T( "JOINMSG" ) )

  00521	e9 94 00 00 00	 jmp	 $L269979
$L269964:
  00526	8b 44 24 3c	 mov	 eax, DWORD PTR _s$[esp+2188]
  0052a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07OHOLIPGE@JOINMSG?$AA@
  0052f	50		 push	 eax
  00530	e8 00 00 00 00	 call	 __mbscmp
  00535	83 c4 08	 add	 esp, 8
  00538	85 c0		 test	 eax, eax
  0053a	75 08		 jne	 SHORT $L269967

; 3183 : 				{
; 3184 : 					GuildCombatProcess[25*nCount+nSoCount].nState	= JOINMSG;

  0053c	c7 06 ea 03 00
	00		 mov	 DWORD PTR [esi], 1002	; 000003eaH

; 3185 : 				}
; 3186 : 				else if( s.Token == _T( "WORLDMSG" ) )

  00542	eb 76		 jmp	 SHORT $L269979
$L269967:
  00544	8b 4c 24 3c	 mov	 ecx, DWORD PTR _s$[esp+2188]
  00548	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08CGGHBCGE@WORLDMSG?$AA@
  0054d	51		 push	 ecx
  0054e	e8 00 00 00 00	 call	 __mbscmp
  00553	83 c4 08	 add	 esp, 8
  00556	85 c0		 test	 eax, eax
  00558	75 08		 jne	 SHORT $L269970

; 3187 : 				{
; 3188 : 					GuildCombatProcess[25*nCount+nSoCount].nState	= WORLDMSG;

  0055a	c7 06 eb 03 00
	00		 mov	 DWORD PTR [esi], 1003	; 000003ebH

; 3189 : 				}
; 3190 : 				else if( s.Token == _T( "STATE" ) )

  00560	eb 58		 jmp	 SHORT $L269979
$L269970:
  00562	8b 54 24 3c	 mov	 edx, DWORD PTR _s$[esp+2188]
  00566	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05MMKHEPHK@STATE?$AA@
  0056b	52		 push	 edx
  0056c	e8 00 00 00 00	 call	 __mbscmp
  00571	83 c4 08	 add	 esp, 8
  00574	85 c0		 test	 eax, eax
  00576	75 08		 jne	 SHORT $L269973

; 3191 : 				{
; 3192 : 					GuildCombatProcess[25*nCount+nSoCount].nState	= STATE;

  00578	c7 06 ec 03 00
	00		 mov	 DWORD PTR [esi], 1004	; 000003ecH

; 3193 : 				}
; 3194 : 				else if( s.Token == _T( "WARSTATE" ) )

  0057e	eb 3a		 jmp	 SHORT $L269979
$L269973:
  00580	8b 44 24 3c	 mov	 eax, DWORD PTR _s$[esp+2188]
  00584	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08NMCCOMCF@WARSTATE?$AA@
  00589	50		 push	 eax
  0058a	e8 00 00 00 00	 call	 __mbscmp
  0058f	83 c4 08	 add	 esp, 8
  00592	85 c0		 test	 eax, eax
  00594	75 08		 jne	 SHORT $L269976

; 3195 : 				{
; 3196 : 					GuildCombatProcess[25*nCount+nSoCount].nState	= WARSTATE;

  00596	c7 06 ed 03 00
	00		 mov	 DWORD PTR [esi], 1005	; 000003edH

; 3197 : 				}
; 3198 : 				else if( s.Token == _T( "WAIT" ) )

  0059c	eb 1c		 jmp	 SHORT $L269979
$L269976:
  0059e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _s$[esp+2188]
  005a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04DBNKAKHO@WAIT?$AA@
  005a7	51		 push	 ecx
  005a8	e8 00 00 00 00	 call	 __mbscmp
  005ad	83 c4 08	 add	 esp, 8
  005b0	85 c0		 test	 eax, eax
  005b2	75 06		 jne	 SHORT $L269979

; 3199 : 				{
; 3200 : 					GuildCombatProcess[25*nCount+nSoCount].nState	= WAIT;

  005b4	c7 06 ee 03 00
	00		 mov	 DWORD PTR [esi], 1006	; 000003eeH
$L269979:

; 3201 : 				}
; 3202 : 				GuildCombatProcess[25*nCount+nSoCount].dwTime	= s.GetNumber();

  005ba	6a 00		 push	 0
  005bc	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  005c0	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 3203 : 				GuildCombatProcess[25*nCount+nSoCount].dwCommand	= s.GetNumber();

  005c5	6a 00		 push	 0
  005c7	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  005cb	89 46 04	 mov	 DWORD PTR [esi+4], eax
  005ce	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber

; 3204 : 				GuildCombatProcess[25*nCount+nSoCount].dwParam		= s.GetNumber();

  005d3	6a 00		 push	 0
  005d5	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  005d9	89 46 08	 mov	 DWORD PTR [esi+8], eax
  005dc	e8 00 00 00 00	 call	 ?GetNumber@CScanner@@QAEHH@Z ; CScanner::GetNumber
  005e1	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 3205 : 				if( GuildCombatProcess[25*nCount+nSoCount].nState == STATE )

  005e4	81 3e ec 03 00
	00		 cmp	 DWORD PTR [esi], 1004	; 000003ecH
  005ea	75 0a		 jne	 SHORT $L269981

; 3206 : 					m_nProcessCount[GuildCombatProcess[25*nCount+nSoCount].dwCommand] = 25*nCount+nSoCount;

  005ec	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  005ef	89 bc 93 88 00
	00 00		 mov	 DWORD PTR [ebx+edx*4+136], edi
$L269981:

; 3207 : 				
; 3208 : 				++nSoCount;

  005f6	83 c6 10	 add	 esi, 16			; 00000010H

; 3209 : 				s.GetToken();

  005f9	6a 00		 push	 0
  005fb	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  005ff	47		 inc	 edi
  00600	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken
  00605	8b 44 24 40	 mov	 eax, DWORD PTR _s$[esp+2192]
  00609	80 38 7d	 cmp	 BYTE PTR [eax], 125	; 0000007dH
  0060c	0f 85 d2 fe ff
	ff		 jne	 $L269959
$L314168:

; 3210 : 			}
; 3211 : 		}
; 3212 : 
; 3213 : 		s.GetToken();

  00612	6a 00		 push	 0
  00614	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$[esp+2160]
  00618	e8 00 00 00 00	 call	 ?GetToken@CScanner@@UAEHH@Z ; CScanner::GetToken
  0061d	83 bc 24 48 08
	00 00 15	 cmp	 DWORD PTR _s$[esp+4248], 21 ; 00000015H
  00625	0f 85 75 fa ff
	ff		 jne	 $L269871
$L269872:

; 3214 : 	}	
; 3215 : 	return TRUE;

  0062b	8d 4c 24 1c	 lea	 ecx, DWORD PTR _s$[esp+2156]
  0062f	c7 84 24 68 08
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+2164], -1
  0063a	e8 00 00 00 00	 call	 ??1CScanner@@UAE@XZ	; CScanner::~CScanner
  0063f	b8 01 00 00 00	 mov	 eax, 1
$L314171:
  00644	5f		 pop	 edi
$L269862:

; 3216 : }

  00645	8b 8c 24 5c 08
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+2152]
  0064c	5e		 pop	 esi
  0064d	5d		 pop	 ebp
  0064e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00655	8b 8c 24 50 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2144]
  0065c	5b		 pop	 ebx
  0065d	33 cc		 xor	 ecx, esp
  0065f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00664	81 c4 5c 08 00
	00		 add	 esp, 2140		; 0000085cH
  0066a	c2 04 00	 ret	 4
$L314159:

; 2995 : 				{
; 2996 : 					Error( "CGuildCombat::LoadScript()     !!" );

  0066d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@NCAENAAF@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$MA?Z?$LF?$LP?5@
$L314173:
  00672	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00677	83 c4 04	 add	 esp, 4
$L314172:

; 2997 : 					return FALSE;

  0067a	8d 4c 24 1c	 lea	 ecx, DWORD PTR _s$[esp+2156]
  0067e	c7 84 24 68 08
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+2164], -1
  00689	e8 00 00 00 00	 call	 ??1CScanner@@UAE@XZ	; CScanner::~CScanner
  0068e	33 c0		 xor	 eax, eax
  00690	eb b2		 jmp	 SHORT $L314171
$L269889:

; 3011 : 				{
; 3012 : 					Error( "CGuildCombat::LoadScript() Time Error = %d", nTime1 );

  00692	50		 push	 eax
  00693	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@JHIMENAO@CGuildCombat?3?3LoadScript?$CI?$CJ?5Time?5@
  00698	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0069d	83 c4 08	 add	 esp, 8

; 3013 : 					return FALSE;

  006a0	eb d8		 jmp	 SHORT $L314172
$L269885:

; 3003 : 				{
; 3004 : 					Error( "CGuildCombat::LoadScript() Day Error = %d", nDay );

  006a2	56		 push	 esi
  006a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@GBPJBNHC@CGuildCombat?3?3LoadScript?$CI?$CJ?5Day?5E@
  006a8	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  006ad	83 c4 08	 add	 esp, 8

; 3005 : 					return FALSE;

  006b0	eb c8		 jmp	 SHORT $L314172
$L314163:

; 3141 : 			{
; 3142 : 				Error( "CGuildCombat::LoadScript()   " );

  006b2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@LMCCKBLL@CGuildCombat?3?3LoadScript?$CI?$CJ?5?$LO?F?$MA?L?E@

; 3143 : 				return FALSE;

  006b7	eb b9		 jmp	 SHORT $L314173
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L313797:
  00000	8d 8d b0 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CScanner@@UAE@XZ	; CScanner::~CScanner
__ehhandler$?LoadScript@CGuildCombat@@QAEHPBD@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T314155
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadScript@CGuildCombat@@QAEHPBD@Z ENDP		; CGuildCombat::LoadScript
PUBLIC	?GetPoint@CGuildCombat@@QAEXPAVCUser@@0@Z	; CGuildCombat::GetPoint
PUBLIC	??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@		; `string'
EXTRN	?GetGuild@CMover@@QAEPAVCGuild@@XZ:NEAR		; CMover::GetGuild
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.h
CONST	SEGMENT
??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@ DB '"%s"', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?GetPoint@CGuildCombat@@QAEXPAVCUser@@0@Z
_TEXT	SEGMENT
_bMaster$ = -68						; size = 4
_bDefender$ = -64					; size = 4
_bKillDiffernceGuild$ = -60				; size = 4
_bLastLife$ = -56					; size = 4
$T314611 = -52						; size = 4
_nGetPoint$ = -52					; size = 4
_this$ = -48						; size = 4
_i$314914 = -44						; size = 4
_i$314609 = -44						; size = 4
_pGuild$ = -40						; size = 4
_GCGetPoint$314966 = -36				; size = 36
_pAttacker$ = 8						; size = 4
$T314936 = 12						; size = 4
_pDefender$ = 12					; size = 4
?GetPoint@CGuildCombat@@QAEXPAVCUser@@0@Z PROC NEAR	; CGuildCombat::GetPoint, COMDAT
; _this$ = ecx

; 3403 : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 3404 : 	//    
; 3405 : 	BOOL bMaster = FALSE;
; 3406 : 	BOOL bDefender = FALSE;
; 3407 : 	BOOL bLastLife = FALSE;
; 3408 : 	BOOL bKillDiffernceGuild = FALSE;
; 3409 : 	int nGetPoint = 2;
; 3410 : 	__JOINPLAYER* pJoinPlayerAttacker = NULL;
; 3411 : 	__JOINPLAYER* pJoinPlayerDefender = NULL;
; 3412 : 	__GuildCombatMember* pGCMemberAttacker = NULL;
; 3413 : 	CGuild* pGuild	= g_GuildMng.GetGuild( pAttacker->m_idGuild );

  00007	8b 7c 24 58	 mov	 edi, DWORD PTR _pAttacker$[esp+80]
  0000b	8b 87 1c 07 00
	00		 mov	 eax, DWORD PTR [edi+1820]
  00011	33 ed		 xor	 ebp, ebp
  00013	8b f1		 mov	 esi, ecx
  00015	bb 02 00 00 00	 mov	 ebx, 2
  0001a	50		 push	 eax
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00020	89 74 24 28	 mov	 DWORD PTR _this$[esp+88], esi
  00024	89 6c 24 14	 mov	 DWORD PTR _bMaster$[esp+88], ebp
  00028	89 6c 24 18	 mov	 DWORD PTR _bDefender$[esp+88], ebp
  0002c	89 6c 24 20	 mov	 DWORD PTR _bLastLife$[esp+88], ebp
  00030	89 6c 24 1c	 mov	 DWORD PTR _bKillDiffernceGuild$[esp+88], ebp
  00034	89 5c 24 24	 mov	 DWORD PTR _nGetPoint$[esp+88], ebx
  00038	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 3414 : 	if( pGuild && pGuild->IsMaster( pAttacker->m_idPlayer ) )

  0003d	3b c5		 cmp	 eax, ebp
  0003f	89 44 24 2c	 mov	 DWORD PTR _pGuild$[esp+84], eax
  00043	74 13		 je	 SHORT $L270063
  00045	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00048	3b 8f 38 02 00
	00		 cmp	 ecx, DWORD PTR [edi+568]
  0004e	75 08		 jne	 SHORT $L270063

; 3415 : 		bMaster = TRUE;

  00050	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bMaster$[esp+84], 1
$L270063:

; 3416 : 
; 3417 : #ifdef __S_BUG_GC
; 3418 : 	pGCMemberAttacker = FindGuildCombatMember( pAttacker->m_idGuild );

  00058	8b 97 1c 07 00
	00		 mov	 edx, DWORD PTR [edi+1820]
  0005e	52		 push	 edx
  0005f	8b ce		 mov	 ecx, esi
  00061	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  00066	8b e8		 mov	 ebp, eax

; 3419 : 	if( pGCMemberAttacker != NULL )

  00068	85 ed		 test	 ebp, ebp
  0006a	0f 84 5f 03 00
	00		 je	 $L270053
  00070	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]

; 3420 : 	{
; 3421 : 		for( int veci = 0 ; veci < (int)( pGCMemberAttacker->vecGCSelectMember.size() ) ; ++veci )

  00073	33 c9		 xor	 ecx, ecx
$L270067:
  00075	85 d2		 test	 edx, edx
  00077	75 04		 jne	 SHORT $L314190
  00079	33 c0		 xor	 eax, eax
  0007b	eb 08		 jmp	 SHORT $L314191
$L314190:
  0007d	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00080	2b c2		 sub	 eax, edx
  00082	c1 f8 02	 sar	 eax, 2
$L314191:
  00085	3b c8		 cmp	 ecx, eax
  00087	0f 8d 42 03 00
	00		 jge	 $L270053
  0008d	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]

; 3422 : 		{
; 3423 : 			__JOINPLAYER* pJoinPlayer = pGCMemberAttacker->vecGCSelectMember[veci];

  00090	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
  00093	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 3424 : 			if( pJoinPlayer->uidPlayer == pAttacker->m_idPlayer )

  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	3b 87 38 02 00
	00		 cmp	 eax, DWORD PTR [edi+568]
  0009e	74 03		 je	 SHORT $L314982

; 3420 : 	{
; 3421 : 		for( int veci = 0 ; veci < (int)( pGCMemberAttacker->vecGCSelectMember.size() ) ; ++veci )

  000a0	41		 inc	 ecx
  000a1	eb d2		 jmp	 SHORT $L270067
$L314982:

; 3425 : 			{
; 3426 : 				pJoinPlayerAttacker = pJoinPlayer;
; 3427 : 				break;
; 3428 : 			}
; 3429 : 		}
; 3430 : 		if( pJoinPlayerAttacker == NULL )
; 3431 : 			return;
; 3432 : 
; 3433 : 		if( pJoinPlayerAttacker->uKillidGuild != 0 && pJoinPlayerAttacker->uKillidGuild != pDefender->m_idGuild )

  000a3	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000a6	85 c0		 test	 eax, eax
  000a8	74 14		 je	 SHORT $L314991
  000aa	8b 4c 24 5c	 mov	 ecx, DWORD PTR _pDefender$[esp+80]
  000ae	3b 81 1c 07 00
	00		 cmp	 eax, DWORD PTR [ecx+1820]
  000b4	74 08		 je	 SHORT $L314991

; 3434 : 			bKillDiffernceGuild = TRUE;

  000b6	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _bKillDiffernceGuild$[esp+84], 1
$L314991:

; 3435 : 
; 3436 : 		if( pJoinPlayerAttacker->nlife == 1 )

  000be	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	3b c8		 cmp	 ecx, eax
  000c8	75 04		 jne	 SHORT $L314993

; 3437 : 			bLastLife = TRUE;

  000ca	89 44 24 1c	 mov	 DWORD PTR _bLastLife$[esp+84], eax
$L314993:

; 3438 : 	}
; 3439 : #else // __S_BUG_GC
; 3440 : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( pAttacker->m_idGuild );
; 3441 : 	if( it != m_GuildCombatMem.end() )
; 3442 : 	{
; 3443 : 		pGCMemberAttacker	= it->second;
; 3444 : 		for( int veci = 0 ; veci < (int)( pGCMemberAttacker->vecGCSelectMember.size() ) ; ++veci )
; 3445 : 		{
; 3446 : 			__JOINPLAYER* pJoinPlayer = pGCMemberAttacker->vecGCSelectMember[veci];
; 3447 : 			if( pJoinPlayer->uidPlayer == pAttacker->m_idPlayer )
; 3448 : 			{
; 3449 : 				pJoinPlayerAttacker = pJoinPlayer;
; 3450 : 				break;
; 3451 : 			}
; 3452 : 		}
; 3453 : 		if( pJoinPlayerAttacker == NULL )
; 3454 : 			return;
; 3455 : 
; 3456 : 		if( pJoinPlayerAttacker->uKillidGuild != 0 && pJoinPlayerAttacker->uKillidGuild != pDefender->m_idGuild )
; 3457 : 			bKillDiffernceGuild = TRUE;
; 3458 : 
; 3459 : 		if( pJoinPlayerAttacker->nlife == 1 )
; 3460 : 			bLastLife = TRUE;
; 3461 : 	}	
; 3462 : #endif // __S_BUG_GC
; 3463 : 
; 3464 : 	if( pGCMemberAttacker == NULL )
; 3465 : 		return;
; 3466 : 
; 3467 : #ifdef __S_BUG_GC
; 3468 : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( pDefender->m_idGuild );

  000ce	8b 54 24 5c	 mov	 edx, DWORD PTR _pDefender$[esp+80]
  000d2	8b 82 1c 07 00
	00		 mov	 eax, DWORD PTR [edx+1820]
  000d8	8b 4c 24 24	 mov	 ecx, DWORD PTR _this$[esp+84]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 3469 : 	if( pGCMember != NULL )

  000e2	85 c0		 test	 eax, eax
  000e4	74 56		 je	 SHORT $L314994
  000e6	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 3470 : 	{
; 3471 : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  000e9	33 d2		 xor	 edx, edx
  000eb	eb 03 8d 49 00	 npad	 5
$L270080:
  000f0	85 ff		 test	 edi, edi
  000f2	75 04		 jne	 SHORT $L314253
  000f4	33 c9		 xor	 ecx, ecx
  000f6	eb 08		 jmp	 SHORT $L314254
$L314253:
  000f8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000fb	2b cf		 sub	 ecx, edi
  000fd	c1 f9 02	 sar	 ecx, 2
$L314254:
  00100	3b d1		 cmp	 edx, ecx
  00102	0f 8d c7 02 00
	00		 jge	 $L270053
  00108	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010b	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]

; 3472 : 		{
; 3473 : 			__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  0010e	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 3474 : 			if( pJoinPlayer->uidPlayer == pDefender->m_idPlayer )

  00110	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00112	8b 4c 24 5c	 mov	 ecx, DWORD PTR _pDefender$[esp+80]
  00116	3b 99 38 02 00
	00		 cmp	 ebx, DWORD PTR [ecx+568]
  0011c	74 03		 je	 SHORT $L314983

; 3470 : 	{
; 3471 : 		for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  0011e	42		 inc	 edx
  0011f	eb cf		 jmp	 SHORT $L270080
$L314983:

; 3475 : 			{
; 3476 : 				pJoinPlayerDefender = pJoinPlayer;
; 3477 : 				break;
; 3478 : 			}
; 3479 : 		}
; 3480 : 		if( pJoinPlayerDefender == NULL )
; 3481 : 			return;
; 3482 : 
; 3483 : 		if( pDefender->m_idPlayer == pGCMember->m_uidDefender )

  00121	8b 91 38 02 00
	00		 mov	 edx, DWORD PTR [ecx+568]
  00127	3b 50 1c	 cmp	 edx, DWORD PTR [eax+28]

; 3484 : 			bDefender = TRUE;

  0012a	8b 7c 24 58	 mov	 edi, DWORD PTR _pAttacker$[esp+80]
  0012e	8b 5c 24 20	 mov	 ebx, DWORD PTR _nGetPoint$[esp+84]
  00132	75 08		 jne	 SHORT $L314994
  00134	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _bDefender$[esp+84], 1
$L314994:

; 3485 : 	}	
; 3486 : #else // __S_BUG_GC
; 3487 : 	it = m_GuildCombatMem.find( pDefender->m_idGuild );
; 3488 : 	if( it != m_GuildCombatMem.end() )
; 3489 : 	{
; 3490 : 		__GuildCombatMember* pGCMember	= it->second;
; 3491 : 		for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 3492 : 		{
; 3493 : 			__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 3494 : 			if( pJoinPlayer->uidPlayer == pDefender->m_idPlayer )
; 3495 : 			{
; 3496 : 				pJoinPlayerDefender = pJoinPlayer;
; 3497 : 				break;
; 3498 : 			}
; 3499 : 		}
; 3500 : 		if( pJoinPlayerDefender == NULL )
; 3501 : 			return;
; 3502 : 
; 3503 : 		if( pDefender->m_idPlayer == pGCMember->m_uidDefender )
; 3504 : 			bDefender = TRUE;
; 3505 : 	}	
; 3506 : #endif // __S_BUG_GC
; 3507 : 
; 3508 : 	//    Kill  
; 3509 : 	if( bKillDiffernceGuild )

  0013c	8b 44 24 18	 mov	 eax, DWORD PTR _bKillDiffernceGuild$[esp+84]
  00140	85 c0		 test	 eax, eax
  00142	74 05		 je	 SHORT $L270087

; 3510 : 		++nGetPoint;

  00144	bb 03 00 00 00	 mov	 ebx, 3
$L270087:

; 3511 : 	//    Kill  
; 3512 : 	if( bMaster )

  00149	8b 44 24 10	 mov	 eax, DWORD PTR _bMaster$[esp+84]
  0014d	85 c0		 test	 eax, eax
  0014f	74 01		 je	 SHORT $L270088

; 3513 : 		++nGetPoint;

  00151	43		 inc	 ebx
$L270088:

; 3514 : 	//  Kill  
; 3515 : 	if( bDefender )

  00152	8b 44 24 14	 mov	 eax, DWORD PTR _bDefender$[esp+84]
  00156	85 c0		 test	 eax, eax
  00158	74 01		 je	 SHORT $L270089

; 3516 : 		++nGetPoint;

  0015a	43		 inc	 ebx
$L270089:

; 3517 : 	//  0  Kill  
; 3518 : 	if( bLastLife )

  0015b	8b 44 24 1c	 mov	 eax, DWORD PTR _bLastLife$[esp+84]
  0015f	85 c0		 test	 eax, eax
  00161	74 01		 je	 SHORT $L270090

; 3519 : 		++nGetPoint;

  00163	43		 inc	 ebx
$L270090:

; 3520 : 
; 3521 : 	pJoinPlayerAttacker->nPoint += nGetPoint;

  00164	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 3522 : 	pGCMemberAttacker->nGuildPoint += nGetPoint;

  00167	01 5d 28	 add	 DWORD PTR [ebp+40], ebx

; 3523 : 	
; 3524 : 	CGuild* pGuildMsg;
; 3525 : 	CGuildMember*	pMember;
; 3526 : 	CUser*			pUsertmp;
; 3527 : 
; 3528 : 	pGuildMsg = pAttacker->GetGuild();

  0016a	8b cf		 mov	 ecx, edi
  0016c	e8 00 00 00 00	 call	 ?GetGuild@CMover@@QAEPAVCGuild@@XZ ; CMover::GetGuild
  00171	8b f8		 mov	 edi, eax

; 3529 : 	if( pGuildMsg )

  00173	85 ff		 test	 edi, edi
  00175	0f 84 d2 00 00
	00		 je	 $L270105

; 3530 : 	{
; 3531 : 		for( map<u_long, CGuildMember*>::iterator i = pGuildMsg->m_mapPMember.begin();

  0017b	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  0017e	8b 30		 mov	 esi, DWORD PTR [eax]

; 3532 : 		i != pGuildMsg->m_mapPMember.end(); ++i )

  00180	3b f0		 cmp	 esi, eax
  00182	0f 84 c5 00 00
	00		 je	 $L270105
  00188	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L314488:

; 3533 : 		{
; 3534 : 			pMember		= i->second;
; 3535 : 			pUsertmp	= (CUser*)prj.GetUserByID( pMember->m_idPlayer );

  00190	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00193	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00196	8d 54 24 20	 lea	 edx, DWORD PTR $T314611[esp+84]
  0019a	52		 push	 edx
  0019b	8d 44 24 2c	 lea	 eax, DWORD PTR _i$314609[esp+88]
  0019f	89 4c 24 24	 mov	 DWORD PTR $T314611[esp+88], ecx
  001a3	50		 push	 eax
  001a4	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  001a9	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  001ae	8b 44 24 28	 mov	 eax, DWORD PTR _i$314609[esp+84]
  001b2	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  001b8	74 44		 je	 SHORT $L270104
  001ba	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 3536 : 			if( IsValidObj( pUsertmp ) && pUsertmp->GetWorld() && pUsertmp->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  001bd	85 c0		 test	 eax, eax
  001bf	74 3d		 je	 SHORT $L270104
  001c1	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  001c5	75 37		 jne	 SHORT $L270104
  001c7	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  001cd	85 c9		 test	 ecx, ecx
  001cf	74 2d		 je	 SHORT $L270104
  001d1	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  001d7	75 25		 jne	 SHORT $L270104

; 3537 : 			{
; 3538 : 				if( bMaster )

  001d9	8b 4c 24 10	 mov	 ecx, DWORD PTR _bMaster$[esp+84]
  001dd	85 c9		 test	 ecx, ecx

; 3539 : 					pUsertmp->AddDefinedCaption( TRUE, TID_GAME_GUILDCOMBAT_POINT_MASTER, "%d", nGetPoint );

  001df	53		 push	 ebx
  001e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  001e5	74 07		 je	 SHORT $L270108
  001e7	68 89 0b 00 00	 push	 2953			; 00000b89H

; 3540 : 				else 

  001ec	eb 05		 jmp	 SHORT $L314997
$L270108:

; 3541 : 					pUsertmp->AddDefinedCaption( TRUE, TID_GAME_GUILDCOMBAT_POINT_GENERAL, "%d", nGetPoint );

  001ee	68 8a 0b 00 00	 push	 2954			; 00000b8aH
$L314997:
  001f3	6a 01		 push	 1
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 ?AddDefinedCaption@CUser@@QAAXHHPBDZZ ; CUser::AddDefinedCaption
  001fb	83 c4 14	 add	 esp, 20			; 00000014H
$L270104:
  001fe	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  00201	84 c0		 test	 al, al
  00203	75 3f		 jne	 SHORT $L314471
  00205	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00208	8a 41 15	 mov	 al, BYTE PTR [ecx+21]
  0020b	84 c0		 test	 al, al
  0020d	75 18		 jne	 SHORT $L314978
  0020f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00211	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00214	84 d2		 test	 dl, dl
  00216	75 0b		 jne	 SHORT $L314486

; 3532 : 		i != pGuildMsg->m_mapPMember.end(); ++i )

$L314485:
  00218	8b c8		 mov	 ecx, eax
  0021a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0021c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0021f	84 d2		 test	 dl, dl
  00221	74 f5		 je	 SHORT $L314485
$L314486:
  00223	8b f1		 mov	 esi, ecx
  00225	eb 1d		 jmp	 SHORT $L314471
$L314978:
  00227	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0022a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0022d	84 c9		 test	 cl, cl
  0022f	75 11		 jne	 SHORT $L314474
$L314473:
  00231	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00234	75 0c		 jne	 SHORT $L314474
  00236	8b f0		 mov	 esi, eax
  00238	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0023b	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0023e	84 c9		 test	 cl, cl
  00240	74 ef		 je	 SHORT $L314473
$L314474:
  00242	8b f0		 mov	 esi, eax
$L314471:
  00244	3b 77 3c	 cmp	 esi, DWORD PTR [edi+60]
  00247	0f 85 43 ff ff
	ff		 jne	 $L314488
$L270105:

; 3542 : 			}
; 3543 : 		}
; 3544 : 	}
; 3545 : 
; 3546 : 	if( bDefender )

  0024d	8b 44 24 14	 mov	 eax, DWORD PTR _bDefender$[esp+84]
  00251	85 c0		 test	 eax, eax

; 3547 : 	{
; 3548 : 		pGuildMsg = pDefender->GetGuild();

  00253	8b 6c 24 5c	 mov	 ebp, DWORD PTR _pDefender$[esp+80]
  00257	0f 84 df 00 00
	00		 je	 $L314996
  0025d	8b cd		 mov	 ecx, ebp
  0025f	e8 00 00 00 00	 call	 ?GetGuild@CMover@@QAEPAVCGuild@@XZ ; CMover::GetGuild
  00264	8b f8		 mov	 edi, eax

; 3549 : 		if( pGuildMsg )

  00266	85 ff		 test	 edi, edi
  00268	0f 84 ce 00 00
	00		 je	 $L314996

; 3550 : 		{
; 3551 : 			for( map<u_long, CGuildMember*>::iterator i = pGuildMsg->m_mapPMember.begin();

  0026e	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00271	8b 30		 mov	 esi, DWORD PTR [eax]

; 3552 : 			i != pGuildMsg->m_mapPMember.end(); ++i )

  00273	3b f0		 cmp	 esi, eax
  00275	0f 84 c1 00 00
	00		 je	 $L314996
  0027b	eb 03 8d 49 00	 npad	 5
$L314814:

; 3553 : 			{
; 3554 : 				pMember		= i->second;
; 3555 : 				pUsertmp	= (CUser*)prj.GetUserByID( pMember->m_idPlayer );

  00280	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00283	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00286	8d 44 24 5c	 lea	 eax, DWORD PTR $T314936[esp+80]
  0028a	50		 push	 eax
  0028b	8d 4c 24 2c	 lea	 ecx, DWORD PTR _i$314914[esp+88]
  0028f	51		 push	 ecx
  00290	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00295	89 54 24 64	 mov	 DWORD PTR $T314936[esp+88], edx
  00299	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  0029e	8b 44 24 28	 mov	 eax, DWORD PTR _i$314914[esp+84]
  002a2	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  002a8	74 40		 je	 SHORT $L270121
  002aa	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 3556 : 				if( IsValidObj( pUsertmp ) && pUsertmp->GetWorld() && pUsertmp->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  002ad	85 c0		 test	 eax, eax
  002af	74 39		 je	 SHORT $L270121
  002b1	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  002b5	75 33		 jne	 SHORT $L270121
  002b7	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  002bd	85 c9		 test	 ecx, ecx
  002bf	74 29		 je	 SHORT $L270121
  002c1	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  002c7	75 21		 jne	 SHORT $L270121

; 3557 : 				{
; 3558 : 					if( pGuild )

  002c9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _pGuild$[esp+84]
  002cd	85 c9		 test	 ecx, ecx
  002cf	74 19		 je	 SHORT $L270121

; 3559 : 						pUsertmp->AddDefinedCaption( TRUE, TID_GAME_GUILDCOMBAT_POINT_DEFENDER, "\"%s\"", pGuild->m_szGuild );	

  002d1	83 c1 08	 add	 ecx, 8
  002d4	51		 push	 ecx
  002d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  002da	68 8b 0b 00 00	 push	 2955			; 00000b8bH
  002df	6a 01		 push	 1
  002e1	50		 push	 eax
  002e2	e8 00 00 00 00	 call	 ?AddDefinedCaption@CUser@@QAAXHHPBDZZ ; CUser::AddDefinedCaption
  002e7	83 c4 14	 add	 esp, 20			; 00000014H
$L270121:
  002ea	8a 46 15	 mov	 al, BYTE PTR [esi+21]
  002ed	84 c0		 test	 al, al
  002ef	75 42		 jne	 SHORT $L314810
  002f1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  002f4	8a 41 15	 mov	 al, BYTE PTR [ecx+21]
  002f7	84 c0		 test	 al, al
  002f9	75 18		 jne	 SHORT $L314981
  002fb	8b 01		 mov	 eax, DWORD PTR [ecx]
  002fd	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00300	84 d2		 test	 dl, dl
  00302	75 0b		 jne	 SHORT $L314799

; 3552 : 			i != pGuildMsg->m_mapPMember.end(); ++i )

$L314798:
  00304	8b c8		 mov	 ecx, eax
  00306	8b 01		 mov	 eax, DWORD PTR [ecx]
  00308	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0030b	84 d2		 test	 dl, dl
  0030d	74 f5		 je	 SHORT $L314798
$L314799:
  0030f	8b f1		 mov	 esi, ecx
  00311	eb 20		 jmp	 SHORT $L314810
$L314981:
  00313	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00316	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  00319	84 c9		 test	 cl, cl
  0031b	75 14		 jne	 SHORT $L314813
  0031d	8d 49 00	 npad	 3
$L314812:
  00320	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00323	75 0c		 jne	 SHORT $L314813
  00325	8b f0		 mov	 esi, eax
  00327	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0032a	8a 48 15	 mov	 cl, BYTE PTR [eax+21]
  0032d	84 c9		 test	 cl, cl
  0032f	74 ef		 je	 SHORT $L314812
$L314813:
  00331	8b f0		 mov	 esi, eax
$L314810:
  00333	3b 77 3c	 cmp	 esi, DWORD PTR [edi+60]
  00336	0f 85 44 ff ff
	ff		 jne	 $L314814
$L314996:

; 3560 : 				}
; 3561 : 			}
; 3562 : 		}
; 3563 : 	}
; 3564 : 	AddvecGCGetPoint( pAttacker->m_idGuild, pDefender->m_idGuild, pAttacker->m_idPlayer, pDefender->m_idPlayer, nGetPoint, bKillDiffernceGuild, bMaster, bDefender, bLastLife );

  0033c	8b 44 24 58	 mov	 eax, DWORD PTR _pAttacker$[esp+80]
  00340	8b 90 1c 07 00
	00		 mov	 edx, DWORD PTR [eax+1820]
  00346	8b 8d 1c 07 00
	00		 mov	 ecx, DWORD PTR [ebp+1820]
  0034c	89 4c 24 34	 mov	 DWORD PTR _GCGetPoint$314966[esp+88], ecx
  00350	8b 4c 24 18	 mov	 ecx, DWORD PTR _bKillDiffernceGuild$[esp+84]
  00354	89 54 24 30	 mov	 DWORD PTR _GCGetPoint$314966[esp+84], edx
  00358	8b 90 38 02 00
	00		 mov	 edx, DWORD PTR [eax+568]
  0035e	8b 85 38 02 00
	00		 mov	 eax, DWORD PTR [ebp+568]
  00364	89 4c 24 44	 mov	 DWORD PTR _GCGetPoint$314966[esp+104], ecx
  00368	8b 4c 24 1c	 mov	 ecx, DWORD PTR _bLastLife$[esp+84]
  0036c	89 54 24 38	 mov	 DWORD PTR _GCGetPoint$314966[esp+92], edx
  00370	8b 54 24 10	 mov	 edx, DWORD PTR _bMaster$[esp+84]
  00374	89 4c 24 50	 mov	 DWORD PTR _GCGetPoint$314966[esp+116], ecx
  00378	8b 4c 24 24	 mov	 ecx, DWORD PTR _this$[esp+84]
  0037c	89 54 24 48	 mov	 DWORD PTR _GCGetPoint$314966[esp+108], edx
  00380	89 44 24 3c	 mov	 DWORD PTR _GCGetPoint$314966[esp+96], eax
  00384	8b 44 24 14	 mov	 eax, DWORD PTR _bDefender$[esp+84]
  00388	8d 54 24 30	 lea	 edx, DWORD PTR _GCGetPoint$314966[esp+84]
  0038c	52		 push	 edx
  0038d	83 c1 50	 add	 ecx, 80			; 00000050H
  00390	89 5c 24 44	 mov	 DWORD PTR _GCGetPoint$314966[esp+104], ebx
  00394	89 44 24 50	 mov	 DWORD PTR _GCGetPoint$314966[esp+116], eax
  00398	e8 00 00 00 00	 call	 ?push_back@?$vector@U__GCGETPOINT@CGuildCombat@@V?$allocator@U__GCGETPOINT@CGuildCombat@@@std@@@std@@QAEXABU__GCGETPOINT@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GCGETPOINT,std::allocator<CGuildCombat::__GCGETPOINT> >::push_back
  0039d	83 ec 24	 sub	 esp, 36			; 00000024H
  003a0	8b fc		 mov	 edi, esp
  003a2	b9 09 00 00 00	 mov	 ecx, 9
  003a7	8d 74 24 54	 lea	 esi, DWORD PTR _GCGetPoint$314966[esp+120]
  003ab	f3 a5		 rep movsd
  003ad	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  003b2	e8 00 00 00 00	 call	 ?AddGCLogRealTimeWorld@CUserMng@@QAEXU__GCGETPOINT@CGuildCombat@@@Z ; CUserMng::AddGCLogRealTimeWorld

; 3565 : 	g_UserMng.AddGCGuildPrecedence();

  003b7	6a 00		 push	 0
  003b9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  003be	e8 00 00 00 00	 call	 ?AddGCGuildPrecedence@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddGCGuildPrecedence

; 3566 : 	g_UserMng.AddGCPlayerPrecedence();

  003c3	6a 00		 push	 0
  003c5	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  003ca	e8 00 00 00 00	 call	 ?AddGCPlayerPrecedence@CUserMng@@QAEXPAVCUser@@@Z ; CUserMng::AddGCPlayerPrecedence
$L270053:

; 3567 : }

  003cf	5f		 pop	 edi
  003d0	5e		 pop	 esi
  003d1	5d		 pop	 ebp
  003d2	5b		 pop	 ebx
  003d3	83 c4 44	 add	 esp, 68			; 00000044H
  003d6	c2 08 00	 ret	 8
?GetPoint@CGuildCombat@@QAEXPAVCUser@@0@Z ENDP		; CGuildCombat::GetPoint
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCGuildCombat@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGuildCombat@@UAEPAXI@Z PROC NEAR			; CGuildCombat::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CGuildCombat@@UAE@XZ	; CGuildCombat::~CGuildCombat
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L315001
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L315001:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCGuildCombat@@UAEPAXI@Z ENDP			; CGuildCombat::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?JoinGuildCombat@CGuildCombat@@QAEXKKH@Z	; CGuildCombat::JoinGuildCombat
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.h
xdata$x	SEGMENT
$T315017 DD	0ffffffffH
	DD	FLAT:$L315009
$T315015 DD	019930520H
	DD	01H
	DD	FLAT:$T315017
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ?JoinGuildCombat@CGuildCombat@@QAEXKKH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T315006 = 8						; size = 4
_pGCMember$ = 8						; size = 4
_idGuild$ = 8						; size = 4
_dwPenya$ = 12						; size = 4
_bRequest$ = 16						; size = 4
?JoinGuildCombat@CGuildCombat@@QAEXKKH@Z PROC NEAR	; CGuildCombat::JoinGuildCombat, COMDAT
; _this$ = ecx

; 430  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?JoinGuildCombat@CGuildCombat@@QAEXKKH@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	53		 push	 ebx
  00016	55		 push	 ebp

; 431  : #ifdef __S_BUG_GC
; 432  : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( idGuild );

  00017	8b 6c 24 18	 mov	 ebp, DWORD PTR _idGuild$[esp+16]
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	55		 push	 ebp
  0001e	8b d9		 mov	 ebx, ecx
  00020	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember

; 433  : 	if( pGCMember != NULL )

  00025	33 ff		 xor	 edi, edi
  00027	3b c7		 cmp	 eax, edi
  00029	74 10		 je	 SHORT $L268385

; 434  : 	{
; 435  : 		pGCMember->dwPenya = dwPenya;		

  0002b	8b 4c 24 24	 mov	 ecx, DWORD PTR _dwPenya$[esp+24]

; 436  : 		pGCMember->bRequest = bRequest;

  0002f	8b 54 24 28	 mov	 edx, DWORD PTR _bRequest$[esp+24]
  00033	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00036	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 437  : 	}
; 438  : 	else

  00039	eb 67		 jmp	 SHORT $L268386
$L268385:

; 439  : 	{
; 440  : 		pGCMember	= new __GuildCombatMember;

  0003b	6a 38		 push	 56			; 00000038H
  0003d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00042	83 c4 04	 add	 esp, 4
  00045	89 44 24 20	 mov	 DWORD PTR $T315006[esp+24], eax
  00049	3b c7		 cmp	 eax, edi
  0004b	89 7c 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], edi
  0004f	74 0b		 je	 SHORT $L315007
  00051	8b c8		 mov	 ecx, eax
  00053	e8 00 00 00 00	 call	 ??0__GuildCombatMember@CGuildCombat@@QAE@XZ
  00058	8b f0		 mov	 esi, eax
  0005a	eb 02		 jmp	 SHORT $L315008
$L315007:
  0005c	33 f6		 xor	 esi, esi
$L315008:

; 441  : 		pGCMember->Clear();

  0005e	8b ce		 mov	 ecx, esi
  00060	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  00068	89 74 24 20	 mov	 DWORD PTR _pGCMember$[esp+24], esi
  0006c	89 3e		 mov	 DWORD PTR [esi], edi
  0006e	e8 00 00 00 00	 call	 ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ ; CGuildCombat::__GuildCombatMember::SelectMemberClear

; 442  : 		pGCMember->uGuildId = idGuild;
; 443  : 		pGCMember->dwPenya = dwPenya;

  00073	8b 44 24 24	 mov	 eax, DWORD PTR _dwPenya$[esp+24]

; 444  : 		pGCMember->bRequest = bRequest;

  00077	8b 4c 24 28	 mov	 ecx, DWORD PTR _bRequest$[esp+24]
  0007b	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0007e	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  00081	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00084	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00087	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0008a	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  0008d	89 2e		 mov	 DWORD PTR [esi], ebp
  0008f	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 445  : 		m_vecGuildCombatMem.push_back( pGCMember );

  00092	8d 54 24 20	 lea	 edx, DWORD PTR _pGCMember$[esp+24]
  00096	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00099	52		 push	 edx
  0009a	8d 4b 70	 lea	 ecx, DWORD PTR [ebx+112]
  0009d	e8 00 00 00 00	 call	 ?push_back@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QAEXABQAU__GuildCombatMember@CGuildCombat@@@Z ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::push_back
$L268386:

; 446  : 	}
; 447  : #else // __S_BUG_GC
; 448  : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( idGuild );
; 449  : 	if( it != m_GuildCombatMem.end() )
; 450  : 	{
; 451  : 		__GuildCombatMember* pGCMember = it->second;
; 452  : 		pGCMember->dwPenya = dwPenya;		
; 453  : 		pGCMember->bRequest = bRequest;
; 454  : 	}
; 455  : 	else
; 456  : 	{
; 457  : 		__GuildCombatMember* pGCMember	= new __GuildCombatMember;
; 458  : 		pGCMember->Clear();
; 459  : 		pGCMember->dwPenya = dwPenya;
; 460  : 		pGCMember->bRequest = bRequest;
; 461  : 		m_GuildCombatMem.insert( map<u_long, __GuildCombatMember*>::value_type( idGuild, pGCMember ) );
; 462  : 	}
; 463  : #endif // __S_BUG_GC
; 464  : 
; 465  : 	SetRequestRanking();

  000a2	8b cb		 mov	 ecx, ebx
  000a4	e8 00 00 00 00	 call	 ?SetRequestRanking@CGuildCombat@@QAEXXZ ; CGuildCombat::SetRequestRanking

; 466  : }

  000a9	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5d		 pop	 ebp
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000b7	5b		 pop	 ebx
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L315009:
  00000	8b 45 04	 mov	 eax, DWORD PTR $T315006[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?JoinGuildCombat@CGuildCombat@@QAEXKKH@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T315015
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?JoinGuildCombat@CGuildCombat@@QAEXKKH@Z ENDP		; CGuildCombat::JoinGuildCombat
PUBLIC	?OutGuildCombat@CGuildCombat@@QAEXK@Z		; CGuildCombat::OutGuildCombat
;	COMDAT xdata$x
xdata$x	SEGMENT
$T315030 DD	0ffffffffH
	DD	FLAT:$L315024
$T315027 DD	019930520H
	DD	01H
	DD	FLAT:$T315030
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?OutGuildCombat@CGuildCombat@@QAEXK@Z
_TEXT	SEGMENT
_itemElem$268402 = -2200				; size = 184
_szMsg1$268405 = -2016					; size = 1000
_szMsg$268403 = -1016					; size = 1000
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_idGuild$ = 8						; size = 4
?OutGuildCombat@CGuildCombat@@QAEXK@Z PROC NEAR		; CGuildCombat::OutGuildCombat, COMDAT
; _this$ = ecx

; 469  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?OutGuildCombat@CGuildCombat@@QAEXK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 8c 08 00
	00		 sub	 esp, 2188		; 0000088cH
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	53		 push	 ebx
  00023	8b d9		 mov	 ebx, ecx

; 470  : 	if( !g_eLocal.GetState( EVE_GUILDCOMBAT ) )

  00025	6a 0f		 push	 15			; 0000000fH
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0002c	89 84 24 90 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2208], eax
  00033	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00038	84 c0		 test	 al, al
  0003a	0f 84 fd 00 00
	00		 je	 $L268396
  00040	56		 push	 esi
  00041	57		 push	 edi

; 471  : 		return; 
; 472  : 	
; 473  : #ifdef __S_BUG_GC
; 474  : 	__GuildCombatMember* pGCMember = FindGuildCombatMember( idGuild );

  00042	8b bc 24 a8 08
	00 00		 mov	 edi, DWORD PTR _idGuild$[esp+2208]
  00049	57		 push	 edi
  0004a	8b cb		 mov	 ecx, ebx
  0004c	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  00051	8b f0		 mov	 esi, eax

; 475  : 	if( pGCMember != NULL ) //    

  00053	85 f6		 test	 esi, esi
  00055	0f 84 d9 00 00
	00		 je	 $L268399

; 476  : 	{
; 477  : 		CGuild* pGuild = g_GuildMng.GetGuild( idGuild );

  0005b	57		 push	 edi
  0005c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00061	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild
  00066	8b f8		 mov	 edi, eax

; 478  : 		if( pGuild && pGCMember->bRequest )

  00068	85 ff		 test	 edi, edi
  0006a	0f 84 b6 00 00
	00		 je	 $L268401
  00070	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00073	85 c0		 test	 eax, eax
  00075	0f 84 ab 00 00
	00		 je	 $L268401

; 479  : 		{
; 480  : 			CItemElem itemElem;

  0007b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _itemElem$268402[esp+2212]
  0007f	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 481  : 			char szMsg[1000];
; 482  : 			sprintf( szMsg, "%s", prj.GetText( TID_GAME_GC_CANCELREQUEST ) );

  00084	68 e8 0b 00 00	 push	 3048			; 00000be8H
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0008e	c7 84 24 a4 08
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+2224], 0
  00099	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0009e	50		 push	 eax
  0009f	8d 84 24 b0 04
	00 00		 lea	 eax, DWORD PTR _szMsg$268403[esp+2216]
  000a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _sprintf
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 483  : 			char szMsg1[1000];
; 484  : 			sprintf( szMsg1, "%s", prj.GetText( TID_GAME_GC_CANCELREQUEST1 ) );

  000b4	68 e9 0b 00 00	 push	 3049			; 00000be9H
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000be	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  000c3	50		 push	 eax
  000c4	8d 8c 24 c8 00
	00 00		 lea	 ecx, DWORD PTR _szMsg1$268405[esp+2216]
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _sprintf

; 485  : 			g_dpDBClient.SendQueryPostMail( pGuild->m_idMaster, 0, itemElem, MulDiv( pGCMember->dwPenya, m_nRequestCanclePercent, 100 ), szMsg, szMsg1 );

  000d6	8b 8b bc 10 00
	00		 mov	 ecx, DWORD PTR [ebx+4284]
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	8d 94 24 c4 00
	00 00		 lea	 edx, DWORD PTR _szMsg1$268405[esp+2212]
  000e6	52		 push	 edx
  000e7	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000ea	8d 84 24 b0 04
	00 00		 lea	 eax, DWORD PTR _szMsg$268403[esp+2216]
  000f1	50		 push	 eax
  000f2	6a 64		 push	 100			; 00000064H
  000f4	51		 push	 ecx
  000f5	52		 push	 edx
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  000fc	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  000ff	50		 push	 eax
  00100	8d 44 24 18	 lea	 eax, DWORD PTR _itemElem$268402[esp+2224]
  00104	50		 push	 eax
  00105	6a 00		 push	 0
  00107	51		 push	 ecx
  00108	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0010d	e8 00 00 00 00	 call	 ?SendQueryPostMail@CDPDatabaseClient@@QAEXKKAAVCItemElem@@HPAD1@Z ; CDPDatabaseClient::SendQueryPostMail

; 486  : 		}		

  00112	8d 4c 24 0c	 lea	 ecx, DWORD PTR _itemElem$268402[esp+2212]
  00116	c7 84 24 a0 08
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+2220], -1
  00121	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L268401:

; 487  : 		pGCMember->bRequest = FALSE;

  00126	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 488  : 		pGCMember->dwPenya = 0;

  0012d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$L268399:

; 489  : 	}
; 490  : #else // __S_BUG_GC
; 491  : 	map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( idGuild );
; 492  : 	if( it != m_GuildCombatMem.end() )
; 493  : 	{
; 494  : 		__GuildCombatMember* pGCMember = it->second;
; 495  : 
; 496  : 		//    
; 497  : 		CGuild* pGuild = g_GuildMng.GetGuild( idGuild );
; 498  : 		if( pGuild && pGCMember->bRequest )
; 499  : 		{
; 500  : 			CItemElem itemElem;
; 501  : 			char szMsg[1000];
; 502  : 			sprintf( szMsg, "%s", prj.GetText( TID_GAME_GC_CANCELREQUEST ) );
; 503  : 			char szMsg1[1000];
; 504  : 			sprintf( szMsg1, "%s", prj.GetText( TID_GAME_GC_CANCELREQUEST1 ) );
; 505  : 			g_dpDBClient.SendQueryPostMail( pGuild->m_idMaster, 0, itemElem, MulDiv( pGCMember->dwPenya, m_nRequestCanclePercent, 100 ), szMsg, szMsg1 );
; 506  : 		}		
; 507  : 		pGCMember->bRequest = FALSE;
; 508  : 		pGCMember->dwPenya = 0;
; 509  : 	}
; 510  : #endif // __S_BUG_GC
; 511  : 	SetRequestRanking();

  00134	8b cb		 mov	 ecx, ebx
  00136	e8 00 00 00 00	 call	 ?SetRequestRanking@CGuildCombat@@QAEXXZ ; CGuildCombat::SetRequestRanking
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
$L268396:

; 512  : }

  0013d	8b 8c 24 90 08
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+2204]
  00144	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014b	8b 8c 24 8c 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2204]
  00152	5b		 pop	 ebx
  00153	33 cc		 xor	 ecx, esp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	81 c4 98 08 00
	00		 add	 esp, 2200		; 00000898H
  00160	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L315024:
  00000	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR _itemElem$268402[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
__ehhandler$?OutGuildCombat@CGuildCombat@@QAEXK@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T315027
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?OutGuildCombat@CGuildCombat@@QAEXK@Z ENDP		; CGuildCombat::OutGuildCombat
PUBLIC	??_C@_09BBHEADKN@GUILDBANK?$AA@			; `string'
PUBLIC	??_C@_09PKCFHHL@?5?5?9?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BA@PDOEFPGE@GUILDCOMBAT_NOT?$AA@		; `string'
PUBLIC	?GuildCombatResult@CGuildCombat@@QAEXHK@Z	; CGuildCombat::GuildCombatResult
EXTRN	?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z:NEAR ; CUserMng::AddWorldCreateSfxObj
EXTRN	?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z:NEAR ; CUserMng::AddPutItemElem
EXTRN	?AddGCWinGuild@CUserMng@@QAEXXZ:NEAR		; CUserMng::AddGCWinGuild
EXTRN	?AddGCBestPlayer@CUserMng@@QAEXXZ:NEAR		; CUserMng::AddGCBestPlayer
EXTRN	?AddGCLogWorld@CUserMng@@QAEXXZ:NEAR		; CUserMng::AddGCLogWorld
EXTRN	?UpdateGuildBank@CDPSrvr@@QAEXPAVCGuild@@HEKPAVCItemElem@@KF@Z:NEAR ; CDPSrvr::UpdateGuildBank
EXTRN	?SendPlayMusic@CDPCoreClient@@QAEXKK@Z:NEAR	; CDPCoreClient::SendPlayMusic
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T319080 DD	0ffffffffH
	DD	FLAT:$L315037
	DD	00H
	DD	FLAT:$L315038
	DD	00H
	DD	FLAT:$L315039
	DD	00H
	DD	FLAT:$L315040
	DD	03H
	DD	FLAT:$L315041
	DD	04H
	DD	FLAT:$L315042
	DD	05H
	DD	FLAT:$L315043
$T319025 DD	019930520H
	DD	07H
	DD	FLAT:$T319080
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_09BBHEADKN@GUILDBANK?$AA@
CONST	SEGMENT
??_C@_09BBHEADKN@GUILDBANK?$AA@ DB 'GUILDBANK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKCFHHL@?5?5?9?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_09PKCFHHL@?5?5?9?5?$CFs?5?$CFs?$AA@ DB '  - %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDOEFPGE@GUILDCOMBAT_NOT?$AA@
CONST	SEGMENT
??_C@_0BA@PDOEFPGE@GUILDCOMBAT_NOT?$AA@ DB 'GUILDCOMBAT_NOT', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
CONST	ENDS
;	COMDAT ?GuildCombatResult@CGuildCombat@@QAEXHK@Z
_TEXT	SEGMENT
_strGuildMsg$268911 = -1192				; size = 4
_fAvgLv$268881 = -1192					; size = 4
_vecSame$268855 = -1192					; size = 4
_nVeci$268832 = -1192					; size = 4
_uBestPlayerGuild$268928 = -1188			; size = 4
_strItemMsg$268923 = -1188				; size = 4
_vecSame$268876 = -1188					; size = 4
_nMaxLife$ = -1188					; size = 4
_nMaxPoint$ = -1188					; size = 4
_vecSameidGuildWinTmp$268875 = -1184			; size = 16
_vecSameidGuildWinTmp$268854 = -1184			; size = 16
_si$268912 = -1168					; size = 4
_fMaxAvgLv$ = -1168					; size = 4
$T319023 = -1164					; size = 4
tv1943 = -1160						; size = 4
_pGuild$268904 = -1160					; size = 4
_nBufWinGuildCount$268909 = -1156			; size = 4
_nSubLevel$268882 = -1156				; size = 4
_vecSameidGuildWin$ = -1152				; size = 16
tv3081 = -1136						; size = 4
$T317214 = -1136					; size = 4
_nGetPoint$268929 = -1136				; size = 4
_nValidObjCount$268883 = -1132				; size = 4
__Cat$318822 = -1128					; size = 1
_i$317192 = -1128					; size = 4
_strPrizeMsg$ = -1128					; size = 4
_RequestGuild$268838 = -1128				; size = 8
_itemElem$268918 = -1120				; size = 184
_aLogItem$268926 = -936					; size = 200
_aLogItem$268920 = -736					; size = 200
_str$ = -536						; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_nResult$ = 8						; size = 4
_idGuildWin$ = 12					; size = 4
?GuildCombatResult@CGuildCombat@@QAEXHK@Z PROC NEAR	; CGuildCombat::GuildCombatResult, COMDAT
; _this$ = ecx

; 1065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GuildCombatResult@CGuildCombat@@QAEXHK@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec a0 04 00
	00		 sub	 esp, 1184		; 000004a0H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	53		 push	 ebx
  00027	33 c5		 xor	 eax, ebp
  00029	56		 push	 esi
  0002a	8b d9		 mov	 ebx, ecx
  0002c	89 84 24 a0 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1204], eax
  00033	57		 push	 edi

; 1305 : #if __VER < 11 // __GUILDCOMBATCHIP
; 1306 : 			strGuildMsg.Format( prj.GetText(TID_GAME_GUILDCOMBAT_PRIZEMSG), pGuild->m_szGuild, m_nWinGuildCount );
; 1307 : 			m_vecstrGuildMsg.push_back( strGuildMsg );
; 1308 : 			strGuildMsg.Format( prj.GetText(TID_GAME_GUILDCOMBAT_PRIZEMSG1 ) );
; 1309 : 			m_vecstrGuildMsg.push_back( strGuildMsg );
; 1310 : #endif // __GUILDCOMBATCHIP
; 1311 : 			for( int si = 0 ; si < (int)( vecGCSendItem.size() ) ; ++si )

  00034	89 5c 24 2c	 mov	 DWORD PTR $T319023[esp+1208], ebx
  00038	33 ff		 xor	 edi, edi
  0003a	33 d2		 xor	 edx, edx
  0003c	89 bc 24 b4 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1216], edi
  00043	89 7c 24 3c	 mov	 DWORD PTR _vecSameidGuildWin$[esp+1212], edi
  00047	89 7c 24 40	 mov	 DWORD PTR _vecSameidGuildWin$[esp+1216], edi
  0004b	89 7c 24 44	 mov	 DWORD PTR _vecSameidGuildWin$[esp+1220], edi
  0004f	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _nMaxPoint$[esp+1208], -1
  00057	89 54 24 10	 mov	 DWORD PTR _nVeci$268832[esp+1208], edx
  0005b	eb 03 8d 49 00	 npad	 5
$L268834:
  00060	8b 8b 14 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4372]
  00066	3b cf		 cmp	 ecx, edi
  00068	75 04		 jne	 SHORT $L315153

; 1066 : 	vector<u_long> vecSameidGuildWin; 
; 1067 : 	vecSameidGuildWin.clear();
; 1068 : 	int nMaxPoint = -1;
; 1069 : 
; 1070 : 	//    (      vecSameidGuildWin  )
; 1071 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  0006a	33 c0		 xor	 eax, eax
  0006c	eb 0b		 jmp	 SHORT $L315154
$L315153:
  0006e	8b 83 18 11 00
	00		 mov	 eax, DWORD PTR [ebx+4376]
  00074	2b c1		 sub	 eax, ecx
  00076	c1 f8 03	 sar	 eax, 3
$L315154:
  00079	3b d0		 cmp	 edx, eax
  0007b	0f 8d fd 00 00
	00		 jge	 $L319041

; 1072 : 	{
; 1073 : 		if( nVeci >= m_nMaxGuild )

  00081	3b 93 a0 10 00
	00		 cmp	 edx, DWORD PTR [ebx+4256]
  00087	0f 8d f1 00 00
	00		 jge	 $L319041
  0008d	8b 83 14 11 00
	00		 mov	 eax, DWORD PTR [ebx+4372]

; 1074 : 			break;
; 1075 : 		
; 1076 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  00093	8b 0c d0	 mov	 ecx, DWORD PTR [eax+edx*8]
  00096	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00099	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1077 : #ifdef __S_BUG_GC
; 1078 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  0009c	51		 push	 ecx
  0009d	8b cb		 mov	 ecx, ebx
  0009f	89 54 24 58	 mov	 DWORD PTR _RequestGuild$268838[esp+1216], edx
  000a3	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  000a8	8b f0		 mov	 esi, eax

; 1079 : 		if( pGCMember != NULL )

  000aa	3b f7		 cmp	 esi, edi
  000ac	0f 84 ba 00 00
	00		 je	 $L268835
  000b2	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1080 : 		{
; 1081 : 			int nPoint = 0;

  000b5	33 d2		 xor	 edx, edx

; 1082 : 			for( int veci = 0 ; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  000b7	33 c9		 xor	 ecx, ecx
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$L268844:
  000c0	85 ff		 test	 edi, edi
  000c2	75 04		 jne	 SHORT $L315216
  000c4	33 c0		 xor	 eax, eax
  000c6	eb 08		 jmp	 SHORT $L315217
$L315216:
  000c8	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000cb	2b c7		 sub	 eax, edi
  000cd	c1 f8 02	 sar	 eax, 2
$L315217:
  000d0	3b c8		 cmp	 ecx, eax
  000d2	7d 15		 jge	 SHORT $L268846

; 1083 : 			{
; 1084 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];

  000d4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d7	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1085 : 				nPoint += pJoinPlayer->nPoint + pJoinPlayer->nlife;

  000da	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  000dd	03 58 04	 add	 ebx, DWORD PTR [eax+4]
  000e0	03 d3		 add	 edx, ebx
  000e2	8b 5c 24 2c	 mov	 ebx, DWORD PTR $T319023[esp+1208]
  000e6	41		 inc	 ecx
  000e7	eb d7		 jmp	 SHORT $L268844
$L268846:

; 1086 : 			}
; 1087 : 			pGCMember->nGuildPoint = nPoint;
; 1088 : 			//  
; 1089 : 			if( nMaxPoint < nPoint )

  000e9	8b 44 24 14	 mov	 eax, DWORD PTR _nMaxPoint$[esp+1208]
  000ed	3b c2		 cmp	 eax, edx
  000ef	89 56 28	 mov	 DWORD PTR [esi+40], edx
  000f2	7d 2b		 jge	 SHORT $L319073

; 1090 : 			{
; 1091 : 				nMaxPoint = nPoint;
; 1092 : 				vecSameidGuildWin.clear();

  000f4	8b 44 24 3c	 mov	 eax, DWORD PTR _vecSameidGuildWin$[esp+1212]
  000f8	33 ff		 xor	 edi, edi
  000fa	3b c7		 cmp	 eax, edi
  000fc	89 54 24 14	 mov	 DWORD PTR _nMaxPoint$[esp+1208], edx
  00100	74 09		 je	 SHORT $L315291
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00108	83 c4 04	 add	 esp, 4
$L315291:

; 1093 : 				vecSameidGuildWin.push_back( pGCMember->uGuildId );

  0010b	56		 push	 esi
  0010c	33 c0		 xor	 eax, eax
  0010e	6a 01		 push	 1
  00110	89 7c 24 44	 mov	 DWORD PTR _vecSameidGuildWin$[esp+1220], edi
  00114	89 7c 24 48	 mov	 DWORD PTR _vecSameidGuildWin$[esp+1224], edi
  00118	89 7c 24 4c	 mov	 DWORD PTR _vecSameidGuildWin$[esp+1228], edi
  0011c	50		 push	 eax

; 1094 : 			}
; 1095 : 			else if( nMaxPoint == nPoint )

  0011d	eb 44		 jmp	 SHORT $L319074
$L319073:
  0011f	75 4b		 jne	 SHORT $L268835

; 1096 : 			{
; 1097 : 				vecSameidGuildWin.push_back( pGCMember->uGuildId );

  00121	8b 7c 24 3c	 mov	 edi, DWORD PTR _vecSameidGuildWin$[esp+1212]
  00125	85 ff		 test	 edi, edi
  00127	8b 54 24 40	 mov	 edx, DWORD PTR _vecSameidGuildWin$[esp+1216]
  0012b	74 32		 je	 SHORT $L315726
  0012d	8b 4c 24 44	 mov	 ecx, DWORD PTR _vecSameidGuildWin$[esp+1220]
  00131	8b c2		 mov	 eax, edx
  00133	2b c7		 sub	 eax, edi
  00135	2b cf		 sub	 ecx, edi
  00137	c1 f8 02	 sar	 eax, 2
  0013a	c1 f9 02	 sar	 ecx, 2
  0013d	3b c1		 cmp	 eax, ecx
  0013f	73 1e		 jae	 SHORT $L315726
  00141	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00143	8b 44 24 10	 mov	 eax, DWORD PTR _nVeci$268832[esp+1208]
  00147	83 c2 04	 add	 edx, 4
  0014a	89 4a fc	 mov	 DWORD PTR [edx-4], ecx
  0014d	40		 inc	 eax
  0014e	89 54 24 40	 mov	 DWORD PTR _vecSameidGuildWin$[esp+1216], edx
  00152	89 44 24 10	 mov	 DWORD PTR _nVeci$268832[esp+1208], eax
  00156	8b d0		 mov	 edx, eax
  00158	33 ff		 xor	 edi, edi
  0015a	e9 01 ff ff ff	 jmp	 $L268834
$L315726:
  0015f	56		 push	 esi
  00160	6a 01		 push	 1
  00162	52		 push	 edx
$L319074:
  00163	8d 4c 24 44	 lea	 ecx, DWORD PTR _vecSameidGuildWin$[esp+1220]
  00167	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
$L268835:
  0016c	8b 44 24 10	 mov	 eax, DWORD PTR _nVeci$268832[esp+1208]
  00170	40		 inc	 eax
  00171	89 44 24 10	 mov	 DWORD PTR _nVeci$268832[esp+1208], eax
  00175	8b d0		 mov	 edx, eax
  00177	33 ff		 xor	 edi, edi
  00179	e9 e2 fe ff ff	 jmp	 $L268834
$L319041:

; 1098 : 			}
; 1099 : 		}
; 1100 : #else // __S_BUG_GC
; 1101 : 		map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 1102 : 		if( it != m_GuildCombatMem.end() )
; 1103 : 		{
; 1104 : 			int nPoint = 0;
; 1105 : 			__GuildCombatMember* pGCMember = it->second;
; 1106 : 			for( int veci = 0 ; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 1107 : 			{
; 1108 : 				__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci];
; 1109 : 				nPoint += pJoinPlayer->nPoint + pJoinPlayer->nlife;
; 1110 : 			}
; 1111 : 			pGCMember->nGuildPoint = nPoint;
; 1112 : 			//  
; 1113 : 			if( nMaxPoint < nPoint )
; 1114 : 			{
; 1115 : 				nMaxPoint = nPoint;
; 1116 : 				vecSameidGuildWin.clear();
; 1117 : 				vecSameidGuildWin.push_back( it->first );
; 1118 : 			}
; 1119 : 			else if( nMaxPoint == nPoint )
; 1120 : 			{
; 1121 : 				vecSameidGuildWin.push_back( it->first );
; 1122 : 			}
; 1123 : 		}
; 1124 : #endif // __S_BUG_GC
; 1125 : 	}
; 1126 : 
; 1127 : 	//         
; 1128 : 	int nMaxLife = 0;
; 1129 : 	if( 1 < vecSameidGuildWin.size() )

  0017e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _vecSameidGuildWin$[esp+1212]
  00182	3b cf		 cmp	 ecx, edi
  00184	89 7c 24 14	 mov	 DWORD PTR _nMaxLife$[esp+1208], edi
  00188	0f 84 61 01 00
	00		 je	 $L316733
  0018e	8b 44 24 40	 mov	 eax, DWORD PTR _vecSameidGuildWin$[esp+1216]
  00192	2b c1		 sub	 eax, ecx
  00194	c1 f8 02	 sar	 eax, 2
  00197	83 f8 01	 cmp	 eax, 1
  0019a	89 44 24 30	 mov	 DWORD PTR tv1943[esp+1208], eax
  0019e	0f 86 4b 01 00
	00		 jbe	 $L316733

; 1130 : 	{
; 1131 : 		vector<u_long> vecSameidGuildWinTmp;

  001a4	c6 84 24 b4 04
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1216], 1

; 1132 : 		vecSameidGuildWinTmp.clear();

  001ac	89 7c 24 1c	 mov	 DWORD PTR _vecSameidGuildWinTmp$268854[esp+1212], edi
  001b0	89 7c 24 20	 mov	 DWORD PTR _vecSameidGuildWinTmp$268854[esp+1216], edi
  001b4	89 7c 24 24	 mov	 DWORD PTR _vecSameidGuildWinTmp$268854[esp+1220], edi

; 1133 : 		for( int vecSame = 0 ; vecSame < (int)( vecSameidGuildWin.size() ) ; ++vecSame )

  001b8	89 7c 24 10	 mov	 DWORD PTR _vecSame$268855[esp+1208], edi
  001bc	8d 64 24 00	 npad	 4
$L268857:
  001c0	8b 4c 24 10	 mov	 ecx, DWORD PTR _vecSame$268855[esp+1208]
  001c4	3b c8		 cmp	 ecx, eax
  001c6	0f 8d fc 00 00
	00		 jge	 $L268859

; 1134 : 		{
; 1135 : 			int nLife = 0;
; 1136 : #ifdef __S_BUG_GC
; 1137 : 			__GuildCombatMember* pGCMember = FindGuildCombatMember( vecSameidGuildWin[vecSame] );

  001cc	8b 54 24 3c	 mov	 edx, DWORD PTR _vecSameidGuildWin$[esp+1212]
  001d0	8b c1		 mov	 eax, ecx
  001d2	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]
  001d5	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  001d8	33 ff		 xor	 edi, edi
  001da	33 c9		 xor	 ecx, ecx
  001dc	8d 64 24 00	 npad	 4
$L316087:
  001e0	85 d2		 test	 edx, edx
  001e2	75 04		 jne	 SHORT $L316093
  001e4	33 c0		 xor	 eax, eax
  001e6	eb 08		 jmp	 SHORT $L316094
$L316093:
  001e8	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  001eb	2b c2		 sub	 eax, edx
  001ed	c1 f8 02	 sar	 eax, 2
$L316094:
  001f0	3b c8		 cmp	 ecx, eax
  001f2	0f 8d c1 00 00
	00		 jge	 $L268858
  001f8	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  001fb	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  001fe	3b 30		 cmp	 esi, DWORD PTR [eax]
  00200	74 03		 je	 SHORT $L319042
  00202	41		 inc	 ecx
  00203	eb db		 jmp	 SHORT $L316087
$L319042:
  00205	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  00208	8b 34 8a	 mov	 esi, DWORD PTR [edx+ecx*4]

; 1138 : 			if( pGCMember != NULL )

  0020b	85 f6		 test	 esi, esi
  0020d	0f 84 a6 00 00
	00		 je	 $L268858
  00213	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1139 : 			{
; 1140 : 				for( int veci2 = 0 ; veci2 < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci2 )

  00216	33 c9		 xor	 ecx, ecx
$L268865:
  00218	85 d2		 test	 edx, edx
  0021a	75 04		 jne	 SHORT $L316140
  0021c	33 c0		 xor	 eax, eax
  0021e	eb 08		 jmp	 SHORT $L316141
$L316140:
  00220	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00223	2b c2		 sub	 eax, edx
  00225	c1 f8 02	 sar	 eax, 2
$L316141:
  00228	3b c8		 cmp	 ecx, eax
  0022a	7d 0c		 jge	 SHORT $L268867

; 1141 : 				{
; 1142 : 					__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci2];
; 1143 : 					nLife += pJoinPlayer->nlife;

  0022c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0022f	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00232	03 78 04	 add	 edi, DWORD PTR [eax+4]
  00235	41		 inc	 ecx
  00236	eb e0		 jmp	 SHORT $L268865
$L268867:

; 1144 : 				}
; 1145 : 				
; 1146 : 				//  
; 1147 : 				if( nMaxLife < nLife )

  00238	8b 44 24 14	 mov	 eax, DWORD PTR _nMaxLife$[esp+1208]
  0023c	3b c7		 cmp	 eax, edi
  0023e	7d 27		 jge	 SHORT $L319075

; 1148 : 				{
; 1149 : 					nMaxLife = nLife;
; 1150 : 					vecSameidGuildWinTmp.clear();

  00240	8b 44 24 1c	 mov	 eax, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1212]
  00244	85 c0		 test	 eax, eax
  00246	89 7c 24 14	 mov	 DWORD PTR _nMaxLife$[esp+1208], edi
  0024a	74 0b		 je	 SHORT $L316215
  0024c	8b c8		 mov	 ecx, eax
  0024e	51		 push	 ecx
  0024f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00254	83 c4 04	 add	 esp, 4
$L316215:
  00257	33 c0		 xor	 eax, eax
  00259	89 44 24 1c	 mov	 DWORD PTR _vecSameidGuildWinTmp$268854[esp+1212], eax
  0025d	89 44 24 20	 mov	 DWORD PTR _vecSameidGuildWinTmp$268854[esp+1216], eax
  00261	89 44 24 24	 mov	 DWORD PTR _vecSameidGuildWinTmp$268854[esp+1220], eax

; 1151 : 					vecSameidGuildWinTmp.push_back( pGCMember->uGuildId );
; 1152 : 				}
; 1153 : 				else if( nMaxLife == nLife )

  00265	eb 45		 jmp	 SHORT $L319076
$L319075:
  00267	75 50		 jne	 SHORT $L268858

; 1154 : 				{
; 1155 : 					vecSameidGuildWinTmp.push_back( pGCMember->uGuildId );

  00269	8b 54 24 1c	 mov	 edx, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1212]
  0026d	85 d2		 test	 edx, edx
  0026f	74 37		 je	 SHORT $L316650
  00271	8b 7c 24 20	 mov	 edi, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1216]
  00275	8b 4c 24 24	 mov	 ecx, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1220]
  00279	8b c7		 mov	 eax, edi
  0027b	2b c2		 sub	 eax, edx
  0027d	2b ca		 sub	 ecx, edx
  0027f	c1 f8 02	 sar	 eax, 2
  00282	c1 f9 02	 sar	 ecx, 2
  00285	3b c1		 cmp	 eax, ecx
  00287	73 1f		 jae	 SHORT $L316650
  00289	8b 16		 mov	 edx, DWORD PTR [esi]
  0028b	8b 44 24 10	 mov	 eax, DWORD PTR _vecSame$268855[esp+1208]
  0028f	89 17		 mov	 DWORD PTR [edi], edx
  00291	83 c7 04	 add	 edi, 4
  00294	40		 inc	 eax
  00295	89 7c 24 20	 mov	 DWORD PTR _vecSameidGuildWinTmp$268854[esp+1216], edi
  00299	89 44 24 10	 mov	 DWORD PTR _vecSame$268855[esp+1208], eax
  0029d	8b 44 24 30	 mov	 eax, DWORD PTR tv1943[esp+1208]
  002a1	33 ff		 xor	 edi, edi
  002a3	e9 18 ff ff ff	 jmp	 $L268857
$L316650:
  002a8	8b 44 24 20	 mov	 eax, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1216]
$L319076:
  002ac	56		 push	 esi
  002ad	6a 01		 push	 1
  002af	8d 4c 24 20	 lea	 ecx, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1216]
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
$L268858:
  002b9	ff 44 24 10	 inc	 DWORD PTR _vecSame$268855[esp+1208]
  002bd	8b 44 24 30	 mov	 eax, DWORD PTR tv1943[esp+1208]
  002c1	33 ff		 xor	 edi, edi
  002c3	e9 f8 fe ff ff	 jmp	 $L268857
$L268859:

; 1156 : 				}
; 1157 : 			}
; 1158 : #else // __S_BUG_GC
; 1159 : 			map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( vecSameidGuildWin[vecSame] );
; 1160 : 			if( it != m_GuildCombatMem.end() )
; 1161 : 			{
; 1162 : 				__GuildCombatMember* pGCMember = it->second;
; 1163 : 				for( int veci2 = 0 ; veci2 < pGCMember->vecGCSelectMember.size() ; ++veci2 )
; 1164 : 				{
; 1165 : 					__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci2];
; 1166 : 					nLife += pJoinPlayer->nlife;
; 1167 : 				}
; 1168 : 				
; 1169 : 				//  
; 1170 : 				if( nMaxLife < nLife )
; 1171 : 				{
; 1172 : 					nMaxLife = nLife;
; 1173 : 					vecSameidGuildWinTmp.clear();
; 1174 : 					vecSameidGuildWinTmp.push_back( it->first );
; 1175 : 				}
; 1176 : 				else if( nMaxLife == nLife )
; 1177 : 				{
; 1178 : 					vecSameidGuildWinTmp.push_back( it->first );
; 1179 : 				}
; 1180 : 			}
; 1181 : #endif // __S_BUG_GC
; 1182 : 		}
; 1183 : 		vecSameidGuildWin = vecSameidGuildWinTmp;

  002c8	8d 4c 24 18	 lea	 ecx, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1208]
  002cc	51		 push	 ecx
  002cd	8d 4c 24 3c	 lea	 ecx, DWORD PTR _vecSameidGuildWin$[esp+1212]
  002d1	e8 00 00 00 00	 call	 ??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=

; 1184 : 	}

  002d6	8b 44 24 1c	 mov	 eax, DWORD PTR _vecSameidGuildWinTmp$268854[esp+1212]
  002da	3b c7		 cmp	 eax, edi
  002dc	c6 84 24 b4 04
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1216], 0
  002e4	74 09		 je	 SHORT $L316733
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002ec	83 c4 04	 add	 esp, 4
$L316733:

; 1185 : 
; 1186 : 	//         
; 1187 : 	float fMaxAvgLv = 0.0f;
; 1188 : 	if( 1 < vecSameidGuildWin.size() )

  002ef	8b 44 24 3c	 mov	 eax, DWORD PTR _vecSameidGuildWin$[esp+1212]
  002f3	3b c7		 cmp	 eax, edi
  002f5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _fMaxAvgLv$[esp+1208], 0
  002fd	0f 84 e7 01 00
	00		 je	 $L317766
  00303	8b 4c 24 40	 mov	 ecx, DWORD PTR _vecSameidGuildWin$[esp+1216]
  00307	2b c8		 sub	 ecx, eax
  00309	c1 f9 02	 sar	 ecx, 2
  0030c	83 f9 01	 cmp	 ecx, 1
  0030f	89 4c 24 30	 mov	 DWORD PTR tv1943[esp+1208], ecx
  00313	0f 86 d1 01 00
	00		 jbe	 $L317766

; 1189 : 	{
; 1190 : 		vector<u_long> vecSameidGuildWinTmp;
; 1191 : 		vecSameidGuildWinTmp.clear();
; 1192 : 		for( int vecSame = 0 ; vecSame < (int)( vecSameidGuildWin.size() ) ; ++vecSame )

  00319	33 c0		 xor	 eax, eax
  0031b	c6 84 24 b4 04
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1216], 2
  00323	89 7c 24 1c	 mov	 DWORD PTR _vecSameidGuildWinTmp$268875[esp+1212], edi
  00327	89 7c 24 20	 mov	 DWORD PTR _vecSameidGuildWinTmp$268875[esp+1216], edi
  0032b	89 7c 24 24	 mov	 DWORD PTR _vecSameidGuildWinTmp$268875[esp+1220], edi
  0032f	89 44 24 14	 mov	 DWORD PTR _vecSame$268876[esp+1208], eax
$L268878:
  00333	3b c1		 cmp	 eax, ecx
  00335	0f 8d 88 01 00
	00		 jge	 $L268880

; 1193 : 		{
; 1194 : 			float fAvgLv = 0.0f;
; 1195 : 			int nSubLevel = 0;
; 1196 : 			int nValidObjCount = 0;
; 1197 : #ifdef __S_BUG_GC
; 1198 : 			__GuildCombatMember* pGCMember = FindGuildCombatMember( vecSameidGuildWin[vecSame] );

  0033b	8b 54 24 3c	 mov	 edx, DWORD PTR _vecSameidGuildWin$[esp+1212]
  0033f	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]
  00342	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  00345	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _fAvgLv$268881[esp+1208], 0
  0034d	89 7c 24 34	 mov	 DWORD PTR _nSubLevel$268882[esp+1208], edi
  00351	89 7c 24 4c	 mov	 DWORD PTR _nValidObjCount$268883[esp+1208], edi
  00355	33 c9		 xor	 ecx, ecx
$L317030:
  00357	3b d7		 cmp	 edx, edi
  00359	75 04		 jne	 SHORT $L317036
  0035b	33 c0		 xor	 eax, eax
  0035d	eb 08		 jmp	 SHORT $L317037
$L317036:
  0035f	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  00362	2b c2		 sub	 eax, edx
  00364	c1 f8 02	 sar	 eax, 2
$L317037:
  00367	3b c8		 cmp	 ecx, eax
  00369	0f 8d 3c 01 00
	00		 jge	 $L268879
  0036f	8b 5c 24 2c	 mov	 ebx, DWORD PTR $T319023[esp+1208]
  00373	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  00376	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00379	3b 30		 cmp	 esi, DWORD PTR [eax]
  0037b	74 05		 je	 SHORT $L319043
  0037d	41		 inc	 ecx
  0037e	33 ff		 xor	 edi, edi
  00380	eb d5		 jmp	 SHORT $L317030
$L319043:
  00382	8b 53 74	 mov	 edx, DWORD PTR [ebx+116]
  00385	8b 34 8a	 mov	 esi, DWORD PTR [edx+ecx*4]

; 1199 : 			if( pGCMember != NULL )

  00388	85 f6		 test	 esi, esi
  0038a	0f 84 1b 01 00
	00		 je	 $L268879
  00390	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]

; 1200 : 			{
; 1201 : 				for( int veci2 = 0 ; veci2 < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci2 )

  00393	33 ff		 xor	 edi, edi
$L268888:
  00395	85 db		 test	 ebx, ebx
  00397	75 04		 jne	 SHORT $L317083
  00399	33 c0		 xor	 eax, eax
  0039b	eb 08		 jmp	 SHORT $L317084
$L317083:
  0039d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  003a0	2b c3		 sub	 eax, ebx
  003a2	c1 f8 02	 sar	 eax, 2
$L317084:
  003a5	3b f8		 cmp	 edi, eax
  003a7	7d 5c		 jge	 SHORT $L268890

; 1202 : 				{
; 1203 : 					__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci2];

  003a9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003ac	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 1204 : 					if( 0 < pJoinPlayer->nlife )

  003af	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003b2	85 c9		 test	 ecx, ecx
  003b4	7e 4c		 jle	 SHORT $L268889

; 1205 : 					{
; 1206 : 						CUser* pUsertmp = (CUser*)prj.GetUserByID( pJoinPlayer->uidPlayer );

  003b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b8	8d 54 24 48	 lea	 edx, DWORD PTR $T317214[esp+1208]
  003bc	52		 push	 edx
  003bd	8d 44 24 54	 lea	 eax, DWORD PTR _i$317192[esp+1212]
  003c1	89 4c 24 4c	 mov	 DWORD PTR $T317214[esp+1212], ecx
  003c5	50		 push	 eax
  003c6	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  003cb	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  003d0	8b 44 24 50	 mov	 eax, DWORD PTR _i$317192[esp+1208]
  003d4	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  003da	74 26		 je	 SHORT $L268889
  003dc	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1207 : 						if( IsValidObj( pUsertmp ) )

  003df	85 c0		 test	 eax, eax
  003e1	74 1f		 je	 SHORT $L268889
  003e3	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  003e7	75 19		 jne	 SHORT $L268889

; 1208 : 						{
; 1209 : 							nSubLevel += pUsertmp->GetLevel();

  003e9	8b 88 e0 05 00
	00		 mov	 ecx, DWORD PTR [eax+1504]
  003ef	8b 54 24 34	 mov	 edx, DWORD PTR _nSubLevel$268882[esp+1208]

; 1210 : 							++nValidObjCount;

  003f3	8b 44 24 4c	 mov	 eax, DWORD PTR _nValidObjCount$268883[esp+1208]
  003f7	03 d1		 add	 edx, ecx
  003f9	40		 inc	 eax
  003fa	89 54 24 34	 mov	 DWORD PTR _nSubLevel$268882[esp+1208], edx
  003fe	89 44 24 4c	 mov	 DWORD PTR _nValidObjCount$268883[esp+1208], eax
$L268889:

; 1200 : 			{
; 1201 : 				for( int veci2 = 0 ; veci2 < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci2 )

  00402	47		 inc	 edi
  00403	eb 90		 jmp	 SHORT $L268888
$L268890:

; 1211 : 						}
; 1212 : 					}
; 1213 : 				}
; 1214 : 				
; 1215 : 				if( nValidObjCount )

  00405	8b 4c 24 4c	 mov	 ecx, DWORD PTR _nValidObjCount$268883[esp+1208]
  00409	85 c9		 test	 ecx, ecx
  0040b	74 13		 je	 SHORT $L268896

; 1216 : 				{
; 1217 : 					fAvgLv = (float)( nSubLevel / nValidObjCount );

  0040d	8b 44 24 34	 mov	 eax, DWORD PTR _nSubLevel$268882[esp+1208]
  00411	99		 cdq
  00412	f7 f9		 idiv	 ecx
  00414	89 44 24 48	 mov	 DWORD PTR tv3081[esp+1208], eax
  00418	db 44 24 48	 fild	 DWORD PTR tv3081[esp+1208]
  0041c	d9 5c 24 10	 fstp	 DWORD PTR _fAvgLv$268881[esp+1208]
$L268896:

; 1218 : 				}
; 1219 : 				
; 1220 : 				//  
; 1221 : 				if( fMaxAvgLv < fAvgLv )

  00420	d9 44 24 28	 fld	 DWORD PTR _fMaxAvgLv$[esp+1208]
  00424	d8 5c 24 10	 fcomp	 DWORD PTR _fAvgLv$268881[esp+1208]
  00428	df e0		 fnstsw	 ax
  0042a	f6 c4 05	 test	 ah, 5
  0042d	7a 2d		 jp	 SHORT $L268898

; 1222 : 				{
; 1223 : 					fMaxAvgLv = fAvgLv;
; 1224 : 					vecSameidGuildWinTmp.clear();

  0042f	8b 44 24 1c	 mov	 eax, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1212]
  00433	85 c0		 test	 eax, eax
  00435	8b 54 24 10	 mov	 edx, DWORD PTR _fAvgLv$268881[esp+1208]
  00439	89 54 24 28	 mov	 DWORD PTR _fMaxAvgLv$[esp+1208], edx
  0043d	74 09		 je	 SHORT $L317248
  0043f	50		 push	 eax
  00440	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00445	83 c4 04	 add	 esp, 4
$L317248:
  00448	33 c0		 xor	 eax, eax

; 1225 : 					vecSameidGuildWinTmp.push_back( pGCMember->uGuildId );

  0044a	56		 push	 esi
  0044b	6a 01		 push	 1
  0044d	89 44 24 24	 mov	 DWORD PTR _vecSameidGuildWinTmp$268875[esp+1220], eax
  00451	89 44 24 28	 mov	 DWORD PTR _vecSameidGuildWinTmp$268875[esp+1224], eax
  00455	89 44 24 2c	 mov	 DWORD PTR _vecSameidGuildWinTmp$268875[esp+1228], eax
  00459	50		 push	 eax

; 1226 : 				}
; 1227 : 				else if( fMaxAvgLv == fAvgLv )

  0045a	eb 46		 jmp	 SHORT $L319077
$L268898:
  0045c	d9 44 24 10	 fld	 DWORD PTR _fAvgLv$268881[esp+1208]
  00460	d9 44 24 28	 fld	 DWORD PTR _fMaxAvgLv$[esp+1208]
  00464	da e9		 fucompp
  00466	df e0		 fnstsw	 ax
  00468	f6 c4 44	 test	 ah, 68			; 00000044H
  0046b	7a 3e		 jp	 SHORT $L268879

; 1228 : 				{
; 1229 : 					vecSameidGuildWinTmp.push_back( pGCMember->uGuildId );

  0046d	8b 44 24 1c	 mov	 eax, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1212]
  00471	85 c0		 test	 eax, eax
  00473	8b 54 24 20	 mov	 edx, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1216]
  00477	74 25		 je	 SHORT $L317683
  00479	8b 7c 24 1c	 mov	 edi, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1212]
  0047d	8b 4c 24 24	 mov	 ecx, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1220]
  00481	8b c2		 mov	 eax, edx
  00483	2b c7		 sub	 eax, edi
  00485	2b cf		 sub	 ecx, edi
  00487	c1 f8 02	 sar	 eax, 2
  0048a	c1 f9 02	 sar	 ecx, 2
  0048d	3b c1		 cmp	 eax, ecx
  0048f	73 0d		 jae	 SHORT $L317683
  00491	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00493	89 0a		 mov	 DWORD PTR [edx], ecx
  00495	83 c2 04	 add	 edx, 4
  00498	89 54 24 20	 mov	 DWORD PTR _vecSameidGuildWinTmp$268875[esp+1216], edx
  0049c	eb 0d		 jmp	 SHORT $L268879
$L317683:
  0049e	56		 push	 esi
  0049f	6a 01		 push	 1
  004a1	52		 push	 edx
$L319077:
  004a2	8d 4c 24 24	 lea	 ecx, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1220]
  004a6	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXViterator@12@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
$L268879:
  004ab	8b 44 24 14	 mov	 eax, DWORD PTR _vecSame$268876[esp+1208]
  004af	8b 4c 24 30	 mov	 ecx, DWORD PTR tv1943[esp+1208]
  004b3	8b 5c 24 2c	 mov	 ebx, DWORD PTR $T319023[esp+1208]
  004b7	40		 inc	 eax
  004b8	89 44 24 14	 mov	 DWORD PTR _vecSame$268876[esp+1208], eax
  004bc	33 ff		 xor	 edi, edi
  004be	e9 70 fe ff ff	 jmp	 $L268878
$L268880:

; 1230 : 				}
; 1231 : 			}
; 1232 : #else // __S_BUG_GC
; 1233 : 			map<u_long, __GuildCombatMember*>::iterator it = m_GuildCombatMem.find( vecSameidGuildWin[vecSame] );
; 1234 : 			if( it != m_GuildCombatMem.end() )
; 1235 : 			{
; 1236 : 				__GuildCombatMember* pGCMember = it->second;
; 1237 : 				for( int veci2 = 0 ; veci2 < pGCMember->vecGCSelectMember.size() ; ++veci2 )
; 1238 : 				{
; 1239 : 					__JOINPLAYER* pJoinPlayer = pGCMember->vecGCSelectMember[veci2];
; 1240 : 					if( 0 < pJoinPlayer->nlife )
; 1241 : 					{
; 1242 : 						CUser* pUsertmp = (CUser*)prj.GetUserByID( pJoinPlayer->uidPlayer );
; 1243 : 						if( IsValidObj( pUsertmp ) )
; 1244 : 						{
; 1245 : 							nSubLevel += pUsertmp->GetLevel();
; 1246 : 							++nValidObjCount;
; 1247 : 						}
; 1248 : 					}
; 1249 : 				}
; 1250 : 				
; 1251 : 				if( nValidObjCount )
; 1252 : 				{
; 1253 : 					fAvgLv = nSubLevel / nValidObjCount;
; 1254 : 				}
; 1255 : 				
; 1256 : 				//  
; 1257 : 				if( fMaxAvgLv < fAvgLv )
; 1258 : 				{
; 1259 : 					fMaxAvgLv = fAvgLv;
; 1260 : 					vecSameidGuildWinTmp.clear();
; 1261 : 					vecSameidGuildWinTmp.push_back( it->first );
; 1262 : 				}
; 1263 : 				else if( fMaxAvgLv == fAvgLv )
; 1264 : 				{
; 1265 : 					vecSameidGuildWinTmp.push_back( it->first );
; 1266 : 				}
; 1267 : 			}
; 1268 : #endif // __S_BUG_GC
; 1269 : 		}
; 1270 : 		vecSameidGuildWin = vecSameidGuildWinTmp;

  004c3	8d 54 24 18	 lea	 edx, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1208]
  004c7	52		 push	 edx
  004c8	8d 4c 24 3c	 lea	 ecx, DWORD PTR _vecSameidGuildWin$[esp+1212]
  004cc	e8 00 00 00 00	 call	 ??4?$vector@KV?$allocator@K@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator=

; 1271 : 	}

  004d1	8b 44 24 1c	 mov	 eax, DWORD PTR _vecSameidGuildWinTmp$268875[esp+1212]
  004d5	3b c7		 cmp	 eax, edi
  004d7	c6 84 24 b4 04
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1216], 0
  004df	74 09		 je	 SHORT $L317766
  004e1	50		 push	 eax
  004e2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004e7	83 c4 04	 add	 esp, 4
$L317766:

; 1272 : 
; 1273 : 	char str[512] = {0,};

  004ea	c6 84 24 a0 02
	00 00 00	 mov	 BYTE PTR _str$[esp+1208], 0
  004f2	33 c0		 xor	 eax, eax
  004f4	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  004f9	8d bc 24 a1 02
	00 00		 lea	 edi, DWORD PTR _str$[esp+1209]
  00500	f3 ab		 rep stosd
  00502	66 ab		 stosw
  00504	aa		 stosb

; 1274 : 	CString strPrizeMsg;

  00505	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  0050a	8b 10		 mov	 edx, DWORD PTR [eax]
  0050c	8b c8		 mov	 ecx, eax
  0050e	ff 52 0c	 call	 DWORD PTR [edx+12]
  00511	83 c0 10	 add	 eax, 16			; 00000010H
  00514	89 44 24 50	 mov	 DWORD PTR _strPrizeMsg$[esp+1208], eax

; 1275 : 
; 1276 : 	//    ( .. )
; 1277 : 	if( 0 < vecSameidGuildWin.size() )

  00518	8b 74 24 3c	 mov	 esi, DWORD PTR _vecSameidGuildWin$[esp+1212]
  0051c	85 f6		 test	 esi, esi
  0051e	c6 84 24 b4 04
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+1216], 3
  00526	0f 84 3f 05 00
	00		 je	 $L268903
  0052c	8b 44 24 40	 mov	 eax, DWORD PTR _vecSameidGuildWin$[esp+1216]
  00530	2b c6		 sub	 eax, esi
  00532	c1 f8 02	 sar	 eax, 2
  00535	85 c0		 test	 eax, eax
  00537	0f 86 2e 05 00
	00		 jbe	 $L268903

; 1278 : 	{
; 1279 : 		CGuild* pGuild	= g_GuildMng.GetGuild( vecSameidGuildWin[0] );

  0053d	8b 06		 mov	 eax, DWORD PTR [esi]
  0053f	50		 push	 eax
  00540	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  00545	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 1280 : 		if( pGuild )

  0054a	85 c0		 test	 eax, eax
  0054c	89 44 24 30	 mov	 DWORD PTR _pGuild$268904[esp+1208], eax
  00550	0f 84 d4 04 00
	00		 je	 $L318974

; 1281 : 		{
; 1282 : 			if( g_eLocal.GetState( EVE_GUILDCOMBAT ) )

  00556	6a 0f		 push	 15			; 0000000fH
  00558	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  0055d	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00562	84 c0		 test	 al, al
  00564	74 36		 je	 SHORT $L268906

; 1283 : 			{
; 1284 : 				g_UserMng.AddWorldCreateSfxObj( XI_NAT_ROCKET02, 1291.0f, 85.0f, 1279.0f, FALSE, WI_WORLD_GUILDWAR );

  00566	68 ca 00 00 00	 push	 202			; 000000caH
  0056b	6a 00		 push	 0
  0056d	68 00 e0 9f 44	 push	 1151328256		; 449fe000H
  00572	68 00 00 aa 42	 push	 1118437376		; 42aa0000H
  00577	68 00 60 a1 44	 push	 1151426560		; 44a16000H
  0057c	68 4b 04 00 00	 push	 1099			; 0000044bH
  00581	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00586	e8 00 00 00 00	 call	 ?AddWorldCreateSfxObj@CUserMng@@QAEXKMMMHK@Z ; CUserMng::AddWorldCreateSfxObj

; 1285 : 				g_DPCoreClient.SendPlayMusic( WI_WORLD_GUILDWAR, BGM_IN_FITUP );

  0058b	6a 19		 push	 25			; 00000019H
  0058d	68 ca 00 00 00	 push	 202			; 000000caH
  00592	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  00597	e8 00 00 00 00	 call	 ?SendPlayMusic@CDPCoreClient@@QAEXKK@Z ; CDPCoreClient::SendPlayMusic
$L268906:

; 1286 : 			}
; 1287 : 			
; 1288 : 			//  
; 1289 : 			if( m_uWinGuildId == vecSameidGuildWin[0] )

  0059c	8b 74 24 2c	 mov	 esi, DWORD PTR $T319023[esp+1208]
  005a0	8b 44 24 3c	 mov	 eax, DWORD PTR _vecSameidGuildWin$[esp+1212]
  005a4	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  005a7	3b 08		 cmp	 ecx, DWORD PTR [eax]
  005a9	75 05		 jne	 SHORT $L268907

; 1290 : 				++m_nWinGuildCount;

  005ab	ff 46 48	 inc	 DWORD PTR [esi+72]

; 1291 : 			else

  005ae	eb 07		 jmp	 SHORT $L268908
$L268907:

; 1292 : 				m_nWinGuildCount = 1;

  005b0	c7 46 48 01 00
	00 00		 mov	 DWORD PTR [esi+72], 1
$L268908:

; 1293 : 			
; 1294 : 			m_uWinGuildId = vecSameidGuildWin[0];

  005b7	8b 10		 mov	 edx, DWORD PTR [eax]
  005b9	89 56 44	 mov	 DWORD PTR [esi+68], edx

; 1295 : 			sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_END) );

  005bc	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  005c1	3d 8e 0b 00 00	 cmp	 eax, 2958		; 00000b8eH
  005c6	7e 1d		 jle	 SHORT $L318006
  005c8	76 0f		 jbe	 SHORT $L319057
  005ca	a1 b8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+696
  005cf	8b 80 38 2e 00
	00		 mov	 eax, DWORD PTR [eax+11832]
  005d5	85 c0		 test	 eax, eax
  005d7	75 07		 jne	 SHORT $L318007
$L319057:
  005d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  005de	eb 24		 jmp	 SHORT $L318001
$L318007:
  005e0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005e3	eb 1f		 jmp	 SHORT $L318001
$L318006:
  005e5	68 8e 0b 00 00	 push	 2958			; 00000b8eH
  005ea	50		 push	 eax
  005eb	6a 00		 push	 0
  005ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  005f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  005f7	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  005fc	83 c4 14	 add	 esp, 20			; 00000014H
  005ff	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L318001:
  00604	50		 push	 eax
  00605	8d 8c 24 a4 02
	00 00		 lea	 ecx, DWORD PTR _str$[esp+1212]
  0060c	51		 push	 ecx
  0060d	e8 00 00 00 00	 call	 _sprintf
  00612	83 c4 08	 add	 esp, 8

; 1296 : 			g_DPCoreClient.SendSystem( str );

  00615	8d 94 24 a0 02
	00 00		 lea	 edx, DWORD PTR _str$[esp+1208]
  0061c	52		 push	 edx
  0061d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  00622	e8 00 00 00 00	 call	 ?SendSystem@CDPCoreClient@@QAEXPBD@Z ; CDPCoreClient::SendSystem

; 1297 : 			g_DPCoreClient.SendCaption( str );

  00627	6a 00		 push	 0
  00629	6a 00		 push	 0
  0062b	8d 84 24 a8 02
	00 00		 lea	 eax, DWORD PTR _str$[esp+1216]
  00632	50		 push	 eax
  00633	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  00638	e8 00 00 00 00	 call	 ?SendCaption@CDPCoreClient@@QAEXPBDKH@Z ; CDPCoreClient::SendCaption

; 1298 : 			sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_WINNER), pGuild->m_szGuild );

  0063d	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00642	3d 93 0a 00 00	 cmp	 eax, 2707		; 00000a93H
  00647	7e 1e		 jle	 SHORT $L318054
  00649	76 10		 jbe	 SHORT $L319058
  0064b	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  00651	8b 81 4c 2a 00
	00		 mov	 eax, DWORD PTR [ecx+10828]
  00657	85 c0		 test	 eax, eax
  00659	75 07		 jne	 SHORT $L318055
$L319058:
  0065b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00660	eb 24		 jmp	 SHORT $L318049
$L318055:
  00662	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00665	eb 1f		 jmp	 SHORT $L318049
$L318054:
  00667	68 93 0a 00 00	 push	 2707			; 00000a93H
  0066c	50		 push	 eax
  0066d	6a 00		 push	 0
  0066f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00674	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00679	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0067e	83 c4 14	 add	 esp, 20			; 00000014H
  00681	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L318049:
  00686	8b 54 24 30	 mov	 edx, DWORD PTR _pGuild$268904[esp+1208]
  0068a	83 c2 08	 add	 edx, 8
  0068d	52		 push	 edx
  0068e	50		 push	 eax
  0068f	8d 84 24 a8 02
	00 00		 lea	 eax, DWORD PTR _str$[esp+1216]
  00696	50		 push	 eax
  00697	e8 00 00 00 00	 call	 _sprintf

; 1299 : #if __VER >= 8 // __GUILDCOMBAT_85
; 1300 : 			int nBufWinGuildCount = m_nWinGuildCount;

  0069c	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]

; 1301 : 			if( m_nMaxGCSendItem < m_nWinGuildCount )

  0069f	8b 86 9c 10 00
	00		 mov	 eax, DWORD PTR [esi+4252]
  006a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a8	3b c1		 cmp	 eax, ecx
  006aa	89 4c 24 34	 mov	 DWORD PTR _nBufWinGuildCount$268909[esp+1208], ecx
  006ae	7d 04		 jge	 SHORT $L268910

; 1302 : 				nBufWinGuildCount = m_nMaxGCSendItem;

  006b0	89 44 24 34	 mov	 DWORD PTR _nBufWinGuildCount$268909[esp+1208], eax
$L268910:

; 1303 : 			//   
; 1304 : 			CString strGuildMsg;

  006b4	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  006b9	8b 10		 mov	 edx, DWORD PTR [eax]
  006bb	8b c8		 mov	 ecx, eax
  006bd	ff 52 0c	 call	 DWORD PTR [edx+12]
  006c0	83 c0 10	 add	 eax, 16			; 00000010H
  006c3	89 44 24 10	 mov	 DWORD PTR _strGuildMsg$268911[esp+1208], eax
  006c7	8b 74 24 30	 mov	 esi, DWORD PTR _pGuild$268904[esp+1208]
  006cb	8b 7c 24 2c	 mov	 edi, DWORD PTR $T319023[esp+1208]

; 1305 : #if __VER < 11 // __GUILDCOMBATCHIP
; 1306 : 			strGuildMsg.Format( prj.GetText(TID_GAME_GUILDCOMBAT_PRIZEMSG), pGuild->m_szGuild, m_nWinGuildCount );
; 1307 : 			m_vecstrGuildMsg.push_back( strGuildMsg );
; 1308 : 			strGuildMsg.Format( prj.GetText(TID_GAME_GUILDCOMBAT_PRIZEMSG1 ) );
; 1309 : 			m_vecstrGuildMsg.push_back( strGuildMsg );
; 1310 : #endif // __GUILDCOMBATCHIP
; 1311 : 			for( int si = 0 ; si < (int)( vecGCSendItem.size() ) ; ++si )

  006cf	33 db		 xor	 ebx, ebx
  006d1	c6 84 24 b4 04
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+1216], 4
  006d9	89 5c 24 28	 mov	 DWORD PTR _si$268912[esp+1208], ebx
  006dd	8d 49 00	 npad	 3
$L268914:
  006e0	8b 87 04 11 00
	00		 mov	 eax, DWORD PTR [edi+4356]
  006e6	85 c0		 test	 eax, eax
  006e8	74 18		 je	 SHORT $L318109
$L318108:
  006ea	8b 8f 08 11 00
	00		 mov	 ecx, DWORD PTR [edi+4360]
  006f0	2b c8		 sub	 ecx, eax
  006f2	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  006f7	f7 e9		 imul	 ecx
  006f9	d1 fa		 sar	 edx, 1
  006fb	8b c2		 mov	 eax, edx
  006fd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00700	03 c2		 add	 eax, edx
$L318109:
  00702	39 44 24 28	 cmp	 DWORD PTR _si$268912[esp+1208], eax
  00706	0f 8d f8 02 00
	00		 jge	 $L268916

; 1312 : 			{
; 1313 : 				if( vecGCSendItem[si].nWinCount != nBufWinGuildCount )

  0070c	8b 87 04 11 00
	00		 mov	 eax, DWORD PTR [edi+4356]
  00712	8b 04 18	 mov	 eax, DWORD PTR [eax+ebx]
  00715	3b 44 24 34	 cmp	 eax, DWORD PTR _nBufWinGuildCount$268909[esp+1208]
  00719	0f 85 d9 02 00
	00		 jne	 $L268915

; 1314 : 					continue;
; 1315 : 
; 1316 : 				//  
; 1317 : 				CItemElem itemElem;

  0071f	8d 4c 24 58	 lea	 ecx, DWORD PTR _itemElem$268918[esp+1208]
  00723	e8 00 00 00 00	 call	 ??0CItemElem@@QAE@XZ	; CItemElem::CItemElem

; 1318 : 				itemElem.m_dwItemId = vecGCSendItem[si].dwItemId;

  00728	8b 8f 04 11 00
	00		 mov	 ecx, DWORD PTR [edi+4356]
  0072e	8b 44 19 04	 mov	 eax, DWORD PTR [ecx+ebx+4]

; 1319 : 				itemElem.m_nItemNum	= vecGCSendItem[si].nItemNum;
; 1320 : 				itemElem.m_nHitPoint = itemElem.GetProp()->dwEndurance;

  00732	85 c0		 test	 eax, eax
  00734	89 44 24 64	 mov	 DWORD PTR _itemElem$268918[esp+1220], eax
  00738	66 8b 4c 19 08	 mov	 cx, WORD PTR [ecx+ebx+8]
  0073d	66 89 8c 24 d8
	00 00 00	 mov	 WORD PTR _itemElem$268918[esp+1336], cx
  00745	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0074b	c6 84 24 b4 04
	00 00 05	 mov	 BYTE PTR __$EHRec$[esp+1216], 5
  00753	7c 11		 jl	 SHORT $L318328
  00755	3b c1		 cmp	 eax, ecx
  00757	7d 0d		 jge	 SHORT $L318328
  00759	73 21		 jae	 SHORT $L319078
  0075b	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  00761	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00764	eb 18		 jmp	 SHORT $L318323
$L318328:
  00766	50		 push	 eax
  00767	51		 push	 ecx
  00768	6a 00		 push	 0
  0076a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0076f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00774	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00779	83 c4 14	 add	 esp, 20			; 00000014H
$L319078:
  0077c	33 c0		 xor	 eax, eax
$L318323:
  0077e	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [eax+144]

; 1321 : 				itemElem.SetSerialNumber();

  00784	8d 4c 24 58	 lea	 ecx, DWORD PTR _itemElem$268918[esp+1208]
  00788	89 84 24 d4 00
	00 00		 mov	 DWORD PTR _itemElem$268918[esp+1332], eax
  0078f	e8 00 00 00 00	 call	 ?SetSerialNumber@CItemBase@@QAEXXZ ; CItemBase::SetSerialNumber

; 1322 : 				if ( pGuild->m_GuildBank.Add( &itemElem ) )

  00794	6a 00		 push	 0
  00796	6a 00		 push	 0
  00798	6a 00		 push	 0
  0079a	8d 4c 24 64	 lea	 ecx, DWORD PTR _itemElem$268918[esp+1220]
  0079e	51		 push	 ecx
  0079f	8d 8e 08 01 00
	00		 lea	 ecx, DWORD PTR [esi+264]
  007a5	e8 00 00 00 00	 call	 ?Add@?$CItemContainer@VCItemElem@@@@QAEHPAVCItemElem@@PAEPAF1@Z ; CItemContainer<CItemElem>::Add
  007aa	85 c0		 test	 eax, eax
  007ac	0f 84 e2 01 00
	00		 je	 $L268919

; 1323 : 				{
; 1324 : 					LogItemInfo aLogItem;

  007b2	8d 8c 24 d8 01
	00 00		 lea	 ecx, DWORD PTR _aLogItem$268920[esp+1208]
  007b9	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 1325 : 					aLogItem.Action = "W";
; 1326 : 					aLogItem.SendName = "GUILDCOMBAT";
; 1327 : 					aLogItem.RecvName = "GUILDBANK";
; 1328 : 					g_DPSrvr.OnLogItem( aLogItem, &itemElem, vecGCSendItem[si].nItemNum );

  007be	8b 87 04 11 00
	00		 mov	 eax, DWORD PTR [edi+4356]
  007c4	c7 84 24 d8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$268920[esp+1208], OFFSET FLAT:??_C@_01ELNMCGJD@W?$AA@
  007cf	c7 84 24 dc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$268920[esp+1212], OFFSET FLAT:??_C@_0M@ILPKKCFD@GUILDCOMBAT?$AA@
  007da	c7 84 24 e0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$268920[esp+1216], OFFSET FLAT:??_C@_09BBHEADKN@GUILDBANK?$AA@
  007e5	8b 54 18 08	 mov	 edx, DWORD PTR [eax+ebx+8]
  007e9	52		 push	 edx
  007ea	8d 44 24 5c	 lea	 eax, DWORD PTR _itemElem$268918[esp+1212]
  007ee	50		 push	 eax
  007ef	8d 8c 24 e0 01
	00 00		 lea	 ecx, DWORD PTR _aLogItem$268920[esp+1216]
  007f6	51		 push	 ecx
  007f7	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  007fc	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 1329 : 					
; 1330 : 					g_DPSrvr.UpdateGuildBank( pGuild, GUILD_PUT_ITEM, 0, 0, &itemElem, 0, vecGCSendItem[si].nItemNum );

  00801	8b 87 04 11 00
	00		 mov	 eax, DWORD PTR [edi+4356]
  00807	33 d2		 xor	 edx, edx
  00809	66 8b 54 18 08	 mov	 dx, WORD PTR [eax+ebx+8]
  0080e	8d 44 24 58	 lea	 eax, DWORD PTR _itemElem$268918[esp+1208]
  00812	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  00817	52		 push	 edx
  00818	6a 00		 push	 0
  0081a	50		 push	 eax
  0081b	6a 00		 push	 0
  0081d	6a 00		 push	 0
  0081f	6a 00		 push	 0
  00821	56		 push	 esi
  00822	e8 00 00 00 00	 call	 ?UpdateGuildBank@CDPSrvr@@QAEXPAVCGuild@@HEKPAVCItemElem@@KF@Z ; CDPSrvr::UpdateGuildBank

; 1331 : 					g_UserMng.AddPutItemElem( vecSameidGuildWin[0], &itemElem );

  00827	8b 54 24 3c	 mov	 edx, DWORD PTR _vecSameidGuildWin$[esp+1212]
  0082b	8b 02		 mov	 eax, DWORD PTR [edx]
  0082d	8d 4c 24 58	 lea	 ecx, DWORD PTR _itemElem$268918[esp+1208]
  00831	51		 push	 ecx
  00832	50		 push	 eax
  00833	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00838	e8 00 00 00 00	 call	 ?AddPutItemElem@CUserMng@@QAEXKPAVCItemElem@@@Z ; CUserMng::AddPutItemElem

; 1332 : 
; 1333 : 					CString strItemMsg;

  0083d	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00842	8b 10		 mov	 edx, DWORD PTR [eax]
  00844	8b c8		 mov	 ecx, eax
  00846	ff 52 0c	 call	 DWORD PTR [edx+12]
  00849	83 c0 10	 add	 eax, 16			; 00000010H
  0084c	89 44 24 14	 mov	 DWORD PTR _strItemMsg$268923[esp+1208], eax

; 1334 : 					strItemMsg.Format( prj.GetText(TID_UPGRADE_SUPPORTM), itemElem.m_nItemNum );					

  00850	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00855	3d 99 08 00 00	 cmp	 eax, 2201		; 00000899H
  0085a	c6 84 24 b4 04
	00 00 06	 mov	 BYTE PTR __$EHRec$[esp+1216], 6
  00862	7e 1d		 jle	 SHORT $L318584
  00864	76 0f		 jbe	 SHORT $L319059
  00866	a1 b8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+696
  0086b	8b 80 64 22 00
	00		 mov	 eax, DWORD PTR [eax+8804]
  00871	85 c0		 test	 eax, eax
  00873	75 07		 jne	 SHORT $L318585
$L319059:
  00875	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0087a	eb 24		 jmp	 SHORT $L318579
$L318585:
  0087c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0087f	eb 1f		 jmp	 SHORT $L318579
$L318584:
  00881	68 99 08 00 00	 push	 2201			; 00000899H
  00886	50		 push	 eax
  00887	6a 00		 push	 0
  00889	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  0088e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00893	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00898	83 c4 14	 add	 esp, 20			; 00000014H
  0089b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L318579:
  008a0	0f bf 8c 24 d8
	00 00 00	 movsx	 ecx, WORD PTR _itemElem$268918[esp+1336]
  008a8	51		 push	 ecx
  008a9	50		 push	 eax
  008aa	8d 54 24 1c	 lea	 edx, DWORD PTR _strItemMsg$268923[esp+1216]
  008ae	52		 push	 edx
  008af	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 1335 : 					strGuildMsg.Format("  - %s %s", itemElem.GetProp()->szName, strItemMsg );

  008b4	8b 44 24 70	 mov	 eax, DWORD PTR _itemElem$268918[esp+1232]
  008b8	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  008be	83 c4 0c	 add	 esp, 12			; 0000000cH
  008c1	85 c0		 test	 eax, eax
  008c3	7c 11		 jl	 SHORT $L318651
  008c5	3b c1		 cmp	 eax, ecx
  008c7	7d 0d		 jge	 SHORT $L318651
  008c9	73 21		 jae	 SHORT $L319079
  008cb	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  008d1	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  008d4	eb 18		 jmp	 SHORT $L318646
$L318651:
  008d6	50		 push	 eax
  008d7	51		 push	 ecx
  008d8	6a 00		 push	 0
  008da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  008df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  008e4	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  008e9	83 c4 14	 add	 esp, 20			; 00000014H
$L319079:
  008ec	33 c0		 xor	 eax, eax
$L318646:
  008ee	8b 54 24 14	 mov	 edx, DWORD PTR _strItemMsg$268923[esp+1208]
  008f2	52		 push	 edx
  008f3	83 c0 04	 add	 eax, 4
  008f6	50		 push	 eax
  008f7	8d 44 24 18	 lea	 eax, DWORD PTR _strGuildMsg$268911[esp+1216]
  008fb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09PKCFHHL@?5?5?9?5?$CFs?5?$CFs?$AA@
  00900	50		 push	 eax
  00901	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 1336 : 					m_vecstrGuildMsg.push_back( strGuildMsg );

  00906	8b 87 f4 10 00
	00		 mov	 eax, DWORD PTR [edi+4340]
  0090c	8d b7 f0 10 00
	00		 lea	 esi, DWORD PTR [edi+4336]
  00912	83 c4 10	 add	 esp, 16			; 00000010H
  00915	85 c0		 test	 eax, eax
  00917	75 04		 jne	 SHORT $L318810
  00919	33 d2		 xor	 edx, edx
  0091b	eb 08		 jmp	 SHORT $L318811
$L318810:
  0091d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00920	2b d0		 sub	 edx, eax
  00922	c1 fa 02	 sar	 edx, 2
$L318811:
  00925	85 c0		 test	 eax, eax
  00927	74 31		 je	 SHORT $L318865
  00929	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0092c	2b c8		 sub	 ecx, eax
  0092e	c1 f9 02	 sar	 ecx, 2
  00931	3b d1		 cmp	 edx, ecx
  00933	73 25		 jae	 SHORT $L318865
  00935	8b 4c 24 50	 mov	 ecx, DWORD PTR __Cat$318822[esp+1208]
  00939	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0093c	51		 push	 ecx
  0093d	56		 push	 esi
  0093e	8d 54 24 18	 lea	 edx, DWORD PTR _strGuildMsg$268911[esp+1216]
  00942	52		 push	 edx
  00943	6a 01		 push	 1
  00945	57		 push	 edi
  00946	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IV12@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@YAXPAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@IABV12@AAV?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > *,unsigned int,ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >
  0094b	83 c4 14	 add	 esp, 20			; 00000014H
  0094e	83 c7 04	 add	 edi, 4
  00951	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00954	8b 7c 24 2c	 mov	 edi, DWORD PTR $T319023[esp+1208]
  00958	eb 12		 jmp	 SHORT $L318857
$L318865:
  0095a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0095d	8d 4c 24 10	 lea	 ecx, DWORD PTR _strGuildMsg$268911[esp+1208]
  00961	51		 push	 ecx
  00962	6a 01		 push	 1
  00964	50		 push	 eax
  00965	8b ce		 mov	 ecx, esi
  00967	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V?$allocator@V?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@std@@@std@@IAEXViterator@12@IABV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; std::vector<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >,std::allocator<ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > > > >::_Insert_n
$L318857:

; 1337 : 				}

  0096c	8b 44 24 14	 mov	 eax, DWORD PTR _strItemMsg$268923[esp+1208]
  00970	83 c0 f0	 add	 eax, -16		; fffffff0H
  00973	c6 84 24 b4 04
	00 00 05	 mov	 BYTE PTR __$EHRec$[esp+1216], 5
  0097b	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  0097e	83 c9 ff	 or	 ecx, -1
  00981	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00985	49		 dec	 ecx
  00986	85 c9		 test	 ecx, ecx
  00988	7f 59		 jg	 SHORT $L268925
  0098a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0098c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0098e	50		 push	 eax
  0098f	ff 52 04	 call	 DWORD PTR [edx+4]

; 1338 : 				else

  00992	eb 4f		 jmp	 SHORT $L268925
$L268919:

; 1339 : 				{
; 1340 : 					LogItemInfo aLogItem;

  00994	8d 8c 24 10 01
	00 00		 lea	 ecx, DWORD PTR _aLogItem$268926[esp+1208]
  0099b	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 1341 : 					aLogItem.Action = "W";
; 1342 : 					aLogItem.SendName = "GUILDCOMBAT_NOT";
; 1343 : 					aLogItem.RecvName = "GUILDBANK";
; 1344 : 					g_DPSrvr.OnLogItem( aLogItem, &itemElem, vecGCSendItem[si].nItemNum );

  009a0	8b 87 04 11 00
	00		 mov	 eax, DWORD PTR [edi+4356]
  009a6	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$268926[esp+1208], OFFSET FLAT:??_C@_01ELNMCGJD@W?$AA@
  009b1	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$268926[esp+1212], OFFSET FLAT:??_C@_0BA@PDOEFPGE@GUILDCOMBAT_NOT?$AA@
  009bc	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR _aLogItem$268926[esp+1216], OFFSET FLAT:??_C@_09BBHEADKN@GUILDBANK?$AA@
  009c7	8b 44 18 08	 mov	 eax, DWORD PTR [eax+ebx+8]
  009cb	50		 push	 eax
  009cc	8d 4c 24 5c	 lea	 ecx, DWORD PTR _itemElem$268918[esp+1212]
  009d0	51		 push	 ecx
  009d1	8d 94 24 18 01
	00 00		 lea	 edx, DWORD PTR _aLogItem$268926[esp+1216]
  009d8	52		 push	 edx
  009d9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  009de	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem
$L268925:

; 1345 : 				}
; 1346 : 			}

  009e3	8d 4c 24 58	 lea	 ecx, DWORD PTR _itemElem$268918[esp+1208]
  009e7	c6 84 24 b4 04
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+1216], 4
  009ef	e8 00 00 00 00	 call	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
  009f4	8b 74 24 30	 mov	 esi, DWORD PTR _pGuild$268904[esp+1208]
$L268915:
  009f8	ff 44 24 28	 inc	 DWORD PTR _si$268912[esp+1208]
  009fc	83 c3 0c	 add	 ebx, 12			; 0000000cH
  009ff	e9 dc fc ff ff	 jmp	 $L268914
$L268916:

; 1347 : #if __VER < 11 // __GUILDCOMBATCHIP
; 1348 : 			strGuildMsg.Format(prj.GetText(TID_GAME_GUILDCOMBAT_PRIZEMSG2) );
; 1349 : 			m_vecstrGuildMsg.push_back( strGuildMsg );
; 1350 : #endif // __GUILDCOMBATCHIP
; 1351 : #else // __VER >= 8
; 1352 : 			if( 0 )//g_eLocal.GetState( 500 ) == 1 )
; 1353 : 			{
; 1354 : 				CItemElem itemElem1;
; 1355 : 				itemElem1.m_dwItemId	= II_SYS_SYS_SCR_BXSCRACH;	// 
; 1356 : 				itemElem1.m_nItemNum	= 1;
; 1357 : 
; 1358 : 				CItemElem aItemElem[3];
; 1359 : 				int nItemSize	= 0;
; 1360 : 				CTime t	= CTime::GetCurrentTime() + CTimeSpan( 14, 0, 0, 0 );	// 2  
; 1361 : 				DWORD dwKeepTime	= t.GetTime();
; 1362 : 				if( m_nWinGuildCount == 1 )
; 1363 : 				{
; 1364 : 					aItemElem[0].m_dwItemId	= II_RID_RID_BOR_RIDINGCLOUD;
; 1365 : 					aItemElem[0].m_nItemNum	= 1;
; 1366 : 					aItemElem[0].m_dwKeepTime	= dwKeepTime;
; 1367 : 					nItemSize	= 1;
; 1368 : 				}
; 1369 : 				else if( m_nWinGuildCount == 2 )
; 1370 : 				{
; 1371 : 					aItemElem[0].m_dwItemId	= II_GEN_JEW_NEC_HPNECKLACE06;
; 1372 : 					aItemElem[0].m_nItemNum	= 1;
; 1373 : 					aItemElem[0].m_dwKeepTime	= dwKeepTime;
; 1374 : 					nItemSize	= 1;
; 1375 : 				}
; 1376 : 				else if( m_nWinGuildCount == 3 )
; 1377 : 				{
; 1378 : 					aItemElem[0].m_dwItemId	= II_GEN_JEW_EAR_DEFEARRING06;
; 1379 : 					aItemElem[0].m_nItemNum	= 1;
; 1380 : 					aItemElem[0].m_dwKeepTime	= dwKeepTime;
; 1381 : 					aItemElem[1].m_dwItemId	= II_GEN_JEW_EAR_DEFEARRING06;
; 1382 : 					aItemElem[1].m_nItemNum	= 1;
; 1383 : 					aItemElem[1].m_dwKeepTime	= dwKeepTime;
; 1384 : 					nItemSize	= 2;
; 1385 : 				}
; 1386 : 				else	// > 4
; 1387 : 				{
; 1388 : 					aItemElem[0].m_dwItemId	= II_GEN_JEW_NEC_HPNECKLACE06;
; 1389 : 					aItemElem[0].m_nItemNum	= 1;
; 1390 : 					aItemElem[0].m_dwKeepTime	= dwKeepTime;
; 1391 : 					aItemElem[1].m_dwItemId	= II_GEN_JEW_EAR_DEFEARRING06;
; 1392 : 					aItemElem[1].m_nItemNum	= 1;
; 1393 : 					aItemElem[1].m_dwKeepTime	= dwKeepTime;
; 1394 : 					aItemElem[2].m_dwItemId	= II_GEN_JEW_EAR_DEFEARRING06;
; 1395 : 					aItemElem[2].m_nItemNum	= 1;
; 1396 : 					aItemElem[2].m_dwKeepTime	= dwKeepTime;
; 1397 : 					nItemSize	= 3;
; 1398 : 				}
; 1399 : 
; 1400 : 				for( map<u_long, __GuildCombatMember*>::iterator i1	= m_GuildCombatMem.begin(); i1 != m_GuildCombatMem.end(); ++i1 )
; 1401 : 				{
; 1402 : 					u_long idGuild	= i1->first;
; 1403 : 					__GuildCombatMember* pGCMember	= i1->second;
; 1404 : 					for( int i = 0; i < pGCMember->vecGCSelectMember.size(); ++i )
; 1405 : 					{
; 1406 : 						__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[i];
; 1407 : 						itemElem1.SetSerialNumber();
; 1408 : 						g_dpDBClient.SendQueryPostMail( pJoinPlayer->uidPlayer, 0, itemElem1, 0, itemElem1.GetProp()->szName, (char*)GETTEXT( TID_GAME_GUILDCOMBAT_EVENT_MAIL ) );
; 1409 : 						if( idGuild == m_uWinGuildId )
; 1410 : 						{
; 1411 : 							for( int i = 0; i < nItemSize; i++ )
; 1412 : 							{
; 1413 : 								aItemElem[i].SetSerialNumber();
; 1414 : 								g_dpDBClient.SendQueryPostMail( pJoinPlayer->uidPlayer, 0, aItemElem[i], 0, aItemElem[i].GetProp()->szName, "" );
; 1415 : 							}
; 1416 : 						}
; 1417 : 					}
; 1418 : 				}
; 1419 : 			}	// 500
; 1420 : #endif // __VER >= 8
; 1421 : 		}

  00a04	8b 44 24 10	 mov	 eax, DWORD PTR _strGuildMsg$268911[esp+1208]
  00a08	83 c0 f0	 add	 eax, -16		; fffffff0H
  00a0b	c6 84 24 b4 04
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+1216], 3
  00a13	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00a16	83 ca ff	 or	 edx, -1
  00a19	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00a1d	4a		 dec	 edx
  00a1e	85 d2		 test	 edx, edx
  00a20	7f 08		 jg	 SHORT $L318974
  00a22	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a24	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a26	50		 push	 eax
  00a27	ff 52 04	 call	 DWORD PTR [edx+4]
$L318974:

; 1422 : 		u_long uBestPlayerGuild;
; 1423 : 		int nGetPoint;
; 1424 : 		m_uBestPlayer = GetBestPlayer( &uBestPlayerGuild, &nGetPoint );

  00a2a	8b 74 24 2c	 mov	 esi, DWORD PTR $T319023[esp+1208]
  00a2e	8d 44 24 48	 lea	 eax, DWORD PTR _nGetPoint$268929[esp+1208]
  00a32	50		 push	 eax
  00a33	8d 4c 24 18	 lea	 ecx, DWORD PTR _uBestPlayerGuild$268928[esp+1212]
  00a37	51		 push	 ecx
  00a38	8b ce		 mov	 ecx, esi
  00a3a	e8 00 00 00 00	 call	 ?GetBestPlayer@CGuildCombat@@QAEKPAKPAH@Z ; CGuildCombat::GetBestPlayer
  00a3f	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 1425 : 
; 1426 : #if __VER < 11 // __GUILD_COMBAT_1TO1
; 1427 : 		g_DPCoreClient.SendSystem( str );
; 1428 : 		g_DPCoreClient.SendCaption( str, 0, TRUE );
; 1429 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 1430 : 		sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_WINNER1), CPlayerDataCenter::GetInstance()->GetPlayerString( m_uBestPlayer ) );
; 1431 : #else	// __SYS_PLAYER_DATA
; 1432 : 		sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_WINNER1), prj.GetPlayerString( m_uBestPlayer ) );
; 1433 : #endif	// __SYS_PLAYER_DATA
; 1434 : 		g_DPCoreClient.SendSystem( str );
; 1435 : 		g_DPCoreClient.SendCaption( str, 0, TRUE );
; 1436 : 		sprintf( str, prj.GetText(TID_GAME_GUILDCOMBAT_WINNER2) );
; 1437 : 		g_DPCoreClient.SendSystem( str );
; 1438 : 		g_DPCoreClient.SendCaption( str, 0, TRUE );
; 1439 : #endif // __GUILD_COMBAT_1TO1
; 1440 : 		
; 1441 : 		++m_nGuildCombatIndex;

  00a42	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00a45	40		 inc	 eax

; 1442 : 		g_UserMng.AddGCWinGuild();

  00a46	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00a4b	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00a4e	e8 00 00 00 00	 call	 ?AddGCWinGuild@CUserMng@@QAEXXZ ; CUserMng::AddGCWinGuild

; 1443 : 		g_UserMng.AddGCBestPlayer();

  00a53	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00a58	e8 00 00 00 00	 call	 ?AddGCBestPlayer@CUserMng@@QAEXXZ ; CUserMng::AddGCBestPlayer

; 1444 : 
; 1445 : 		g_UserMng.AddGCLogWorld();

  00a5d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00a62	e8 00 00 00 00	 call	 ?AddGCLogWorld@CUserMng@@QAEXXZ ; CUserMng::AddGCLogWorld
  00a67	8b 74 24 3c	 mov	 esi, DWORD PTR _vecSameidGuildWin$[esp+1212]
$L268903:

; 1446 : 	}
; 1447 : }

  00a6b	8b 44 24 50	 mov	 eax, DWORD PTR _strPrizeMsg$[esp+1208]
  00a6f	83 c0 f0	 add	 eax, -16		; fffffff0H
  00a72	c6 84 24 b4 04
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1216], 0
  00a7a	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  00a7d	83 c9 ff	 or	 ecx, -1
  00a80	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00a84	49		 dec	 ecx
  00a85	85 c9		 test	 ecx, ecx
  00a87	7f 08		 jg	 SHORT $L319001
  00a89	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a8b	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a8d	50		 push	 eax
  00a8e	ff 52 04	 call	 DWORD PTR [edx+4]
$L319001:
  00a91	85 f6		 test	 esi, esi
  00a93	74 09		 je	 SHORT $L319021
  00a95	56		 push	 esi
  00a96	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a9b	83 c4 04	 add	 esp, 4
$L319021:
  00a9e	8b 8c 24 ac 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1208]
  00aa5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00aac	8b 8c 24 a4 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1208]
  00ab3	5f		 pop	 edi
  00ab4	5e		 pop	 esi
  00ab5	33 cd		 xor	 ecx, ebp
  00ab7	5b		 pop	 ebx
  00ab8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00abd	8b e5		 mov	 esp, ebp
  00abf	5d		 pop	 ebp
  00ac0	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L315037:
  00000	8d 8d 80 fb ff
	ff		 lea	 ecx, DWORD PTR _vecSameidGuildWin$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
$L315038:
  0000b	8d 8d 60 fb ff
	ff		 lea	 ecx, DWORD PTR _vecSameidGuildWinTmp$268854[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
$L315039:
  00016	8d 8d 60 fb ff
	ff		 lea	 ecx, DWORD PTR _vecSameidGuildWinTmp$268875[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
$L315040:
  00021	8d 8d 98 fb ff
	ff		 lea	 ecx, DWORD PTR _strPrizeMsg$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L315041:
  0002c	8d 8d 58 fb ff
	ff		 lea	 ecx, DWORD PTR _strGuildMsg$268911[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L315042:
  00037	8d 8d a0 fb ff
	ff		 lea	 ecx, DWORD PTR _itemElem$268918[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1CItemElem@@UAE@XZ	; CItemElem::~CItemElem
$L315043:
  00042	8d 8d 5c fb ff
	ff		 lea	 ecx, DWORD PTR _strItemMsg$268923[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?GuildCombatResult@CGuildCombat@@QAEXHK@Z:
  0004d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T319025
  00052	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GuildCombatResult@CGuildCombat@@QAEXHK@Z ENDP		; CGuildCombat::GuildCombatResult
PUBLIC	?SetGuildCombatCloseWait@CGuildCombat@@QAEXH@Z	; CGuildCombat::SetGuildCombatCloseWait
; Function compile flags: /Ogty
;	COMDAT ?SetGuildCombatCloseWait@CGuildCombat@@QAEXH@Z
_TEXT	SEGMENT
_bGM$ = 8						; size = 4
?SetGuildCombatCloseWait@CGuildCombat@@QAEXH@Z PROC NEAR ; CGuildCombat::SetGuildCombatCloseWait, COMDAT
; _this$ = ecx

; 2662 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2663 : 	if( m_nState == CLOSE_STATE )

  00003	83 be 40 11 00
	00 01		 cmp	 DWORD PTR [esi+4416], 1
  0000a	74 28		 je	 SHORT $L269746

; 2664 : 		return;
; 2665 : 
; 2666 : 	if( bGM )

  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _bGM$[esp]
  00010	85 c0		 test	 eax, eax
  00012	74 0e		 je	 SHORT $L269745

; 2667 : 	{
; 2668 : 		m_nStopWar = 2;

  00014	c7 86 8c 10 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+4236], 2
  0001e	5e		 pop	 esi

; 2676 : #endif // __GUILDCOMBATCHIP
; 2677 : 	}	
; 2678 : }

  0001f	c2 04 00	 ret	 4
$L269745:

; 2669 : 		return;
; 2670 : 	}
; 2671 : 	else
; 2672 : 	{
; 2673 : 		GuildCombatResult();

  00022	6a 00		 push	 0
  00024	6a 00		 push	 0
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?GuildCombatResult@CGuildCombat@@QAEXHK@Z ; CGuildCombat::GuildCombatResult

; 2674 : #if __VER >= 11 // __GUILDCOMBATCHIP
; 2675 : 		GuildCombatResultRanking();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?GuildCombatResultRanking@CGuildCombat@@QAEXXZ ; CGuildCombat::GuildCombatResultRanking
$L269746:
  00034	5e		 pop	 esi

; 2676 : #endif // __GUILDCOMBATCHIP
; 2677 : 	}	
; 2678 : }

  00035	c2 04 00	 ret	 4
?SetGuildCombatCloseWait@CGuildCombat@@QAEXH@Z ENDP	; CGuildCombat::SetGuildCombatCloseWait
_TEXT	ENDS
PUBLIC	?SetMaintenance@CGuildCombat@@QAEXXZ		; CGuildCombat::SetMaintenance
EXTRN	?SendGuildcombatContinue@CDPDatabaseClient@@QAEXHKH@Z:NEAR ; CDPDatabaseClient::SendGuildcombatContinue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T320255 DD	0ffffffffH
	DD	FLAT:$L319088
	DD	00H
	DD	FLAT:$L319089
	DD	01H
	DD	FLAT:$L319090
$T320230 DD	019930520H
	DD	03H
	DD	FLAT:$T320255
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ?SetMaintenance@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_nVeci$269506 = -64					; size = 4
_nCount$ = -60						; size = 4
_pJoinPlayer$269529 = -56				; size = 4
_i$269519 = -56						; size = 4
_this$ = -52						; size = 4
_bWinGuild_Continue$ = -48				; size = 4
_strMsgGeneral$ = -44					; size = 4
_strMsgDefender$ = -40					; size = 4
_strMsgMaster$ = -36					; size = 4
__Newnode$319951 = -32					; size = 4
$T319568 = -32						; size = 4
_pJoinPlayer$269524 = -32				; size = 4
_i$319566 = -28						; size = 4
$T320101 = -24						; size = 4
_pGuild$269516 = -24					; size = 4
_RequestGuild$269512 = -24				; size = 8
_i$320079 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetMaintenance@CGuildCombat@@QAEXXZ PROC NEAR		; CGuildCombat::SetMaintenance, COMDAT
; _this$ = ecx

; 2208 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?SetMaintenance@CGuildCombat@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 34	 sub	 esp, 52			; 00000034H

; 2209 : 	CString strMsgMaster = prj.GetText( TID_GAME_GUILDCOMBAT_JOIN_MSG_MASTER );

  00018	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  0001d	3d 85 0b 00 00	 cmp	 eax, 2949		; 00000b85H
  00022	53		 push	 ebx
  00023	8b d9		 mov	 ebx, ecx
  00025	55		 push	 ebp
  00026	89 5c 24 14	 mov	 DWORD PTR _this$[esp+72], ebx
  0002a	7e 1d		 jle	 SHORT $L319121
  0002c	76 0f		 jbe	 SHORT $L320242
  0002e	a1 b8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+696
  00033	8b 80 14 2e 00
	00		 mov	 eax, DWORD PTR [eax+11796]
  00039	85 c0		 test	 eax, eax
  0003b	75 07		 jne	 SHORT $L319122
$L320242:
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00042	eb 24		 jmp	 SHORT $L319116
$L319122:
  00044	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00047	eb 1f		 jmp	 SHORT $L319116
$L319121:
  00049	68 85 0b 00 00	 push	 2949			; 00000b85H
  0004e	50		 push	 eax
  0004f	6a 00		 push	 0
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0005b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00060	83 c4 14	 add	 esp, 20			; 00000014H
  00063	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L319116:
  00068	50		 push	 eax
  00069	8d 4c 24 28	 lea	 ecx, DWORD PTR _strMsgMaster$[esp+76]
  0006d	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 2210 : 	CString strMsgDefender = prj.GetText( TID_GAME_GUILDCOMBAT_JOIN_MSG_DEFENDER );

  00072	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  00077	33 ed		 xor	 ebp, ebp
  00079	3d 86 0b 00 00	 cmp	 eax, 2950		; 00000b86H
  0007e	89 6c 24 44	 mov	 DWORD PTR __$EHRec$[esp+80], ebp
  00082	7e 1e		 jle	 SHORT $L319169
  00084	76 10		 jbe	 SHORT $L320238
  00086	8b 0d b8 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+696
  0008c	8b 81 18 2e 00
	00		 mov	 eax, DWORD PTR [ecx+11800]
  00092	3b c5		 cmp	 eax, ebp
  00094	75 07		 jne	 SHORT $L319170
$L320238:
  00096	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0009b	eb 23		 jmp	 SHORT $L319164
$L319170:
  0009d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a0	eb 1e		 jmp	 SHORT $L319164
$L319169:
  000a2	68 86 0b 00 00	 push	 2950			; 00000b86H
  000a7	50		 push	 eax
  000a8	55		 push	 ebp
  000a9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  000ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000b3	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L319164:
  000c0	50		 push	 eax
  000c1	8d 4c 24 24	 lea	 ecx, DWORD PTR _strMsgDefender$[esp+76]
  000c5	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 2211 : 	CString strMsgGeneral = prj.GetText( TID_GAME_GUILDCOMBAT_JOIN_MSG_GENERAL );

  000ca	a1 c8 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+712
  000cf	3d 87 0b 00 00	 cmp	 eax, 2951		; 00000b87H
  000d4	c6 44 24 44 01	 mov	 BYTE PTR __$EHRec$[esp+80], 1
  000d9	7e 1e		 jle	 SHORT $L319217
  000db	76 10		 jbe	 SHORT $L320239
  000dd	8b 15 b8 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+696
  000e3	8b 82 1c 2e 00
	00		 mov	 eax, DWORD PTR [edx+11804]
  000e9	3b c5		 cmp	 eax, ebp
  000eb	75 07		 jne	 SHORT $L319218
$L320239:
  000ed	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000f2	eb 23		 jmp	 SHORT $L319212
$L319218:
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	eb 1e		 jmp	 SHORT $L319212
$L319217:
  000f9	68 87 0b 00 00	 push	 2951			; 00000b87H
  000fe	50		 push	 eax
  000ff	55		 push	 ebp
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00105	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0010a	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0010f	83 c4 14	 add	 esp, 20			; 00000014H
  00112	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
$L319212:
  00117	56		 push	 esi
  00118	57		 push	 edi
  00119	50		 push	 eax
  0011a	8d 4c 24 28	 lea	 ecx, DWORD PTR _strMsgGeneral$[esp+84]
  0011e	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  00123	c6 44 24 4c 02	 mov	 BYTE PTR __$EHRec$[esp+88], 2

; 2212 : 	
; 2213 : 	BOOL bWinGuild_Continue = FALSE;		//      

  00128	89 6c 24 20	 mov	 DWORD PTR _bWinGuild_Continue$[esp+80], ebp

; 2214 : 	int nCount = 0;

  0012c	89 6c 24 14	 mov	 DWORD PTR _nCount$[esp+80], ebp

; 2215 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  00130	33 ff		 xor	 edi, edi
$L320254:
  00132	8b 8b 14 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4372]
  00138	3b cd		 cmp	 ecx, ebp
  0013a	89 7c 24 10	 mov	 DWORD PTR _nVeci$269506[esp+80], edi
  0013e	75 04		 jne	 SHORT $L319240
  00140	33 c0		 xor	 eax, eax
  00142	eb 0b		 jmp	 SHORT $L319241
$L319240:
  00144	8b 83 18 11 00
	00		 mov	 eax, DWORD PTR [ebx+4376]
  0014a	2b c1		 sub	 eax, ecx
  0014c	c1 f8 03	 sar	 eax, 3
$L319241:
  0014f	3b f8		 cmp	 edi, eax
  00151	0f 8d cd 02 00
	00		 jge	 $L320236

; 2216 : 	{
; 2217 : 		//      
; 2218 : 		if( nVeci >= m_nMaxGuild )

  00157	3b bb a0 10 00
	00		 cmp	 edi, DWORD PTR [ebx+4256]
  0015d	0f 8d c1 02 00
	00		 jge	 $L320236
  00163	8b 83 14 11 00
	00		 mov	 eax, DWORD PTR [ebx+4372]

; 2219 : 			break;
; 2220 : 
; 2221 : 		__REQUESTGUILD RequestGuild = vecRequestRanking[nVeci];

  00169	8b 0c f8	 mov	 ecx, DWORD PTR [eax+edi*8]
  0016c	8b 54 f8 04	 mov	 edx, DWORD PTR [eax+edi*8+4]
  00170	8d 04 f8	 lea	 eax, DWORD PTR [eax+edi*8]

; 2222 : 
; 2223 : 		if( RequestGuild.uidGuild == m_uWinGuildId )

  00173	3b 4b 44	 cmp	 ecx, DWORD PTR [ebx+68]
  00176	89 54 24 3c	 mov	 DWORD PTR _RequestGuild$269512[esp+84], edx
  0017a	75 08		 jne	 SHORT $L320243

; 2224 : 			bWinGuild_Continue = TRUE;

  0017c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bWinGuild_Continue$[esp+80], 1
$L320243:

; 2225 : 
; 2226 : #ifdef __S_BUG_GC
; 2227 : 		__GuildCombatMember* pGCMember = FindGuildCombatMember( RequestGuild.uidGuild );

  00184	51		 push	 ecx
  00185	8b cb		 mov	 ecx, ebx
  00187	e8 00 00 00 00	 call	 ?FindGuildCombatMember@CGuildCombat@@QAEPAU__GuildCombatMember@1@K@Z ; CGuildCombat::FindGuildCombatMember
  0018c	8b f0		 mov	 esi, eax

; 2228 : 		if( pGCMember != NULL )

  0018e	3b f5		 cmp	 esi, ebp
  00190	0f 84 86 02 00
	00		 je	 $L269509

; 2229 : 		{
; 2230 : 			CGuild* pGuild = g_GuildMng.GetGuild( pGCMember->uGuildId );

  00196	8b 06		 mov	 eax, DWORD PTR [esi]
  00198	50		 push	 eax
  00199	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildMng@@3VCGuildMng@@A
  0019e	e8 00 00 00 00	 call	 ?GetGuild@CGuildMng@@QAEPAVCGuild@@K@Z ; CGuildMng::GetGuild

; 2231 : 			if( pGuild )

  001a3	3b c5		 cmp	 eax, ebp
  001a5	89 44 24 38	 mov	 DWORD PTR _pGuild$269516[esp+80], eax
  001a9	0f 84 6d 02 00
	00		 je	 $L269509

; 2232 : 			{
; 2233 : 				pGCMember->nJoinCount = 0;

  001af	89 6e 20	 mov	 DWORD PTR [esi+32], ebp

; 2234 : 				pGCMember->nWarCount = 0;

  001b2	89 6e 24	 mov	 DWORD PTR [esi+36], ebp

; 2235 : 				BOOL bMaxWarCount = FALSE;
; 2236 : 
; 2237 : 				for( int i = 0; i < (int)( pGCMember->vecGCSelectMember.size() ) ; ++i )

  001b5	33 d2		 xor	 edx, edx
$L320250:
  001b7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001ba	3b cd		 cmp	 ecx, ebp
  001bc	89 54 24 18	 mov	 DWORD PTR _i$269519[esp+80], edx
  001c0	75 04		 jne	 SHORT $L319303
  001c2	33 c0		 xor	 eax, eax
  001c4	eb 08		 jmp	 SHORT $L319304
$L319303:
  001c6	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001c9	2b c1		 sub	 eax, ecx
  001cb	c1 f8 02	 sar	 eax, 2
$L319304:
  001ce	3b d0		 cmp	 edx, eax
  001d0	7d 48		 jge	 SHORT $L320233
  001d2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001d5	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 2238 : 				{
; 2239 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[i];

  001d8	8b 00		 mov	 eax, DWORD PTR [eax]

; 2240 : 					if( 0 < pJoinPlayer->nlife )

  001da	39 68 04	 cmp	 DWORD PTR [eax+4], ebp
  001dd	89 44 24 30	 mov	 DWORD PTR _pJoinPlayer$269524[esp+80], eax
  001e1	7e 32		 jle	 SHORT $L269522

; 2241 : 						pGCMember->lspFifo.push_back( pJoinPlayer );

  001e3	8b 6e 30	 mov	 ebp, DWORD PTR [esi+48]
  001e6	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  001e9	8d 7e 2c	 lea	 edi, DWORD PTR [esi+44]
  001ec	8d 54 24 30	 lea	 edx, DWORD PTR _pJoinPlayer$269524[esp+80]
  001f0	52		 push	 edx
  001f1	50		 push	 eax
  001f2	55		 push	 ebp
  001f3	8b cf		 mov	 ecx, edi
  001f5	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  001fa	6a 01		 push	 1
  001fc	8b cf		 mov	 ecx, edi
  001fe	8b d8		 mov	 ebx, eax
  00200	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  00205	8b 54 24 18	 mov	 edx, DWORD PTR _i$269519[esp+80]
  00209	89 5d 04	 mov	 DWORD PTR [ebp+4], ebx
  0020c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0020f	89 19		 mov	 DWORD PTR [ecx], ebx
  00211	8b 5c 24 1c	 mov	 ebx, DWORD PTR _this$[esp+80]
$L269522:
  00215	42		 inc	 edx
  00216	33 ed		 xor	 ebp, ebp
  00218	eb 9d		 jmp	 SHORT $L320250
$L320233:

; 2242 : 				}
; 2243 : 
; 2244 : 				while( pGCMember->lspFifo.size() > 0 )

  0021a	39 6e 34	 cmp	 DWORD PTR [esi+52], ebp
  0021d	0f 86 26 01 00
	00		 jbe	 $L320245
$L269527:

; 2245 : 				{
; 2246 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->lspFifo.front();

  00223	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00226	8b 02		 mov	 eax, DWORD PTR [edx]
  00228	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 2247 : 					CMover* pMover	= prj.GetUserByID( pJoinPlayer->uidPlayer );

  0022b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0022d	8d 54 24 30	 lea	 edx, DWORD PTR $T319568[esp+80]
  00231	52		 push	 edx
  00232	8d 44 24 38	 lea	 eax, DWORD PTR _i$319566[esp+84]
  00236	89 4c 24 34	 mov	 DWORD PTR $T319568[esp+84], ecx
  0023a	50		 push	 eax
  0023b	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00240	89 7c 24 20	 mov	 DWORD PTR _pJoinPlayer$269529[esp+88], edi
  00244	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  00249	8b 44 24 34	 mov	 eax, DWORD PTR _i$319566[esp+80]
  0024d	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  00253	74 67		 je	 SHORT $L320244
  00255	8b 68 10	 mov	 ebp, DWORD PTR [eax+16]

; 2248 : 					if( IsValidObj( pMover ) && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  00258	85 ed		 test	 ebp, ebp
  0025a	74 60		 je	 SHORT $L320244
  0025c	f6 45 04 01	 test	 BYTE PTR [ebp+4], 1
  00260	75 5a		 jne	 SHORT $L320244
  00262	8b 8d 6c 01 00
	00		 mov	 ecx, DWORD PTR [ebp+364]
  00268	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  0026e	75 4c		 jne	 SHORT $L320244

; 2249 : 					{
; 2250 : 						pGCMember->nWarCount++;

  00270	ff 46 24	 inc	 DWORD PTR [esi+36]

; 2251 : //						pJoinPlayer->bEntry	= TRUE;
; 2252 : 						pJoinPlayer->dwTelTime	= timeGetTime();

  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00279	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 2253 : 						((CUser*)pMover)->AddGCJoinWarWindow( pJoinPlayer->nMap, m_nMaxMapTime );

  0027c	8b 93 b0 10 00
	00		 mov	 edx, DWORD PTR [ebx+4272]
  00282	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00285	52		 push	 edx
  00286	50		 push	 eax
  00287	8b cd		 mov	 ecx, ebp
  00289	e8 00 00 00 00	 call	 ?AddGCJoinWarWindow@CUser@@QAEXHH@Z ; CUser::AddGCJoinWarWindow

; 2254 : 						pGCMember->lspFifo.pop_front();

  0028e	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00291	8b 01		 mov	 eax, DWORD PTR [ecx]
  00293	3b c1		 cmp	 eax, ecx
  00295	0f 84 98 00 00
	00		 je	 $L269535
  0029b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0029e	8b 10		 mov	 edx, DWORD PTR [eax]
  002a0	89 11		 mov	 DWORD PTR [ecx], edx
  002a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002a7	50		 push	 eax
  002a8	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  002ab	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002b0	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  002b3	83 c4 04	 add	 esp, 4
  002b6	48		 dec	 eax
  002b7	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 2255 : 					}
; 2256 : 					else

  002ba	eb 77		 jmp	 SHORT $L269535
$L320244:

; 2257 : 					{
; 2258 : 						pGCMember->lspFifo.pop_front();

  002bc	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  002bf	8b 01		 mov	 eax, DWORD PTR [ecx]
  002c1	3b c1		 cmp	 eax, ecx
  002c3	8d 6e 2c	 lea	 ebp, DWORD PTR [esi+44]
  002c6	74 1f		 je	 SHORT $L319888
  002c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002cb	8b 10		 mov	 edx, DWORD PTR [eax]
  002cd	89 11		 mov	 DWORD PTR [ecx], edx
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002d4	50		 push	 eax
  002d5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  002d8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002dd	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  002e0	83 c4 04	 add	 esp, 4
  002e3	48		 dec	 eax
  002e4	89 45 08	 mov	 DWORD PTR [ebp+8], eax
$L319888:

; 2259 : 						pJoinPlayer->nlife--;

  002e7	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  002ea	49		 dec	 ecx

; 2260 : 						if( pJoinPlayer->nlife > 0 )

  002eb	8b c1		 mov	 eax, ecx
  002ed	85 c0		 test	 eax, eax
  002ef	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  002f2	7e 36		 jle	 SHORT $L320251

; 2261 : 							pGCMember->lspFifo.push_back( pJoinPlayer );

  002f4	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  002f7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  002fa	8d 44 24 18	 lea	 eax, DWORD PTR _pJoinPlayer$269529[esp+80]
  002fe	50		 push	 eax
  002ff	51		 push	 ecx
  00300	53		 push	 ebx
  00301	8b cd		 mov	 ecx, ebp
  00303	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@0ABQAU__JOINPLAYER@CGuildCombat@@@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Buynode
  00308	6a 01		 push	 1
  0030a	8b cd		 mov	 ecx, ebp
  0030c	89 44 24 34	 mov	 DWORD PTR __Newnode$319951[esp+84], eax
  00310	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXI@Z ; std::list<CGuildCombat::__JOINPLAYER *,std::allocator<CGuildCombat::__JOINPLAYER *> >::_Incsize
  00315	8b 44 24 30	 mov	 eax, DWORD PTR __Newnode$319951[esp+80]
  00319	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0031c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0031f	8b 5c 24 1c	 mov	 ebx, DWORD PTR _this$[esp+80]
  00323	89 02		 mov	 DWORD PTR [edx], eax

; 2262 : 						if( pJoinPlayer->nlife < 0 )

  00325	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00328	85 c0		 test	 eax, eax
$L320251:
  0032a	7d 07		 jge	 SHORT $L269535

; 2263 : 							pJoinPlayer->nlife	= 0;

  0032c	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$L269535:

; 2264 : 					}
; 2265 : 					if( pGCMember->nWarCount == m_nMaxWarPlayer )

  00333	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00336	3b 83 ac 10 00
	00		 cmp	 eax, DWORD PTR [ebx+4268]
  0033c	74 0b		 je	 SHORT $L320245
  0033e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00341	85 c0		 test	 eax, eax
  00343	0f 87 da fe ff
	ff		 ja	 $L269527
$L320245:

; 2266 : 						break;
; 2267 : 				}
; 2268 : 
; 2269 : 				g_UserMng.AddGCGuildStatus( pGCMember->uGuildId );

  00349	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0034b	6a 00		 push	 0
  0034d	51		 push	 ecx
  0034e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00353	e8 00 00 00 00	 call	 ?AddGCGuildStatus@CUserMng@@QAEXKPAVCUser@@@Z ; CUserMng::AddGCGuildStatus

; 2270 : 
; 2271 : #if __VER >= 15 // __IMPROVE_SYSTEM_VER15
; 2272 : 				for( int veci = 0; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  00358	8b 6c 24 38	 mov	 ebp, DWORD PTR _pGuild$269516[esp+80]
  0035c	33 ff		 xor	 edi, edi
  0035e	8b ff		 npad	 2
$L269539:
  00360	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00363	85 c9		 test	 ecx, ecx
  00365	75 04		 jne	 SHORT $L319970
  00367	33 c0		 xor	 eax, eax
  00369	eb 08		 jmp	 SHORT $L319971
$L319970:
  0036b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0036e	2b c1		 sub	 eax, ecx
  00370	c1 f8 02	 sar	 eax, 2
$L319971:
  00373	3b f8		 cmp	 edi, eax
  00375	0f 8d 86 00 00
	00		 jge	 $L269541
  0037b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0037e	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]

; 2273 : 				{
; 2274 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[veci];

  00381	8b 00		 mov	 eax, DWORD PTR [eax]

; 2275 : 					CMover* pMover	= prj.GetUserByID( pJoinPlayer->uidPlayer );

  00383	8b 08		 mov	 ecx, DWORD PTR [eax]
  00385	8d 54 24 38	 lea	 edx, DWORD PTR $T320101[esp+80]
  00389	52		 push	 edx
  0038a	8d 44 24 44	 lea	 eax, DWORD PTR _i$320079[esp+84]
  0038e	89 4c 24 3c	 mov	 DWORD PTR $T320101[esp+84], ecx
  00392	50		 push	 eax
  00393	b9 38 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+56
  00398	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
  0039d	8b 44 24 40	 mov	 eax, DWORD PTR _i$320079[esp+80]
  003a1	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+60
  003a7	74 52		 je	 SHORT $L269540
  003a9	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 2276 : 					if( IsValidObj( pMover ) && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  003ac	85 c9		 test	 ecx, ecx
  003ae	74 4b		 je	 SHORT $L269540
  003b0	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  003b4	75 45		 jne	 SHORT $L269540
  003b6	8b 91 6c 01 00
	00		 mov	 edx, DWORD PTR [ecx+364]
  003bc	81 3a ca 00 00
	00		 cmp	 DWORD PTR [edx], 202	; 000000caH
  003c2	75 37		 jne	 SHORT $L269540

; 2277 : 					{
; 2278 : 						// Message
; 2279 : 						if( pGuild->IsMaster( pMover->m_idPlayer ) )	// Master

  003c4	8b 81 38 02 00
	00		 mov	 eax, DWORD PTR [ecx+568]
  003ca	39 45 44	 cmp	 DWORD PTR [ebp+68], eax
  003cd	75 0d		 jne	 SHORT $L269545

; 2280 : 							((CUser*)pMover)->AddDiagText( strMsgMaster );

  003cf	8b 44 24 2c	 mov	 eax, DWORD PTR _strMsgMaster$[esp+80]

; 2283 : 						else
; 2284 : 							((CUser*)pMover)->AddDiagText( strMsgGeneral );

  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText
  003d9	47		 inc	 edi
  003da	eb 84		 jmp	 SHORT $L269539
$L269545:

; 2281 : 						else if( pGCMember->m_uidDefender == pMover->m_idPlayer )	// Defender

  003dc	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  003df	75 10		 jne	 SHORT $L269548

; 2282 : 							((CUser*)pMover)->AddDiagText( strMsgDefender );

  003e1	8b 54 24 28	 mov	 edx, DWORD PTR _strMsgDefender$[esp+80]
  003e5	52		 push	 edx

; 2283 : 						else
; 2284 : 							((CUser*)pMover)->AddDiagText( strMsgGeneral );

  003e6	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText
  003eb	47		 inc	 edi
  003ec	e9 6f ff ff ff	 jmp	 $L269539
$L269548:
  003f1	8b 44 24 24	 mov	 eax, DWORD PTR _strMsgGeneral$[esp+80]
  003f5	50		 push	 eax
  003f6	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText
$L269540:

; 2270 : 
; 2271 : #if __VER >= 15 // __IMPROVE_SYSTEM_VER15
; 2272 : 				for( int veci = 0; veci < (int)( pGCMember->vecGCSelectMember.size() ) ; ++veci )

  003fb	47		 inc	 edi
  003fc	e9 5f ff ff ff	 jmp	 $L269539
$L269541:

; 2285 : 					}
; 2286 : 				}
; 2287 : #else // __IMPROVE_SYSTEM_VER15
; 2288 : 				//  
; 2289 : 				CMover* pLeader = NULL;
; 2290 : 				for( int veci = 0; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 2291 : 				{
; 2292 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[veci];
; 2293 : 					CMover* pMover	= prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2294 : 					if( IsValidObj( pMover ) && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )
; 2295 : 					{
; 2296 : 						// Message
; 2297 : 						if( pGuild->IsMaster( pMover->m_idPlayer ) )	// Master
; 2298 : 							((CUser*)pMover)->AddDiagText( strMsgMaster );
; 2299 : 						else if( pGCMember->m_uidDefender == pMover->m_idPlayer )	// Defender
; 2300 : 							((CUser*)pMover)->AddDiagText( strMsgDefender );
; 2301 : 						else
; 2302 : 							((CUser*)pMover)->AddDiagText( strMsgGeneral );
; 2303 : 						if( pLeader == NULL )
; 2304 : 							pLeader = pMover;
; 2305 : 						else					
; 2306 : 							g_DPCoreClient.SendGCAddParty( pLeader->m_idPlayer, pLeader->GetLevel(), pLeader->GetJob(), pLeader->GetSex(), 
; 2307 : 							pMover->m_idPlayer, pMover->GetLevel(), pMover->GetJob(), pMover->GetSex() );
; 2308 : 					}
; 2309 : 				}
; 2310 : #endif // __IMPROVE_SYSTEM_VER15
; 2311 : 
; 2312 : 				if( 0 < pGCMember->vecGCSelectMember.size() )

  00401	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00404	85 c0		 test	 eax, eax
  00406	74 10		 je	 SHORT $L320248
  00408	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  0040b	2b f0		 sub	 esi, eax
  0040d	c1 fe 02	 sar	 esi, 2
  00410	85 f6		 test	 esi, esi
  00412	76 04		 jbe	 SHORT $L320248

; 2313 : 					++nCount;

  00414	ff 44 24 14	 inc	 DWORD PTR _nCount$[esp+80]
$L320248:
  00418	8b 7c 24 10	 mov	 edi, DWORD PTR _nVeci$269506[esp+80]
$L269509:

; 2215 : 	for( int nVeci = 0 ; nVeci < (int)( vecRequestRanking.size() ) ; ++nVeci )

  0041c	47		 inc	 edi
  0041d	33 ed		 xor	 ebp, ebp
  0041f	e9 0e fd ff ff	 jmp	 $L320254
$L320236:

; 2314 : 			}
; 2315 : 		}
; 2316 : #else // __S_BUG_GC
; 2317 : 		map<u_long, __GuildCombatMember*>::iterator ita = m_GuildCombatMem.find( RequestGuild.uidGuild );
; 2318 : 		if( ita != m_GuildCombatMem.end() )
; 2319 : 		{
; 2320 : 			__GuildCombatMember* pGCMember = ita->second;
; 2321 : 			CGuild* pGuild = g_GuildMng.GetGuild( RequestGuild.uidGuild );
; 2322 : 			if( pGuild )
; 2323 : 			{
; 2324 : 				pGCMember->nJoinCount = 0;
; 2325 : 				pGCMember->nWarCount = 0;
; 2326 : 				BOOL bMaxWarCount = FALSE;
; 2327 : 
; 2328 : 				for( int i = 0; i < pGCMember->vecGCSelectMember.size() ; ++i )
; 2329 : 				{
; 2330 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[i];
; 2331 : 					if( 0 < pJoinPlayer->nlife )
; 2332 : 						pGCMember->lspFifo.push_back( pJoinPlayer );
; 2333 : 				}
; 2334 : 
; 2335 : 				while( pGCMember->lspFifo.size() > 0 )
; 2336 : 				{
; 2337 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->lspFifo.front();
; 2338 : 					CMover* pMover	= prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2339 : 					if( IsValidObj( pMover ) && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )
; 2340 : 					{
; 2341 : 						pGCMember->nWarCount++;
; 2342 : //						pJoinPlayer->bEntry	= TRUE;
; 2343 : 						pJoinPlayer->dwTelTime	= timeGetTime();
; 2344 : 						((CUser*)pMover)->AddGCJoinWarWindow( pJoinPlayer->nMap, m_nMaxMapTime );
; 2345 : 						pGCMember->lspFifo.pop_front();
; 2346 : 					}
; 2347 : 					else
; 2348 : 					{
; 2349 : 						pGCMember->lspFifo.pop_front();
; 2350 : 						pJoinPlayer->nlife--;
; 2351 : 						if( pJoinPlayer->nlife > 0 )
; 2352 : 							pGCMember->lspFifo.push_back( pJoinPlayer );
; 2353 : 						if( pJoinPlayer->nlife < 0 )
; 2354 : 							pJoinPlayer->nlife	= 0;
; 2355 : 					}
; 2356 : 					if( pGCMember->nWarCount == m_nMaxWarPlayer )
; 2357 : 						break;
; 2358 : 				}
; 2359 : 
; 2360 : 				g_UserMng.AddGCGuildStatus( ita->first );
; 2361 : 
; 2362 : 				//  
; 2363 : 				CMover* pLeader = NULL;
; 2364 : 				for( int veci = 0; veci < pGCMember->vecGCSelectMember.size() ; ++veci )
; 2365 : 				{
; 2366 : 					__JOINPLAYER* pJoinPlayer	= pGCMember->vecGCSelectMember[veci];
; 2367 : 					CMover* pMover	= prj.GetUserByID( pJoinPlayer->uidPlayer );
; 2368 : 					if( IsValidObj( pMover ) && pMover->GetWorld()->GetID() == WI_WORLD_GUILDWAR )
; 2369 : 					{
; 2370 : 						// Message
; 2371 : 						if( pGuild->IsMaster( pMover->m_idPlayer ) )	// Master
; 2372 : 							((CUser*)pMover)->AddDiagText( strMsgMaster );
; 2373 : 						else if( pGCMember->m_uidDefender == pMover->m_idPlayer )	// Defender
; 2374 : 							((CUser*)pMover)->AddDiagText( strMsgDefender );
; 2375 : 						else
; 2376 : 							((CUser*)pMover)->AddDiagText( strMsgGeneral );
; 2377 : 						if( pLeader == NULL )
; 2378 : 							pLeader = pMover;
; 2379 : 						else					
; 2380 : 							g_DPCoreClient.SendGCAddParty( pLeader->m_idPlayer, pLeader->GetLevel(), pLeader->GetJob(), pLeader->GetSex(), 
; 2381 : 							pMover->m_idPlayer, pMover->GetLevel(), pMover->GetJob(), pMover->GetSex() );
; 2382 : 					}
; 2383 : 				}
; 2384 : 
; 2385 : 				if( 0 < pGCMember->vecGCSelectMember.size() )
; 2386 : 					++nCount;
; 2387 : 			}
; 2388 : 		}
; 2389 : #endif // __S_BUG_GC
; 2390 : 	}
; 2391 : 
; 2392 : 	//   2   .
; 2393 : #if __VER >= 8 // __GUILDCOMBAT_85
; 2394 : 	if( nCount < m_nMinGuild )

  00424	8b 4c 24 14	 mov	 ecx, DWORD PTR _nCount$[esp+80]
  00428	3b 8b 98 10 00
	00		 cmp	 ecx, DWORD PTR [ebx+4248]
  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	7d 3d		 jge	 SHORT $L320143

; 2395 : #else // __VER >= 8
; 2396 : 	if( nCount < 2 )
; 2397 : #endif // __VER >= 8
; 2398 : 	{
; 2399 : 		//  
; 2400 : 		//      
; 2401 : 		//    (    )
; 2402 : 		if( bWinGuild_Continue == FALSE )

  00432	39 6c 24 18	 cmp	 DWORD PTR _bWinGuild_Continue$[esp+72], ebp
  00436	75 24		 jne	 SHORT $L269554

; 2403 : 		{
; 2404 : 			g_dpDBClient.SendGuildcombatContinue( m_nGuildCombatIndex-1, m_uWinGuildId, 0 );

  00438	8b 53 44	 mov	 edx, DWORD PTR [ebx+68]
  0043b	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  0043e	55		 push	 ebp
  0043f	52		 push	 edx
  00440	48		 dec	 eax
  00441	50		 push	 eax
  00442	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00447	e8 00 00 00 00	 call	 ?SendGuildcombatContinue@CDPDatabaseClient@@QAEXHKH@Z ; CDPDatabaseClient::SendGuildcombatContinue

; 2405 : 			m_uWinGuildId = 0;
; 2406 : 			m_nWinGuildCount = 0;
; 2407 : 
; 2408 : 			g_UserMng.AddGCWinGuild();

  0044c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00451	89 6b 44	 mov	 DWORD PTR [ebx+68], ebp
  00454	89 6b 48	 mov	 DWORD PTR [ebx+72], ebp
  00457	e8 00 00 00 00	 call	 ?AddGCWinGuild@CUserMng@@QAEXXZ ; CUserMng::AddGCWinGuild
$L269554:

; 2409 : 		}
; 2410 : 		SetGuildCombatCloseWait( TRUE );

  0045c	83 bb 40 11 00
	00 01		 cmp	 DWORD PTR [ebx+4416], 1
  00463	74 0a		 je	 SHORT $L320143
  00465	c7 83 8c 10 00
	00 02 00 00 00	 mov	 DWORD PTR [ebx+4236], 2
$L320143:

; 2411 : 	}
; 2412 : }

  0046f	8b 44 24 1c	 mov	 eax, DWORD PTR _strMsgGeneral$[esp+72]
  00473	83 c0 f0	 add	 eax, -16		; fffffff0H
  00476	c6 44 24 44 01	 mov	 BYTE PTR __$EHRec$[esp+80], 1
  0047b	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0047e	83 ca ff	 or	 edx, -1
  00481	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00485	4a		 dec	 edx
  00486	85 d2		 test	 edx, edx
  00488	5d		 pop	 ebp
  00489	5b		 pop	 ebx
  0048a	7f 08		 jg	 SHORT $L320172
  0048c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00490	50		 push	 eax
  00491	ff 52 04	 call	 DWORD PTR [edx+4]
$L320172:
  00494	8b 44 24 18	 mov	 eax, DWORD PTR _strMsgDefender$[esp+64]
  00498	83 c0 f0	 add	 eax, -16		; fffffff0H
  0049b	c6 44 24 3c 00	 mov	 BYTE PTR __$EHRec$[esp+72], 0
  004a0	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  004a3	83 ca ff	 or	 edx, -1
  004a6	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  004aa	4a		 dec	 edx
  004ab	85 d2		 test	 edx, edx
  004ad	7f 08		 jg	 SHORT $L320199
  004af	8b 08		 mov	 ecx, DWORD PTR [eax]
  004b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  004b3	50		 push	 eax
  004b4	ff 52 04	 call	 DWORD PTR [edx+4]
$L320199:
  004b7	8b 44 24 1c	 mov	 eax, DWORD PTR _strMsgMaster$[esp+64]
  004bb	83 c0 f0	 add	 eax, -16		; fffffff0H
  004be	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+72], -1
  004c6	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  004c9	83 ca ff	 or	 edx, -1
  004cc	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  004d0	4a		 dec	 edx
  004d1	85 d2		 test	 edx, edx
  004d3	7f 08		 jg	 SHORT $L320226
  004d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  004d9	50		 push	 eax
  004da	ff 52 04	 call	 DWORD PTR [edx+4]
$L320226:
  004dd	8b 4c 24 34	 mov	 ecx, DWORD PTR __$EHRec$[esp+64]
  004e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  004e8	83 c4 40	 add	 esp, 64			; 00000040H
  004eb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L319088:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _strMsgMaster$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L319089:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR _strMsgDefender$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L319090:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR _strMsgGeneral$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?SetMaintenance@CGuildCombat@@QAEXXZ:
  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T320230
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetMaintenance@CGuildCombat@@QAEXXZ ENDP		; CGuildCombat::SetMaintenance
PUBLIC	?ProcessCommand@CGuildCombat@@QAEXXZ		; CGuildCombat::ProcessCommand
EXTRN	?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z:NEAR ; CUserMng::AddGuildCombatNextTimeWorld
EXTRN	?AddGuildCombatState@CUserMng@@QAEXXZ:NEAR	; CUserMng::AddGuildCombatState
EXTRN	?AddWorldMsg@CUserMng@@QAEXKPBD@Z:NEAR		; CUserMng::AddWorldMsg
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T320283 DD	0ffffffffH
	DD	FLAT:$L320261
	DD	0ffffffffH
	DD	FLAT:$L320262
	DD	0ffffffffH
	DD	FLAT:$L320263
$T320277 DD	019930520H
	DD	03H
	DD	FLAT:$T320283
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\eveschool.cpp
xdata$x	ENDS
;	COMDAT ?ProcessCommand@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_str$269854 = -16					; size = 4
_str$269852 = -16					; size = 4
_str$269848 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ProcessCommand@CGuildCombat@@QAEXXZ PROC NEAR		; CGuildCombat::ProcessCommand, COMDAT
; _this$ = ecx

; 2857 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?ProcessCommand@CGuildCombat@@QAEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	55		 push	 ebp
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx

; 2858 : 	if( m_nStopWar == 1 )

  0001a	8b 86 8c 10 00
	00		 mov	 eax, DWORD PTR [esi+4236]
  00020	57		 push	 edi
  00021	bf 01 00 00 00	 mov	 edi, 1
  00026	3b c7		 cmp	 eax, edi
  00028	75 1c		 jne	 SHORT $L269824

; 2859 : 	{
; 2860 : 		m_nProcessGo = m_nProcessCount[COMPLET_CLOSE_STATE];

  0002a	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  00030	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax

; 2861 : 		m_dwTime = 0;

  00036	33 c0		 xor	 eax, eax
  00038	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax

; 2862 : 		m_nStopWar = 0;

  0003e	89 86 8c 10 00
	00		 mov	 DWORD PTR [esi+4236], eax

; 2863 : 	}
; 2864 : 	else if( m_nStopWar == 2 )

  00044	eb 25		 jmp	 SHORT $L320278
$L269824:
  00046	83 f8 02	 cmp	 eax, 2
  00049	75 20		 jne	 SHORT $L320278

; 2865 : 	{
; 2866 : 		m_nProcessGo = m_nProcessCount[GM_COLSE_STATE];

  0004b	8b 8e 98 00 00
	00		 mov	 ecx, DWORD PTR [esi+152]
  00051	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx

; 2867 : 		m_dwTime = 0;

  00057	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0

; 2868 : 		m_nStopWar = 200;

  00061	c7 86 8c 10 00
	00 c8 00 00 00	 mov	 DWORD PTR [esi+4236], 200 ; 000000c8H
$L320278:

; 2869 : 	}
; 2870 : 	if( m_dwTime <= GetTickCount() )

  0006b	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__GetTickCount@0
  00071	ff d5		 call	 ebp
  00073	39 86 80 00 00
	00		 cmp	 DWORD PTR [esi+128], eax
  00079	0f 87 b1 02 00
	00		 ja	 $L269827

; 2871 : 	{
; 2872 : 		if( GuildCombatProcess[m_nProcessGo].nState == WARSTATE )

  0007f	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  00085	c1 e2 04	 shl	 edx, 4
  00088	8b 8c 32 ec 00
	00 00		 mov	 ecx, DWORD PTR [edx+esi+236]
  0008f	81 f9 ed 03 00
	00		 cmp	 ecx, 1005		; 000003edH
  00095	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00098	0f 85 90 00 00
	00		 jne	 $L320279

; 2873 : 		{
; 2874 : 			if( GuildCombatProcess[m_nProcessGo].dwCommand == NOTENTER_COUNT_STATE )

  0009e	8b 80 f4 00 00
	00		 mov	 eax, DWORD PTR [eax+244]
  000a4	83 f8 65	 cmp	 eax, 101		; 00000065H
  000a7	75 1e		 jne	 SHORT $L269829

; 2875 : #ifdef __LAYER_1015
; 2876 : 				g_UserMng.ReplaceWorld( WI_WORLD_GUILDWAR, WI_WORLD_MADRIGAL, 6968.0f, 3328.8f, nDefaultLayer );

  000a9	6a 00		 push	 0
  000ab	68 cd 0c 50 45	 push	 1162874061		; 45500ccdH
  000b0	68 00 c0 d9 45	 push	 1171898368		; 45d9c000H
  000b5	57		 push	 edi
  000b6	68 ca 00 00 00	 push	 202			; 000000caH
  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000c0	e8 00 00 00 00	 call	 ?ReplaceWorld@CUserMng@@QAEXKKMMH@Z ; CUserMng::ReplaceWorld

; 2877 : #else	// __LAYER_1015
; 2878 : 				g_UserMng.ReplaceWorld( WI_WORLD_GUILDWAR, WI_WORLD_MADRIGAL, 6968.0f, 3328.8f );
; 2879 : #endif	// __LAYER_1015
; 2880 : 			else if( GuildCombatProcess[m_nProcessGo].dwCommand == MAINTENANCE_STATE )

  000c5	eb 67		 jmp	 SHORT $L320279
$L269829:
  000c7	83 f8 67	 cmp	 eax, 103		; 00000067H
  000ca	75 09		 jne	 SHORT $L269831

; 2881 : 			{
; 2882 : 				//   
; 2883 : 				SetMaintenance();

  000cc	8b ce		 mov	 ecx, esi
  000ce	e8 00 00 00 00	 call	 ?SetMaintenance@CGuildCombat@@QAEXXZ ; CGuildCombat::SetMaintenance

; 2884 : 			}
; 2885 : 			else if( GuildCombatProcess[m_nProcessGo].dwCommand == ENTER_STATE )

  000d3	eb 59		 jmp	 SHORT $L320279
$L269831:
  000d5	83 f8 66	 cmp	 eax, 102		; 00000066H
  000d8	75 09		 jne	 SHORT $L269833

; 2886 : 			{
; 2887 : 				//   
; 2888 : 				SetEnter();

  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 ?SetEnter@CGuildCombat@@QAEXXZ ; CGuildCombat::SetEnter

; 2889 : 			}
; 2890 : 			else if( GuildCombatProcess[m_nProcessGo].dwCommand == WAR_WAR_STATE )

  000e1	eb 4b		 jmp	 SHORT $L320279
$L269833:
  000e3	83 f8 68	 cmp	 eax, 104		; 00000068H
  000e6	75 09		 jne	 SHORT $L269835

; 2891 : 			{
; 2892 : 				//   
; 2893 : 				SetGuildCombatStart();

  000e8	8b ce		 mov	 ecx, esi
  000ea	e8 00 00 00 00	 call	 ?SetGuildCombatStart@CGuildCombat@@QAEXXZ ; CGuildCombat::SetGuildCombatStart

; 2894 : 			}
; 2895 : 			else if( GuildCombatProcess[m_nProcessGo].dwCommand == WAR_CLOSE_STATE )

  000ef	eb 3d		 jmp	 SHORT $L320279
$L269835:
  000f1	83 f8 69	 cmp	 eax, 105		; 00000069H
  000f4	75 0b		 jne	 SHORT $L269837

; 2896 : 			{
; 2897 : 				//  
; 2898 : 				SetGuildCombatClose();

  000f6	6a 00		 push	 0
  000f8	8b ce		 mov	 ecx, esi
  000fa	e8 00 00 00 00	 call	 ?SetGuildCombatClose@CGuildCombat@@QAEXH@Z ; CGuildCombat::SetGuildCombatClose

; 2899 : 			}
; 2900 : 			else if( GuildCombatProcess[m_nProcessGo].dwCommand == WAR_CLOSE_WAIT_STATE )

  000ff	eb 2d		 jmp	 SHORT $L320279
$L269837:
  00101	83 f8 6a	 cmp	 eax, 106		; 0000006aH
  00104	75 1c		 jne	 SHORT $L269839

; 2901 : 			{
; 2902 : 				//     
; 2903 : 				SetGuildCombatCloseWait();

  00106	39 be 40 11 00
	00		 cmp	 DWORD PTR [esi+4416], edi
  0010c	74 20		 je	 SHORT $L320279
  0010e	6a 00		 push	 0
  00110	6a 00		 push	 0
  00112	8b ce		 mov	 ecx, esi
  00114	e8 00 00 00 00	 call	 ?GuildCombatResult@CGuildCombat@@QAEXHK@Z ; CGuildCombat::GuildCombatResult
  00119	8b ce		 mov	 ecx, esi
  0011b	e8 00 00 00 00	 call	 ?GuildCombatResultRanking@CGuildCombat@@QAEXXZ ; CGuildCombat::GuildCombatResultRanking

; 2904 : 			}
; 2905 : 			else if( GuildCombatProcess[m_nProcessGo].dwCommand == WAR_TELEPORT_STATE )

  00120	eb 0c		 jmp	 SHORT $L320279
$L269839:
  00122	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  00125	75 07		 jne	 SHORT $L320279

; 2906 : 			{
; 2907 : 				//   
; 2908 : 				GuildCombatCloseTeleport();

  00127	8b ce		 mov	 ecx, esi
  00129	e8 00 00 00 00	 call	 ?GuildCombatCloseTeleport@CGuildCombat@@QAEXXZ ; CGuildCombat::GuildCombatCloseTeleport
$L320279:

; 2909 : 			}
; 2910 : 		}
; 2911 : 
; 2912 : 		switch( GuildCombatProcess[m_nProcessGo].nState )

  0012e	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00134	c1 e0 04	 shl	 eax, 4
  00137	8b 8c 30 ec 00
	00 00		 mov	 ecx, DWORD PTR [eax+esi+236]
  0013e	03 c6		 add	 eax, esi
  00140	81 c1 18 fc ff
	ff		 add	 ecx, -1000		; fffffc18H
  00146	83 f9 05	 cmp	 ecx, 5
  00149	0f 87 a4 01 00
	00		 ja	 $L269843
  0014f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L320282[ecx*4]
$L269846:

; 2913 : 		{
; 2914 : 		case ALLMSG:
; 2915 : 			{
; 2916 : #if __VER >= 11 // __GUILD_COMBAT_1TO1
; 2917 : 				if( GuildCombatProcess[m_nProcessGo].dwCommand != TID_GAME_GUILDCOMBAT_OPEN_MSG )

  00156	8b 88 f4 00 00
	00		 mov	 ecx, DWORD PTR [eax+244]
  0015c	bf 96 0a 00 00	 mov	 edi, 2710		; 00000a96H
  00161	3b cf		 cmp	 ecx, edi
  00163	74 6c		 je	 SHORT $L269847

; 2918 : #endif // __GUILD_COMBAT_1TO1
; 2919 : 				{
; 2920 : 					CString str;

  00165	8d 4c 24 0c	 lea	 ecx, DWORD PTR _str$269848[esp+28]
  00169	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 2921 : 					str.Format( prj.GetText( GuildCombatProcess[m_nProcessGo].dwCommand ), GuildCombatProcess[m_nProcessGo].dwTime / 1000 );

  0016e	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00174	8d 51 0f	 lea	 edx, DWORD PTR [ecx+15]
  00177	c1 e2 04	 shl	 edx, 4
  0017a	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0017f	f7 24 32	 mul	 DWORD PTR [edx+esi]
  00182	c1 e1 04	 shl	 ecx, 4
  00185	8b 84 31 f4 00
	00 00		 mov	 eax, DWORD PTR [ecx+esi+244]
  0018c	c1 ea 06	 shr	 edx, 6
  0018f	52		 push	 edx
  00190	50		 push	 eax
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00196	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 0
  0019e	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  001a3	50		 push	 eax
  001a4	8d 4c 24 14	 lea	 ecx, DWORD PTR _str$269848[esp+36]
  001a8	51		 push	 ecx
  001a9	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 2922 : 					g_DPCoreClient.SendSystem( str );

  001ae	8b 54 24 18	 mov	 edx, DWORD PTR _str$269848[esp+40]
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b5	52		 push	 edx
  001b6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  001bb	e8 00 00 00 00	 call	 ?SendSystem@CDPCoreClient@@QAEXPBD@Z ; CDPCoreClient::SendSystem

; 2923 : 				}

  001c0	8d 4c 24 0c	 lea	 ecx, DWORD PTR _str$269848[esp+28]
  001c4	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  001cc	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L269847:

; 2924 : 
; 2925 : 				if( GuildCombatProcess[m_nProcessGo].dwCommand == TID_GAME_GUILDCOMBAT_OPEN_MSG )

  001d1	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  001d7	c1 e0 04	 shl	 eax, 4
  001da	39 bc 30 f4 00
	00 00		 cmp	 DWORD PTR [eax+esi+244], edi
  001e1	0f 85 0c 01 00
	00		 jne	 $L269843

; 2926 : 					SendGuildCombatEnterTime( );

  001e7	8b ce		 mov	 ecx, esi
  001e9	e8 00 00 00 00	 call	 ?SendGuildCombatEnterTime@CGuildCombat@@QAEXXZ ; CGuildCombat::SendGuildCombatEnterTime

; 2927 : 			}
; 2928 : 			break;

  001ee	e9 00 01 00 00	 jmp	 $L269843
$L269851:

; 2929 : 		case GUILDMSG:
; 2930 : 			{
; 2931 : 			}
; 2932 : 			break;
; 2933 : 		case JOINMSG:
; 2934 : 			{
; 2935 : 				CString str;

  001f3	8d 4c 24 0c	 lea	 ecx, DWORD PTR _str$269852[esp+28]
  001f7	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 2936 : 				str.Format( prj.GetText( GuildCombatProcess[m_nProcessGo].dwCommand ), GuildCombatProcess[m_nProcessGo].dwTime / 1000 );

  001fc	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00202	8d 51 0f	 lea	 edx, DWORD PTR [ecx+15]
  00205	c1 e2 04	 shl	 edx, 4
  00208	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0020d	f7 24 32	 mul	 DWORD PTR [edx+esi]
  00210	c1 e1 04	 shl	 ecx, 4
  00213	8b 84 31 f4 00
	00 00		 mov	 eax, DWORD PTR [ecx+esi+244]
  0021a	c1 ea 06	 shr	 edx, 6
  0021d	52		 push	 edx
  0021e	50		 push	 eax
  0021f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00224	89 7c 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], edi
  00228	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0022d	50		 push	 eax
  0022e	8d 4c 24 14	 lea	 ecx, DWORD PTR _str$269852[esp+36]
  00232	51		 push	 ecx
  00233	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format
  00238	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2937 : //				SendJoinMsg( str );
; 2938 : 			}
; 2939 : 			break;

  0023b	eb 60		 jmp	 SHORT $L320281
$L269853:

; 2940 : 		case WORLDMSG:
; 2941 : 			{
; 2942 : 				CString str;

  0023d	8d 4c 24 0c	 lea	 ecx, DWORD PTR _str$269854[esp+28]
  00241	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 2943 : 				str.Format( prj.GetText( GuildCombatProcess[m_nProcessGo].dwCommand ), GuildCombatProcess[m_nProcessGo].dwTime / 1000 );

  00246	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  0024c	8d 51 0f	 lea	 edx, DWORD PTR [ecx+15]
  0024f	c1 e2 04	 shl	 edx, 4
  00252	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00257	f7 24 32	 mul	 DWORD PTR [edx+esi]
  0025a	c1 e1 04	 shl	 ecx, 4
  0025d	8b 84 31 f4 00
	00 00		 mov	 eax, DWORD PTR [ecx+esi+244]
  00264	c1 ea 06	 shr	 edx, 6
  00267	52		 push	 edx
  00268	50		 push	 eax
  00269	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0026e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 2
  00276	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0027b	50		 push	 eax
  0027c	8d 4c 24 14	 lea	 ecx, DWORD PTR _str$269854[esp+36]
  00280	51		 push	 ecx
  00281	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 2944 : 				g_UserMng.AddWorldMsg( WI_WORLD_GUILDWAR, str );

  00286	8b 54 24 18	 mov	 edx, DWORD PTR _str$269854[esp+40]
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028d	52		 push	 edx
  0028e	68 ca 00 00 00	 push	 202			; 000000caH
  00293	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00298	e8 00 00 00 00	 call	 ?AddWorldMsg@CUserMng@@QAEXKPBD@Z ; CUserMng::AddWorldMsg
$L320281:

; 2945 : 			}

  0029d	8d 4c 24 0c	 lea	 ecx, DWORD PTR _str$269854[esp+28]
  002a1	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  002a9	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 2946 : 			break;

  002ae	eb 43		 jmp	 SHORT $L269843
$L269855:

; 2947 : 		case STATE:
; 2948 : 			{
; 2949 : 				if( g_eLocal.GetState( EVE_GUILDCOMBAT ) )

  002b0	6a 0f		 push	 15			; 0000000fH
  002b2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  002b7	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  002bc	84 c0		 test	 al, al
  002be	74 33		 je	 SHORT $L269843

; 2950 : 					g_DPCoreClient.SendGuildCombatState( GuildCombatProcess[m_nProcessGo].dwCommand );

  002c0	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  002c6	c1 e0 04	 shl	 eax, 4
  002c9	8b 8c 30 f4 00
	00 00		 mov	 ecx, DWORD PTR [eax+esi+244]
  002d0	51		 push	 ecx
  002d1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  002d6	e8 00 00 00 00	 call	 ?SendGuildCombatState@CDPCoreClient@@QAEXH@Z ; CDPCoreClient::SendGuildCombatState

; 2951 : //				m_nState = GuildCombatProcess[m_nProcessGo].dwCommand;
; 2952 : 			}
; 2953 : 			break;

  002db	eb 16		 jmp	 SHORT $L269843
$L269857:

; 2954 : 		case WARSTATE:
; 2955 : 			{
; 2956 : 				m_nGCState = GuildCombatProcess[m_nProcessGo].dwCommand;

  002dd	8b 90 f4 00 00
	00		 mov	 edx, DWORD PTR [eax+244]

; 2957 : 				g_UserMng.AddGuildCombatState();

  002e3	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  002e8	89 96 44 11 00
	00		 mov	 DWORD PTR [esi+4420], edx
  002ee	e8 00 00 00 00	 call	 ?AddGuildCombatState@CUserMng@@QAEXXZ ; CUserMng::AddGuildCombatState
$L269843:

; 2958 : 			}
; 2959 : 			break;
; 2960 : 		}
; 2961 : 		m_dwTime = GetTickCount() + GuildCombatProcess[m_nProcessGo].dwTime;

  002f3	8b be 84 00 00
	00		 mov	 edi, DWORD PTR [esi+132]
  002f9	8d 47 0f	 lea	 eax, DWORD PTR [edi+15]
  002fc	c1 e0 04	 shl	 eax, 4
  002ff	53		 push	 ebx
  00300	8d 1c 30	 lea	 ebx, DWORD PTR [eax+esi]
  00303	ff d5		 call	 ebp
  00305	03 03		 add	 eax, DWORD PTR [ebx]

; 2962 : 		if( GuildCombatProcess[m_nProcessGo].dwParam != 0 )

  00307	c1 e7 04	 shl	 edi, 4
  0030a	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  00310	8b bc 37 f8 00
	00 00		 mov	 edi, DWORD PTR [edi+esi+248]
  00317	85 ff		 test	 edi, edi
  00319	74 0e		 je	 SHORT $L269858

; 2963 : 			g_UserMng.AddGuildCombatNextTimeWorld( GuildCombatProcess[m_nProcessGo].dwTime, GuildCombatProcess[m_nProcessGo].dwParam );

  0031b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0031d	57		 push	 edi
  0031e	51		 push	 ecx
  0031f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00324	e8 00 00 00 00	 call	 ?AddGuildCombatNextTimeWorld@CUserMng@@QAEXKK@Z ; CUserMng::AddGuildCombatNextTimeWorld
$L269858:

; 2964 : 		++m_nProcessGo;

  00329	ff 86 84 00 00
	00		 inc	 DWORD PTR [esi+132]
  0032f	5b		 pop	 ebx
$L269827:

; 2965 : 	}
; 2966 : }

  00330	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  00334	5f		 pop	 edi
  00335	5e		 pop	 esi
  00336	5d		 pop	 ebp
  00337	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0033e	83 c4 10	 add	 esp, 16			; 00000010H
  00341	c3		 ret	 0
  00342	8b ff		 npad	 2
$L320282:
  00344	00 00 00 00	 DD	 $L269846
  00348	00 00 00 00	 DD	 $L269843
  0034c	00 00 00 00	 DD	 $L269851
  00350	00 00 00 00	 DD	 $L269853
  00354	00 00 00 00	 DD	 $L269855
  00358	00 00 00 00	 DD	 $L269857
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L320261:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _str$269848[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L320262:
  00008	8d 4d f0	 lea	 ecx, DWORD PTR _str$269852[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L320263:
  00010	8d 4d f0	 lea	 ecx, DWORD PTR _str$269854[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?ProcessCommand@CGuildCombat@@QAEXXZ:
  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T320277
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ProcessCommand@CGuildCombat@@QAEXXZ ENDP		; CGuildCombat::ProcessCommand
PUBLIC	?Process@CGuildCombat@@QAEXXZ			; CGuildCombat::Process
EXTRN	?Set@CTimer@@QAEXMH@Z:NEAR			; CTimer::Set
; Function compile flags: /Ogty
;	COMDAT ?Process@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT
_ctime$269789 = -8					; size = 8
?Process@CGuildCombat@@QAEXXZ PROC NEAR			; CGuildCombat::Process, COMDAT
; _this$ = ecx

; 2752 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2753 : #ifdef __WORLDSERVER
; 2754 : #ifdef _DEBUG	
; 2755 : //	TRACE( "GuildWarFlyff::Process <%d>, <%d>\n", m_nState, m_nGuildCombatState);
; 2756 : #endif //_DEBUG
; 2757 : 	if( m_nState != CLOSE_STATE )

  00006	83 be 40 11 00
	00 01		 cmp	 DWORD PTR [esi+4416], 1
  0000d	74 21		 je	 SHORT $L269786

; 2758 : 	{
; 2759 : 		if( m_nProcessGo < m_nProcessCount[0] )

  0000f	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00015	3b 86 88 00 00
	00		 cmp	 eax, DWORD PTR [esi+136]
  0001b	7d 07		 jge	 SHORT $L269787

; 2760 : 			ProcessCommand();

  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?ProcessCommand@CGuildCombat@@QAEXXZ ; CGuildCombat::ProcessCommand
$L269787:

; 2761 : 		ProcessJoinWar();	//

  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?ProcessJoinWar@CGuildCombat@@QAEXXZ ; CGuildCombat::ProcessJoinWar
  0002b	5e		 pop	 esi

; 2796 : 			}
; 2797 : 		}
; 2798 : 	}
; 2799 : #endif //__WORLDSERVER
; 2800 : }

  0002c	83 c4 08	 add	 esp, 8
  0002f	c3		 ret	 0
$L269786:

; 2762 : 	}
; 2763 : 	else
; 2764 : 	{
; 2765 : 		CTime ctime = CTime::GetCurrentTime();

  00030	6a 00		 push	 0
  00032	e8 00 00 00 00	 call	 __time64

; 2766 : 
; 2767 : 		if( __AutoOpen[ctime.GetDayOfWeek()-1].bUseing )

  00037	8d 4c 24 08	 lea	 ecx, DWORD PTR _ctime$269789[esp+16]
  0003b	51		 push	 ecx
  0003c	89 44 24 0c	 mov	 DWORD PTR _ctime$269789[esp+20], eax
  00040	89 54 24 10	 mov	 DWORD PTR _ctime$269789[esp+24], edx
  00044	e8 00 00 00 00	 call	 __localtime64
  00049	83 c4 08	 add	 esp, 8
  0004c	85 c0		 test	 eax, eax
  0004e	74 06		 je	 SHORT $L320312
  00050	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00053	40		 inc	 eax
  00054	eb 02		 jmp	 SHORT $L320313
$L320312:
  00056	33 c0		 xor	 eax, eax
$L320313:
  00058	83 3c c6 00	 cmp	 DWORD PTR [esi+eax*8], 0
  0005c	0f 84 2a 01 00
	00		 je	 $L269797

; 2768 : 		{
; 2769 : 			//       
; 2770 : 			if( __AutoOpen[ctime.GetDayOfWeek()-1].nHour == ctime.GetHour() &&
; 2771 : 				__AutoOpen[ctime.GetDayOfWeek()-1].nMinute == ctime.GetMinute() && m_bMutex == FALSE )

  00062	8d 54 24 04	 lea	 edx, DWORD PTR _ctime$269789[esp+12]
  00066	57		 push	 edi
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 __localtime64
  0006d	83 c4 04	 add	 esp, 4
  00070	85 c0		 test	 eax, eax
  00072	74 06		 je	 SHORT $L320334
  00074	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  00077	47		 inc	 edi
  00078	eb 02		 jmp	 SHORT $L320335
$L320334:
  0007a	33 ff		 xor	 edi, edi
$L320335:
  0007c	8d 44 24 08	 lea	 eax, DWORD PTR _ctime$269789[esp+16]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 __localtime64
  00086	83 c4 04	 add	 esp, 4
  00089	85 c0		 test	 eax, eax
  0008b	74 05		 je	 SHORT $L320356
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	eb 03		 jmp	 SHORT $L320357
$L320356:
  00092	83 c8 ff	 or	 eax, -1
$L320357:
  00095	0f b6 4c fe 04	 movzx	 ecx, BYTE PTR [esi+edi*8+4]
  0009a	3b c8		 cmp	 ecx, eax
  0009c	0f 85 b8 00 00
	00		 jne	 $L269792
  000a2	8d 54 24 08	 lea	 edx, DWORD PTR _ctime$269789[esp+16]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 __localtime64
  000ac	83 c4 04	 add	 esp, 4
  000af	85 c0		 test	 eax, eax
  000b1	74 06		 je	 SHORT $L320378
  000b3	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  000b6	47		 inc	 edi
  000b7	eb 02		 jmp	 SHORT $L320379
$L320378:
  000b9	33 ff		 xor	 edi, edi
$L320379:
  000bb	8d 44 24 08	 lea	 eax, DWORD PTR _ctime$269789[esp+16]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 __localtime64
  000c5	83 c4 04	 add	 esp, 4
  000c8	85 c0		 test	 eax, eax
  000ca	74 05		 je	 SHORT $L320400
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	eb 03		 jmp	 SHORT $L320401
$L320400:
  000d1	83 c8 ff	 or	 eax, -1
$L320401:
  000d4	0f b6 4c fe 05	 movzx	 ecx, BYTE PTR [esi+edi*8+5]
  000d9	3b c8		 cmp	 ecx, eax
  000db	75 7d		 jne	 SHORT $L269792
  000dd	8b 86 c8 10 00
	00		 mov	 eax, DWORD PTR [esi+4296]
  000e3	85 c0		 test	 eax, eax
  000e5	75 73		 jne	 SHORT $L269792

; 2772 : 			{
; 2773 : #ifdef __S_BUG_GC
; 2774 : 				if( (int)( m_vecGuildCombatMem.size() ) >= m_nMinGuild )

  000e7	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  000ea	e8 00 00 00 00	 call	 ?size@?$vector@PAU__GuildCombatMember@CGuildCombat@@V?$allocator@PAU__GuildCombatMember@CGuildCombat@@@std@@@std@@QBEIXZ ; std::vector<CGuildCombat::__GuildCombatMember *,std::allocator<CGuildCombat::__GuildCombatMember *> >::size
  000ef	3b 86 98 10 00
	00		 cmp	 eax, DWORD PTR [esi+4248]
  000f5	7c 09		 jl	 SHORT $L269794

; 2775 : #else // __S_BUG_GC
; 2776 : 				if( m_GuildCombatMem.size() > 1 )
; 2777 : #endif // __S_BUG_GC
; 2778 : 				{				
; 2779 : 					GuildCombatOpen();

  000f7	8b ce		 mov	 ecx, esi
  000f9	e8 00 00 00 00	 call	 ?GuildCombatOpen@CGuildCombat@@QAEXXZ ; CGuildCombat::GuildCombatOpen

; 2780 : 				}
; 2781 : 				else

  000fe	eb 50		 jmp	 SHORT $L269795
$L269794:

; 2782 : 				{
; 2783 : 					m_ctrMutexOut.Set( SEC(60) );

  00100	6a 00		 push	 0
  00102	68 00 60 6a 47	 push	 1198153728		; 476a6000H
  00107	8d 8e d0 10 00
	00		 lea	 ecx, DWORD PTR [esi+4304]
  0010d	e8 00 00 00 00	 call	 ?Set@CTimer@@QAEXMH@Z	; CTimer::Set

; 2784 : 					m_bMutexMsg = TRUE;
; 2785 : 					g_DPCoreClient.SendSystem( prj.GetText( TID_GAME_GUILDCOMBAT_NEXT_COMBAT ) );	

  00112	68 a8 0a 00 00	 push	 2728			; 00000aa8H
  00117	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0011c	c7 86 cc 10 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4300], 1
  00126	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0012b	50		 push	 eax
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  00131	e8 00 00 00 00	 call	 ?SendSystem@CDPCoreClient@@QAEXPBD@Z ; CDPCoreClient::SendSystem

; 2786 : 					g_DPCoreClient.SendSystem( prj.GetText( TID_GAME_GUILDCOMBAT_ENJOY ) );	

  00136	68 a9 0a 00 00	 push	 2729			; 00000aa9H
  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00140	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  00145	50		 push	 eax
  00146	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  0014b	e8 00 00 00 00	 call	 ?SendSystem@CDPCoreClient@@QAEXPBD@Z ; CDPCoreClient::SendSystem
$L269795:

; 2787 : 				}
; 2788 : 
; 2789 : 				m_bMutex = TRUE;				

  00150	c7 86 c8 10 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4296], 1
$L269792:

; 2790 : 			}
; 2791 : 
; 2792 : 			if( m_bMutexMsg && m_ctrMutexOut.IsTimeOut() )

  0015a	8b 86 cc 10 00
	00		 mov	 eax, DWORD PTR [esi+4300]
  00160	85 c0		 test	 eax, eax
  00162	5f		 pop	 edi
  00163	74 27		 je	 SHORT $L269797
  00165	8b 96 d0 10 00
	00		 mov	 edx, DWORD PTR [esi+4304]
  0016b	8d 8e d0 10 00
	00		 lea	 ecx, DWORD PTR [esi+4304]
  00171	ff 52 08	 call	 DWORD PTR [edx+8]
  00174	85 c0		 test	 eax, eax
  00176	74 14		 je	 SHORT $L269797

; 2793 : 			{
; 2794 : 				m_bMutexMsg = FALSE;

  00178	c7 86 cc 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4300], 0

; 2795 : 				m_bMutex    = FALSE;

  00182	c7 86 c8 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4296], 0
$L269797:
  0018c	5e		 pop	 esi

; 2796 : 			}
; 2797 : 		}
; 2798 : 	}
; 2799 : #endif //__WORLDSERVER
; 2800 : }

  0018d	83 c4 08	 add	 esp, 8
  00190	c3		 ret	 0
?Process@CGuildCombat@@QAEXXZ ENDP			; CGuildCombat::Process
_TEXT	ENDS
CRT$XCU	SEGMENT
_$S5	DD	FLAT:_$E3
; Function compile flags: /Ogty
CRT$XCU	ENDS
;	COMDAT _$E3
text$yc	SEGMENT
_$E3	PROC NEAR					; COMDAT

; 3673 : CGuildCombat	g_GuildCombatMng;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombatMng@@3VCGuildCombat@@A
  00005	e8 00 00 00 00	 call	 ??0CGuildCombat@@QAE@XZ	; CGuildCombat::CGuildCombat
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:_$E4
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
_$E3	ENDP
; Function compile flags: /Ogty
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
  00000	c3		 ret	 0
_$E2	ENDP
; Function compile flags: /Ogty
text$yd	ENDS
;	COMDAT _$E4
text$yd	SEGMENT
_$E4	PROC NEAR					; COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombatMng@@3VCGuildCombat@@A
  00005	e9 00 00 00 00	 jmp	 ??1CGuildCombat@@UAE@XZ	; CGuildCombat::~CGuildCombat
_$E4	ENDP
text$yd	ENDS
PUBLIC	?g_GuildCombatMng@@3VCGuildCombat@@A		; g_GuildCombatMng
_BSS	SEGMENT
?g_GuildCombatMng@@3VCGuildCombat@@A DB 01150H DUP (?)	; g_GuildCombatMng
_BSS	ENDS
END
