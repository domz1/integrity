; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\vutil.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@NBIPLAAF@?3?3LoadTextureFromRes?5?3?5?$CFs?5not?5fo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@EOOHBDEA@D3DXCreateTextureFromFileInMemor@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@EONEHPLE@?6Surface?5?$CFd?5?$CFd?0?5Pt?5?$CFd?5?$CFd?5IMG_BIT@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GC@NMPFDOHB@D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_24?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@FIMJOGAK@?5D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_32@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@JOHHHILL@?5D3DFMT_A8R8G8B8?5ERROR?5IMGBIT_24@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JCAPCJAP@?4tga?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LJDDIHIK@?4bmp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHDFBJEH@LoadBMP?5Failed?5?$DN?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?GetCharLen@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrCut@@YAHPBDPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStrLen@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChar@@YAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMultiByte@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNative@@YAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsHangul@@YAHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStrNull@@YAXPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDPAPAUIDirect3DTexture9@@KW4_D3DFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustSize@@YAXPAUtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadImageA@@YAHPBDPAUIMAGE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTGA@@YAHPBDPAUIMAGE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadBMP@@YAHPBDPAUIMAGE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveBMP@@YAHPBDPAEUtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPickRay@@YAXVCRect@@UtagPOINT@@PAUD3DXMATRIX@@2PAUD3DXVECTOR3@@3@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRayEnd@@YAXPAUD3DXVECTOR3@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IntersectTriangle@@YAHAAUD3DXVECTOR3@@00ABU1@1PAU1@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?abs@@YAJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?szstrError@?1??PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z@4PADA
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?Read@CFileIO@@UAEIPAXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@CFileIO@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Handle@CFileIO@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFileIO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFileIO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCFileIO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Flush@CFileIO@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetC@CFileIO@@UAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetW@CFileIO@@UAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDW@CFileIO@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Tell@CFileIO@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CFileIO@@UAEHJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileIO@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isdigit2@@YAHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_szCrashClient@@3PADA				; g_szCrashClient
_BSS	SEGMENT
?g_szCrashClient@@3PADA DB 0400H DUP (?)		; g_szCrashClient
_BSS	ENDS
PUBLIC	?GetCharLen@@YAHPBD@Z				; GetCharLen
EXTRN	__imp__CharNextA@4:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
;	COMDAT ?GetCharLen@@YAHPBD@Z
_TEXT	SEGMENT
_pStr$ = 8						; size = 4
?GetCharLen@@YAHPBD@Z PROC NEAR				; GetCharLen, COMDAT

; 13   : {

  00000	56		 push	 esi

; 14   : 	char* pNext = CharNext( pStr );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pStr$[esp]
  00005	56		 push	 esi
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4

; 15   : 	return (int) (pNext - pStr );

  0000c	2b c6		 sub	 eax, esi
  0000e	5e		 pop	 esi

; 16   : }

  0000f	c3		 ret	 0
?GetCharLen@@YAHPBD@Z ENDP				; GetCharLen
_TEXT	ENDS
PUBLIC	?GetStrCut@@YAHPBDPADH@Z			; GetStrCut
; Function compile flags: /Ogty
;	COMDAT ?GetStrCut@@YAHPBDPADH@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_pDest$ = 12						; size = 4
_nCount$ = 16						; size = 4
?GetStrCut@@YAHPBDPADH@Z PROC NEAR			; GetStrCut, COMDAT

; 20   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 21   : 	int nOffset = 0;
; 22   : 	int nLen;
; 23   : 	
; 24   : 	while( nCount )

  00002	8b 6c 24 14	 mov	 ebp, DWORD PTR _nCount$[esp+4]
  00006	56		 push	 esi
  00007	8b 74 24 10	 mov	 esi, DWORD PTR _pSrc$[esp+8]
  0000b	33 db		 xor	 ebx, ebx
  0000d	85 ed		 test	 ebp, ebp
  0000f	57		 push	 edi
  00010	74 11		 je	 SHORT $L225609
$L225608:

; 25   : 	{
; 26   : 		nLen = GetCharLen( &pSrc[ nOffset ]  );

  00012	8d 3c 33	 lea	 edi, DWORD PTR [ebx+esi]
  00015	57		 push	 edi
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4

; 27   : 		nOffset += nLen;

  0001c	2b c7		 sub	 eax, edi
  0001e	03 d8		 add	 ebx, eax
  00020	4d		 dec	 ebp
  00021	75 ef		 jne	 SHORT $L225608
$L225609:

; 28   : 		nCount--;
; 29   : 	}
; 30   : 	
; 31   : 	memcpy( pDest, pSrc, sizeof(char)*nOffset);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR _pDest$[esp+12]
  00027	8b cb		 mov	 ecx, ebx
  00029	8b c1		 mov	 eax, ecx
  0002b	c1 e9 02	 shr	 ecx, 2
  0002e	f3 a5		 rep movsd
  00030	8b c8		 mov	 ecx, eax
  00032	83 e1 03	 and	 ecx, 3
  00035	f3 a4		 rep movsb
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp

; 32   : 	
; 33   : 	return 1;

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	5b		 pop	 ebx

; 34   : }	

  00040	c3		 ret	 0
?GetStrCut@@YAHPBDPADH@Z ENDP				; GetStrCut
_TEXT	ENDS
PUBLIC	?GetStrLen@@YAHPBD@Z				; GetStrLen
; Function compile flags: /Ogty
;	COMDAT ?GetStrLen@@YAHPBD@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
?GetStrLen@@YAHPBD@Z PROC NEAR				; GetStrLen, COMDAT

; 38   : {

  00000	53		 push	 ebx

; 39   : 	int nCount = 0;
; 40   : 	int nOffset = 0;
; 41   : 	int nLen;
; 42   : 	
; 43   : 	while( pSrc[ nOffset ] != NULL )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _pSrc$[esp]
  00005	8a 03		 mov	 al, BYTE PTR [ebx]
  00007	55		 push	 ebp
  00008	57		 push	 edi
  00009	33 ed		 xor	 ebp, ebp
  0000b	33 ff		 xor	 edi, edi
  0000d	84 c0		 test	 al, al
  0000f	74 1a		 je	 SHORT $L227321
  00011	56		 push	 esi
  00012	8b f3		 mov	 esi, ebx
$L225618:

; 44   : 	{
; 45   : 		nLen = GetCharLen( &pSrc[ nOffset ]  );

  00014	56		 push	 esi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextA@4

; 46   : 		nOffset += nLen;

  0001b	2b c6		 sub	 eax, esi
  0001d	03 f8		 add	 edi, eax
  0001f	8a 04 1f	 mov	 al, BYTE PTR [edi+ebx]
  00022	8d 34 1f	 lea	 esi, DWORD PTR [edi+ebx]

; 47   : 		nCount++;

  00025	45		 inc	 ebp
  00026	84 c0		 test	 al, al
  00028	75 ea		 jne	 SHORT $L225618
  0002a	5e		 pop	 esi
$L227321:
  0002b	5f		 pop	 edi

; 48   : 	}
; 49   : 	
; 50   : 	return nCount;

  0002c	8b c5		 mov	 eax, ebp
  0002e	5d		 pop	 ebp
  0002f	5b		 pop	 ebx

; 51   : }	

  00030	c3		 ret	 0
?GetStrLen@@YAHPBD@Z ENDP				; GetStrLen
_TEXT	ENDS
PUBLIC	?CopyChar@@YAHPBDPAD@Z				; CopyChar
EXTRN	?g_codePage@@3GA:WORD				; g_codePage
EXTRN	?CharNextEx@@YAPBDPBDG@Z:NEAR			; CharNextEx
; Function compile flags: /Ogty
;	COMDAT ?CopyChar@@YAHPBDPAD@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_pDest$ = 12						; size = 4
?CopyChar@@YAHPBDPAD@Z PROC NEAR			; CopyChar, COMDAT

; 56   : 	const char* pNext = CharNextEx(pSrc);

  00000	33 c0		 xor	 eax, eax
  00002	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g_codePage@@3GA ; g_codePage
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR _pSrc$[esp]
  0000d	57		 push	 edi
  0000e	50		 push	 eax
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?CharNextEx@@YAPBDPBDG@Z ; CharNextEx

; 57   : 
; 58   : 	memcpy(pDest, pSrc, pNext - pSrc);

  00015	8b 7c 24 18	 mov	 edi, DWORD PTR _pDest$[esp+12]
  00019	2b c6		 sub	 eax, esi
  0001b	8b c8		 mov	 ecx, eax
  0001d	8b d1		 mov	 edx, ecx
  0001f	c1 e9 02	 shr	 ecx, 2
  00022	f3 a5		 rep movsd
  00024	8b ca		 mov	 ecx, edx
  00026	83 c4 08	 add	 esp, 8
  00029	83 e1 03	 and	 ecx, 3
  0002c	f3 a4		 rep movsb
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 59   : 
; 60   : 	return pNext - pSrc;
; 61   : }

  00030	c3		 ret	 0
?CopyChar@@YAHPBDPAD@Z ENDP				; CopyChar
_TEXT	ENDS
PUBLIC	?IsMultiByte@@YAHPBD@Z				; IsMultiByte
; Function compile flags: /Ogty
;	COMDAT ?IsMultiByte@@YAHPBD@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
?IsMultiByte@@YAHPBD@Z PROC NEAR			; IsMultiByte, COMDAT

; 65   : 	return ( CharNextEx(pSrc) - pSrc ) > 1;

  00000	33 c0		 xor	 eax, eax
  00002	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g_codePage@@3GA ; g_codePage
  00008	56		 push	 esi
  00009	8b 74 24 08	 mov	 esi, DWORD PTR _pSrc$[esp]
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ?CharNextEx@@YAPBDPBDG@Z ; CharNextEx
  00014	2b c6		 sub	 eax, esi
  00016	33 c9		 xor	 ecx, ecx
  00018	83 c4 08	 add	 esp, 8
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	0f 9f c1	 setg	 cl
  00021	5e		 pop	 esi
  00022	8b c1		 mov	 eax, ecx

; 66   : }

  00024	c3		 ret	 0
?IsMultiByte@@YAHPBD@Z ENDP				; IsMultiByte
_TEXT	ENDS
PUBLIC	?IsHangul@@YAHG@Z				; IsHangul
; Function compile flags: /Ogty
;	COMDAT ?IsHangul@@YAHG@Z
_TEXT	SEGMENT
_word$ = 8						; size = 2
?IsHangul@@YAHG@Z PROC NEAR				; IsHangul, COMDAT

; 119  : 	BYTE l = word & 0xff;
; 120  : 	BYTE h = word >> 8;

  00000	66 8b 44 24 04	 mov	 ax, WORD PTR _word$[esp-4]

; 121  : 
; 122  : 	//  ,    FALSE
; 123  : 	if( h >= 0xa1 && h <= 0xac && l >= 0xa0 && l <= 0xff )

  00005	80 fc a1	 cmp	 ah, 161			; 000000a1H
  00008	72 0d		 jb	 SHORT $L225668
  0000a	80 fc ac	 cmp	 ah, 172			; 000000acH
  0000d	77 08		 ja	 SHORT $L225668
  0000f	3c a0		 cmp	 al, 160			; 000000a0H
  00011	72 04		 jb	 SHORT $L225668
  00013	3c ff		 cmp	 al, 255			; 000000ffH

; 124  : 		return FALSE;

  00015	76 2a		 jbe	 SHORT $L225670
$L225668:

; 125  : 	//    
; 126  : 	if( h >= 0x81 && h <= 0xc6 && l >= 0x41 && l <= 0xfe )

  00017	80 fc 81	 cmp	 ah, 129			; 00000081H
  0001a	72 0d		 jb	 SHORT $L225669
  0001c	80 fc c6	 cmp	 ah, 198			; 000000c6H
  0001f	77 08		 ja	 SHORT $L225669
  00021	3c 41		 cmp	 al, 65			; 00000041H
  00023	72 04		 jb	 SHORT $L225669
  00025	3c fe		 cmp	 al, 254			; 000000feH

; 127  : 		return TRUE;

  00027	76 12		 jbe	 SHORT $L227331
$L225669:

; 128  : 	//   
; 129  : 	if( h >= 0xb0 && h <= 0xc8 && l >= 0xa1 && l <= 0xfe )

  00029	80 fc b0	 cmp	 ah, 176			; 000000b0H
  0002c	72 13		 jb	 SHORT $L225670
  0002e	80 fc c8	 cmp	 ah, 200			; 000000c8H
  00031	77 0e		 ja	 SHORT $L225670
  00033	3c a1		 cmp	 al, 161			; 000000a1H
  00035	72 0a		 jb	 SHORT $L225670
  00037	3c fe		 cmp	 al, 254			; 000000feH
  00039	77 06		 ja	 SHORT $L225670
$L227331:

; 130  : 		return TRUE;

  0003b	b8 01 00 00 00	 mov	 eax, 1

; 132  : } 

  00040	c3		 ret	 0
$L225670:

; 131  : 	return FALSE;

  00041	33 c0		 xor	 eax, eax

; 132  : } 

  00043	c3		 ret	 0
?IsHangul@@YAHG@Z ENDP					; IsHangul
_TEXT	ENDS
PUBLIC	?SetStrNull@@YAXPADH@Z				; SetStrNull
EXTRN	__imp__IsDBCSLeadByte@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?SetStrNull@@YAXPADH@Z
_TEXT	SEGMENT
_lpStr$ = 8						; size = 4
_nNullLength$ = 12					; size = 4
?SetStrNull@@YAXPADH@Z PROC NEAR			; SetStrNull, COMDAT

; 135  : {

  00000	55		 push	 ebp

; 136  : 	int nLength = strlen( lpStr );

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR _lpStr$[esp]
  00005	8b c5		 mov	 eax, ebp
  00007	56		 push	 esi
  00008	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L227336:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L227336
  00017	57		 push	 edi

; 137  : 	// 0            
; 138  : 	if( nNullLength > nLength )

  00018	8b 7c 24 14	 mov	 edi, DWORD PTR _nNullLength$[esp+8]
  0001c	2b c2		 sub	 eax, edx
  0001e	3b f8		 cmp	 edi, eax
  00020	7e 02		 jle	 SHORT $L225676

; 139  : 		nNullLength = nLength;

  00022	8b f8		 mov	 edi, eax
$L225676:

; 140  : 	for( int i = 0; i < nNullLength; )

  00024	33 f6		 xor	 esi, esi
  00026	85 ff		 test	 edi, edi
  00028	7e 1e		 jle	 SHORT $L225680
  0002a	53		 push	 ebx
  0002b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__IsDBCSLeadByte@4
$L225679:

; 141  : 	{
; 142  : #ifdef __CLIENT
; 143  : 		if( ::GetLanguage() == LANG_THA && g_codePage == 874 ) //  
; 144  : 			i++;
; 145  : 		else if(::GetLanguage() == LANG_VTN && g_codePage == 1258)
; 146  : 			i++;
; 147  : 		else
; 148  : #endif//__CLIENT
; 149  : 		if( IsDBCSLeadByte( lpStr[ i ] ) )

  00031	33 c0		 xor	 eax, eax
  00033	8a 04 2e	 mov	 al, BYTE PTR [esi+ebp]
  00036	50		 push	 eax
  00037	ff d3		 call	 ebx
  00039	85 c0		 test	 eax, eax
  0003b	74 05		 je	 SHORT $L225681

; 150  : 			i+=2;

  0003d	83 c6 02	 add	 esi, 2

; 151  : 		else

  00040	eb 01		 jmp	 SHORT $L225682
$L225681:

; 152  : 			i++;

  00042	46		 inc	 esi
$L225682:

; 140  : 	for( int i = 0; i < nNullLength; )

  00043	3b f7		 cmp	 esi, edi
  00045	7c ea		 jl	 SHORT $L225679
  00047	5b		 pop	 ebx
$L225680:

; 153  : 	}
; 154  : 	// i nLength   Word ,     .
; 155  : 	if( i > nNullLength )

  00048	3b f7		 cmp	 esi, edi
  0004a	5f		 pop	 edi
  0004b	7e 08		 jle	 SHORT $L225683

; 156  : 		lpStr[ i - 2 ] = 0;

  0004d	c6 44 2e fe 00	 mov	 BYTE PTR [esi+ebp-2], 0
  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp

; 159  : }

  00054	c3		 ret	 0
$L225683:

; 157  : 	else
; 158  : 		lpStr[ i ] = 0;

  00055	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  00059	5e		 pop	 esi
  0005a	5d		 pop	 ebp

; 159  : }

  0005b	c3		 ret	 0
?SetStrNull@@YAXPADH@Z ENDP				; SetStrNull
_TEXT	ENDS
PUBLIC	?PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z ; PaintTexture
PUBLIC	??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@	; `string'
PUBLIC	??_C@_0DG@EONEHPLE@?6Surface?5?$CFd?5?$CFd?0?5Pt?5?$CFd?5?$CFd?5IMG_BIT@ ; `string'
PUBLIC	??_C@_0GC@NMPFDOHB@D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_24?6@ ; `string'
PUBLIC	??_C@_0CB@FIMJOGAK@?5D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_32@ ; `string'
PUBLIC	??_C@_0CB@JOHHHILL@?5D3DFMT_A8R8G8B8?5ERROR?5IMGBIT_24@ ; `string'
PUBLIC	??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@	; `string'
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	_sprintf:NEAR
EXTRN	?AfxMessageBox@@YGHPBDII@Z:NEAR			; AfxMessageBox
;	COMDAT ?szstrError@?1??PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z@4PADA
_BSS	SEGMENT
?szstrError@?1??PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z@4PADA DB 080H DUP (?) ; `PaintTexture'::`2'::szstrError
_BSS	ENDS
;	COMDAT ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@
CONST	SEGMENT
??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@ DB 0aH, 'PaintTexture - IN'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EONEHPLE@?6Surface?5?$CFd?5?$CFd?0?5Pt?5?$CFd?5?$CFd?5IMG_BIT@
CONST	SEGMENT
??_C@_0DG@EONEHPLE@?6Surface?5?$CFd?5?$CFd?0?5Pt?5?$CFd?5?$CFd?5IMG_BIT@ DB 0aH
	DB	'Surface %d %d, Pt %d %d IMG_BIT = %d, D3DFORMAT = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@NMPFDOHB@D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_24?6@
CONST	SEGMENT
??_C@_0GC@NMPFDOHB@D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_24?6@ DB 'D3DFMT_A4R4G4'
	DB	'B4 ERROR IMGBIT_24', 0aH, ' Current = %d   Tex X = %d, Y = %d'
	DB	'  [%d,%d]', 0aH, ' LINE = %d', 0aH, ' Size = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FIMJOGAK@?5D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_32@
CONST	SEGMENT
??_C@_0CB@FIMJOGAK@?5D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_32@ DB ' D3DFMT_A4R4G'
	DB	'4B4 ERROR IMGBIT_32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JOHHHILL@?5D3DFMT_A8R8G8B8?5ERROR?5IMGBIT_24@
CONST	SEGMENT
??_C@_0CB@JOHHHILL@?5D3DFMT_A8R8G8B8?5ERROR?5IMGBIT_24@ DB ' D3DFMT_A8R8G'
	DB	'8B8 ERROR IMGBIT_24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@
CONST	SEGMENT
??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@ DB 0aH, 'PaintTexture - O'
	DB	'UT', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z
_TEXT	SEGMENT
_dwOffsetDest$ = -2092					; size = 4
tv417 = -2088						; size = 4
tv343 = -2088						; size = 4
tv280 = -2088						; size = 4
_x$225824 = -2088					; size = 4
tv527 = -2084						; size = 4
$T227342 = -2080					; size = 4
_pSrc$225841 = -2080					; size = 4
tv217 = -2080						; size = 4
_sizeTexture$ = -2076					; size = 8
_dwLine$ = -2068					; size = 4
_nSizeSurface$ = -2064					; size = 4
$T227341 = -2060					; size = 4
_szFile$225786 = -2056					; size = 2048
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pDestData$ = 8						; size = 4
_pImage$ = 12						; size = 4
_pt$ = 16						; size = 8
_sizeSurface$ = 24					; size = 8
_d3dFormat$ = 32					; size = 4
?PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z PROC NEAR ; PaintTexture, COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 2c 08 00
	00		 sub	 esp, 2092		; 0000082cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	8b 55 0c	 mov	 edx, DWORD PTR _pImage$[ebp]
  00014	33 c5		 xor	 eax, ebp
  00016	53		 push	 ebx
  00017	89 84 24 2c 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2096], eax
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pDestData$[ebp]
  00021	56		 push	 esi
  00022	57		 push	 edi

; 369  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  00023	89 44 24 2c	 mov	 DWORD PTR $T227341[esp+2104], eax
  00027	33 c0		 xor	 eax, eax
  00029	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0002e	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?g_szCrashClient@@3PADA ; g_szCrashClient
  00033	f3 ab		 rep stosd
  00035	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?g_szCrashClient@@3PADA ; g_szCrashClient
  0003a	89 54 24 18	 mov	 DWORD PTR $T227342[esp+2104], edx
  0003e	4f		 dec	 edi
  0003f	90		 npad	 1
$L227362:
  00040	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00043	47		 inc	 edi
  00044	84 c0		 test	 al, al
  00046	75 f8		 jne	 SHORT $L227362
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@
  0004e	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@+4
  00053	89 0f		 mov	 DWORD PTR [edi], ecx
  00055	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@+8
  0005b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0005e	a1 0c 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@+12
  00063	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00066	66 8b 0d 10 00
	00 00		 mov	 cx, WORD PTR ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@+16
  0006d	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00070	a0 12 00 00 00	 mov	 al, BYTE PTR ??_C@_0BD@EAALEJKH@?6PaintTexture?5?9?5IN?$AA@+18
  00075	66 89 4f 10	 mov	 WORD PTR [edi+16], cx
  00079	88 47 12	 mov	 BYTE PTR [edi+18], al
  0007c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0007f	8b 7d 10	 mov	 edi, DWORD PTR _pt$[ebp]
  00082	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00085	89 4c 24 20	 mov	 DWORD PTR _sizeTexture$[esp+2108], ecx
  00089	8b 4d 18	 mov	 ecx, DWORD PTR _sizeSurface$[ebp]
  0008c	8b c1		 mov	 eax, ecx
  0008e	0f af 45 14	 imul	 eax, DWORD PTR _pt$[ebp+4]
  00092	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00095	03 c7		 add	 eax, edi
  00097	89 44 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], eax
  0009b	8b c1		 mov	 eax, ecx
  0009d	2b c6		 sub	 eax, esi
  0009f	89 44 24 24	 mov	 DWORD PTR _dwLine$[esp+2104], eax
  000a3	89 74 24 1c	 mov	 DWORD PTR _sizeTexture$[esp+2104], esi
  000a7	8b 75 1c	 mov	 esi, DWORD PTR _sizeSurface$[ebp+4]
  000aa	8b c6		 mov	 eax, esi
  000ac	0f af c1	 imul	 eax, ecx
  000af	89 44 24 28	 mov	 DWORD PTR _nSizeSurface$[esp+2104], eax
  000b3	8b 45 20	 mov	 eax, DWORD PTR _d3dFormat$[ebp]
  000b6	50		 push	 eax
  000b7	8b 45 14	 mov	 eax, DWORD PTR _pt$[ebp+4]
  000ba	52		 push	 edx
  000bb	50		 push	 eax
  000bc	57		 push	 edi
  000bd	56		 push	 esi
  000be	51		 push	 ecx
  000bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@EONEHPLE@?6Surface?5?$CFd?5?$CFd?0?5Pt?5?$CFd?5?$CFd?5IMG_BIT@
  000c4	68 00 00 00 00	 push	 OFFSET FLAT:?szstrError@?1??PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z@4PADA
  000c9	33 db		 xor	 ebx, ebx
  000cb	e8 00 00 00 00	 call	 _sprintf
  000d0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?szstrError@?1??PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z@4PADA
  000d5	83 c4 20	 add	 esp, 32			; 00000020H
  000d8	8b f0		 mov	 esi, eax
  000da	8d 9b 00 00 00
	00		 npad	 6
$L227363:
  000e0	8a 08		 mov	 cl, BYTE PTR [eax]
  000e2	40		 inc	 eax
  000e3	84 c9		 test	 cl, cl
  000e5	75 f9		 jne	 SHORT $L227363
  000e7	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?g_szCrashClient@@3PADA ; g_szCrashClient
  000ec	2b c6		 sub	 eax, esi
  000ee	4f		 dec	 edi
  000ef	90		 npad	 1
$L227364:
  000f0	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000f3	47		 inc	 edi
  000f4	84 c9		 test	 cl, cl
  000f6	75 f8		 jne	 SHORT $L227364
  000f8	8b c8		 mov	 ecx, eax
  000fa	c1 e9 02	 shr	 ecx, 2
  000fd	f3 a5		 rep movsd
  000ff	8b c8		 mov	 ecx, eax
  00101	8b 45 20	 mov	 eax, DWORD PTR _d3dFormat$[ebp]
  00104	83 e1 03	 and	 ecx, 3
  00107	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0010a	f3 a4		 rep movsb
  0010c	0f 85 23 02 00
	00		 jne	 $L225768
  00112	8b 44 24 18	 mov	 eax, DWORD PTR $T227342[esp+2104]
  00116	8b 30		 mov	 esi, DWORD PTR [eax]
  00118	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0011b	83 f8 02	 cmp	 eax, 2
  0011e	0f 85 25 01 00
	00		 jne	 $L225772
  00124	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  00127	8b 54 24 20	 mov	 edx, DWORD PTR _sizeTexture$[esp+2108]
  0012b	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0012e	3b c8		 cmp	 ecx, eax
  00130	0f 8d 71 03 00
	00		 jge	 $L225846
  00136	8b 54 24 1c	 mov	 edx, DWORD PTR _sizeTexture$[esp+2104]
  0013a	8b 7d 10	 mov	 edi, DWORD PTR _pt$[ebp]
  0013d	03 d7		 add	 edx, edi
  0013f	2b c1		 sub	 eax, ecx
  00141	89 54 24 14	 mov	 DWORD PTR tv527[esp+2104], edx
  00145	89 44 24 10	 mov	 DWORD PTR tv280[esp+2104], eax
  00149	eb 05		 jmp	 SHORT $L225774
$L227374:

; 250  : 	memset( g_szCrashClient, 0, sizeof(char) * 1024 );
; 251  : 
; 252  : 	strcat( g_szCrashClient, "\nPaintTexture - IN" );
; 253  : 
; 254  : 	SIZE sizeTexture = pImage->size;
; 255  : 	DWORD dwOffsetSrc = 0;
; 256  : 	DWORD dwOffsetDest = ( pt.y * sizeSurface.cx + pt.x );
; 257  : 	DWORD dwLine = sizeSurface.cx - sizeTexture.cx;
; 258  : 	int nSizeSurface = sizeSurface.cx * sizeSurface.cy;
; 259  : 
; 260  : 	static char szstrError[128];
; 261  : 
; 262  : 	sprintf( szstrError, "\nSurface %d %d, Pt %d %d IMG_BIT = %d, D3DFORMAT = %d", sizeSurface.cx, sizeSurface.cy, pt.x, pt.y, pImage->nImgBit, d3dFormat );
; 263  : 	strcat( g_szCrashClient, szstrError );
; 264  : 
; 265  : 	if( d3dFormat == D3DFMT_A4R4G4B4 )
; 266  : 	{
; 267  : 		LPWORD pDest = (LPWORD) pDestData;
; 268  : 		LPBYTE pSrc = pImage->lpData;
; 269  : 		if( pImage->nImgBit == IMGBIT_24 )
; 270  : 		{
; 271  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  0014b	8b 7d 10	 mov	 edi, DWORD PTR _pt$[ebp]
  0014e	8b ff		 npad	 2
$L225774:

; 272  : 			{
; 273  : 				for( int x = pt.x; x < pt.x + sizeTexture.cx; x++, dwOffsetSrc += 3, dwOffsetDest++ )

  00150	3b 7c 24 14	 cmp	 edi, DWORD PTR tv527[esp+2104]
  00154	0f 8d cd 00 00
	00		 jge	 $L225775
  0015a	8d 9b 00 00 00
	00		 npad	 6
$L225778:

; 274  : 				{
; 275  : 					if( dwOffsetDest >= 0 && (DWORD)dwOffsetDest < (DWORD)nSizeSurface )

  00160	8b 44 24 0c	 mov	 eax, DWORD PTR _dwOffsetDest$[esp+2104]
  00164	3b 44 24 28	 cmp	 eax, DWORD PTR _nSizeSurface$[esp+2104]
  00168	73 51		 jae	 SHORT $L225779

; 276  : 					{
; 277  : 						DWORD bitcount = pImage->nImgBit / 8;
; 278  : //						if( dwOffsetSrc >= pImage->dwSize )
; 279  : 						if( pImage->dwSize != pImage->dwSizeBak )

  0016a	8b 44 24 18	 mov	 eax, DWORD PTR $T227342[esp+2104]
  0016e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00171	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00174	75 5c		 jne	 SHORT $L227351

; 288  : 
; 289  : //							dwOffsetSrc = si
; 290  : 							break;
; 291  : 						}
; 292  : 
; 293  : 						BYTE byData1 = pSrc[ dwOffsetSrc + 0 ] >> 4; 

  00176	8a 0c 1e	 mov	 cl, BYTE PTR [esi+ebx]

; 294  : 						BYTE byData2 = pSrc[ dwOffsetSrc + 1 ] >> 4; 

  00179	8a 54 1e 01	 mov	 dl, BYTE PTR [esi+ebx+1]

; 295  : 						BYTE byData3 = pSrc[ dwOffsetSrc + 2 ] >> 4; 

  0017d	8a 44 1e 02	 mov	 al, BYTE PTR [esi+ebx+2]
  00181	c0 e9 04	 shr	 cl, 4
  00184	c0 ea 04	 shr	 dl, 4
  00187	c0 e8 04	 shr	 al, 4

; 296  : 						//      ff00ff  .
; 297  : 						if( byData1 != 0xf || byData2 != 0 || byData3 != 0xf )

  0018a	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  0018d	75 08		 jne	 SHORT $L225792
  0018f	84 d2		 test	 dl, dl
  00191	75 04		 jne	 SHORT $L225792
  00193	3a c1		 cmp	 al, cl
  00195	74 24		 je	 SHORT $L225779
$L225792:

; 298  : 							pDest[ dwOffsetDest ] = 0xf000 | ( byData3 << 8 ) | ( byData2 << 4 ) | byData1;

  00197	0c f0		 or	 al, 240			; 000000f0H
  00199	66 0f b6 c0	 movzx	 ax, al
  0019d	66 0f b6 d2	 movzx	 dx, dl
  001a1	66 0f b6 c9	 movzx	 cx, cl
  001a5	c1 e0 04	 shl	 eax, 4
  001a8	0b c2		 or	 eax, edx
  001aa	8b 54 24 2c	 mov	 edx, DWORD PTR $T227341[esp+2104]
  001ae	c1 e0 04	 shl	 eax, 4
  001b1	0b c1		 or	 eax, ecx
  001b3	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwOffsetDest$[esp+2104]
  001b7	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
$L225779:
  001bb	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwOffsetDest$[esp+2104]
  001bf	8b 44 24 14	 mov	 eax, DWORD PTR tv527[esp+2104]
  001c3	47		 inc	 edi
  001c4	83 c3 03	 add	 ebx, 3
  001c7	41		 inc	 ecx
  001c8	3b f8		 cmp	 edi, eax
  001ca	89 4c 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], ecx
  001ce	7c 90		 jl	 SHORT $L225778

; 346  : 					{
; 347  : 						if( dwOffsetSrc >= (DWORD)( (sizeTexture.cx * sizeTexture.cy * 2 ) ) )

  001d0	eb 55		 jmp	 SHORT $L225775
$L227351:

; 280  : 						{
; 281  : 							
; 282  : 							char szFile[2048] = { 0 };
; 283  : 
; 284  : 							sprintf( szFile, "D3DFMT_A4R4G4B4 ERROR IMGBIT_24\n Current = %d   Tex X = %d, Y = %d  [%d,%d]\n LINE = %d\n Size = %d", dwOffsetSrc, sizeTexture.cx, sizeTexture.cy, sizeSurface.cx, sizeSurface.cy, dwLine, pImage->dwSize );

  001d2	8b 54 24 18	 mov	 edx, DWORD PTR $T227342[esp+2104]
  001d6	33 c0		 xor	 eax, eax
  001d8	c6 44 24 30 00	 mov	 BYTE PTR _szFile$225786[esp+2104], 0
  001dd	b9 ff 01 00 00	 mov	 ecx, 511		; 000001ffH
  001e2	8d 7c 24 31	 lea	 edi, DWORD PTR _szFile$225786[esp+2105]
  001e6	f3 ab		 rep stosd
  001e8	8b 4c 24 24	 mov	 ecx, DWORD PTR _dwLine$[esp+2104]
  001ec	66 ab		 stosw
  001ee	aa		 stosb
  001ef	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001f2	8b 55 1c	 mov	 edx, DWORD PTR _sizeSurface$[ebp+4]
  001f5	50		 push	 eax
  001f6	8b 45 18	 mov	 eax, DWORD PTR _sizeSurface$[ebp]
  001f9	51		 push	 ecx
  001fa	8b 4c 24 28	 mov	 ecx, DWORD PTR _sizeTexture$[esp+2116]
  001fe	52		 push	 edx
  001ff	8b 54 24 28	 mov	 edx, DWORD PTR _sizeTexture$[esp+2116]
  00203	50		 push	 eax
  00204	51		 push	 ecx
  00205	52		 push	 edx
  00206	53		 push	 ebx
  00207	8d 44 24 4c	 lea	 eax, DWORD PTR _szFile$225786[esp+2132]
  0020b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GC@NMPFDOHB@D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_24?6@
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _sprintf
  00216	83 c4 24	 add	 esp, 36			; 00000024H

; 285  : 							//if( byData4 )
; 286  : 							//	pDest[ dwOffsetDest ] = ( byData4 << 12 ) | ( byData3 << 8 ) | ( byData2 << 4 ) | byData1;
; 287  : 							AfxMessageBox(szFile, MB_OKCANCEL);

  00219	6a 00		 push	 0
  0021b	6a 01		 push	 1
  0021d	8d 4c 24 38	 lea	 ecx, DWORD PTR _szFile$225786[esp+2112]
  00221	51		 push	 ecx
  00222	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
$L225775:
  00227	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwOffsetDest$[esp+2104]
  0022b	8b 54 24 24	 mov	 edx, DWORD PTR _dwLine$[esp+2104]
  0022f	8b 44 24 10	 mov	 eax, DWORD PTR tv280[esp+2104]
  00233	03 ca		 add	 ecx, edx
  00235	48		 dec	 eax
  00236	89 4c 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], ecx
  0023a	89 44 24 10	 mov	 DWORD PTR tv280[esp+2104], eax
  0023e	0f 85 07 ff ff
	ff		 jne	 $L227374

; 299  : 					}
; 300  : 				}
; 301  : 			}
; 302  : 		}
; 303  : 		else

  00244	e9 5e 02 00 00	 jmp	 $L225846
$L225772:

; 304  : 		if( pImage->nImgBit == IMGBIT_32 )

  00249	83 f8 03	 cmp	 eax, 3
  0024c	0f 85 55 02 00
	00		 jne	 $L225846

; 305  : 		{
; 306  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  00252	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  00255	8b 44 24 20	 mov	 eax, DWORD PTR _sizeTexture$[esp+2108]
  00259	03 c1		 add	 eax, ecx
  0025b	3b c8		 cmp	 ecx, eax
  0025d	0f 8d 44 02 00
	00		 jge	 $L225846
  00263	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  00266	8b 7c 24 1c	 mov	 edi, DWORD PTR _sizeTexture$[esp+2104]

; 367  : 		{
; 368  : 			LPDWORD pSrc = (LPDWORD)pImage->lpData;

  0026a	03 fa		 add	 edi, edx
  0026c	2b c1		 sub	 eax, ecx
  0026e	89 7c 24 14	 mov	 DWORD PTR tv527[esp+2104], edi
  00272	89 44 24 10	 mov	 DWORD PTR tv343[esp+2104], eax
  00276	eb 08		 jmp	 SHORT $L225796
$L227375:

; 305  : 		{
; 306  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  00278	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  0027b	eb 03 8d 49 00	 npad	 5
$L225796:

; 307  : 			{
; 308  : 				for( int x = pt.x; x < pt.x + sizeTexture.cx; x++, dwOffsetSrc += 4, dwOffsetDest++ )

  00280	3b 54 24 14	 cmp	 edx, DWORD PTR tv527[esp+2104]
  00284	8b ca		 mov	 ecx, edx
  00286	0f 8d 87 00 00
	00		 jge	 $L227367
  0028c	8d 64 24 00	 npad	 4
$L225800:

; 309  : 				{
; 310  : 					if( dwOffsetDest >= 0 && (DWORD)dwOffsetDest < (DWORD)nSizeSurface )

  00290	8b 7c 24 0c	 mov	 edi, DWORD PTR _dwOffsetDest$[esp+2104]
  00294	3b 7c 24 28	 cmp	 edi, DWORD PTR _nSizeSurface$[esp+2104]
  00298	73 56		 jae	 SHORT $L225801

; 311  : 					{
; 312  : 						if( dwOffsetSrc >= (DWORD)( (sizeTexture.cx * sizeTexture.cy * 4) ) )

  0029a	8b 54 24 20	 mov	 edx, DWORD PTR _sizeTexture$[esp+2108]
  0029e	0f af 54 24 1c	 imul	 edx, DWORD PTR _sizeTexture$[esp+2104]
  002a3	c1 e2 02	 shl	 edx, 2
  002a6	3b da		 cmp	 ebx, edx
  002a8	73 59		 jae	 SHORT $L227352

; 317  : 							break;
; 318  : 						}
; 319  : 
; 320  : 						BYTE byData1 = pSrc[ dwOffsetSrc + 0 ] >> 4; 
; 321  : 						BYTE byData2 = pSrc[ dwOffsetSrc + 1 ] >> 4; 
; 322  : 						BYTE byData3 = pSrc[ dwOffsetSrc + 2 ] >> 4; 
; 323  : 						
; 324  : 
; 325  : 						BYTE byData4 = pSrc[ dwOffsetSrc + 3 ] >> 4; 

  002aa	8a 44 1e 03	 mov	 al, BYTE PTR [esi+ebx+3]
  002ae	c0 e8 04	 shr	 al, 4

; 326  : 						//          .
; 327  : 						if( byData4 )

  002b1	84 c0		 test	 al, al
  002b3	74 3b		 je	 SHORT $L225801
  002b5	8a 54 1e 02	 mov	 dl, BYTE PTR [esi+ebx+2]

; 328  : 							pDest[ dwOffsetDest ] = ( byData4 << 12 ) | ( byData3 << 8 ) | ( byData2 << 4 ) | byData1;

  002b9	66 0f b6 c0	 movzx	 ax, al
  002bd	c0 ea 04	 shr	 dl, 4
  002c0	66 0f b6 d2	 movzx	 dx, dl
  002c4	c1 e0 04	 shl	 eax, 4
  002c7	0b d0		 or	 edx, eax
  002c9	8a 44 1e 01	 mov	 al, BYTE PTR [esi+ebx+1]
  002cd	c0 e8 04	 shr	 al, 4
  002d0	66 0f b6 c0	 movzx	 ax, al
  002d4	c1 e2 04	 shl	 edx, 4
  002d7	0b d0		 or	 edx, eax
  002d9	8a 04 1e	 mov	 al, BYTE PTR [esi+ebx]
  002dc	c0 e8 04	 shr	 al, 4
  002df	66 0f b6 c0	 movzx	 ax, al
  002e3	c1 e2 04	 shl	 edx, 4
  002e6	0b d0		 or	 edx, eax
  002e8	8b 44 24 2c	 mov	 eax, DWORD PTR $T227341[esp+2104]
  002ec	66 89 14 78	 mov	 WORD PTR [eax+edi*2], dx
$L225801:
  002f0	8b 44 24 14	 mov	 eax, DWORD PTR tv527[esp+2104]
  002f4	41		 inc	 ecx
  002f5	83 c3 04	 add	 ebx, 4
  002f8	47		 inc	 edi
  002f9	3b c8		 cmp	 ecx, eax
  002fb	89 7c 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], edi
  002ff	7c 8f		 jl	 SHORT $L225800

; 346  : 					{
; 347  : 						if( dwOffsetSrc >= (DWORD)( (sizeTexture.cx * sizeTexture.cy * 2 ) ) )

  00301	eb 14		 jmp	 SHORT $L225797
$L227352:

; 313  : 						{
; 314  : 							//if( byData4 )
; 315  : 							//	pDest[ dwOffsetDest ] = ( byData4 << 12 ) | ( byData3 << 8 ) | ( byData2 << 4 ) | byData1;
; 316  : 							AfxMessageBox(" D3DFMT_A4R4G4B4 ERROR IMGBIT_32", MB_OK );

  00303	6a 00		 push	 0
  00305	6a 00		 push	 0
  00307	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@FIMJOGAK@?5D3DFMT_A4R4G4B4?5ERROR?5IMGBIT_32@
  0030c	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00311	eb 04		 jmp	 SHORT $L225797
$L227367:
  00313	8b 7c 24 0c	 mov	 edi, DWORD PTR _dwOffsetDest$[esp+2104]
$L225797:

; 305  : 		{
; 306  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  00317	8b 4c 24 24	 mov	 ecx, DWORD PTR _dwLine$[esp+2104]
  0031b	8b 44 24 10	 mov	 eax, DWORD PTR tv343[esp+2104]
  0031f	03 f9		 add	 edi, ecx
  00321	48		 dec	 eax
  00322	89 7c 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], edi
  00326	89 44 24 10	 mov	 DWORD PTR tv343[esp+2104], eax
  0032a	0f 85 48 ff ff
	ff		 jne	 $L227375

; 329  : 					}
; 330  : 				}
; 331  : 			}
; 332  : 		}
; 333  : 	}
; 334  : 	else

  00330	e9 72 01 00 00	 jmp	 $L225846
$L225768:

; 335  : 	if( d3dFormat == D3DFMT_A8R8G8B8 )

  00335	83 f8 15	 cmp	 eax, 21			; 00000015H
  00338	0f 85 69 01 00
	00		 jne	 $L225846

; 336  : 	{
; 337  : 		LPDWORD pDest = (LPDWORD) pDestData;
; 338  : 		if( pImage->nImgBit == IMGBIT_24 )

  0033e	8b 44 24 18	 mov	 eax, DWORD PTR $T227342[esp+2104]
  00342	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00345	83 f9 02	 cmp	 ecx, 2
  00348	0f 85 dc 00 00
	00		 jne	 $L225818

; 341  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  0034e	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  00351	8b 54 24 20	 mov	 edx, DWORD PTR _sizeTexture$[esp+2108]
  00355	8b 38		 mov	 edi, DWORD PTR [eax]
  00357	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0035a	3b c8		 cmp	 ecx, eax
  0035c	0f 8d 45 01 00
	00		 jge	 $L225846
  00362	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]

; 366  : 		if( pImage->nImgBit == IMGBIT_32 )

  00365	8b 74 24 1c	 mov	 esi, DWORD PTR _sizeTexture$[esp+2104]

; 367  : 		{
; 368  : 			LPDWORD pSrc = (LPDWORD)pImage->lpData;

  00369	03 f2		 add	 esi, edx
  0036b	2b c1		 sub	 eax, ecx
  0036d	89 74 24 14	 mov	 DWORD PTR tv527[esp+2104], esi
  00371	89 44 24 18	 mov	 DWORD PTR tv217[esp+2104], eax
  00375	eb 09		 jmp	 SHORT $L225821
$L227376:

; 339  : 		{
; 340  : 			LPBYTE pSrc = pImage->lpData;

  00377	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  0037a	8d 9b 00 00 00
	00		 npad	 6
$L225821:

; 342  : 			{
; 343  : 				for( int x = pt.x; x < pt.x + sizeTexture.cx; x++, dwOffsetSrc += 3, dwOffsetDest++ )

  00380	3b 54 24 14	 cmp	 edx, DWORD PTR tv527[esp+2104]
  00384	89 54 24 10	 mov	 DWORD PTR _x$225824[esp+2104], edx
  00388	0f 8d 7a 00 00
	00		 jge	 $L227368
  0038e	8b ff		 npad	 2
$L225825:

; 344  : 				{
; 345  : 					if( dwOffsetDest >= 0 && (DWORD)dwOffsetDest < (DWORD)nSizeSurface )

  00390	8b 74 24 0c	 mov	 esi, DWORD PTR _dwOffsetDest$[esp+2104]
  00394	3b 74 24 28	 cmp	 esi, DWORD PTR _nSizeSurface$[esp+2104]
  00398	73 43		 jae	 SHORT $L225826

; 346  : 					{
; 347  : 						if( dwOffsetSrc >= (DWORD)( (sizeTexture.cx * sizeTexture.cy * 2 ) ) )

  0039a	8b 44 24 20	 mov	 eax, DWORD PTR _sizeTexture$[esp+2108]
  0039e	0f af 44 24 1c	 imul	 eax, DWORD PTR _sizeTexture$[esp+2104]
  003a3	d1 e0		 shl	 eax, 1
  003a5	3b d8		 cmp	 ebx, eax
  003a7	73 4f		 jae	 SHORT $L227353

; 352  : 							break;
; 353  : 						}
; 354  : 
; 355  : 						BYTE byData1 = pSrc[ dwOffsetSrc + 0 ]; 

  003a9	8a 04 1f	 mov	 al, BYTE PTR [edi+ebx]

; 356  : 						BYTE byData2 = pSrc[ dwOffsetSrc + 1 ]; 
; 357  : 						BYTE byData3 = pSrc[ dwOffsetSrc + 2 ]; 
; 358  : 						//      ff00ff  .
; 359  : 						if( byData1 != 0xff || byData2 != 0 || byData3 != 0xff )

  003ac	3c ff		 cmp	 al, 255			; 000000ffH
  003ae	8a 54 1f 01	 mov	 dl, BYTE PTR [edi+ebx+1]
  003b2	8a 4c 1f 02	 mov	 cl, BYTE PTR [edi+ebx+2]
  003b6	75 08		 jne	 SHORT $L225838
  003b8	84 d2		 test	 dl, dl
  003ba	75 04		 jne	 SHORT $L225838
  003bc	3a c8		 cmp	 cl, al
  003be	74 1d		 je	 SHORT $L225826
$L225838:

; 360  : 							pDest[ dwOffsetDest ] = 0xf000 | ( byData3 << 16 ) | ( byData2 << 8 ) | byData1;

  003c0	33 d2		 xor	 edx, edx
  003c2	8a f1		 mov	 dh, cl
  003c4	8b 4c 24 2c	 mov	 ecx, DWORD PTR $T227341[esp+2104]
  003c8	0f b6 c0	 movzx	 eax, al
  003cb	8a 54 1f 01	 mov	 dl, BYTE PTR [edi+ebx+1]
  003cf	81 ca f0 00 00
	00		 or	 edx, 240		; 000000f0H
  003d5	c1 e2 08	 shl	 edx, 8
  003d8	0b d0		 or	 edx, eax
  003da	89 14 b1	 mov	 DWORD PTR [ecx+esi*4], edx
$L225826:
  003dd	8b 44 24 10	 mov	 eax, DWORD PTR _x$225824[esp+2104]
  003e1	8b 4c 24 14	 mov	 ecx, DWORD PTR tv527[esp+2104]
  003e5	40		 inc	 eax
  003e6	83 c3 03	 add	 ebx, 3
  003e9	46		 inc	 esi
  003ea	3b c1		 cmp	 eax, ecx
  003ec	89 44 24 10	 mov	 DWORD PTR _x$225824[esp+2104], eax
  003f0	89 74 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], esi
  003f4	7c 9a		 jl	 SHORT $L225825

; 346  : 					{
; 347  : 						if( dwOffsetSrc >= (DWORD)( (sizeTexture.cx * sizeTexture.cy * 2 ) ) )

  003f6	eb 14		 jmp	 SHORT $L225822
$L227353:

; 348  : 						{
; 349  : 							//if( byData4 )
; 350  : 							//	pDest[ dwOffsetDest ] = ( byData4 << 12 ) | ( byData3 << 8 ) | ( byData2 << 4 ) | byData1;
; 351  : 							AfxMessageBox(" D3DFMT_A8R8G8B8 ERROR IMGBIT_24", MB_OK );

  003f8	6a 00		 push	 0
  003fa	6a 00		 push	 0
  003fc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@JOHHHILL@?5D3DFMT_A8R8G8B8?5ERROR?5IMGBIT_24@
  00401	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00406	eb 04		 jmp	 SHORT $L225822
$L227368:
  00408	8b 74 24 0c	 mov	 esi, DWORD PTR _dwOffsetDest$[esp+2104]
$L225822:

; 341  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  0040c	8b 4c 24 24	 mov	 ecx, DWORD PTR _dwLine$[esp+2104]
  00410	8b 44 24 18	 mov	 eax, DWORD PTR tv217[esp+2104]
  00414	03 f1		 add	 esi, ecx
  00416	48		 dec	 eax
  00417	89 74 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], esi
  0041b	89 44 24 18	 mov	 DWORD PTR tv217[esp+2104], eax
  0041f	0f 85 52 ff ff
	ff		 jne	 $L227376

; 361  : 					}
; 362  : 				}
; 363  : 			}
; 364  : 		}
; 365  : 		else

  00425	e9 7d 00 00 00	 jmp	 $L225846
$L225818:

; 366  : 		if( pImage->nImgBit == IMGBIT_32 )

  0042a	83 f9 03	 cmp	 ecx, 3
  0042d	75 78		 jne	 SHORT $L225846

; 367  : 		{
; 368  : 			LPDWORD pSrc = (LPDWORD)pImage->lpData;

  0042f	8b 10		 mov	 edx, DWORD PTR [eax]

; 369  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  00431	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  00434	8b 44 24 20	 mov	 eax, DWORD PTR _sizeTexture$[esp+2108]
  00438	03 c1		 add	 eax, ecx
  0043a	3b c8		 cmp	 ecx, eax
  0043c	89 54 24 18	 mov	 DWORD PTR _pSrc$225841[esp+2104], edx
  00440	7d 65		 jge	 SHORT $L225846
  00442	8b 54 24 1c	 mov	 edx, DWORD PTR _sizeTexture$[esp+2104]
  00446	8b 75 10	 mov	 esi, DWORD PTR _pt$[ebp]
  00449	03 d6		 add	 edx, esi
  0044b	2b c1		 sub	 eax, ecx
  0044d	89 54 24 14	 mov	 DWORD PTR tv527[esp+2104], edx
  00451	89 44 24 10	 mov	 DWORD PTR tv417[esp+2104], eax
$L225844:

; 370  : 			{
; 371  : 				for( int x = pt.x; x < pt.x + sizeTexture.cx; x++, dwOffsetSrc++, dwOffsetDest++ )

  00455	3b f2		 cmp	 esi, edx
  00457	7d 35		 jge	 SHORT $L227369
  00459	2b d6		 sub	 edx, esi
  0045b	eb 03 8d 49 00	 npad	 5
$L225848:

; 372  : 				{
; 373  : 					if( dwOffsetDest >= 0 && (DWORD)dwOffsetDest < (DWORD)nSizeSurface )

  00460	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwOffsetDest$[esp+2104]
  00464	3b 4c 24 28	 cmp	 ecx, DWORD PTR _nSizeSurface$[esp+2104]
  00468	73 15		 jae	 SHORT $L225849

; 374  : 					{
; 375  : 						//          .
; 376  : 						if( pSrc[ dwOffsetSrc ] & 0xff000000 )

  0046a	8b 44 24 18	 mov	 eax, DWORD PTR _pSrc$225841[esp+2104]
  0046e	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00471	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00476	74 07		 je	 SHORT $L225849

; 377  : 							pDest[ dwOffsetDest ] = pSrc[ dwOffsetSrc ];//yData4 << 24 ) | ( byData3 << 16 ) | ( byData2 << 8 ) | byData1;

  00478	8b 7c 24 2c	 mov	 edi, DWORD PTR $T227341[esp+2104]
  0047c	89 04 8f	 mov	 DWORD PTR [edi+ecx*4], eax
$L225849:
  0047f	43		 inc	 ebx
  00480	41		 inc	 ecx
  00481	4a		 dec	 edx
  00482	89 4c 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], ecx
  00486	75 d8		 jne	 SHORT $L225848

; 370  : 			{
; 371  : 				for( int x = pt.x; x < pt.x + sizeTexture.cx; x++, dwOffsetSrc++, dwOffsetDest++ )

  00488	8b 54 24 14	 mov	 edx, DWORD PTR tv527[esp+2104]
  0048c	eb 04		 jmp	 SHORT $L225845
$L227369:
  0048e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _dwOffsetDest$[esp+2104]
$L225845:

; 369  : 			for( int y = pt.y; y < pt.y + sizeTexture.cy; y++, dwOffsetDest += dwLine )

  00492	8b 7c 24 24	 mov	 edi, DWORD PTR _dwLine$[esp+2104]
  00496	8b 44 24 10	 mov	 eax, DWORD PTR tv417[esp+2104]
  0049a	03 cf		 add	 ecx, edi
  0049c	48		 dec	 eax
  0049d	89 4c 24 0c	 mov	 DWORD PTR _dwOffsetDest$[esp+2104], ecx
  004a1	89 44 24 10	 mov	 DWORD PTR tv417[esp+2104], eax
  004a5	75 ae		 jne	 SHORT $L225844
$L225846:

; 378  : 					}
; 379  : 				}
; 380  : 			}
; 381  : 		}
; 382  : 	}
; 383  : 
; 384  : 	strcat( g_szCrashClient, "\nPaintTexture - OUT" );

  004a7	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?g_szCrashClient@@3PADA ; g_szCrashClient
  004ac	4f		 dec	 edi
  004ad	8d 49 00	 npad	 3
$L227365:
  004b0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  004b3	47		 inc	 edi
  004b4	84 c0		 test	 al, al
  004b6	75 f8		 jne	 SHORT $L227365
  004b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@
  004be	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@+4
  004c4	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@+8
  004c9	89 0f		 mov	 DWORD PTR [edi], ecx
  004cb	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@+12
  004d1	89 57 04	 mov	 DWORD PTR [edi+4], edx
  004d4	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BE@KDDNLGBP@?6PaintTexture?5?9?5OUT?$AA@+16
  004da	89 47 08	 mov	 DWORD PTR [edi+8], eax
  004dd	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx

; 385  : }

  004e0	8b 8c 24 34 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2104]
  004e7	89 57 10	 mov	 DWORD PTR [edi+16], edx
  004ea	5f		 pop	 edi
  004eb	5e		 pop	 esi
  004ec	33 cd		 xor	 ecx, ebp
  004ee	5b		 pop	 ebx
  004ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f4	8b e5		 mov	 esp, ebp
  004f6	5d		 pop	 ebp
  004f7	c3		 ret	 0
?PaintTexture@@YAXPAXPAUIMAGE@@VCPoint@@VCSize@@W4_D3DFORMAT@@@Z ENDP ; PaintTexture
_TEXT	ENDS
PUBLIC	?AdjustSize@@YAXPAUtagSIZE@@@Z			; AdjustSize
; Function compile flags: /Ogty
;	COMDAT ?AdjustSize@@YAXPAUtagSIZE@@@Z
_TEXT	SEGMENT
_dwTemp$ = -4						; size = 2
_pSize$ = 8						; size = 4
?AdjustSize@@YAXPAUtagSIZE@@@Z PROC NEAR		; AdjustSize, COMDAT

; 388  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 389  : 	//  2   
; 390  : 	WORD dwTemp = 0x8000;
; 391  : 	for( int i = 0; i < 16; i++ )

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _pSize$[esp+4]
  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	57		 push	 edi
  00009	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
  0000e	89 7c 24 08	 mov	 DWORD PTR _dwTemp$[esp+12], edi
  00012	33 c9		 xor	 ecx, ecx
  00014	66 8b d7	 mov	 dx, di
  00017	53		 push	 ebx
$L227389:

; 392  : 	{
; 393  : 		if( pSize->cx & dwTemp )

  00018	0f b7 da	 movzx	 ebx, dx
  0001b	85 d8		 test	 ebx, eax
  0001d	75 10		 jne	 SHORT $L227385

; 399  : 			}
; 400  : 			break;
; 401  : 		}
; 402  : 		dwTemp >>= 1;

  0001f	66 d1 ea	 shr	 dx, 1
  00022	41		 inc	 ecx
  00023	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00026	66 89 54 24 0c	 mov	 WORD PTR _dwTemp$[esp+16], dx
  0002b	7c eb		 jl	 SHORT $L227389

; 406  : 	{
; 407  : 		if( pSize->cy & dwTemp )

  0002d	eb 16		 jmp	 SHORT $L225865
$L227385:

; 394  : 		{
; 395  : 			if( pSize->cx % dwTemp )

  0002f	0f b7 ca	 movzx	 ecx, dx
  00032	99		 cdq
  00033	f7 f9		 idiv	 ecx
  00035	85 d2		 test	 edx, edx
  00037	74 0c		 je	 SHORT $L225865

; 396  : 			{
; 397  : 				dwTemp <<= 1;

  00039	8b 54 24 0c	 mov	 edx, DWORD PTR _dwTemp$[esp+16]
  0003d	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]

; 398  : 				pSize->cx = dwTemp;

  00040	0f b7 c8	 movzx	 ecx, ax
  00043	89 0e		 mov	 DWORD PTR [esi], ecx
$L225865:
  00045	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 403  : 	}
; 404  : 	dwTemp = 0x8000;

  00048	89 7c 24 0c	 mov	 DWORD PTR _dwTemp$[esp+16], edi

; 405  : 	for( i = 0; i < 16; i++ )

  0004c	33 c9		 xor	 ecx, ecx
  0004e	66 8b d7	 mov	 dx, di
  00051	5b		 pop	 ebx
$L227390:

; 406  : 	{
; 407  : 		if( pSize->cy & dwTemp )

  00052	0f b7 fa	 movzx	 edi, dx
  00055	85 f8		 test	 edi, eax
  00057	75 12		 jne	 SHORT $L227386

; 413  : 			}
; 414  : 			break;
; 415  : 		}
; 416  : 		dwTemp >>= 1;

  00059	66 d1 ea	 shr	 dx, 1
  0005c	41		 inc	 ecx
  0005d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00060	66 89 54 24 08	 mov	 WORD PTR _dwTemp$[esp+12], dx
  00065	7c eb		 jl	 SHORT $L227390
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 417  : 	}
; 418  : 	//return size;
; 419  : }

  00069	59		 pop	 ecx
  0006a	c3		 ret	 0
$L227386:

; 408  : 		{
; 409  : 			if( pSize->cy % dwTemp )

  0006b	0f b7 ca	 movzx	 ecx, dx
  0006e	99		 cdq
  0006f	f7 f9		 idiv	 ecx
  00071	85 d2		 test	 edx, edx
  00073	74 0d		 je	 SHORT $L225870

; 410  : 			{
; 411  : 				dwTemp <<= 1;

  00075	8b 54 24 08	 mov	 edx, DWORD PTR _dwTemp$[esp+12]
  00079	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]

; 412  : 				pSize->cy = dwTemp;

  0007c	0f b7 c8	 movzx	 ecx, ax
  0007f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$L225870:
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi

; 417  : 	}
; 418  : 	//return size;
; 419  : }

  00084	59		 pop	 ecx
  00085	c3		 ret	 0
?AdjustSize@@YAXPAUtagSIZE@@@Z ENDP			; AdjustSize
_TEXT	ENDS
PUBLIC	?LoadTGA@@YAHPBDPAUIMAGE@@@Z			; LoadTGA
; Function compile flags: /Ogty
;	COMDAT ?LoadTGA@@YAHPBDPAUIMAGE@@@Z
_TEXT	SEGMENT
_lpszFileName$ = 8					; size = 4
_lpImage$ = 12						; size = 4
?LoadTGA@@YAHPBDPAUIMAGE@@@Z PROC NEAR			; LoadTGA, COMDAT

; 438  : #if !defined(__SERVER)
; 439  : 	lpImage->nImgBit = IMGBIT_32;
; 440  : 	CTarga targa;
; 441  : 	return targa.Load( lpszFileName, &lpImage->lpData, &lpImage->size );
; 442  : #endif
; 443  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 444  : }

  00002	c3		 ret	 0
?LoadTGA@@YAHPBDPAUIMAGE@@@Z ENDP			; LoadTGA
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L39168

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L227398:
$L39168:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L227399:
$L227397:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 66   : 		return (this+1);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 67   : 	}

  00003	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
; Function compile flags: /Ogty
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?AddRef@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 71   : 		ATLASSERT(nRefs > 0);
; 72   : 		_InterlockedIncrement(&nRefs);

  00000	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 73   : 	}

  0000c	c3		 ret	 0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 76   : 		return nRefs < 0;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 9c c0	 setl	 al

; 77   : 	}

  0000a	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Ogty
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 80   : 		return( nRefs > 1 ); 

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 01	 cmp	 edx, 1
  00008	0f 9f c0	 setg	 al

; 81   : 	}

  0000b	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Ogty
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	4a		 dec	 edx
  0000b	85 d2		 test	 edx, edx
  0000d	7f 0a		 jg	 SHORT $L39885

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b c8		 mov	 ecx, eax
  00016	ff 52 04	 call	 DWORD PTR [edx+4]
$L39885:

; 98   : 		}
; 99   : 	}

  00019	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	?Width@CRect@@QBEHXZ				; CRect::Width
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltypes.inl
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT
?Width@CRect@@QBEHXZ PROC NEAR				; CRect::Width, COMDAT
; _this$ = ecx

; 123  : 	{ return right - left; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c3		 ret	 0
?Width@CRect@@QBEHXZ ENDP				; CRect::Width
_TEXT	ENDS
PUBLIC	?Height@CRect@@QBEHXZ				; CRect::Height
; Function compile flags: /Ogty
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT
?Height@CRect@@QBEHXZ PROC NEAR				; CRect::Height, COMDAT
; _this$ = ecx

; 125  : 	{ return bottom - top; }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c3		 ret	 0
?Height@CRect@@QBEHXZ ENDP				; CRect::Height
_TEXT	ENDS
PUBLIC	?abs@@YAJJ@Z					; abs
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?abs@@YAJJ@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?abs@@YAJJ@Z PROC NEAR					; abs, COMDAT

; 529  :         {return (labs(_X)); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __X$[esp-4]
  00004	99		 cdq
  00005	33 c2		 xor	 eax, edx
  00007	2b c2		 sub	 eax, edx
  00009	c3		 ret	 0
?abs@@YAJJ@Z ENDP					; abs
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
; Function compile flags: /Ogty
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC NEAR				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 313  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
EXTRN	__fltused:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 300  :     x = fx;
; 301  :     y = fy;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _fy$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _fx$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 302  :     z = fz;

  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _fz$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 303  : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
; Function compile flags: /Ogty
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 377  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _v$[esp-4]
  00004	d9 40 08	 fld	 DWORD PTR [eax+8]
  00007	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  0000a	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000d	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00010	d9 00		 fld	 DWORD PTR [eax]
  00012	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00016	d8 01		 fadd	 DWORD PTR [ecx]
  00018	d9 18		 fstp	 DWORD PTR [eax]
  0001a	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0001d	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 378  : }

  00020	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
; Function compile flags: /Ogty
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC NEAR		; operator*, COMDAT

; 403  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _v$[esp-4]
  00004	d9 44 24 08	 fld	 DWORD PTR _f$[esp-4]
  00008	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0000b	d9 44 24 08	 fld	 DWORD PTR _f$[esp-4]
  0000f	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00012	d9 44 24 08	 fld	 DWORD PTR _f$[esp-4]
  00016	d8 08		 fmul	 DWORD PTR [eax]
  00018	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0001c	d9 18		 fstp	 DWORD PTR [eax]
  0001e	d9 58 04	 fstp	 DWORD PTR [eax+4]
  00021	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 404  : }

  00024	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
PUBLIC	??0CFileIO@@QAE@XZ				; CFileIO::CFileIO
PUBLIC	?Flush@CFileIO@@UAEHXZ				; CFileIO::Flush
PUBLIC	?GetC@CFileIO@@UAEDXZ				; CFileIO::GetC
PUBLIC	?GetW@CFileIO@@UAEGXZ				; CFileIO::GetW
PUBLIC	?GetDW@CFileIO@@UAEKXZ				; CFileIO::GetDW
PUBLIC	?Tell@CFileIO@@UAEJXZ				; CFileIO::Tell
PUBLIC	?Seek@CFileIO@@UAEHJH@Z				; CFileIO::Seek
PUBLIC	?GetLength@CFileIO@@UAEJXZ			; CFileIO::GetLength
PUBLIC	?Read@CFileIO@@UAEIPAXII@Z			; CFileIO::Read
PUBLIC	??_7CFileIO@@6B@				; CFileIO::`vftable'
PUBLIC	??_GCFileIO@@UAEPAXI@Z				; CFileIO::`scalar deleting destructor'
EXTRN	?Open@CFileIO@@UAEHPBDPAD@Z:NEAR		; CFileIO::Open
EXTRN	?Close@CFileIO@@UAEHXZ:NEAR			; CFileIO::Close
EXTRN	?Read@CFileIO@@UAEPAXXZ:NEAR			; CFileIO::Read
EXTRN	??_ECFileIO@@UAEPAXI@Z:NEAR			; CFileIO::`vector deleting destructor'
;	COMDAT ??_7CFileIO@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\file.h
CONST	SEGMENT
??_7CFileIO@@6B@ DD FLAT:??_ECFileIO@@UAEPAXI@Z		; CFileIO::`vftable'
	DD	FLAT:?Open@CFileIO@@UAEHPBDPAD@Z
	DD	FLAT:?Close@CFileIO@@UAEHXZ
	DD	FLAT:?Flush@CFileIO@@UAEHXZ
	DD	FLAT:?GetC@CFileIO@@UAEDXZ
	DD	FLAT:?GetW@CFileIO@@UAEGXZ
	DD	FLAT:?GetDW@CFileIO@@UAEKXZ
	DD	FLAT:?Tell@CFileIO@@UAEJXZ
	DD	FLAT:?Seek@CFileIO@@UAEHJH@Z
	DD	FLAT:?GetLength@CFileIO@@UAEJXZ
	DD	FLAT:?Read@CFileIO@@UAEPAXXZ
	DD	FLAT:?Read@CFileIO@@UAEIPAXII@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CFileIO@@QAE@XZ
_TEXT	SEGMENT
??0CFileIO@@QAE@XZ PROC NEAR				; CFileIO::CFileIO, COMDAT
; _this$ = ecx

; 15   : 	CFileIO() { fp = NULL; } 

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFileIO@@6B@
  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0000f	c3		 ret	 0
??0CFileIO@@QAE@XZ ENDP					; CFileIO::CFileIO
_TEXT	ENDS
PUBLIC	??1CFileIO@@UAE@XZ				; CFileIO::~CFileIO
; Function compile flags: /Ogty
;	COMDAT ??1CFileIO@@UAE@XZ
_TEXT	SEGMENT
??1CFileIO@@UAE@XZ PROC NEAR				; CFileIO::~CFileIO, COMDAT
; _this$ = ecx

; 17   : 	virtual ~CFileIO() { Close(); }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CFileIO@@6B@
  00006	e9 00 00 00 00	 jmp	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
??1CFileIO@@UAE@XZ ENDP					; CFileIO::~CFileIO
_TEXT	ENDS
EXTRN	_fflush:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Flush@CFileIO@@UAEHXZ
_TEXT	SEGMENT
?Flush@CFileIO@@UAEHXZ PROC NEAR			; CFileIO::Flush, COMDAT
; _this$ = ecx

; 20   : 	virtual int	 Flush()  { return fflush( fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fflush
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?Flush@CFileIO@@UAEHXZ ENDP				; CFileIO::Flush
_TEXT	ENDS
EXTRN	_getc:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetC@CFileIO@@UAEDXZ
_TEXT	SEGMENT
?GetC@CFileIO@@UAEDXZ PROC NEAR				; CFileIO::GetC, COMDAT
; _this$ = ecx

; 21   : 	virtual char  GetC()  { return (char)getc( fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _getc
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?GetC@CFileIO@@UAEDXZ ENDP				; CFileIO::GetC
_TEXT	ENDS
EXTRN	_fgetwc:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetW@CFileIO@@UAEGXZ
_TEXT	SEGMENT
?GetW@CFileIO@@UAEGXZ PROC NEAR				; CFileIO::GetW, COMDAT
; _this$ = ecx

; 22   : 	virtual WORD  GetW()  { return getwc( fp ); } 

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fgetwc
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?GetW@CFileIO@@UAEGXZ ENDP				; CFileIO::GetW
_TEXT	ENDS
EXTRN	_fread:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetDW@CFileIO@@UAEKXZ
_TEXT	SEGMENT
_dw$ = -4						; size = 4
?GetDW@CFileIO@@UAEKXZ PROC NEAR			; CFileIO::GetDW, COMDAT
; _this$ = ecx

; 23   : 	virtual DWORD GetDW() { DWORD dw; fread( &dw, sizeof( dw ), 1, fp ); return dw; }

  00000	51		 push	 ecx
  00001	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00004	50		 push	 eax
  00005	6a 01		 push	 1
  00007	8d 4c 24 08	 lea	 ecx, DWORD PTR _dw$[esp+12]
  0000b	6a 04		 push	 4
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _fread
  00013	8b 44 24 10	 mov	 eax, DWORD PTR _dw$[esp+20]
  00017	83 c4 14	 add	 esp, 20			; 00000014H
  0001a	c3		 ret	 0
?GetDW@CFileIO@@UAEKXZ ENDP				; CFileIO::GetDW
_TEXT	ENDS
EXTRN	_ftell:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Tell@CFileIO@@UAEJXZ
_TEXT	SEGMENT
?Tell@CFileIO@@UAEJXZ PROC NEAR				; CFileIO::Tell, COMDAT
; _this$ = ecx

; 24   : 	virtual long Tell()   { return ftell(fp); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _ftell
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?Tell@CFileIO@@UAEJXZ ENDP				; CFileIO::Tell
_TEXT	ENDS
EXTRN	_fseek:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Seek@CFileIO@@UAEHJH@Z
_TEXT	SEGMENT
_offset$ = 8						; size = 4
_whence$ = 12						; size = 4
?Seek@CFileIO@@UAEHJH@Z PROC NEAR			; CFileIO::Seek, COMDAT
; _this$ = ecx

; 25   : 	virtual int  Seek( long offset, int whence ) { return fseek( fp, offset, whence ); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _whence$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _offset$[esp-4]
  00008	50		 push	 eax
  00009	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000c	52		 push	 edx
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _fseek
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c2 08 00	 ret	 8
?Seek@CFileIO@@UAEHJH@Z ENDP				; CFileIO::Seek
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Read@CFileIO@@UAEIPAXII@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_n$ = 16						; size = 4
?Read@CFileIO@@UAEIPAXII@Z PROC NEAR			; CFileIO::Read, COMDAT
; _this$ = ecx

; 27   : 	virtual size_t Read( void *ptr, size_t size, size_t n = 1 )	{ return fread( ptr, size, n, fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 0c	 mov	 ecx, DWORD PTR _n$[esp-4]
  00007	8b 54 24 08	 mov	 edx, DWORD PTR _size$[esp-4]
  0000b	50		 push	 eax
  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _ptr$[esp]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _fread
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?Read@CFileIO@@UAEIPAXII@Z ENDP				; CFileIO::Read
_TEXT	ENDS
PUBLIC	?Handle@CFileIO@@QAEHXZ				; CFileIO::Handle
EXTRN	_fileno:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Handle@CFileIO@@QAEHXZ
_TEXT	SEGMENT
?Handle@CFileIO@@QAEHXZ PROC NEAR			; CFileIO::Handle, COMDAT
; _this$ = ecx

; 30   : 	int  Handle() { return fileno( fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fileno
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?Handle@CFileIO@@QAEHXZ ENDP				; CFileIO::Handle
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCFileIO@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFileIO@@UAEPAXI@Z PROC NEAR			; CFileIO::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CFileIO@@6B@
  00009	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
  0000e	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00013	74 09		 je	 SHORT $L227488
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	83 c4 04	 add	 esp, 4
$L227488:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	c2 04 00	 ret	 4
??_GCFileIO@@UAEPAXI@Z ENDP				; CFileIO::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?isdigit2@@YAHD@Z				; isdigit2
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.h
;	COMDAT ?isdigit2@@YAHD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?isdigit2@@YAHD@Z PROC NEAR				; isdigit2, COMDAT

; 105  : 	if( c >= '0' && c <= '9' )

  00000	8a 44 24 04	 mov	 al, BYTE PTR _c$[esp-4]
  00004	3c 30		 cmp	 al, 48			; 00000030H
  00006	7c 0a		 jl	 SHORT $L167218
  00008	3c 39		 cmp	 al, 57			; 00000039H
  0000a	7f 06		 jg	 SHORT $L167218

; 106  : 		return TRUE;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 109  : }

  00011	c3		 ret	 0
$L167218:

; 107  : 	else
; 108  : 		return FALSE;

  00012	33 c0		 xor	 eax, eax

; 109  : }

  00014	c3		 ret	 0
?isdigit2@@YAHD@Z ENDP					; isdigit2
_TEXT	ENDS
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 510  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 511  : 	}

  00002	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
; Function compile flags: /Ogty
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  00005	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Ogty
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L219986
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L219986

; 794  : 			AtlThrow(E_INVALIDARG);
; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 797  : 		m_pszData[nLength] = 0;

  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 798  : 	}

  00018	c2 04 00	 ret	 4
$L219986:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L227508:
$L227507:
  00025	cc		 int	 3
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Ogty
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pData$[esp-4]
  00004	83 c0 10	 add	 eax, 16			; 00000010H
  00007	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00009	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Ogty
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nChars$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp]
  00009	8b c1		 mov	 eax, ecx
  0000b	57		 push	 edi
  0000c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pchDest$[esp+4]
  00010	c1 e9 02	 shr	 ecx, 2
  00013	f3 a5		 rep movsd
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	f3 a4		 rep movsb
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 654  : 	}

  0001e	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	e9 00 00 00 00	 jmp	 _memmove
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Ogty
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00000	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00005	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L227525:
$L227524:
  0000a	cc		 int	 3
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Ogty
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv181 = 8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 716  : 		CStringData* pOldData = GetData();

  00002	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00004	83 eb 10	 sub	 ebx, 16			; 00000010H
  00007	55		 push	 ebp

; 717  : 		int nOldLength = pOldData->nDataLength;

  00008	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$[esp+12], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0000f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 10	 call	 DWORD PTR [eax+16]
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _nLength$[esp+12]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	6a 01		 push	 1
  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	ff 12		 call	 DWORD PTR [edx]

; 719  : 		if( pNewData == NULL )

  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $L222762

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00028	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L227556:
$L222762:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0002d	3b ee		 cmp	 ebp, esi
  0002f	7d 02		 jge	 SHORT $L227530
  00031	8b f5		 mov	 esi, ebp
$L227530:
  00033	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  00036	8b d1		 mov	 edx, ecx
  00038	57		 push	 edi
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	89 7c 24 18	 mov	 DWORD PTR tv181[esp+16], edi
  00043	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00046	f3 a5		 rep movsd
  00048	8b ca		 mov	 ecx, edx
  0004a	83 e1 03	 and	 ecx, 3
  0004d	f3 a4		 rep movsb

; 725  : 		pNewData->nDataLength = nOldLength;

  0004f	89 68 04	 mov	 DWORD PTR [eax+4], ebp

; 726  : 		pOldData->Release();

  00052	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00055	83 c9 ff	 or	 ecx, -1
  00058	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0005c	49		 dec	 ecx
  0005d	85 c9		 test	 ecx, ecx
  0005f	5f		 pop	 edi
  00060	7f 08		 jg	 SHORT $L227546
  00062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	53		 push	 ebx
  00067	ff 52 04	 call	 DWORD PTR [edx+4]
$L227546:

; 727  : 		Attach( pNewData );

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR tv181[esp+12]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	5b		 pop	 ebx

; 728  : 	}

  00077	59		 pop	 ecx
  00078	c2 04 00	 ret	 4
$L227555:
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Ogty
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 777  : 		CStringData* pOldData = GetData();
; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nLength$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	83 e8 10	 sub	 eax, 16			; 00000010H
  00012	6a 01		 push	 1
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	ff 52 08	 call	 DWORD PTR [edx+8]

; 781  : 		if( pNewData == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L222771

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0001d	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L227572:
$L222771:

; 784  : 		}
; 785  : 		Attach( pNewData );

  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	5f		 pop	 edi
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	5e		 pop	 esi

; 786  : 	}

  00029	c2 04 00	 ret	 4
$L227571:
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?IsNative@@YAHPBD@Z				; IsNative
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
;	COMDAT ?IsNative@@YAHPBD@Z
_TEXT	SEGMENT
_lpszStr$ = 8						; size = 4
?IsNative@@YAHPBD@Z PROC NEAR				; IsNative, COMDAT

; 70   : 	ASSERT( g_codePage != 0 );
; 71   : 
; 72   : 	LPCWSTR pwSrc = (LPCWSTR) lpszStr;
; 73   : 
; 74   : 	if( g_codePage == 874 ) //  

  00000	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g_codePage@@3GA ; g_codePage
  00006	66 3d 6a 03	 cmp	 ax, 874			; 0000036aH
  0000a	75 15		 jne	 SHORT $L225634

; 75   : 	{
; 76   : 		return (BYTE)*lpszStr >= 0xa1 && (BYTE)*lpszStr <= 0xfb;

  0000c	8b 44 24 04	 mov	 eax, DWORD PTR _lpszStr$[esp-4]
  00010	8a 00		 mov	 al, BYTE PTR [eax]
  00012	3c a1		 cmp	 al, 161			; 000000a1H
  00014	72 08		 jb	 SHORT $L225662
  00016	3c fb		 cmp	 al, 251			; 000000fbH
  00018	0f 86 90 00 00
	00		 jbe	 $L227578
$L225662:

; 112  : 		
; 113  : 	}
; 114  : 	return FALSE;

  0001e	33 c0		 xor	 eax, eax

; 115  : }

  00020	c3		 ret	 0
$L225634:

; 77   : 	}
; 78   : 	else
; 79   : 	if( g_codePage == 949 ) //  

  00021	66 3d b5 03	 cmp	 ax, 949			; 000003b5H
  00025	75 12		 jne	 SHORT $L225638

; 80   : 	{
; 81   : 		return IsHangul( *pwSrc );

  00027	8b 4c 24 04	 mov	 ecx, DWORD PTR _lpszStr$[esp-4]
  0002b	33 d2		 xor	 edx, edx
  0002d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00030	89 54 24 04	 mov	 DWORD PTR _lpszStr$[esp-4], edx
  00034	e9 00 00 00 00	 jmp	 ?IsHangul@@YAHG@Z	; IsHangul
$L225638:

; 82   : 	}
; 83   : 	else
; 84   : 	if( g_codePage == 932 ) //  

  00039	66 3d a4 03	 cmp	 ax, 932			; 000003a4H
  0003d	75 10		 jne	 SHORT $L225640

; 85   : 	{
; 86   : 		return IsDBCSLeadByte( (BYTE)( *pwSrc ) );

  0003f	8b 44 24 04	 mov	 eax, DWORD PTR _lpszStr$[esp-4]
  00043	33 c9		 xor	 ecx, ecx
  00045	8a 08		 mov	 cl, BYTE PTR [eax]
  00047	51		 push	 ecx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4

; 115  : }

  0004e	c3		 ret	 0
$L225640:

; 87   : 	}
; 88   : 	else
; 89   : 	if( g_codePage == 936 ) //  : 

  0004f	66 3d a8 03	 cmp	 ax, 936			; 000003a8H
  00053	75 10		 jne	 SHORT $L225643

; 90   : 	{
; 91   : 		return IsDBCSLeadByte( (BYTE)( *pwSrc ) );

  00055	8b 54 24 04	 mov	 edx, DWORD PTR _lpszStr$[esp-4]
  00059	33 c0		 xor	 eax, eax
  0005b	8a 02		 mov	 al, BYTE PTR [edx]
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDBCSLeadByte@4

; 115  : }

  00064	c3		 ret	 0
$L225643:

; 92   : 	}
; 93   : 	else
; 94   : 	if( g_codePage == 950 ) //  :  

  00065	66 3d b6 03	 cmp	 ax, 950			; 000003b6H
  00069	75 b3		 jne	 SHORT $L225662

; 95   : 	{
; 96   : //		return IsDBCSLeadByte( *pwSrc );
; 97   : 
; 98   : 		if( ((BYTE)*lpszStr >= 0xCA && (BYTE)*lpszStr <= 0xFD) && ( (BYTE)*lpszStr+1 >= 0xA1 ) && ( (BYTE)*lpszStr+1 <= 0xFE) )

  0006b	8b 4c 24 04	 mov	 ecx, DWORD PTR _lpszStr$[esp-4]
  0006f	8a 01		 mov	 al, BYTE PTR [ecx]
  00071	3c ca		 cmp	 al, 202			; 000000caH
  00073	72 18		 jb	 SHORT $L225651
  00075	3c fd		 cmp	 al, 253			; 000000fdH
  00077	77 14		 ja	 SHORT $L225651
  00079	0f b6 c8	 movzx	 ecx, al
  0007c	41		 inc	 ecx
  0007d	81 f9 a1 00 00
	00		 cmp	 ecx, 161		; 000000a1H
  00083	7c 08		 jl	 SHORT $L225651
  00085	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH

; 99   : 		{
; 100  : 			return TRUE;

  0008b	7e 21		 jle	 SHORT $L227578
$L225651:

; 101  : 		}
; 102  : 		else
; 103  : 		if ( ( ( (BYTE)*lpszStr >= 0x41 ) && 
; 104  : 		 	 ( (BYTE)*lpszStr <= 0x5A ) ) || 
; 105  : 		   	( ( (BYTE)*lpszStr >= 0x61 ) && ( (BYTE)*lpszStr <= 0x7A) ) ) 	

  0008d	3c 41		 cmp	 al, 65			; 00000041H
  0008f	72 04		 jb	 SHORT $L225659
  00091	3c 5a		 cmp	 al, 90			; 0000005aH
  00093	76 19		 jbe	 SHORT $L227578
$L225659:
  00095	3c 61		 cmp	 al, 97			; 00000061H
  00097	72 04		 jb	 SHORT $L225657
  00099	3c 7a		 cmp	 al, 122			; 0000007aH

; 106  : 		{ 
; 107  : 			return TRUE;			

  0009b	76 11		 jbe	 SHORT $L227578
$L225657:

; 108  : 		} 
; 109  : 		else
; 110  : 		if( isdigit2( (BYTE)*lpszStr ) )

  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ?isdigit2@@YAHD@Z	; isdigit2
  000a3	83 c4 04	 add	 esp, 4
  000a6	85 c0		 test	 eax, eax
  000a8	0f 84 70 ff ff
	ff		 je	 $L225662
$L227578:

; 111  : 			return TRUE;

  000ae	b8 01 00 00 00	 mov	 eax, 1

; 115  : }

  000b3	c3		 ret	 0
?IsNative@@YAHPBD@Z ENDP				; IsNative
_TEXT	ENDS
PUBLIC	?LoadBMP@@YAHPBDPAUIMAGE@@@Z			; LoadBMP
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BE@MHDFBJEH@LoadBMP?5Failed?5?$DN?5?$CFs?$AA@ ; `string'
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\file.h
xdata$x	SEGMENT
$T227623 DD	0ffffffffH
	DD	FLAT:$L227592
$T227614 DD	019930520H
	DD	01H
	DD	FLAT:$T227623
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHDFBJEH@LoadBMP?5Failed?5?$DN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@MHDFBJEH@LoadBMP?5Failed?5?$DN?5?$CFs?$AA@ DB 'LoadBMP Failed ='
	DB	' %s', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
CONST	ENDS
;	COMDAT ?LoadBMP@@YAHPBDPAUIMAGE@@@Z
_TEXT	SEGMENT
_lpData$ = -76						; size = 4
tv237 = -72						; size = 4
_lpNewData$ = -68					; size = 4
_lpDataDelete$ = -64					; size = 4
_file$ = -60						; size = 8
_infoHeader$ = -52					; size = 40
__$EHRec$ = -12						; size = 12
_lpszFileName$ = 8					; size = 4
_lpImage$ = 12						; size = 4
?LoadBMP@@YAHPBDPAUIMAGE@@@Z PROC NEAR			; LoadBMP, COMDAT

; 447  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?LoadBMP@@YAHPBDPAUIMAGE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 40	 sub	 esp, 64			; 00000040H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 448  : 	CResFile file;

  0001b	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_7CFileIO@@6B@
  00020	33 db		 xor	 ebx, ebx
  00022	89 7c 24 1c	 mov	 DWORD PTR _file$[esp+88], edi
  00026	89 5c 24 20	 mov	 DWORD PTR _file$[esp+92], ebx

; 449  : 	if( file.Open( lpszFileName, "rb" ) == FALSE )

  0002a	8b 74 24 5c	 mov	 esi, DWORD PTR _lpszFileName$[esp+84]
  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  00033	56		 push	 esi
  00034	8d 4c 24 24	 lea	 ecx, DWORD PTR _file$[esp+96]
  00038	89 5c 24 5c	 mov	 DWORD PTR __$EHRec$[esp+104], ebx
  0003c	e8 00 00 00 00	 call	 ?Open@CFileIO@@UAEHPBDPAD@Z ; CFileIO::Open
  00041	85 c0		 test	 eax, eax
  00043	75 37		 jne	 SHORT $L225890

; 450  : 	{
; 451  : 		Error( "LoadBMP Failed = %s", lpszFileName );

  00045	56		 push	 esi
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@MHDFBJEH@LoadBMP?5Failed?5?$DN?5?$CFs?$AA@
  0004b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00050	83 c4 08	 add	 esp, 8

; 452  : 		return FALSE;

  00053	8d 4c 24 1c	 lea	 ecx, DWORD PTR _file$[esp+88]
  00057	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+96], -1
  0005f	89 7c 24 1c	 mov	 DWORD PTR _file$[esp+88], edi
  00063	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	33 c0		 xor	 eax, eax
  0006c	5b		 pop	 ebx

; 520  : }

  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR __$EHRec$[esp+76]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00078	83 c4 4c	 add	 esp, 76			; 0000004cH
  0007b	c3		 ret	 0
$L225890:
  0007c	55		 push	 ebp

; 453  : 	}
; 454  : 
; 455  : 	BITMAPINFOHEADER infoHeader;
; 456  : 	LPBYTE lpData = (LPBYTE)file.Read();

  0007d	8d 4c 24 20	 lea	 ecx, DWORD PTR _file$[esp+92]
  00081	e8 00 00 00 00	 call	 ?Read@CFileIO@@UAEPAXXZ	; CFileIO::Read

; 457  : 	LPBYTE lpDataDelete = lpData;

  00086	8b d0		 mov	 edx, eax

; 458  : 	lpData += sizeof( BITMAPFILEHEADER );

  00088	83 c0 0e	 add	 eax, 14			; 0000000eH

; 459  : 	memcpy( &infoHeader, lpData, sizeof( BITMAPINFOHEADER ) );

  0008b	8b f0		 mov	 esi, eax
  0008d	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00092	8d 7c 24 28	 lea	 edi, DWORD PTR _infoHeader$[esp+92]
  00096	f3 a5		 rep movsd

; 460  : 	lpData += sizeof( BITMAPINFOHEADER );
; 461  : 
; 462  : 	int bitCount = 1;
; 463  : 	if( infoHeader.biBitCount < 8)

  00098	66 8b 4c 24 36	 mov	 cx, WORD PTR _infoHeader$[esp+106]
  0009d	83 c0 28	 add	 eax, 40			; 00000028H
  000a0	66 83 f9 08	 cmp	 cx, 8
  000a4	89 54 24 1c	 mov	 DWORD PTR _lpDataDelete$[esp+92], edx
  000a8	89 44 24 10	 mov	 DWORD PTR _lpData$[esp+92], eax
  000ac	bd 01 00 00 00	 mov	 ebp, 1
  000b1	73 4a		 jae	 SHORT $L227621
$L227622:

; 464  : 	{
; 465  : 		lpImage->size.cx = 0;

  000b3	8b 44 24 64	 mov	 eax, DWORD PTR _lpImage$[esp+88]

; 466  : 		lpImage->size.cy = 0;
; 467  : 		lpImage->lpData = NULL;
; 468  : 		lpImage->nImgBit = IMGBIT_24;
; 469  : 		safe_delete_array( lpDataDelete );

  000b7	52		 push	 edx
  000b8	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  000bb	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  000be	89 18		 mov	 DWORD PTR [eax], ebx
  000c0	c7 40 0c 02 00
	00 00		 mov	 DWORD PTR [eax+12], 2
  000c7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000cc	83 c4 04	 add	 esp, 4

; 470  : 		return FALSE;

  000cf	8d 4c 24 20	 lea	 ecx, DWORD PTR _file$[esp+92]
  000d3	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+100], -1
  000db	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _file$[esp+92], OFFSET FLAT:??_7CFileIO@@6B@
  000e3	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
  000e8	5d		 pop	 ebp
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	33 c0		 xor	 eax, eax
  000ed	5b		 pop	 ebx

; 520  : }

  000ee	8b 4c 24 40	 mov	 ecx, DWORD PTR __$EHRec$[esp+76]
  000f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f9	83 c4 4c	 add	 esp, 76			; 0000004cH
  000fc	c3		 ret	 0
$L227621:

; 471  : 	}
; 472  : 	if( infoHeader.biBitCount > 8)

  000fd	76 06		 jbe	 SHORT $L225905

; 473  : 	{
; 474  : 		bitCount = infoHeader.biBitCount / 8;

  000ff	0f b7 e9	 movzx	 ebp, cx
  00102	c1 ed 03	 shr	 ebp, 3
$L225905:

; 475  : 	}
; 476  : 	if( infoHeader.biCompression)

  00105	39 5c 24 38	 cmp	 DWORD PTR _infoHeader$[esp+108], ebx

; 477  : 	{
; 478  : 		lpImage->size.cx = 0;
; 479  : 		lpImage->size.cy = 0;
; 480  : 		lpImage->lpData = NULL;
; 481  : 		lpImage->nImgBit = IMGBIT_24;
; 482  : 		safe_delete_array( lpDataDelete );
; 483  : 		return FALSE;

  00109	75 a8		 jne	 SHORT $L227622

; 484  : 	}
; 485  : 	int nLgHeight = infoHeader.biHeight;
; 486  : 	int nLgWidth  = infoHeader.biWidth;
; 487  : 
; 488  : 	lpImage->size.cx = nLgWidth;
; 489  : 	lpImage->size.cy = nLgHeight;
; 490  : 
; 491  : 	if( bitCount == 1 ) 

  0010b	83 fd 01	 cmp	 ebp, 1
  0010e	8b 7c 24 64	 mov	 edi, DWORD PTR _lpImage$[esp+88]
  00112	8b 5c 24 2c	 mov	 ebx, DWORD PTR _infoHeader$[esp+96]
  00116	8b 4c 24 30	 mov	 ecx, DWORD PTR _infoHeader$[esp+100]
  0011a	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0011d	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00120	75 14		 jne	 SHORT $L225912

; 492  : 	{
; 493  : 		if( infoHeader.biClrUsed == 0 )

  00122	8b 54 24 48	 mov	 edx, DWORD PTR _infoHeader$[esp+124]
  00126	85 d2		 test	 edx, edx
  00128	75 05		 jne	 SHORT $L225913

; 494  : 			infoHeader.biClrUsed = 256;

  0012a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$L225913:

; 495  : 		lpData += infoHeader.biClrUsed * 4;

  0012f	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00132	89 44 24 10	 mov	 DWORD PTR _lpData$[esp+92], eax
$L225912:

; 496  : 	}
; 497  : 
; 498  : 	LPBYTE lpNewData = new BYTE[ nLgWidth * nLgHeight * bitCount * 2 ]; //   2 .  4     * 2  

  00136	8b f3		 mov	 esi, ebx
  00138	0f af f1	 imul	 esi, ecx
  0013b	0f af f5	 imul	 esi, ebp
  0013e	d1 e6		 shl	 esi, 1
  00140	56		 push	 esi
  00141	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 499  : 	lpImage->dwSizeBak	= lpImage->dwSize = nLgWidth * nLgHeight * bitCount * 2;
; 500  : 
; 501  : 	int nPgHeight = abs( infoHeader.biHeight );
; 502  : 	int nPgWidth  = infoHeader.biWidth;
; 503  : 
; 504  : 	nPgWidth *= bitCount;

  00146	0f af dd	 imul	 ebx, ebp
  00149	89 44 24 1c	 mov	 DWORD PTR _lpNewData$[esp+96], eax
  0014d	8b 44 24 34	 mov	 eax, DWORD PTR _infoHeader$[esp+104]
  00151	99		 cdq
  00152	33 c2		 xor	 eax, edx

; 505  : 	nLgWidth *= bitCount;

  00154	8b eb		 mov	 ebp, ebx

; 506  : 	nLgWidth += ( ( nLgWidth % 4 ) ? ( 4 - nLgWidth % 4 ) : 0 );

  00156	8b cd		 mov	 ecx, ebp
  00158	83 c4 04	 add	 esp, 4
  0015b	2b c2		 sub	 eax, edx
  0015d	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00163	89 77 10	 mov	 DWORD PTR [edi+16], esi
  00166	89 77 14	 mov	 DWORD PTR [edi+20], esi
  00169	79 05		 jns	 SHORT $L227620
  0016b	49		 dec	 ecx
  0016c	83 c9 fc	 or	 ecx, -4			; fffffffcH
  0016f	41		 inc	 ecx
$L227620:
  00170	74 09		 je	 SHORT $L227588
  00172	ba 04 00 00 00	 mov	 edx, 4
  00177	2b d1		 sub	 edx, ecx
  00179	eb 02		 jmp	 SHORT $L227589
$L227588:
  0017b	33 d2		 xor	 edx, edx
$L227589:

; 507  : 
; 508  : 	LPBYTE pTempDst = lpNewData + ( nPgWidth * ( nPgHeight - 1 ) );

  0017d	8b 74 24 18	 mov	 esi, DWORD PTR _lpNewData$[esp+92]
  00181	03 ea		 add	 ebp, edx
  00183	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00186	0f af d3	 imul	 edx, ebx
  00189	03 d6		 add	 edx, esi

; 509  : 
; 510  : 	for( int i = 0; i < nPgHeight; i++ )

  0018b	85 c0		 test	 eax, eax
  0018d	7e 35		 jle	 SHORT $L225923

; 506  : 	nLgWidth += ( ( nLgWidth % 4 ) ? ( 4 - nLgWidth % 4 ) : 0 );

  0018f	89 44 24 14	 mov	 DWORD PTR tv237[esp+92], eax
$L225921:

; 511  : 	{
; 512  : 		memcpy( pTempDst, lpData, nLgWidth );

  00193	8b 74 24 10	 mov	 esi, DWORD PTR _lpData$[esp+92]
  00197	8b cd		 mov	 ecx, ebp
  00199	8b c1		 mov	 eax, ecx
  0019b	c1 e9 02	 shr	 ecx, 2
  0019e	8b fa		 mov	 edi, edx
  001a0	f3 a5		 rep movsd
  001a2	8b c8		 mov	 ecx, eax
  001a4	8b 44 24 14	 mov	 eax, DWORD PTR tv237[esp+92]
  001a8	83 e1 03	 and	 ecx, 3
  001ab	f3 a4		 rep movsb

; 513  : 		lpData += nLgWidth;

  001ad	8b 74 24 10	 mov	 esi, DWORD PTR _lpData$[esp+92]
  001b1	03 f5		 add	 esi, ebp

; 514  : 		pTempDst -= nPgWidth;

  001b3	2b d3		 sub	 edx, ebx
  001b5	48		 dec	 eax
  001b6	89 74 24 10	 mov	 DWORD PTR _lpData$[esp+92], esi
  001ba	89 44 24 14	 mov	 DWORD PTR tv237[esp+92], eax
  001be	75 d3		 jne	 SHORT $L225921

; 509  : 
; 510  : 	for( int i = 0; i < nPgHeight; i++ )

  001c0	8b 7c 24 64	 mov	 edi, DWORD PTR _lpImage$[esp+88]
$L225923:

; 515  : 	}
; 516  : 	safe_delete_array( lpDataDelete );

  001c4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _lpDataDelete$[esp+92]
  001c8	51		 push	 ecx
  001c9	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 517  : 	lpImage->lpData = lpNewData;

  001ce	8b 54 24 1c	 mov	 edx, DWORD PTR _lpNewData$[esp+96]
  001d2	83 c4 04	 add	 esp, 4

; 518  : 	lpImage->nImgBit = IMGBIT_24;
; 519  : 	return TRUE;

  001d5	8d 4c 24 20	 lea	 ecx, DWORD PTR _file$[esp+92]
  001d9	89 17		 mov	 DWORD PTR [edi], edx
  001db	c7 47 0c 02 00
	00 00		 mov	 DWORD PTR [edi+12], 2
  001e2	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+100], -1
  001ea	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _file$[esp+92], OFFSET FLAT:??_7CFileIO@@6B@
  001f2	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close

; 520  : }

  001f7	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  001fb	5d		 pop	 ebp
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	b8 01 00 00 00	 mov	 eax, 1
  00203	5b		 pop	 ebx
  00204	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020b	83 c4 4c	 add	 esp, 76			; 0000004cH
  0020e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L227592:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileIO@@UAE@XZ	; CFileIO::~CFileIO
__ehhandler$?LoadBMP@@YAHPBDPAUIMAGE@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T227614
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadBMP@@YAHPBDPAUIMAGE@@@Z ENDP			; LoadBMP
PUBLIC	?SaveBMP@@YAHPBDPAEUtagSIZE@@@Z			; SaveBMP
EXTRN	??0CFile@@QAE@XZ:NEAR				; CFile::CFile
EXTRN	?Open@CFile@@UAEHPBDIPAVCFileException@@@Z:NEAR	; CFile::Open
EXTRN	?Write@CFile@@UAEXPBXI@Z:NEAR			; CFile::Write
EXTRN	??1CFile@@UAE@XZ:NEAR				; CFile::~CFile
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
xdata$x	SEGMENT
$T227661 DD	0ffffffffH
	DD	FLAT:$L227635
$T227655 DD	019930520H
	DD	01H
	DD	FLAT:$T227661
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
xdata$x	ENDS
;	COMDAT ?SaveBMP@@YAHPBDPAEUtagSIZE@@@Z
_TEXT	SEGMENT
_BMPheader$ = -84					; size = 14
_file$ = -68						; size = 16
_header$ = -52						; size = 40
__$EHRec$ = -12						; size = 12
_lpszFileName$ = 8					; size = 4
tv93 = 12						; size = 4
_lpData$ = 12						; size = 4
_pBMP$ = 16						; size = 4
_size$ = 16						; size = 8
?SaveBMP@@YAHPBDPAEUtagSIZE@@@Z PROC NEAR		; SaveBMP, COMDAT

; 523  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?SaveBMP@@YAHPBDPAEUtagSIZE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 48	 sub	 esp, 72			; 00000048H

; 524  : 	int i, j;
; 525  : 	BITMAPFILEHEADER BMPheader;
; 526  : 	BITMAPINFOHEADER header = { 40,640,-480,1,24,0,0,5904,5904,0,0 };

  00018	b8 10 17 00 00	 mov	 eax, 5904		; 00001710H
  0001d	89 44 24 38	 mov	 DWORD PTR _header$[esp+108], eax
  00021	89 44 24 3c	 mov	 DWORD PTR _header$[esp+112], eax

; 527  : 	header.biBitCount = 24;
; 528  : 	header.biWidth  = size.cx;
; 529  : 	header.biHeight = -abs(size.cy);

  00025	8b 44 24 64	 mov	 eax, DWORD PTR _size$[esp+84]
  00029	99		 cdq
  0002a	33 c2		 xor	 eax, edx
  0002c	2b c2		 sub	 eax, edx
  0002e	f7 d8		 neg	 eax

; 530  : 
; 531  : 	LPBYTE pBMP = NULL;
; 532  : 	LPBYTE pp;
; 533  : 
; 534  : 	LPBYTE pSurface = (LPBYTE) lpData;
; 535  : 
; 536  : 	int nBit = 24 >> 3;//m_infoHeader.biBitCount >> 3;
; 537  : 
; 538  : 	BMPheader.bfType = 'M';
; 539  : 	BMPheader.bfType <<= 8;
; 540  : 	BMPheader.bfType += 'B';
; 541  : 	BMPheader.bfReserved1 = 0; 
; 542  : 	BMPheader.bfReserved2 = 0;
; 543  : 	// 16(nBit==2)        .     
; 544  : 	if(nBit == 1 || nBit == 2)
; 545  : 	{
; 546  : 		BMPheader.bfSize = ( sizeof(BITMAPFILEHEADER ) + sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 256 + header.biWidth * abs(header.biHeight) * nBit );
; 547  : 		BMPheader.bfOffBits = sizeof(BITMAPFILEHEADER ) + sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 256;
; 548  : 	}
; 549  : 	else
; 550  : 	{
; 551  : 		BMPheader.bfSize = ( sizeof(BITMAPFILEHEADER ) + sizeof(BITMAPINFOHEADER) + header.biWidth * abs(header.biHeight) * nBit );

  00030	99		 cdq
  00031	53		 push	 ebx
  00032	55		 push	 ebp
  00033	8b 6c 24 68	 mov	 ebp, DWORD PTR _size$[esp+88]
  00037	56		 push	 esi
  00038	8b f0		 mov	 esi, eax
  0003a	33 f2		 xor	 esi, edx
  0003c	2b f2		 sub	 esi, edx
  0003e	8b c6		 mov	 eax, esi
  00040	0f af c5	 imul	 eax, ebp
  00043	83 c0 12	 add	 eax, 18			; 00000012H
  00046	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00049	57		 push	 edi
  0004a	33 ff		 xor	 edi, edi

; 552  : 		BMPheader.bfOffBits = sizeof(BITMAPFILEHEADER ) + sizeof(BITMAPINFOHEADER);
; 553  : 	}
; 554  :  	pBMP = new BYTE[BMPheader.bfSize];

  0004c	50		 push	 eax
  0004d	c7 44 24 34 28
	00 00 00	 mov	 DWORD PTR _header$[esp+104], 40 ; 00000028H
  00055	66 c7 44 24 40
	01 00		 mov	 WORD PTR _header$[esp+116], 1
  0005c	89 7c 24 44	 mov	 DWORD PTR _header$[esp+120], edi
  00060	89 7c 24 48	 mov	 DWORD PTR _header$[esp+124], edi
  00064	89 7c 24 54	 mov	 DWORD PTR _header$[esp+136], edi
  00068	89 7c 24 58	 mov	 DWORD PTR _header$[esp+140], edi
  0006c	66 c7 44 24 42
	18 00		 mov	 WORD PTR _header$[esp+118], 24 ; 00000018H
  00073	89 6c 24 38	 mov	 DWORD PTR _header$[esp+108], ebp
  00077	66 c7 44 24 14
	42 4d		 mov	 WORD PTR _BMPheader$[esp+104], 19778 ; 00004d42H
  0007e	66 89 7c 24 1a	 mov	 WORD PTR _BMPheader$[esp+110], di
  00083	66 89 7c 24 1c	 mov	 WORD PTR _BMPheader$[esp+112], di
  00088	89 44 24 16	 mov	 DWORD PTR _BMPheader$[esp+106], eax
  0008c	c7 44 24 1e 36
	00 00 00	 mov	 DWORD PTR _BMPheader$[esp+114], 54 ; 00000036H
  00094	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00099	8b d8		 mov	 ebx, eax
  0009b	83 c4 04	 add	 esp, 4

; 555  : 	if( pBMP == NULL )	return	FALSE;

  0009e	3b df		 cmp	 ebx, edi
  000a0	89 5c 24 70	 mov	 DWORD PTR _pBMP$[esp+96], ebx
  000a4	0f 84 06 01 00
	00		 je	 $L227660

; 556  : 	pp = pBMP;
; 557  : 
; 558  : 	header.biHeight = abs( header.biHeight);
; 559  : 
; 560  : 	memcpy( pp, &BMPheader, sizeof(BITMAPFILEHEADER) ); pp += sizeof(BITMAPFILEHEADER);

  000aa	8b 54 24 10	 mov	 edx, DWORD PTR _BMPheader$[esp+100]
  000ae	8b cb		 mov	 ecx, ebx
  000b0	89 11		 mov	 DWORD PTR [ecx], edx
  000b2	8b 54 24 14	 mov	 edx, DWORD PTR _BMPheader$[esp+104]
  000b6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000b9	8b 54 24 18	 mov	 edx, DWORD PTR _BMPheader$[esp+108]
  000bd	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000c0	66 8b 54 24 1c	 mov	 dx, WORD PTR _BMPheader$[esp+112]
  000c5	66 89 51 0c	 mov	 WORD PTR [ecx+12], dx
  000c9	8b c6		 mov	 eax, esi
  000cb	89 44 24 38	 mov	 DWORD PTR _header$[esp+108], eax

; 561  : 	memcpy( pp, &header, sizeof(BITMAPINFOHEADER) ); pp += sizeof(BITMAPINFOHEADER);
; 562  : 
; 563  : 	if(nBit == 1 || nBit == 2)
; 564  : 	{
; 565  : 	}
; 566  : 
; 567  : 	j = header.biWidth * abs(header.biHeight) * nBit;

  000cf	99		 cdq
  000d0	83 c3 0e	 add	 ebx, 14			; 0000000eH
  000d3	33 c2		 xor	 eax, edx
  000d5	8b fb		 mov	 edi, ebx
  000d7	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000dc	8d 74 24 30	 lea	 esi, DWORD PTR _header$[esp+100]
  000e0	f3 a5		 rep movsd
  000e2	2b c2		 sub	 eax, edx
  000e4	8b c8		 mov	 ecx, eax
  000e6	0f af cd	 imul	 ecx, ebp
  000e9	83 c3 28	 add	 ebx, 40			; 00000028H

; 568  : 
; 569  : 
; 570  : 	for( i = 0; i < abs(header.biHeight); i ++ )

  000ec	85 c0		 test	 eax, eax
  000ee	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  000f1	7e 32		 jle	 SHORT $L225965
  000f3	8b 74 24 6c	 mov	 esi, DWORD PTR _lpData$[esp+96]
  000f7	8d 54 6d 00	 lea	 edx, DWORD PTR [ebp+ebp*2]
  000fb	8d 2c 31	 lea	 ebp, DWORD PTR [ecx+esi]
  000fe	89 44 24 6c	 mov	 DWORD PTR tv93[esp+96], eax
$L225963:

; 571  : 	{
; 572  : 		j  -= header.biWidth * nBit;
; 573  : 		memcpy( pp, pSurface + j, header.biWidth * nBit );		

  00102	8b ca		 mov	 ecx, edx
  00104	8b c1		 mov	 eax, ecx
  00106	c1 e9 02	 shr	 ecx, 2
  00109	2b ea		 sub	 ebp, edx
  0010b	8b fb		 mov	 edi, ebx
  0010d	8b f5		 mov	 esi, ebp
  0010f	f3 a5		 rep movsd
  00111	8b c8		 mov	 ecx, eax
  00113	8b 44 24 6c	 mov	 eax, DWORD PTR tv93[esp+96]
  00117	83 e1 03	 and	 ecx, 3

; 574  : 		pp += header.biWidth * nBit;

  0011a	03 da		 add	 ebx, edx
  0011c	48		 dec	 eax
  0011d	f3 a4		 rep movsb
  0011f	89 44 24 6c	 mov	 DWORD PTR tv93[esp+96], eax
  00123	75 dd		 jne	 SHORT $L225963
$L225965:

; 575  : 	}
; 576  : 
; 577  : 	CFile file;

  00125	8d 4c 24 20	 lea	 ecx, DWORD PTR _file$[esp+100]
  00129	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile

; 578  : 	if(file.Open(lpszFileName,CFile::modeWrite|CFile::modeCreate))

  0012e	8b 4c 24 68	 mov	 ecx, DWORD PTR _lpszFileName$[esp+96]
  00132	6a 00		 push	 0
  00134	68 01 10 00 00	 push	 4097			; 00001001H
  00139	51		 push	 ecx
  0013a	8d 4c 24 2c	 lea	 ecx, DWORD PTR _file$[esp+112]
  0013e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+120], 0
  00146	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  0014b	85 c0		 test	 eax, eax
  0014d	74 43		 je	 SHORT $L225967

; 579  : 	{
; 580  : 		file.Write(pBMP,(int)(pp - pBMP));

  0014f	8b 74 24 70	 mov	 esi, DWORD PTR _pBMP$[esp+96]
  00153	2b de		 sub	 ebx, esi
  00155	53		 push	 ebx
  00156	56		 push	 esi
  00157	8d 4c 24 28	 lea	 ecx, DWORD PTR _file$[esp+108]
  0015b	e8 00 00 00 00	 call	 ?Write@CFile@@UAEXPBXI@Z ; CFile::Write

; 581  : 		safe_delete_array( pBMP );

  00160	56		 push	 esi
  00161	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00166	83 c4 04	 add	 esp, 4

; 582  : 		return TRUE;

  00169	8d 4c 24 20	 lea	 ecx, DWORD PTR _file$[esp+100]
  0016d	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+108], -1
  00175	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5d		 pop	 ebp
  0017d	b8 01 00 00 00	 mov	 eax, 1
  00182	5b		 pop	 ebx

; 587  : }

  00183	8b 4c 24 48	 mov	 ecx, DWORD PTR __$EHRec$[esp+84]
  00187	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0018e	83 c4 54	 add	 esp, 84			; 00000054H
  00191	c3		 ret	 0
$L225967:

; 583  : 	}
; 584  : 
; 585  : 	safe_delete_array( pBMP );

  00192	8b 54 24 70	 mov	 edx, DWORD PTR _pBMP$[esp+96]
  00196	52		 push	 edx
  00197	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0019c	83 c4 04	 add	 esp, 4

; 586  : 	return FALSE; 

  0019f	8d 4c 24 20	 lea	 ecx, DWORD PTR _file$[esp+100]
  001a3	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+108], -1
  001ab	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
$L227660:

; 587  : }

  001b0	8b 4c 24 58	 mov	 ecx, DWORD PTR __$EHRec$[esp+100]
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi
  001b6	5d		 pop	 ebp
  001b7	33 c0		 xor	 eax, eax
  001b9	5b		 pop	 ebx
  001ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c1	83 c4 54	 add	 esp, 84			; 00000054H
  001c4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L227635:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
__ehhandler$?SaveBMP@@YAHPBDPAEUtagSIZE@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T227655
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SaveBMP@@YAHPBDPAEUtagSIZE@@@Z ENDP			; SaveBMP
PUBLIC	?GetPickRay@@YAXVCRect@@UtagPOINT@@PAUD3DXMATRIX@@2PAUD3DXVECTOR3@@3@Z ; GetPickRay
PUBLIC	__real@3f800000
EXTRN	_D3DXMatrixInverse@12:NEAR
;	COMDAT __real@3f800000
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
CONST	ENDS
;	COMDAT ?GetPickRay@@YAXVCRect@@UtagPOINT@@PAUD3DXMATRIX@@2PAUD3DXVECTOR3@@3@Z
_TEXT	SEGMENT
tv274 = -80						; size = 4
_v$ = -76						; size = 12
_m$ = -64						; size = 64
_rect$ = 8						; size = 16
_ptCursor$ = 24						; size = 8
tv272 = 32						; size = 4
_pmatProj$ = 32						; size = 4
_pmatView$ = 36						; size = 4
_pvPickRayOrig$ = 40					; size = 4
_pvPickRayDir$ = 44					; size = 4
?GetPickRay@@YAXVCRect@@UtagPOINT@@PAUD3DXMATRIX@@2PAUD3DXVECTOR3@@3@Z PROC NEAR ; GetPickRay, COMDAT

; 590  : {

  00000	83 ec 50	 sub	 esp, 80			; 00000050H

; 591  : 	D3DXVECTOR3 v;
; 592  : 	v.x =  ( ( ( 2.0f * ptCursor.x ) / rect.Width()  ) - 1 ) / pmatProj->_11;

  00003	8b 4c 24 54	 mov	 ecx, DWORD PTR _rect$[esp+76]
  00007	db 44 24 64	 fild	 DWORD PTR _ptCursor$[esp+76]
  0000b	8b 44 24 5c	 mov	 eax, DWORD PTR _rect$[esp+84]
  0000f	2b c1		 sub	 eax, ecx
  00011	dc c0		 fadd	 ST(0), ST(0)
  00013	89 04 24	 mov	 DWORD PTR tv274[esp+80], eax
  00016	da 34 24	 fidiv	 DWORD PTR tv274[esp+80]
  00019	8b 44 24 6c	 mov	 eax, DWORD PTR _pmatProj$[esp+76]

; 593  : 	v.y = -( ( ( 2.0f * ptCursor.y ) / rect.Height() ) - 1 ) / pmatProj->_22;

  0001d	8b 54 24 58	 mov	 edx, DWORD PTR _rect$[esp+80]
  00021	8b 4c 24 60	 mov	 ecx, DWORD PTR _rect$[esp+88]
  00025	2b ca		 sub	 ecx, edx
  00027	89 4c 24 6c	 mov	 DWORD PTR tv272[esp+76], ecx

; 594  : 	v.z =  1.0f;
; 595  : 
; 596  : 	// Get the inverse view matrix
; 597  : 	D3DXMATRIX m;
; 598  : 	D3DXMatrixInverse( &m, NULL, pmatView );

  0002b	8b 54 24 70	 mov	 edx, DWORD PTR _pmatView$[esp+76]
  0002f	52		 push	 edx
  00030	6a 00		 push	 0
  00032	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  00038	d8 30		 fdiv	 DWORD PTR [eax]
  0003a	d9 5c 24 0c	 fstp	 DWORD PTR _v$[esp+88]
  0003e	db 44 24 70	 fild	 DWORD PTR _ptCursor$[esp+88]
  00042	dc c0		 fadd	 ST(0), ST(0)
  00044	da 74 24 74	 fidiv	 DWORD PTR tv272[esp+84]
  00048	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  0004e	d8 70 14	 fdiv	 DWORD PTR [eax+20]
  00051	8d 44 24 18	 lea	 eax, DWORD PTR _m$[esp+88]
  00055	50		 push	 eax
  00056	d9 e0		 fchs
  00058	d9 5c 24 14	 fstp	 DWORD PTR _v$[esp+96]
  0005c	e8 00 00 00 00	 call	 _D3DXMatrixInverse@12

; 599  : 
; 600  : 	// Transform the screen space pick ray into 3D space
; 601  : 	pvPickRayDir->x  = v.x*m._11 + v.y*m._21 + v.z*m._31;

  00061	d9 44 24 20	 fld	 DWORD PTR _m$[esp+96]
  00065	d8 4c 24 08	 fmul	 DWORD PTR _v$[esp+84]
  00069	8b 44 24 78	 mov	 eax, DWORD PTR _pvPickRayDir$[esp+76]
  0006d	d9 44 24 10	 fld	 DWORD PTR _m$[esp+80]

; 602  : 	pvPickRayDir->y  = v.x*m._12 + v.y*m._22 + v.z*m._32;
; 603  : 	pvPickRayDir->z  = v.x*m._13 + v.y*m._23 + v.z*m._33;
; 604  : 	pvPickRayOrig->x = m._41;
; 605  : 	pvPickRayOrig->y = m._42;

  00071	8b 4c 24 44	 mov	 ecx, DWORD PTR _m$[esp+132]
  00075	d8 4c 24 04	 fmul	 DWORD PTR _v$[esp+80]

; 606  : 	pvPickRayOrig->z = m._43;

  00079	8b 54 24 48	 mov	 edx, DWORD PTR _m$[esp+136]
  0007d	de c1		 faddp	 ST(1), ST(0)
  0007f	d8 44 24 30	 fadd	 DWORD PTR _m$[esp+112]
  00083	d9 18		 fstp	 DWORD PTR [eax]
  00085	d9 44 24 24	 fld	 DWORD PTR _m$[esp+100]
  00089	d8 4c 24 08	 fmul	 DWORD PTR _v$[esp+84]
  0008d	d9 44 24 14	 fld	 DWORD PTR _m$[esp+84]
  00091	d8 4c 24 04	 fmul	 DWORD PTR _v$[esp+80]
  00095	de c1		 faddp	 ST(1), ST(0)
  00097	d8 44 24 34	 fadd	 DWORD PTR _m$[esp+116]
  0009b	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0009e	d9 44 24 28	 fld	 DWORD PTR _m$[esp+104]
  000a2	d8 4c 24 08	 fmul	 DWORD PTR _v$[esp+84]
  000a6	d9 44 24 18	 fld	 DWORD PTR _m$[esp+88]
  000aa	d8 4c 24 04	 fmul	 DWORD PTR _v$[esp+80]
  000ae	de c1		 faddp	 ST(1), ST(0)
  000b0	d8 44 24 38	 fadd	 DWORD PTR _m$[esp+120]
  000b4	d9 58 08	 fstp	 DWORD PTR [eax+8]
  000b7	8b 44 24 74	 mov	 eax, DWORD PTR _pvPickRayOrig$[esp+76]
  000bb	d9 44 24 40	 fld	 DWORD PTR _m$[esp+128]
  000bf	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000c2	d9 18		 fstp	 DWORD PTR [eax]
  000c4	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 607  : }

  000c7	83 c4 50	 add	 esp, 80			; 00000050H
  000ca	c3		 ret	 0
?GetPickRay@@YAXVCRect@@UtagPOINT@@PAUD3DXMATRIX@@2PAUD3DXVECTOR3@@3@Z ENDP ; GetPickRay
_TEXT	ENDS
PUBLIC	?GetRayEnd@@YAXPAUD3DXVECTOR3@@00@Z		; GetRayEnd
; Function compile flags: /Ogty
;	COMDAT ?GetRayEnd@@YAXPAUD3DXVECTOR3@@00@Z
_TEXT	SEGMENT
$T227686 = -12						; size = 12
tv171 = 8						; size = 4
_pvPickRayOrig$ = 8					; size = 4
_pvPickRayDir$ = 12					; size = 4
_pvPickRayEnd$ = 16					; size = 4
?GetRayEnd@@YAXPAUD3DXVECTOR3@@00@Z PROC NEAR		; GetRayEnd, COMDAT

; 610  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 611  : 	FLOAT fyOrig = pvPickRayOrig->y;

  00003	8b 4c 24 10	 mov	 ecx, DWORD PTR _pvPickRayOrig$[esp+8]
  00007	d9 41 04	 fld	 DWORD PTR [ecx+4]

; 612  : 	FLOAT fyDir  = -pvPickRayDir->y;

  0000a	8b 44 24 14	 mov	 eax, DWORD PTR _pvPickRayDir$[esp+8]
  0000e	d9 40 04	 fld	 DWORD PTR [eax+4]
  00011	d9 e0		 fchs

; 613  : 	pvPickRayDir->x = fyOrig * pvPickRayDir->x / fyDir; // vecY : posY = vecX : posX

  00013	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  00019	d9 c0		 fld	 ST(0)
  0001b	d8 08		 fmul	 DWORD PTR [eax]
  0001d	d8 ca		 fmul	 ST(0), ST(2)
  0001f	d9 54 24 10	 fst	 DWORD PTR tv171[esp+8]
  00023	d9 18		 fstp	 DWORD PTR [eax]

; 614  : 	pvPickRayDir->z = fyOrig * pvPickRayDir->z / fyDir; // vecY : posY = vecZ : posZ

  00025	d8 c9		 fmul	 ST(0), ST(1)
  00027	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0002a	d9 50 08	 fst	 DWORD PTR [eax+8]

; 615  : 	pvPickRayDir->y = -fyOrig; //  *pvPickRayDir + *pvPickRayOrig y 0   -fyOrig  .

  0002d	d9 c9		 fxch	 ST(1)
  0002f	d9 e0		 fchs
  00031	d9 50 04	 fst	 DWORD PTR [eax+4]

; 616  : 	*pvPickRayEnd = *pvPickRayDir + *pvPickRayOrig;

  00034	8b 44 24 18	 mov	 eax, DWORD PTR _pvPickRayEnd$[esp+8]
  00038	d9 44 24 10	 fld	 DWORD PTR tv171[esp+8]
  0003c	d8 01		 fadd	 DWORD PTR [ecx]
  0003e	d9 1c 24	 fstp	 DWORD PTR $T227686[esp+12]
  00041	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00044	d9 5c 24 04	 fstp	 DWORD PTR $T227686[esp+16]
  00048	8b 54 24 04	 mov	 edx, DWORD PTR $T227686[esp+16]
  0004c	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  0004f	8b 0c 24	 mov	 ecx, DWORD PTR $T227686[esp+12]
  00052	89 08		 mov	 DWORD PTR [eax], ecx
  00054	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00057	d9 5c 24 08	 fstp	 DWORD PTR $T227686[esp+20]
  0005b	8b 4c 24 08	 mov	 ecx, DWORD PTR $T227686[esp+20]
  0005f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 617  : }

  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	c3		 ret	 0
?GetRayEnd@@YAXPAUD3DXVECTOR3@@00@Z ENDP		; GetRayEnd
_TEXT	ENDS
PUBLIC	?IntersectTriangle@@YAHAAUD3DXVECTOR3@@00ABU1@1PAU1@PAM@Z ; IntersectTriangle
EXTRN	_D3DXIntersectTri@32:NEAR
; Function compile flags: /Ogty
;	COMDAT ?IntersectTriangle@@YAHAAUD3DXVECTOR3@@00ABU1@1PAU1@PAM@Z
_TEXT	SEGMENT
_fV$ = -32						; size = 4
_fU$ = -28						; size = 4
$T227702 = -24						; size = 12
$T227701 = -12						; size = 12
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_orig$ = 20						; size = 4
_dir$ = 24						; size = 4
_pIntersect$ = 28					; size = 4
_pfDist$ = 32						; size = 4
?IntersectTriangle@@YAHAAUD3DXVECTOR3@@00ABU1@1PAU1@PAM@Z PROC NEAR ; IntersectTriangle, COMDAT

; 624  : 	FLOAT fU,fV;
; 625  : 	if(D3DXIntersectTri( &v0, &v1, &v2, &orig, &dir, &fU, &fV, pfDist ) == TRUE )

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _v2$[esp-4]
  00004	83 ec 20	 sub	 esp, 32			; 00000020H
  00007	53		 push	 ebx
  00008	8b 5c 24 40	 mov	 ebx, DWORD PTR _pfDist$[esp+32]
  0000c	56		 push	 esi
  0000d	8b 74 24 3c	 mov	 esi, DWORD PTR _dir$[esp+36]
  00011	57		 push	 edi
  00012	8b 7c 24 3c	 mov	 edi, DWORD PTR _orig$[esp+40]
  00016	53		 push	 ebx
  00017	8d 44 24 10	 lea	 eax, DWORD PTR _fV$[esp+48]
  0001b	50		 push	 eax
  0001c	8b 44 24 3c	 mov	 eax, DWORD PTR _v1$[esp+48]
  00020	8d 4c 24 18	 lea	 ecx, DWORD PTR _fU$[esp+52]
  00024	51		 push	 ecx
  00025	8b 4c 24 3c	 mov	 ecx, DWORD PTR _v0$[esp+52]
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _D3DXIntersectTri@32
  00033	83 f8 01	 cmp	 eax, 1
  00036	75 58		 jne	 SHORT $L226004

; 626  : 	{
; 627  : 		*pIntersect = orig + *pfDist * dir;

  00038	d9 03		 fld	 DWORD PTR [ebx]
  0003a	8b 54 24 44	 mov	 edx, DWORD PTR _pIntersect$[esp+40]
  0003e	d9 c0		 fld	 ST(0)
  00040	d8 0e		 fmul	 DWORD PTR [esi]
  00042	d9 c1		 fld	 ST(1)
  00044	d8 4e 04	 fmul	 DWORD PTR [esi+4]
  00047	d9 5c 24 24	 fstp	 DWORD PTR $T227701[esp+48]
  0004b	d9 c9		 fxch	 ST(1)
  0004d	d8 4e 08	 fmul	 DWORD PTR [esi+8]
  00050	d9 5c 24 28	 fstp	 DWORD PTR $T227701[esp+52]
  00054	d8 07		 fadd	 DWORD PTR [edi]
  00056	d9 5c 24 14	 fstp	 DWORD PTR $T227702[esp+44]
  0005a	8b 44 24 14	 mov	 eax, DWORD PTR $T227702[esp+44]
  0005e	d9 44 24 24	 fld	 DWORD PTR $T227701[esp+48]
  00062	d8 47 04	 fadd	 DWORD PTR [edi+4]
  00065	d9 5c 24 18	 fstp	 DWORD PTR $T227702[esp+48]
  00069	8b 4c 24 18	 mov	 ecx, DWORD PTR $T227702[esp+48]
  0006d	d9 44 24 28	 fld	 DWORD PTR $T227701[esp+52]
  00071	d8 47 08	 fadd	 DWORD PTR [edi+8]
  00074	89 02		 mov	 DWORD PTR [edx], eax
  00076	5f		 pop	 edi
  00077	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0007a	d9 5c 24 18	 fstp	 DWORD PTR $T227702[esp+48]
  0007e	8b 44 24 18	 mov	 eax, DWORD PTR $T227702[esp+48]
  00082	5e		 pop	 esi
  00083	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 628  : 		return TRUE;

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	5b		 pop	 ebx

; 631  : }

  0008c	83 c4 20	 add	 esp, 32			; 00000020H
  0008f	c3		 ret	 0
$L226004:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 629  : 	}
; 630  : 	return FALSE;

  00092	33 c0		 xor	 eax, eax
  00094	5b		 pop	 ebx

; 631  : }

  00095	83 c4 20	 add	 esp, 32			; 00000020H
  00098	c3		 ret	 0
?IntersectTriangle@@YAHAAUD3DXVECTOR3@@00ABU1@1PAU1@PAM@Z ENDP ; IntersectTriangle
_TEXT	ENDS
PUBLIC	?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ; ATL::CSimpleStringT<char,0>::GetManager
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetManager, COMDAT
; _this$ = ecx

; 505  : 		return( GetData()->pStringMgr->Clone() );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00005	8b 11		 mov	 edx, DWORD PTR [ecx]
  00007	ff 62 10	 jmp	 DWORD PTR [edx+16]
?GetManager@?$CSimpleStringT@D$0A@@ATL@@QBEPAUIAtlStringMgr@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetManager
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pchSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pStringMgr$ = 16					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 245  : 	CSimpleStringT( const XCHAR* pchSrc, int nLength, IAtlStringMgr* pStringMgr )

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 246  : 	{
; 247  : 		ATLASSERT( pStringMgr != NULL );
; 248  : 		
; 249  : 		if(pchSrc == NULL && nLength != 0)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	57		 push	 edi
  00009	8b 7c 24 14	 mov	 edi, DWORD PTR _nLength$[esp+8]
  0000d	8b d9		 mov	 ebx, ecx
  0000f	75 0e		 jne	 SHORT $L226151
  00011	85 ff		 test	 edi, edi
  00013	74 0a		 je	 SHORT $L226151

; 258  : 		SetLength( nLength );

$L227758:
  00015	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0001a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L227765:
$L226151:

; 250  : 			AtlThrow(E_INVALIDARG);
; 251  : 
; 252  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );

  0001f	8b 4c 24 18	 mov	 ecx, DWORD PTR _pStringMgr$[esp+8]
  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	ff 10		 call	 DWORD PTR [eax]

; 253  : 		if( pData == NULL )

  0002a	85 c0		 test	 eax, eax
  0002c	75 05		 jne	 SHORT $L226155

; 254  : 		{
; 255  : 			ThrowMemoryException();

  0002e	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L227766:
$L226155:

; 256  : 		}
; 257  : 		Attach( pData );

  00033	83 c0 10	 add	 eax, 16			; 00000010H

; 258  : 		SetLength( nLength );

  00036	85 ff		 test	 edi, edi
  00038	89 03		 mov	 DWORD PTR [ebx], eax
  0003a	7c d9		 jl	 SHORT $L227758
  0003c	3b 78 f8	 cmp	 edi, DWORD PTR [eax-8]
  0003f	7f d4		 jg	 SHORT $L227758
  00041	89 78 f4	 mov	 DWORD PTR [eax-12], edi
  00044	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00046	c6 04 0f 00	 mov	 BYTE PTR [edi+ecx], 0

; 259  : 		CopyChars( m_pszData, pchSrc, nLength );

  0004a	8b cf		 mov	 ecx, edi
  0004c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0004e	8b d1		 mov	 edx, ecx
  00050	c1 e9 02	 shr	 ecx, 2
  00053	f3 a5		 rep movsd
  00055	8b ca		 mov	 ecx, edx
  00057	83 e1 03	 and	 ecx, 3
  0005a	f3 a4		 rep movsb
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 260  : 	}

  0005e	8b c3		 mov	 eax, ebx
  00060	5b		 pop	 ebx
  00061	c2 0c 00	 ret	 12			; 0000000cH
$L227764:
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
EXTRN	__filelength:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\file.h
;	COMDAT ?GetLength@CFileIO@@UAEJXZ
_TEXT	SEGMENT
?GetLength@CFileIO@@UAEJXZ PROC NEAR			; CFileIO::GetLength, COMDAT
; _this$ = ecx

; 26   : 	virtual long GetLength() { return _filelength( Handle() ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fileno
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __filelength
  0000f	83 c4 08	 add	 esp, 8
  00012	c3		 ret	 0
?GetLength@CFileIO@@UAEJXZ ENDP				; CFileIO::GetLength
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 501  : 		return( GetData()->nDataLength );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]

; 502  : 	}

  00005	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 263  : 		CStringData* pData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 264  : 		pData->Release();

  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L227789
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L227789:

; 265  : 	}

  0001c	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
; Function compile flags: /Ogty
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nNewLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L227807
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L227807
  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 549  : 	}

  00018	c2 04 00	 ret	 4
$L227807:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L227810:
$L227809:
  00025	cc		 int	 3
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
; Function compile flags: /Ogty
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 422  : 		CStringData* pOldData = GetData();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 424  : 		if( pOldData->nDataLength == 0 )

  00005	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  00008	85 d2		 test	 edx, edx
  0000a	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	74 4c		 je	 SHORT $L227844
  00012	53		 push	 ebx

; 425  : 		{
; 426  : 			return;
; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

  00013	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00016	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  00019	85 db		 test	 ebx, ebx
  0001b	5b		 pop	 ebx
  0001c	7d 20		 jge	 SHORT $L221323

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

  0001e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00021	85 c0		 test	 eax, eax
  00023	7d 0a		 jge	 SHORT $L227833
  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L227849:
$L227833:
  0002f	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	5f		 pop	 edi
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003c	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  0003d	c3		 ret	 0
$L221323:

; 433  : 		}
; 434  : 		else
; 435  : 		{
; 436  : 			pOldData->Release();

  0003e	83 c9 ff	 or	 ecx, -1
  00041	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00045	49		 dec	 ecx
  00046	85 c9		 test	 ecx, ecx
  00048	7f 08		 jg	 SHORT $L227839
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	50		 push	 eax
  0004f	ff 52 04	 call	 DWORD PTR [edx+4]
$L227839:

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b cf		 mov	 ecx, edi
  00056	ff 50 0c	 call	 DWORD PTR [eax+12]

; 438  : 			Attach( pNewData );

  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 06		 mov	 DWORD PTR [esi], eax
$L227844:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  00060	c3		 ret	 0
$L227848:
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 747  : 		CStringData* pOldData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 748  : 		if( pOldData->nDataLength > nLength )

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _nLength$[esp-4]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7e 02		 jle	 SHORT $L221345

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  00011	8b d6		 mov	 edx, esi
$L221345:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00013	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00017	5e		 pop	 esi
  00018	7e 09		 jle	 SHORT $L221346

; 753  : 		{
; 754  : 			Fork( nLength );

  0001a	89 54 24 04	 mov	 DWORD PTR _nLength$[esp-4], edx
  0001e	e9 00 00 00 00	 jmp	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L221346:

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00023	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00026	3b c2		 cmp	 eax, edx
  00028	7d 1f		 jge	 SHORT $L221348

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;
; 760  : 			if( nNewLength > 1024 )

  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7e 07		 jle	 SHORT $L221350

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00031	05 00 04 00 00	 add	 eax, 1024		; 00000400H

; 763  : 			}
; 764  : 			else

  00036	eb 02		 jmp	 SHORT $L221351
$L221350:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00038	03 c0		 add	 eax, eax
$L221351:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 02		 jge	 SHORT $L221352

; 769  : 			{
; 770  : 				nNewLength = nLength;

  0003e	8b c2		 mov	 eax, edx
$L221352:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00040	89 44 24 04	 mov	 DWORD PTR _nLength$[esp-4], eax
  00044	e9 00 00 00 00	 jmp	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L221348:

; 773  : 		}
; 774  : 	}

  00049	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
PUBLIC	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
; Function compile flags: /Ogty
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CloneData, COMDAT

; 801  : 	{

  00000	56		 push	 esi

; 802  : 		CStringData* pNewData = NULL;
; 803  : 
; 804  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pData$[esp]
  00005	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 10	 call	 DWORD PTR [eax+16]

; 805  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

  0000c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0000f	85 d2		 test	 edx, edx
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	7c 11		 jl	 SHORT $L221356
  00016	3b 06		 cmp	 eax, DWORD PTR [esi]
  00018	75 0d		 jne	 SHORT $L221356

; 806  : 		{
; 807  : 			pNewData = pData;

  0001a	8b c6		 mov	 eax, esi

; 808  : 			pNewData->AddRef();

  0001c	ba 01 00 00 00	 mov	 edx, 1
  00021	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  00025	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  00026	c3		 ret	 0
$L221356:

; 809  : 		}
; 810  : 		else
; 811  : 		{
; 812  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	6a 01		 push	 1
  0002e	51		 push	 ecx
  0002f	8b c8		 mov	 ecx, eax
  00031	ff 12		 call	 DWORD PTR [edx]

; 813  : 			if( pNewData == NULL )

  00033	85 c0		 test	 eax, eax
  00035	75 05		 jne	 SHORT $L221359

; 814  : 			{
; 815  : 				ThrowMemoryException();

  00037	e9 00 00 00 00	 jmp	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L221359:

; 816  : 			}
; 817  : 			pNewData->nDataLength = pData->nDataLength;

  0003c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 818  : 			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'

  00042	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00045	41		 inc	 ecx
  00046	8b d1		 mov	 edx, ecx
  00048	57		 push	 edi
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	83 c6 10	 add	 esi, 16			; 00000010H
  0004f	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  00052	f3 a5		 rep movsd
  00054	8b ca		 mov	 ecx, edx
  00056	83 e1 03	 and	 ecx, 3
  00059	f3 a4		 rep movsb
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );
; 822  : 	}

  0005d	c3		 ret	 0
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ENDP ; ATL::CSimpleStringT<char,0>::CloneData
_TEXT	ENDS
PUBLIC	?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z ; LoadTextureFromRes
PUBLIC	??_C@_0CE@NBIPLAAF@?3?3LoadTextureFromRes?5?3?5?$CFs?5not?5fo@ ; `string'
PUBLIC	??_C@_0CK@EOOHBDEA@D3DXCreateTextureFromFileInMemor@ ; `string'
EXTRN	_DXGetErrorString9A@4:NEAR
EXTRN	_D3DXCreateTextureFromFileInMemoryEx@60:NEAR
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\file.h
xdata$x	SEGMENT
$T227912 DD	0ffffffffH
	DD	FLAT:$L227886
$T227909 DD	019930520H
	DD	01H
	DD	FLAT:$T227912
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0CE@NBIPLAAF@?3?3LoadTextureFromRes?5?3?5?$CFs?5not?5fo@
CONST	SEGMENT
??_C@_0CE@NBIPLAAF@?3?3LoadTextureFromRes?5?3?5?$CFs?5not?5fo@ DB '::Load'
	DB	'TextureFromRes : %s not found', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EOOHBDEA@D3DXCreateTextureFromFileInMemor@
CONST	SEGMENT
??_C@_0CK@EOOHBDEA@D3DXCreateTextureFromFileInMemor@ DB 'D3DXCreateTextur'
	DB	'eFromFileInMemoryEx %s %s', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
CONST	ENDS
;	COMDAT ?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z
_TEXT	SEGMENT
_file$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pDevice$ = 8						; size = 4
_pFileName$ = 12					; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_MipLevels$ = 24					; size = 4
_Usage$ = 28						; size = 4
_Format$ = 32						; size = 4
_Pool$ = 36						; size = 4
_Filter$ = 40						; size = 4
_MipFilter$ = 44					; size = 4
_ColorKey$ = 48						; size = 4
_pSrcInfo$ = 52						; size = 4
_pPalette$ = 56						; size = 4
_ppTexture$ = 60					; size = 4
?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z PROC NEAR ; LoadTextureFromRes, COMDAT

; 220  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi

; 221  : 	HRESULT hr = E_FAIL;
; 222  : 	CResFile file;

  0001b	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_7CFileIO@@6B@
  00020	33 c0		 xor	 eax, eax
  00022	bb 05 40 00 80	 mov	 ebx, -2147467259	; 80004005H
  00027	89 74 24 0c	 mov	 DWORD PTR _file$[esp+32], esi
  0002b	89 44 24 10	 mov	 DWORD PTR _file$[esp+36], eax

; 223  : 	if( file.Open( pFileName, "rb" ) == FALSE )

  0002f	8b 6c 24 28	 mov	 ebp, DWORD PTR _pFileName$[esp+28]
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  00038	55		 push	 ebp
  00039	8d 4c 24 14	 lea	 ecx, DWORD PTR _file$[esp+40]
  0003d	89 44 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], eax
  00041	e8 00 00 00 00	 call	 ?Open@CFileIO@@UAEHPBDPAD@Z ; CFileIO::Open
  00046	85 c0		 test	 eax, eax
  00048	75 37		 jne	 SHORT $L225729

; 224  : 	{
; 225  : 		LPCTSTR szErr = Error( "::LoadTextureFromRes : %s not found", pFileName );

  0004a	55		 push	 ebp
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@NBIPLAAF@?3?3LoadTextureFromRes?5?3?5?$CFs?5not?5fo@
  00050	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00055	83 c4 08	 add	 esp, 8

; 226  : 		ADDERRORMSG( szErr );
; 227  : 		return E_FAIL;

  00058	8d 4c 24 0c	 lea	 ecx, DWORD PTR _file$[esp+32]
  0005c	c7 44 24 1c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+40], -1
  00064	89 74 24 0c	 mov	 DWORD PTR _file$[esp+32], esi
  00068	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	8b c3		 mov	 eax, ebx
  00071	5b		 pop	 ebx

; 244  : }

  00072	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007d	83 c4 14	 add	 esp, 20			; 00000014H
  00080	c3		 ret	 0
$L225729:

; 228  : 	}
; 229  : 	
; 230  : 	int nSrcDataSize = file.GetLength();

  00081	8b 44 24 10	 mov	 eax, DWORD PTR _file$[esp+36]
  00085	57		 push	 edi
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _fileno
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 __filelength
  00092	8b f0		 mov	 esi, eax

; 231  : 	LPBYTE pSrcData = new BYTE[ nSrcDataSize ];

  00094	56		 push	 esi
  00095	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 232  : 	if( file.Read( pSrcData, nSrcDataSize ) >= 1 )

  0009a	8b 4c 24 20	 mov	 ecx, DWORD PTR _file$[esp+52]
  0009e	51		 push	 ecx
  0009f	6a 01		 push	 1
  000a1	8b f8		 mov	 edi, eax
  000a3	56		 push	 esi
  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 _fread
  000aa	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	72 63		 jb	 SHORT $L227910

; 233  : 	{
; 234  : 		hr = D3DXCreateTextureFromFileInMemoryEx( pDevice,
; 235  : 			   pSrcData, nSrcDataSize, Width, Height, MipLevels, Usage, Format, Pool, Filter, MipFilter, ColorKey, pSrcInfo, pPalette, ppTexture );

  000b2	8b 54 24 5c	 mov	 edx, DWORD PTR _ppTexture$[esp+32]
  000b6	8b 44 24 58	 mov	 eax, DWORD PTR _pPalette$[esp+32]
  000ba	8b 4c 24 54	 mov	 ecx, DWORD PTR _pSrcInfo$[esp+32]
  000be	52		 push	 edx
  000bf	8b 54 24 54	 mov	 edx, DWORD PTR _ColorKey$[esp+36]
  000c3	50		 push	 eax
  000c4	8b 44 24 54	 mov	 eax, DWORD PTR _MipFilter$[esp+40]
  000c8	51		 push	 ecx
  000c9	8b 4c 24 54	 mov	 ecx, DWORD PTR _Filter$[esp+44]
  000cd	52		 push	 edx
  000ce	8b 54 24 54	 mov	 edx, DWORD PTR _Pool$[esp+48]
  000d2	50		 push	 eax
  000d3	8b 44 24 54	 mov	 eax, DWORD PTR _Format$[esp+52]
  000d7	51		 push	 ecx
  000d8	8b 4c 24 54	 mov	 ecx, DWORD PTR _Usage$[esp+56]
  000dc	52		 push	 edx
  000dd	8b 54 24 54	 mov	 edx, DWORD PTR _MipLevels$[esp+60]
  000e1	50		 push	 eax
  000e2	8b 44 24 54	 mov	 eax, DWORD PTR _Height$[esp+64]
  000e6	51		 push	 ecx
  000e7	8b 4c 24 54	 mov	 ecx, DWORD PTR _Width$[esp+68]
  000eb	52		 push	 edx
  000ec	8b 54 24 50	 mov	 edx, DWORD PTR _pDevice$[esp+72]
  000f0	50		 push	 eax
  000f1	51		 push	 ecx
  000f2	56		 push	 esi
  000f3	57		 push	 edi
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _D3DXCreateTextureFromFileInMemoryEx@60
  000fa	8b d8		 mov	 ebx, eax

; 236  : 		if( FAILED( hr ) )

  000fc	85 db		 test	 ebx, ebx
  000fe	7d 15		 jge	 SHORT $L227910

; 237  : 		{
; 238  : 			LPCTSTR szErr = Error( "D3DXCreateTextureFromFileInMemoryEx %s %s", pFileName, DXGetErrorString9( hr ) );

  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _DXGetErrorString9A@4
  00106	50		 push	 eax
  00107	55		 push	 ebp
  00108	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CK@EOOHBDEA@D3DXCreateTextureFromFileInMemor@
  0010d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH
$L227910:

; 239  : 			ADDERRORMSG( szErr );
; 240  : 		}
; 241  : 	}
; 242  : 	SAFE_DELETE_ARRAY( pSrcData );

  00115	85 ff		 test	 edi, edi
  00117	74 09		 je	 SHORT $L225746
  00119	57		 push	 edi
  0011a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0011f	83 c4 04	 add	 esp, 4
$L225746:

; 243  : 	return hr;

  00122	8d 4c 24 10	 lea	 ecx, DWORD PTR _file$[esp+36]
  00126	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+44], -1
  0012e	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _file$[esp+36], OFFSET FLAT:??_7CFileIO@@6B@
  00136	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close

; 244  : }

  0013b	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5d		 pop	 ebp
  00142	8b c3		 mov	 eax, ebx
  00144	5b		 pop	 ebx
  00145	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014c	83 c4 14	 add	 esp, 20			; 00000014H
  0014f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L227886:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileIO@@UAE@XZ	; CFileIO::~CFileIO
__ehhandler$?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T227909
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z ENDP ; LoadTextureFromRes
PUBLIC	?LoadImageA@@YAHPBDPAUIMAGE@@@Z			; LoadImageA
PUBLIC	??_C@_04JCAPCJAP@?4tga?$AA@			; `string'
PUBLIC	??_C@_04LJDDIHIK@?4bmp?$AA@			; `string'
EXTRN	_strstr:NEAR
EXTRN	_strlwr:NEAR
;	COMDAT ??_C@_04JCAPCJAP@?4tga?$AA@
CONST	SEGMENT
??_C@_04JCAPCJAP@?4tga?$AA@ DB '.tga', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJDDIHIK@?4bmp?$AA@
CONST	SEGMENT
??_C@_04LJDDIHIK@?4bmp?$AA@ DB '.bmp', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?LoadImageA@@YAHPBDPAUIMAGE@@@Z
_TEXT	SEGMENT
_szFileName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpszFileName$ = 8					; size = 4
_lpImage$ = 12						; size = 4
?LoadImageA@@YAHPBDPAUIMAGE@@@Z PROC NEAR		; LoadImageA, COMDAT

; 421  : {

  00000	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi
  0000e	8b b4 24 10 01
	00 00		 mov	 esi, DWORD PTR _lpszFileName$[esp+264]

; 422  : 	TCHAR szFileName[ MAX_PATH ];
; 423  : 	strcpy( szFileName, lpszFileName );

  00015	8d 54 24 04	 lea	 edx, DWORD PTR _szFileName$[esp+268]
  00019	89 84 24 08 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+268], eax
  00020	57		 push	 edi
  00021	8b bc 24 18 01
	00 00		 mov	 edi, DWORD PTR _lpImage$[esp+268]
  00028	8b c6		 mov	 eax, esi
  0002a	2b d6		 sub	 edx, esi
  0002c	8d 64 24 00	 npad	 4
$L227919:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00035	40		 inc	 eax
  00036	84 c9		 test	 cl, cl
  00038	75 f6		 jne	 SHORT $L227919

; 424  : 	strlwr( szFileName );

  0003a	8d 44 24 08	 lea	 eax, DWORD PTR _szFileName$[esp+272]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _strlwr

; 425  : 	if( strstr( szFileName, ".tga" ) )

  00044	8d 4c 24 0c	 lea	 ecx, DWORD PTR _szFileName$[esp+276]
  00048	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04JCAPCJAP@?4tga?$AA@
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _strstr
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	85 c0		 test	 eax, eax

; 426  : 	{
; 427  : 		return LoadTGA( lpszFileName, lpImage );

  00058	75 37		 jne	 SHORT $L225879

; 428  : 	}
; 429  : 	else
; 430  : 	if( strstr( szFileName, ".bmp" ) )

  0005a	8d 54 24 08	 lea	 edx, DWORD PTR _szFileName$[esp+272]
  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LJDDIHIK@?4bmp?$AA@
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _strstr
  00069	83 c4 08	 add	 esp, 8
  0006c	85 c0		 test	 eax, eax
  0006e	74 21		 je	 SHORT $L225879

; 431  : 	{
; 432  : 		return LoadBMP( lpszFileName, lpImage );

  00070	57		 push	 edi
  00071	56		 push	 esi
  00072	e8 00 00 00 00	 call	 ?LoadBMP@@YAHPBDPAUIMAGE@@@Z ; LoadBMP
  00077	83 c4 08	 add	 esp, 8
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 433  : 	}				
; 434  : 	return FALSE;
; 435  : }

  0007c	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+264]
  00083	33 cc		 xor	 ecx, esp
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00090	c3		 ret	 0
$L225879:
  00091	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	33 cc		 xor	 ecx, esp
  0009c	33 c0		 xor	 eax, eax
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  000a9	c3		 ret	 0
?LoadImageA@@YAHPBDPAUIMAGE@@@Z ENDP			; LoadImageA
_TEXT	ENDS
PUBLIC	??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z		; ATL::CSimpleStringT<char,0>::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z
_TEXT	SEGMENT
_iChar$ = 8						; size = 4
??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator[], COMDAT
; _this$ = ecx

; 369  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 370  : 		
; 371  : 		if( (iChar < 0) || (iChar > GetLength()) )

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _iChar$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	7c 0d		 jl	 SHORT $L226018
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	3b 50 f4	 cmp	 edx, DWORD PTR [eax-12]
  0000d	7f 06		 jg	 SHORT $L226018

; 372  : 			AtlThrow(E_INVALIDARG);
; 373  : 			
; 374  : 		return( m_pszData[iChar] );

  0000f	8a 04 10	 mov	 al, BYTE PTR [eax+edx]

; 375  : 	}

  00012	c2 04 00	 ret	 4
$L226018:
  00015	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0001a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L227940:
$L227939:
  0001f	cc		 int	 3
??A?$CSimpleStringT@D$0A@@ATL@@QBEDH@Z ENDP		; ATL::CSimpleStringT<char,0>::operator[]
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pch$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pStringMgr$ = 16					; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 923  : 	{

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _pStringMgr$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _pch$[esp-4]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nLength$[esp]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 924  : 	}

  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 0c 00	 ret	 12			; 0000000cH
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 963  : 	}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H
  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L227961
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L227961:
  0001c	c3		 ret	 0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H

; 220  : 		CStringData* pNewData = CloneData( pSrcData );

  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData

; 221  : 		Attach( pNewData );

  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 222  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 735  : 		CStringData* pOldData = GetData();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nLength$[esp]
  00019	2b d0		 sub	 edx, eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L227984

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L227984:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 744  : 	}

  0002a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDPAPAUIDirect3DTexture9@@KW4_D3DFORMAT@@@Z ; LoadTextureFromRes
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
;	COMDAT ?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDPAPAUIDirect3DTexture9@@KW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
_pd3dDevice$ = 8					; size = 4
_strTexture$ = 12					; size = 4
_ppTexture$ = 16					; size = 4
_MipFilter$ = 20					; size = 4
_d3dFormat$ = 24					; size = 4
?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDPAPAUIDirect3DTexture9@@KW4_D3DFORMAT@@@Z PROC NEAR ; LoadTextureFromRes, COMDAT

; 197  : 
; 198  :     return LoadTextureFromRes( pd3dDevice, strTexture, 
; 199  : 		D3DX_DEFAULT, D3DX_DEFAULT, MipFilter, 0, d3dFormat, 
; 200  : 		D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
; 201  : 		D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, ppTexture );

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _ppTexture$[esp-4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR _d3dFormat$[esp-4]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR _MipFilter$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 0c	 mov	 eax, DWORD PTR _strTexture$[esp]
  00011	6a 00		 push	 0
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	68 04 00 07 00	 push	 458756			; 00070004H
  0001c	68 04 00 07 00	 push	 458756			; 00070004H
  00021	6a 01		 push	 1
  00023	51		 push	 ecx
  00024	8b 4c 24 24	 mov	 ecx, DWORD PTR _pd3dDevice$[esp+28]
  00028	6a 00		 push	 0
  0002a	52		 push	 edx
  0002b	6a ff		 push	 -1
  0002d	6a ff		 push	 -1
  0002f	50		 push	 eax
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDIIIKW4_D3DFORMAT@@W4_D3DPOOL@@KKKPAU_D3DXIMAGE_INFO@@PAUtagPALETTEENTRY@@PAPAUIDirect3DTexture9@@@Z ; LoadTextureFromRes
  00036	83 c4 38	 add	 esp, 56			; 00000038H

; 202  : }

  00039	c3		 ret	 0
?LoadTextureFromRes@@YAJPAUIDirect3DDevice9@@PBDPAPAUIDirect3DTexture9@@KW4_D3DFORMAT@@@Z ENDP ; LoadTextureFromRes
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 814  : 	{

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	83 e8 10	 sub	 eax, 16			; 00000010H
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00012	83 c0 10	 add	 eax, 16			; 00000010H
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	83 c4 04	 add	 esp, 4

; 815  : 	}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	c2 04 00	 ret	 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nMinBufferLength$[esp]
  00019	2b d0		 sub	 edx, eax
  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L228030
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L228030:
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 491  : 	}

  0002a	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	53		 push	 ebx

; 584  : 		if( nLength == 0 )

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nLength$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	8b e9		 mov	 ebp, ecx
  0000a	75 0a		 jne	 SHORT $L221330

; 585  : 		{
; 586  : 			Empty();

  0000c	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty
  00011	5d		 pop	 ebp
  00012	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00013	c2 08 00	 ret	 8
$L221330:

; 587  : 		}
; 588  : 		else
; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

  00016	8b 54 24 0c	 mov	 edx, DWORD PTR _pszSrc$[esp+4]
  0001a	85 d2		 test	 edx, edx
  0001c	75 0a		 jne	 SHORT $L221332

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

$L228102:
  0001e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L228106:
$L221332:

; 597  : 				AtlThrow(E_INVALIDARG);			
; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

  00028	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0002b	56		 push	 esi

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

  0002c	8b f2		 mov	 esi, edx
  0002e	2b f0		 sub	 esi, eax

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  00038	57		 push	 edi
  00039	8b 78 f4	 mov	 edi, DWORD PTR [eax-12]
  0003c	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0003f	2b c3		 sub	 eax, ebx
  00041	0b c8		 or	 ecx, eax
  00043	7d 0c		 jge	 SHORT $L228070
  00045	53		 push	 ebx
  00046	8b cd		 mov	 ecx, ebp
  00048	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  0004d	8b 54 24 14	 mov	 edx, DWORD PTR _pszSrc$[esp+12]
$L228070:

; 605  : 			if( nOffset <= nOldLength )

  00051	3b f7		 cmp	 esi, edi
  00053	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00056	77 10		 ja	 SHORT $L221337

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

  00058	53		 push	 ebx
  00059	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0005c	51		 push	 ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memmove
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 			}
; 609  : 			else

  00066	eb 14		 jmp	 SHORT $L228075
$L221337:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

  00068	8b cb		 mov	 ecx, ebx
  0006a	8b f2		 mov	 esi, edx
  0006c	8b d1		 mov	 edx, ecx
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	8b f8		 mov	 edi, eax
  00073	f3 a5		 rep movsd
  00075	8b ca		 mov	 ecx, edx
  00077	83 e1 03	 and	 ecx, 3
  0007a	f3 a4		 rep movsb
$L228075:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

  0007c	85 db		 test	 ebx, ebx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	7c 9c		 jl	 SHORT $L228102
  00082	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00085	3b 58 f8	 cmp	 ebx, DWORD PTR [eax-8]
  00088	7f 94		 jg	 SHORT $L228102
  0008a	89 58 f4	 mov	 DWORD PTR [eax-12], ebx
  0008d	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00090	5d		 pop	 ebp
  00091	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  00095	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00096	c2 08 00	 ret	 8
$L228105:
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT
$T228111 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_nCount$ = 12						; size = 4
?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left, COMDAT
; _this$ = ecx

; 1759 : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 1760 : 		// nCount is in XCHARs
; 1761 : 		if (nCount < 0)

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _nCount$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T228111[esp+12], 0
  00013	7d 02		 jge	 SHORT $L226010

; 1762 : 			nCount = 0;

  00015	33 f6		 xor	 esi, esi
$L226010:

; 1763 : 
; 1764 : 		int nLength = GetLength();

  00017	8b 07		 mov	 eax, DWORD PTR [edi]

; 1765 : 		if( nCount >= nLength )

  00019	3b 70 f4	 cmp	 esi, DWORD PTR [eax-12]
  0001c	7c 1d		 jl	 SHORT $L226012

; 1766 : 		{
; 1767 : 			return( *this );

  0001e	83 c0 f0	 add	 eax, -16		; fffffff0H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  00027	83 c4 04	 add	 esp, 4
  0002a	8b c8		 mov	 ecx, eax
  0002c	8b 44 24 10	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+8]
  00030	83 c1 10	 add	 ecx, 16			; 00000010H
  00033	5f		 pop	 edi
  00034	89 08		 mov	 DWORD PTR [eax], ecx
  00036	5e		 pop	 esi

; 1771 : 	}

  00037	59		 pop	 ecx
  00038	c2 08 00	 ret	 8
$L226012:

; 1768 : 		}
; 1769 : 
; 1770 : 		return( CStringT( GetString(), nCount, GetManager() ) );

  0003b	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	ff 52 10	 call	 DWORD PTR [edx+16]
  00043	50		 push	 eax
  00044	8b 07		 mov	 eax, DWORD PTR [edi]
  00046	56		 push	 esi
  00047	8b 74 24 18	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+16]
  0004b	50		 push	 eax
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
  00053	5f		 pop	 edi
  00054	8b c6		 mov	 eax, esi
  00056	5e		 pop	 esi

; 1771 : 	}

  00057	59		 pop	 ecx
  00058	c2 08 00	 ret	 8
?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 274  : 		CStringData* pSrcData = strSrc.GetData();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]

; 275  : 		CStringData* pOldData = GetData();

  0000a	8b 37		 mov	 esi, DWORD PTR [edi]
  0000c	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000f	83 ee 10	 sub	 esi, 16			; 00000010H

; 276  : 		if( pSrcData != pOldData)

  00012	3b c6		 cmp	 eax, esi
  00014	74 4d		 je	 SHORT $L228211

; 277  : 		{
; 278  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )

  00016	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00019	85 d2		 test	 edx, edx
  0001b	53		 push	 ebx
  0001c	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  0001f	55		 push	 ebp
  00020	7c 33		 jl	 SHORT $L219958
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	3b 16		 cmp	 edx, DWORD PTR [esi]
  00026	75 2d		 jne	 SHORT $L219958

; 281  : 			}
; 282  : 			else
; 283  : 			{
; 284  : 				CStringData* pNewData = CloneData( pSrcData );

  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
  0002e	8b e8		 mov	 ebp, eax
  00030	83 c4 04	 add	 esp, 4

; 285  : 				pOldData->Release();

  00033	83 c8 ff	 or	 eax, -1
  00036	f0 0f c1 03	 lock	  xadd	 DWORD PTR [ebx], eax
  0003a	48		 dec	 eax
  0003b	85 c0		 test	 eax, eax
  0003d	7f 08		 jg	 SHORT $L228202
  0003f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	56		 push	 esi
  00044	ff 52 04	 call	 DWORD PTR [edx+4]
$L228202:

; 286  : 				Attach( pNewData );

  00047	83 c5 10	 add	 ebp, 16			; 00000010H
  0004a	89 2f		 mov	 DWORD PTR [edi], ebp
  0004c	5d		 pop	 ebp
  0004d	5b		 pop	 ebx

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

  0004e	8b c7		 mov	 eax, edi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 291  : 	}

  00052	c2 04 00	 ret	 4
$L219958:

; 279  : 			{
; 280  : 				SetString( strSrc.GetString(), strSrc.GetLength() );

  00055	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  00058	50		 push	 eax
  00059	51		 push	 ecx
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00061	5d		 pop	 ebp
  00062	5b		 pop	 ebx
$L228211:

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

  00063	8b c7		 mov	 eax, edi
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 291  : 	}

  00067	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_strSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 968  : 		CThisSimpleString::operator=( strSrc );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _strSrc$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=

; 969  : 
; 970  : 		return( *this );

  0000d	8b c6		 mov	 eax, esi
  0000f	5e		 pop	 esi

; 971  : 	}

  00010	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; SetStrNull
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T228324 DD	0ffffffffH
	DD	FLAT:$L228223
	DD	0ffffffffH
	DD	FLAT:$L228224
$T228316 DD	019930520H
	DD	02H
	DD	FLAT:$T228324
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\vutil.cpp
xdata$x	ENDS
;	COMDAT ?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T228251 = 8						; size = 1
$T228221 = 8						; size = 4
_string$ = 8						; size = 4
$T228222 = 12						; size = 4
_nNullLength$ = 12					; size = 4
?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC NEAR ; SetStrNull, COMDAT

; 161  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	53		 push	 ebx

; 162  : 	int nLength = string.GetLength();
; 163  : 	// 0            
; 164  : 	if( nNullLength > nLength )

  00016	8b 5c 24 18	 mov	 ebx, DWORD PTR _nNullLength$[esp+12]
  0001a	55		 push	 ebp
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b 7c 24 20	 mov	 edi, DWORD PTR _string$[esp+24]
  00021	8b 07		 mov	 eax, DWORD PTR [edi]
  00023	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  00026	3b d8		 cmp	 ebx, eax
  00028	7e 02		 jle	 SHORT $L225690

; 165  : 		nNullLength = nLength;

  0002a	8b d8		 mov	 ebx, eax
$L225690:

; 166  : 	for( int i = 0; i < nNullLength; )

  0002c	33 f6		 xor	 esi, esi
  0002e	85 db		 test	 ebx, ebx
  00030	7e 2d		 jle	 SHORT $L225694
  00032	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__IsDBCSLeadByte@4
$L225693:

; 167  : 	{
; 168  : #ifdef __CLIENT
; 169  : 		if( ::GetLanguage() == LANG_THA && g_codePage == 874 ) //  
; 170  : 			i++;
; 171  : 		else if(::GetLanguage() == LANG_VTN && g_codePage == 1258)
; 172  : 			i++;
; 173  : 		else
; 174  : #endif//__CLIENT
; 175  : 		if( IsDBCSLeadByte( string[ i ] ) )

  00038	85 f6		 test	 esi, esi
  0003a	7c 4d		 jl	 SHORT $L228318
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	3b 70 f4	 cmp	 esi, DWORD PTR [eax-12]
  00041	7f 46		 jg	 SHORT $L228318
  00043	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  00046	88 4c 24 20	 mov	 BYTE PTR $T228251[esp+24], cl
  0004a	8b 54 24 20	 mov	 edx, DWORD PTR $T228251[esp+24]
  0004e	52		 push	 edx
  0004f	ff d5		 call	 ebp
  00051	85 c0		 test	 eax, eax
  00053	74 05		 je	 SHORT $L225695

; 176  : 			i+=2;

  00055	83 c6 02	 add	 esi, 2

; 177  : 		else

  00058	eb 01		 jmp	 SHORT $L225696
$L225695:

; 178  : 			i++;

  0005a	46		 inc	 esi
$L225696:

; 166  : 	for( int i = 0; i < nNullLength; )

  0005b	3b f3		 cmp	 esi, ebx
  0005d	7c d9		 jl	 SHORT $L225693
$L225694:

; 179  : 	}
; 180  : 	// i nLength   Word ,     .
; 181  : 	if( i > nNullLength )

  0005f	3b f3		 cmp	 esi, ebx

; 182  : 		string = string.Left( i - 2 );

  00061	8b cf		 mov	 ecx, edi
  00063	7e 2e		 jle	 SHORT $L225697
  00065	83 c6 fe	 add	 esi, -2			; fffffffeH
  00068	56		 push	 esi
  00069	8d 44 24 24	 lea	 eax, DWORD PTR $T228221[esp+28]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
  00073	50		 push	 eax
  00074	8b cf		 mov	 ecx, edi
  00076	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 0
  0007e	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
  00083	8b 44 24 20	 mov	 eax, DWORD PTR $T228221[esp+24]

; 183  : 	else

  00087	eb 29		 jmp	 SHORT $L228323
$L228318:

; 167  : 	{
; 168  : #ifdef __CLIENT
; 169  : 		if( ::GetLanguage() == LANG_THA && g_codePage == 874 ) //  
; 170  : 			i++;
; 171  : 		else if(::GetLanguage() == LANG_VTN && g_codePage == 1258)
; 172  : 			i++;
; 173  : 		else
; 174  : #endif//__CLIENT
; 175  : 		if( IsDBCSLeadByte( string[ i ] ) )

  00089	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0008e	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L228325:
$L225697:

; 184  : 		string = string.Left( i );

  00093	56		 push	 esi
  00094	8d 44 24 28	 lea	 eax, DWORD PTR $T228222[esp+28]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?Left@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Left
  0009e	50		 push	 eax
  0009f	8b cf		 mov	 ecx, edi
  000a1	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 1
  000a9	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
  000ae	8b 44 24 24	 mov	 eax, DWORD PTR $T228222[esp+24]
$L228323:
  000b2	83 c0 f0	 add	 eax, -16		; fffffff0H
  000b5	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  000bd	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  000c0	83 ca ff	 or	 edx, -1
  000c3	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000c7	4a		 dec	 edx
  000c8	85 d2		 test	 edx, edx
  000ca	7f 08		 jg	 SHORT $L228314
  000cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d0	50		 push	 eax
  000d1	ff 52 04	 call	 DWORD PTR [edx+4]
$L228314:

; 185  : }

  000d4	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5d		 pop	 ebp
  000db	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e2	5b		 pop	 ebx
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	c3		 ret	 0
$L228321:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L228223:
  00000	8d 4d 04	 lea	 ecx, DWORD PTR $T228221[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L228224:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR $T228222[ebp-4]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T228316
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetStrNull@@YAXAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; SetStrNull
END
