; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\MoverSkill.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DO@PAGMBNAO@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@JPIDGHBC@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@POBPMOID@CMover?3?3DoUseSkill?5?3?5?$CFs?$LE?B?5nIdx?$LP?$KB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FIJAGOKJ@DoUseSkill_P?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LLMCBIOI@DoUseSkill?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@EEBJCALL@DoUseSkill?5?3?5?$CFs?5?0?5?E?$LI?$LA?Y?5?$CFs?5?$MA?G?5?G?A?$LH@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KNNGFFII@SkillLevel1?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@KIFDAMPH@DoUseSkill?5?3?5?$CFs?5NULL?5GetSkill?5?$CFd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KPJAOLNB@SkillLevel2?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@HOKPNGH@DoUseSkill?5?3?5?$CFs?5dwSkillType?5?$DN?5?$CFd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@ILELHNJ@OnEndSkillState?5?3?5?$LN?$LK?E?$LD?$MA?G?5?$LJ?$PM?$MA?$KH?$LI?$KG?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLKPHDJP@OnEndSkillState?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@PPLMFBOE@GUILDHOUSE_LISTUP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01INIBCBCB@f?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HGMIEEBN@HOUSING_USE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@OINNJKEM@ANGEL_SUMMON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PNFMAOFG@?$CC?$CFd?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@COEAJDGE@USE_RECCURENCE_ITEM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@KAAKNBKL@USE_RESTATE_ITEM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PFGKEPEH@?$CFd?5?9?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DPACILDJ@?$CC?$CFs?$CC?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PGLFOAIL@?$CFs?5?$CFd?$CF?$CF?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@FCPHEJAC@DoUseItem?0?5IK2_SKILL?0?5item?5?$CFs?5?9?$DO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@GIPACFEO@II_SYS_SYS_SCR_RETURN?5selected?5v@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDNJAMCD@MaFl_InstantBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FAFPDOMC@USE_PERIN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@DCNDELEC@DoAttackRange?5?3?5?$CFs?5ActiveHandIte@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@HDIEHEPJ@DoAttackRange?5?3?5?$CFs?5?$FL?$CFd?$FN?8s?5dwUseM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@EOHFKLIK@DoAttackSP?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L?5NU@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FIKMOPND@DoAttackSP?5?3?5?$CFs?$MA?G?5?$LA?x?$LA?$NN?$CFd?$MA?G?5dwUse@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BKJEKCBD@DoAttackMelee?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@JELFJLED@CMover?3?3SendDamageAround?5?3?5D?3?$CFs?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@FEJEHPAL@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@BLLPBDJB@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BEJKIDOG@CMover?3?3SendDamageLine?5?3?5D?3?$CFs?5A?3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@KEBMKGCP@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LN?$LK?E@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@LKDJCKJ@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LO?F?$MA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@EGNMKPHL@Pet_Seltpiyo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BOLHNAPJ@Pet_Seltpudi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CNOPGOC@Pet_Seltcobi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NPNKEHMC@Pet_Seltpierce?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetOwner@CAIPet@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__MINIGAME_PACKET@@QAE@GHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MINIGMAME_PRIZE_LIST@CRainbowRaceMng@@QAE@KHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerId2CampusId@CCampusMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasInput@CUser@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChild@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChild@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChildE@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChildE@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRecvHandle@CDPSock@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@HonorData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMasterSkillPointUp@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetQueueCastingTime@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseSkill@CMover@@QAEHHHKW4SKILLUSETYPE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseSkill@CMover@@QAEHKHKW4SKILLUSETYPE@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnEndSkillState@CMover@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnEndMeleeAttack@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRemoveSfxObj@CMover@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRemoveSfxObj@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemVirtual@CMover@@QAEHKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItem@CMover@@QAEHKKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemBlinkWing@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemSystem@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemOnce@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemKeep@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDoUseBuff@CMover@@QAEHPAUItemProp@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemFood_SM@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemFood@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemSexChange@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoAttackMagic@CMover@@QAEHPAVCObj@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoAttackRange@CMover@@QAEHPAVCObj@@KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoAttackSP@CMover@@QAEHPAVCObj@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoAttackMelee@CMover@@QAEHPAV1@W4OBJMSG@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoPickupItemAround@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDamageAround@CMover@@QAEXHPAV1@HHMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDamageLine@CMover@@QAEXHHHMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemWarp@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReuseDelay@CMover@@QAEKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemFeedPocket@CMover@@QAEHPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InactivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseSystemPet@CMover@@AAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseEatPet@CMover@@AAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InactivateEatPet@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessVisPet@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InactivateBarunaPet@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSatisfyNeedVis@CMover@@QAEEPAVCItemElem@@PAUItemProp@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoUseItemPetTonic@CMover@@AAEHPAVCItemElem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAEAAPAVCCtrl@@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAU_PlayerData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAU_PlayerData@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEXABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAPAVCMiniGameBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampusMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampusMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HU__ATTRIBUTE_ENCHANT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU__ATTRIBUTE_ENCHANT@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharNextA@?$ChTraitsCRT@D@ATL@@SAPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBKPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXViterator@12@IABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE@V?$allocator@U__SECRETROOM_MONSTER@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@V312@ABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEAAPAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXViterator@12@IABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildHouseBase@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSock@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSock@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSockE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSockE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEABQAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEABUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__SECRETROOM_MONSTER@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKU_Friend@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKK@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$make_pair@KPAVCGuildHouseBase@@@std@@YA?AU?$pair@KPAVCGuildHouseBase@@@0@KPAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0KPAVCGuildHouseBase@@@?$pair@$$CBKPAVCGuildHouseBase@@@std@@QAE@ABU?$pair@KPAVCGuildHouseBase@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CFixedArray@UtagWORLD@@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UtagWORLD@@@@QAEPAUtagWORLD@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAEE@std@@YAXPAE0ABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__SECRETROOM_MONSTER@@@std@@YAPAU__SECRETROOM_MONSTER@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CFixedArray@UtagWORLD@@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCGuildHouseBase@@@std@@QAE@ABKABQAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@EIE@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SECRETROOM_MONSTER@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAEIE@std@@YAXPAEIABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SECRETROOM_MONSTER@@@std@@YAXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CFixedArray@UtagWORLD@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@E@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVisKeepTime@CItemElem@@QAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasActivatedVisPet@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPiercingItem@CItemElem@@QAEKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVisPetItem@CMover@@QAEPAVCItemElem@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVisPetItem@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsVisPet@ItemProp@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTransformVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEatPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEatPetId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasActivatedEatPet@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasActivatedSystemPet@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPetId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUserByID@CProject@@QAEPAVCMover@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRandomOptItemId@CItemElem@@QAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextNode@CObj@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDamage@CActionMover@@QAEHKKHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLive@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDie@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetType@CObj@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInst@IBuff@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTotal@IBuff@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFlag@CItemElem@@QAEHE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPKValue@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetLayer@CObj@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPartyId@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSerialNumber@CItemBase@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnergy@CPet@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExp@CPet@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLife@CPet@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStateMode@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSit@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCoolTime@ItemProp@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xRandom@@YAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFly@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetId@IBuff@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetId@CCtrl@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsActAttack@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngle@CObj@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSMMode@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPKPink@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPKPink@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsChaotic@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDest@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestObj@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestPos@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@IBuff@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDegree@@YAMABUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VelocityToVec@@YA?AUD3DXVECTOR3@@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsArena@CWorld@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPeaceful@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CMover@@QAEPAUMoverProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsInvalidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetText@CProject@@QAEPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFly@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDie@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@tagSkill@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNPC@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMapChildE@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMapChild@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBuffer2@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_EXT_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __P$[esp-4]
  00004	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?SetOwner@CAIPet@@QAEXK@Z			; CAIPet::SetOwner
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\aipet.h
;	COMDAT ?SetOwner@CAIPet@@QAEXK@Z
_TEXT	SEGMENT
_idOwner$ = 8						; size = 4
?SetOwner@CAIPet@@QAEXK@Z PROC NEAR			; CAIPet::SetOwner, COMDAT
; _this$ = ecx

; 32   : 	void	SetOwner( OBJID idOwner ) { m_idOwner = idOwner; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _idOwner$[esp-4]
  00004	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00007	c2 04 00	 ret	 4
?SetOwner@CAIPet@@QAEXK@Z ENDP				; CAIPet::SetOwner
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__InterlockedExchange@8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
EXTRN	__imp__GetThreadLocale@0:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_szACP$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax

; 102  : 	UINT nACP = 0;

  0000f	33 f6		 xor	 esi, esi

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  00017	6a 07		 push	 7
  00019	8d 4c 24 08	 lea	 ecx, DWORD PTR _szACP$[esp+20]
  0001d	51		 push	 ecx
  0001e	68 04 10 00 00	 push	 4100			; 00001004H
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  0002a	85 c0		 test	 eax, eax
  0002c	74 27		 je	 SHORT $L282081

; 111  : 	{
; 112  : 		char* pch = szACP;
; 113  : 		while (*pch != '\0')

  0002e	8a 44 24 04	 mov	 al, BYTE PTR _szACP$[esp+16]
  00032	84 c0		 test	 al, al
  00034	8d 4c 24 04	 lea	 ecx, DWORD PTR _szACP$[esp+16]
  00038	74 1b		 je	 SHORT $L282081
  0003a	8d 9b 00 00 00
	00		 npad	 6
$L38556:

; 114  : 		{
; 115  : 			nACP *= 10;
; 116  : 			nACP += *pch++ - '0';

  00040	0f be c0	 movsx	 eax, al
  00043	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  00046	41		 inc	 ecx
  00047	8d 74 50 d0	 lea	 esi, DWORD PTR [eax+edx*2-48]
  0004b	8a 01		 mov	 al, BYTE PTR [ecx]
  0004d	84 c0		 test	 al, al
  0004f	75 ef		 jne	 SHORT $L38556

; 117  : 		}
; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  00051	85 f6		 test	 esi, esi
  00053	75 16		 jne	 SHORT $L282082
$L282081:

; 121  : 		nACP = ::GetACP();

  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  0005b	5e		 pop	 esi

; 122  : 
; 123  : 	return nACP;
; 124  : }

  0005c	8b 4c 24 08	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+12]
  00060	33 cc		 xor	 ecx, esp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	c3		 ret	 0
$L282082:
  0006b	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16]
  0006f	8b c6		 mov	 eax, esi
  00071	5e		 pop	 esi
  00072	33 cc		 xor	 ecx, esp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 128  : 	return( CP_THREAD_ACP );

  00000	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00005	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_ver$ = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 94 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+152], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );
; 139  : 	::GetVersionEx( &ver );

  00014	8d 04 24	 lea	 eax, DWORD PTR _ver$[esp+152]
  00017	50		 push	 eax
  00018	c7 44 24 04 94
	00 00 00	 mov	 DWORD PTR _ver$[esp+156], 148 ; 00000094H
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00026	83 7c 24 10 02	 cmp	 DWORD PTR _ver$[esp+168], 2
  0002b	75 0c		 jne	 SHORT $L38566
  0002d	83 7c 24 04 05	 cmp	 DWORD PTR _ver$[esp+156], 5

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  00032	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal
  00037	73 05		 jae	 SHORT $L38567
$L38566:

; 144  : 	}
; 145  : 	else
; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L38567:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  00050	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  00057	33 cc		 xor	 ecx, esp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00064	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 158  : 	return( g_pfnGetThreadACP() );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L39168

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L282105:
$L39168:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L282106:
$L282104:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?HasInput@CUser@@QAEHXZ				; CUser::HasInput
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\worldserver\user.h
;	COMDAT ?HasInput@CUser@@QAEHXZ
_TEXT	SEGMENT
?HasInput@CUser@@QAEHXZ PROC NEAR			; CUser::HasInput, COMDAT
; _this$ = ecx

; 560  : 	BOOL	HasInput()	{	return m_szInput[0] != '\0';	}

  00000	8a 91 44 96 00
	00		 mov	 dl, BYTE PTR [ecx+38468]
  00006	33 c0		 xor	 eax, eax
  00008	84 d2		 test	 dl, dl
  0000a	0f 95 c0	 setne	 al
  0000d	c3		 ret	 0
?HasInput@CUser@@QAEHXZ ENDP				; CUser::HasInput
_TEXT	ENDS
PUBLIC	?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
EXTRN	__imp__LockResource@4:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_hResource$ = 12					; size = 4
_id$ = 16						; size = 4
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z PROC NEAR ; ATL::_AtlGetStringResourceImage, COMDAT

; 239  : {

  00000	53		 push	 ebx

; 240  : 	const ATLSTRINGRESOURCEIMAGE* pImage;
; 241  : 	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
; 242  : 	ULONG nResourceSize;
; 243  : 	HGLOBAL hGlobal;
; 244  : 	UINT iIndex;
; 245  : 
; 246  : 	hGlobal = ::LoadResource( hInstance, hResource );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _hInstance$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR _hResource$[esp+4]
  0000a	57		 push	 edi
  0000b	53		 push	 ebx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8

; 247  : 	if( hGlobal == NULL )

  00012	85 c0		 test	 eax, eax
  00014	75 03		 jne	 SHORT $L39522
  00016	5f		 pop	 edi
  00017	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  00018	c3		 ret	 0
$L39522:
  00019	56		 push	 esi

; 248  : 	{
; 249  : 		return( NULL );
; 250  : 	}
; 251  : 
; 252  : 	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );

  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  00021	8b f0		 mov	 esi, eax

; 253  : 	if( pImage == NULL )

  00023	85 f6		 test	 esi, esi
  00025	75 06		 jne	 SHORT $L39524
$L282115:
  00027	5e		 pop	 esi
  00028	5f		 pop	 edi

; 254  : 	{
; 255  : 		return( NULL );

  00029	33 c0		 xor	 eax, eax
  0002b	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  0002c	c3		 ret	 0
$L39524:

; 256  : 	}
; 257  : 
; 258  : 	nResourceSize = ::SizeofResource( hInstance, hResource );

  0002d	57		 push	 edi
  0002e	53		 push	 ebx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8

; 259  : 	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);
; 260  : 	iIndex = id&0x000f;

  00035	8b 4c 24 18	 mov	 ecx, DWORD PTR _id$[esp+8]
  00039	03 c6		 add	 eax, esi
  0003b	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 261  : 
; 262  : 	while( (iIndex > 0) && (pImage < pImageEnd) )

  0003e	76 0e		 jbe	 SHORT $L39528
$L39527:
  00040	3b f0		 cmp	 esi, eax
  00042	73 e3		 jae	 SHORT $L282115

; 263  : 	{
; 264  : 		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));
; 265  : 		iIndex--;

  00044	49		 dec	 ecx
  00045	0f b7 16	 movzx	 edx, WORD PTR [esi]
  00048	8d 74 56 02	 lea	 esi, DWORD PTR [esi+edx*2+2]
  0004c	75 f2		 jne	 SHORT $L39527
$L39528:

; 266  : 	}
; 267  : 	if( pImage >= pImageEnd )

  0004e	3b f0		 cmp	 esi, eax

; 268  : 	{
; 269  : 		return( NULL );

  00050	73 d5		 jae	 SHORT $L282115

; 270  : 	}
; 271  : 	if( pImage->nLength == 0 )

  00052	66 8b 06	 mov	 ax, WORD PTR [esi]
  00055	66 f7 d8	 neg	 ax
  00058	1b c0		 sbb	 eax, eax
  0005a	23 c6		 and	 eax, esi
  0005c	5e		 pop	 esi
  0005d	5f		 pop	 edi
  0005e	5b		 pop	 ebx

; 272  : 	{
; 273  : 		return( NULL );
; 274  : 	}
; 275  : 
; 276  : 	return( pImage );
; 277  : }

  0005f	c3		 ret	 0
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ENDP ; ATL::_AtlGetStringResourceImage
_TEXT	ENDS
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
EXTRN	__imp__FindResourceA@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_id$ = 12						; size = 4
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z PROC NEAR ; ATL::AtlGetStringResourceImage, COMDAT

; 280  : {

  00000	56		 push	 esi

; 281  : 	HRSRC hResource;
; 282  : 
; 283  : 	hResource = ::FindResource( hInstance, MAKEINTRESOURCE( ((id>>4)+1) ), RT_STRING );

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _id$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	c1 e8 04	 shr	 eax, 4
  0000a	57		 push	 edi
  0000b	8b 7c 24 0c	 mov	 edi, DWORD PTR _hInstance$[esp+4]
  0000f	40		 inc	 eax
  00010	0f b7 c8	 movzx	 ecx, ax
  00013	6a 06		 push	 6
  00015	51		 push	 ecx
  00016	57		 push	 edi
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12

; 284  : 	if( hResource == NULL )

  0001d	85 c0		 test	 eax, eax
  0001f	75 03		 jne	 SHORT $L39545
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 290  : }

  00023	c3		 ret	 0
$L39545:

; 285  : 	{
; 286  : 		return( NULL );
; 287  : 	}
; 288  : 
; 289  : 	return _AtlGetStringResourceImage( hInstance, hResource, id );

  00024	56		 push	 esi
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 290  : }

  00031	c3		 ret	 0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ENDP ; ATL::AtlGetStringResourceImage
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 66   : 		return (this+1);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 67   : 	}

  00003	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 76   : 		return nRefs < 0;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 9c c0	 setl	 al

; 77   : 	}

  0000a	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Ogty
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 80   : 		return( nRefs > 1 ); 

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 01	 cmp	 edx, 1
  00008	0f 9f c0	 setg	 al

; 81   : 	}

  0000b	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Ogty
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	4a		 dec	 edx
  0000b	85 d2		 test	 edx, edx
  0000d	7f 0a		 jg	 SHORT $L39885

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b c8		 mov	 ecx, eax
  00016	ff 52 04	 call	 DWORD PTR [edx+4]
$L39885:

; 98   : 		}
; 99   : 	}

  00019	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z ; CInstanceDungeonHelper::IsInstanceDungeon
EXTRN	?GetType@CInstanceDungeonHelper@@AAEHK@Z:NEAR	; CInstanceDungeonHelper::GetType
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\instancedungeonbase.h
;	COMDAT ?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z
_TEXT	SEGMENT
_dwWorldId$ = 8						; size = 4
?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z PROC NEAR ; CInstanceDungeonHelper::IsInstanceDungeon, COMDAT
; _this$ = ecx

; 205  : 	BOOL	IsInstanceDungeon( DWORD dwWorldId )	{ return GetType( dwWorldId ) != NULL_ID; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwWorldId$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?GetType@CInstanceDungeonHelper@@AAEHK@Z ; CInstanceDungeonHelper::GetType
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	0f 95 c1	 setne	 cl
  00012	8b c1		 mov	 eax, ecx
  00014	c2 04 00	 ret	 4
?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z ENDP	; CInstanceDungeonHelper::IsInstanceDungeon
_TEXT	ENDS
PUBLIC	??0CTimeSpan@ATL@@QAE@JHHH@Z			; ATL::CTimeSpan::CTimeSpan
EXTRN	__allmul:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT
_lDays$ = 8						; size = 4
_nHours$ = 12						; size = 4
_nMins$ = 16						; size = 4
_nSecs$ = 20						; size = 4
??0CTimeSpan@ATL@@QAE@JHHH@Z PROC NEAR			; ATL::CTimeSpan::CTimeSpan, COMDAT
; _this$ = ecx

; 38   :  	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lDays$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	6a 00		 push	 0
  00008	99		 cdq
  00009	6a 18		 push	 24			; 00000018H
  0000b	52		 push	 edx
  0000c	50		 push	 eax
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 __allmul
  00014	8b c8		 mov	 ecx, eax
  00016	8b 44 24 10	 mov	 eax, DWORD PTR _nHours$[esp+4]
  0001a	8b fa		 mov	 edi, edx
  0001c	99		 cdq
  0001d	6a 00		 push	 0
  0001f	03 c8		 add	 ecx, eax
  00021	6a 3c		 push	 60			; 0000003cH
  00023	13 fa		 adc	 edi, edx
  00025	57		 push	 edi
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 __allmul
  0002c	8b c8		 mov	 ecx, eax
  0002e	8b 44 24 14	 mov	 eax, DWORD PTR _nMins$[esp+4]
  00032	8b fa		 mov	 edi, edx
  00034	99		 cdq
  00035	6a 00		 push	 0
  00037	03 c8		 add	 ecx, eax
  00039	6a 3c		 push	 60			; 0000003cH
  0003b	13 fa		 adc	 edi, edx
  0003d	57		 push	 edi
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 __allmul
  00044	8b c8		 mov	 ecx, eax
  00046	8b 44 24 18	 mov	 eax, DWORD PTR _nSecs$[esp+4]
  0004a	8b fa		 mov	 edi, edx
  0004c	99		 cdq
  0004d	03 c8		 add	 ecx, eax
  0004f	13 fa		 adc	 edi, edx
  00051	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00054	5f		 pop	 edi
  00055	89 0e		 mov	 DWORD PTR [esi], ecx

; 39   : }

  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	c2 10 00	 ret	 16			; 00000010H
??0CTimeSpan@ATL@@QAE@JHHH@Z ENDP			; ATL::CTimeSpan::CTimeSpan
_TEXT	ENDS
PUBLIC	?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ		; ATL::CTimeSpan::GetTimeSpan
; Function compile flags: /Ogty
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ PROC NEAR		; ATL::CTimeSpan::GetTimeSpan, COMDAT
; _this$ = ecx

; 78   : 	return( m_timeSpan );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 79   : }

  00005	c3		 ret	 0
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ ENDP		; ATL::CTimeSpan::GetTimeSpan
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
; Function compile flags: /Ogty
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 167  : {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _time$[esp]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _time$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 168  : }

  0000f	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z		; ATL::CTime::operator+
; Function compile flags: /Ogty
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_span$ = 12						; size = 8
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z PROC NEAR	; ATL::CTime::operator+, COMDAT
; _this$ = ecx

; 286  : 	return( CTime( m_time+span.GetTimeSpan() ) );

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 44 24 08	 mov	 eax, DWORD PTR _span$[esp-4]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	03 d0		 add	 edx, eax
  0000b	13 4c 24 0c	 adc	 ecx, DWORD PTR _span$[esp]
  0000f	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00013	89 10		 mov	 DWORD PTR [eax], edx
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 287  : }

  00018	c2 0c 00	 ret	 12			; 0000000cH
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z ENDP		; ATL::CTime::operator+
_TEXT	ENDS
PUBLIC	?OnEndMeleeAttack@CMover@@QAEXK@Z		; CMover::OnEndMeleeAttack
EXTRN	?PostAIMsg@CMover@@QAEXKKKK@Z:NEAR		; CMover::PostAIMsg
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
;	COMDAT ?OnEndMeleeAttack@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwState$ = 8						; size = 4
?OnEndMeleeAttack@CMover@@QAEXK@Z PROC NEAR		; CMover::OnEndMeleeAttack, COMDAT
; _this$ = ecx

; 1160 : #ifdef __WORLDSERVER
; 1161 : 	PostAIMsg( AIMSG_END_MELEEATTACK );

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	6a 00		 push	 0
  00006	6a 0f		 push	 15			; 0000000fH
  00008	e8 00 00 00 00	 call	 ?PostAIMsg@CMover@@QAEXKKKK@Z ; CMover::PostAIMsg

; 1162 : #endif // WorldServer
; 1163 : }

  0000d	c2 04 00	 ret	 4
?OnEndMeleeAttack@CMover@@QAEXK@Z ENDP			; CMover::OnEndMeleeAttack
_TEXT	ENDS
PUBLIC	?GetRemoveSfxObj@CMover@@QAEKK@Z		; CMover::GetRemoveSfxObj
; Function compile flags: /Ogty
;	COMDAT ?GetRemoveSfxObj@CMover@@QAEKK@Z
_TEXT	SEGMENT
_dwRemoveSfxObjID$ = 8					; size = 4
?GetRemoveSfxObj@CMover@@QAEKK@Z PROC NEAR		; CMover::GetRemoveSfxObj, COMDAT
; _this$ = ecx

; 1167 : {

  00000	56		 push	 esi

; 1168 : 	DWORD	dwResult = 0;
; 1169 : 	for(int i=0;i<MAX_SKILLBUFF_COUNT;i++)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _dwRemoveSfxObjID$[esp]
  00005	33 d2		 xor	 edx, edx
  00007	8d 81 78 07 00
	00		 lea	 eax, DWORD PTR [ecx+1912]
  0000d	8d 49 00	 npad	 3
$L274581:

; 1170 : 	{
; 1171 : 		if(dwRemoveSfxObj[i] ==  dwRemoveSfxObjID)

  00010	39 30		 cmp	 DWORD PTR [eax], esi
  00012	74 0f		 je	 SHORT $L282162
  00014	42		 inc	 edx
  00015	83 c0 04	 add	 eax, 4
  00018	83 fa 63	 cmp	 edx, 99			; 00000063H
  0001b	7c f3		 jl	 SHORT $L274581

; 1175 : 			return	dwResult;
; 1176 : 		}
; 1177 : 	}	
; 1178 : 	return	dwResult;	

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 1179 : }

  00020	c2 04 00	 ret	 4
$L282162:

; 1172 : 		{
; 1173 : 			dwResult = dwRemoveSfxObj[i];

  00023	8b 84 91 78 07
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+1912]

; 1174 : 			dwRemoveSfxObj[i] = 0;

  0002a	c7 84 91 78 07
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+edx*4+1912], 0
  00035	5e		 pop	 esi

; 1179 : }

  00036	c2 04 00	 ret	 4
?GetRemoveSfxObj@CMover@@QAEKK@Z ENDP			; CMover::GetRemoveSfxObj
_TEXT	ENDS
PUBLIC	?GetTime@CTime@ATL@@QBE_JXZ			; ATL::CTime::GetTime
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTime@CTime@ATL@@QBE_JXZ PROC NEAR			; ATL::CTime::GetTime, COMDAT
; _this$ = ecx

; 372  : 	return( m_time );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 373  : }

  00005	c3		 ret	 0
?GetTime@CTime@ATL@@QBE_JXZ ENDP			; ATL::CTime::GetTime
_TEXT	ENDS
PUBLIC	?SetRemoveSfxObj@CMover@@QAEXK@Z		; CMover::SetRemoveSfxObj
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
;	COMDAT ?SetRemoveSfxObj@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwRemoveSfxObjID$ = 8					; size = 4
?SetRemoveSfxObj@CMover@@QAEXK@Z PROC NEAR		; CMover::SetRemoveSfxObj, COMDAT
; _this$ = ecx

; 1182 : {

  00000	56		 push	 esi

; 1183 : 	for(int i=0;i<MAX_SKILLBUFF_COUNT;i++)

  00001	8d 91 78 07 00
	00		 lea	 edx, DWORD PTR [ecx+1912]
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR _dwRemoveSfxObjID$[esp+4]
  0000c	33 c0		 xor	 eax, eax
  0000e	8b f2		 mov	 esi, edx
$L274590:

; 1184 : 	{
; 1185 : 		if(dwRemoveSfxObj[i] ==  dwRemoveSfxObjID)

  00010	39 3e		 cmp	 DWORD PTR [esi], edi
  00012	74 26		 je	 SHORT $L274596
  00014	40		 inc	 eax
  00015	83 c6 04	 add	 esi, 4
  00018	83 f8 63	 cmp	 eax, 99			; 00000063H
  0001b	7c f3		 jl	 SHORT $L274590

; 1186 : 			return;
; 1187 : 	}
; 1188 : 	for( i=0;i<MAX_SKILLBUFF_COUNT;i++)

  0001d	33 c0		 xor	 eax, eax
  0001f	90		 npad	 1
$L274594:

; 1189 : 	{
; 1190 : 		if(dwRemoveSfxObj[i] ==  0)

  00020	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00023	74 0e		 je	 SHORT $L282173
  00025	40		 inc	 eax
  00026	83 c2 04	 add	 edx, 4
  00029	83 f8 63	 cmp	 eax, 99			; 00000063H
  0002c	7c f2		 jl	 SHORT $L274594
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 1193 : 			return;
; 1194 : 		}
; 1195 : 	}
; 1196 : }

  00030	c2 04 00	 ret	 4
$L282173:

; 1191 : 		{
; 1192 : 			dwRemoveSfxObj[i] = dwRemoveSfxObjID;

  00033	89 bc 81 78 07
	00 00		 mov	 DWORD PTR [ecx+eax*4+1912], edi
$L274596:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 1193 : 			return;
; 1194 : 		}
; 1195 : 	}
; 1196 : }

  0003c	c2 04 00	 ret	 4
?SetRemoveSfxObj@CMover@@QAEXK@Z ENDP			; CMover::SetRemoveSfxObj
_TEXT	ENDS
PUBLIC	?DoUseItemOnce@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemOnce
EXTRN	?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z:NEAR ; CCtrl::DoApplySkill
EXTRN	?HasBuffByIk3@CMover@@QAEHK@Z:NEAR		; CMover::HasBuffByIk3
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemOnce@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT
_pItemProp$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
_nPart$ = 16						; size = 4
?DoUseItemOnce@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z PROC NEAR ; CMover::DoUseItemOnce, COMDAT
; _this$ = ecx

; 2985 : {

  00000	53		 push	 ebx

; 2986 : 	int nResult = 0;
; 2987 : #ifdef __WORLDSERVER
; 2988 : 	if( HasBuffByIk3( pItemProp->dwItemKind3 ))

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _pItemProp$[esp]
  00005	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	33 ff		 xor	 edi, edi
  0000f	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  00014	85 c0		 test	 eax, eax
  00016	74 0b		 je	 SHORT $L275212
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi

; 2989 : 		nResult = 2;

  0001a	b8 02 00 00 00	 mov	 eax, 2
  0001f	5b		 pop	 ebx

; 2994 : }

  00020	c2 0c 00	 ret	 12			; 0000000cH
$L275212:

; 2990 : 	else
; 2991 : 		DoApplySkill( (CCtrl*)this, pItemProp, NULL );

  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	53		 push	 ebx
  0002e	56		 push	 esi
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill

; 2992 : #endif // __WORLDSERVER
; 2993 : 	return nResult;

  00036	8b c7		 mov	 eax, edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx

; 2994 : }

  0003b	c2 0c 00	 ret	 12			; 0000000cH
?DoUseItemOnce@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ENDP ; CMover::DoUseItemOnce
_TEXT	ENDS
PUBLIC	?DoPickupItemAround@CMover@@QAEXXZ		; CMover::DoPickupItemAround
; Function compile flags: /Ogty
;	COMDAT ?DoPickupItemAround@CMover@@QAEXXZ
_TEXT	SEGMENT
?DoPickupItemAround@CMover@@QAEXXZ PROC NEAR		; CMover::DoPickupItemAround, COMDAT
; _this$ = ecx

; 3746 : #ifdef __CLIENT
; 3747 : 	if( m_pActMover->IsActAttack() )	return;		//  .
; 3748 : 	if( IsDie() )		return;						//  .
; 3749 : 	
; 3750 : 	int nRange	= 4;	// 4m
; 3751 : 	float fDistMin = 99999.0f, fDistSq;
; 3752 : 	CObj* pObj, *pMinObj = NULL;
; 3753 : 	D3DXVECTOR3 vPos = GetPos();
; 3754 : 	D3DXVECTOR3 vDist;
; 3755 : 	FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkDynamic, GetLayer() )
; 3756 : 	{
; 3757 : 		if( pObj->GetType() == OT_ITEM )
; 3758 : 		{
; 3759 : 			vDist = pObj->GetPos() - vPos;		// this ->  
; 3760 : 			fDistSq = D3DXVec3LengthSq( &vDist );
; 3761 : 			if( fDistSq < 4.0f * 4.0f )		//   x  .
; 3762 : 			{
; 3763 : 				if( fDistSq < fDistMin )	//    
; 3764 : 				{
; 3765 : 					fDistMin = fDistSq;
; 3766 : 					pMinObj = pObj;
; 3767 : 				}
; 3768 : 			}
; 3769 : 		}
; 3770 : 	}
; 3771 : 	END_LINKMAP
; 3772 : 
; 3773 : 	//   .
; 3774 : 	if( pMinObj )
; 3775 : 	{
; 3776 : 		CMD_SetUseItem( (CCtrl*)pMinObj );
; 3777 : 	}
; 3778 : #endif // __CLIENT
; 3779 : }

  00000	c3		 ret	 0
?DoPickupItemAround@CMover@@QAEXXZ ENDP			; CMover::DoPickupItemAround
_TEXT	ENDS
PUBLIC	?GetReuseDelay@CMover@@QAEKH@Z			; CMover::GetReuseDelay
EXTRN	__imp__timeGetTime@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetReuseDelay@CMover@@QAEKH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetReuseDelay@CMover@@QAEKH@Z PROC NEAR		; CMover::GetReuseDelay, COMDAT
; _this$ = ecx

; 4165 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4166 : 	ASSERT( nIndex >= 0 );	
; 4167 : 
; 4168 : 	DWORD dwCur = ::timeGetTime();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00009	8b c8		 mov	 ecx, eax

; 4169 : 	if( dwCur > m_tmReUseDelay[nIndex] )	//      

  0000b	8b 44 24 08	 mov	 eax, DWORD PTR _nIndex$[esp]
  0000f	8b 84 86 04 05
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+1284]
  00016	3b c8		 cmp	 ecx, eax
  00018	5e		 pop	 esi
  00019	76 05		 jbe	 SHORT $L275978

; 4170 : 		return 0;								//  .

  0001b	33 c0		 xor	 eax, eax

; 4173 : }

  0001d	c2 04 00	 ret	 4
$L275978:

; 4171 : 	else									//  
; 4172 : 		return m_tmReUseDelay[nIndex] - dwCur;	//  -  

  00020	2b c1		 sub	 eax, ecx

; 4173 : }

  00022	c2 04 00	 ret	 4
?GetReuseDelay@CMover@@QAEKH@Z ENDP			; CMover::GetReuseDelay
_TEXT	ENDS
PUBLIC	?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ	; CItemContainer<CItemElem>::GetMax
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ PROC NEAR	; CItemContainer<CItemElem>::GetMax, COMDAT
; _this$ = ecx

; 412  : 	int		GetMax() { return int( m_dwItemMax ); }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ ENDP	; CItemContainer<CItemElem>::GetMax
_TEXT	ENDS
PUBLIC	?CharNextA@?$ChTraitsCRT@D@ATL@@SAPADPBD@Z	; ATL::ChTraitsCRT<char>::CharNextA
EXTRN	__mbsinc:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharNextA@?$ChTraitsCRT@D@ATL@@SAPADPBD@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?CharNextA@?$ChTraitsCRT@D@ATL@@SAPADPBD@Z PROC NEAR	; ATL::ChTraitsCRT<char>::CharNextA, COMDAT

; 321  : 		return reinterpret_cast< char* >( _mbsinc( reinterpret_cast< const unsigned char* >( p ) ) );

  00000	e9 00 00 00 00	 jmp	 __mbsinc
?CharNextA@?$ChTraitsCRT@D@ATL@@SAPADPBD@Z ENDP		; ATL::ChTraitsCRT<char>::CharNextA
_TEXT	ENDS
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@XZ PROC NEAR			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L282204
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L282204:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx

; 459  : 		}

  0000f	c3		 ret	 0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@@Z ; std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@@Z ENDP ; std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00008	03 d1		 add	 edx, ecx
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000c	c2 04 00	 ret	 4
??Yiterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 156  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwItemId$ = 8						; size = 4
?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtItemId, COMDAT
; _this$ = ecx

; 531  : 	}
; 532  : 	return NULL;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	56		 push	 esi
  00004	33 c0		 xor	 eax, eax
  00006	85 d2		 test	 edx, edx
  00008	57		 push	 edi
  00009	76 19		 jbe	 SHORT $L279383
  0000b	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  0000e	8b 7c 24 0c	 mov	 edi, DWORD PTR _dwItemId$[esp+4]
  00012	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
$L279381:
  00015	39 39		 cmp	 DWORD PTR [ecx], edi
  00017	74 12		 je	 SHORT $L282246
  00019	40		 inc	 eax
  0001a	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00020	3b c2		 cmp	 eax, edx
  00022	72 f1		 jb	 SHORT $L279381
$L279383:
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	33 c0		 xor	 eax, eax

; 533  : }

  00028	c2 04 00	 ret	 4
$L282246:

; 527  : 	for( DWORD i = 0; i < m_dwItemMax; i++ )
; 528  : 	{
; 529  : 		if( m_apItem[i].m_dwItemId == dwItemId )
; 530  : 			return &m_apItem[i];

  0002b	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00031	5f		 pop	 edi
  00032	03 c6		 add	 eax, esi
  00034	5e		 pop	 esi

; 533  : }

  00035	c2 04 00	 ret	 4
?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAtItemId
_TEXT	ENDS
PUBLIC	??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 331  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl

; 332  : 		}

  0000c	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogty
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 352  : 		return (::strlen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L282258:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $L282258
  0000e	2b c2		 sub	 eax, edx

; 353  : 		}

  00010	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Ogty
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __First2$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __First1$[esp+4]
  0000e	8b c1		 mov	 eax, ecx
  00010	8b d7		 mov	 edx, edi
  00012	c1 e9 02	 shr	 ecx, 2
  00015	f3 a5		 rep movsd
  00017	8b c8		 mov	 ecx, eax
  00019	83 e1 03	 and	 ecx, 3
  0001c	f3 a4		 rep movsb
  0001e	5f		 pop	 edi
  0001f	8b c2		 mov	 eax, edx
  00021	5e		 pop	 esi

; 359  : 		}

  00022	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

  00000	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	??$fill@PAEE@std@@YAXPAE0ABE@Z			; std::fill<unsigned char *,unsigned char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill@PAEE@std@@YAXPAE0ABE@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAEE@std@@YAXPAE0ABE@Z PROC NEAR		; std::fill<unsigned char *,unsigned char>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 0f		 je	 SHORT $L279758
  0000c	56		 push	 esi
  0000d	8b 74 24 10	 mov	 esi, DWORD PTR __Val$[esp]
$L279756:

; 1136 : 		*_First = _Val;

  00011	8a 16		 mov	 dl, BYTE PTR [esi]
  00013	88 10		 mov	 BYTE PTR [eax], dl
  00015	40		 inc	 eax
  00016	3b c1		 cmp	 eax, ecx
  00018	75 f7		 jne	 SHORT $L279756
  0001a	5e		 pop	 esi
$L279758:

; 1137 : 	}

  0001b	c3		 ret	 0
??$fill@PAEE@std@@YAXPAE0ABE@Z ENDP			; std::fill<unsigned char *,unsigned char>
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 282  : 	{	// return pointer category from pointer to unsigned char arguments

  00000	51		 push	 ecx

; 283  : 	_Scalar_ptr_iterator_tag _Cat;
; 284  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 285  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z ; std::_Ptr_cat<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *>
; Function compile flags: /Ogty
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z PROC NEAR ; std::_Ptr_cat<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	51		 push	 ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z ENDP ; std::_Ptr_cat<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,unsigned char *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<unsigned char *,unsigned char *>, COMDAT

; 1031 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Last$[esp]
  00009	2b f0		 sub	 esi, eax

; 1032 : 	return ((_OutIt)::memmove(&*_Dest, &*_First,
; 1033 : 		_Off * sizeof (*_First)) + _Off);

  0000b	56		 push	 esi
  0000c	50		 push	 eax
  0000d	8b 44 24 18	 mov	 eax, DWORD PTR __Dest$[esp+8]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memmove
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	03 c6		 add	 eax, esi
  0001c	5e		 pop	 esi

; 1034 : 	}

  0001d	c3		 ret	 0
??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned char *,unsigned char *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<unsigned char *,unsigned char *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00010	2b c8		 sub	 ecx, eax
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  0001b	c3		 ret	 0
??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 91   : 			{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 92   : 			++_Myptr;

  00002	ff 00		 inc	 DWORD PTR [eax]

; 93   : 			return (*this);
; 94   : 			}

  00004	c3		 ret	 0
??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned char,unsigned char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<unsigned char,unsigned char>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Last$[esp]
  00009	2b f0		 sub	 esi, eax

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000b	56		 push	 esi
  0000c	50		 push	 eax
  0000d	8b 44 24 18	 mov	 eax, DWORD PTR __Dest$[esp+8]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memmove
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	03 c6		 add	 eax, esi
  0001c	5e		 pop	 esi

; 109  : 	}

  0001d	c3		 ret	 0
??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned char,unsigned char>
_TEXT	ENDS
PUBLIC	??$fill_n@PAEIE@std@@YAXPAEIABE@Z		; std::fill_n<unsigned char *,unsigned int,unsigned char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill_n@PAEIE@std@@YAXPAEIABE@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAEIE@std@@YAXPAEIABE@Z PROC NEAR		; std::fill_n<unsigned char *,unsigned int,unsigned char>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 12		 jbe	 SHORT $L280722
  00008	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 10	 mov	 esi, DWORD PTR __Val$[esp]
$L280720:

; 1161 : 		*_First = _Val;

  00011	8a 16		 mov	 dl, BYTE PTR [esi]
  00013	88 10		 mov	 BYTE PTR [eax], dl
  00015	40		 inc	 eax
  00016	49		 dec	 ecx
  00017	75 f8		 jne	 SHORT $L280720
  00019	5e		 pop	 esi
$L280722:

; 1162 : 	}

  0001a	c3		 ret	 0
??$fill_n@PAEIE@std@@YAXPAEIABE@Z ENDP			; std::fill_n<unsigned char *,unsigned int,unsigned char>
_TEXT	ENDS
PUBLIC	??$_Construct@EE@std@@YAXPAEABE@Z		; std::_Construct<unsigned char,unsigned char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@EE@std@@YAXPAEABE@Z PROC NEAR		; std::_Construct<unsigned char,unsigned char>, COMDAT

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L282298
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000e	88 10		 mov	 BYTE PTR [eax], dl
$L282298:

; 43   : 	}

  00010	c3		 ret	 0
??$_Construct@EE@std@@YAXPAEABE@Z ENDP			; std::_Construct<unsigned char,unsigned char>
_TEXT	ENDS
PUBLIC	??$_Destroy@E@std@@YAXPAE@Z			; std::_Destroy<unsigned char>
; Function compile flags: /Ogty
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@E@std@@YAXPAE@Z PROC NEAR			; std::_Destroy<unsigned char>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@E@std@@YAXPAE@Z ENDP			; std::_Destroy<unsigned char>
_TEXT	ENDS
PUBLIC	_acosf
EXTRN	__CIacos:NEAR
EXTRN	__fltused:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT _acosf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_acosf	PROC NEAR					; COMDAT

; 434  :         {return ((float)acos((double)_X)); }

  00000	d9 44 24 04	 fld	 DWORD PTR __X$[esp-4]
  00004	e8 00 00 00 00	 call	 __CIacos
  00009	c3		 ret	 0
_acosf	ENDP
_TEXT	ENDS
PUBLIC	_cosf
; Function compile flags: /Ogty
;	COMDAT _cosf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_cosf	PROC NEAR					; COMDAT

; 444  :         {return ((float)cos((double)_X)); }

  00000	d9 44 24 04	 fld	 DWORD PTR __X$[esp-4]
  00004	d9 ff		 fcos
  00006	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
PUBLIC	_sinf
; Function compile flags: /Ogty
;	COMDAT _sinf
_TEXT	SEGMENT
__X$ = 8						; size = 4
_sinf	PROC NEAR					; COMDAT

; 466  :         {return ((float)sin((double)_X)); }

  00000	d9 44 24 04	 fld	 DWORD PTR __X$[esp-4]
  00004	d9 fe		 fsin
  00006	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 165  :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
; Function compile flags: /Ogty
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC NEAR				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 313  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 300  :     x = fx;
; 301  :     y = fy;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _fy$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _fx$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 302  :     z = fz;

  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _fz$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 303  : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
; Function compile flags: /Ogty
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 377  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _v$[esp-4]
  00004	d9 40 08	 fld	 DWORD PTR [eax+8]
  00007	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  0000a	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000d	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00010	d9 00		 fld	 DWORD PTR [eax]
  00012	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00016	d8 01		 fadd	 DWORD PTR [ecx]
  00018	d9 18		 fstp	 DWORD PTR [eax]
  0001a	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0001d	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 378  : }

  00020	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
; Function compile flags: /Ogty
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC NEAR		; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 383  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00000	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00003	8b 44 24 08	 mov	 eax, DWORD PTR _v$[esp-4]
  00007	d8 60 08	 fsub	 DWORD PTR [eax+8]
  0000a	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000d	d8 60 04	 fsub	 DWORD PTR [eax+4]
  00010	d9 01		 fld	 DWORD PTR [ecx]
  00012	d8 20		 fsub	 DWORD PTR [eax]
  00014	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00018	d9 18		 fstp	 DWORD PTR [eax]
  0001a	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0001d	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 384  : }

  00020	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
; Function compile flags: /Ogty
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC NEAR	; D3DXVec3LengthSq, COMDAT

; 1693 : #ifdef D3DX_DEBUG
; 1694 :     if(!pV)
; 1695 :         return 0.0f;
; 1696 : #endif
; 1697 : 
; 1698 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pV$[esp-4]
  00004	d9 40 08	 fld	 DWORD PTR [eax+8]
  00007	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000a	d9 00		 fld	 DWORD PTR [eax]
  0000c	d9 c0		 fld	 ST(0)
  0000e	d8 c9		 fmul	 ST(0), ST(1)
  00010	d9 c2		 fld	 ST(2)
  00012	d8 cb		 fmul	 ST(0), ST(3)
  00014	de c1		 faddp	 ST(1), ST(0)
  00016	d9 c3		 fld	 ST(3)
  00018	d8 cc		 fmul	 ST(0), ST(4)
  0001a	de c1		 faddp	 ST(1), ST(0)
  0001c	dd db		 fstp	 ST(3)
  0001e	dd d8		 fstp	 ST(0)
  00020	dd d8		 fstp	 ST(0)

; 1699 : }

  00022	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
PUBLIC	?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z		; D3DXVec3Dot
; Function compile flags: /Ogty
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z PROC NEAR		; D3DXVec3Dot, COMDAT

; 1704 : #ifdef D3DX_DEBUG
; 1705 :     if(!pV1 || !pV2)
; 1706 :         return 0.0f;
; 1707 : #endif
; 1708 : 
; 1709 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pV1$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _pV2$[esp-4]
  00008	d9 40 08	 fld	 DWORD PTR [eax+8]
  0000b	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  0000e	d9 40 04	 fld	 DWORD PTR [eax+4]
  00011	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00014	de c1		 faddp	 ST(1), ST(0)
  00016	d9 00		 fld	 DWORD PTR [eax]
  00018	d8 09		 fmul	 DWORD PTR [ecx]
  0001a	de c1		 faddp	 ST(1), ST(0)

; 1710 : }

  0001c	c3		 ret	 0
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z ENDP		; D3DXVec3Dot
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0_LogItemInfo@@QAE@XZ				; _LogItemInfo::_LogItemInfo
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\cmnhdr.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT
??0_LogItemInfo@@QAE@XZ PROC NEAR			; _LogItemInfo::_LogItemInfo, COMDAT
; _this$ = ecx

; 641  : 	_LogItemInfo()

  00000	8b c1		 mov	 eax, ecx
  00002	56		 push	 esi

; 642  : 	{
; 643  : 		Action = _T("");
; 644  : 		SendName = _T("");
; 645  : 		RecvName = _T("");
; 646  : 		WorldId = Gold = Gold2 = 0;
; 647  : 		Negudo = 0;
; 648  : 		MaxNegudo = 0;
; 649  : 		ItemNo = 0;
; 650  : 		//ItemName = _T("");
; 651  : 		::memset( szItemName, 0, sizeof(szItemName) );

  00003	33 d2		 xor	 edx, edx
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00012	33 c9		 xor	 ecx, ecx
  00014	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00017	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001d	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00020	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00023	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00026	8d 70 24	 lea	 esi, DWORD PTR [eax+36]
  00029	89 16		 mov	 DWORD PTR [esi], edx
  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0002e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00031	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00034	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00037	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0003a	89 56 18	 mov	 DWORD PTR [esi+24], edx
  0003d	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 652  : 		itemNumber = 0;

  00040	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 653  : 		nAbilityOption = 0;

  00043	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 654  : 		Gold_1 = 0;

  00046	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 655  : 		nSlot = 100;
; 656  : 		nSlot1 = 100;
; 657  : 		nItemResist = 0;

  00049	89 48 58	 mov	 DWORD PTR [eax+88], ecx

; 658  : 		nResistAbilityOption = 0;

  0004c	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 659  : 		m_bCharged = FALSE;

  0004f	89 48 60	 mov	 DWORD PTR [eax+96], ecx

; 660  : 		m_dwKeepTime = 0;

  00052	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 661  : #if __VER >= 11 // __SYS_IDENTIFY
; 662  : 		m_iRandomOptItemId = 0;

  00055	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00058	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 663  : #else	//__SYS_IDENTIFY
; 664  : 		m_nRandomOptItemId = 0;
; 665  : #endif	// __SYS_IDENTIFY
; 666  : #if __VER >= 12 // __EXT_PIERCING
; 667  : 		nPiercedSize = 0;

  0005b	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  0005e	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00063	89 50 50	 mov	 DWORD PTR [eax+80], edx
  00066	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 668  : //		for( int i=0; i<MAX_PIERCING_WEAPON; i++ )
; 669  : //			adwItemId[i] = 0;
; 670  : 		memset( adwItemId, 0, sizeof(adwItemId) );

  00069	33 d2		 xor	 edx, edx
  0006b	8d 70 74	 lea	 esi, DWORD PTR [eax+116]
  0006e	89 16		 mov	 DWORD PTR [esi], edx
  00070	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00073	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00076	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00079	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0007c	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0007f	89 56 18	 mov	 DWORD PTR [esi+24], edx
  00082	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  00085	89 56 20	 mov	 DWORD PTR [esi+32], edx
  00088	89 56 24	 mov	 DWORD PTR [esi+36], edx

; 671  : 		nUMPiercedSize = 0;

  0008b	89 88 9c 00 00
	00		 mov	 DWORD PTR [eax+156], ecx

; 672  : //		for( i=0; i<MAX_PIERCING_ULTIMATE; i++ )
; 673  : //	adwUMItemId[i] = 0;
; 674  : 		memset( adwUMItemId, 0, sizeof(adwUMItemId) );

  00091	8d b0 a0 00 00
	00		 lea	 esi, DWORD PTR [eax+160]
  00097	89 16		 mov	 DWORD PTR [esi], edx
  00099	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0009c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009f	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000a2	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 675  : #else // __EXT_PIERCING
; 676  : 		nPiercedSize = 0;
; 677  : 		adwItemId0 = 0;
; 678  : 		adwItemId1 = 0;
; 679  : 		adwItemId2 = 0;
; 680  : 		adwItemId3 = 0;
; 681  : #if __VER >= 9 // __ULTIMATE
; 682  : 		adwItemId4 = 0;
; 683  : #endif // __ULTIMATE
; 684  : #endif // __EXT_PIERCING
; 685  : #if __VER >= 9 // __PET_0410
; 686  : 		nPetKind = 0;

  000a5	88 88 b4 00 00
	00		 mov	 BYTE PTR [eax+180], cl

; 687  : 		nPetLevel = 0;

  000ab	88 88 b5 00 00
	00		 mov	 BYTE PTR [eax+181], cl

; 688  : 		dwPetExp = 0;

  000b1	89 88 b8 00 00
	00		 mov	 DWORD PTR [eax+184], ecx

; 689  : 		wPetEnergy = 0;

  000b7	66 89 88 bc 00
	00 00		 mov	 WORD PTR [eax+188], cx

; 690  : 		wPetLife = 0;

  000be	66 89 88 be 00
	00 00		 mov	 WORD PTR [eax+190], cx

; 691  : 		nPetAL_D = 0;

  000c5	88 88 c0 00 00
	00		 mov	 BYTE PTR [eax+192], cl

; 692  : 		nPetAL_C = 0;

  000cb	88 88 c1 00 00
	00		 mov	 BYTE PTR [eax+193], cl

; 693  : 		nPetAL_B = 0;

  000d1	88 88 c2 00 00
	00		 mov	 BYTE PTR [eax+194], cl

; 694  : 		nPetAL_A = 0;

  000d7	88 88 c3 00 00
	00		 mov	 BYTE PTR [eax+195], cl

; 695  : 		nPetAL_S = 0;

  000dd	88 88 c4 00 00
	00		 mov	 BYTE PTR [eax+196], cl
  000e3	5e		 pop	 esi

; 696  : #endif // __PET_0410
; 697  : 	}

  000e4	c3		 ret	 0
??0_LogItemInfo@@QAE@XZ ENDP				; _LogItemInfo::_LogItemInfo
_TEXT	ENDS
PUBLIC	?time_null@@YAJXZ				; time_null
EXTRN	?g_tCurrent@@3JA:DWORD				; g_tCurrent
; Function compile flags: /Ogty
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT
?time_null@@YAJXZ PROC NEAR				; time_null, COMDAT

; 702  : #if defined(__WORLDSERVER) || defined(__CLIENT)
; 703  : 	return	g_tCurrent;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent

; 704  : #else	//
; 705  : 	return time( NULL );
; 706  : #endif	//
; 707  : }

  00005	c3		 ret	 0
?time_null@@YAJXZ ENDP					; time_null
_TEXT	ENDS
PUBLIC	?xRand@@YAKXZ					; xRand
EXTRN	?g_next@@3KA:DWORD				; g_next
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\xutil.h
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT
?xRand@@YAKXZ PROC NEAR					; xRand, COMDAT

; 16   : 	g_next = g_next * 1103515245 + 12345;// + nRandomSeed[ i++ ];

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next

; 17   : 	return g_next;	//   .
; 18   : }

  00015	c3		 ret	 0
?xRand@@YAKXZ ENDP					; xRand
_TEXT	ENDS
PUBLIC	?xRandom@@YAKK@Z				; xRandom
; Function compile flags: /Ogty
;	COMDAT ?xRandom@@YAKK@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
?xRandom@@YAKK@Z PROC NEAR				; xRandom, COMDAT

; 22   : 	return  xRand() % num;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  00015	33 d2		 xor	 edx, edx
  00017	f7 74 24 04	 div	 DWORD PTR _num$[esp-4]
  0001b	8b c2		 mov	 eax, edx

; 23   : }

  0001d	c3		 ret	 0
?xRandom@@YAKK@Z ENDP					; xRandom
_TEXT	ENDS
PUBLIC	?IsDelete@CObj@@QAEHXZ				; CObj::IsDelete
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT
?IsDelete@CObj@@QAEHXZ PROC NEAR			; CObj::IsDelete, COMDAT
; _this$ = ecx

; 180  : 	BOOL			IsDelete()	{ return (m_dwFlags & OBJ_FLAG_DELETE);  }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e0 01	 and	 eax, 1
  00006	c3		 ret	 0
?IsDelete@CObj@@QAEHXZ ENDP				; CObj::IsDelete
_TEXT	ENDS
PUBLIC	?GetNextNode@CObj@@QAEPAV1@XZ			; CObj::GetNextNode
; Function compile flags: /Ogty
;	COMDAT ?GetNextNode@CObj@@QAEPAV1@XZ
_TEXT	SEGMENT
?GetNextNode@CObj@@QAEPAV1@XZ PROC NEAR			; CObj::GetNextNode, COMDAT
; _this$ = ecx

; 195  : 	CObj*			GetNextNode() { return m_pNext; }

  00000	8b 81 80 01 00
	00		 mov	 eax, DWORD PTR [ecx+384]
  00006	c3		 ret	 0
?GetNextNode@CObj@@QAEPAV1@XZ ENDP			; CObj::GetNextNode
_TEXT	ENDS
PUBLIC	?GetType@CObj@@QAEKXZ				; CObj::GetType
; Function compile flags: /Ogty
;	COMDAT ?GetType@CObj@@QAEKXZ
_TEXT	SEGMENT
?GetType@CObj@@QAEKXZ PROC NEAR				; CObj::GetType, COMDAT
; _this$ = ecx

; 206  : 	DWORD			GetType() { return m_dwType; }

  00000	8b 81 70 01 00
	00		 mov	 eax, DWORD PTR [ecx+368]
  00006	c3		 ret	 0
?GetType@CObj@@QAEKXZ ENDP				; CObj::GetType
_TEXT	ENDS
PUBLIC	?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ		; CObj::GetPos
; Function compile flags: /Ogty
;	COMDAT ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ PROC NEAR		; CObj::GetPos, COMDAT
; _this$ = ecx

; 215  : 	D3DXVECTOR3		GetPos()	{ return m_vPos; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	81 c1 60 01 00
	00		 add	 ecx, 352		; 00000160H
  0000a	56		 push	 esi
  0000b	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000d	8b d0		 mov	 edx, eax
  0000f	89 32		 mov	 DWORD PTR [edx], esi
  00011	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00014	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00017	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ENDP		; CObj::GetPos
_TEXT	ENDS
PUBLIC	?GetAngle@CObj@@QAEMXZ				; CObj::GetAngle
; Function compile flags: /Ogty
;	COMDAT ?GetAngle@CObj@@QAEMXZ
_TEXT	SEGMENT
?GetAngle@CObj@@QAEMXZ PROC NEAR			; CObj::GetAngle, COMDAT
; _this$ = ecx

; 217  : 	FLOAT			GetAngle()	{ return m_fAngle; }

  00000	d9 41 18	 fld	 DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetAngle@CObj@@QAEMXZ ENDP				; CObj::GetAngle
_TEXT	ENDS
PUBLIC	?GetWorld@CObj@@QAEPAVCWorld@@XZ		; CObj::GetWorld
; Function compile flags: /Ogty
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT
?GetWorld@CObj@@QAEPAVCWorld@@XZ PROC NEAR		; CObj::GetWorld, COMDAT
; _this$ = ecx

; 221  : 	CWorld*			GetWorld()	{ return m_pWorld; }

  00000	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00006	c3		 ret	 0
?GetWorld@CObj@@QAEPAVCWorld@@XZ ENDP			; CObj::GetWorld
_TEXT	ENDS
PUBLIC	?GetLayer@CObj@@QAEHXZ				; CObj::GetLayer
; Function compile flags: /Ogty
;	COMDAT ?GetLayer@CObj@@QAEHXZ
_TEXT	SEGMENT
?GetLayer@CObj@@QAEHXZ PROC NEAR			; CObj::GetLayer, COMDAT
; _this$ = ecx

; 247  : 	int		GetLayer()	{	return m_nLayer;	}

  00000	8b 81 b8 01 00
	00		 mov	 eax, DWORD PTR [ecx+440]
  00006	c3		 ret	 0
?GetLayer@CObj@@QAEHXZ ENDP				; CObj::GetLayer
_TEXT	ENDS
PUBLIC	?VelocityToVec@@YA?AUD3DXVECTOR3@@MM@Z		; VelocityToVec
PUBLIC	__real@3c8efa35
;	COMDAT __real@3c8efa35
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
CONST	ENDS
;	COMDAT ?VelocityToVec@@YA?AUD3DXVECTOR3@@MM@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_fAngle$ = 12						; size = 4
_fVelocity$ = 16					; size = 4
?VelocityToVec@@YA?AUD3DXVECTOR3@@MM@Z PROC NEAR	; VelocityToVec, COMDAT

; 280  : 	FLOAT fTheta = D3DXToRadian( fAngle );

  00000	d9 44 24 08	 fld	 DWORD PTR _fAngle$[esp-4]

; 281  : 	FLOAT fx = sinf( fTheta ) * fVelocity;
; 282  : 	FLOAT fz = -cosf( fTheta ) * fVelocity;
; 283  : 	return D3DXVECTOR3( fx, 0.0f, fz );

  00004	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00008	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c8efa35
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00015	d9 c0		 fld	 ST(0)
  00017	d9 fe		 fsin
  00019	d8 4c 24 0c	 fmul	 DWORD PTR _fVelocity$[esp-4]
  0001d	d9 18		 fstp	 DWORD PTR [eax]
  0001f	d9 ff		 fcos
  00021	d8 4c 24 0c	 fmul	 DWORD PTR _fVelocity$[esp-4]
  00025	d9 e0		 fchs
  00027	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 284  : }

  0002a	c3		 ret	 0
?VelocityToVec@@YA?AUD3DXVECTOR3@@MM@Z ENDP		; VelocityToVec
_TEXT	ENDS
PUBLIC	?GetDegree@@YAMABUD3DXVECTOR3@@0@Z		; GetDegree
PUBLIC	__real@0000000000000000
PUBLIC	__real@00000000
PUBLIC	__real@42652ee0
PUBLIC	__real@43b40000
EXTRN	_D3DXVec3Normalize@8:NEAR
;	COMDAT __real@0000000000000000
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@42652ee0
CONST	SEGMENT
__real@42652ee0 DD 042652ee0r			; 57.2958
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
CONST	ENDS
;	COMDAT ?GetDegree@@YAMABUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_vDir2$ = -24						; size = 12
_vDir1$ = -12						; size = 12
_vDestPos$ = 8						; size = 4
_vSrcPos$ = 12						; size = 4
?GetDegree@@YAMABUD3DXVECTOR3@@0@Z PROC NEAR		; GetDegree, COMDAT

; 289  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H

; 290  : 	D3DXVECTOR3 vDir1 = VelocityToVec( 0.0f, 1.0f );

  00003	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000

; 291  : 	D3DXVECTOR3 vDir2 = vDestPos - vSrcPos;

  00009	8b 44 24 1c	 mov	 eax, DWORD PTR _vDestPos$[esp+20]
  0000d	d9 fe		 fsin
  0000f	8b 4c 24 20	 mov	 ecx, DWORD PTR _vSrcPos$[esp+20]
  00013	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _vDir1$[esp+28], 0

; 292  : 	vDir2.y = 0.0f;

  0001b	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _vDir2$[esp+28], 0
  00023	d9 5c 24 0c	 fstp	 DWORD PTR _vDir1$[esp+24]
  00027	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  0002d	d9 ff		 fcos
  0002f	d9 e0		 fchs
  00031	d9 5c 24 14	 fstp	 DWORD PTR _vDir1$[esp+32]
  00035	d9 00		 fld	 DWORD PTR [eax]
  00037	d8 21		 fsub	 DWORD PTR [ecx]
  00039	d9 1c 24	 fstp	 DWORD PTR _vDir2$[esp+24]
  0003c	d9 40 08	 fld	 DWORD PTR [eax+8]

; 293  : 
; 294  : 	D3DXVec3Normalize( &vDir1, &vDir1 );

  0003f	8d 44 24 0c	 lea	 eax, DWORD PTR _vDir1$[esp+24]
  00043	d8 61 08	 fsub	 DWORD PTR [ecx+8]
  00046	50		 push	 eax
  00047	8b c8		 mov	 ecx, eax
  00049	51		 push	 ecx
  0004a	d9 5c 24 10	 fstp	 DWORD PTR _vDir2$[esp+40]
  0004e	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 295  : 	D3DXVec3Normalize( &vDir2, &vDir2 );

  00053	8d 14 24	 lea	 edx, DWORD PTR _vDir2$[esp+24]
  00056	52		 push	 edx
  00057	8b c2		 mov	 eax, edx
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 296  : 	FLOAT fDot = D3DXVec3Dot( &vDir1, &vDir2 );

  0005f	d9 44 24 08	 fld	 DWORD PTR _vDir2$[esp+32]
  00063	d8 4c 24 14	 fmul	 DWORD PTR _vDir1$[esp+32]
  00067	d9 44 24 0c	 fld	 DWORD PTR _vDir1$[esp+24]
  0006b	d8 0c 24	 fmul	 DWORD PTR _vDir2$[esp+24]

; 301  : 	else
; 302  : 		fDegree = fDegree;
; 303  : 	return fDegree;

  0006e	de c1		 faddp	 ST(1), ST(0)
  00070	d9 44 24 10	 fld	 DWORD PTR _vDir1$[esp+28]
  00074	d8 4c 24 04	 fmul	 DWORD PTR _vDir2$[esp+28]
  00078	de c1		 faddp	 ST(1), ST(0)
  0007a	e8 00 00 00 00	 call	 __CIacos
  0007f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42652ee0
  00085	d9 04 24	 fld	 DWORD PTR _vDir2$[esp+24]
  00088	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0008e	df e0		 fnstsw	 ax
  00090	f6 c4 05	 test	 ah, 5
  00093	7a 06		 jp	 SHORT $L176563

; 297  : 	FLOAT fRadian = acosf( fDot );
; 298  : 	FLOAT fDegree = D3DXToDegree( fRadian );
; 299  : 	if( vDir2.x < 0.0f )
; 300  : 		fDegree = 360.0f - fDegree;

  00095	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@43b40000
$L176563:

; 304  : }

  0009b	83 c4 18	 add	 esp, 24			; 00000018H
  0009e	c3		 ret	 0
?GetDegree@@YAMABUD3DXVECTOR3@@0@Z ENDP			; GetDegree
_TEXT	ENDS
PUBLIC	?IsValidObj@@YAHPAVCObj@@@Z			; IsValidObj
; Function compile flags: /Ogty
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?IsValidObj@@YAHPAVCObj@@@Z PROC NEAR			; IsValidObj, COMDAT

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pObj$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 0c		 je	 SHORT $L282453
  00008	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0000c	75 06		 jne	 SHORT $L282453
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 328  : }

  00013	c3		 ret	 0
$L282453:

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00014	33 c0		 xor	 eax, eax

; 328  : }

  00016	c3		 ret	 0
?IsValidObj@@YAHPAVCObj@@@Z ENDP			; IsValidObj
_TEXT	ENDS
PUBLIC	?IsInvalidObj@@YAHPAVCObj@@@Z			; IsInvalidObj
; Function compile flags: /Ogty
;	COMDAT ?IsInvalidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?IsInvalidObj@@YAHPAVCObj@@@Z PROC NEAR			; IsInvalidObj, COMDAT

; 332  : 	return !IsValidObj( pObj ); 

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pObj$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 15		 je	 SHORT $L282469
  00008	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0000c	75 0f		 jne	 SHORT $L282469
  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	33 c9		 xor	 ecx, ecx
  00015	85 c0		 test	 eax, eax
  00017	0f 94 c1	 sete	 cl
  0001a	8b c1		 mov	 eax, ecx

; 333  : }

  0001c	c3		 ret	 0

; 332  : 	return !IsValidObj( pObj ); 

$L282469:
  0001d	33 c0		 xor	 eax, eax
  0001f	33 c9		 xor	 ecx, ecx
  00021	85 c0		 test	 eax, eax
  00023	0f 94 c1	 sete	 cl
  00026	8b c1		 mov	 eax, ecx

; 333  : }

  00028	c3		 ret	 0
?IsInvalidObj@@YAHPAVCObj@@@Z ENDP			; IsInvalidObj
_TEXT	ENDS
PUBLIC	?GetCoolTime@ItemProp@@QAEKXZ			; ItemProp::GetCoolTime
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\projectcmn.h
;	COMDAT ?GetCoolTime@ItemProp@@QAEKXZ
_TEXT	SEGMENT
?GetCoolTime@ItemProp@@QAEKXZ PROC NEAR			; ItemProp::GetCoolTime, COMDAT
; _this$ = ecx

; 453  : 	DWORD	GetCoolTime()  { return dwSkillReady; }

  00000	8b 81 c8 01 00
	00		 mov	 eax, DWORD PTR [ecx+456]
  00006	c3		 ret	 0
?GetCoolTime@ItemProp@@QAEKXZ ENDP			; ItemProp::GetCoolTime
_TEXT	ENDS
PUBLIC	?IsVisPet@ItemProp@@QAEHXZ			; ItemProp::IsVisPet
; Function compile flags: /Ogty
;	COMDAT ?IsVisPet@ItemProp@@QAEHXZ
_TEXT	SEGMENT
?IsVisPet@ItemProp@@QAEHXZ PROC NEAR			; ItemProp::IsVisPet, COMDAT
; _this$ = ecx

; 509  : 	BOOL	IsVisPet()	{ return (dwItemKind3 == IK3_PET) && (dwReferStat1 == PET_VIS); }

  00000	83 79 78 64	 cmp	 DWORD PTR [ecx+120], 100 ; 00000064H
  00004	75 0f		 jne	 SHORT $L282479
  00006	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	3b d0		 cmp	 edx, eax
  00013	74 02		 je	 SHORT $L282480
$L282479:
  00015	33 c0		 xor	 eax, eax
$L282480:
  00017	c3		 ret	 0
?IsVisPet@ItemProp@@QAEHXZ ENDP				; ItemProp::IsVisPet
_TEXT	ENDS
PUBLIC	?GetId@CCtrl@@QAEKXZ				; CCtrl::GetId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ctrl.h
;	COMDAT ?GetId@CCtrl@@QAEKXZ
_TEXT	SEGMENT
?GetId@CCtrl@@QAEKXZ PROC NEAR				; CCtrl::GetId, COMDAT
; _this$ = ecx

; 58   : 	OBJID			GetId()					{ return m_objid;   }

  00000	8b 81 bc 01 00
	00		 mov	 eax, DWORD PTR [ecx+444]
  00006	c3		 ret	 0
?GetId@CCtrl@@QAEKXZ ENDP				; CCtrl::GetId
_TEXT	ENDS
PUBLIC	?LOG_RANGE@@YAXPBDHHH@Z				; LOG_RANGE
PUBLIC	??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ ; `string'
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	SEGMENT
??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ DB '%'
	DB	's min:%d, max:%d, index:%d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT
_szMsg$ = 8						; size = 4
_nMin$ = 12						; size = 4
_nMax$ = 16						; size = 4
_nIndex$ = 20						; size = 4
?LOG_RANGE@@YAXPBDHHH@Z PROC NEAR			; LOG_RANGE, COMDAT

; 559  : 	LPCTSTR szErr = Error( _T( "%s min:%d, max:%d, index:%d" ), szMsg, nMin, nMax, nIndex ); 

  00000	8b 44 24 10	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMax$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR _nMin$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR _szMsg$[esp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00019	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 560  : 	ADDERRORMSG( szErr ); 
; 561  : }

  00021	c3		 ret	 0
?LOG_RANGE@@YAXPBDHHH@Z ENDP				; LOG_RANGE
_TEXT	ENDS
PUBLIC	?LOG_CALLSTACK@@YAXXZ				; LOG_CALLSTACK
; Function compile flags: /Ogty
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT
?LOG_CALLSTACK@@YAXXZ PROC NEAR				; LOG_CALLSTACK, COMDAT

; 565  : #ifdef _DEBUG
; 566  : 	__asm int 3
; 567  : #endif
; 568  : 
; 569  : #if defined(__INTERNALSERVER)
; 570  : 	int *p = NULL;		//    
; 571  : 	*p = 1;
; 572  : #endif
; 573  : }

  00000	c3		 ret	 0
?LOG_CALLSTACK@@YAXXZ ENDP				; LOG_CALLSTACK
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@ ; `string'
PUBLIC	?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z	; CProject::GetMoverProp
;	COMDAT ??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
CONST	SEGMENT
??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@ DB 'GetMoverProp range_'
	DB	'error', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z PROC NEAR	; CProject::GetMoverProp, COMDAT
; _this$ = ecx

; 1381 : 	VERIFY_RANGE( nIndex, 0, m_nMoverPropSize, "GetMoverProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 19		 jl	 SHORT $L197938
  00008	3b 81 d0 01 00
	00		 cmp	 eax, DWORD PTR [ecx+464]
  0000e	7d 11		 jge	 SHORT $L197938

; 1382 : 	return m_pPropMover + nIndex;

  00010	8b 91 d4 01 00
	00		 mov	 edx, DWORD PTR [ecx+468]
  00016	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  0001c	03 c2		 add	 eax, edx

; 1383 : }

  0001e	c2 04 00	 ret	 4
$L197938:

; 1381 : 	VERIFY_RANGE( nIndex, 0, m_nMoverPropSize, "GetMoverProp range_error", NULL );

  00021	50		 push	 eax
  00022	8b 81 d0 01 00
	00		 mov	 eax, DWORD PTR [ecx+464]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00035	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003a	83 c4 14	 add	 esp, 20			; 00000014H
  0003d	33 c0		 xor	 eax, eax

; 1383 : }

  0003f	c2 04 00	 ret	 4
?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z ENDP	; CProject::GetMoverProp
_TEXT	ENDS
PUBLIC	?GetLevel@CPet@@QAEEXZ				; CPet::GetLevel
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
;	COMDAT ?GetLevel@CPet@@QAEEXZ
_TEXT	SEGMENT
?GetLevel@CPet@@QAEEXZ PROC NEAR			; CPet::GetLevel, COMDAT
; _this$ = ecx

; 134  : 	BYTE	GetLevel( void )	{	return m_nLevel;	}

  00000	8a 41 05	 mov	 al, BYTE PTR [ecx+5]
  00003	c3		 ret	 0
?GetLevel@CPet@@QAEEXZ ENDP				; CPet::GetLevel
_TEXT	ENDS
PUBLIC	?GetExp@CPet@@QAEKXZ				; CPet::GetExp
; Function compile flags: /Ogty
;	COMDAT ?GetExp@CPet@@QAEKXZ
_TEXT	SEGMENT
?GetExp@CPet@@QAEKXZ PROC NEAR				; CPet::GetExp, COMDAT
; _this$ = ecx

; 137  : 	DWORD	GetExp( void )	{	return m_dwExp;		}

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetExp@CPet@@QAEKXZ ENDP				; CPet::GetExp
_TEXT	ENDS
PUBLIC	?SetLife@CPet@@QAEXG@Z				; CPet::SetLife
; Function compile flags: /Ogty
;	COMDAT ?SetLife@CPet@@QAEXG@Z
_TEXT	SEGMENT
_wLife$ = 8						; size = 2
?SetLife@CPet@@QAEXG@Z PROC NEAR			; CPet::SetLife, COMDAT
; _this$ = ecx

; 140  : 	void	SetLife( WORD wLife )	{	m_wLife	= wLife;	}

  00000	66 8b 44 24 04	 mov	 ax, WORD PTR _wLife$[esp-4]
  00005	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax
  00009	c2 04 00	 ret	 4
?SetLife@CPet@@QAEXG@Z ENDP				; CPet::SetLife
_TEXT	ENDS
PUBLIC	?GetEnergy@CPet@@QAEGXZ				; CPet::GetEnergy
; Function compile flags: /Ogty
;	COMDAT ?GetEnergy@CPet@@QAEGXZ
_TEXT	SEGMENT
?GetEnergy@CPet@@QAEGXZ PROC NEAR			; CPet::GetEnergy, COMDAT
; _this$ = ecx

; 141  : 	WORD	GetEnergy( void )	{	return m_wEnergy;	}

  00000	66 8b 41 0c	 mov	 ax, WORD PTR [ecx+12]
  00004	c3		 ret	 0
?GetEnergy@CPet@@QAEGXZ ENDP				; CPet::GetEnergy
_TEXT	ENDS
PUBLIC	?GetName@CPet@@QAEPBDXZ				; CPet::GetName
; Function compile flags: /Ogty
;	COMDAT ?GetName@CPet@@QAEPBDXZ
_TEXT	SEGMENT
?GetName@CPet@@QAEPBDXZ PROC NEAR			; CPet::GetName, COMDAT
; _this$ = ecx

; 149  : 	const char*	GetName()	{	return m_szName;	}

  00000	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]
  00003	c3		 ret	 0
?GetName@CPet@@QAEPBDXZ ENDP				; CPet::GetName
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 48   : 	BOOL			IsEmpty() { return m_dwItemId ? FALSE : TRUE; }

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	?GetSerialNumber@CItemBase@@QAEKXZ		; CItemBase::GetSerialNumber
; Function compile flags: /Ogty
;	COMDAT ?GetSerialNumber@CItemBase@@QAEKXZ
_TEXT	SEGMENT
?GetSerialNumber@CItemBase@@QAEKXZ PROC NEAR		; CItemBase::GetSerialNumber, COMDAT
; _this$ = ecx

; 64   : 	SERIALNUMBER	GetSerialNumber( void )		{	return m_liSerialNumber;	}

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?GetSerialNumber@CItemBase@@QAEKXZ ENDP			; CItemBase::GetSerialNumber
_TEXT	ENDS
PUBLIC	?GetPiercingSize@CItemElem@@QAEHXZ		; CItemElem::GetPiercingSize
EXTRN	?GetPiercingSize@CPiercing@@QAEHXZ:NEAR		; CPiercing::GetPiercingSize
; Function compile flags: /Ogty
;	COMDAT ?GetPiercingSize@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetPiercingSize@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::GetPiercingSize, COMDAT
; _this$ = ecx

; 101  : 	int		GetPiercingSize()	{	return m_piercing.GetPiercingSize();		}

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
?GetPiercingSize@CItemElem@@QAEHXZ ENDP			; CItemElem::GetPiercingSize
_TEXT	ENDS
PUBLIC	?GetPiercingItem@CItemElem@@QAEKH@Z		; CItemElem::GetPiercingItem
EXTRN	?GetPiercingItem@CPiercing@@QAEKH@Z:NEAR	; CPiercing::GetPiercingItem
; Function compile flags: /Ogty
;	COMDAT ?GetPiercingItem@CItemElem@@QAEKH@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
?GetPiercingItem@CItemElem@@QAEKH@Z PROC NEAR		; CItemElem::GetPiercingItem, COMDAT
; _this$ = ecx

; 104  : 	DWORD	GetPiercingItem( int nth )	{	return m_piercing.GetPiercingItem( nth );	}

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
?GetPiercingItem@CItemElem@@QAEKH@Z ENDP		; CItemElem::GetPiercingItem
_TEXT	ENDS
PUBLIC	?GetRandomOptItemId@CItemElem@@QAE_JXZ		; CItemElem::GetRandomOptItemId
; Function compile flags: /Ogty
;	COMDAT ?GetRandomOptItemId@CItemElem@@QAE_JXZ
_TEXT	SEGMENT
?GetRandomOptItemId@CItemElem@@QAE_JXZ PROC NEAR	; CItemElem::GetRandomOptItemId, COMDAT
; _this$ = ecx

; 167  : 	__int64		GetRandomOptItemId( void )	{	return m_iRandomOptItemId;	}

  00000	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  00006	8b 91 9c 00 00
	00		 mov	 edx, DWORD PTR [ecx+156]
  0000c	c3		 ret	 0
?GetRandomOptItemId@CItemElem@@QAE_JXZ ENDP		; CItemElem::GetRandomOptItemId
_TEXT	ENDS
PUBLIC	?IsFlag@CItemElem@@QAEHE@Z			; CItemElem::IsFlag
; Function compile flags: /Ogty
;	COMDAT ?IsFlag@CItemElem@@QAEHE@Z
_TEXT	SEGMENT
_byFlag$ = 8						; size = 1
?IsFlag@CItemElem@@QAEHE@Z PROC NEAR			; CItemElem::IsFlag, COMDAT
; _this$ = ecx

; 256  : 	BOOL	IsFlag( BYTE byFlag )	{	return ( m_byFlag & byFlag ) ? TRUE: FALSE;		}

  00000	8a 81 82 00 00
	00		 mov	 al, BYTE PTR [ecx+130]
  00006	22 44 24 04	 and	 al, BYTE PTR _byFlag$[esp-4]
  0000a	f6 d8		 neg	 al
  0000c	1b c0		 sbb	 eax, eax
  0000e	f7 d8		 neg	 eax
  00010	c2 04 00	 ret	 4
?IsFlag@CItemElem@@QAEHE@Z ENDP				; CItemElem::IsFlag
_TEXT	ENDS
PUBLIC	?GetVisKeepTime@CItemElem@@QAEJH@Z		; CItemElem::GetVisKeepTime
EXTRN	?GetVisKeepTime@CPiercing@@QAEJH@Z:NEAR		; CPiercing::GetVisKeepTime
; Function compile flags: /Ogty
;	COMDAT ?GetVisKeepTime@CItemElem@@QAEJH@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
?GetVisKeepTime@CItemElem@@QAEJH@Z PROC NEAR		; CItemElem::GetVisKeepTime, COMDAT
; _this$ = ecx

; 278  : 	time_t	GetVisKeepTime( int nth )					{ return m_piercing.GetVisKeepTime( nth ); }

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?GetVisKeepTime@CPiercing@@QAEJH@Z ; CPiercing::GetVisKeepTime
?GetVisKeepTime@CItemElem@@QAEJH@Z ENDP			; CItemElem::GetVisKeepTime
_TEXT	ENDS
PUBLIC	?GetId@IBuff@@QAEGXZ				; IBuff::GetId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\buff.h
;	COMDAT ?GetId@IBuff@@QAEGXZ
_TEXT	SEGMENT
?GetId@IBuff@@QAEGXZ PROC NEAR				; IBuff::GetId, COMDAT
; _this$ = ecx

; 31   : 	WORD	GetId()		{	return m_wId;	}

  00000	66 8b 41 06	 mov	 ax, WORD PTR [ecx+6]
  00004	c3		 ret	 0
?GetId@IBuff@@QAEGXZ ENDP				; IBuff::GetId
_TEXT	ENDS
PUBLIC	?GetLevel@IBuff@@QAEKXZ				; IBuff::GetLevel
; Function compile flags: /Ogty
;	COMDAT ?GetLevel@IBuff@@QAEKXZ
_TEXT	SEGMENT
?GetLevel@IBuff@@QAEKXZ PROC NEAR			; IBuff::GetLevel, COMDAT
; _this$ = ecx

; 32   : 	DWORD	GetLevel()	{	return m_dwLevel;	}

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetLevel@IBuff@@QAEKXZ ENDP				; IBuff::GetLevel
_TEXT	ENDS
PUBLIC	?GetTotal@IBuff@@QAEKXZ				; IBuff::GetTotal
; Function compile flags: /Ogty
;	COMDAT ?GetTotal@IBuff@@QAEKXZ
_TEXT	SEGMENT
?GetTotal@IBuff@@QAEKXZ PROC NEAR			; IBuff::GetTotal, COMDAT
; _this$ = ecx

; 33   : 	DWORD	GetTotal()	{	return m_tmTotal;	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetTotal@IBuff@@QAEKXZ ENDP				; IBuff::GetTotal
_TEXT	ENDS
PUBLIC	?GetInst@IBuff@@QAEKXZ				; IBuff::GetInst
; Function compile flags: /Ogty
;	COMDAT ?GetInst@IBuff@@QAEKXZ
_TEXT	SEGMENT
?GetInst@IBuff@@QAEKXZ PROC NEAR			; IBuff::GetInst, COMDAT
; _this$ = ecx

; 39   : 	DWORD	GetInst()		{	return m_tmInst;	}

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetInst@IBuff@@QAEKXZ ENDP				; IBuff::GetInst
_TEXT	ENDS
PUBLIC	?IsFly@CAction@@QAEHXZ				; CAction::IsFly
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\action.h
;	COMDAT ?IsFly@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsFly@CAction@@QAEHXZ PROC NEAR			; CAction::IsFly, COMDAT
; _this$ = ecx

; 309  : 	BOOL			IsFly() { return (m_dwStateFlag & OBJSTAF_FLY) ? TRUE : FALSE; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c1 e8 03	 shr	 eax, 3
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsFly@CAction@@QAEHXZ ENDP				; CAction::IsFly
_TEXT	ENDS
PUBLIC	?IsDie@CAction@@QAEHXZ				; CAction::IsDie
; Function compile flags: /Ogty
;	COMDAT ?IsDie@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsDie@CAction@@QAEHXZ PROC NEAR			; CAction::IsDie, COMDAT
; _this$ = ecx

; 310  : 	BOOL			IsDie() { return (m_dwState & OBJSTA_DIE_ALL) ? TRUE : FALSE; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsDie@CAction@@QAEHXZ ENDP				; CAction::IsDie
_TEXT	ENDS
PUBLIC	?IsSit@CAction@@QAEHXZ				; CAction::IsSit
; Function compile flags: /Ogty
;	COMDAT ?IsSit@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsSit@CAction@@QAEHXZ PROC NEAR			; CAction::IsSit, COMDAT
; _this$ = ecx

; 311  : 	BOOL			IsSit() { return (m_dwStateFlag & OBJSTAF_SIT) ? TRUE : FALSE; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c1 e8 02	 shr	 eax, 2
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsSit@CAction@@QAEHXZ ENDP				; CAction::IsSit
_TEXT	ENDS
PUBLIC	?IsActAttack@CAction@@QAEHXZ			; CAction::IsActAttack
; Function compile flags: /Ogty
;	COMDAT ?IsActAttack@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsActAttack@CAction@@QAEHXZ PROC NEAR			; CAction::IsActAttack, COMDAT
; _this$ = ecx

; 322  : 	BOOL			IsActAttack()		{ return m_dwState & OBJSTA_ATK_ALL; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00008	c3		 ret	 0
?IsActAttack@CAction@@QAEHXZ ENDP			; CAction::IsActAttack
_TEXT	ENDS
PUBLIC	?SendDamage@CActionMover@@QAEHKKHHH@Z		; CActionMover::SendDamage
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\actionmover.h
;	COMDAT ?SendDamage@CActionMover@@QAEHKKHHH@Z
_TEXT	SEGMENT
_dwAtkFlags$ = 8					; size = 4
_idSender$ = 12						; size = 4
_nParam$ = 16						; size = 4
_bTarget$ = 20						; size = 4
_nReflect$ = 24						; size = 4
?SendDamage@CActionMover@@QAEHKKHHH@Z PROC NEAR		; CActionMover::SendDamage, COMDAT
; _this$ = ecx

; 134  : 	int				SendDamage( DWORD dwAtkFlags, OBJID idSender, int nParam = 0, BOOL bTarget = TRUE, int nReflect = 0 )	{	return SendActMsg( OBJMSG_DAMAGE, dwAtkFlags, idSender, nParam, bTarget, nReflect );	}

  00000	8b 54 24 14	 mov	 edx, DWORD PTR _nReflect$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	52		 push	 edx
  00007	8b 54 24 14	 mov	 edx, DWORD PTR _bTarget$[esp]
  0000b	52		 push	 edx
  0000c	8b 54 24 14	 mov	 edx, DWORD PTR _nParam$[esp+4]
  00010	52		 push	 edx
  00011	8b 54 24 14	 mov	 edx, DWORD PTR _idSender$[esp+8]
  00015	52		 push	 edx
  00016	8b 54 24 14	 mov	 edx, DWORD PTR _dwAtkFlags$[esp+12]
  0001a	52		 push	 edx
  0001b	6a 29		 push	 41			; 00000029H
  0001d	ff 50 04	 call	 DWORD PTR [eax+4]
  00020	c2 14 00	 ret	 20			; 00000014H
?SendDamage@CActionMover@@QAEHKKHHH@Z ENDP		; CActionMover::SendDamage
_TEXT	ENDS
PUBLIC	?HasActivatedEatPet@CMover@@QAEHXZ		; CMover::HasActivatedEatPet
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
;	COMDAT ?HasActivatedEatPet@CMover@@QAEHXZ
_TEXT	SEGMENT
?HasActivatedEatPet@CMover@@QAEHXZ PROC NEAR		; CMover::HasActivatedEatPet, COMDAT
; _this$ = ecx

; 827  : 	BOOL	HasActivatedEatPet( void )		{	return m_oiEatPet != NULL_ID;	}

  00000	8b 91 7c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1660]
  00006	33 c0		 xor	 eax, eax
  00008	83 fa ff	 cmp	 edx, -1
  0000b	0f 95 c0	 setne	 al
  0000e	c3		 ret	 0
?HasActivatedEatPet@CMover@@QAEHXZ ENDP			; CMover::HasActivatedEatPet
_TEXT	ENDS
PUBLIC	?HasActivatedSystemPet@CMover@@QAEHXZ		; CMover::HasActivatedSystemPet
; Function compile flags: /Ogty
;	COMDAT ?HasActivatedSystemPet@CMover@@QAEHXZ
_TEXT	SEGMENT
?HasActivatedSystemPet@CMover@@QAEHXZ PROC NEAR		; CMover::HasActivatedSystemPet, COMDAT
; _this$ = ecx

; 828  : 	BOOL	HasActivatedSystemPet( void )	{	return m_dwPetId != NULL_ID;	}

  00000	8b 91 8c 11 00
	00		 mov	 edx, DWORD PTR [ecx+4492]
  00006	33 c0		 xor	 eax, eax
  00008	83 fa ff	 cmp	 edx, -1
  0000b	0f 95 c0	 setne	 al
  0000e	c3		 ret	 0
?HasActivatedSystemPet@CMover@@QAEHXZ ENDP		; CMover::HasActivatedSystemPet
_TEXT	ENDS
PUBLIC	?GetEatPetId@CMover@@QAEKXZ			; CMover::GetEatPetId
; Function compile flags: /Ogty
;	COMDAT ?GetEatPetId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetEatPetId@CMover@@QAEKXZ PROC NEAR			; CMover::GetEatPetId, COMDAT
; _this$ = ecx

; 829  : 	OBJID	GetEatPetId( void )		{	return m_oiEatPet;		}

  00000	8b 81 7c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1660]
  00006	c3		 ret	 0
?GetEatPetId@CMover@@QAEKXZ ENDP			; CMover::GetEatPetId
_TEXT	ENDS
PUBLIC	?SetEatPetId@CMover@@QAEXK@Z			; CMover::SetEatPetId
; Function compile flags: /Ogty
;	COMDAT ?SetEatPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT
_oiEatPet$ = 8						; size = 4
?SetEatPetId@CMover@@QAEXK@Z PROC NEAR			; CMover::SetEatPetId, COMDAT
; _this$ = ecx

; 830  : 	void	SetEatPetId( OBJID oiEatPet )		{	m_oiEatPet	= oiEatPet;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _oiEatPet$[esp-4]
  00004	89 81 7c 06 00
	00		 mov	 DWORD PTR [ecx+1660], eax
  0000a	c2 04 00	 ret	 4
?SetEatPetId@CMover@@QAEXK@Z ENDP			; CMover::SetEatPetId
_TEXT	ENDS
PUBLIC	?GetPetId@CMover@@QAEKXZ			; CMover::GetPetId
; Function compile flags: /Ogty
;	COMDAT ?GetPetId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPetId@CMover@@QAEKXZ PROC NEAR			; CMover::GetPetId, COMDAT
; _this$ = ecx

; 831  : 	DWORD	GetPetId( void )	{	return m_dwPetId;	}

  00000	8b 81 8c 11 00
	00		 mov	 eax, DWORD PTR [ecx+4492]
  00006	c3		 ret	 0
?GetPetId@CMover@@QAEKXZ ENDP				; CMover::GetPetId
_TEXT	ENDS
PUBLIC	?SetPetId@CMover@@QAEXK@Z			; CMover::SetPetId
; Function compile flags: /Ogty
;	COMDAT ?SetPetId@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwPetId$ = 8						; size = 4
?SetPetId@CMover@@QAEXK@Z PROC NEAR			; CMover::SetPetId, COMDAT
; _this$ = ecx

; 832  : 	void	SetPetId( DWORD dwPetId )		{	m_dwPetId	= dwPetId;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwPetId$[esp-4]
  00004	89 81 8c 11 00
	00		 mov	 DWORD PTR [ecx+4492], eax
  0000a	c2 04 00	 ret	 4
?SetPetId@CMover@@QAEXK@Z ENDP				; CMover::SetPetId
_TEXT	ENDS
PUBLIC	?SetVisPetItem@CMover@@QAEXK@Z			; CMover::SetVisPetItem
; Function compile flags: /Ogty
;	COMDAT ?SetVisPetItem@CMover@@QAEXK@Z
_TEXT	SEGMENT
_objId$ = 8						; size = 4
?SetVisPetItem@CMover@@QAEXK@Z PROC NEAR		; CMover::SetVisPetItem, COMDAT
; _this$ = ecx

; 845  : 	void		SetVisPetItem( OBJID objId )	{ m_objIdVisPet = objId; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _objId$[esp-4]
  00004	89 81 94 11 00
	00		 mov	 DWORD PTR [ecx+4500], eax
  0000a	c2 04 00	 ret	 4
?SetVisPetItem@CMover@@QAEXK@Z ENDP			; CMover::SetVisPetItem
_TEXT	ENDS
PUBLIC	?HasActivatedVisPet@CMover@@QAEHXZ		; CMover::HasActivatedVisPet
; Function compile flags: /Ogty
;	COMDAT ?HasActivatedVisPet@CMover@@QAEHXZ
_TEXT	SEGMENT
?HasActivatedVisPet@CMover@@QAEHXZ PROC NEAR		; CMover::HasActivatedVisPet, COMDAT
; _this$ = ecx

; 846  : 	BOOL		HasActivatedVisPet()	{ return m_objIdVisPet != NULL_ID; }

  00000	8b 91 94 11 00
	00		 mov	 edx, DWORD PTR [ecx+4500]
  00006	33 c0		 xor	 eax, eax
  00008	83 fa ff	 cmp	 edx, -1
  0000b	0f 95 c0	 setne	 al
  0000e	c3		 ret	 0
?HasActivatedVisPet@CMover@@QAEHXZ ENDP			; CMover::HasActivatedVisPet
_TEXT	ENDS
PUBLIC	?GetPartyId@CMover@@QAEKXZ			; CMover::GetPartyId
; Function compile flags: /Ogty
;	COMDAT ?GetPartyId@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPartyId@CMover@@QAEKXZ PROC NEAR			; CMover::GetPartyId, COMDAT
; _this$ = ecx

; 1025 : 	u_long			GetPartyId() { return m_idparty; }

  00000	8b 81 18 07 00
	00		 mov	 eax, DWORD PTR [ecx+1816]
  00006	c3		 ret	 0
?GetPartyId@CMover@@QAEKXZ ENDP				; CMover::GetPartyId
_TEXT	ENDS
PUBLIC	?IsNPC@CMover@@QAEHXZ				; CMover::IsNPC
; Function compile flags: /Ogty
;	COMDAT ?IsNPC@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsNPC@CMover@@QAEHXZ PROC NEAR				; CMover::IsNPC, COMDAT
; _this$ = ecx

; 1041 : 	BOOL			IsNPC()				{ return !m_bPlayer; }

  00000	8b 91 34 02 00
	00		 mov	 edx, DWORD PTR [ecx+564]
  00006	33 c0		 xor	 eax, eax
  00008	85 d2		 test	 edx, edx
  0000a	0f 94 c0	 sete	 al
  0000d	c3		 ret	 0
?IsNPC@CMover@@QAEHXZ ENDP				; CMover::IsNPC
_TEXT	ENDS
PUBLIC	?IsPlayer@CMover@@QAEHXZ			; CMover::IsPlayer
; Function compile flags: /Ogty
;	COMDAT ?IsPlayer@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsPlayer@CMover@@QAEHXZ PROC NEAR			; CMover::IsPlayer, COMDAT
; _this$ = ecx

; 1042 : 	BOOL			IsPlayer()			{ return m_bPlayer; }

  00000	8b 81 34 02 00
	00		 mov	 eax, DWORD PTR [ecx+564]
  00006	c3		 ret	 0
?IsPlayer@CMover@@QAEHXZ ENDP				; CMover::IsPlayer
_TEXT	ENDS
PUBLIC	?GetPropA@CMover@@QAEPAUMoverProp@@XZ		; CMover::GetPropA
EXTRN	?prj@@3VCProject@@A:BYTE			; prj
; Function compile flags: /Ogty
;	COMDAT ?GetPropA@CMover@@QAEPAUMoverProp@@XZ
_TEXT	SEGMENT
?GetPropA@CMover@@QAEPAUMoverProp@@XZ PROC NEAR		; CMover::GetPropA, COMDAT
; _this$ = ecx

; 1046 : 	MoverProp*		GetProp() { return prj.GetMoverProp( m_dwIndex ); }	//    	

  00000	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  00006	85 c0		 test	 eax, eax
  00008	8b 0d d0 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+464
  0000e	7c 13		 jl	 SHORT $L282611
  00010	3b c1		 cmp	 eax, ecx
  00012	7d 0f		 jge	 SHORT $L282611
  00014	8b 0d d4 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+468
  0001a	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  00020	03 c1		 add	 eax, ecx
  00022	c3		 ret	 0
$L282611:
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00031	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	33 c0		 xor	 eax, eax
  0003b	c3		 ret	 0
?GetPropA@CMover@@QAEPAUMoverProp@@XZ ENDP		; CMover::GetPropA
_TEXT	ENDS
PUBLIC	?ClearDestObj@CMover@@QAEXXZ			; CMover::ClearDestObj
; Function compile flags: /Ogty
;	COMDAT ?ClearDestObj@CMover@@QAEXXZ
_TEXT	SEGMENT
?ClearDestObj@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDestObj, COMDAT
; _this$ = ecx

; 1056 : 	void			ClearDestObj()     	{ m_idDest = NULL_ID; m_fArrivalRange = 0.0f; }

  00000	c7 81 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+604], -1
  0000a	c7 81 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+600], 0
  00014	c3		 ret	 0
?ClearDestObj@CMover@@QAEXXZ ENDP			; CMover::ClearDestObj
_TEXT	ENDS
PUBLIC	?ClearDestPos@CMover@@QAEXXZ			; CMover::ClearDestPos
; Function compile flags: /Ogty
;	COMDAT ?ClearDestPos@CMover@@QAEXXZ
_TEXT	SEGMENT
$T282624 = -12						; size = 12
?ClearDestPos@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDestPos, COMDAT
; _this$ = ecx

; 1057 : 	void			ClearDestPos()		{ m_vDestPos = D3DXVECTOR3( 0.0f, 0.0f, 0.0f ); }		

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	c7 04 24 00 00
	00 00		 mov	 DWORD PTR $T282624[esp+12], 0
  0000a	8b 04 24	 mov	 eax, DWORD PTR $T282624[esp+12]
  0000d	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T282624[esp+16], 0
  0001d	8b 54 24 04	 mov	 edx, DWORD PTR $T282624[esp+16]
  00021	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T282624[esp+20], 0
  00029	8b 44 24 08	 mov	 eax, DWORD PTR $T282624[esp+20]
  0002d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00030	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	c3		 ret	 0
?ClearDestPos@CMover@@QAEXXZ ENDP			; CMover::ClearDestPos
_TEXT	ENDS
PUBLIC	?ClearDest@CMover@@QAEXXZ			; CMover::ClearDest
; Function compile flags: /Ogty
;	COMDAT ?ClearDest@CMover@@QAEXXZ
_TEXT	SEGMENT
$T282640 = -12						; size = 12
?ClearDest@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDest, COMDAT
; _this$ = ecx

; 1058 : 	void			ClearDest()			{ ClearDestObj(); ClearDestPos(); }

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	c7 81 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+604], -1
  0000d	c7 81 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+600], 0
  00017	c7 04 24 00 00
	00 00		 mov	 DWORD PTR $T282640[esp+12], 0
  0001e	8b 04 24	 mov	 eax, DWORD PTR $T282640[esp+12]
  00021	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  00027	89 01		 mov	 DWORD PTR [ecx], eax
  00029	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T282640[esp+16], 0
  00031	8b 54 24 04	 mov	 edx, DWORD PTR $T282640[esp+16]
  00035	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T282640[esp+20], 0
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR $T282640[esp+20]
  00041	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00044	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	c3		 ret	 0
?ClearDest@CMover@@QAEXXZ ENDP				; CMover::ClearDest
_TEXT	ENDS
PUBLIC	?GetSex@CMover@@QAEEXZ				; CMover::GetSex
; Function compile flags: /Ogty
;	COMDAT ?GetSex@CMover@@QAEEXZ
_TEXT	SEGMENT
?GetSex@CMover@@QAEEXZ PROC NEAR			; CMover::GetSex, COMDAT
; _this$ = ecx

; 1144 : 	BYTE			GetSex() { return m_bySex; }

  00000	8a 81 20 06 00
	00		 mov	 al, BYTE PTR [ecx+1568]
  00006	c3		 ret	 0
?GetSex@CMover@@QAEEXZ ENDP				; CMover::GetSex
_TEXT	ENDS
PUBLIC	?SetSex@CMover@@QAEXE@Z				; CMover::SetSex
; Function compile flags: /Ogty
;	COMDAT ?SetSex@CMover@@QAEXE@Z
_TEXT	SEGMENT
_bySex$ = 8						; size = 1
?SetSex@CMover@@QAEXE@Z PROC NEAR			; CMover::SetSex, COMDAT
; _this$ = ecx

; 1145 : 	void			SetSex( BYTE bySex ) { m_bySex = bySex; }

  00000	8a 44 24 04	 mov	 al, BYTE PTR _bySex$[esp-4]
  00004	88 81 20 06 00
	00		 mov	 BYTE PTR [ecx+1568], al
  0000a	c2 04 00	 ret	 4
?SetSex@CMover@@QAEXE@Z ENDP				; CMover::SetSex
_TEXT	ENDS
PUBLIC	?IsPeaceful@CMover@@QAEHXZ			; CMover::IsPeaceful
; Function compile flags: /Ogty
;	COMDAT ?IsPeaceful@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsPeaceful@CMover@@QAEHXZ PROC NEAR			; CMover::IsPeaceful, COMDAT
; _this$ = ecx

; 1146 : 	BOOL			IsPeaceful() { return m_dwBelligerence == BELLI_PEACEFUL; }

  00000	8b 91 6c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1644]
  00006	33 c0		 xor	 eax, eax
  00008	83 fa 01	 cmp	 edx, 1
  0000b	0f 94 c0	 sete	 al
  0000e	c3		 ret	 0
?IsPeaceful@CMover@@QAEHXZ ENDP				; CMover::IsPeaceful
_TEXT	ENDS
PUBLIC	?GetLevel@CMover@@QAEHXZ			; CMover::GetLevel
; Function compile flags: /Ogty
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetLevel@CMover@@QAEHXZ PROC NEAR			; CMover::GetLevel, COMDAT
; _this$ = ecx

; 1159 : 	int				GetLevel() { return m_nLevel; }

  00000	8b 81 e0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1504]
  00006	c3		 ret	 0
?GetLevel@CMover@@QAEHXZ ENDP				; CMover::GetLevel
_TEXT	ENDS
PUBLIC	?IsDie@CMover@@QAEHXZ				; CMover::IsDie
; Function compile flags: /Ogty
;	COMDAT ?IsDie@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsDie@CMover@@QAEHXZ PROC NEAR				; CMover::IsDie, COMDAT
; _this$ = ecx

; 1276 : 	BOOL			IsDie() { return m_pActMover->IsDie() || m_nHitPoint == 0; }

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  0000d	75 0d		 jne	 SHORT $L282659
  0000f	8b 81 00 06 00
	00		 mov	 eax, DWORD PTR [ecx+1536]
  00015	85 c0		 test	 eax, eax
  00017	74 03		 je	 SHORT $L282659
  00019	33 c0		 xor	 eax, eax
  0001b	c3		 ret	 0
$L282659:
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	c3		 ret	 0
?IsDie@CMover@@QAEHXZ ENDP				; CMover::IsDie
_TEXT	ENDS
PUBLIC	?IsLive@CMover@@QAEHXZ				; CMover::IsLive
; Function compile flags: /Ogty
;	COMDAT ?IsLive@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsLive@CMover@@QAEHXZ PROC NEAR			; CMover::IsLive, COMDAT
; _this$ = ecx

; 1277 : 	BOOL			IsLive() { return m_pActMover->IsDie() == FALSE || m_nHitPoint > 0; }		// &&   || .  != > 

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  0000d	74 0d		 je	 SHORT $L282667
  0000f	8b 81 00 06 00
	00		 mov	 eax, DWORD PTR [ecx+1536]
  00015	85 c0		 test	 eax, eax
  00017	7f 03		 jg	 SHORT $L282667
  00019	33 c0		 xor	 eax, eax
  0001b	c3		 ret	 0
$L282667:
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	c3		 ret	 0
?IsLive@CMover@@QAEHXZ ENDP				; CMover::IsLive
_TEXT	ENDS
PUBLIC	?SetPKPink@CMover@@QAEXK@Z			; CMover::SetPKPink
; Function compile flags: /Ogty
;	COMDAT ?SetPKPink@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwTime$ = 8						; size = 4
?SetPKPink@CMover@@QAEXK@Z PROC NEAR			; CMover::SetPKPink, COMDAT
; _this$ = ecx

; 1280 : 	void			SetPKPink( DWORD dwTime ) { if( dwTime == 0 || m_dwPKTime < dwTime ) m_dwPKTime = dwTime; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwTime$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L212436
  00008	39 81 58 07 00
	00		 cmp	 DWORD PTR [ecx+1880], eax
  0000e	73 06		 jae	 SHORT $L212435
$L212436:
  00010	89 81 58 07 00
	00		 mov	 DWORD PTR [ecx+1880], eax
$L212435:
  00016	c2 04 00	 ret	 4
?SetPKPink@CMover@@QAEXK@Z ENDP				; CMover::SetPKPink
_TEXT	ENDS
PUBLIC	?IsPKPink@CMover@@QAEHXZ			; CMover::IsPKPink
; Function compile flags: /Ogty
;	COMDAT ?IsPKPink@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsPKPink@CMover@@QAEHXZ PROC NEAR			; CMover::IsPKPink, COMDAT
; _this$ = ecx

; 1282 : 	BOOL			IsPKPink( void )	{ return m_dwPKTime > 0; }			/// PK  

  00000	8b 91 58 07 00
	00		 mov	 edx, DWORD PTR [ecx+1880]
  00006	33 c0		 xor	 eax, eax
  00008	3b c2		 cmp	 eax, edx
  0000a	1b c0		 sbb	 eax, eax
  0000c	f7 d8		 neg	 eax
  0000e	c3		 ret	 0
?IsPKPink@CMover@@QAEHXZ ENDP				; CMover::IsPKPink
_TEXT	ENDS
PUBLIC	?IsChaotic@CMover@@QAEHXZ			; CMover::IsChaotic
; Function compile flags: /Ogty
;	COMDAT ?IsChaotic@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsChaotic@CMover@@QAEHXZ PROC NEAR			; CMover::IsChaotic, COMDAT
; _this$ = ecx

; 1283 : 	BOOL			IsChaotic( void ) { return m_dwPKPropensity > 0; }	/// 

  00000	8b 91 60 07 00
	00		 mov	 edx, DWORD PTR [ecx+1888]
  00006	33 c0		 xor	 eax, eax
  00008	3b c2		 cmp	 eax, edx
  0000a	1b c0		 sbb	 eax, eax
  0000c	f7 d8		 neg	 eax
  0000e	c3		 ret	 0
?IsChaotic@CMover@@QAEHXZ ENDP				; CMover::IsChaotic
_TEXT	ENDS
PUBLIC	?GetPKValue@CMover@@QAEHXZ			; CMover::GetPKValue
; Function compile flags: /Ogty
;	COMDAT ?GetPKValue@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetPKValue@CMover@@QAEHXZ PROC NEAR			; CMover::GetPKValue, COMDAT
; _this$ = ecx

; 1285 : 	int				GetPKValue( void ) { return m_nPKValue; }

  00000	8b 81 5c 07 00
	00		 mov	 eax, DWORD PTR [ecx+1884]
  00006	c3		 ret	 0
?GetPKValue@CMover@@QAEHXZ ENDP				; CMover::GetPKValue
_TEXT	ENDS
PUBLIC	?IsSMMode@CMover@@QAEHH@Z			; CMover::IsSMMode
; Function compile flags: /Ogty
;	COMDAT ?IsSMMode@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nType$ = 8						; size = 4
?IsSMMode@CMover@@QAEHH@Z PROC NEAR			; CMover::IsSMMode, COMDAT
; _this$ = ecx

; 1483 : 	BOOL			IsSMMode( int nType ) { return ( m_dwSMTime[nType] > 0 ) ? TRUE : FALSE; }

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _nType$[esp-4]
  00004	56		 push	 esi
  00005	8b b4 91 04 03
	00 00		 mov	 esi, DWORD PTR [ecx+edx*4+772]
  0000c	33 c0		 xor	 eax, eax
  0000e	3b c6		 cmp	 eax, esi
  00010	1b c0		 sbb	 eax, eax
  00012	f7 d8		 neg	 eax
  00014	5e		 pop	 esi
  00015	c2 04 00	 ret	 4
?IsSMMode@CMover@@QAEHH@Z ENDP				; CMover::IsSMMode
_TEXT	ENDS
PUBLIC	?IsMode@CMover@@QAEHK@Z				; CMover::IsMode
EXTRN	?GetAdjParam@CMover@@QAEHH@Z:NEAR		; CMover::GetAdjParam
; Function compile flags: /Ogty
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?IsMode@CMover@@QAEHK@Z PROC NEAR			; CMover::IsMode, COMDAT
; _this$ = ecx

; 1762 : { 

  00000	53		 push	 ebx

; 1763 : #ifdef __HACK_0516
; 1764 : 	switch( dwMode )
; 1765 : 	{
; 1766 : 		case MATCHLESS_MODE:		//  
; 1767 : 		case ONEKILL_MODE:		//  
; 1768 : 		case MATCHLESS2_MODE:	//  2
; 1769 : 			if( m_dwAuthorization == AUTH_GENERAL )
; 1770 : 				return FALSE;
; 1771 : 			break;
; 1772 : 	}
; 1773 : #endif	// __HACK_0516
; 1774 : 	if( (dwMode & TRANSPARENT_MODE) )	//   

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _dwMode$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 16		 je	 SHORT $L212480

; 1775 : 		if( GetAdjParam(DST_CHRSTATE) & CHS_INVISIBILITY )	//  ?

  0000d	6a 40		 push	 64			; 00000040H
  0000f	e8 00 00 00 00	 call	 ?GetAdjParam@CMover@@QAEHH@Z ; CMover::GetAdjParam
  00014	f6 c4 04	 test	 ah, 4
  00017	74 0a		 je	 SHORT $L212480
  00019	5e		 pop	 esi

; 1776 : 			return TRUE;

  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	5b		 pop	 ebx

; 1778 : }	

  00020	c2 04 00	 ret	 4
$L212480:

; 1777 : 	return ( ( m_dwMode & dwMode ) == dwMode ) ? TRUE : FALSE; 

  00023	8b 86 44 02 00
	00		 mov	 eax, DWORD PTR [esi+580]
  00029	23 c3		 and	 eax, ebx
  0002b	2b c3		 sub	 eax, ebx
  0002d	f7 d8		 neg	 eax
  0002f	1b c0		 sbb	 eax, eax
  00031	5e		 pop	 esi
  00032	40		 inc	 eax
  00033	5b		 pop	 ebx

; 1778 : }	

  00034	c2 04 00	 ret	 4
?IsMode@CMover@@QAEHK@Z ENDP				; CMover::IsMode
_TEXT	ENDS
PUBLIC	?IsStateMode@CMover@@QAEHK@Z			; CMover::IsStateMode
; Function compile flags: /Ogty
;	COMDAT ?IsStateMode@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?IsStateMode@CMover@@QAEHK@Z PROC NEAR			; CMover::IsStateMode, COMDAT
; _this$ = ecx

; 1782 : 	return ( ( m_dwStateMode & dwMode ) == dwMode ) ? TRUE : FALSE; 

  00000	8b 81 4c 02 00
	00		 mov	 eax, DWORD PTR [ecx+588]
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwMode$[esp-4]
  0000a	23 c1		 and	 eax, ecx
  0000c	2b c1		 sub	 eax, ecx
  0000e	f7 d8		 neg	 eax
  00010	1b c0		 sbb	 eax, eax
  00012	40		 inc	 eax

; 1783 : }	

  00013	c2 04 00	 ret	 4
?IsStateMode@CMover@@QAEHK@Z ENDP			; CMover::IsStateMode
_TEXT	ENDS
PUBLIC	?IsFly@CMover@@QAEHXZ				; CMover::IsFly
; Function compile flags: /Ogty
;	COMDAT ?IsFly@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsFly@CMover@@QAEHXZ PROC NEAR				; CMover::IsFly, COMDAT
; _this$ = ecx

; 1787 : #ifdef _DEBUG
; 1788 : 	if( IsNPC() )
; 1789 : 	{
; 1790 : 		Error( _T( "CMover::IsFly : NPC IsFly()  . IsFlyingNPC() ! %s" ), m_szName );
; 1791 : 		return FALSE;
; 1792 : 	}
; 1793 : #endif
; 1794 : 	return m_pActMover->IsFly();

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00009	c1 e8 03	 shr	 eax, 3
  0000c	83 e0 01	 and	 eax, 1

; 1795 : }

  0000f	c3		 ret	 0
?IsFly@CMover@@QAEHXZ ENDP				; CMover::IsFly
_TEXT	ENDS
PUBLIC	?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z	; CMover::SendActMsg
; Function compile flags: /Ogty
;	COMDAT ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z
_TEXT	SEGMENT
_dwMsg$ = 8						; size = 4
_nParam1$ = 12						; size = 4
_nParam2$ = 16						; size = 4
_nParam3$ = 20						; size = 4
_nParam4$ = 24						; size = 4
?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z PROC NEAR	; CMover::SendActMsg, COMDAT
; _this$ = ecx

; 1820 : 	if( m_pActMover )	

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $L212505

; 1821 : 		return m_pActMover->SendActMsg( dwMsg, nParam1, nParam2, nParam3, nParam4 );	

  0000a	8b 54 24 14	 mov	 edx, DWORD PTR _nParam4$[esp-4]
  0000e	6a 00		 push	 0
  00010	52		 push	 edx
  00011	8b 54 24 18	 mov	 edx, DWORD PTR _nParam3$[esp+4]
  00015	52		 push	 edx
  00016	8b 54 24 18	 mov	 edx, DWORD PTR _nParam2$[esp+8]
  0001a	52		 push	 edx
  0001b	8b 54 24 18	 mov	 edx, DWORD PTR _nParam1$[esp+12]
  0001f	52		 push	 edx
  00020	8b 54 24 18	 mov	 edx, DWORD PTR _dwMsg$[esp+16]
  00024	8b c8		 mov	 ecx, eax
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	52		 push	 edx
  00029	ff 50 04	 call	 DWORD PTR [eax+4]

; 1824 : }

  0002c	c2 14 00	 ret	 20			; 00000014H
$L212505:

; 1822 : 	else
; 1823 : 		return 0;

  0002f	33 c0		 xor	 eax, eax

; 1824 : }

  00031	c2 14 00	 ret	 20			; 00000014H
?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z ENDP		; CMover::SendActMsg
_TEXT	ENDS
PUBLIC	?GetGold@CMover@@QAEHXZ				; CMover::GetGold
; Function compile flags: /Ogty
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetGold@CMover@@QAEHXZ PROC NEAR			; CMover::GetGold, COMDAT
; _this$ = ecx

; 1829 : 	int nGold = m_dwGold;
; 1830 : //	nGold -= m_vtInfo.TradeGetGold();
; 1831 : 	ASSERT( nGold >= 0 );
; 1832 : 	return nGold;

  00000	8b 81 84 16 00
	00		 mov	 eax, DWORD PTR [ecx+5764]

; 1833 : }

  00006	c3		 ret	 0
?GetGold@CMover@@QAEHXZ ENDP				; CMover::GetGold
_TEXT	ENDS
PUBLIC	?GetID@CWorld@@QAEKXZ				; CWorld::GetID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\world.h
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT
?GetID@CWorld@@QAEKXZ PROC NEAR				; CWorld::GetID, COMDAT
; _this$ = ecx

; 413  : 	DWORD			GetID()	{ return m_dwWorldID; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetID@CWorld@@QAEKXZ ENDP				; CWorld::GetID
_TEXT	ENDS
PUBLIC	?IsArena@CWorld@@QAEHXZ				; CWorld::IsArena
; Function compile flags: /Ogty
;	COMDAT ?IsArena@CWorld@@QAEHXZ
_TEXT	SEGMENT
?IsArena@CWorld@@QAEHXZ PROC NEAR			; CWorld::IsArena, COMDAT
; _this$ = ecx

; 417  : 		{	return( m_dwWorldID == WI_WORLD_ARENA );	}

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	81 fa d0 00 00
	00		 cmp	 edx, 208		; 000000d0H
  0000a	0f 94 c0	 sete	 al
  0000d	c3		 ret	 0
?IsArena@CWorld@@QAEHXZ ENDP				; CWorld::IsArena
_TEXT	ENDS
PUBLIC	??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ		; ATL::CSimpleStringT<char,0>::operator char const *
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::operator char const *, COMDAT
; _this$ = ecx

; 379  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 380  : 	}

  00002	c3		 ret	 0
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP		; ATL::CSimpleStringT<char,0>::operator char const *
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1109 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1110 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ	; CFixedArray<ItemProp>::GetSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ PROC NEAR	; CFixedArray<ItemProp>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ ENDP		; CFixedArray<ItemProp>::GetSize
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ	; CFixedArray<tagColorText>::GetSize
; Function compile flags: /Ogty
;	COMDAT ?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ PROC NEAR ; CFixedArray<tagColorText>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UtagColorText@@@@QAEHXZ ENDP	; CFixedArray<tagColorText>::GetSize
_TEXT	ENDS
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 510  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 511  : 	}

  00002	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
PUBLIC	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
; Function compile flags: /Ogty
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::StringLength, COMDAT

; 678  : 		if( psz == NULL )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _psz$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 01		 jne	 SHORT $L219971

; 683  : 	}

  00008	c3		 ret	 0
$L219971:

; 679  : 		{
; 680  : 			return( 0 );
; 681  : 		}
; 682  : 		return( int( strlen( psz ) ) );

  00009	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$L282729:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L282729
  00017	2b c2		 sub	 eax, edx

; 683  : 	}

  00019	c3		 ret	 0
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::StringLength
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
; Function compile flags: /Ogty
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  00005	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Ogty
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L219986
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L219986

; 794  : 			AtlThrow(E_INVALIDARG);
; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 797  : 		m_pszData[nLength] = 0;

  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 798  : 	}

  00018	c2 04 00	 ret	 4
$L219986:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L282743:
$L282742:
  00025	cc		 int	 3
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
EXTRN	?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z:NEAR ; AfxFindStringResourceHandle
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\afxstr.h
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance, COMDAT

; 45   : 		return( AfxFindStringResourceHandle( nID ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nID$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle

; 46   : 	}

  0000a	c3		 ret	 0
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
_TEXT	ENDS
PUBLIC	?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
EXTRN	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ:NEAR ; AfxGetStringManager
; Function compile flags: /Ogty
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 50   : 		return( AfxGetStringManager() );

  00000	e9 00 00 00 00	 jmp	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
PUBLIC	?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z ; ATL::ChTraitsCRT<char>::StringFindString
EXTRN	__mbsstr:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z
_TEXT	SEGMENT
_pszBlock$ = 8						; size = 4
_pszMatch$ = 12						; size = 4
?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z PROC NEAR ; ATL::ChTraitsCRT<char>::StringFindString, COMDAT

; 356  : 		return reinterpret_cast< LPCSTR >( _mbsstr( reinterpret_cast< const unsigned char* >( pszBlock ),
; 357  : 			reinterpret_cast< const unsigned char* >( pszMatch ) ) );

  00000	e9 00 00 00 00	 jmp	 __mbsstr
?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z ENDP	; ATL::ChTraitsCRT<char>::StringFindString
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L282758
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  00009	c3		 ret	 0
$L282758:

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??R?$less@K@std@@QBE_NABK0@Z			; std::less<unsigned long>::operator()
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@K@std@@QBE_NABK0@Z PROC NEAR			; std::less<unsigned long>::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (_Left < _Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 54 24 08	 mov	 edx, DWORD PTR __Right$[esp-4]
  0000a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000c	1b c0		 sbb	 eax, eax
  0000e	f7 d8		 neg	 eax

; 140  : 		}

  00010	c2 08 00	 ret	 8
??R?$less@K@std@@QBE_NABK0@Z ENDP			; std::less<unsigned long>::operator()
_TEXT	ENDS
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L282772
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L282772:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx

; 517  : 		}

  0000f	c3		 ret	 0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
PUBLIC	??0?$allocator@E@std@@QAE@ABV01@@Z		; std::allocator<unsigned char>::allocator<unsigned char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@E@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@E@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil
; Function compile flags: /Ogty
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pData$[esp-4]
  00004	83 c0 10	 add	 eax, 16			; 00000010H
  00007	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00009	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ; ATL::ChTraitsCRT<char>::GetFormattedLength
EXTRN	__vscprintf:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetFormattedLength, COMDAT

; 408  : 		return _vscprintf( pszFormat, args );

  00000	e9 00 00 00 00	 jmp	 __vscprintf
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ENDP ; ATL::ChTraitsCRT<char>::GetFormattedLength
_TEXT	ENDS
PUBLIC	?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z	; ATL::ChTraitsCRT<char>::Format
EXTRN	_vsprintf:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT
_pszBuffer$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
_args$ = 16						; size = 4
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z PROC NEAR	; ATL::ChTraitsCRT<char>::Format, COMDAT

; 413  : 		return vsprintf( pszBuffer, pszFormat, args );

  00000	e9 00 00 00 00	 jmp	 _vsprintf
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z ENDP		; ATL::ChTraitsCRT<char>::Format
_TEXT	ENDS
PUBLIC	?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z ; ATL::ChTraitsCRT<char>::GetBaseTypeLength
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT
_pszSource$ = 8						; size = 4
_nLength$ = 12						; size = 4
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetBaseTypeLength, COMDAT

; 437  : 		// Returns required buffer length in XCHARs
; 438  : 		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, nLength, NULL, 0, NULL, NULL );

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR _nLength$[esp-4]
  0000a	8b 54 24 04	 mov	 edx, DWORD PTR _pszSource$[esp-4]
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	6a 00		 push	 0
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 439  : 	}

  00021	c3		 ret	 0
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z ENDP	; ATL::ChTraitsCRT<char>::GetBaseTypeLength
_TEXT	ENDS
PUBLIC	?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z ; ATL::ChTraitsCRT<char>::ConvertToBaseType
; Function compile flags: /Ogty
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_nDestLength$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nSrcLength$ = 20					; size = 4
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z PROC NEAR ; ATL::ChTraitsCRT<char>::ConvertToBaseType, COMDAT

; 452  : 		// nLen is in XCHARs
; 453  : 		::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nDestLength$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _pszDest$[esp-4]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR _nSrcLength$[esp-4]
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	8b 44 24 18	 mov	 eax, DWORD PTR _pszSrc$[esp+8]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 454  : 	}

  00027	c3		 ret	 0
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z ENDP ; ATL::ChTraitsCRT<char>::ConvertToBaseType
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L282828
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  00009	c3		 ret	 0
$L282828:

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@E@std@@QAEXPAEI@Z	; std::allocator<unsigned char>::deallocate
; Function compile flags: /Ogty
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXPAEI@Z PROC NEAR	; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@E@std@@QAEXPAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCMover@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCMover@@@2@@Z ENDP ; std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nChars$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp]
  00009	8b c1		 mov	 eax, ecx
  0000b	57		 push	 edi
  0000c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pchDest$[esp+4]
  00010	c1 e9 02	 shr	 ecx, 2
  00013	f3 a5		 rep movsd
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	f3 a4		 rep movsb
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 654  : 	}

  0001e	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
; Function compile flags: /Ogty
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	e9 00 00 00 00	 jmp	 _memmove
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Ogty
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00000	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00005	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L282877:
$L282876:
  0000a	cc		 int	 3
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Ogty
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv181 = 8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 716  : 		CStringData* pOldData = GetData();

  00002	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00004	83 eb 10	 sub	 ebx, 16			; 00000010H
  00007	55		 push	 ebp

; 717  : 		int nOldLength = pOldData->nDataLength;

  00008	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$[esp+12], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0000f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 10	 call	 DWORD PTR [eax+16]
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _nLength$[esp+12]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	6a 01		 push	 1
  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	ff 12		 call	 DWORD PTR [edx]

; 719  : 		if( pNewData == NULL )

  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $L222762

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00028	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L282908:
$L222762:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0002d	3b ee		 cmp	 ebp, esi
  0002f	7d 02		 jge	 SHORT $L282882
  00031	8b f5		 mov	 esi, ebp
$L282882:
  00033	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  00036	8b d1		 mov	 edx, ecx
  00038	57		 push	 edi
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	89 7c 24 18	 mov	 DWORD PTR tv181[esp+16], edi
  00043	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00046	f3 a5		 rep movsd
  00048	8b ca		 mov	 ecx, edx
  0004a	83 e1 03	 and	 ecx, 3
  0004d	f3 a4		 rep movsb

; 725  : 		pNewData->nDataLength = nOldLength;

  0004f	89 68 04	 mov	 DWORD PTR [eax+4], ebp

; 726  : 		pOldData->Release();

  00052	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00055	83 c9 ff	 or	 ecx, -1
  00058	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0005c	49		 dec	 ecx
  0005d	85 c9		 test	 ecx, ecx
  0005f	5f		 pop	 edi
  00060	7f 08		 jg	 SHORT $L282898
  00062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	53		 push	 ebx
  00067	ff 52 04	 call	 DWORD PTR [edx+4]
$L282898:

; 727  : 		Attach( pNewData );

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR tv181[esp+12]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	5b		 pop	 ebx

; 728  : 	}

  00077	59		 pop	 ecx
  00078	c2 04 00	 ret	 4
$L282907:
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Ogty
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 777  : 		CStringData* pOldData = GetData();
; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nLength$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	83 e8 10	 sub	 eax, 16			; 00000010H
  00012	6a 01		 push	 1
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	ff 52 08	 call	 DWORD PTR [edx+8]

; 781  : 		if( pNewData == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L222771

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0001d	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L282924:
$L222771:

; 784  : 		}
; 785  : 		Attach( pNewData );

  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	5f		 pop	 edi
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	5e		 pop	 esi

; 786  : 	}

  00029	c2 04 00	 ret	 4
$L282923:
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00001	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  00004	83 fe 10	 cmp	 esi, 16			; 00000010H
  00007	57		 push	 edi
  00008	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0000b	72 04		 jb	 SHORT $L282933
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	eb 02		 jmp	 SHORT $L282934
$L282933:
  00011	8b d0		 mov	 edx, eax
$L282934:
  00013	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00017	3b fa		 cmp	 edi, edx
  00019	72 17		 jb	 SHORT $L222788
  0001b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0001e	72 02		 jb	 SHORT $L282941
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L282941:
  00022	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00025	03 c8		 add	 ecx, eax
  00027	3b cf		 cmp	 ecx, edi
  00029	76 07		 jbe	 SHORT $L222788
  0002b	5f		 pop	 edi

; 1497 : 		else
; 1498 : 			return (true);

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi

; 1499 : 		}

  0002f	c2 04 00	 ret	 4
$L222788:
  00032	5f		 pop	 edi

; 1496 : 			return (false);	// don't ask

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 1499 : 		}

  00036	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@E@std@@QBEIXZ		; std::allocator<unsigned char>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@E@std@@QBEIXZ PROC NEAR		; std::allocator<unsigned char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 159  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@E@std@@QBEIXZ ENDP		; std::allocator<unsigned char>::max_size
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 159  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ; CFixedArray<ItemProp>::GetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z PROC NEAR ; CFixedArray<ItemProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224299

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224299:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ENDP ; CFixedArray<ItemProp>::GetAt
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z ; CFixedArray<tagColorText>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z PROC NEAR ; CFixedArray<tagColorText>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224363

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224363:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UtagColorText@@@@QAEPAUtagColorText@@K@Z ENDP ; CFixedArray<tagColorText>::GetAt
_TEXT	ENDS
PUBLIC	?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwId$ = 8						; size = 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtId, COMDAT
; _this$ = ecx

; 518  : 	if( dwId >= (DWORD)( GetMax() ) ) return NULL;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwId$[esp-4]
  00004	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00007	72 05		 jb	 SHORT $L224421
  00009	33 c0		 xor	 eax, eax

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  0000b	c2 04 00	 ret	 4
$L224421:

; 519  : 	T* pItemElem = &m_apItem[ dwId ];

  0000e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00011	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00017	03 c2		 add	 eax, edx
  00019	8b c8		 mov	 ecx, eax

; 520  : 	if( pItemElem->IsEmpty() ) 

  0001b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001e	f7 d8		 neg	 eax
  00020	1b c0		 sbb	 eax, eax
  00022	23 c1		 and	 eax, ecx

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  00024	c2 04 00	 ret	 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAtId
_TEXT	ENDS
PUBLIC	??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z PROC NEAR ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Allocate@E@std@@YAPAEIPAE@Z			; std::_Allocate<unsigned char>
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@E@std@@YAPAEIPAE@Z PROC NEAR		; std::_Allocate<unsigned char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@E@std@@YAPAEIPAE@Z ENDP			; std::_Allocate<unsigned char>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
EXTRN	__time64:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC NEAR		; ATL::CTime::GetTickCount, COMDAT

; 139  : 	return( CTime( ::_time64( NULL ) ) );

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	83 c4 04	 add	 esp, 4
  00010	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00013	8b c1		 mov	 eax, ecx

; 140  : }

  00015	c2 04 00	 ret	 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
_TEXT	ENDS
PUBLIC	??_C@_0CL@ILELHNJ@OnEndSkillState?5?3?5?$LN?$LK?E?$LD?$MA?G?5?$LJ?$PM?$MA?$KH?$LI?$KG?5@ ; `string'
PUBLIC	??_C@_0BA@LLKPHDJP@OnEndSkillState?$AA@		; `string'
PUBLIC	?OnEndSkillState@CMover@@QAEXKK@Z		; CMover::OnEndSkillState
EXTRN	?GetParam@CMover@@QAEHHH@Z:NEAR			; CMover::GetParam
EXTRN	?ResetDestParam@CMover@@QAEXHHH@Z:NEAR		; CMover::ResetDestParam
EXTRN	?ResetState@CAction@@QAEXK@Z:NEAR		; CAction::ResetState
;	COMDAT ??_C@_0BA@LLKPHDJP@OnEndSkillState?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BA@LLKPHDJP@OnEndSkillState?$AA@ DB 'OnEndSkillState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ILELHNJ@OnEndSkillState?5?3?5?$LN?$LK?E?$LD?$MA?G?5?$LJ?$PM?$MA?$KH?$LI?$KG?5@
CONST	SEGMENT
??_C@_0CL@ILELHNJ@OnEndSkillState?5?3?5?$LN?$LK?E?$LD?$MA?G?5?$LJ?$PM?$MA?$KH?$LI?$KG?5@ DB 'O'
	DB	'nEndSkillState : ', 0bdH, 0baH, 0c5H, 0b3H, 0c0H, 0c7H, ' ', 0b9H
	DB	0fcH, 0c0H, 0a7H, 0b8H, 0a6H, ' ', 0b3H, 0d1H, 0beH, 0eeH, 0bcH
	DB	0b6H, '. %d', 00H				; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?OnEndSkillState@CMover@@QAEXKK@Z
_TEXT	SEGMENT
_pSkillProp$ = -4					; size = 4
_pAddSkillProp$ = 8					; size = 4
_dwSkill$ = 8						; size = 4
_dwLevel$ = 12						; size = 4
?OnEndSkillState@CMover@@QAEXKK@Z PROC NEAR		; CMover::OnEndSkillState, COMDAT
; _this$ = ecx

; 1096 : {

  00000	51		 push	 ecx

; 1097 : 	if( dwSkill < 0 || (int)( dwSkill ) > prj.m_aPropSkill.GetSize() )

  00001	a1 80 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+640
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7c 24 10	 mov	 edi, DWORD PTR _dwSkill$[esp+8]
  0000c	3b f8		 cmp	 edi, eax
  0000e	8b f1		 mov	 esi, ecx
  00010	0f 8f 99 00 00
	00		 jg	 $L274562

; 1100 : 		return;
; 1101 : 	}
; 1102 : 	ItemProp* pSkillProp = NULL;
; 1103 : 	AddSkillProp *pAddSkillProp = NULL;
; 1104 : 	GetSkillProp( &pSkillProp, &pAddSkillProp, dwSkill, dwLevel, "OnEndSkillState" );

  00016	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwLevel$[esp+8]
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@LLKPHDJP@OnEndSkillState?$AA@
  00021	51		 push	 ecx
  00022	57		 push	 edi
  00023	8d 54 24 1c	 lea	 edx, DWORD PTR _pAddSkillProp$[esp+20]
  00027	52		 push	 edx
  00028	8d 4c 24 18	 lea	 ecx, DWORD PTR _pSkillProp$[esp+28]
  0002c	51		 push	 ecx
  0002d	8b ce		 mov	 ecx, esi
  0002f	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _pSkillProp$[esp+32], 0
  00037	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _pAddSkillProp$[esp+28], 0
  0003f	ff 50 30	 call	 DWORD PTR [eax+48]

; 1105 : 
; 1106 : 	if( dwSkill == SI_ACR_YOYO_COUNTER )	//   

  00042	81 ff cc 00 00
	00		 cmp	 edi, 204		; 000000ccH
  00048	75 40		 jne	 SHORT $L274567

; 1107 : 	{
; 1108 : 		m_pActMover->ResetState( OBJSTA_ATK_ALL );		//  .  (     )

  0004a	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00050	68 00 00 ff 00	 push	 16711680		; 00ff0000H
  00055	e8 00 00 00 00	 call	 ?ResetState@CAction@@QAEXK@Z ; CAction::ResetState
$L274569:

; 1146 : 	else
; 1147 : #endif // __3RD_LEGEND16
; 1148 : 	{
; 1149 : 		ResetDestParam( pAddSkillProp->dwDestParam1, pAddSkillProp->nAdjParamVal1, bSend );

  0005a	8b 44 24 10	 mov	 eax, DWORD PTR _pAddSkillProp$[esp+8]
  0005e	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00061	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00064	6a 01		 push	 1
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 1150 : 		ResetDestParam( pAddSkillProp->dwDestParam2, pAddSkillProp->nAdjParamVal2, bSend );

  0006f	8b 44 24 10	 mov	 eax, DWORD PTR _pAddSkillProp$[esp+8]
  00073	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00076	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  00079	6a 01		 push	 1
  0007b	51		 push	 ecx
  0007c	52		 push	 edx
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 1151 : 	}
; 1152 : #endif
; 1153 : 
; 1154 : 
; 1155 : }

  00086	59		 pop	 ecx
  00087	c2 08 00	 ret	 8
$L274567:

; 1109 : 	}
; 1110 : #if defined( __CLIENT ) 
; 1111 : /*	// 091022 mirchang - ,      sfx 
; 1112 : 	#if __VER >= 11 // __MA_VER11_06				//   world,neuz
; 1113 : 	if(	dwSkill == SI_MAG_FIRE_HOTAIR)
; 1114 : 	{
; 1115 : 		SetRemoveSfxObj( pSkillProp->dwSfxObj2 );
; 1116 : //		CSfx *pSfx = prj.GetSfx((this)->m_dwObjID,
; 1117 : //		if(pSfx)
; 1118 : //			pSfx->m_nSec = 0;	
; 1119 : 	}
; 1120 : 	if(	dwSkill == SI_PSY_HERO_STONE)
; 1121 : 	{
; 1122 : 		SetRemoveSfxObj( pSkillProp->dwSfxObj4 );
; 1123 : 	}
; 1124 : 	#endif // __MA_VER11_06				//   world,neuz
; 1125 : */	// 091022 mirchang - ,      sfx 
; 1126 : 	switch( dwSkill )	// 091022 mirchang - ,      sfx 
; 1127 : 	{
; 1128 : 		case SI_MAG_FIRE_HOTAIR :
; 1129 : 			SetRemoveSfxObj( pSkillProp->dwSfxObj2 );
; 1130 : 			break;
; 1131 : 		case SI_PSY_HERO_STONE :
; 1132 : 		case SI_MER_SHIELD_PANBARRIER:
; 1133 : 		case SI_MER_SHIELD_PROTECTION:
; 1134 : 			SetRemoveSfxObj( pSkillProp->dwSfxObj4 );
; 1135 : 			break;
; 1136 : 	}
; 1137 :   #endif	// 
; 1138 : 
; 1139 : 	BOOL	bSend = FALSE;
; 1140 : #ifdef __WORLDSERVER
; 1141 : 	bSend = TRUE;			//   .
; 1142 : 
; 1143 : #ifdef __3RD_LEGEND16
; 1144 : 	if( dwSkill == SI_FLO_SUP_ABSOLUTE )

  0008a	81 ff a5 01 00
	00		 cmp	 edi, 421		; 000001a5H
  00090	75 c8		 jne	 SHORT $L274569

; 1145 : 		ResetDestParam( DST_IGNORE_DMG_PVP, GetParam( DST_IGNORE_DMG_PVP, 0), bSend );

  00092	6a 01		 push	 1
  00094	6a 00		 push	 0
  00096	6a 5e		 push	 94			; 0000005eH
  00098	8b ce		 mov	 ecx, esi
  0009a	e8 00 00 00 00	 call	 ?GetParam@CMover@@QAEHHH@Z ; CMover::GetParam
  0009f	50		 push	 eax
  000a0	6a 5e		 push	 94			; 0000005eH
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi

; 1151 : 	}
; 1152 : #endif
; 1153 : 
; 1154 : 
; 1155 : }

  000ab	59		 pop	 ecx
  000ac	c2 08 00	 ret	 8
$L274562:

; 1098 : 	{
; 1099 : 		Error( "OnEndSkillState :   . %d", dwSkill );

  000af	57		 push	 edi
  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@ILELHNJ@OnEndSkillState?5?3?5?$LN?$LK?E?$LD?$MA?G?5?$LJ?$PM?$MA?$KH?$LI?$KG?5@
  000b5	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000ba	83 c4 08	 add	 esp, 8
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi

; 1151 : 	}
; 1152 : #endif
; 1153 : 
; 1154 : 
; 1155 : }

  000bf	59		 pop	 ecx
  000c0	c2 08 00	 ret	 8
?OnEndSkillState@CMover@@QAEXKK@Z ENDP			; CMover::OnEndSkillState
_TEXT	ENDS
PUBLIC	__real@40400000
PUBLIC	__real@3fc00000
PUBLIC	?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z	; CMover::OnAfterUseItem
EXTRN	?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z:NEAR ; CUserMng::AddCreateSfxObj
EXTRN	?GetUnderHeight@CWorld@@QAEMABUD3DXVECTOR3@@@Z:NEAR ; CWorld::GetUnderHeight
EXTRN	?SetHonorAdd@CMover@@QAEXHHH@Z:NEAR		; CMover::SetHonorAdd
EXTRN	?g_UserMng@@3VCUserMng@@A:BYTE			; g_UserMng
;	COMDAT __real@40400000
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z
_TEXT	SEGMENT
_sPos$ = -60						; size = 12
$T283017 = -48						; size = 12
$T283016 = -48						; size = 12
$T283015 = -48						; size = 12
$T283014 = -48						; size = 12
$T283018 = -36						; size = 12
$T283019 = -24						; size = 12
$T283020 = -12						; size = 12
_fTheta$274630 = 8					; size = 4
_pItemProp$ = 8						; size = 4
?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z PROC NEAR	; CMover::OnAfterUseItem, COMDAT
; _this$ = ecx

; 1263 : {

  00000	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1264 : #ifdef __WORLDSERVER
; 1265 : 	if( pItemProp == NULL )

  00005	8b 7c 24 48	 mov	 edi, DWORD PTR _pItemProp$[esp+64]
  00009	85 ff		 test	 edi, edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	0f 84 89 01 00
	00		 je	 $L274646

; 1266 : 		return;
; 1267 : 
; 1268 : 	D3DXVECTOR3 sPos = D3DXVECTOR3(0.0f,0.0f,0.0f);
; 1269 : 	DWORD dwSfxID = pItemProp->dwSfxObj3;		//    
; 1270 : 
; 1271 : 	if(	pItemProp->dwItemKind3 == IK3_MAGICTRICK ) //  

  00013	83 7f 78 21	 cmp	 DWORD PTR [edi+120], 33	; 00000021H
  00017	53		 push	 ebx
  00018	8b 9f dc 01 00
	00		 mov	 ebx, DWORD PTR [edi+476]
  0001e	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _sPos$[esp+72], 0
  00026	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _sPos$[esp+76], 0
  0002e	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _sPos$[esp+80], 0
  00036	0f 85 25 01 00
	00		 jne	 $L274633

; 1272 : 	{
; 1273 : 		float	fTheta = D3DXToRadian( GetAngle() );

  0003c	d9 46 18	 fld	 DWORD PTR [esi+24]

; 1274 : 		switch( pItemProp->dwID )

  0003f	8b 07		 mov	 eax, DWORD PTR [edi]
  00041	3d 5c 0b 00 00	 cmp	 eax, 2908		; 00000b5cH
  00046	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c8efa35
  0004c	d9 5c 24 4c	 fstp	 DWORD PTR _fTheta$274630[esp+68]
  00050	77 56		 ja	 SHORT $L283021
  00052	74 71		 je	 SHORT $L274636
  00054	2d 58 0b 00 00	 sub	 eax, 2904		; 00000b58H
  00059	83 f8 03	 cmp	 eax, 3
  0005c	0f 87 ff 00 00
	00		 ja	 $L274633
  00062	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L283065[eax*4]
$L274641:

; 1285 : 			break;
; 1286 : 		case II_GEN_MAG_TRI_NEWYEARBOMB:
; 1287 : 		case II_GEN_MAG_TRI_SULNALBOMB:
; 1288 : 		case II_GEN_MAG_TRI_GOODBYEBOMB:
; 1289 : 			sPos.x = GetPos().x;

  00069	8d 44 24 24	 lea	 eax, DWORD PTR $T283018[esp+72]
  0006d	50		 push	 eax
  0006e	8b ce		 mov	 ecx, esi
  00070	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1290 : 			sPos.z = GetPos().z;

  00077	8d 54 24 30	 lea	 edx, DWORD PTR $T283019[esp+72]
  0007b	89 4c 24 0c	 mov	 DWORD PTR _sPos$[esp+72], ecx
  0007f	52		 push	 edx
  00080	8b ce		 mov	 ecx, esi
  00082	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  00087	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1291 : 			sPos.y = GetPos().y + 3.0f;

  0008a	8d 4c 24 3c	 lea	 ecx, DWORD PTR $T283020[esp+72]
  0008e	51		 push	 ecx
  0008f	8b ce		 mov	 ecx, esi
  00091	89 44 24 18	 mov	 DWORD PTR _sPos$[esp+84], eax
  00095	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  0009a	d9 40 04	 fld	 DWORD PTR [eax+4]
  0009d	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@40400000

; 1292 : 			break;

  000a3	e9 b5 00 00 00	 jmp	 $L283064
$L283021:

; 1274 : 		switch( pItemProp->dwID )

  000a8	3d ed 27 00 00	 cmp	 eax, 10221		; 000027edH
  000ad	0f 82 ae 00 00
	00		 jb	 $L274633
  000b3	3d ee 27 00 00	 cmp	 eax, 10222		; 000027eeH
  000b8	76 0b		 jbe	 SHORT $L274636
  000ba	3d f0 27 00 00	 cmp	 eax, 10224		; 000027f0H
  000bf	0f 85 9c 00 00
	00		 jne	 $L274633
$L274636:

; 1275 : 		{
; 1276 : 		case II_GEN_MAG_TRI_FIRESHOWER:
; 1277 : 		case II_GEN_MAG_TRI_HWFIREWORKS:
; 1278 : 		case II_CHR_MAG_TRI_ROCKETBOMB:
; 1279 : 		case II_CHR_MAG_TRI_HEARTBOMB:
; 1280 : 		case II_CHR_MAG_TRI_TWISTERBOMB:
; 1281 : 			sPos.x = GetPos().x + sinf(fTheta) * 3.0f;			//   1  .

  000c5	d9 44 24 4c	 fld	 DWORD PTR _fTheta$274630[esp+68]
  000c9	8d 86 60 01 00
	00		 lea	 eax, DWORD PTR [esi+352]
  000cf	d9 fe		 fsin
  000d1	8b d0		 mov	 edx, eax
  000d3	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000d5	89 4c 24 18	 mov	 DWORD PTR $T283014[esp+72], ecx
  000d9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000dc	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000df	89 4c 24 1c	 mov	 DWORD PTR $T283014[esp+76], ecx
  000e3	89 54 24 20	 mov	 DWORD PTR $T283014[esp+80], edx

; 1282 : 			sPos.z = GetPos().z + -cosf(fTheta) * 3.0f;

  000e7	8b c8		 mov	 ecx, eax
  000e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000eb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40400000
  000f1	d8 44 24 18	 fadd	 DWORD PTR $T283014[esp+72]
  000f5	89 54 24 18	 mov	 DWORD PTR $T283015[esp+72], edx
  000f9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fc	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000ff	d9 54 24 0c	 fst	 DWORD PTR _sPos$[esp+72]
  00103	89 4c 24 20	 mov	 DWORD PTR $T283015[esp+80], ecx
  00107	d9 44 24 4c	 fld	 DWORD PTR _fTheta$274630[esp+68]

; 1283 : 			sPos.y = GetPos().y + 1.5f;

  0010b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010e	d9 ff		 fcos
  00110	89 54 24 1c	 mov	 DWORD PTR $T283015[esp+76], edx
  00114	8b 10		 mov	 edx, DWORD PTR [eax]
  00116	89 4c 24 1c	 mov	 DWORD PTR $T283016[esp+76], ecx

; 1284 : 			sPos.y = GetWorld()->GetUnderHeight( D3DXVECTOR3(sPos.x,sPos.y,sPos.z) );

  0011a	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00120	89 54 24 18	 mov	 DWORD PTR $T283016[esp+72], edx
  00124	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00127	8d 44 24 18	 lea	 eax, DWORD PTR $T283017[esp+72]
  0012b	50		 push	 eax
  0012c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40400000
  00132	d8 6c 24 24	 fsubr	 DWORD PTR $T283015[esp+84]
  00136	89 54 24 24	 mov	 DWORD PTR $T283016[esp+84], edx
  0013a	d9 54 24 18	 fst	 DWORD PTR _sPos$[esp+84]
  0013e	d9 44 24 20	 fld	 DWORD PTR $T283016[esp+80]
  00142	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3fc00000
  00148	d9 ca		 fxch	 ST(2)
  0014a	d9 5c 24 1c	 fstp	 DWORD PTR $T283017[esp+76]
  0014e	d9 c9		 fxch	 ST(1)
  00150	d9 5c 24 20	 fstp	 DWORD PTR $T283017[esp+80]
  00154	d9 5c 24 24	 fstp	 DWORD PTR $T283017[esp+84]
  00158	e8 00 00 00 00	 call	 ?GetUnderHeight@CWorld@@QAEMABUD3DXVECTOR3@@@Z ; CWorld::GetUnderHeight
$L283064:
  0015d	d9 5c 24 10	 fstp	 DWORD PTR _sPos$[esp+76]
$L274633:

; 1293 : 		}
; 1294 : 	}
; 1295 : 
; 1296 : 	if( dwSfxID != NULL_ID )		

  00161	83 fb ff	 cmp	 ebx, -1
  00164	74 1d		 je	 SHORT $L274645

; 1297 : 		g_UserMng.AddCreateSfxObj( this, dwSfxID, sPos.x, sPos.y, sPos.z );	//  .

  00166	8b 4c 24 14	 mov	 ecx, DWORD PTR _sPos$[esp+80]
  0016a	8b 54 24 10	 mov	 edx, DWORD PTR _sPos$[esp+76]
  0016e	8b 44 24 0c	 mov	 eax, DWORD PTR _sPos$[esp+72]
  00172	6a 00		 push	 0
  00174	51		 push	 ecx
  00175	52		 push	 edx
  00176	50		 push	 eax
  00177	53		 push	 ebx
  00178	56		 push	 esi
  00179	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0017e	e8 00 00 00 00	 call	 ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj
$L274645:

; 1298 : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 1299 : 	if( IsPlayer() )

  00183	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00189	85 c0		 test	 eax, eax
  0018b	5b		 pop	 ebx
  0018c	74 0e		 je	 SHORT $L274646

; 1300 : 		((CUser*)this)->SetHonorAdd(pItemProp->dwID,HI_USE_ITEM);

  0018e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00190	6a 00		 push	 0
  00192	6a 05		 push	 5
  00194	51		 push	 ecx
  00195	8b ce		 mov	 ecx, esi
  00197	e8 00 00 00 00	 call	 ?SetHonorAdd@CMover@@QAEXHHH@Z ; CMover::SetHonorAdd
$L274646:
  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi

; 1301 : #ifndef __MAINSERVER
; 1302 : 	else
; 1303 : 		FILEOUT( "..\\HonorError.txt", "OnAfterUseItem()\n" );
; 1304 : #endif	// __MAINSERVER
; 1305 : #endif	// __HONORABLE_TITLE			// 
; 1306 : 
; 1307 : #endif // __WORLDSERVER
; 1308 : }

  0019e	83 c4 3c	 add	 esp, 60			; 0000003cH
  001a1	c2 04 00	 ret	 4
$L283065:
  001a4	00 00 00 00	 DD	 $L274641
  001a8	00 00 00 00	 DD	 $L274636
  001ac	00 00 00 00	 DD	 $L274641
  001b0	00 00 00 00	 DD	 $L274641
?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z ENDP	; CMover::OnAfterUseItem
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	?DoUseItemBlinkWing@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemBlinkWing
PUBLIC	??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@		; `string'
EXTRN	?AddDefinedText@CUser@@QAAXHPBDZZ:NEAR		; CUser::AddDefinedText
EXTRN	?AddDefinedText@CUser@@QAEXH@Z:NEAR		; CUser::AddDefinedText
EXTRN	?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z:NEAR ; CMover::Replace
EXTRN	?SetAngle@CObj@@QAEXM@Z:NEAR			; CObj::SetAngle
EXTRN	?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A:BYTE ; g_GuildCombat1to1Mng
EXTRN	?IsUsableItem@@YAHPAVCItemBase@@@Z:NEAR		; IsUsableItem
EXTRN	?GetInstance@CSecretRoomMng@@SAPAV1@XZ:NEAR	; CSecretRoomMng::GetInstance
EXTRN	?IsInTheSecretRoom@CSecretRoomMng@@QAEHPAVCMover@@@Z:NEAR ; CSecretRoomMng::IsInTheSecretRoom
EXTRN	?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z:NEAR	; CWorldMng::GetWorld
EXTRN	?GetRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z:NEAR ; CWorldMng::GetRevivalPosChao
EXTRN	?GetNearRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z:NEAR ; CWorldMng::GetNearRevivalPosChao
EXTRN	?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z:NEAR ; CWorldMng::GetRevivalPos
EXTRN	?GetNearRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z:NEAR ; CWorldMng::GetNearRevivalPos
EXTRN	?UpdateItem@CMover@@QAEXEDKK@Z:NEAR		; CMover::UpdateItem
EXTRN	?GetInstance@CRainbowRaceMng@@SAPAV1@XZ:NEAR	; CRainbowRaceMng::GetInstance
EXTRN	?IsEntry@CRainbowRaceMng@@QAEHK@Z:NEAR		; CRainbowRaceMng::IsEntry
EXTRN	?UseItem@CItemElem@@QAEXXZ:NEAR			; CItemElem::UseItem
EXTRN	?g_uIdofMulti@@3KA:DWORD			; g_uIdofMulti
EXTRN	?IsPossibleUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z:NEAR ; CGuildCombat1to1Mng::IsPossibleUser
EXTRN	?g_WorldMng@@3VCWorldMng@@A:BYTE		; g_WorldMng
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\world.h
CONST	SEGMENT
??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@ DB '"%s"', 00H	; `string'
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseItemBlinkWing@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT
_vPos$274957 = -24					; size = 12
$T283071 = -24						; size = 12
$T283070 = -24						; size = 12
$T283069 = -24						; size = 12
$T283072 = -12						; size = 12
_pItemProp$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
tv494 = 16						; size = 4
tv492 = 16						; size = 4
tv490 = 16						; size = 4
tv488 = 16						; size = 4
_bUse$ = 16						; size = 4
?DoUseItemBlinkWing@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z PROC NEAR ; CMover::DoUseItemBlinkWing, COMDAT
; _this$ = ecx

; 1872 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1873 : #ifdef __WORLDSERVER
; 1874 : 	if( m_pActMover->IsSit() ) // 2005.12.08 raiders    

  00006	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  0000c	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  0000f	b0 04		 mov	 al, 4
  00011	84 d0		 test	 dl, al

; 1875 : 		return FALSE;

  00013	75 08		 jne	 SHORT $L283172

; 1876 : 
; 1877 : 	if( IsStateMode( STATE_BASEMOTION_MODE ) ) 

  00015	84 86 4c 02 00
	00		 test	 BYTE PTR [esi+588], al
  0001b	74 09		 je	 SHORT $L274911
$L283172:

; 1878 : 		return FALSE;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 2015 : }

  00020	83 c4 18	 add	 esp, 24			; 00000018H
  00023	c2 0c 00	 ret	 12			; 0000000cH
$L274911:
  00026	53		 push	 ebx

; 1879 : 
; 1880 : 	if( bUse )

  00027	8b 5c 24 2c	 mov	 ebx, DWORD PTR _bUse$[esp+28]
  0002b	85 db		 test	 ebx, ebx
  0002d	74 0b		 je	 SHORT $L274913

; 1881 : 	{
; 1882 : 		if( GetWorld()->m_dwWorldID == WI_WORLD_KEBARAS )

  0002f	8b 96 6c 01 00
	00		 mov	 edx, DWORD PTR [esi+364]
  00035	83 3a 02	 cmp	 DWORD PTR [edx], 2

; 1883 : 			return FALSE;

  00038	74 33		 je	 SHORT $L274917
$L274913:

; 1884 : 	}
; 1885 : 
; 1886 : 	if( GetWorld()->m_dwWorldID == WI_WORLD_GUILDWAR )

  0003a	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  00040	81 38 ca 00 00
	00		 cmp	 DWORD PTR [eax], 202	; 000000caH

; 1887 : 		return FALSE;

  00046	74 25		 je	 SHORT $L274917

; 1888 : 
; 1889 : #if __VER >= 11 // __GUILD_COMBAT_1TO1
; 1890 : 	if( g_GuildCombat1to1Mng.IsPossibleUser( (CUser*)this ) )

  00048	56		 push	 esi
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  0004e	e8 00 00 00 00	 call	 ?IsPossibleUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::IsPossibleUser
  00053	85 c0		 test	 eax, eax
  00055	74 20		 je	 SHORT $L274916

; 1891 : 	{
; 1892 : 		if( IsPlayer() )

  00057	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0005d	85 c0		 test	 eax, eax
  0005f	74 0c		 je	 SHORT $L274917

; 1893 : 			((CUser*)this)->AddDefinedText( TID_GAME_GUILDCOMBAT1TO1_NOBLINKWING );

  00061	68 82 0d 00 00	 push	 3458			; 00000d82H
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L274917:
  0006d	5b		 pop	 ebx

; 1894 : 		return FALSE;

  0006e	33 c0		 xor	 eax, eax
  00070	5e		 pop	 esi

; 2015 : }

  00071	83 c4 18	 add	 esp, 24			; 00000018H
  00074	c2 0c 00	 ret	 12			; 0000000cH
$L274916:

; 1895 : 	}
; 1896 : #endif // __GUILD_COMBAT_1TO1
; 1897 : 
; 1898 : #if __VER >= 12 // __SECRET_ROOM
; 1899 : 	if( CSecretRoomMng::GetInstance()->IsInTheSecretRoom( this ) )

  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 ?GetInstance@CSecretRoomMng@@SAPAV1@XZ ; CSecretRoomMng::GetInstance
  0007d	8b c8		 mov	 ecx, eax
  0007f	e8 00 00 00 00	 call	 ?IsInTheSecretRoom@CSecretRoomMng@@QAEHPAVCMover@@@Z ; CSecretRoomMng::IsInTheSecretRoom
  00084	85 c0		 test	 eax, eax
  00086	74 20		 je	 SHORT $L274919

; 1900 : 	{
; 1901 : 		if( IsPlayer() )

  00088	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0008e	85 c0		 test	 eax, eax
  00090	74 0c		 je	 SHORT $L274920

; 1902 : 			((CUser*)this)->AddDefinedText( TID_GAME_SECRETROOM_USEBRINKITEM );

  00092	68 5a 0f 00 00	 push	 3930			; 00000f5aH
  00097	8b ce		 mov	 ecx, esi
  00099	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L274920:
  0009e	5b		 pop	 ebx

; 1903 : 		return FALSE;

  0009f	33 c0		 xor	 eax, eax
  000a1	5e		 pop	 esi

; 2015 : }

  000a2	83 c4 18	 add	 esp, 24			; 00000018H
  000a5	c2 0c 00	 ret	 12			; 0000000cH
$L274919:

; 1904 : 	}
; 1905 : #endif // __SECRET_ROOM
; 1906 : 
; 1907 : #if __VER >= 13 // __RAINBOW_RACE
; 1908 : 	if( CRainbowRaceMng::GetInstance()->IsEntry( ((CUser*)this)->m_idPlayer ) )

  000a8	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  000b4	8b c8		 mov	 ecx, eax
  000b6	e8 00 00 00 00	 call	 ?IsEntry@CRainbowRaceMng@@QAEHK@Z ; CRainbowRaceMng::IsEntry
  000bb	85 c0		 test	 eax, eax
  000bd	74 20		 je	 SHORT $L274923

; 1909 : 	{
; 1910 : 		if( IsPlayer() )

  000bf	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  000c5	85 c0		 test	 eax, eax
  000c7	74 0c		 je	 SHORT $L274924

; 1911 : 			((CUser*)this)->AddDefinedText( TID_GAME_RAINBOWRACE_NOTELEPORT );

  000c9	68 c1 0f 00 00	 push	 4033			; 00000fc1H
  000ce	8b ce		 mov	 ecx, esi
  000d0	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L274924:
  000d5	5b		 pop	 ebx

; 1912 : 		return FALSE;

  000d6	33 c0		 xor	 eax, eax
  000d8	5e		 pop	 esi

; 2015 : }

  000d9	83 c4 18	 add	 esp, 24			; 00000018H
  000dc	c2 0c 00	 ret	 12			; 0000000cH
$L274923:

; 1913 : 	}
; 1914 : #endif // __RAINBOW_RACE
; 1915 : 
; 1916 : #if __VER >= 13 // __HOUSING
; 1917 : 	if( GetWorld()->GetID() == WI_WORLD_MINIROOM )	//   .

  000df	8b 96 6c 01 00
	00		 mov	 edx, DWORD PTR [esi+364]
  000e5	81 3a d1 00 00
	00		 cmp	 DWORD PTR [edx], 209	; 000000d1H

; 1918 : 		return FALSE;

  000eb	74 80		 je	 SHORT $L274917
  000ed	57		 push	 edi

; 1919 : #endif // __HOUSING
; 1920 : 
; 1921 : 	//  .
; 1922 :  	if( pItemProp->dwLimitLevel1 != NULL_ID && (int)( pItemProp->dwLimitLevel1 ) > GetLevel() )

  000ee	8b 7c 24 28	 mov	 edi, DWORD PTR _pItemProp$[esp+32]
  000f2	8b 87 60 02 00
	00		 mov	 eax, DWORD PTR [edi+608]
  000f8	83 f8 ff	 cmp	 eax, -1
  000fb	74 33		 je	 SHORT $L274928
  000fd	3b 86 e0 05 00
	00		 cmp	 eax, DWORD PTR [esi+1504]
  00103	7e 2b		 jle	 SHORT $L274928

; 1923 : 	{
; 1924 : 		if( TRUE == IsPlayer() )

  00105	83 be 34 02 00
	00 01		 cmp	 DWORD PTR [esi+564], 1
  0010c	75 17		 jne	 SHORT $L274929

; 1925 : 			( (CUser*)this )->AddDefinedText( TID_GAME_USINGNOTLEVEL, "\"%s\"", pItemProp->szName );

  0010e	83 c7 04	 add	 edi, 4
  00111	57		 push	 edi
  00112	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00117	68 7f 04 00 00	 push	 1151			; 0000047fH
  0011c	56		 push	 esi
  0011d	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00122	83 c4 10	 add	 esp, 16			; 00000010H
$L274929:
  00125	5f		 pop	 edi
  00126	5b		 pop	 ebx

; 1926 : 		return FALSE;

  00127	33 c0		 xor	 eax, eax
  00129	5e		 pop	 esi

; 2015 : }

  0012a	83 c4 18	 add	 esp, 24			; 00000018H
  0012d	c2 0c 00	 ret	 12			; 0000000cH
$L274928:

; 1927 : 	}
; 1928 : 
; 1929 : 	if( pItemProp->dwItemKind3 == IK3_TOWNBLINKWING )	// IK3_TOWNBLINKWING

  00130	83 7f 78 2f	 cmp	 DWORD PTR [edi+120], 47	; 0000002fH
  00134	55		 push	 ebp
  00135	0f 85 38 01 00
	00		 jne	 $L274931

; 1930 : 	{
; 1931 : 		REPLACE_TYPE type = REPLACE_NORMAL;
; 1932 : 		if( pItemProp->dwID == II_CHR_SYS_SCR_ESCAPEBLINKWING )

  0013b	8b 07		 mov	 eax, DWORD PTR [edi]
  0013d	33 ed		 xor	 ebp, ebp
  0013f	3d c3 28 00 00	 cmp	 eax, 10435		; 000028c3H
  00144	75 05		 jne	 SHORT $L274933

; 1933 : 			type = REPLACE_FORCE; 

  00146	bd 01 00 00 00	 mov	 ebp, 1
$L274933:

; 1934 : 
; 1935 : 		// lodestar
; 1936 : 		if( bUse )

  0014b	85 db		 test	 ebx, ebx
  0014d	74 35		 je	 SHORT $L274934

; 1937 : 		{
; 1938 : 			if( IsUsableItem( pItemElem ) == FALSE )

  0014f	8b 7c 24 30	 mov	 edi, DWORD PTR _pItemElem$[esp+36]
  00153	57		 push	 edi
  00154	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  00159	83 c4 04	 add	 esp, 4
  0015c	85 c0		 test	 eax, eax

; 1939 : 				return FALSE;

  0015e	0f 84 61 02 00
	00		 je	 $L274953

; 1940 : 
; 1941 : 			pItemElem->UseItem();

  00164	8b cf		 mov	 ecx, edi
  00166	e8 00 00 00 00	 call	 ?UseItem@CItemElem@@QAEXXZ ; CItemElem::UseItem

; 1942 : 			UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_NUM, pItemElem->m_nItemNum );

  0016b	0f bf 87 80 00
	00 00		 movsx	 eax, WORD PTR [edi+128]
  00172	33 c9		 xor	 ecx, ecx
  00174	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]
  00177	6a 00		 push	 0
  00179	50		 push	 eax
  0017a	6a 00		 push	 0
  0017c	51		 push	 ecx
  0017d	8b ce		 mov	 ecx, esi
  0017f	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L274934:

; 1943 : 		}
; 1944 : 		
; 1945 : 		PRegionElem pRgnElem	= NULL;
; 1946 : 		CWorld* pWorld	= GetWorld();

  00184	8b be 6c 01 00
	00		 mov	 edi, DWORD PTR [esi+364]

; 1947 : 		if( !pWorld )

  0018a	85 ff		 test	 edi, edi

; 1948 : 			return FALSE;

  0018c	0f 84 33 02 00
	00		 je	 $L274953

; 1949 : 
; 1950 : 		if( IsChaotic() )

  00192	8b 86 60 07 00
	00		 mov	 eax, DWORD PTR [esi+1888]

; 1951 : 		{
; 1952 : #if __VER >= 8 // __S8_PK
; 1953 : 			if( pWorld->GetID() != pWorld->m_dwIdWorldRevival && pWorld->m_dwIdWorldRevival != 0 )

  00198	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0019a	85 c0		 test	 eax, eax
  0019c	8b 87 18 93 08
	00		 mov	 eax, DWORD PTR [edi+561944]
  001a2	76 3a		 jbe	 SHORT $L274940
  001a4	3b c8		 cmp	 ecx, eax
  001a6	74 1a		 je	 SHORT $L283156
  001a8	85 c0		 test	 eax, eax
  001aa	74 16		 je	 SHORT $L283156

; 1954 : 				pRgnElem	= g_WorldMng.GetRevivalPosChao( pWorld->m_dwIdWorldRevival, pWorld->m_szKeyRevival );

  001ac	8d 97 f8 92 08
	00		 lea	 edx, DWORD PTR [edi+561912]
  001b2	52		 push	 edx
  001b3	50		 push	 eax
  001b4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  001b9	e8 00 00 00 00	 call	 ?GetRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPosChao

; 1955 : 			if( NULL == pRgnElem )	// Find near revival pos

  001be	85 c0		 test	 eax, eax
  001c0	75 58		 jne	 SHORT $L283159
$L283156:

; 1956 : 				pRgnElem	= g_WorldMng.GetNearRevivalPosChao( pWorld->GetID(), GetPos() );

  001c2	8b 1f		 mov	 ebx, DWORD PTR [edi]
  001c4	8d 44 24 10	 lea	 eax, DWORD PTR $T283069[esp+40]
  001c8	50		 push	 eax
  001c9	8b ce		 mov	 ecx, esi
  001cb	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  001d0	50		 push	 eax
  001d1	53		 push	 ebx
  001d2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  001d7	e8 00 00 00 00	 call	 ?GetNearRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z ; CWorldMng::GetNearRevivalPosChao

; 1957 : #else // __VER >= 8 // __S8_PK
; 1958 : 			pRgnElem	= g_WorldMng.GetNearRevivalPosChao( pWorld->GetID(), GetPos() );
; 1959 : #endif // __VER >= 8 // __S8_PK
; 1960 : 		}
; 1961 : 		else

  001dc	eb 38		 jmp	 SHORT $L274946
$L274940:

; 1962 : 
; 1963 : 		{
; 1964 : 			if( pWorld->GetID() != pWorld->m_dwIdWorldRevival && pWorld->m_dwIdWorldRevival != 0 )

  001de	3b c8		 cmp	 ecx, eax
  001e0	74 1a		 je	 SHORT $L283157
  001e2	85 c0		 test	 eax, eax
  001e4	74 16		 je	 SHORT $L283157

; 1965 : 				pRgnElem	= g_WorldMng.GetRevivalPos( pWorld->m_dwIdWorldRevival, pWorld->m_szKeyRevival );

  001e6	8d 8f f8 92 08
	00		 lea	 ecx, DWORD PTR [edi+561912]
  001ec	51		 push	 ecx
  001ed	50		 push	 eax
  001ee	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  001f3	e8 00 00 00 00	 call	 ?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPos

; 1966 : 			if( NULL == pRgnElem )	// Find near revival pos

  001f8	85 c0		 test	 eax, eax
  001fa	75 1e		 jne	 SHORT $L283159
$L283157:

; 1967 : 				pRgnElem	= g_WorldMng.GetNearRevivalPos( pWorld->GetID(), GetPos() );

  001fc	8b 1f		 mov	 ebx, DWORD PTR [edi]
  001fe	8d 54 24 10	 lea	 edx, DWORD PTR $T283070[esp+40]
  00202	52		 push	 edx
  00203	8b ce		 mov	 ecx, esi
  00205	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  0020a	50		 push	 eax
  0020b	53		 push	 ebx
  0020c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00211	e8 00 00 00 00	 call	 ?GetNearRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z ; CWorldMng::GetNearRevivalPos
$L274946:

; 1968 : 		}
; 1969 : 		if( NULL != pRgnElem )

  00216	85 c0		 test	 eax, eax
  00218	74 2a		 je	 SHORT $L274948
$L283159:

; 1970 : 			REPLACE( g_uIdofMulti, pRgnElem->m_dwWorldId, pRgnElem->m_vPos, type, nRevivalLayer );

  0021a	8b 90 c0 02 00
	00		 mov	 edx, DWORD PTR [eax+704]
  00220	6a 00		 push	 0
  00222	55		 push	 ebp
  00223	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00226	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  0022b	51		 push	 ecx
  0022c	52		 push	 edx
  0022d	50		 push	 eax

; 2008 : #endif // __VER >= 8 // __S8_PK
; 2009 : 		{
; 2010 : 			REPLACE( g_uIdofMulti, pItemProp->dwWeaponType, vPos, REPLACE_NORMAL, nTempLayer );

  0022e	8b ce		 mov	 ecx, esi
  00230	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace
  00235	5d		 pop	 ebp
  00236	5f		 pop	 edi
  00237	5b		 pop	 ebx

; 2011 : 		}
; 2012 : 	}
; 2013 : #endif // worldserver
; 2014 : 	return TRUE;

  00238	b8 01 00 00 00	 mov	 eax, 1
  0023d	5e		 pop	 esi

; 2015 : }

  0023e	83 c4 18	 add	 esp, 24			; 00000018H
  00241	c2 0c 00	 ret	 12			; 0000000cH
$L274948:

; 1971 : 		else
; 1972 : 			REPLACE( g_uIdofMulti, pWorld->GetID(), GetPos(), type, nDefaultLayer );

  00244	6a 00		 push	 0
  00246	55		 push	 ebp
  00247	8d 4c 24 18	 lea	 ecx, DWORD PTR $T283071[esp+48]
  0024b	51		 push	 ecx
  0024c	8b ce		 mov	 ecx, esi
  0024e	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  00253	8b 17		 mov	 edx, DWORD PTR [edi]
  00255	50		 push	 eax
  00256	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  0025b	52		 push	 edx
  0025c	50		 push	 eax

; 2008 : #endif // __VER >= 8 // __S8_PK
; 2009 : 		{
; 2010 : 			REPLACE( g_uIdofMulti, pItemProp->dwWeaponType, vPos, REPLACE_NORMAL, nTempLayer );

  0025d	8b ce		 mov	 ecx, esi
  0025f	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace
  00264	5d		 pop	 ebp
  00265	5f		 pop	 edi
  00266	5b		 pop	 ebx

; 2011 : 		}
; 2012 : 	}
; 2013 : #endif // worldserver
; 2014 : 	return TRUE;

  00267	b8 01 00 00 00	 mov	 eax, 1
  0026c	5e		 pop	 esi

; 2015 : }

  0026d	83 c4 18	 add	 esp, 24			; 00000018H
  00270	c2 0c 00	 ret	 12			; 0000000cH
$L274931:

; 1973 : 	}
; 1974 : 	else
; 1975 : 	{
; 1976 : 		//		x: dwItemAtkOrder1
; 1977 : 		//		y: dwItemAtkOrder2
; 1978 : 		//		z: dwItemAtkOrder3
; 1979 : 		//		angle: dwItemAtkOrder4
; 1980 : 		//		dwWeaponType: worldid
; 1981 : 		if( pItemProp->dwWeaponType == WI_WORLD_NONE || pItemProp->dwWeaponType == 0xffffffff )

  00273	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  00279	85 c0		 test	 eax, eax
  0027b	0f 84 44 01 00
	00		 je	 $L274953
  00281	83 f8 ff	 cmp	 eax, -1
  00284	0f 84 3b 01 00
	00		 je	 $L274953

; 1983 : 		D3DXVECTOR3 vPos( (float)( pItemProp->dwItemAtkOrder1 ), (float)( pItemProp->dwItemAtkOrder2 ), (float)( pItemProp->dwItemAtkOrder3 ) );

  0028a	8b 8f 10 01 00
	00		 mov	 ecx, DWORD PTR [edi+272]
  00290	db 87 10 01 00
	00		 fild	 DWORD PTR [edi+272]
  00296	85 c9		 test	 ecx, ecx
  00298	7d 06		 jge	 SHORT $L283163
  0029a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L283163:
  002a0	8b 97 14 01 00
	00		 mov	 edx, DWORD PTR [edi+276]
  002a6	d9 5c 24 10	 fstp	 DWORD PTR _vPos$274957[esp+40]
  002aa	85 d2		 test	 edx, edx
  002ac	db 87 14 01 00
	00		 fild	 DWORD PTR [edi+276]
  002b2	7d 06		 jge	 SHORT $L283166
  002b4	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L283166:
  002ba	8b 87 18 01 00
	00		 mov	 eax, DWORD PTR [edi+280]
  002c0	d9 5c 24 14	 fstp	 DWORD PTR _vPos$274957[esp+44]
  002c4	85 c0		 test	 eax, eax
  002c6	db 87 18 01 00
	00		 fild	 DWORD PTR [edi+280]
  002cc	7d 06		 jge	 SHORT $L283167
  002ce	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L283167:

; 1984 : 		SetAngle( (float)pItemProp->dwItemAtkOrder4 );

  002d4	8b 8f 1c 01 00
	00		 mov	 ecx, DWORD PTR [edi+284]
  002da	d9 5c 24 18	 fstp	 DWORD PTR _vPos$274957[esp+48]
  002de	85 c9		 test	 ecx, ecx
  002e0	db 87 1c 01 00
	00		 fild	 DWORD PTR [edi+284]
  002e6	7d 06		 jge	 SHORT $L283168
  002e8	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L283168:
  002ee	51		 push	 ecx
  002ef	8b ce		 mov	 ecx, esi
  002f1	d9 1c 24	 fstp	 DWORD PTR [esp]
  002f4	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle

; 1985 : 		// remove & transfer
; 1986 : 		if( bUse )

  002f9	85 db		 test	 ebx, ebx
  002fb	74 35		 je	 SHORT $L274959

; 1987 : 		{
; 1988 : 			if( IsUsableItem( pItemElem ) == FALSE )

  002fd	8b 5c 24 30	 mov	 ebx, DWORD PTR _pItemElem$[esp+36]
  00301	53		 push	 ebx
  00302	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  00307	83 c4 04	 add	 esp, 4
  0030a	85 c0		 test	 eax, eax

; 1989 : 				return FALSE;

  0030c	0f 84 b3 00 00
	00		 je	 $L274953

; 1990 : 
; 1991 : 			pItemElem->UseItem();

  00312	8b cb		 mov	 ecx, ebx
  00314	e8 00 00 00 00	 call	 ?UseItem@CItemElem@@QAEXXZ ; CItemElem::UseItem

; 1992 : 			UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_NUM, pItemElem->m_nItemNum );

  00319	0f bf 93 80 00
	00 00		 movsx	 edx, WORD PTR [ebx+128]
  00320	33 c0		 xor	 eax, eax
  00322	8a 43 04	 mov	 al, BYTE PTR [ebx+4]
  00325	6a 00		 push	 0
  00327	52		 push	 edx
  00328	6a 00		 push	 0
  0032a	8b ce		 mov	 ecx, esi
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L274959:

; 1993 : 		}
; 1994 : #if __VER >= 8 // __S8_PK
; 1995 : 		if( IsChaotic() )

  00332	8b 86 60 07 00
	00		 mov	 eax, DWORD PTR [esi+1888]
  00338	85 c0		 test	 eax, eax
  0033a	76 5c		 jbe	 SHORT $L274962

; 1996 : 		{
; 1997 : 			PRegionElem pRgnElem	= NULL;
; 1998 : 			CWorld* pWorld = g_WorldMng.GetWorld( pItemProp->dwWeaponType );

  0033c	8b 8f 0c 01 00
	00		 mov	 ecx, DWORD PTR [edi+268]
  00342	51		 push	 ecx
  00343	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00348	e8 00 00 00 00	 call	 ?GetWorld@CWorldMng@@QAEPAVCWorld@@K@Z ; CWorldMng::GetWorld
  0034d	8b d8		 mov	 ebx, eax

; 1999 : 			if( pWorld )

  0034f	85 db		 test	 ebx, ebx
  00351	74 1c		 je	 SHORT $L283158

; 2000 : 				pRgnElem	= g_WorldMng.GetRevivalPosChao( pItemProp->dwWeaponType, pItemProp->szTextFileName );

  00353	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  00359	8d 97 74 02 00
	00		 lea	 edx, DWORD PTR [edi+628]
  0035f	52		 push	 edx
  00360	50		 push	 eax
  00361	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00366	e8 00 00 00 00	 call	 ?GetRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPosChao

; 2001 : 			if( NULL == pRgnElem )	// Find near revival pos

  0036b	85 c0		 test	 eax, eax
  0036d	75 1e		 jne	 SHORT $L283154
$L283158:

; 2002 : 				pRgnElem	= g_WorldMng.GetNearRevivalPosChao( pWorld->GetID(), GetPos() );

  0036f	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00371	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T283072[esp+40]
  00375	51		 push	 ecx
  00376	8b ce		 mov	 ecx, esi
  00378	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  0037d	50		 push	 eax
  0037e	57		 push	 edi
  0037f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  00384	e8 00 00 00 00	 call	 ?GetNearRevivalPosChao@CWorldMng@@QAEPAUREGIONELEM@@KAAUD3DXVECTOR3@@@Z ; CWorldMng::GetNearRevivalPosChao

; 2003 : 
; 2004 : 			if( pRgnElem )

  00389	85 c0		 test	 eax, eax
  0038b	74 29		 je	 SHORT $L274969
$L283154:

; 2005 : 				REPLACE( g_uIdofMulti, pRgnElem->m_dwWorldId, pRgnElem->m_vPos, REPLACE_NORMAL, nRevivalLayer );

  0038d	8d 50 10	 lea	 edx, DWORD PTR [eax+16]
  00390	8b 80 c0 02 00
	00		 mov	 eax, DWORD PTR [eax+704]

; 2006 : 		}
; 2007 : 		else

  00396	eb 0a		 jmp	 SHORT $L283170
$L274962:

; 2008 : #endif // __VER >= 8 // __S8_PK
; 2009 : 		{
; 2010 : 			REPLACE( g_uIdofMulti, pItemProp->dwWeaponType, vPos, REPLACE_NORMAL, nTempLayer );

  00398	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  0039e	8d 54 24 10	 lea	 edx, DWORD PTR _vPos$274957[esp+40]
$L283170:
  003a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  003a8	6a 00		 push	 0
  003aa	6a 00		 push	 0
  003ac	52		 push	 edx
  003ad	50		 push	 eax
  003ae	51		 push	 ecx
  003af	8b ce		 mov	 ecx, esi
  003b1	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace
$L274969:
  003b6	5d		 pop	 ebp
  003b7	5f		 pop	 edi
  003b8	5b		 pop	 ebx

; 2011 : 		}
; 2012 : 	}
; 2013 : #endif // worldserver
; 2014 : 	return TRUE;

  003b9	b8 01 00 00 00	 mov	 eax, 1
  003be	5e		 pop	 esi

; 2015 : }

  003bf	83 c4 18	 add	 esp, 24			; 00000018H
  003c2	c2 0c 00	 ret	 12			; 0000000cH
$L274953:
  003c5	5d		 pop	 ebp
  003c6	5f		 pop	 edi
  003c7	5b		 pop	 ebx

; 1982 : 			return FALSE;

  003c8	33 c0		 xor	 eax, eax
  003ca	5e		 pop	 esi

; 2015 : }

  003cb	83 c4 18	 add	 esp, 24			; 00000018H
  003ce	c2 0c 00	 ret	 12			; 0000000cH
?DoUseItemBlinkWing@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ENDP ; CMover::DoUseItemBlinkWing
_TEXT	ENDS
PUBLIC	?IsDoUseBuff@CMover@@QAEHPAUItemProp@@@Z	; CMover::IsDoUseBuff
EXTRN	?HasBuff@CMover@@QAEHGG@Z:NEAR			; CMover::HasBuff
EXTRN	?GetQuest@CMover@@QAEPAUtagQuest@@H@Z:NEAR	; CMover::GetQuest
EXTRN	?GetBuff@CBuffMgr@@QAEPAVIBuff@@GG@Z:NEAR	; CBuffMgr::GetBuff
EXTRN	?GetState@CFlyffEvent@@QAEEH@Z:NEAR		; CFlyffEvent::GetState
EXTRN	?g_eLocal@@3VCFlyffEvent@@A:BYTE		; g_eLocal
; Function compile flags: /Ogty
;	COMDAT ?IsDoUseBuff@CMover@@QAEHPAUItemProp@@@Z
_TEXT	SEGMENT
_nResult$ = -4						; size = 4
_nMax$275387 = 8					; size = 4
_pItemProp$ = 8						; size = 4
?IsDoUseBuff@CMover@@QAEHPAUItemProp@@@Z PROC NEAR	; CMover::IsDoUseBuff, COMDAT
; _this$ = ecx

; 3096 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 3097 : 	int nResult = 0;
; 3098 : 	if( pItemProp->dwItemKind3 == IK3_POTION_BUFF_STR
; 3099 : 		|| pItemProp->dwItemKind3 == IK3_POTION_BUFF_DEX
; 3100 : 		|| pItemProp->dwItemKind3 == IK3_POTION_BUFF_INT
; 3101 : 		|| pItemProp->dwItemKind3 == IK3_POTION_BUFF_STA
; 3102 : 		|| pItemProp->dwItemKind3 == IK3_POTION_BUFF_DEFENSE		
; 3103 : #if __VER >= 8 //__CSC_VER8_5
; 3104 : 		|| pItemProp->dwItemKind3 == IK3_ANGEL_BUFF		
; 3105 : #endif // __CSC_VER8_5
; 3106 : #ifdef __BUFF_TOGIFT
; 3107 : 		|| pItemProp->dwItemKind2 == IK2_BUFF_TOGIFT
; 3108 : #endif // __BUFF_TOGIFT
; 3109 : 		)

  00002	8b 5c 24 0c	 mov	 ebx, DWORD PTR _pItemProp$[esp+4]
  00006	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	33 ed		 xor	 ebp, ebp
  0000d	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	89 6c 24 10	 mov	 DWORD PTR _nResult$[esp+20], ebp
  00017	0f 84 42 02 00
	00		 je	 $L275371
  0001d	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00020	0f 84 39 02 00
	00		 je	 $L275371
  00026	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00029	0f 84 30 02 00
	00		 je	 $L275371
  0002f	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  00032	0f 84 27 02 00
	00		 je	 $L275371
  00038	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  0003b	0f 84 1e 02 00
	00		 je	 $L275371
  00041	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00044	0f 84 15 02 00
	00		 je	 $L275371
  0004a	83 7b 74 25	 cmp	 DWORD PTR [ebx+116], 37	; 00000025H
  0004e	0f 84 0b 02 00
	00		 je	 $L275371

; 3133 : 		}
; 3134 : #else //__PKSERVER_USE_ANGEL
; 3135 : 		if( pItemProp->dwItemKind3 == IK3_ANGEL_BUFF )
; 3136 : 		{
; 3137 : 			if( 0 >= GetPKValue() )
; 3138 : 				nResult = 2;
; 3139 : 			if( GetQuest( QUEST_PKMINUS ) == NULL )
; 3140 : 				nResult = 3;
; 3141 : 			if( m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_RED100 ) != NULL 
; 3142 : 				|| m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_BLUE100 ) != NULL 
; 3143 : 				|| m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_GREEN100 ) != NULL 
; 3144 : 				|| m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_WHITE100 ) != NULL 
; 3145 : 				)
; 3146 : 				nResult = 4;
; 3147 : 		}
; 3148 : #endif //__PKSERVER_USE_ANGEL
; 3149 : #endif // __CSC_VER8_5
; 3150 : 	}
; 3151 : #if __VER >= 8
; 3152 : 	else if( pItemProp->dwID == II_SYS_SYS_SCR_DEFENSE20 || pItemProp->dwID == II_SYS_SYS_SCR_DEFENSE50 )

  00054	8b 03		 mov	 eax, DWORD PTR [ebx]
  00056	3d 02 66 00 00	 cmp	 eax, 26114		; 00006602H
  0005b	0f 84 cb 01 00
	00		 je	 $L275382
  00061	3d 03 66 00 00	 cmp	 eax, 26115		; 00006603H
  00066	0f 84 c0 01 00
	00		 je	 $L275382

; 3156 : 	}
; 3157 : #endif // __VER >= 8
; 3158 : #ifdef __JEFF_11_1
; 3159 : 	else if( pItemProp->dwID == II_SYS_SYS_SCR_PET_FEED_POCKET02 )

  0006c	3d a3 67 00 00	 cmp	 eax, 26531		; 000067a3H
  00071	0f 85 a7 00 00
	00		 jne	 $L275386

; 3160 : 	{
; 3161 : 		int nMax	= m_Inventory.GetMax();

  00077	8b 87 9c 0b 00
	00		 mov	 eax, DWORD PTR [edi+2972]

; 3162 : 		CItemElem* pItem;
; 3163 : 		for( int i = 0 ; i < nMax; i++ )

  0007d	3b c5		 cmp	 eax, ebp
  0007f	89 44 24 18	 mov	 DWORD PTR _nMax$275387[esp+16], eax
  00083	7e 4f		 jle	 SHORT $L283197
  00085	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$L275390:

; 3164 : 		{
; 3165 : 			pItem	= m_Inventory.GetAtId( i );

  00090	55		 push	 ebp
  00091	8d 8f 90 0b 00
	00		 lea	 ecx, DWORD PTR [edi+2960]
  00097	e8 00 00 00 00	 call	 ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtId
  0009c	8b f0		 mov	 esi, eax

; 3166 : 			if( IsUsableItem( pItem )
; 3167 : 				&& pItem->m_dwItemId == II_SYS_SYS_SCR_PET_FEED_POCKET
; 3168 : 				&& pItem->m_dwKeepTime > 0
; 3169 : 				&& !pItem->IsFlag( CItemElem::expired )
; 3170 : 				)

  0009e	56		 push	 esi
  0009f	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  000a4	83 c4 04	 add	 esp, 4
  000a7	85 c0		 test	 eax, eax
  000a9	74 20		 je	 SHORT $L275391
  000ab	81 7e 0c 2b 52
	00 00		 cmp	 DWORD PTR [esi+12], 21035 ; 0000522bH
  000b2	75 17		 jne	 SHORT $L275391
  000b4	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  000ba	85 c0		 test	 eax, eax
  000bc	76 0d		 jbe	 SHORT $L275391
  000be	f6 86 82 00 00
	00 01		 test	 BYTE PTR [esi+130], 1
  000c5	0f 84 87 01 00
	00		 je	 $L275384
$L275391:

; 3162 : 		CItemElem* pItem;
; 3163 : 		for( int i = 0 ; i < nMax; i++ )

  000cb	8b 44 24 18	 mov	 eax, DWORD PTR _nMax$275387[esp+16]
  000cf	45		 inc	 ebp
  000d0	3b e8		 cmp	 ebp, eax
  000d2	7c bc		 jl	 SHORT $L275390
$L283197:

; 3171 : 			{
; 3172 : 				nResult		= 1;
; 3173 : 				break;
; 3174 : 			}
; 3175 : 		}
; 3176 : 		if( nResult != 1 )
; 3177 : 		{
; 3178 : 		#ifdef __BUFF_1107
; 3179 : 			IBuff* pBuff	= m_buffs.GetBuff( BUFF_ITEM, (WORD)( pItemProp->dwID ) );

  000d4	33 c0		 xor	 eax, eax
  000d6	66 8b 03	 mov	 ax, WORD PTR [ebx]
  000d9	8d 8f f0 02 00
	00		 lea	 ecx, DWORD PTR [edi+752]
  000df	50		 push	 eax
  000e0	6a 00		 push	 0
  000e2	e8 00 00 00 00	 call	 ?GetBuff@CBuffMgr@@QAEPAVIBuff@@GG@Z ; CBuffMgr::GetBuff
  000e7	8b f0		 mov	 esi, eax

; 3180 : 			if( pBuff )

  000e9	85 f6		 test	 esi, esi
  000eb	0f 84 1c 02 00
	00		 je	 $L283198

; 3181 : 			{
; 3182 : 				DWORD dwCurr	= ::timeGetTime();

  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0

; 3183 : 				if( static_cast<int>( pItemProp->dwSkillTime ) > static_cast<int>( pItemProp->dwSkillTime + ( pBuff->GetTotal() - ( dwCurr - pBuff->GetInst() ) ) ) )

  000f7	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000fa	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  000fd	8b 8b f0 01 00
	00		 mov	 ecx, DWORD PTR [ebx+496]
  00103	03 d5		 add	 edx, ebp
  00105	2b d0		 sub	 edx, eax

; 3263 : 		break;	
; 3264 : #endif // __CSC_VER8_5
; 3265 : 	}
; 3266 : 	return nResult;

  00107	03 d1		 add	 edx, ecx
  00109	3b ca		 cmp	 ecx, edx
  0010b	0f 8e fc 01 00
	00		 jle	 $L283198

; 3184 : 					nResult		= 1;

  00111	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 1

; 3185 : 			}
; 3186 : 		#else	// __BUFF_1107
; 3187 : 			LPSKILLINFLUENCE ptr	= m_SkillState.FindPtr( BUFF_ITEM, pItemProp->dwID );
; 3188 : 			if( ptr )
; 3189 : 			{
; 3190 : 				DWORD dwCurr	= ::timeGetTime();
; 3191 : 				if( static_cast<int>( pItemProp->dwSkillTime ) > static_cast<int>( pItemProp->dwSkillTime + ( ptr->tmCount - ( dwCurr - ptr->tmTime ) ) ) )
; 3192 : 					nResult		= 1;
; 3193 : 			}
; 3194 : 		#endif	// __BUFF_1107
; 3195 : 		}
; 3196 : 	}
; 3197 : #endif	// __JEFF_11_1
; 3198 : 	else if( HasBuff( BUFF_ITEM, (WORD)( pItemProp->dwID ) ) )

  00119	e9 ef 01 00 00	 jmp	 $L283198
$L275386:
  0011e	33 c0		 xor	 eax, eax
  00120	66 8b 03	 mov	 ax, WORD PTR [ebx]
  00123	8b cf		 mov	 ecx, edi
  00125	50		 push	 eax
  00126	55		 push	 ebp
  00127	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0012c	85 c0		 test	 eax, eax
  0012e	74 0d		 je	 SHORT $L275404

; 3199 : 	{
; 3200 : 		nResult = 1;

  00130	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 1

; 3201 : 	}
; 3202 : #if __VER >= 11 // __SYS_COLLECTING
; 3203 : 	else if( pItemProp->dwID == II_GEN_TOO_COL_SILVERBATTERY

  00138	e9 d0 01 00 00	 jmp	 $L283198
$L275404:

; 3204 : 		|| pItemProp->dwID == II_GEN_TOO_COL_GOLDBATTERY
; 3205 : 		|| pItemProp->dwID == II_GEN_TOO_COL_BATTERY001
; 3206 : 		)

  0013d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0013f	3d 56 67 00 00	 cmp	 eax, 26454		; 00006756H
  00144	0f 84 b5 00 00
	00		 je	 $L275407
  0014a	3d 57 67 00 00	 cmp	 eax, 26455		; 00006757H
  0014f	0f 84 aa 00 00
	00		 je	 $L275407
  00155	3d c0 67 00 00	 cmp	 eax, 26560		; 000067c0H
  0015a	0f 84 9f 00 00
	00		 je	 $L275407

; 3219 : 		|| pItemProp->dwID == II_SYS_SYS_SCR_PARTYEXPUP02
; 3220 : 		|| pItemProp->dwID == II_SYS_SYS_SCR_PARTYEXPUP01_01
; 3221 : 		)

  00160	3d a9 67 00 00	 cmp	 eax, 26537		; 000067a9H
  00165	74 6b		 je	 SHORT $L275412
  00167	3d aa 67 00 00	 cmp	 eax, 26538		; 000067aaH
  0016c	74 64		 je	 SHORT $L275412
  0016e	3d 48 4f 00 00	 cmp	 eax, 20296		; 00004f48H
  00173	74 5d		 je	 SHORT $L275412

; 3230 : 		)

  00175	3d cd 67 00 00	 cmp	 eax, 26573		; 000067cdH
  0017a	75 08		 jne	 SHORT $L275416

; 3231 : 	{
; 3232 : 		if( HasBuff( BUFF_ITEM2, II_SYS_SYS_SCR_SPETGOOD )
; 3233 : 			)

  0017c	50		 push	 eax
  0017d	6a 03		 push	 3

; 3234 : 			nResult = 1;
; 3235 : 	}
; 3236 : 	else if( pItemProp->dwID == II_SYS_SYS_SCR_PARTYSKILLUP01

  0017f	e9 bf 00 00 00	 jmp	 $L283201
$L275416:

; 3237 : 		|| pItemProp->dwID == II_SYS_SYS_SCR_PARTYSKILLUP02
; 3238 : 		|| pItemProp->dwID == II_SYS_SYS_SCR_PARTYSKILLUP01_01
; 3239 : 		)

  00184	3d ab 67 00 00	 cmp	 eax, 26539		; 000067abH
  00189	74 12		 je	 SHORT $L275420
  0018b	3d ac 67 00 00	 cmp	 eax, 26540		; 000067acH
  00190	74 0b		 je	 SHORT $L275420
  00192	3d 49 4f 00 00	 cmp	 eax, 20297		; 00004f49H
  00197	0f 85 70 01 00
	00		 jne	 $L283198
$L275420:

; 3240 : 	{
; 3241 : 		if( HasBuff( BUFF_ITEM2, II_SYS_SYS_SCR_PARTYSKILLUP01 )
; 3242 : 			|| HasBuff( BUFF_ITEM2, II_SYS_SYS_SCR_PARTYSKILLUP02 )
; 3243 : 			|| HasBuff( BUFF_ITEM2, II_SYS_SYS_SCR_PARTYSKILLUP01_01 )
; 3244 : 			)

  0019d	68 ab 67 00 00	 push	 26539			; 000067abH
  001a2	6a 03		 push	 3
  001a4	8b cf		 mov	 ecx, edi
  001a6	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001ab	85 c0		 test	 eax, eax
  001ad	0f 85 9f 00 00
	00		 jne	 $L275384
  001b3	68 ac 67 00 00	 push	 26540			; 000067acH
  001b8	6a 03		 push	 3
  001ba	8b cf		 mov	 ecx, edi
  001bc	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001c1	85 c0		 test	 eax, eax
  001c3	0f 85 89 00 00
	00		 jne	 $L275384
  001c9	68 49 4f 00 00	 push	 20297			; 00004f49H
  001ce	6a 03		 push	 3

; 3245 : 			nResult = 1;

  001d0	eb 71		 jmp	 SHORT $L283201
$L275412:

; 3222 : 	{
; 3223 : 		if( HasBuff( BUFF_ITEM2, II_SYS_SYS_SCR_PARTYEXPUP01 )
; 3224 : 			|| HasBuff( BUFF_ITEM2, II_SYS_SYS_SCR_PARTYEXPUP02 )
; 3225 : 			|| HasBuff( BUFF_ITEM2, II_SYS_SYS_SCR_PARTYEXPUP01_01 )
; 3226 : 			)

  001d2	68 a9 67 00 00	 push	 26537			; 000067a9H
  001d7	6a 03		 push	 3
  001d9	8b cf		 mov	 ecx, edi
  001db	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001e0	85 c0		 test	 eax, eax
  001e2	75 6e		 jne	 SHORT $L275384
  001e4	68 aa 67 00 00	 push	 26538			; 000067aaH
  001e9	6a 03		 push	 3
  001eb	8b cf		 mov	 ecx, edi
  001ed	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001f2	85 c0		 test	 eax, eax
  001f4	75 5c		 jne	 SHORT $L275384
  001f6	68 48 4f 00 00	 push	 20296			; 00004f48H
  001fb	6a 03		 push	 3

; 3227 : 			nResult = 1;
; 3228 : 	}
; 3229 : 	else if( pItemProp->dwID == II_SYS_SYS_SCR_SPETGOOD

  001fd	eb 44		 jmp	 SHORT $L283201
$L275407:

; 3207 : 	{
; 3208 : 		if( HasBuff( BUFF_ITEM2, II_GEN_TOO_COL_SILVERBATTERY )
; 3209 : 			|| HasBuff( BUFF_ITEM2, II_GEN_TOO_COL_GOLDBATTERY )
; 3210 : 			|| HasBuff( BUFF_ITEM2, II_GEN_TOO_COL_BATTERY001 )
; 3211 : 			)

  001ff	68 56 67 00 00	 push	 26454			; 00006756H
  00204	6a 03		 push	 3
  00206	8b cf		 mov	 ecx, edi
  00208	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0020d	85 c0		 test	 eax, eax
  0020f	75 41		 jne	 SHORT $L275384
  00211	68 57 67 00 00	 push	 26455			; 00006757H
  00216	6a 03		 push	 3
  00218	8b cf		 mov	 ecx, edi
  0021a	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0021f	85 c0		 test	 eax, eax
  00221	75 2f		 jne	 SHORT $L275384
  00223	68 c0 67 00 00	 push	 26560			; 000067c0H
  00228	6a 03		 push	 3

; 3212 : 			nResult = 1;
; 3213 : 	}
; 3214 : #endif // __SYS_COLLECTING
; 3215 : #if __VER >= 12 // __JHMA_VER12_1	//12 
; 3216 : 	#define II_SYS_SYS_SCR_PARTYEXPUP01_01 20296
; 3217 : #define II_SYS_SYS_SCR_PARTYSKILLUP01_01 20297
; 3218 : 	else if( pItemProp->dwID == II_SYS_SYS_SCR_PARTYEXPUP01

  0022a	eb 17		 jmp	 SHORT $L283201
$L275382:

; 3153 : 	{
; 3154 : 		if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_DEFENSE20 ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_DEFENSE50 ) )

  0022c	68 02 66 00 00	 push	 26114			; 00006602H
  00231	55		 push	 ebp
  00232	8b cf		 mov	 ecx, edi
  00234	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00239	85 c0		 test	 eax, eax
  0023b	75 15		 jne	 SHORT $L275384
  0023d	68 03 66 00 00	 push	 26115			; 00006603H
  00242	55		 push	 ebp
$L283201:
  00243	8b cf		 mov	 ecx, edi
  00245	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0024a	85 c0		 test	 eax, eax
  0024c	0f 84 bb 00 00
	00		 je	 $L283198
$L275384:

; 3155 : 			nResult = 1;

  00252	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 1

; 3156 : 	}
; 3157 : #endif // __VER >= 8
; 3158 : #ifdef __JEFF_11_1
; 3159 : 	else if( pItemProp->dwID == II_SYS_SYS_SCR_PET_FEED_POCKET02 )

  0025a	e9 ae 00 00 00	 jmp	 $L283198
$L275371:

; 3110 : 	{
; 3111 : 		if( HasBuffByIk3( pItemProp->dwItemKind3 ) )

  0025f	50		 push	 eax
  00260	8b cf		 mov	 ecx, edi
  00262	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  00267	85 c0		 test	 eax, eax
  00269	74 08		 je	 SHORT $L275372

; 3112 : 			nResult = 1;

  0026b	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 1
$L275372:

; 3113 : 
; 3114 : #if __VER >= 8 //__CSC_VER8_5
; 3115 : #ifdef __PKSERVER_USE_ANGEL
; 3116 : 		if( pItemProp->dwItemKind3 == IK3_ANGEL_BUFF )

  00273	83 7b 78 5f	 cmp	 DWORD PTR [ebx+120], 95	; 0000005fH
  00277	0f 85 90 00 00
	00		 jne	 $L283198

; 3117 : 		{
; 3118 : 			if(g_eLocal.GetState( EVE_PK ))	

  0027d	6a 0b		 push	 11			; 0000000bH
  0027f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00284	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00289	84 c0		 test	 al, al
  0028b	74 78		 je	 SHORT $L275374

; 3119 : 			{
; 3120 : 				if( 0 >= GetPKValue() )

  0028d	39 af 5c 07 00
	00		 cmp	 DWORD PTR [edi+1884], ebp
  00293	7f 08		 jg	 SHORT $L275375

; 3121 : 					nResult = 2;

  00295	c7 44 24 10 02
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 2
$L275375:

; 3122 : 				if( GetQuest( QUEST_PKMINUS ) == NULL )

  0029d	68 8c 13 00 00	 push	 5004			; 0000138cH
  002a2	8b cf		 mov	 ecx, edi
  002a4	e8 00 00 00 00	 call	 ?GetQuest@CMover@@QAEPAUtagQuest@@H@Z ; CMover::GetQuest
  002a9	85 c0		 test	 eax, eax
  002ab	75 08		 jne	 SHORT $L275376

; 3123 : 					nResult = 3;

  002ad	c7 44 24 10 03
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 3
$L275376:

; 3124 : 				if( m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_RED100 ) != NULL 
; 3125 : 					|| m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_BLUE100 ) != NULL 
; 3126 : 					|| m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_GREEN100 ) != NULL 
; 3127 : 					|| m_Inventory.GetAtItemId( II_SYS_SYS_QUE_ANGEL_WHITE100 ) != NULL 
; 3128 : 					)

  002b5	8d b7 90 0b 00
	00		 lea	 esi, DWORD PTR [edi+2960]
  002bb	68 57 75 00 00	 push	 30039			; 00007557H
  002c0	8b ce		 mov	 ecx, esi
  002c2	e8 00 00 00 00	 call	 ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId
  002c7	85 c0		 test	 eax, eax
  002c9	75 30		 jne	 SHORT $L275378
  002cb	68 58 75 00 00	 push	 30040			; 00007558H
  002d0	8b ce		 mov	 ecx, esi
  002d2	e8 00 00 00 00	 call	 ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId
  002d7	85 c0		 test	 eax, eax
  002d9	75 20		 jne	 SHORT $L275378
  002db	68 59 75 00 00	 push	 30041			; 00007559H
  002e0	8b ce		 mov	 ecx, esi
  002e2	e8 00 00 00 00	 call	 ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId
  002e7	85 c0		 test	 eax, eax
  002e9	75 10		 jne	 SHORT $L275378
  002eb	68 5a 75 00 00	 push	 30042			; 0000755aH
  002f0	8b ce		 mov	 ecx, esi
  002f2	e8 00 00 00 00	 call	 ?GetAtItemId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtItemId
  002f7	85 c0		 test	 eax, eax
  002f9	74 12		 je	 SHORT $L283198
$L275378:

; 3129 : 					nResult = 4;

  002fb	c7 44 24 10 04
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 4

; 3130 : 			}
; 3131 : 			else

  00303	eb 08		 jmp	 SHORT $L283198
$L275374:

; 3132 : 				nResult = 5;

  00305	c7 44 24 10 05
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 5
$L283198:

; 3246 : 	}
; 3247 : #endif // //12 
; 3248 : 	
; 3249 : 	switch( nResult )

  0030d	8b 74 24 10	 mov	 esi, DWORD PTR _nResult$[esp+20]
  00311	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00314	83 f8 03	 cmp	 eax, 3
  00317	77 5c		 ja	 SHORT $L275424
  00319	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L283203[eax*4]
$L275427:

; 3250 : 	{
; 3251 : 	case 1:
; 3252 : 		((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   

  00320	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00325	68 30 08 00 00	 push	 2096			; 00000830H
  0032a	57		 push	 edi
  0032b	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00330	83 c4 0c	 add	 esp, 12			; 0000000cH
  00333	5f		 pop	 edi

; 3263 : 		break;	
; 3264 : #endif // __CSC_VER8_5
; 3265 : 	}
; 3266 : 	return nResult;

  00334	8b c6		 mov	 eax, esi
  00336	5e		 pop	 esi
  00337	5d		 pop	 ebp
  00338	5b		 pop	 ebx

; 3267 : }

  00339	59		 pop	 ecx
  0033a	c2 04 00	 ret	 4
$L275429:

; 3253 : 		break;
; 3254 : #if __VER >= 8 //__CSC_VER8_5
; 3255 : 	case 2:
; 3256 : 		((CUser*)this)->AddDefinedText( TID_GAME_PKVALUE_NOT_ANGEL );

  0033d	68 43 0c 00 00	 push	 3139			; 00000c43H

; 3260 : 		break;	
; 3261 : 	case 4:
; 3262 : 		((CUser*)this)->AddDefinedText( TID_GAME_NOT_COMPLETE_ANGEL );

  00342	8b cf		 mov	 ecx, edi
  00344	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  00349	5f		 pop	 edi

; 3263 : 		break;	
; 3264 : #endif // __CSC_VER8_5
; 3265 : 	}
; 3266 : 	return nResult;

  0034a	8b c6		 mov	 eax, esi
  0034c	5e		 pop	 esi
  0034d	5d		 pop	 ebp
  0034e	5b		 pop	 ebx

; 3267 : }

  0034f	59		 pop	 ecx
  00350	c2 04 00	 ret	 4
$L275431:

; 3257 : 		break;
; 3258 : 	case 3:
; 3259 : 		((CUser*)this)->AddDefinedText( TID_GAME_NOT_QUEST_ANGEL );

  00353	68 4b 0c 00 00	 push	 3147			; 00000c4bH

; 3260 : 		break;	
; 3261 : 	case 4:
; 3262 : 		((CUser*)this)->AddDefinedText( TID_GAME_NOT_COMPLETE_ANGEL );

  00358	8b cf		 mov	 ecx, edi
  0035a	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  0035f	5f		 pop	 edi

; 3263 : 		break;	
; 3264 : #endif // __CSC_VER8_5
; 3265 : 	}
; 3266 : 	return nResult;

  00360	8b c6		 mov	 eax, esi
  00362	5e		 pop	 esi
  00363	5d		 pop	 ebp
  00364	5b		 pop	 ebx

; 3267 : }

  00365	59		 pop	 ecx
  00366	c2 04 00	 ret	 4
$L275433:

; 3260 : 		break;	
; 3261 : 	case 4:
; 3262 : 		((CUser*)this)->AddDefinedText( TID_GAME_NOT_COMPLETE_ANGEL );

  00369	68 4c 0c 00 00	 push	 3148			; 00000c4cH
  0036e	8b cf		 mov	 ecx, edi
  00370	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L275424:
  00375	5f		 pop	 edi

; 3263 : 		break;	
; 3264 : #endif // __CSC_VER8_5
; 3265 : 	}
; 3266 : 	return nResult;

  00376	8b c6		 mov	 eax, esi
  00378	5e		 pop	 esi
  00379	5d		 pop	 ebp
  0037a	5b		 pop	 ebx

; 3267 : }

  0037b	59		 pop	 ecx
  0037c	c2 04 00	 ret	 4
  0037f	90		 npad	 1
$L283203:
  00380	00 00 00 00	 DD	 $L275427
  00384	00 00 00 00	 DD	 $L275429
  00388	00 00 00 00	 DD	 $L275431
  0038c	00 00 00 00	 DD	 $L275433
?IsDoUseBuff@CMover@@QAEHPAUItemProp@@@Z ENDP		; CMover::IsDoUseBuff
_TEXT	ENDS
PUBLIC	?DoUseItemFood_SM@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CMover::DoUseItemFood_SM
EXTRN	?SetSMMode@CMover@@QAEHHK@Z:NEAR		; CMover::SetSMMode
EXTRN	?SetDestParam@CMover@@QAEXHHHH@Z:NEAR		; CMover::SetDestParam
EXTRN	?GetMaxOriginHitPoint@CMover@@QAEHH@Z:NEAR	; CMover::GetMaxOriginHitPoint
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemFood_SM@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemProp$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
?DoUseItemFood_SM@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z PROC NEAR ; CMover::DoUseItemFood_SM, COMDAT
; _this$ = ecx

; 3272 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3273 : #ifdef __WORLDSERVER
; 3274 : 	if( !( IsSMMode( SM_MAX_HP ) || IsSMMode( SM_MAX_HP50 ) ) )		// MAXHP   .

  00003	8b 86 24 03 00
	00		 mov	 eax, DWORD PTR [esi+804]
  00009	85 c0		 test	 eax, eax
  0000b	0f 87 90 00 00
	00		 ja	 $L275440
  00011	8b 86 28 03 00
	00		 mov	 eax, DWORD PTR [esi+808]
  00017	85 c0		 test	 eax, eax
  00019	0f 87 82 00 00
	00		 ja	 $L275440
  0001f	53		 push	 ebx
  00020	57		 push	 edi

; 3275 : 	{
; 3276 : 		DWORD nAdjParamVal;
; 3277 : 		int nType;
; 3278 : 		if( pItemProp->dwID == II_CHR_FOO_COO_BULLHAMS )

  00021	8b 7c 24 10	 mov	 edi, DWORD PTR _pItemProp$[esp+8]
  00025	8b 07		 mov	 eax, DWORD PTR [edi]
  00027	3d e1 27 00 00	 cmp	 eax, 10209		; 000027e1H
  0002c	75 0d		 jne	 SHORT $L275443

; 3279 : 		{
; 3280 : 			nAdjParamVal = pItemProp->nAdjParamVal2;

  0002e	8b 87 5c 01 00
	00		 mov	 eax, DWORD PTR [edi+348]

; 3281 : 			nType = SM_MAX_HP;

  00034	bb 08 00 00 00	 mov	 ebx, 8

; 3282 : 		}
; 3283 : 		else

  00039	eb 32		 jmp	 SHORT $L275446
$L275443:

; 3284 : 		if( pItemProp->dwID == II_CHR_FOO_COO_GRILLEDEEL )

  0003b	3d e2 27 00 00	 cmp	 eax, 10210		; 000027e2H
  00040	75 57		 jne	 SHORT $L275445

; 3285 : 		{
; 3286 : 			m_nPlusMaxHitPoint = nAdjParamVal = int( GetMaxOriginHitPoint() / ( 100 / pItemProp->nAdjParamVal1 ) );

  00042	6a 01		 push	 1
  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  0004b	8b c8		 mov	 ecx, eax
  0004d	33 d2		 xor	 edx, edx
  0004f	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00054	f7 b7 58 01 00
	00		 div	 DWORD PTR [edi+344]
  0005a	33 d2		 xor	 edx, edx
  0005c	8b d8		 mov	 ebx, eax
  0005e	8b c1		 mov	 eax, ecx
  00060	f7 f3		 div	 ebx

; 3287 : 			nType = SM_MAX_HP50;

  00062	bb 09 00 00 00	 mov	 ebx, 9
  00067	89 86 b8 06 00
	00		 mov	 DWORD PTR [esi+1720], eax
$L275446:

; 3291 : 			
; 3292 : 		SetDestParam( pItemProp->dwDestParam1, nAdjParamVal, nAdjParamVal );

  0006d	8b 97 40 01 00
	00		 mov	 edx, DWORD PTR [edi+320]
  00073	6a 01		 push	 1
  00075	50		 push	 eax
  00076	50		 push	 eax
  00077	52		 push	 edx
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 3293 : 		SetSMMode( nType, pItemProp->dwCircleTime );

  0007f	8b 87 ec 01 00
	00		 mov	 eax, DWORD PTR [edi+492]
  00085	50		 push	 eax
  00086	53		 push	 ebx
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode
  0008e	5f		 pop	 edi
  0008f	5b		 pop	 ebx

; 3299 : 	}
; 3300 : #endif
; 3301 : 	return TRUE;

  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	5e		 pop	 esi

; 3302 : }

  00096	c2 08 00	 ret	 8
$L275445:
  00099	5f		 pop	 edi
  0009a	5b		 pop	 ebx

; 3288 : 		}
; 3289 : 		else
; 3290 : 			return FALSE;

  0009b	33 c0		 xor	 eax, eax
  0009d	5e		 pop	 esi

; 3302 : }

  0009e	c2 08 00	 ret	 8
$L275440:

; 3294 : 	}
; 3295 : 	else
; 3296 : 	{
; 3297 : 		((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" );	//   

  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000a6	68 30 08 00 00	 push	 2096			; 00000830H
  000ab	56		 push	 esi
  000ac	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3298 : 		return FALSE;

  000b4	33 c0		 xor	 eax, eax
  000b6	5e		 pop	 esi

; 3302 : }

  000b7	c2 08 00	 ret	 8
?DoUseItemFood_SM@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ENDP ; CMover::DoUseItemFood_SM
_TEXT	ENDS
PUBLIC	__real@3e99999a
PUBLIC	?DoUseItemFood@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CMover::DoUseItemFood
EXTRN	?GetMaxPoint@CMover@@QAEHH@Z:NEAR		; CMover::GetMaxPoint
EXTRN	?GetPointParam@CMover@@QAEHH@Z:NEAR		; CMover::GetPointParam
EXTRN	?SetPointParam@CMover@@QAEXHHH@Z:NEAR		; CMover::SetPointParam
EXTRN	?GetMaxHitPoint@CMover@@QAEHXZ:NEAR		; CMover::GetMaxHitPoint
EXTRN	?GetMaxManaPoint@CMover@@QAEHXZ:NEAR		; CMover::GetMaxManaPoint
EXTRN	?GetMaxFatiguePoint@CMover@@QAEHXZ:NEAR		; CMover::GetMaxFatiguePoint
EXTRN	__ftol2:NEAR
;	COMDAT __real@3e99999a
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseItemFood@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT
tv252 = -20						; size = 4
_nMax$ = -20						; size = 4
_i$275459 = -16						; size = 4
_nPoint$ = -12						; size = 4
_nHP$ = -8						; size = 4
_nHPMax$ = -4						; size = 4
_pItemProp$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
?DoUseItemFood@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z PROC NEAR ; CMover::DoUseItemFood, COMDAT
; _this$ = ecx

; 3306 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	55		 push	 ebp

; 3307 : #ifdef __WORLDSERVER
; 3308 : 	if( pItemProp->dwID == II_GEN_FOO_INS_SUPERHOTDOG )

  00004	8b 6c 24 1c	 mov	 ebp, DWORD PTR _pItemProp$[esp+20]
  00008	81 7d 00 0a 0b
	00 00		 cmp	 DWORD PTR [ebp], 2826	; 00000b0aH
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	75 44		 jne	 SHORT $L275454

; 3309 : 	{
; 3310 : 		SetPointParam( DST_HP, GetMaxHitPoint() );

  00014	6a 00		 push	 0
  00016	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  0001b	50		 push	 eax
  0001c	6a 26		 push	 38			; 00000026H
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam

; 3311 : 		SetPointParam( DST_MP, GetMaxManaPoint() );

  00025	6a 00		 push	 0
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  0002e	50		 push	 eax
  0002f	6a 27		 push	 39			; 00000027H
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam

; 3312 : 		SetPointParam( DST_FP, GetMaxFatiguePoint() );

  00038	6a 00		 push	 0
  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  00041	50		 push	 eax
  00042	6a 28		 push	 40			; 00000028H
  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
  0004b	5e		 pop	 esi

; 3313 : 		return TRUE;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	5d		 pop	 ebp

; 3385 : }

  00052	83 c4 14	 add	 esp, 20			; 00000014H
  00055	c2 08 00	 ret	 8
$L275454:
  00058	53		 push	 ebx

; 3314 : 	}
; 3315 : 
; 3316 : 	int nPoint;
; 3317 : 	int nMax, nHP, nHPMax;
; 3318 : #ifdef __PROP_0827
; 3319 : 	for( int i = 0; i < 3; i ++ )

  00059	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _i$275459[esp+32], 0
  00061	81 c5 40 01 00
	00		 add	 ebp, 320		; 00000140H
  00067	57		 push	 edi
  00068	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L275460:

; 3320 : #else	// __PROP_0827
; 3321 : 	for( int i = 0; i < 2; i ++ )
; 3322 : #endif	// __PROP_0827
; 3323 : 	{
; 3324 : 		if( pItemProp->dwDestParam[i] != (DWORD)-1 )

  00070	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00073	83 f8 ff	 cmp	 eax, -1
  00076	0f 84 11 01 00
	00		 je	 $L275461

; 3325 : 		{
; 3326 : 			nHP	   = GetPointParam( pItemProp->dwDestParam[i] );

  0007c	50		 push	 eax
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?GetPointParam@CMover@@QAEHH@Z ; CMover::GetPointParam

; 3327 : 			nPoint = pItemProp->nAdjParamVal[i];

  00084	8b 5d 18	 mov	 ebx, DWORD PTR [ebp+24]
  00087	8b f8		 mov	 edi, eax

; 3328 : 			nHPMax = GetMaxPoint( pItemProp->dwDestParam[i]);

  00089	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0008c	50		 push	 eax
  0008d	8b ce		 mov	 ecx, esi
  0008f	89 7c 24 20	 mov	 DWORD PTR _nHP$[esp+40], edi
  00093	89 5c 24 1c	 mov	 DWORD PTR _nPoint$[esp+40], ebx
  00097	e8 00 00 00 00	 call	 ?GetMaxPoint@CMover@@QAEHH@Z ; CMover::GetMaxPoint
  0009c	8b d0		 mov	 edx, eax

; 3329 : 			nMax   = pItemProp->dwAbilityMin;

  0009e	8b 44 24 28	 mov	 eax, DWORD PTR _pItemProp$[esp+32]
  000a2	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  000a8	89 4c 24 10	 mov	 DWORD PTR _nMax$[esp+36], ecx

; 3330 : 			
; 3331 : 			if( pItemProp->dwCircleTime != -1)	//  dwCircleTime  ....

  000ac	83 b8 ec 01 00
	00 ff		 cmp	 DWORD PTR [eax+492], -1
  000b3	89 54 24 20	 mov	 DWORD PTR _nHPMax$[esp+36], edx
  000b7	74 1f		 je	 SHORT $L275465

; 3332 : 			{
; 3333 : 				BOOL bRet = DoUseItemFood_SM( pItemProp, pItemElem );

  000b9	8b 54 24 2c	 mov	 edx, DWORD PTR _pItemElem$[esp+32]
  000bd	52		 push	 edx
  000be	50		 push	 eax
  000bf	8b ce		 mov	 ecx, esi
  000c1	e8 00 00 00 00	 call	 ?DoUseItemFood_SM@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CMover::DoUseItemFood_SM

; 3334 : 				if( bRet == FALSE )	return FALSE;

  000c6	85 c0		 test	 eax, eax
  000c8	0f 85 bf 00 00
	00		 jne	 $L275461
  000ce	5f		 pop	 edi
  000cf	5b		 pop	 ebx
  000d0	5e		 pop	 esi
  000d1	5d		 pop	 ebp

; 3385 : }

  000d2	83 c4 14	 add	 esp, 20			; 00000014H
  000d5	c2 08 00	 ret	 8
$L275465:

; 3335 : 			}
; 3336 : 			else
; 3337 : 			{
; 3338 : 				if( pItemProp->dwDestParam[i] == DST_HP || pItemProp->dwDestParam[i] == DST_MP || pItemProp->dwDestParam[i] == DST_FP )

  000d8	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  000db	83 f9 26	 cmp	 ecx, 38			; 00000026H
  000de	74 22		 je	 SHORT $L275470
  000e0	83 f9 27	 cmp	 ecx, 39			; 00000027H
  000e3	74 1d		 je	 SHORT $L275470
  000e5	83 f9 28	 cmp	 ecx, 40			; 00000028H
  000e8	74 18		 je	 SHORT $L275470

; 3374 : 				} // DST_HP, MP, FP
; 3375 : 				else
; 3376 : 				{
; 3377 : 					DoApplySkill( this, pItemProp, NULL );

  000ea	6a 00		 push	 0
  000ec	6a 00		 push	 0
  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	6a 00		 push	 0
  000f4	50		 push	 eax
  000f5	56		 push	 esi
  000f6	8b ce		 mov	 ecx, esi
  000f8	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  000fd	e9 8b 00 00 00	 jmp	 $L275461
$L275470:

; 3339 : 				{
; 3340 : 					if( nPoint != -1 )

  00102	83 fb ff	 cmp	 ebx, -1
  00105	74 78		 je	 SHORT $L283229

; 3341 : 					{
; 3342 : 						if( nHP >= nMax )

  00107	3b 7c 24 10	 cmp	 edi, DWORD PTR _nMax$[esp+36]
  0010b	7c 6a		 jl	 SHORT $L275472

; 3343 : 						{
; 3344 : 							if( nHP + (nPoint * 0.3f) >= nHPMax )

  0010d	db 44 24 18	 fild	 DWORD PTR _nPoint$[esp+36]
  00111	d9 54 24 10	 fst	 DWORD PTR tv252[esp+36]
  00115	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e99999a
  0011b	da 44 24 1c	 fiadd	 DWORD PTR _nHP$[esp+36]
  0011f	db 44 24 20	 fild	 DWORD PTR _nHPMax$[esp+36]
  00123	de d9		 fcompp
  00125	df e0		 fnstsw	 ax
  00127	f6 c4 41	 test	 ah, 65			; 00000041H

; 3345 : 								nHP = nHPMax;
; 3346 : 							else

  0012a	7b 51		 jnp	 SHORT $L283232

; 3347 : 							{
; 3348 : 								if( TRUE == IsPlayer() )

  0012c	83 be 34 02 00
	00 01		 cmp	 DWORD PTR [esi+564], 1
  00133	75 2f		 jne	 SHORT $L283228

; 3349 : 								{
; 3350 : 									DWORD dwParam = 0;

  00135	33 c0		 xor	 eax, eax

; 3351 : 									switch( pItemProp->dwDestParam[i] )

  00137	83 e9 26	 sub	 ecx, 38			; 00000026H
  0013a	74 14		 je	 SHORT $L275481
  0013c	49		 dec	 ecx
  0013d	74 0a		 je	 SHORT $L275482
  0013f	49		 dec	 ecx
  00140	75 13		 jne	 SHORT $L275478

; 3355 : 									case DST_FP:	dwParam = TID_GAME_LIMITFP;		break;

  00142	b8 6e 09 00 00	 mov	 eax, 2414		; 0000096eH
  00147	eb 0c		 jmp	 SHORT $L275478
$L275482:

; 3354 : 									case DST_MP:	dwParam = TID_GAME_LIMITMP;		break;

  00149	b8 66 02 00 00	 mov	 eax, 614		; 00000266H
  0014e	eb 05		 jmp	 SHORT $L275478
$L275481:

; 3352 : 									{
; 3353 : 									case DST_HP:	dwParam = TID_GAME_LIMITHP;		break;

  00150	b8 65 02 00 00	 mov	 eax, 613		; 00000265H
$L275478:

; 3356 : 									}
; 3357 : 									
; 3358 : 									((CUser*)this)->AddDefinedText( dwParam, "" );

  00155	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0015a	50		 push	 eax
  0015b	56		 push	 esi
  0015c	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
$L283228:

; 3359 : 								}
; 3360 : 								nPoint = (int)( nPoint * 0.3f );

  00164	d9 44 24 10	 fld	 DWORD PTR tv252[esp+36]
  00168	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e99999a

; 3361 : 								nHP = nHP + nPoint;

  0016e	e8 00 00 00 00	 call	 __ftol2
  00173	03 f8		 add	 edi, eax

; 3362 : 							}
; 3363 : 						}
; 3364 : 						else

  00175	eb 08		 jmp	 SHORT $L283229
$L275472:

; 3365 : 						{
; 3366 : 							if( nHP + nPoint >= nHPMax )	//    .

  00177	03 fb		 add	 edi, ebx
  00179	3b fa		 cmp	 edi, edx
  0017b	7c 02		 jl	 SHORT $L283229
$L283232:

; 3367 : 								nHP = nHPMax;

  0017d	8b fa		 mov	 edi, edx
$L283229:

; 3368 : 							else
; 3369 : 								nHP = nHP + nPoint;
; 3370 : 						}
; 3371 : 					}
; 3372 : 					
; 3373 : 					SetPointParam( pItemProp->dwDestParam[i], nHP );

  0017f	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00182	6a 00		 push	 0
  00184	57		 push	 edi
  00185	50		 push	 eax
  00186	8b ce		 mov	 ecx, esi
  00188	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
$L275461:
  0018d	8b 44 24 14	 mov	 eax, DWORD PTR _i$275459[esp+36]
  00191	40		 inc	 eax
  00192	83 c5 04	 add	 ebp, 4
  00195	83 f8 03	 cmp	 eax, 3
  00198	89 44 24 14	 mov	 DWORD PTR _i$275459[esp+36], eax
  0019c	0f 8c ce fe ff
	ff		 jl	 $L275460
  001a2	5f		 pop	 edi
  001a3	5b		 pop	 ebx
  001a4	5e		 pop	 esi

; 3378 : 				}
; 3379 : 			}
; 3380 : 		}
; 3381 : 	} // for
; 3382 : #endif // worldserver
; 3383 : 	
; 3384 : 	return TRUE;

  001a5	b8 01 00 00 00	 mov	 eax, 1
  001aa	5d		 pop	 ebp

; 3385 : }

  001ab	83 c4 14	 add	 esp, 20			; 00000014H
  001ae	c2 08 00	 ret	 8
?DoUseItemFood@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ENDP ; CMover::DoUseItemFood
_TEXT	ENDS
PUBLIC	?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z	; CMover::ActivateSystemPet
EXTRN	?CalluspPetLog@CDPDatabaseClient@@QAEXKKKHPAVCPet@@@Z:NEAR ; CDPDatabaseClient::CalluspPetLog
EXTRN	??0CPet@@QAE@XZ:NEAR				; CPet::CPet
EXTRN	?GetIndex@CPet@@QAEKXZ:NEAR			; CPet::GetIndex
EXTRN	?InitEgg@CPet@@QAEXXZ:NEAR			; CPet::InitEgg
EXTRN	?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z:NEAR ; CUserMng::AddPetCall
EXTRN	?AddPet@CUser@@QAEXPAVCPet@@E@Z:NEAR		; CUser::AddPet
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?g_dpDBClient@@3VCDPDatabaseClient@@A:BYTE	; g_dpDBClient
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\pet.h
xdata$x	SEGMENT
$T283283 DD	0ffffffffH
	DD	FLAT:$L283240
$T283280 DD	019930520H
	DD	01H
	DD	FLAT:$T283283
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
xdata$x	ENDS
;	COMDAT ?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T283276 = 8						; size = 1
$T283237 = 8						; size = 4
_pItemElem$ = 8						; size = 4
?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z PROC NEAR ; CMover::ActivateSystemPet, COMDAT
; _this$ = ecx

; 4234 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	55		 push	 ebp
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx

; 4235 : #ifdef __QUIZ
; 4236 : 	if( GetWorld() && GetWorld()->GetID() == WI_WORLD_QUIZ )

  0001a	8b 87 6c 01 00
	00		 mov	 eax, DWORD PTR [edi+364]
  00020	85 c0		 test	 eax, eax
  00022	74 0c		 je	 SHORT $L276010
  00024	81 38 d3 00 00
	00		 cmp	 DWORD PTR [eax], 211	; 000000d3H
  0002a	0f 84 df 00 00
	00		 je	 $L276020
$L276010:

; 4237 : 		return;
; 4238 : #endif // __QUIZ
; 4239 : 	if( IsFly() )

  00030	8b 87 3c 02 00
	00		 mov	 eax, DWORD PTR [edi+572]
  00036	f6 40 08 08	 test	 BYTE PTR [eax+8], 8
  0003a	74 20		 je	 SHORT $L276011

; 4240 : 	{
; 4241 : 		static_cast<CUser*>( this )->AddDefinedText( TID_GAME_CANNOT_CALL_PET_ON_FLYING );

  0003c	68 8a 0c 00 00	 push	 3210			; 00000c8aH
  00041	8b cf		 mov	 ecx, edi
  00043	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 4266 : }

  00048	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	c2 04 00	 ret	 4
$L276011:

; 4242 : 		return;	
; 4243 : 	}
; 4244 : 	BOOL bFirst		= FALSE;
; 4245 : 	if( pItemElem->m_pPet == NULL )

  0005c	8b 74 24 1c	 mov	 esi, DWORD PTR _pItemElem$[esp+20]
  00060	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  00066	33 ed		 xor	 ebp, ebp
  00068	85 c0		 test	 eax, eax
  0006a	75 3b		 jne	 SHORT $L276014

; 4246 : 	{
; 4247 : 		pItemElem->m_pPet	= new CPet;

  0006c	6a 28		 push	 40			; 00000028H
  0006e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00073	83 c4 04	 add	 esp, 4
  00076	89 44 24 1c	 mov	 DWORD PTR $T283237[esp+20], eax
  0007a	85 c0		 test	 eax, eax
  0007c	89 6c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], ebp
  00080	74 09		 je	 SHORT $L283238
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 ??0CPet@@QAE@XZ		; CPet::CPet
  00089	eb 02		 jmp	 SHORT $L283239
$L283238:
  0008b	33 c0		 xor	 eax, eax
$L283239:

; 4248 : 		pItemElem->m_pPet->InitEgg();

  0008d	8b c8		 mov	 ecx, eax
  0008f	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  00097	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax
  0009d	e8 00 00 00 00	 call	 ?InitEgg@CPet@@QAEXXZ	; CPet::InitEgg

; 4249 : 		bFirst	= TRUE;

  000a2	bd 01 00 00 00	 mov	 ebp, 1
$L276014:

; 4250 : 	}
; 4251 : 	SetPetId( pItemElem->m_dwObjId );

  000a7	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000aa	89 8f 8c 11 00
	00		 mov	 DWORD PTR [edi+4492], ecx

; 4252 : 
; 4253 : //#if __VER >= 12 // __PET_0519	// CMover::ProcessPetAvail() 
; 4254 : //	SetDestParamRandomOptExtension( pItemElem );	//       
; 4255 : //#endif	// __PET_0519
; 4256 : 	g_dpDBClient.CalluspPetLog( m_idPlayer, pItemElem->GetSerialNumber(), 0, PETLOGTYPE_CALL, pItemElem->m_pPet );

  000b0	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  000b6	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000b9	8b 8f 38 02 00
	00		 mov	 ecx, DWORD PTR [edi+568]
  000bf	52		 push	 edx
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	50		 push	 eax
  000c5	51		 push	 ecx
  000c6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  000cb	e8 00 00 00 00	 call	 ?CalluspPetLog@CDPDatabaseClient@@QAEXKKKHPAVCPet@@@Z ; CDPDatabaseClient::CalluspPetLog

; 4257 : 	// pet, log
; 4258 : #ifdef __PET_1024
; 4259 : 	g_UserMng.AddPetCall( this, pItemElem->m_dwObjId, pItemElem->m_pPet->GetIndex(), (BYTE)pItemElem->m_pPet->GetLevel(), pItemElem->m_pPet->GetName() );

  000d0	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  000d6	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  000d9	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]
  000dc	50		 push	 eax
  000dd	88 54 24 20	 mov	 BYTE PTR $T283276[esp+24], dl
  000e1	8b 44 24 20	 mov	 eax, DWORD PTR $T283276[esp+24]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?GetIndex@CPet@@QAEKXZ	; CPet::GetIndex
  000eb	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000ee	50		 push	 eax
  000ef	51		 push	 ecx
  000f0	57		 push	 edi
  000f1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000f6	e8 00 00 00 00	 call	 ?AddPetCall@CUserMng@@QAEXPAVCMover@@KKEPBD@Z ; CUserMng::AddPetCall

; 4260 : #else	// __PET_1024
; 4261 : 	g_UserMng.AddPetCall( this, pItemElem->m_dwObjId, pItemElem->m_pPet->GetIndex(), (BYTE)pItemElem->m_pPet->GetLevel() );
; 4262 : #endif	// __PET_1024
; 4263 : 	
; 4264 : 	if( bFirst )

  000fb	85 ed		 test	 ebp, ebp
  000fd	74 10		 je	 SHORT $L276020

; 4265 : 		static_cast<CUser*>(this )->AddPet( pItemElem->m_pPet, PF_PET );

  000ff	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  00105	6a 00		 push	 0
  00107	52		 push	 edx
  00108	8b cf		 mov	 ecx, edi
  0010a	e8 00 00 00 00	 call	 ?AddPet@CUser@@QAEXPAVCPet@@E@Z ; CUser::AddPet
$L276020:

; 4266 : }

  0010f	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0011c	5d		 pop	 ebp
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00120	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L283240:
  00000	8b 45 04	 mov	 eax, DWORD PTR $T283237[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T283280
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z ENDP	; CMover::ActivateSystemPet
PUBLIC	?InactivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z ; CMover::InactivateSystemPet
EXTRN	?PetRelease@CMover@@QAEXXZ:NEAR			; CMover::PetRelease
; Function compile flags: /Ogty
;	COMDAT ?InactivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
?InactivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z PROC NEAR ; CMover::InactivateSystemPet, COMDAT
; _this$ = ecx

; 4270 : 	if( GetPetId() == pItemElem->m_dwObjId )

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pItemElem$[esp-4]
  00004	8b 81 8c 11 00
	00		 mov	 eax, DWORD PTR [ecx+4492]
  0000a	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0000d	75 08		 jne	 SHORT $L276026

; 4271 : 		PetRelease();

  0000f	e8 00 00 00 00	 call	 ?PetRelease@CMover@@QAEXXZ ; CMover::PetRelease

; 4274 : }

  00014	c2 04 00	 ret	 4
$L276026:

; 4272 : 	else
; 4273 : 		static_cast<CUser*>(this )->AddDefinedText( TID_GAME_PET_NOWUSE );

  00017	c7 44 24 04 0c
	0d 00 00	 mov	 DWORD PTR _pItemElem$[esp-4], 3340 ; 00000d0cH
  0001f	e9 00 00 00 00	 jmp	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
?InactivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z ENDP	; CMover::InactivateSystemPet
_TEXT	ENDS
PUBLIC	?DoUseSystemPet@CMover@@AAEXPAVCItemElem@@@Z	; CMover::DoUseSystemPet
; Function compile flags: /Ogty
;	COMDAT ?DoUseSystemPet@CMover@@AAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
?DoUseSystemPet@CMover@@AAEXPAVCItemElem@@@Z PROC NEAR	; CMover::DoUseSystemPet, COMDAT
; _this$ = ecx

; 4278 : 	if( HasActivatedSystemPet() )

  00000	8b 81 8c 11 00
	00		 mov	 eax, DWORD PTR [ecx+4492]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 1e		 je	 SHORT $L276033

; 4279 : 		InactivateSystemPet( pItemElem );

  0000b	8b 54 24 04	 mov	 edx, DWORD PTR _pItemElem$[esp-4]
  0000f	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00012	75 08		 jne	 SHORT $L283306
  00014	e8 00 00 00 00	 call	 ?PetRelease@CMover@@QAEXXZ ; CMover::PetRelease

; 4282 : }

  00019	c2 04 00	 ret	 4
$L283306:

; 4279 : 		InactivateSystemPet( pItemElem );

  0001c	c7 44 24 04 0c
	0d 00 00	 mov	 DWORD PTR _pItemElem$[esp-4], 3340 ; 00000d0cH
  00024	e9 00 00 00 00	 jmp	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L276033:

; 4280 : 	else
; 4281 : 		ActivateSystemPet( pItemElem );

  00029	e9 00 00 00 00	 jmp	 ?ActivateSystemPet@CMover@@QAEXPAVCItemElem@@@Z ; CMover::ActivateSystemPet
?DoUseSystemPet@CMover@@AAEXPAVCItemElem@@@Z ENDP	; CMover::DoUseSystemPet
_TEXT	ENDS
PUBLIC	?InactivateBarunaPet@CMover@@QAEXXZ		; CMover::InactivateBarunaPet
EXTRN	?Delete@CObj@@QAEXXZ:NEAR			; CObj::Delete
EXTRN	?GetMover@CProject@@QAEPAVCMover@@K@Z:NEAR	; CProject::GetMover
EXTRN	?AddActivateBarunaPet@CUser@@QAEXKKH@Z:NEAR	; CUser::AddActivateBarunaPet
; Function compile flags: /Ogty
;	COMDAT ?InactivateBarunaPet@CMover@@QAEXXZ
_TEXT	SEGMENT
?InactivateBarunaPet@CMover@@QAEXXZ PROC NEAR		; CMover::InactivateBarunaPet, COMDAT
; _this$ = ecx

; 4514 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4515 : 	CMover* pBarunaPet		= prj.GetMover( GetEatPetId() );

  00003	8b 86 7c 06 00
	00		 mov	 eax, DWORD PTR [esi+1660]
  00009	50		 push	 eax
  0000a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0000f	e8 00 00 00 00	 call	 ?GetMover@CProject@@QAEPAVCMover@@K@Z ; CProject::GetMover

; 4516 : 	if( IsValidObj( pBarunaPet ) )

  00014	85 c0		 test	 eax, eax
  00016	74 0d		 je	 SHORT $L276159
  00018	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0001c	75 07		 jne	 SHORT $L276159

; 4517 : 	{
; 4518 : 		pBarunaPet->Delete();

  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 ?Delete@CObj@@QAEXXZ	; CObj::Delete
$L276159:

; 4519 : 	}
; 4520 : 	SetEatPetId( NULL_ID );
; 4521 : 	static_cast<CUser*>(this)->AddActivateBarunaPet( NULL_ID, NULL_ID, FALSE );

  00025	6a 00		 push	 0
  00027	6a ff		 push	 -1
  00029	6a ff		 push	 -1
  0002b	8b ce		 mov	 ecx, esi
  0002d	c7 86 7c 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1660], -1
  00037	e8 00 00 00 00	 call	 ?AddActivateBarunaPet@CUser@@QAEXKKH@Z ; CUser::AddActivateBarunaPet
  0003c	5e		 pop	 esi

; 4522 : }

  0003d	c3		 ret	 0
?InactivateBarunaPet@CMover@@QAEXXZ ENDP		; CMover::InactivateBarunaPet
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Key
; Function compile flags: /Ogty
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ
_TEXT	SEGMENT
??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@EV?$allocator@E@std@@@std@@QBEAAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	03 4c 24 08	 add	 ecx, DWORD PTR __Off$[esp-4]
  00006	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 			}

  0000c	c2 08 00	 ret	 8
??Hiterator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 160  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 161  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L278633
  0000d	8d 49 00	 npad	 3
$L278632:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L278632
$L278633:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??$copy@PAEPAE@std@@YAPAEPAE00@Z		; std::copy<unsigned char *,unsigned char *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAEPAE@std@@YAPAEPAE00@Z PROC NEAR		; std::copy<unsigned char *,unsigned char *>, COMDAT

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Last$[esp]
  00009	2b f0		 sub	 esi, eax
  0000b	56		 push	 esi
  0000c	50		 push	 eax
  0000d	8b 44 24 18	 mov	 eax, DWORD PTR __Dest$[esp+8]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memmove
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	03 c6		 add	 eax, esi
  0001c	5e		 pop	 esi

; 1041 : 	}

  0001d	c3		 ret	 0
??$copy@PAEPAE@std@@YAPAEPAE00@Z ENDP			; std::copy<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z	; std::copy_backward<unsigned char *,unsigned char *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z PROC NEAR	; std::copy_backward<unsigned char *,unsigned char *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00010	2b c8		 sub	 ecx, eax
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  0001b	c3		 ret	 0
??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::copy_backward<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAt, COMDAT
; _this$ = ecx

; 826  : 	DWORD dwIdx = m_apIndex[ dwIndex ];

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR _dwIndex$[esp-4]
  00007	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 827  : 	if( dwIdx == NULL_ID )

  0000a	83 f8 ff	 cmp	 eax, -1
  0000d	75 05		 jne	 SHORT $L280383

; 828  : 		return NULL;

  0000f	33 c0		 xor	 eax, eax

; 831  : 		return NULL;
; 832  : 	return pItemElem;
; 833  : }

  00011	c2 04 00	 ret	 4
$L280383:

; 829  : 	T* pItemElem = &m_apItem[ dwIdx ];

  00014	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00017	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  0001d	03 c2		 add	 eax, edx
  0001f	8b c8		 mov	 ecx, eax

; 830  : 	if( pItemElem->IsEmpty() ) 

  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	f7 d8		 neg	 eax
  00026	1b c0		 sbb	 eax, eax
  00028	23 c1		 and	 eax, ecx

; 831  : 		return NULL;
; 832  : 	return pItemElem;
; 833  : }

  0002a	c2 04 00	 ret	 4
?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAt
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z PROC NEAR ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Last$[esp]
  00009	2b f0		 sub	 esi, eax
  0000b	56		 push	 esi
  0000c	50		 push	 eax
  0000d	8b 44 24 18	 mov	 eax, DWORD PTR __Dest$[esp+8]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memmove
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	03 c6		 add	 eax, esi
  0001c	5e		 pop	 esi

; 129  : 	}

  0001d	c3		 ret	 0
??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@EIE@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned char,unsigned int,unsigned char>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@EIE@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@EIE@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<unsigned char,unsigned int,unsigned char>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 0e		 jbe	 SHORT $L283473
  0000c	56		 push	 esi
  0000d	8b 74 24 10	 mov	 esi, DWORD PTR __Val$[esp]
$L283471:
  00011	8a 16		 mov	 dl, BYTE PTR [esi]
  00013	88 10		 mov	 BYTE PTR [eax], dl
  00015	40		 inc	 eax
  00016	49		 dec	 ecx
  00017	75 f8		 jne	 SHORT $L283471
  00019	5e		 pop	 esi
$L283473:

; 238  : 	}

  0001a	c3		 ret	 0
??$_Uninit_fill_n@EIE@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned char,unsigned int,unsigned char>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@E@std@@QAEXPAEABE@Z	; std::allocator<unsigned char>::construct
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@E@std@@QAEXPAEABE@Z PROC NEAR	; std::allocator<unsigned char>::construct, COMDAT
; _this$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L283492
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0000c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000e	88 10		 mov	 BYTE PTR [eax], dl
$L283492:

; 148  : 		}

  00010	c2 08 00	 ret	 8
?construct@?$allocator@E@std@@QAEXPAEABE@Z ENDP		; std::allocator<unsigned char>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@E@std@@QAEXPAE@Z		; std::allocator<unsigned char>::destroy
; Function compile flags: /Ogty
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@E@std@@QAEXPAE@Z PROC NEAR		; std::allocator<unsigned char>::destroy, COMDAT
; _this$ = ecx

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@E@std@@QAEXPAE@Z ENDP		; std::allocator<unsigned char>::destroy
_TEXT	ENDS
PUBLIC	??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ ; `string'
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetItemProp
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ DB 'GetItemProp range_er'
	DB	'ror', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 1a		 jl	 SHORT $L197914
  00008	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 10		 jge	 SHORT $L197914

; 1365 : 	return m_aPropItem.GetAt( nIndex ); 

  00012	3b c2		 cmp	 eax, edx
  00014	73 28		 jae	 SHORT $L283526
  00016	8b 89 4c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+588]
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1366 : }

  0001f	c2 04 00	 ret	 4
$L197914:

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00022	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00036	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$L283526:
  0003e	33 c0		 xor	 eax, eax

; 1366 : }

  00040	c2 04 00	 ret	 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ENDP		; CProject::GetItemProp
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@ ; `string'
PUBLIC	?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetSkillProp
;	COMDAT ??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@ DB 'GetSkillProp range_'
	DB	'error', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetSkillProp, COMDAT
; _this$ = ecx

; 1370 : 	VERIFY_RANGE( nIndex, 0, m_aPropSkill.GetSize(), "GetSkillProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 1a		 jl	 SHORT $L197924
  00008	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 10		 jge	 SHORT $L197924

; 1371 : 	return m_aPropSkill.GetAt( nIndex ); 

  00012	3b c2		 cmp	 eax, edx
  00014	73 28		 jae	 SHORT $L283548
  00016	8b 89 70 02 00
	00		 mov	 ecx, DWORD PTR [ecx+624]
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1372 : }

  0001f	c2 04 00	 ret	 4
$L197924:

; 1370 : 	VERIFY_RANGE( nIndex, 0, m_aPropSkill.GetSize(), "GetSkillProp range_error", NULL );

  00022	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00036	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$L283548:
  0003e	33 c0		 xor	 eax, eax

; 1372 : }

  00040	c2 04 00	 ret	 4
?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z ENDP	; CProject::GetSkillProp
_TEXT	ENDS
PUBLIC	??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@	; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	?GetText@CProject@@QAEPBDK@Z			; CProject::GetText
;	COMDAT ??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@ DB 'GetText range_error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetText@CProject@@QAEPBDK@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetText@CProject@@QAEPBDK@Z PROC NEAR			; CProject::GetText, COMDAT
; _this$ = ecx

; 1402 : 	VERIFY_RANGE( (int)( dwIndex ), 0, m_colorText.GetSize(), "GetText range_error", "error" );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 41		 jl	 SHORT $L197970
  00008	8b 91 c8 02 00
	00		 mov	 edx, DWORD PTR [ecx+712]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 37		 jge	 SHORT $L197970

; 1403 : 	if( m_colorText.GetAt( dwIndex ) == NULL )

  00012	3b c2		 cmp	 eax, edx
  00014	73 0c		 jae	 SHORT $L283576
  00016	8b 91 b8 02 00
	00		 mov	 edx, DWORD PTR [ecx+696]
  0001c	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  00020	75 08		 jne	 SHORT $L197974
$L283576:

; 1404 : 		return "";

  00022	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 1406 : }

  00027	c2 04 00	 ret	 4
$L197974:

; 1405 : 	return m_colorText.GetAt( dwIndex )->lpszData; 

  0002a	3b 81 c8 02 00
	00		 cmp	 eax, DWORD PTR [ecx+712]
  00030	72 08		 jb	 SHORT $L283572
  00032	33 c0		 xor	 eax, eax
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1406 : }

  00037	c2 04 00	 ret	 4

; 1405 : 	return m_colorText.GetAt( dwIndex )->lpszData; 

$L283572:
  0003a	8b 89 b8 02 00
	00		 mov	 ecx, DWORD PTR [ecx+696]
  00040	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1406 : }

  00046	c2 04 00	 ret	 4
$L197970:

; 1402 : 	VERIFY_RANGE( (int)( dwIndex ), 0, m_colorText.GetSize(), "GetText range_error", "error" );

  00049	8b 91 c8 02 00
	00		 mov	 edx, DWORD PTR [ecx+712]
  0004f	50		 push	 eax
  00050	52		 push	 edx
  00051	6a 00		 push	 0
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@OHDBLHOM@GetText?5range_error?$AA@
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0005d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00062	83 c4 14	 add	 esp, 20			; 00000014H
  00065	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@

; 1406 : }

  0006a	c2 04 00	 ret	 4
?GetText@CProject@@QAEPBDK@Z ENDP			; CProject::GetText
_TEXT	ENDS
PUBLIC	?GetPropA@CItemElem@@QAEPAUItemProp@@XZ		; CItemElem::GetPropA
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ PROC NEAR	; CItemElem::GetPropA, COMDAT
; _this$ = ecx

; 229  : 	ItemProp*	GetProp()	{	return prj.GetItemProp( m_dwItemId );	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000b	7c 10		 jl	 SHORT $L283607
  0000d	3b c1		 cmp	 eax, ecx
  0000f	7d 0c		 jge	 SHORT $L283607
  00011	73 20		 jae	 SHORT $L283623
  00013	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00019	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001c	c3		 ret	 0
$L283607:
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0002b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$L283623:
  00033	33 c0		 xor	 eax, eax
  00035	c3		 ret	 0
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ENDP		; CItemElem::GetPropA
_TEXT	ENDS
PUBLIC	?IsTransformVisPet@CItemElem@@QAEHXZ		; CItemElem::IsTransformVisPet
; Function compile flags: /Ogty
;	COMDAT ?IsTransformVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?IsTransformVisPet@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::IsTransformVisPet, COMDAT
; _this$ = ecx

; 280  : 	BOOL	IsTransformVisPet() { return GetProp() && GetProp()->dwItemKind3 == IK3_PET && m_bTranformVisPet; }

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00007	85 c0		 test	 eax, eax
  00009	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000f	7c 21		 jl	 SHORT $L283680
  00011	3b c1		 cmp	 eax, ecx
  00013	7d 1d		 jge	 SHORT $L283680
  00015	73 31		 jae	 SHORT $L283627
  00017	8b 35 4c 02 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+588
  0001d	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]
  00020	85 d2		 test	 edx, edx
  00022	74 24		 je	 SHORT $L283627
  00024	85 c0		 test	 eax, eax
  00026	7c 25		 jl	 SHORT $L283757
  00028	3b c1		 cmp	 eax, ecx
  0002a	7d 21		 jge	 SHORT $L283757
  0002c	73 35		 jae	 SHORT $L283759
  0002e	8b c2		 mov	 eax, edx
  00030	eb 33		 jmp	 SHORT $L283752
$L283680:
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	6a 00		 push	 0
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00040	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00045	83 c4 14	 add	 esp, 20			; 00000014H
$L283627:
  00048	5f		 pop	 edi
  00049	33 c0		 xor	 eax, eax
  0004b	5e		 pop	 esi
  0004c	c3		 ret	 0
$L283757:
  0004d	50		 push	 eax
  0004e	51		 push	 ecx
  0004f	6a 00		 push	 0
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0005b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00060	83 c4 14	 add	 esp, 20			; 00000014H
$L283759:
  00063	33 c0		 xor	 eax, eax
$L283752:
  00065	83 78 78 64	 cmp	 DWORD PTR [eax+120], 100 ; 00000064H
  00069	75 dd		 jne	 SHORT $L283627
  0006b	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  00071	85 c0		 test	 eax, eax
  00073	74 d3		 je	 SHORT $L283627
  00075	5f		 pop	 edi
  00076	b8 01 00 00 00	 mov	 eax, 1
  0007b	5e		 pop	 esi
  0007c	c3		 ret	 0
?IsTransformVisPet@CItemElem@@QAEHXZ ENDP		; CItemElem::IsTransformVisPet
_TEXT	ENDS
PUBLIC	?GetPropA@tagSkill@@QAEPAUItemProp@@XZ		; tagSkill::GetPropA
; Function compile flags: /Ogty
;	COMDAT ?GetPropA@tagSkill@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@tagSkill@@QAEPAUItemProp@@XZ PROC NEAR	; tagSkill::GetPropA, COMDAT
; _this$ = ecx

; 313  : 	ItemProp* GetProp()	{ return prj.GetSkillProp( dwSkill ); }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	8b 0d 80 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+640
  0000a	7c 10		 jl	 SHORT $L283798
  0000c	3b c1		 cmp	 eax, ecx
  0000e	7d 0c		 jge	 SHORT $L283798
  00010	73 20		 jae	 SHORT $L283801
  00012	8b 0d 70 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+624
  00018	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001b	c3		 ret	 0
$L283798:
  0001c	50		 push	 eax
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0002a	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
$L283801:
  00032	33 c0		 xor	 eax, eax
  00034	c3		 ret	 0
?GetPropA@tagSkill@@QAEPAUItemProp@@XZ ENDP		; tagSkill::GetPropA
_TEXT	ENDS
PUBLIC	?GetVisPetItem@CMover@@QAEPAVCItemElem@@XZ	; CMover::GetVisPetItem
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
;	COMDAT ?GetVisPetItem@CMover@@QAEPAVCItemElem@@XZ
_TEXT	SEGMENT
?GetVisPetItem@CMover@@QAEPAVCItemElem@@XZ PROC NEAR	; CMover::GetVisPetItem, COMDAT
; _this$ = ecx

; 844  : 	CItemElem*	GetVisPetItem( void )	{ return m_Inventory.GetAtId( m_objIdVisPet ); }

  00000	8b 81 94 11 00
	00		 mov	 eax, DWORD PTR [ecx+4500]
  00006	3b 81 9c 0b 00
	00		 cmp	 eax, DWORD PTR [ecx+2972]
  0000c	72 03		 jb	 SHORT $L283819
  0000e	33 c0		 xor	 eax, eax
  00010	c3		 ret	 0
$L283819:
  00011	8b 91 a0 0b 00
	00		 mov	 edx, DWORD PTR [ecx+2976]
  00017	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  0001d	03 c2		 add	 eax, edx
  0001f	8b c8		 mov	 ecx, eax
  00021	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00024	f7 d8		 neg	 eax
  00026	1b c0		 sbb	 eax, eax
  00028	23 c1		 and	 eax, ecx
  0002a	c3		 ret	 0
?GetVisPetItem@CMover@@QAEPAVCItemElem@@XZ ENDP		; CMover::GetVisPetItem
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 501  : 		return( GetData()->nDataLength );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]

; 502  : 	}

  00005	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 468  : 		return (const_iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 469  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT
; _this$ = ecx

; 478  : 		return (const_iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 479  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 210  : 	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 211  : 	{
; 212  : 		ATLASSERT( pStringMgr != NULL );
; 213  : 		CStringData* pData = pStringMgr->GetNilString();

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _pStringMgr$[esp]
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 0c	 call	 DWORD PTR [eax+12]

; 214  : 		Attach( pData );

  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 06		 mov	 DWORD PTR [esi], eax

; 215  : 	}

  00011	8b c6		 mov	 eax, esi
  00013	5e		 pop	 esi
  00014	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Ogty
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 263  : 		CStringData* pData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 264  : 		pData->Release();

  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L283871
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L283871:

; 265  : 	}

  0001c	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
; Function compile flags: /Ogty
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nNewLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L283889
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L283889
  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 549  : 	}

  00018	c2 04 00	 ret	 4
$L283889:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L283892:
$L283891:
  00025	cc		 int	 3
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 35   : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z PROC NEAR ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 22   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ENDP ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 422  : 		CStringData* pOldData = GetData();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 424  : 		if( pOldData->nDataLength == 0 )

  00005	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  00008	85 d2		 test	 edx, edx
  0000a	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	74 4c		 je	 SHORT $L283970
  00012	53		 push	 ebx

; 425  : 		{
; 426  : 			return;
; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

  00013	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00016	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  00019	85 db		 test	 ebx, ebx
  0001b	5b		 pop	 ebx
  0001c	7d 20		 jge	 SHORT $L221323

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

  0001e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00021	85 c0		 test	 eax, eax
  00023	7d 0a		 jge	 SHORT $L283959
  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L283975:
$L283959:
  0002f	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	5f		 pop	 edi
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003c	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  0003d	c3		 ret	 0
$L221323:

; 433  : 		}
; 434  : 		else
; 435  : 		{
; 436  : 			pOldData->Release();

  0003e	83 c9 ff	 or	 ecx, -1
  00041	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00045	49		 dec	 ecx
  00046	85 c9		 test	 ecx, ecx
  00048	7f 08		 jg	 SHORT $L283965
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	50		 push	 eax
  0004f	ff 52 04	 call	 DWORD PTR [edx+4]
$L283965:

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b cf		 mov	 ecx, edi
  00056	ff 50 0c	 call	 DWORD PTR [eax+12]

; 438  : 			Attach( pNewData );

  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 06		 mov	 DWORD PTR [esi], eax
$L283970:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  00060	c3		 ret	 0
$L283974:
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 747  : 		CStringData* pOldData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 748  : 		if( pOldData->nDataLength > nLength )

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _nLength$[esp-4]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7e 02		 jle	 SHORT $L221345

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  00011	8b d6		 mov	 edx, esi
$L221345:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00013	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00017	5e		 pop	 esi
  00018	7e 09		 jle	 SHORT $L221346

; 753  : 		{
; 754  : 			Fork( nLength );

  0001a	89 54 24 04	 mov	 DWORD PTR _nLength$[esp-4], edx
  0001e	e9 00 00 00 00	 jmp	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L221346:

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00023	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00026	3b c2		 cmp	 eax, edx
  00028	7d 1f		 jge	 SHORT $L221348

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;
; 760  : 			if( nNewLength > 1024 )

  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7e 07		 jle	 SHORT $L221350

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00031	05 00 04 00 00	 add	 eax, 1024		; 00000400H

; 763  : 			}
; 764  : 			else

  00036	eb 02		 jmp	 SHORT $L221351
$L221350:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00038	03 c0		 add	 eax, eax
$L221351:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 02		 jge	 SHORT $L221352

; 769  : 			{
; 770  : 				nNewLength = nLength;

  0003e	8b c2		 mov	 eax, edx
$L221352:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00040	89 44 24 04	 mov	 DWORD PTR _nLength$[esp-4], eax
  00044	e9 00 00 00 00	 jmp	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L221348:

; 773  : 		}
; 774  : 	}

  00049	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00008	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000b	72 0a		 jb	 SHORT $L283994
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1476 : 		}

  00014	c2 04 00	 ret	 4

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$L283994:
  00017	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 1476 : 		}

  0001c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 522  : 		}

  00003	c3		 ret	 0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC NEAR	; std::allocator<unsigned char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 138  : 		}

  0000d	c2 04 00	 ret	 4
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1116 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 138  : 		}

  0000d	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?SetMasterSkillPointUp@CMover@@QAEXXZ		; CMover::SetMasterSkillPointUp
EXTRN	?IsHero@CMover@@QAEHXZ:NEAR			; CMover::IsHero
EXTRN	?IsLegendHero@CMover@@QAEHXZ:NEAR		; CMover::IsLegendHero
EXTRN	?AddDoUseSkillPoint@CUser@@QAEXQAUtagSkill@@H@Z:NEAR ; CUser::AddDoUseSkillPoint
EXTRN	?SendLogSkillPoint@CDPDatabaseClient@@QAEXHHPAVCMover@@PAUtagSkill@@@Z:NEAR ; CDPDatabaseClient::SendLogSkillPoint
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
;	COMDAT ?SetMasterSkillPointUp@CMover@@QAEXXZ
_TEXT	SEGMENT
$T284049 = -12						; size = 12
$T284048 = -12						; size = 12
$T284047 = -12						; size = 12
?SetMasterSkillPointUp@CMover@@QAEXXZ PROC NEAR		; CMover::SetMasterSkillPointUp, COMDAT
; _this$ = ecx

; 71   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 72   : 	if( m_nLevel != 72 && m_nLevel != 84 && m_nLevel != 96 && m_nLevel != 108 )

  00006	8b 87 e0 05 00
	00		 mov	 eax, DWORD PTR [edi+1504]
  0000c	83 f8 48	 cmp	 eax, 72			; 00000048H
  0000f	74 13		 je	 SHORT $L274252
  00011	83 f8 54	 cmp	 eax, 84			; 00000054H
  00014	74 0e		 je	 SHORT $L274252
  00016	83 f8 60	 cmp	 eax, 96			; 00000060H
  00019	74 09		 je	 SHORT $L274252
  0001b	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  0001e	0f 85 cc 00 00
	00		 jne	 $L274251
$L274252:

; 73   : 		return;
; 74   : 	if( IsHero() )

  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  0002b	85 c0		 test	 eax, eax
  0002d	0f 85 bd 00 00
	00		 jne	 $L274251

; 75   : 		return;
; 76   : #ifdef __3RD_LEGEND16
; 77   : 	if( IsLegendHero() )

  00033	8b cf		 mov	 ecx, edi
  00035	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  0003a	85 c0		 test	 eax, eax
  0003c	0f 85 ae 00 00
	00		 jne	 $L274251
  00042	53		 push	 ebx
  00043	55		 push	 ebp

; 78   : 		return;
; 79   : #endif // __3RD_LEGEND16
; 80   : 	for( int i = 0; i < MAX_SKILL_JOB; i++ ) 

  00044	8d 9f 6c 03 00
	00		 lea	 ebx, DWORD PTR [edi+876]
  0004a	56		 push	 esi
  0004b	8b f3		 mov	 esi, ebx
  0004d	bd 33 00 00 00	 mov	 ebp, 51			; 00000033H
$L274256:

; 81   : 	{				
; 82   : 		LPSKILL lpSkill = &(m_aJobSkill[i]);
; 83   : 		if( lpSkill && lpSkill->dwSkill != NULL_ID )

  00052	85 f6		 test	 esi, esi
  00054	74 33		 je	 SHORT $L274257
  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	74 2c		 je	 SHORT $L274257

; 84   : 		{
; 85   : 			ItemProp* pSkillProp    = prj.GetSkillProp( lpSkill->dwSkill );			

  0005d	50		 push	 eax
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00063	e8 00 00 00 00	 call	 ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetSkillProp

; 86   : 			if( pSkillProp == NULL )

  00068	85 c0		 test	 eax, eax
  0006a	74 1d		 je	 SHORT $L274257

; 87   : 				continue;
; 88   : 			if( pSkillProp->dwItemKind1 != JTYPE_MASTER)

  0006c	83 78 70 05	 cmp	 DWORD PTR [eax+112], 5
  00070	75 17		 jne	 SHORT $L274257

; 89   : 				continue;
; 90   : 			lpSkill->dwLevel++;

  00072	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 91   : 			g_dpDBClient.SendLogSkillPoint( LOG_SKILLPOINT_USE, 1, this, &(m_aJobSkill[i]) );

  00075	56		 push	 esi
  00076	57		 push	 edi
  00077	41		 inc	 ecx
  00078	6a 01		 push	 1
  0007a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0007d	6a 10		 push	 16			; 00000010H
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00084	e8 00 00 00 00	 call	 ?SendLogSkillPoint@CDPDatabaseClient@@QAEXHHPAVCMover@@PAUtagSkill@@@Z ; CDPDatabaseClient::SendLogSkillPoint
$L274257:
  00089	83 c6 08	 add	 esi, 8
  0008c	4d		 dec	 ebp
  0008d	75 c3		 jne	 SHORT $L274256

; 92   : 		}
; 93   : 	}	
; 94   : 	g_UserMng.AddCreateSfxObj(this, XI_SYS_EXCHAN01, GetPos().x, GetPos().y, GetPos().z);

  0008f	8b af 64 01 00
	00		 mov	 ebp, DWORD PTR [edi+356]
  00095	8d 87 60 01 00
	00		 lea	 eax, DWORD PTR [edi+352]
  0009b	8b c8		 mov	 ecx, eax
  0009d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009f	89 54 24 10	 mov	 DWORD PTR $T284047[esp+28], edx
  000a3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a6	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000a9	89 54 24 14	 mov	 DWORD PTR $T284047[esp+32], edx
  000ad	8b f0		 mov	 esi, eax
  000af	8b 16		 mov	 edx, DWORD PTR [esi]
  000b1	6a 00		 push	 0
  000b3	89 54 24 14	 mov	 DWORD PTR $T284048[esp+32], edx
  000b7	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000ba	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  000bd	51		 push	 ecx
  000be	52		 push	 edx
  000bf	89 74 24 24	 mov	 DWORD PTR $T284048[esp+48], esi
  000c3	8b 30		 mov	 esi, DWORD PTR [eax]
  000c5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c8	56		 push	 esi
  000c9	6a 6c		 push	 108			; 0000006cH
  000cb	57		 push	 edi
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000d1	89 6c 24 2c	 mov	 DWORD PTR $T284049[esp+56], ebp
  000d5	89 44 24 30	 mov	 DWORD PTR $T284049[esp+60], eax
  000d9	e8 00 00 00 00	 call	 ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj

; 95   : 
; 96   : 	CUser *pUser = (CUser *)this;
; 97   : 	pUser->AddDoUseSkillPoint( &m_aJobSkill[0], m_nSkillPoint );

  000de	8b 8f a4 11 00
	00		 mov	 ecx, DWORD PTR [edi+4516]
  000e4	51		 push	 ecx
  000e5	53		 push	 ebx
  000e6	8b cf		 mov	 ecx, edi
  000e8	e8 00 00 00 00	 call	 ?AddDoUseSkillPoint@CUser@@QAEXQAUtagSkill@@H@Z ; CUser::AddDoUseSkillPoint
  000ed	5e		 pop	 esi
  000ee	5d		 pop	 ebp
  000ef	5b		 pop	 ebx
$L274251:
  000f0	5f		 pop	 edi

; 98   : 
; 99   : #ifdef __S_NEW_SKILL_2
; 100  : 	g_dpDBClient.SaveSkill( this );
; 101  : #endif // __S_NEW_SKILL_2
; 102  : }

  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	c3		 ret	 0
?SetMasterSkillPointUp@CMover@@QAEXXZ ENDP		; CMover::SetMasterSkillPointUp
_TEXT	ENDS
PUBLIC	?GetQueueCastingTime@CMover@@QAEHXZ		; CMover::GetQueueCastingTime
PUBLIC	__real@3f333333
PUBLIC	__real@3a83126f
PUBLIC	__real@41700000
PUBLIC	??_C@_0DO@PAGMBNAO@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0EC@JPIDGHBC@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@ ; `string'
EXTRN	?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z:NEAR	; CMover::GetSkill
EXTRN	?GetAddSkillProp@CProject@@QAEPAUAddSkillProp@@KK@Z:NEAR ; CProject::GetAddSkillProp
EXTRN	?GetCastingTime@CMover@@QAEHH@Z:NEAR		; CMover::GetCastingTime
;	COMDAT __real@3f333333
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT ??_C@_0DO@PAGMBNAO@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0DO@PAGMBNAO@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@ DB 'CMover::'
	DB	'GetQueueCastingTime : %s. ', 0bdH, 0baH, 0c5H, 0b3H, '(%d)', 0c0H
	DB	0c7H, ' ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH, 0c6H, 0bcH, 0b0H
	DB	0a1H, ' ', 0beH, 0f8H, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@JPIDGHBC@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0EC@JPIDGHBC@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@ DB 'CMover::'
	DB	'GetQueueCastingTime : %s. ', 0beH, 0d6H, 0b5H, 0e5H, 0bdH, 0baH
	DB	0c5H, 0b3H, '(%d)', 0c0H, 0c7H, ' ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H
	DB	0dbH, 0c6H, 0bcH, 0b0H, 0a1H, ' ', 0beH, 0f8H, 0b4H, 0d9H, '.', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?GetQueueCastingTime@CMover@@QAEHXZ
_TEXT	SEGMENT
tv313 = -4						; size = 4
_nTotalTime$ = -4					; size = 4
?GetQueueCastingTime@CMover@@QAEHXZ PROC NEAR		; CMover::GetQueueCastingTime, COMDAT
; _this$ = ecx

; 107  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	8b d9		 mov	 ebx, ecx

; 108  : 	if( IsNPC() )	

  00004	8b 83 34 02 00
	00		 mov	 eax, DWORD PTR [ebx+564]
  0000a	55		 push	 ebp
  0000b	33 ed		 xor	 ebp, ebp
  0000d	3b c5		 cmp	 eax, ebp
  0000f	75 06		 jne	 SHORT $L274272
  00011	5d		 pop	 ebp

; 109  : 		return 0;

  00012	33 c0		 xor	 eax, eax
  00014	5b		 pop	 ebx

; 163  : }

  00015	59		 pop	 ecx
  00016	c3		 ret	 0
$L274272:
  00017	57		 push	 edi

; 110  : 
; 111  : 	CUser *pUser = (CUser *)this;
; 112  : 	int		i;
; 113  : 	SHORTCUT *pSlotQueue = pUser->m_playTaskBar.m_aSlotQueue;

  00018	8d 83 b0 91 00
	00		 lea	 eax, DWORD PTR [ebx+37296]

; 114  : 	int		nTotalTime = 0;

  0001e	89 6c 24 0c	 mov	 DWORD PTR _nTotalTime$[esp+16], ebp
  00022	8b f8		 mov	 edi, eax
  00024	56		 push	 esi
$L274278:

; 115  : 
; 116  : 	for( i = 0; i < MAX_SLOT_QUEUE; i ++ )
; 117  : 	{
; 118  : 		if( pSlotQueue[i].m_dwShortcut )

  00025	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00028	74 52		 je	 SHORT $L274279

; 119  : 		{
; 120  : 			LPSKILL pSkill = GetSkill( 0, pSlotQueue[i].m_dwId );

  0002a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002d	50		 push	 eax
  0002e	6a 00		 push	 0
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z ; CMover::GetSkill

; 121  : 			
; 122  : 			ItemProp *pSkillProp;
; 123  : 			if( !( pSkillProp = pSkill->GetProp() ) )					// JobSkill     .

  00037	8b 0d 80 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+640
  0003d	8b f0		 mov	 esi, eax
  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	85 c0		 test	 eax, eax
  00043	7c 79		 jl	 SHORT $L284112
  00045	3b c1		 cmp	 eax, ecx
  00047	7d 75		 jge	 SHORT $L284112
  00049	72 04		 jb	 SHORT $L284122
  0004b	33 c0		 xor	 eax, eax
  0004d	eb 09		 jmp	 SHORT $L284121
$L284122:
  0004f	8b 0d 70 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+624
  00055	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
$L284121:
  00058	85 c0		 test	 eax, eax
  0005a	74 78		 je	 SHORT $L284126

; 127  : 			}
; 128  : 			
; 129  : 			AddSkillProp* pAddSkillProp;
; 130  : 			
; 131  : 		#ifdef __SKILL0517
; 132  : 			if( !( pAddSkillProp	= prj.GetAddSkillProp( pSkillProp->dwSubDefine, GetSkillLevel( pSkill ) ) ) )					// JobSkill     .
; 133  : 		#else	// __SKILL0517
; 134  : 			if( !( pAddSkillProp	= prj.GetAddSkillProp( pSkillProp->dwSubDefine, pSkill->dwLevel ) ) )					// JobSkill     .

  0005c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0005f	8b 80 40 02 00
	00		 mov	 eax, DWORD PTR [eax+576]
  00065	52		 push	 edx
  00066	50		 push	 eax
  00067	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0006c	e8 00 00 00 00	 call	 ?GetAddSkillProp@CProject@@QAEPAUAddSkillProp@@KK@Z ; CProject::GetAddSkillProp
  00071	85 c0		 test	 eax, eax
  00073	74 7e		 je	 SHORT $L284127

; 139  : 			}
; 140  : 
; 141  : 		#ifdef _DEBUG
; 142  : 		#if __VER >= 9	// __SKILL_0706
; 143  : 			if( (int)pAddSkillProp->dwCastingTime <= 0 )
; 144  : 				Error( "GetQueueCastingTime : %s addProp dwCastingTime %d", pSkillProp->szName, pAddSkillProp->dwCastingTime );
; 145  : 		#else	// __SKILL_0706
; 146  : 			if( (int)pAddSkillProp->dwSkillReady <= 0 )
; 147  : 				Error( "GetQueueCastingTime : %s addProp dwSkillReady %d", pSkillProp->szName, pAddSkillProp->dwSkillReady );
; 148  : 		#endif	// __SKILL_0706
; 149  : 		#endif
; 150  : #if __VER >= 9	// __SKILL_0706
; 151  : 			nTotalTime += (int)pAddSkillProp->dwCastingTime;

  00075	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00078	01 4c 24 10	 add	 DWORD PTR _nTotalTime$[esp+20], ecx
$L274279:
  0007c	45		 inc	 ebp
  0007d	81 c7 98 00 00
	00		 add	 edi, 152		; 00000098H
  00083	83 fd 06	 cmp	 ebp, 6
  00086	7c 9d		 jl	 SHORT $L274278

; 152  : #else	// __SKILL_0706
; 153  : 			nTotalTime += (int)pAddSkillProp->dwSkillReady;
; 154  : #endif	// __SKILL_0706
; 155  : 		}
; 156  : 	}
; 157  : 
; 158  : 	nTotalTime = (int)(nTotalTime * 0.7f);		// 70 .
; 159  : 	nTotalTime = (int)( (nTotalTime / 1000.0f) * SEC1 );	//   .
; 160  : 	nTotalTime	= GetCastingTime( nTotalTime );
; 161  : 
; 162  : 	return nTotalTime;

  00088	db 44 24 10	 fild	 DWORD PTR _nTotalTime$[esp+20]
  0008c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f333333
  00092	e8 00 00 00 00	 call	 __ftol2
  00097	89 44 24 10	 mov	 DWORD PTR tv313[esp+20], eax
  0009b	db 44 24 10	 fild	 DWORD PTR tv313[esp+20]
  0009f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a83126f
  000a5	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41700000
  000ab	e8 00 00 00 00	 call	 __ftol2
  000b0	50		 push	 eax
  000b1	8b cb		 mov	 ecx, ebx
  000b3	e8 00 00 00 00	 call	 ?GetCastingTime@CMover@@QAEHH@Z ; CMover::GetCastingTime
  000b8	5e		 pop	 esi
  000b9	5f		 pop	 edi
  000ba	5d		 pop	 ebp
  000bb	5b		 pop	 ebx

; 163  : }

  000bc	59		 pop	 ecx
  000bd	c3		 ret	 0

; 121  : 			
; 122  : 			ItemProp *pSkillProp;
; 123  : 			if( !( pSkillProp = pSkill->GetProp() ) )					// JobSkill     .

$L284112:
  000be	50		 push	 eax
  000bf	51		 push	 ecx
  000c0	6a 00		 push	 0
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000cc	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000d1	83 c4 14	 add	 esp, 20			; 00000014H
$L284126:

; 124  : 			{
; 125  : 				Error( "CMover::GetQueueCastingTime : %s. (%d)  .", m_szName, pSkill->dwSkill );

  000d4	8b 16		 mov	 edx, DWORD PTR [esi]
  000d6	52		 push	 edx
  000d7	81 c3 90 16 00
	00		 add	 ebx, 5776		; 00001690H
  000dd	53		 push	 ebx
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DO@PAGMBNAO@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@
  000e3	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000eb	5e		 pop	 esi
  000ec	5f		 pop	 edi
  000ed	5d		 pop	 ebp

; 126  : 				return FALSE;	// property not found

  000ee	33 c0		 xor	 eax, eax
  000f0	5b		 pop	 ebx

; 163  : }

  000f1	59		 pop	 ecx
  000f2	c3		 ret	 0
$L284127:

; 135  : 		#endif	// __SKILL0517
; 136  : 			{
; 137  : 				Error( "CMover::GetQueueCastingTime : %s. (%d)  .", m_szName, pSkill->dwSkill );

  000f3	8b 06		 mov	 eax, DWORD PTR [esi]
  000f5	50		 push	 eax
  000f6	81 c3 90 16 00
	00		 add	 ebx, 5776		; 00001690H
  000fc	53		 push	 ebx
  000fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EC@JPIDGHBC@CMover?3?3GetQueueCastingTime?5?3?5?$CFs@
  00102	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	5e		 pop	 esi
  0010b	5f		 pop	 edi
  0010c	5d		 pop	 ebp

; 138  : 				return FALSE;	// property not found

  0010d	33 c0		 xor	 eax, eax
  0010f	5b		 pop	 ebx

; 163  : }

  00110	59		 pop	 ecx
  00111	c3		 ret	 0
?GetQueueCastingTime@CMover@@QAEHXZ ENDP		; CMover::GetQueueCastingTime
_TEXT	ENDS
PUBLIC	??_C@_0N@KNNGFFII@SkillLevel1?5?$AA@		; `string'
PUBLIC	??_C@_0DF@KIFDAMPH@DoUseSkill?5?3?5?$CFs?5NULL?5GetSkill?5?$CFd@ ; `string'
PUBLIC	??_C@_0N@KPJAOLNB@SkillLevel2?5?$AA@		; `string'
PUBLIC	??_C@_0CB@HOKPNGH@DoUseSkill?5?3?5?$CFs?5dwSkillType?5?$DN?5?$CFd@ ; `string'
PUBLIC	?DoUseSkill@CMover@@QAEHKHKW4SKILLUSETYPE@@HH@Z	; CMover::DoUseSkill
PUBLIC	??_C@_0L@LLMCBIOI@DoUseSkill?$AA@		; `string'
PUBLIC	??_C@_0CN@EEBJCALL@DoUseSkill?5?3?5?$CFs?5?0?5?E?$LI?$LA?Y?5?$CFs?5?$MA?G?5?G?A?$LH@ ; `string'
EXTRN	?GetPKPVPRegionAttr@CMover@@QAEKXZ:NEAR		; CMover::GetPKPVPRegionAttr
EXTRN	?AddText@CUser@@QAEXPBD@Z:NEAR			; CUser::AddText
EXTRN	?IsMaster@CMover@@QAEHXZ:NEAR			; CMover::IsMaster
EXTRN	?IsGuildCombatTarget@CMover@@QAEHPAV1@@Z:NEAR	; CMover::IsGuildCombatTarget
EXTRN	?IsSteal@CMover@@QAEHPAV1@@Z:NEAR		; CMover::IsSteal
EXTRN	?ArrowDown@CMover@@QAEXH@Z:NEAR			; CMover::ArrowDown
EXTRN	?GetActiveHandItemProp@CMover@@QAEPAUItemProp@@H@Z:NEAR ; CMover::GetActiveHandItemProp
EXTRN	?GetWeaponItem@CMover@@QAEPAVCItemElem@@H@Z:NEAR ; CMover::GetWeaponItem
EXTRN	?GetLWeaponItem@CMover@@QAEPAVCItemElem@@XZ:NEAR ; CMover::GetLWeaponItem
EXTRN	?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z:NEAR	; CMover::GetEquipItem
EXTRN	?IsDualWeapon@CMover@@QAEHXZ:NEAR		; CMover::IsDualWeapon
EXTRN	?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z:NEAR ; CUserMng::AddUseSkill
EXTRN	?SetActParam@CMover@@AAEXW4OBJACT@@HHH@Z:NEAR	; CMover::SetActParam
EXTRN	?GetSkill@CMover@@QAEPAUtagSkill@@K@Z:NEAR	; CMover::GetSkill
EXTRN	?GetSkillIdx@CMover@@QAEHK@Z:NEAR		; CMover::GetSkillIdx
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	?IncManaPoint@CMover@@QAEXH@Z:NEAR		; CMover::IncManaPoint
EXTRN	?IncFatiguePoint@CMover@@QAEXH@Z:NEAR		; CMover::IncFatiguePoint
EXTRN	?IsPVPTarget@CMover@@QAEHPAV1@@Z:NEAR		; CMover::IsPVPTarget
EXTRN	?IsWarTarget@CMover@@QAEHPAV1@@Z:NEAR		; CMover::IsWarTarget
EXTRN	?IsArenaTarget@CMover@@QAEHPAV1@@Z:NEAR		; CMover::IsArenaTarget
EXTRN	?GetHitType2@CMover@@QAE?AW4HITTYPE@@PAV1@HH@Z:NEAR ; CMover::GetHitType2
EXTRN	?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z:NEAR	; CUserMng::AddPKPink
EXTRN	?GetManaPoint@CMover@@QAEHXZ:NEAR		; CMover::GetManaPoint
EXTRN	?GetFatiguePoint@CMover@@QAEHXZ:NEAR		; CMover::GetFatiguePoint
EXTRN	?GetReqMp@CMover@@QAEHH@Z:NEAR			; CMover::GetReqMp
EXTRN	?GetReqFp@CMover@@QAEHH@Z:NEAR			; CMover::GetReqFp
EXTRN	?IsPKPVPInspectionBase@CMover@@QAEHKH@Z:NEAR	; CMover::IsPKPVPInspectionBase
EXTRN	?g_GuildCombatMng@@3VCGuildCombat@@A:BYTE	; g_GuildCombatMng
EXTRN	?SetJJim@CMover@@QAEXPAV1@@Z:NEAR		; CMover::SetJJim
EXTRN	?IsBullet@CMover@@QAEHPAUItemProp@@@Z:NEAR	; CMover::IsBullet
;	COMDAT ??_C@_0L@LLMCBIOI@DoUseSkill?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_0L@LLMCBIOI@DoUseSkill?$AA@ DB 'DoUseSkill', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EEBJCALL@DoUseSkill?5?3?5?$CFs?5?0?5?E?$LI?$LA?Y?5?$CFs?5?$MA?G?5?G?A?$LH@
CONST	SEGMENT
??_C@_0CN@EEBJCALL@DoUseSkill?5?3?5?$CFs?5?0?5?E?$LI?$LA?Y?5?$CFs?5?$MA?G?5?G?A?$LH@ DB 'D'
	DB	'oUseSkill : %s , ', 0c5H, 0b8H, 0b0H, 0d9H, ' %s ', 0c0H, 0c7H
	DB	' ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH, 0c6H, 0bcH, 0b0H, 0a1H
	DB	' ', 0beH, 0f8H, 0b4H, 0d9H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KNNGFFII@SkillLevel1?5?$AA@
CONST	SEGMENT
??_C@_0N@KNNGFFII@SkillLevel1?5?$AA@ DB 'SkillLevel1 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KIFDAMPH@DoUseSkill?5?3?5?$CFs?5NULL?5GetSkill?5?$CFd@
CONST	SEGMENT
??_C@_0DF@KIFDAMPH@DoUseSkill?5?3?5?$CFs?5NULL?5GetSkill?5?$CFd@ DB 'DoUs'
	DB	'eSkill : %s NULL GetSkill %d = dwReSkill(%d, %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPJAOLNB@SkillLevel2?5?$AA@
CONST	SEGMENT
??_C@_0N@KPJAOLNB@SkillLevel2?5?$AA@ DB 'SkillLevel2 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HOKPNGH@DoUseSkill?5?3?5?$CFs?5dwSkillType?5?$DN?5?$CFd@
CONST	SEGMENT
??_C@_0CB@HOKPNGH@DoUseSkill?5?3?5?$CFs?5dwSkillType?5?$DN?5?$CFd@ DB 'Do'
	DB	'UseSkill : %s dwSkillType = %d', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseSkill@CMover@@QAEHKHKW4SKILLUSETYPE@@HH@Z
_TEXT	SEGMENT
_pSkillProp$ = -36					; size = 4
_pAddSkillProp$ = -32					; size = 4
_pTarget$ = -28						; size = 4
$T284141 = -24						; size = 12
$T284142 = -12						; size = 12
_dwSkill$ = 8						; size = 4
_nLevel$ = 12						; size = 4
_idFocusObj$ = 16					; size = 4
_sutType$ = 20						; size = 4
_bControl$ = 24						; size = 4
_nCastingTime$ = 28					; size = 4
?DoUseSkill@CMover@@QAEHKHKW4SKILLUSETYPE@@HH@Z PROC NEAR ; CMover::DoUseSkill, COMDAT
; _this$ = ecx

; 301  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 302  : 	if( IsDie() )	return FALSE;

  00006	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0000c	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  00013	75 1d		 jne	 SHORT $L284351
  00015	8b 96 00 06 00
	00		 mov	 edx, DWORD PTR [esi+1536]
  0001b	33 c9		 xor	 ecx, ecx
  0001d	3b d1		 cmp	 edx, ecx
  0001f	74 11		 je	 SHORT $L284351

; 303  : 	if( m_pActMover->IsFly() )	return FALSE;

  00021	f6 40 08 08	 test	 BYTE PTR [eax+8], 8
  00025	75 0b		 jne	 SHORT $L284351

; 304  : 	if( m_dwFlag & MVRF_NOATTACK )	

  00027	8b 86 48 02 00
	00		 mov	 eax, DWORD PTR [esi+584]
  0002d	f6 c4 02	 test	 ah, 2
  00030	74 09		 je	 SHORT $L274337
$L284351:

; 305  : 		return FALSE;		//    .

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi

; 1090 : }

  00035	83 c4 24	 add	 esp, 36			; 00000024H
  00038	c2 18 00	 ret	 24			; 00000018H
$L274337:
  0003b	53		 push	 ebx

; 306  : 
; 307  : #ifdef __QUIZ
; 308  : 	if( GetWorld() && GetWorld()->GetID() == WI_WORLD_QUIZ )

  0003c	8b 9e 6c 01 00
	00		 mov	 ebx, DWORD PTR [esi+364]
  00042	3b d9		 cmp	 ebx, ecx
  00044	74 45		 je	 SHORT $L274341
  00046	8b 03		 mov	 eax, DWORD PTR [ebx]
  00048	3d d3 00 00 00	 cmp	 eax, 211		; 000000d3H

; 309  : 		return FALSE;

  0004d	74 32		 je	 SHORT $L274342

; 310  : #endif // __QUIZ
; 311  : 	
; 312  : #if defined(__WORLDSERVER)	
; 313  : 	//   
; 314  : 	CWorld* pWorld	= GetWorld();
; 315  : 	if( pWorld && pWorld->GetID() == WI_WORLD_GUILDWAR )

  0004f	3b d9		 cmp	 ebx, ecx
  00051	74 38		 je	 SHORT $L274341
  00053	3d ca 00 00 00	 cmp	 eax, 202		; 000000caH
  00058	75 31		 jne	 SHORT $L274341

; 316  : 	{		
; 317  : 		if( m_nGuildCombatState == 0 )

  0005a	39 8e 98 0e 00
	00		 cmp	 DWORD PTR [esi+3736], ecx
  00060	75 29		 jne	 SHORT $L274341

; 318  : 		{
; 319  : 			if( IsPlayer() )

  00062	39 8e 34 02 00
	00		 cmp	 DWORD PTR [esi+564], ecx
  00068	74 17		 je	 SHORT $L274342

; 320  : 				((CUser*) this)->AddText( prj.GetText( TID_GAME_GUILDCOMBAT_STANDS_NOTUSESKILL ) );	//" :    " );

  0006a	68 a2 0b 00 00	 push	 2978			; 00000ba2H
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00074	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  00079	50		 push	 eax
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
$L274342:
  00081	5b		 pop	 ebx

; 321  : 			return FALSE;

  00082	33 c0		 xor	 eax, eax
  00084	5e		 pop	 esi

; 1090 : }

  00085	83 c4 24	 add	 esp, 36			; 00000024H
  00088	c2 18 00	 ret	 24			; 00000018H
$L274341:

; 322  : 		}
; 323  : 	}
; 324  : #endif //defined(__WORLDSERVER)
; 325  : 
; 326  : 	if( IsMode( NO_ATTACK_MODE ) ) return FALSE;

  0008b	f6 86 44 02 00
	00 40		 test	 BYTE PTR [esi+580], 64	; 00000040H
  00092	75 ed		 jne	 SHORT $L274342

; 327  : 	
; 328  : 	ItemProp *pSkillProp = NULL;
; 329  : 	AddSkillProp *pAddSkillProp = NULL;
; 330  : 	GetSkillProp( &pSkillProp, &pAddSkillProp, dwSkill, nLevel, "DoUseSkill" );

  00094	8b 54 24 30	 mov	 edx, DWORD PTR _dwSkill$[esp+40]
  00098	8b 06		 mov	 eax, DWORD PTR [esi]
  0009a	55		 push	 ebp
  0009b	89 4c 24 0c	 mov	 DWORD PTR _pSkillProp$[esp+48], ecx
  0009f	89 4c 24 10	 mov	 DWORD PTR _pAddSkillProp$[esp+48], ecx
  000a3	8b 4c 24 38	 mov	 ecx, DWORD PTR _nLevel$[esp+44]
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@LLMCBIOI@DoUseSkill?$AA@
  000ac	51		 push	 ecx
  000ad	52		 push	 edx
  000ae	8d 4c 24 1c	 lea	 ecx, DWORD PTR _pAddSkillProp$[esp+60]
  000b2	51		 push	 ecx
  000b3	8d 54 24 1c	 lea	 edx, DWORD PTR _pSkillProp$[esp+64]
  000b7	52		 push	 edx
  000b8	8b ce		 mov	 ecx, esi
  000ba	ff 50 30	 call	 DWORD PTR [eax+48]

; 331  : 
; 332  : #ifdef __CLIENT
; 333  : 	//      
; 334  : 	DWORD dwWorldID(GetWorld()->GetID());
; 335  : 	if(dwWorldID >= WI_WORLD_GUILDWAR1TO1_0 && dwWorldID <= WI_WORLD_GUILDWAR1TO1_L)
; 336  : 	{
; 337  : 		if(pSkillProp->dwID == SI_MAG_MAG_BLINKPOOL)
; 338  : 		{
; 339  : 			g_WndMng.PutString(prj.GetText(TID_GAME_NEVERKILLSTOP), NULL, prj.GetTextColor(TID_GAME_NEVERKILLSTOP));
; 340  : 			return FALSE;
; 341  : 		}
; 342  : 	}
; 343  : #endif // __CLIENT
; 344  : 
; 345  : 	CMover* pTarget = prj.GetMover( idFocusObj );	//   .

  000bd	8b 44 24 3c	 mov	 eax, DWORD PTR _idFocusObj$[esp+44]
  000c1	50		 push	 eax
  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000c7	e8 00 00 00 00	 call	 ?GetMover@CProject@@QAEPAVCMover@@K@Z ; CProject::GetMover
  000cc	8b e8		 mov	 ebp, eax

; 346  : 	if( IsInvalidObj( pTarget ) )	

  000ce	55		 push	 ebp
  000cf	89 6c 24 18	 mov	 DWORD PTR _pTarget$[esp+52], ebp
  000d3	e8 00 00 00 00	 call	 ?IsInvalidObj@@YAHPAVCObj@@@Z ; IsInvalidObj
  000d8	83 c4 04	 add	 esp, 4
  000db	85 c0		 test	 eax, eax
  000dd	74 0b		 je	 SHORT $L274350
  000df	5d		 pop	 ebp
  000e0	5b		 pop	 ebx

; 347  : 		return FALSE;

  000e1	33 c0		 xor	 eax, eax
  000e3	5e		 pop	 esi

; 1090 : }

  000e4	83 c4 24	 add	 esp, 36			; 00000024H
  000e7	c2 18 00	 ret	 24			; 00000018H
$L274350:
  000ea	57		 push	 edi

; 348  : 
; 349  : 	if( pSkillProp->dwID == SI_ASS_HEAL_HEALING )	//    

  000eb	8b 7c 24 10	 mov	 edi, DWORD PTR _pSkillProp$[esp+52]
  000ef	83 3f 2c	 cmp	 DWORD PTR [edi], 44	; 0000002cH
  000f2	75 0f		 jne	 SHORT $L274352

; 350  : 	{
; 351  : 		if( pTarget->IsDie() )

  000f4	8b cd		 mov	 ecx, ebp
  000f6	e8 00 00 00 00	 call	 ?IsDie@CMover@@QAEHXZ	; CMover::IsDie
  000fb	85 c0		 test	 eax, eax

; 352  : 			return FALSE;

  000fd	0f 85 a6 00 00
	00		 jne	 $L284347
$L274352:

; 353  : 	}
; 354  : 
; 355  : #ifdef __WORLDSERVER
; 356  : #ifdef __PK_PVP_SKILL_REGION
; 357  : 	if( pSkillProp->nEvildoing < 0 )	//PK     PVP  ..

  00103	8b 87 34 02 00
	00		 mov	 eax, DWORD PTR [edi+564]
  00109	85 c0		 test	 eax, eax
  0010b	0f 8d a4 00 00
	00		 jge	 $L274358

; 358  : 	{
; 359  : 		int nAttackerPK, nDefenderPK;
; 360  : 		nAttackerPK = nDefenderPK = 0;
; 361  : 		if( IsPlayer() && pTarget->IsPlayer() && (this != pTarget) ) //(this!=pTarget) -     .

  00111	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00117	85 c0		 test	 eax, eax
  00119	0f 84 96 00 00
	00		 je	 $L274358
  0011f	8b 4c 24 18	 mov	 ecx, DWORD PTR _pTarget$[esp+52]
  00123	8b 81 34 02 00
	00		 mov	 eax, DWORD PTR [ecx+564]
  00129	85 c0		 test	 eax, eax
  0012b	0f 84 84 00 00
	00		 je	 $L274358
  00131	8b c1		 mov	 eax, ecx
  00133	3b f0		 cmp	 esi, eax
  00135	74 7e		 je	 SHORT $L274358

; 362  : 		{
; 363  : 			DWORD dwRegionAttr	= GetPKPVPRegionAttr();

  00137	8b ce		 mov	 ecx, esi
  00139	e8 00 00 00 00	 call	 ?GetPKPVPRegionAttr@CMover@@QAEKXZ ; CMover::GetPKPVPRegionAttr
  0013e	8b f8		 mov	 edi, eax

; 364  : 			nAttackerPK = IsPKPVPInspectionBase( dwRegionAttr, FALSE );

  00140	6a 00		 push	 0
  00142	57		 push	 edi
  00143	8b ce		 mov	 ecx, esi
  00145	e8 00 00 00 00	 call	 ?IsPKPVPInspectionBase@CMover@@QAEHKH@Z ; CMover::IsPKPVPInspectionBase

; 365  : 			nDefenderPK = pTarget->IsPKPVPInspectionBase( dwRegionAttr, FALSE );

  0014a	8b 4c 24 18	 mov	 ecx, DWORD PTR _pTarget$[esp+52]
  0014e	6a 00		 push	 0
  00150	57		 push	 edi
  00151	8b e8		 mov	 ebp, eax
  00153	e8 00 00 00 00	 call	 ?IsPKPVPInspectionBase@CMover@@QAEHKH@Z ; CMover::IsPKPVPInspectionBase

; 366  : 			if( (nAttackerPK == 1 || nDefenderPK == 1) &&
; 367  : 				!( 
; 368  : 						IsPVPTarget( pTarget )
; 369  : 					|| IsWarTarget( pTarget )
; 370  : 					|| IsGuildCombatTarget( pTarget ) 
; 371  : #ifdef __JEFF_11_4
; 372  : 					|| IsArenaTarget( pTarget )
; 373  : #endif	// __JEFF_11_4
; 374  : 				) )

  00158	83 fd 01	 cmp	 ebp, 1
  0015b	74 05		 je	 SHORT $L274359
  0015d	83 f8 01	 cmp	 eax, 1
  00160	75 53		 jne	 SHORT $L274358
$L274359:
  00162	8b 7c 24 18	 mov	 edi, DWORD PTR _pTarget$[esp+52]
  00166	57		 push	 edi
  00167	8b ce		 mov	 ecx, esi
  00169	e8 00 00 00 00	 call	 ?IsPVPTarget@CMover@@QAEHPAV1@@Z ; CMover::IsPVPTarget
  0016e	85 c0		 test	 eax, eax
  00170	75 43		 jne	 SHORT $L274358
  00172	57		 push	 edi
  00173	8b ce		 mov	 ecx, esi
  00175	e8 00 00 00 00	 call	 ?IsWarTarget@CMover@@QAEHPAV1@@Z ; CMover::IsWarTarget
  0017a	85 c0		 test	 eax, eax
  0017c	75 37		 jne	 SHORT $L274358
  0017e	57		 push	 edi
  0017f	8b ce		 mov	 ecx, esi
  00181	e8 00 00 00 00	 call	 ?IsGuildCombatTarget@CMover@@QAEHPAV1@@Z ; CMover::IsGuildCombatTarget
  00186	85 c0		 test	 eax, eax
  00188	75 2b		 jne	 SHORT $L274358
  0018a	57		 push	 edi
  0018b	8b ce		 mov	 ecx, esi
  0018d	e8 00 00 00 00	 call	 ?IsArenaTarget@CMover@@QAEHPAV1@@Z ; CMover::IsArenaTarget
  00192	85 c0		 test	 eax, eax
  00194	75 1f		 jne	 SHORT $L274358

; 375  : 			{
; 376  : 				((CUser*)this)->AddDefinedText( TID_GMAE_PK_NOT_AREA, "" );

  00196	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0019b	68 42 0c 00 00	 push	 3138			; 00000c42H
  001a0	56		 push	 esi
  001a1	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L284347:
  001a9	5f		 pop	 edi
  001aa	5d		 pop	 ebp
  001ab	5b		 pop	 ebx

; 377  : 				return FALSE;

  001ac	33 c0		 xor	 eax, eax
  001ae	5e		 pop	 esi

; 1090 : }

  001af	83 c4 24	 add	 esp, 36			; 00000024H
  001b2	c2 18 00	 ret	 24			; 00000018H
$L274358:

; 378  : 			}
; 379  : 		}
; 380  : 	}
; 381  : #endif // __PK_PVP_SKILL_REGION
; 382  : 	if( HasBuff( BUFF_SKILL, SI_BLD_SUP_BERSERK ) )		//     .

  001b5	68 8f 00 00 00	 push	 143			; 0000008fH
  001ba	bd 01 00 00 00	 mov	 ebp, 1
  001bf	55		 push	 ebp
  001c0	8b ce		 mov	 ecx, esi
  001c2	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001c7	85 c0		 test	 eax, eax

; 383  : 		return FALSE;

  001c9	75 de		 jne	 SHORT $L284347

; 384  : 
; 385  : #ifdef __NPC_BUFF
; 386  : 	if( ( pSkillProp->dwID == SI_ASS_CHEER_QUICKSTEP && pTarget->HasBuff(BUFF_SKILL, SI_GEN_EVE_QUICKSTEP) )
; 387  : 		|| ( pSkillProp->dwID == SI_ASS_CHEER_HASTE && pTarget->HasBuff(BUFF_SKILL, SI_GEN_EVE_HASTE) )
; 388  : 		|| ( pSkillProp->dwID == SI_ASS_CHEER_HEAPUP && pTarget->HasBuff(BUFF_SKILL, SI_GEN_EVE_HEAPUP) )
; 389  : 		|| ( pSkillProp->dwID == SI_ASS_CHEER_ACCURACY && pTarget->HasBuff(BUFF_SKILL, SI_GEN_EVE_ACCURACY) ) )

  001cb	8b 54 24 10	 mov	 edx, DWORD PTR _pSkillProp$[esp+52]
  001cf	83 3a 72	 cmp	 DWORD PTR [edx], 114	; 00000072H
  001d2	8b 7c 24 18	 mov	 edi, DWORD PTR _pTarget$[esp+52]
  001d6	75 11		 jne	 SHORT $L274364
  001d8	68 3d 01 00 00	 push	 317			; 0000013dH
  001dd	55		 push	 ebp
  001de	8b cf		 mov	 ecx, edi
  001e0	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001e5	85 c0		 test	 eax, eax
  001e7	75 4e		 jne	 SHORT $L274363
$L274364:
  001e9	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  001ed	83 38 14	 cmp	 DWORD PTR [eax], 20	; 00000014H
  001f0	75 11		 jne	 SHORT $L274365
  001f2	68 3e 01 00 00	 push	 318			; 0000013eH
  001f7	55		 push	 ebp
  001f8	8b cf		 mov	 ecx, edi
  001fa	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001ff	85 c0		 test	 eax, eax
  00201	75 34		 jne	 SHORT $L274363
$L274365:
  00203	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  00207	83 39 31	 cmp	 DWORD PTR [ecx], 49	; 00000031H
  0020a	75 11		 jne	 SHORT $L274366
  0020c	68 3f 01 00 00	 push	 319			; 0000013fH
  00211	55		 push	 ebp
  00212	8b cf		 mov	 ecx, edi
  00214	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00219	85 c0		 test	 eax, eax
  0021b	75 1a		 jne	 SHORT $L274363
$L274366:
  0021d	8b 54 24 10	 mov	 edx, DWORD PTR _pSkillProp$[esp+52]
  00221	83 3a 74	 cmp	 DWORD PTR [edx], 116	; 00000074H
  00224	75 42		 jne	 SHORT $L284323
  00226	68 40 01 00 00	 push	 320			; 00000140H
  0022b	55		 push	 ebp
  0022c	8b cf		 mov	 ecx, edi
  0022e	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00233	85 c0		 test	 eax, eax
  00235	74 31		 je	 SHORT $L284323
$L274363:

; 390  : 	{
; 391  : 		if( pTarget->IsPlayer() )

  00237	8b 87 34 02 00
	00		 mov	 eax, DWORD PTR [edi+564]
  0023d	85 c0		 test	 eax, eax
  0023f	74 1b		 je	 SHORT $L274367

; 392  : 			((CUser*)pTarget)->AddDefinedText( TID_GAME_NPCBUFF_FAILED, "\"%s\"", pSkillProp->szName );

  00241	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  00245	83 c0 04	 add	 eax, 4
  00248	50		 push	 eax
  00249	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  0024e	68 ac 0d 00 00	 push	 3500			; 00000dacH
  00253	57		 push	 edi
  00254	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00259	83 c4 10	 add	 esp, 16			; 00000010H
$L274367:
  0025c	5f		 pop	 edi
  0025d	5d		 pop	 ebp
  0025e	5b		 pop	 ebx

; 393  : 		return FALSE;

  0025f	33 c0		 xor	 eax, eax
  00261	5e		 pop	 esi

; 1090 : }

  00262	83 c4 24	 add	 esp, 36			; 00000024H
  00265	c2 18 00	 ret	 24			; 00000018H
$L284323:

; 394  : 	}
; 395  : #endif // __NPC_BUFF
; 396  : 
; 397  : 	if( pSkillProp->dwID == SI_ACR_YOYO_SNITCH || pSkillProp->dwID == SI_JST_YOYO_VATALSTAB )	// ,    .

  00268	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  0026c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0026e	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  00273	74 07		 je	 SHORT $L274371
  00275	3d d6 00 00 00	 cmp	 eax, 214		; 000000d6H
  0027a	75 3e		 jne	 SHORT $L284324
$L274371:

; 398  : 	{
; 399  : 		if( !HasBuff( BUFF_SKILL, SI_ACR_SUP_DARKILLUSION ) )		//    

  0027c	68 c1 00 00 00	 push	 193			; 000000c1H
  00281	55		 push	 ebp
  00282	8b ce		 mov	 ecx, esi
  00284	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00289	85 c0		 test	 eax, eax
  0028b	75 2d		 jne	 SHORT $L284324

; 400  : 		{
; 401  : 			if( IsPlayer() )

  0028d	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00293	85 c0		 test	 eax, eax
  00295	0f 84 0e ff ff
	ff		 je	 $L284347

; 402  : 				((CUser*)this)->AddDefinedText( TID_GAME_REQ_DARK, "" );		//  .

  0029b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  002a0	68 a9 09 00 00	 push	 2473			; 000009a9H
  002a5	56		 push	 esi
  002a6	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  002ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ae	5f		 pop	 edi
  002af	5d		 pop	 ebp
  002b0	5b		 pop	 ebx

; 403  : 			return FALSE;

  002b1	33 c0		 xor	 eax, eax
  002b3	5e		 pop	 esi

; 1090 : }

  002b4	83 c4 24	 add	 esp, 36			; 00000024H
  002b7	c2 18 00	 ret	 24			; 00000018H
$L284324:

; 404  : 		}
; 405  : 	}
; 406  : 
; 407  : #if __VER >= 13 // __RAINBOW_RACE
; 408  : 	if( pSkillProp->dwID == SI_RIG_HERO_RETURN
; 409  : 		&& IsPlayer() && CRainbowRaceMng::GetInstance()->IsEntry( ((CUser*)this)->m_idPlayer ) )

  002ba	8b 54 24 10	 mov	 edx, DWORD PTR _pSkillProp$[esp+52]
  002be	81 3a f4 00 00
	00		 cmp	 DWORD PTR [edx], 244	; 000000f4H
  002c4	75 39		 jne	 SHORT $L284336
  002c6	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  002cc	85 c0		 test	 eax, eax
  002ce	74 2f		 je	 SHORT $L284336
  002d0	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  002d6	50		 push	 eax
  002d7	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  002dc	8b c8		 mov	 ecx, eax
  002de	e8 00 00 00 00	 call	 ?IsEntry@CRainbowRaceMng@@QAEHK@Z ; CRainbowRaceMng::IsEntry
  002e3	85 c0		 test	 eax, eax
  002e5	74 18		 je	 SHORT $L284336

; 410  : 	{
; 411  : 		((CUser*)this)->AddDefinedText( TID_GAME_RAINBOWRACE_NOTELEPORT );

  002e7	68 c1 0f 00 00	 push	 4033			; 00000fc1H
  002ec	8b ce		 mov	 ecx, esi
  002ee	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  002f3	5f		 pop	 edi
  002f4	5d		 pop	 ebp
  002f5	5b		 pop	 ebx

; 412  : 		return FALSE;

  002f6	33 c0		 xor	 eax, eax
  002f8	5e		 pop	 esi

; 1090 : }

  002f9	83 c4 24	 add	 esp, 36			; 00000024H
  002fc	c2 18 00	 ret	 24			; 00000018H
$L284336:

; 413  : 	}
; 414  : #endif // __RAINBOW_RACE
; 415  : #endif //defined(__WORLDSERVER)
; 416  : 
; 417  : 	MoverProp *pMoverProp = pTarget->GetProp();

  002ff	8b cf		 mov	 ecx, edi
  00301	e8 00 00 00 00	 call	 ?GetPropA@CMover@@QAEPAUMoverProp@@XZ ; CMover::GetPropA

; 418  : 	if( pMoverProp == NULL )

  00306	85 c0		 test	 eax, eax
  00308	75 1b		 jne	 SHORT $L274379

; 419  : 		Error( "DoUseSkill : %s ,  %s   ", m_szName, pTarget->m_szName );

  0030a	8d 8f 90 16 00
	00		 lea	 ecx, DWORD PTR [edi+5776]
  00310	51		 push	 ecx
  00311	8d 96 90 16 00
	00		 lea	 edx, DWORD PTR [esi+5776]
  00317	52		 push	 edx
  00318	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@EEBJCALL@DoUseSkill?5?3?5?$CFs?5?0?5?E?$LI?$LA?Y?5?$CFs?5?$MA?G?5?G?A?$LH@
  0031d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00322	83 c4 0c	 add	 esp, 12			; 0000000cH
$L274379:

; 420  : 	
; 421  : 	if( pTarget != this )	//     .

  00325	3b fe		 cmp	 edi, esi
  00327	0f 84 e2 00 00
	00		 je	 $L274381

; 422  : 	{
; 423  : 	#ifdef __WORLDSERVER
; 424  : 		if( pSkillProp->dwUseChance == WUI_NOW )	//  -  

  0032d	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  00331	39 a8 f8 01 00
	00		 cmp	 DWORD PTR [eax+504], ebp

; 425  : 			return FALSE;

  00337	0f 84 6c fe ff
	ff		 je	 $L284347

; 426  : 		if( pSkillProp->dwExeTarget == EXT_SELFCHGPARAMET )

  0033d	39 a8 f4 01 00
	00		 cmp	 DWORD PTR [eax+500], ebp

; 427  : 			return FALSE;

  00343	0f 84 60 fe ff
	ff		 je	 $L284347

; 428  : 
; 429  : 		if( pTarget->IsNPC() && pTarget->IsPeaceful() )	

  00349	8b 87 34 02 00
	00		 mov	 eax, DWORD PTR [edi+564]
  0034f	85 c0		 test	 eax, eax
  00351	75 0c		 jne	 SHORT $L274384
  00353	39 af 6c 06 00
	00		 cmp	 DWORD PTR [edi+1644], ebp

; 430  : 			return FALSE;	// NPC ?NPC   

  00359	0f 84 4a fe ff
	ff		 je	 $L284347
$L274384:

; 431  : 		
; 432  : 		if( !g_eLocal.GetState( EVE_STEAL ) )

  0035f	6a 0d		 push	 13			; 0000000dH
  00361	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00366	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  0036b	84 c0		 test	 al, al
  0036d	75 1e		 jne	 SHORT $L284325

; 433  : 		{
; 434  : 			if( pSkillProp->nEvildoing < 0 )	//  

  0036f	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  00373	8b 88 34 02 00
	00		 mov	 ecx, DWORD PTR [eax+564]
  00379	85 c9		 test	 ecx, ecx
  0037b	7d 10		 jge	 SHORT $L284325

; 435  : 				if( IsSteal( pTarget ) )	// pTarget   

  0037d	57		 push	 edi
  0037e	8b ce		 mov	 ecx, esi
  00380	e8 00 00 00 00	 call	 ?IsSteal@CMover@@QAEHPAV1@@Z ; CMover::IsSteal
  00385	85 c0		 test	 eax, eax

; 436  : 					return FALSE;

  00387	0f 85 1c fe ff
	ff		 jne	 $L284347
$L284325:

; 437  : 		}
; 438  : #ifdef __JEFF_11_4
; 439  : 		if(  pWorld && pWorld->IsArena() == FALSE )		//  ,

  0038d	85 db		 test	 ebx, ebx
  0038f	74 51		 je	 SHORT $L274391
  00391	81 3b d0 00 00
	00		 cmp	 DWORD PTR [ebx], 208	; 000000d0H
  00397	74 49		 je	 SHORT $L274391

; 440  : #endif	// __JEFF_11_4
; 441  : 		{
; 442  : 			if( pSkillProp->nEvildoing > 0 )	//  

  00399	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  0039d	8b 81 34 02 00
	00		 mov	 eax, DWORD PTR [ecx+564]
  003a3	85 c0		 test	 eax, eax
  003a5	7e 3b		 jle	 SHORT $L274391

; 443  : 			{
; 444  : 				HITTYPE hy;
; 445  : #if __VER >= 8 // __S8_PK
; 446  : 				if( (hy = GetHitType2( pTarget, TRUE, TRUE)) != HITTYPE_FAIL )  	//   

  003a7	55		 push	 ebp
  003a8	55		 push	 ebp
  003a9	57		 push	 edi
  003aa	8b ce		 mov	 ecx, esi
  003ac	e8 00 00 00 00	 call	 ?GetHitType2@CMover@@QAE?AW4HITTYPE@@PAV1@HH@Z ; CMover::GetHitType2
  003b1	85 c0		 test	 eax, eax
  003b3	74 2d		 je	 SHORT $L274391

; 447  : #else // __VER >= 8 // __S8_PK
; 448  : 				if( (hy = GetHitType2( pTarget, TRUE)) != HITTYPE_FAIL )  	//   
; 449  : #endif // __VER >= 8 // __S8_PK
; 450  : 				{
; 451  : 					if( IsPlayer() )

  003b5	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  003bb	85 c0		 test	 eax, eax
  003bd	0f 84 e6 fd ff
	ff		 je	 $L284347

; 452  : 						((CUser*)this)->AddDefinedText( TID_GAME_NEVERKILLSTOP, "" );		//    .

  003c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  003c8	68 aa 09 00 00	 push	 2474			; 000009aaH
  003cd	56		 push	 esi
  003ce	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  003d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d6	5f		 pop	 edi
  003d7	5d		 pop	 ebp
  003d8	5b		 pop	 ebx

; 453  : 					return FALSE;		//  

  003d9	33 c0		 xor	 eax, eax
  003db	5e		 pop	 esi

; 1090 : }

  003dc	83 c4 24	 add	 esp, 36			; 00000024H
  003df	c2 18 00	 ret	 24			; 00000018H
$L274391:

; 454  : 				}
; 455  : 			}
; 456  : 		}
; 457  : 		
; 458  : 	#endif
; 459  : 		SetAngle( GetDegree(pTarget->GetPos(), GetPos()) );		//   .

  003e2	8d 54 24 1c	 lea	 edx, DWORD PTR $T284141[esp+52]
  003e6	52		 push	 edx
  003e7	8b ce		 mov	 ecx, esi
  003e9	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  003ee	50		 push	 eax
  003ef	8d 44 24 2c	 lea	 eax, DWORD PTR $T284142[esp+56]
  003f3	50		 push	 eax
  003f4	8b cf		 mov	 ecx, edi
  003f6	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?GetDegree@@YAMABUD3DXVECTOR3@@0@Z ; GetDegree
  00401	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  00405	83 c4 04	 add	 esp, 4
  00408	8b ce		 mov	 ecx, esi
  0040a	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle
$L274381:

; 460  : 	}
; 461  : 	
; 462  : 	//   
; 463  : 	if( GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  0040f	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00415	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH
  0041b	75 2c		 jne	 SHORT $L274400

; 464  : 	{
; 465  : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 466  : 		if( pSkillProp->dwID == SI_MAG_MAG_BLINKPOOL || pSkillProp->dwID == SI_RIG_HERO_RETURN )

  0041d	8b 54 24 10	 mov	 edx, DWORD PTR _pSkillProp$[esp+52]
  00421	8b 02		 mov	 eax, DWORD PTR [edx]
  00423	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  00426	0f 84 7d fd ff
	ff		 je	 $L284347
  0042c	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H
  00431	0f 84 72 fd ff
	ff		 je	 $L284347

; 467  : #else //__LEGEND	//	10 	Neuz, World, Trans
; 468  : 		if( pSkillProp->dwID == SI_MAG_MAG_BLINKPOOL )
; 469  : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 470  : 			return FALSE;
; 471  : 
; 472  : 		if( g_GuildCombatMng.m_nState != CGuildCombat::WAR_STATE )

  00437	83 3d 40 11 00
	00 02		 cmp	 DWORD PTR ?g_GuildCombatMng@@3VCGuildCombat@@A+4416, 2
  0043e	74 09		 je	 SHORT $L274400

; 473  : 		{
; 474  : 			if( pSkillProp->dwID == SI_ASS_HEAL_RESURRECTION )

  00440	83 f8 2d	 cmp	 eax, 45			; 0000002dH

; 475  : 				return FALSE;

  00443	0f 84 13 fe ff
	ff		 je	 $L274367
$L274400:

; 476  : 		}
; 477  : 	}
; 478  : 
; 479  : #ifdef __WORLDSERVER
; 480  : 
; 481  : /*
; 482  : ---- 2008.03.25   
; 483  : 	#if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 484  : 	if( pSkillProp->dwID == SI_KNT_HERO_DRAWING )
; 485  : 	{
; 486  : 		CParty* pParty	= g_PartyMng.GetParty( ((CUser*)this)->m_idparty );
; 487  : 		if( pParty )
; 488  : 			pParty->DoUsePartyReCall( ((CUser*)this)->m_idparty, ((CUser*)this)->m_idPlayer, 0);
; 489  : 	}
; 490  : 	#endif	//__LEGEND	//	10 	Neuz, World, Trans
; 491  : ---- 2008.03.25   
; 492  : */
; 493  : 	if( g_eLocal.GetState( EVE_SCHOOL ) )

  00449	6a 04		 push	 4
  0044b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00450	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00455	84 c0		 test	 al, al
  00457	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  0045b	74 09		 je	 SHORT $L274402

; 494  : 	{
; 495  : 		if( pSkillProp->dwID == SI_ASS_HEAL_RESURRECTION )

  0045d	83 38 2d	 cmp	 DWORD PTR [eax], 45	; 0000002dH

; 496  : 			return FALSE;

  00460	0f 84 43 fd ff
	ff		 je	 $L284347
$L274402:

; 497  : 	}
; 498  : 
; 499  : 	//       
; 500  : 	ItemProp* pItemProp = NULL;
; 501  : 	DWORD	dwItemKind3;
; 502  : 
; 503  : 	if( pSkillProp->dwLinkKind == IK3_SHIELD || pSkillProp->dwLinkKind == IK3_MAGICBARUNA || pSkillProp->dwLinkKind == IK3_ZEMBARUNA )	//  

  00466	8b 80 e0 00 00
	00		 mov	 eax, DWORD PTR [eax+224]
  0046c	33 ed		 xor	 ebp, ebp
  0046e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00471	74 1e		 je	 SHORT $L274406
  00473	3d 96 00 00 00	 cmp	 eax, 150		; 00000096H
  00478	74 17		 je	 SHORT $L274406
  0047a	3d 97 00 00 00	 cmp	 eax, 151		; 00000097H
  0047f	74 10		 je	 SHORT $L274406

; 512  : 	}
; 513  : 	else	//     ...
; 514  : 	{
; 515  : 		pItemProp = GetActiveHandItemProp();

  00481	6a 0a		 push	 10			; 0000000aH
  00483	8b ce		 mov	 ecx, esi
  00485	e8 00 00 00 00	 call	 ?GetActiveHandItemProp@CMover@@QAEPAUItemProp@@H@Z ; CMover::GetActiveHandItemProp
  0048a	8b e8		 mov	 ebp, eax

; 516  : 		dwItemKind3 = pItemProp->dwItemKind3;

  0048c	8b 45 78	 mov	 eax, DWORD PTR [ebp+120]
  0048f	eb 1e		 jmp	 SHORT $L274409
$L274406:

; 504  : 	{
; 505  : 		CItemElem *pItemElem = GetEquipItem( PARTS_SHIELD );

  00491	6a 0b		 push	 11			; 0000000bH
  00493	8b ce		 mov	 ecx, esi
  00495	e8 00 00 00 00	 call	 ?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetEquipItem

; 506  : 		if( pItemElem )

  0049a	85 c0		 test	 eax, eax
  0049c	74 0e		 je	 SHORT $L274408

; 507  : 		{
; 508  : 			pItemProp = pItemElem->GetProp();

  0049e	8b c8		 mov	 ecx, eax
  004a0	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  004a5	8b e8		 mov	 ebp, eax

; 509  : 			dwItemKind3 = pItemProp->dwItemKind3;

  004a7	8b 45 78	 mov	 eax, DWORD PTR [ebp+120]

; 510  : 		} else

  004aa	eb 03		 jmp	 SHORT $L274409
$L274408:

; 511  : 			dwItemKind3 = NULL_ID;

  004ac	83 c8 ff	 or	 eax, -1
$L274409:

; 517  : 	}
; 518  : 	
; 519  : 	switch( pSkillProp->dwLinkKind )	//   .

  004af	8b 7c 24 10	 mov	 edi, DWORD PTR _pSkillProp$[esp+52]
  004b3	8b 8f e0 00 00
	00		 mov	 ecx, DWORD PTR [edi+224]
  004b9	8d 51 f4	 lea	 edx, DWORD PTR [ecx-12]
  004bc	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  004bf	0f 87 fa 00 00
	00		 ja	 $L274441
  004c5	0f b6 92 00 00
	00 00		 movzx	 edx, BYTE PTR $L284322[edx]
  004cc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L284355[edx*4]
$L274415:

; 520  : 	{
; 521  : 	case IK3_ENCHANTWEAPON:
; 522  : 		{
; 523  : 			if( IsPlayer() )

  004d3	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  004d9	85 c0		 test	 eax, eax
  004db	0f 84 18 01 00
	00		 je	 $L284337

; 524  : 			{
; 525  : 				BOOL bFail = FALSE;
; 526  : 
; 527  : 				CItemElem *pItemElemR = GetWeaponItem();

  004e1	6a 0a		 push	 10			; 0000000aH
  004e3	8b ce		 mov	 ecx, esi
  004e5	e8 00 00 00 00	 call	 ?GetWeaponItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetWeaponItem

; 528  : 				CItemElem *pItemElemL = GetLWeaponItem();

  004ea	8b ce		 mov	 ecx, esi
  004ec	8b f8		 mov	 edi, eax
  004ee	e8 00 00 00 00	 call	 ?GetLWeaponItem@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetLWeaponItem

; 529  : 
; 530  : 				if( pItemElemR && pItemElemL )	//  .

  004f3	85 ff		 test	 edi, edi
  004f5	74 26		 je	 SHORT $L284317
  004f7	85 c0		 test	 eax, eax
  004f9	74 18		 je	 SHORT $L274420

; 531  : 				{	//   
; 532  : 					if( (pItemElemR && pItemElemR->m_bItemResist == SAI79::NO_PROP) &&		
; 533  : 						(pItemElemL && pItemElemL->m_bItemResist == SAI79::NO_PROP) )

  004fb	8a 8f 88 00 00
	00		 mov	 cl, BYTE PTR [edi+136]
  00501	84 c9		 test	 cl, cl
  00503	0f 85 ec 00 00
	00		 jne	 $L284326
  00509	8a 88 88 00 00
	00		 mov	 cl, BYTE PTR [eax+136]
  0050f	84 c9		 test	 cl, cl

; 534  : 						bFail = TRUE;		// 
; 535  : 				} 
; 536  : 				else if( pItemElemR && pItemElemL == NULL )	//   .

  00511	eb 0c		 jmp	 SHORT $L284344
$L274420:

; 537  : 				{
; 538  : 					if( pItemElemR && pItemElemR->m_bItemResist == SAI79::NO_PROP )		//   

  00513	8a 87 88 00 00
	00		 mov	 al, BYTE PTR [edi+136]
  00519	84 c0		 test	 al, al

; 539  : 						bFail = TRUE;		// 
; 540  : 				} 
; 541  : 				else if( pItemElemR == NULL && pItemElemL == NULL )	//  

  0051b	eb 02		 jmp	 SHORT $L284344
$L284317:
  0051d	85 c0		 test	 eax, eax
$L284344:
  0051f	0f 85 d0 00 00
	00		 jne	 $L284326

; 542  : 				{
; 543  : 					bFail = TRUE;		//   
; 544  : 				}
; 545  : 
; 546  : 				if( bFail )
; 547  : 				{
; 548  : 					( (CUser*)this )->AddDefinedText( TID_SKILL_NOTELEWEAPON, "" );	//   .

  00525	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0052a	68 c7 08 00 00	 push	 2247			; 000008c7H
  0052f	56		 push	 esi
  00530	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00535	83 c4 0c	 add	 esp, 12			; 0000000cH
  00538	5f		 pop	 edi
  00539	5d		 pop	 ebp
  0053a	5b		 pop	 ebx

; 549  : 					return FALSE;

  0053b	33 c0		 xor	 eax, eax
  0053d	5e		 pop	 esi

; 1090 : }

  0053e	83 c4 24	 add	 esp, 36			; 00000024H
  00541	c2 18 00	 ret	 24			; 00000018H
$L274429:

; 550  : 				}
; 551  : 			}
; 552  : 		}
; 553  : 		break;
; 554  : 	case IK3_MAGICBOTH:
; 555  : 		if( dwItemKind3 != IK3_WAND  && dwItemKind3 != IK3_STAFF )	//     

  00544	83 f8 06	 cmp	 eax, 6
  00547	0f 84 ac 00 00
	00		 je	 $L284337
  0054d	83 f8 07	 cmp	 eax, 7
  00550	0f 84 a3 00 00
	00		 je	 $L284337

; 556  : 		{
; 557  : 			if( IsPlayer() )

  00556	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0055c	85 c0		 test	 eax, eax
  0055e	0f 84 45 fc ff
	ff		 je	 $L284347
$L284348:

; 558  : 				( (CUser*)this )->AddDefinedText( TID_GAME_WRONGITEM, "" );

  00564	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00569	68 78 02 00 00	 push	 632			; 00000278H
$L284350:
  0056e	56		 push	 esi
  0056f	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00574	83 c4 0c	 add	 esp, 12			; 0000000cH
  00577	5f		 pop	 edi
  00578	5d		 pop	 ebp
  00579	5b		 pop	 ebx

; 559  : 			return FALSE;

  0057a	33 c0		 xor	 eax, eax
  0057c	5e		 pop	 esi

; 1090 : }

  0057d	83 c4 24	 add	 esp, 36			; 00000024H
  00580	c2 18 00	 ret	 24			; 00000018H
$L274433:

; 560  : 		}
; 561  : 		break;
; 562  : 	case IK3_YOBO:
; 563  : #ifdef __CROSSBOW
; 564  : 		if( dwItemKind3 != IK3_YOYO && dwItemKind3 != IK3_BOW && dwItemKind3 != IK3_CROSSBOW )	

  00583	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00586	74 71		 je	 SHORT $L284337
$L274437:
  00588	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0058b	74 6c		 je	 SHORT $L284337
  0058d	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00590	74 67		 je	 SHORT $L284337

; 565  : #else // __CROSSBOW
; 566  : 		if( dwItemKind3 != IK3_YOYO && dwItemKind3 != IK3_BOW )	
; 567  : #endif // __CROSSBOW
; 568  : 		{
; 569  : 			if( IsPlayer() )

  00592	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00598	85 c0		 test	 eax, eax
  0059a	0f 84 09 fc ff
	ff		 je	 $L284347

; 570  : 				( (CUser*)this )->AddDefinedText( TID_GAME_WRONGITEM, "" );

  005a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  005a5	68 78 02 00 00	 push	 632			; 00000278H
  005aa	56		 push	 esi
  005ab	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  005b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b3	5f		 pop	 edi
  005b4	5d		 pop	 ebp
  005b5	5b		 pop	 ebx

; 571  : 			return FALSE;

  005b6	33 c0		 xor	 eax, eax
  005b8	5e		 pop	 esi

; 1090 : }

  005b9	83 c4 24	 add	 esp, 36			; 00000024H
  005bc	c2 18 00	 ret	 24			; 00000018H
$L274441:

; 572  : 		}
; 573  : 		break;
; 574  : #ifdef __CROSSBOW
; 575  : 	case IK3_BOW:
; 576  : 		if( dwItemKind3 != IK3_BOW && dwItemKind3 != IK3_CROSSBOW )
; 577  : 		{
; 578  : 			if( IsPlayer() )
; 579  : 				( (CUser*)this )->AddDefinedText( TID_GAME_WRONGITEM, "" );
; 580  : 			return FALSE;
; 581  : 		}
; 582  : 		break;
; 583  : #endif // __CROSSBOW
; 584  : 	default:
; 585  : 		if( pSkillProp->dwLinkKind != NULL_ID && pSkillProp->dwLinkKind != dwItemKind3 )	//  IK3   .

  005bf	83 f9 ff	 cmp	 ecx, -1
  005c2	74 35		 je	 SHORT $L284337
  005c4	3b c8		 cmp	 ecx, eax
  005c6	74 31		 je	 SHORT $L284337

; 586  : 		{
; 587  : 			if( IsPlayer() )

  005c8	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  005ce	85 c0		 test	 eax, eax
  005d0	0f 84 d3 fb ff
	ff		 je	 $L284347

; 588  : 				( (CUser*)this )->AddDefinedText( TID_GAME_WRONGITEM, "" );

  005d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  005db	68 78 02 00 00	 push	 632			; 00000278H
  005e0	56		 push	 esi
  005e1	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  005e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  005e9	5f		 pop	 edi
  005ea	5d		 pop	 ebp
  005eb	5b		 pop	 ebx

; 589  : 			return FALSE;

  005ec	33 c0		 xor	 eax, eax
  005ee	5e		 pop	 esi

; 1090 : }

  005ef	83 c4 24	 add	 esp, 36			; 00000024H
  005f2	c2 18 00	 ret	 24			; 00000018H
$L284326:

; 589  : 			return FALSE;

  005f5	8b 7c 24 10	 mov	 edi, DWORD PTR _pSkillProp$[esp+52]
$L284337:

; 590  : 		}
; 591  : 		break;
; 592  : 	}
; 593  : 
; 594  : #if __VER >= 8 //__CSC_VER8_3 //          .
; 595  : 	if(pSkillProp->dwSkillType == BUFF_SKILL)

  005f9	8b 87 18 02 00
	00		 mov	 eax, DWORD PTR [edi+536]
  005ff	bb 01 00 00 00	 mov	 ebx, 1
  00604	3b c3		 cmp	 eax, ebx
  00606	75 5a		 jne	 SHORT $L274453

; 596  : 	{
; 597  : 		CMover* searchMover;
; 598  : 		if(pTarget == this)

  00608	8b 44 24 18	 mov	 eax, DWORD PTR _pTarget$[esp+52]
  0060c	3b c6		 cmp	 eax, esi
  0060e	75 02		 jne	 SHORT $L274448

; 599  : 			searchMover = this;

  00610	8b c6		 mov	 eax, esi
$L274448:

; 600  : 		else
; 601  : 			searchMover = pTarget;
; 602  : 
; 603  : #ifdef __BUFF_1107
; 604  : 		IBuff* pBuff	= searchMover->m_buffs.GetBuff( BUFF_SKILL, (WORD)( pSkillProp->dwID ) );

  00612	33 c9		 xor	 ecx, ecx
  00614	66 8b 0f	 mov	 cx, WORD PTR [edi]
  00617	51		 push	 ecx
  00618	53		 push	 ebx
  00619	8d 88 f0 02 00
	00		 lea	 ecx, DWORD PTR [eax+752]
  0061f	e8 00 00 00 00	 call	 ?GetBuff@CBuffMgr@@QAEPAVIBuff@@GG@Z ; CBuffMgr::GetBuff

; 605  : 		if( pBuff )

  00624	85 c0		 test	 eax, eax
  00626	74 36		 je	 SHORT $L284327

; 606  : 		{
; 607  : 			if( pBuff->GetLevel() > (DWORD)( nLevel ) )

  00628	8b 54 24 3c	 mov	 edx, DWORD PTR _nLevel$[esp+48]
  0062c	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  0062f	76 2d		 jbe	 SHORT $L284327

; 608  : #else	// __BUFF_1107
; 609  : 		SKILLINFLUENCE* hasSkill = searchMover->m_SkillState.Find( BUFF_SKILL, pSkillProp->dwID );
; 610  : 		if( hasSkill )
; 611  : 		{
; 612  : 			if( hasSkill->dwLevel > nLevel )
; 613  : #endif	// __BUFF_1107
; 614  : 			{
; 615  : 				if( IsPlayer() ) // 	// this CUser   .

  00631	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00637	85 c0		 test	 eax, eax
  00639	0f 84 6a fb ff
	ff		 je	 $L284347

; 616  : 					( (CUser*)this )->AddDefinedText( TID_GAME_DONOTUSEBUFF, "" );

  0063f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00644	68 3b 0c 00 00	 push	 3131			; 00000c3bH
  00649	56		 push	 esi
  0064a	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0064f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00652	5f		 pop	 edi
  00653	5d		 pop	 ebp
  00654	5b		 pop	 ebx

; 617  : 				return FALSE;

  00655	33 c0		 xor	 eax, eax
  00657	5e		 pop	 esi

; 1090 : }

  00658	83 c4 24	 add	 esp, 36			; 00000024H
  0065b	c2 18 00	 ret	 24			; 00000018H
$L284327:

; 617  : 				return FALSE;

  0065e	8b 7c 24 10	 mov	 edi, DWORD PTR _pSkillProp$[esp+52]
$L274453:

; 618  : 			}
; 619  : 		}
; 620  : 	}
; 621  : #endif //__CSC_VER8_3
; 622  : 
; 623  : 	//   .
; 624  : 	if( pSkillProp->dwHanded != NULL_ID )

  00662	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  00668	83 f8 ff	 cmp	 eax, -1
  0066b	74 2a		 je	 SHORT $L274463

; 625  : 	{
; 626  : 		if( pItemProp )

  0066d	85 ed		 test	 ebp, ebp
  0066f	74 26		 je	 SHORT $L274463

; 627  : 		{
; 628  : 			if( IsPlayer() )

  00671	8b 8e 34 02 00
	00		 mov	 ecx, DWORD PTR [esi+564]
  00677	85 c9		 test	 ecx, ecx
  00679	74 1c		 je	 SHORT $L274463

; 629  : 			{
; 630  : 				if( pSkillProp->dwHanded == HD_DUAL )		//  

  0067b	83 f8 03	 cmp	 eax, 3
  0067e	0f 85 af 00 00
	00		 jne	 $L274459

; 631  : 				{
; 632  : 					if( IsDualWeapon() == FALSE )			//   .

  00684	8b ce		 mov	 ecx, esi
  00686	e8 00 00 00 00	 call	 ?IsDualWeapon@CMover@@QAEHXZ ; CMover::IsDualWeapon
  0068b	85 c0		 test	 eax, eax
  0068d	0f 84 d1 fe ff
	ff		 je	 $L284348

; 639  : 				{
; 640  : 					((CUser*)this)->AddDefinedText( TID_GAME_WRONGITEM, "" );
; 641  : 					return FALSE;

  00693	8b 7c 24 10	 mov	 edi, DWORD PTR _pSkillProp$[esp+52]
$L274463:

; 642  : 				}
; 643  : 			}
; 644  : 		}
; 645  : 	}
; 646  : 
; 647  : 	//   
; 648  : 	if( IsBullet( pSkillProp ) == FALSE )

  00697	57		 push	 edi
  00698	8b ce		 mov	 ecx, esi
  0069a	e8 00 00 00 00	 call	 ?IsBullet@CMover@@QAEHPAUItemProp@@@Z ; CMover::IsBullet
  0069f	85 c0		 test	 eax, eax

; 649  : 		return FALSE;

  006a1	0f 84 02 fb ff
	ff		 je	 $L284347

; 650  : 
; 651  : 	if( IsPlayer() )

  006a7	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  006ad	85 c0		 test	 eax, eax
  006af	0f 84 37 01 00
	00		 je	 $L284330

; 652  : 	{
; 653  : #if __VER >= 10 // __LEGEND	//	9 	Neuz, World, Trans
; 654  : #ifdef __3RD_LEGEND16
; 655  : 		if( pSkillProp->dwReqDisLV != NULL_ID && GetLevel() < (int)( pSkillProp->dwReqDisLV )  && !IsMaster() && !IsHero() && !IsLegendHero() )

  006b5	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  006b9	8b 80 b0 01 00
	00		 mov	 eax, DWORD PTR [eax+432]
  006bf	83 f8 ff	 cmp	 eax, -1
  006c2	74 2d		 je	 SHORT $L284329
  006c4	39 86 e0 05 00
	00		 cmp	 DWORD PTR [esi+1504], eax
  006ca	7d 25		 jge	 SHORT $L284329
  006cc	8b ce		 mov	 ecx, esi
  006ce	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  006d3	85 c0		 test	 eax, eax
  006d5	75 1a		 jne	 SHORT $L284329
  006d7	8b ce		 mov	 ecx, esi
  006d9	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  006de	85 c0		 test	 eax, eax
  006e0	75 0f		 jne	 SHORT $L284329
  006e2	8b ce		 mov	 ecx, esi
  006e4	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  006e9	85 c0		 test	 eax, eax

; 656  : #else // __3RD_LEGEND16
; 657  : 		if( pSkillProp->dwReqDisLV != NULL_ID && GetLevel() < (int)( pSkillProp->dwReqDisLV )  && !IsMaster() && !IsHero() )
; 658  : #endif // __3RD_LEGEND16
; 659  : 			return FALSE;

  006eb	0f 84 b8 fa ff
	ff		 je	 $L284347
$L284329:

; 660  : #else //__LEGEND	//	9 	Neuz, World, Trans
; 661  : 		if( pSkillProp->dwReqDisLV != NULL_ID && GetLevel() < pSkillProp->dwReqDisLV )
; 662  : 			return FALSE;
; 663  : #endif	//__LEGEND	//	9 	Neuz, World, Trans
; 664  : 		
; 665  : 		if( pSkillProp->dwReSkill1 != 0xffffffff )

  006f1	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  006f5	8b 81 b4 01 00
	00		 mov	 eax, DWORD PTR [ecx+436]
  006fb	83 f8 ff	 cmp	 eax, -1
  006fe	74 77		 je	 SHORT $L284338

; 666  : 		{
; 667  : 			LPSKILL pSkillBuf = GetSkill( pSkillProp->dwReSkill1 );

  00700	50		 push	 eax
  00701	8b ce		 mov	 ecx, esi
  00703	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z ; CMover::GetSkill

; 668  : 			if( pSkillBuf )

  00708	85 c0		 test	 eax, eax
  0070a	74 38		 je	 SHORT $L274471

; 669  : 			{
; 670  : 				if( pSkillBuf->dwLevel < pSkillProp->dwReSkillLevel1 )

  0070c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0070f	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  00713	3b 90 b8 01 00
	00		 cmp	 edx, DWORD PTR [eax+440]
  00719	73 5c		 jae	 SHORT $L284338

; 671  : 				{
; 672  : 					( (CUser*)this )->AddText( "SkillLevel1 " );

  0071b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KNNGFFII@SkillLevel1?5?$AA@
  00720	8b ce		 mov	 ecx, esi
  00722	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  00727	5f		 pop	 edi
  00728	5d		 pop	 ebp
  00729	5b		 pop	 ebx
  0072a	33 c0		 xor	 eax, eax
  0072c	5e		 pop	 esi

; 1090 : }

  0072d	83 c4 24	 add	 esp, 36			; 00000024H
  00730	c2 18 00	 ret	 24			; 00000018H
$L274459:

; 633  : 					{
; 634  : 						((CUser*)this)->AddDefinedText( TID_GAME_WRONGITEM, "" );
; 635  : 						return FALSE;
; 636  : 					}
; 637  : 				} 
; 638  : 				else if( pItemProp->dwHanded != pSkillProp->dwHanded )	//     Handed   

  00733	39 85 a0 00 00
	00		 cmp	 DWORD PTR [ebp+160], eax
  00739	0f 84 58 ff ff
	ff		 je	 $L274463

; 639  : 				{
; 640  : 					((CUser*)this)->AddDefinedText( TID_GAME_WRONGITEM, "" );
; 641  : 					return FALSE;

  0073f	e9 20 fe ff ff	 jmp	 $L284348
$L274471:

; 673  : 					return FALSE;
; 674  : 				}
; 675  : 			}
; 676  : 			else
; 677  : 			{
; 678  : 				int nIdx = GetSkillIdx( dwSkill );

  00744	8b 4c 24 38	 mov	 ecx, DWORD PTR _dwSkill$[esp+48]
  00748	51		 push	 ecx
  00749	8b ce		 mov	 ecx, esi
  0074b	e8 00 00 00 00	 call	 ?GetSkillIdx@CMover@@QAEHK@Z ; CMover::GetSkillIdx

; 679  : 				Error( "DoUseSkill : %s NULL GetSkill %d = dwReSkill(%d, %d)", m_szName, nIdx, pSkillProp->dwReSkill1, pSkillProp->dwReSkill2 );

  00750	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  00754	8b 91 bc 01 00
	00		 mov	 edx, DWORD PTR [ecx+444]
  0075a	8b 89 b4 01 00
	00		 mov	 ecx, DWORD PTR [ecx+436]
  00760	52		 push	 edx
  00761	51		 push	 ecx
  00762	50		 push	 eax
  00763	8d 96 90 16 00
	00		 lea	 edx, DWORD PTR [esi+5776]
  00769	52		 push	 edx
  0076a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@KIFDAMPH@DoUseSkill?5?3?5?$CFs?5NULL?5GetSkill?5?$CFd@
  0076f	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00774	83 c4 14	 add	 esp, 20			; 00000014H
$L284338:

; 680  : 			}
; 681  : 		}
; 682  : 
; 683  : 		if( pSkillProp->dwReSkill2 != 0xffffffff )

  00777	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  0077b	8b 80 bc 01 00
	00		 mov	 eax, DWORD PTR [eax+444]
  00781	83 f8 ff	 cmp	 eax, -1
  00784	74 66		 je	 SHORT $L284330

; 684  : 		{
; 685  : 			LPSKILL pSkillBuf = GetSkill( pSkillProp->dwReSkill2 );

  00786	50		 push	 eax
  00787	8b ce		 mov	 ecx, esi
  00789	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z ; CMover::GetSkill

; 686  : 			if( pSkillBuf )

  0078e	85 c0		 test	 eax, eax
  00790	74 27		 je	 SHORT $L274480

; 687  : 			{
; 688  : 				if( pSkillBuf->dwLevel < pSkillProp->dwReSkillLevel2 )

  00792	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00795	8b 54 24 10	 mov	 edx, DWORD PTR _pSkillProp$[esp+52]
  00799	3b 8a c0 01 00
	00		 cmp	 ecx, DWORD PTR [edx+448]
  0079f	73 4b		 jae	 SHORT $L284330

; 689  : 				{
; 690  : 					( (CUser*)this )->AddText( "SkillLevel2 " );

  007a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KPJAOLNB@SkillLevel2?5?$AA@
  007a6	8b ce		 mov	 ecx, esi
  007a8	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
  007ad	5f		 pop	 edi
  007ae	5d		 pop	 ebp
  007af	5b		 pop	 ebx
  007b0	33 c0		 xor	 eax, eax
  007b2	5e		 pop	 esi

; 1090 : }

  007b3	83 c4 24	 add	 esp, 36			; 00000024H
  007b6	c2 18 00	 ret	 24			; 00000018H
$L274480:

; 691  : 					return FALSE;
; 692  : 				}				
; 693  : 			}
; 694  : 			else
; 695  : 			{
; 696  : 				int nIdx = GetSkillIdx( dwSkill );

  007b9	8b 44 24 38	 mov	 eax, DWORD PTR _dwSkill$[esp+48]
  007bd	50		 push	 eax
  007be	8b ce		 mov	 ecx, esi
  007c0	e8 00 00 00 00	 call	 ?GetSkillIdx@CMover@@QAEHK@Z ; CMover::GetSkillIdx

; 697  : 				Error( "DoUseSkill : %s NULL GetSkill %d = dwReSkill(%d, %d)", m_szName, nIdx, pSkillProp->dwReSkill1, pSkillProp->dwReSkill2 );

  007c5	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  007c9	8b 91 bc 01 00
	00		 mov	 edx, DWORD PTR [ecx+444]
  007cf	8b 89 b4 01 00
	00		 mov	 ecx, DWORD PTR [ecx+436]
  007d5	52		 push	 edx
  007d6	51		 push	 ecx
  007d7	50		 push	 eax
  007d8	8d 96 90 16 00
	00		 lea	 edx, DWORD PTR [esi+5776]
  007de	52		 push	 edx
  007df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@KIFDAMPH@DoUseSkill?5?3?5?$CFs?5NULL?5GetSkill?5?$CFd@
  007e4	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  007e9	83 c4 14	 add	 esp, 20			; 00000014H
$L284330:

; 698  : 			}
; 699  : 		}
; 700  : 	}
; 701  : 
; 702  : 	if( pSkillProp->dwID == SI_BIL_PST_ASALRAALAIKUM )	//   .

  007ec	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  007f0	81 38 9f 00 00
	00		 cmp	 DWORD PTR [eax], 159	; 0000009fH
  007f6	75 3e		 jne	 SHORT $L274487

; 703  : 	{
; 704  : 		//if( GetFatiguePoint() <= 0  )		// FP   . // chipi_090917 
; 705  : 		if( IsPlayer() && GetFatiguePoint() < GetReqFp( pAddSkillProp->nReqFp )  )		// chipi_090917  FP 

  007f8	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  007fe	85 c0		 test	 eax, eax
  00800	74 34		 je	 SHORT $L274487
  00802	8b 4c 24 14	 mov	 ecx, DWORD PTR _pAddSkillProp$[esp+52]
  00806	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00809	52		 push	 edx
  0080a	8b ce		 mov	 ecx, esi
  0080c	e8 00 00 00 00	 call	 ?GetReqFp@CMover@@QAEHH@Z ; CMover::GetReqFp
  00811	8b ce		 mov	 ecx, esi
  00813	8b f8		 mov	 edi, eax
  00815	e8 00 00 00 00	 call	 ?GetFatiguePoint@CMover@@QAEHXZ ; CMover::GetFatiguePoint
  0081a	3b c7		 cmp	 eax, edi
  0081c	7d 18		 jge	 SHORT $L274487

; 706  : 		{
; 707  : 			((CUser*)this)->AddDefinedText( TID_GAME_REQFP ); // chipi_00917

  0081e	68 67 02 00 00	 push	 615			; 00000267H
  00823	8b ce		 mov	 ecx, esi
  00825	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  0082a	5f		 pop	 edi
  0082b	5d		 pop	 ebp
  0082c	5b		 pop	 ebx
  0082d	33 c0		 xor	 eax, eax
  0082f	5e		 pop	 esi

; 1090 : }

  00830	83 c4 24	 add	 esp, 36			; 00000024H
  00833	c2 18 00	 ret	 24			; 00000018H
$L274487:

; 708  : 			return FALSE;
; 709  : 		}
; 710  : 	}
; 711  : 
; 712  : 	//  .
; 713  : 	{
; 714  : 		int nSkillIdx = GetSkillIdx( dwSkill );		//   .

  00836	8b 44 24 38	 mov	 eax, DWORD PTR _dwSkill$[esp+48]
  0083a	50		 push	 eax
  0083b	8b ce		 mov	 ecx, esi
  0083d	e8 00 00 00 00	 call	 ?GetSkillIdx@CMover@@QAEHK@Z ; CMover::GetSkillIdx

; 715  : 		if( nSkillIdx >= 0 )

  00842	85 c0		 test	 eax, eax
  00844	7c 29		 jl	 SHORT $L274491

; 716  : 		{
; 717  : 			if( GetReuseDelay( nSkillIdx ) )		//      .

  00846	50		 push	 eax
  00847	8b ce		 mov	 ecx, esi
  00849	e8 00 00 00 00	 call	 ?GetReuseDelay@CMover@@QAEKH@Z ; CMover::GetReuseDelay
  0084e	85 c0		 test	 eax, eax
  00850	74 1d		 je	 SHORT $L274491

; 718  : 			{
; 719  : 				if( IsPlayer() )

  00852	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00858	85 c0		 test	 eax, eax
  0085a	0f 84 49 f9 ff
	ff		 je	 $L284347

; 720  : 					((CUser*)this)->AddDefinedText( TID_GAME_SKILLWAITTIME, "" );	//    .

  00860	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00865	68 c4 03 00 00	 push	 964			; 000003c4H

; 721  : 				return FALSE;

  0086a	e9 ff fc ff ff	 jmp	 $L284350
$L274491:

; 722  : 			}
; 723  : 		}
; 724  : 	}
; 725  : #endif // __WORLDSERVER
; 726  : 		
; 727  : 
; 728  : 	SendActMsg( OBJMSG_STOP );

  0086f	6a 00		 push	 0
  00871	6a 00		 push	 0
  00873	6a 00		 push	 0
  00875	6a 00		 push	 0
  00877	6a 06		 push	 6
  00879	8b ce		 mov	 ecx, esi
  0087b	e8 00 00 00 00	 call	 ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z ; CMover::SendActMsg

; 729  : 	ClearDest();

  00880	8b ce		 mov	 ecx, esi
  00882	e8 00 00 00 00	 call	 ?ClearDest@CMover@@QAEXXZ ; CMover::ClearDest

; 730  : 
; 731  : 	OBJMSG dwMsg = OBJMSG_NONE;
; 732  : 	int nMotion = (int)pSkillProp->dwUseMotion;

  00887	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  0088b	8b a8 e8 01 00
	00		 mov	 ebp, DWORD PTR [eax+488]

; 733  : 	
; 734  : 	//---   ...
; 735  : 	if( pSkillProp->dwSkillType == KT_SKILL )

  00891	8b 80 18 02 00
	00		 mov	 eax, DWORD PTR [eax+536]
  00897	33 ff		 xor	 edi, edi
  00899	83 f8 02	 cmp	 eax, 2
  0089c	0f 85 b0 00 00
	00		 jne	 $L274497

; 736  : 	{
; 737  : 	#ifdef __WORLDSERVER
; 738  : 
; 739  : 		#if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 740  : 			if(GetReqFp( pAddSkillProp->nReqFp ) == 9999999)

  008a2	8b 4c 24 14	 mov	 ecx, DWORD PTR _pAddSkillProp$[esp+52]
  008a6	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  008a9	52		 push	 edx
  008aa	8b ce		 mov	 ecx, esi
  008ac	e8 00 00 00 00	 call	 ?GetReqFp@CMover@@QAEHH@Z ; CMover::GetReqFp
  008b1	3d 7f 96 98 00	 cmp	 eax, 9999999		; 0098967fH
  008b6	75 3e		 jne	 SHORT $L274498

; 741  : 			{
; 742  : 				if( GetManaPoint() != GetMaxManaPoint())

  008b8	8b ce		 mov	 ecx, esi
  008ba	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  008bf	8b ce		 mov	 ecx, esi
  008c1	8b f8		 mov	 edi, eax
  008c3	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint
  008c8	3b c7		 cmp	 eax, edi
  008ca	74 0b		 je	 SHORT $L274499

; 743  : 				{
; 744  : 					if( TRUE == IsPlayer() )

  008cc	39 9e 34 02 00
	00		 cmp	 DWORD PTR [esi+564], ebx

; 745  : 						( (CUser*)this )->AddDefinedText( TID_GAME_REQMP, "" );
; 746  : 					return FALSE;

  008d2	e9 12 01 00 00	 jmp	 $L284353
$L274499:

; 747  : 				}
; 748  : 				if( GetFatiguePoint() != GetMaxFatiguePoint())

  008d7	8b ce		 mov	 ecx, esi
  008d9	e8 00 00 00 00	 call	 ?GetFatiguePoint@CMover@@QAEHXZ ; CMover::GetFatiguePoint
  008de	8b ce		 mov	 ecx, esi
  008e0	8b f8		 mov	 edi, eax
  008e2	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  008e7	3b f8		 cmp	 edi, eax
  008e9	74 5d		 je	 SHORT $L274511

; 749  : 				{
; 750  : 					if( TRUE == IsPlayer() )

  008eb	39 9e 34 02 00
	00		 cmp	 DWORD PTR [esi+564], ebx

; 751  : 						( (CUser*)this )->AddDefinedText( TID_GAME_REQFP, "" );
; 752  : 					return FALSE;

  008f1	e9 bd 00 00 00	 jmp	 $L284354
$L274498:

; 753  : 				}
; 754  : 			}
; 755  : 			else
; 756  : 			{
; 757  : 				if( GetFatiguePoint() - GetReqFp( pAddSkillProp->nReqFp ) < 0 )	// FP  

  008f6	8b 44 24 14	 mov	 eax, DWORD PTR _pAddSkillProp$[esp+52]
  008fa	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  008fd	51		 push	 ecx
  008fe	8b ce		 mov	 ecx, esi
  00900	e8 00 00 00 00	 call	 ?GetReqFp@CMover@@QAEHH@Z ; CMover::GetReqFp
  00905	8b ce		 mov	 ecx, esi
  00907	8b f8		 mov	 edi, eax
  00909	e8 00 00 00 00	 call	 ?GetFatiguePoint@CMover@@QAEHXZ ; CMover::GetFatiguePoint
  0090e	2b c7		 sub	 eax, edi
  00910	79 0b		 jns	 SHORT $L274506

; 758  : 				{
; 759  : 					if( TRUE == IsPlayer() )

  00912	39 9e 34 02 00
	00		 cmp	 DWORD PTR [esi+564], ebx

; 760  : 						( (CUser*)this )->AddDefinedText( TID_GAME_REQFP, "" );
; 761  : 					return FALSE;

  00918	e9 96 00 00 00	 jmp	 $L284354
$L274506:

; 762  : 				}
; 763  : 
; 764  : 				// KT_SKILL MP   FP  .
; 765  : 				if( (int)pAddSkillProp->nReqMp > 0 )

  0091d	8b 54 24 14	 mov	 edx, DWORD PTR _pAddSkillProp$[esp+52]
  00921	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00924	85 c0		 test	 eax, eax
  00926	7e 20		 jle	 SHORT $L274511

; 766  : 				{
; 767  : 					if( GetManaPoint() - GetReqMp( pAddSkillProp->nReqMp ) < 0 )		//   

  00928	50		 push	 eax
  00929	8b ce		 mov	 ecx, esi
  0092b	e8 00 00 00 00	 call	 ?GetReqMp@CMover@@QAEHH@Z ; CMover::GetReqMp
  00930	8b ce		 mov	 ecx, esi
  00932	8b f8		 mov	 edi, eax
  00934	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint
  00939	2b c7		 sub	 eax, edi
  0093b	79 0b		 jns	 SHORT $L274511

; 768  : 					{
; 769  : 						if( TRUE == IsPlayer() )

  0093d	39 9e 34 02 00
	00		 cmp	 DWORD PTR [esi+564], ebx

; 770  : 							( (CUser*)this )->AddDefinedText( TID_GAME_REQMP, "" );
; 771  : 						return FALSE;

  00943	e9 a1 00 00 00	 jmp	 $L284353
$L274511:

; 772  : 					}
; 773  : 				}
; 774  : 			}
; 775  : 		#else //__LEGEND	//	10 	Neuz, World, Trans
; 776  : 			if( GetFatiguePoint() - GetReqFp( pAddSkillProp->nReqFp ) < 0 )	// FP  
; 777  : 			{
; 778  : 				if( TRUE == IsPlayer() )
; 779  : 					( (CUser*)this )->AddDefinedText( TID_GAME_REQFP, "" );
; 780  : 				return FALSE;
; 781  : 			}
; 782  : 
; 783  : 			// KT_SKILL MP   FP  .
; 784  : 			if( (int)pAddSkillProp->nReqMp > 0 )
; 785  : 			{
; 786  : 				if( GetManaPoint() - GetReqMp( pAddSkillProp->nReqMp ) < 0 )		//   
; 787  : 				{
; 788  : 					if( TRUE == IsPlayer() )
; 789  : 						( (CUser*)this )->AddDefinedText( TID_GAME_REQMP, "" );
; 790  : 					return FALSE;
; 791  : 				}
; 792  : 			}
; 793  : 		#endif	//__LEGEND	//	10 	Neuz, World, Trans
; 794  : 
; 795  : 	#endif
; 796  : 		dwMsg = OBJMSG_MELEESKILL;	//  

  00948	bf 25 00 00 00	 mov	 edi, 37			; 00000025H

; 797  : 	} 
; 798  : 	else if( pSkillProp->dwSkillType == KT_MAGIC )

  0094d	e9 ee 00 00 00	 jmp	 $L284345
$L274497:
  00952	3b c3		 cmp	 eax, ebx
  00954	0f 85 d1 00 00
	00		 jne	 $L274515

; 799  : 	{
; 800  : 	#ifdef __WORLDSERVER
; 801  : 		if( GetAdjParam( DST_CHRSTATE ) & CHS_SILENT )		//     .

  0095a	6a 40		 push	 64			; 00000040H
  0095c	8b ce		 mov	 ecx, esi
  0095e	e8 00 00 00 00	 call	 ?GetAdjParam@CMover@@QAEHH@Z ; CMover::GetAdjParam
  00963	a9 00 00 01 00	 test	 eax, 65536		; 00010000H

; 802  : 			return FALSE;

  00968	0f 85 3b f8 ff
	ff		 jne	 $L284347

; 803  : 
; 804  : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 805  : 		if(GetReqMp( pAddSkillProp->nReqMp ) == 9999999)

  0096e	8b 44 24 14	 mov	 eax, DWORD PTR _pAddSkillProp$[esp+52]
  00972	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00975	51		 push	 ecx
  00976	8b ce		 mov	 ecx, esi
  00978	e8 00 00 00 00	 call	 ?GetReqMp@CMover@@QAEHH@Z ; CMover::GetReqMp
  0097d	3d 7f 96 98 00	 cmp	 eax, 9999999		; 0098967fH

; 806  : 		{
; 807  : 			if( GetManaPoint() != GetMaxManaPoint())

  00982	8b ce		 mov	 ecx, esi
  00984	75 42		 jne	 SHORT $L274517
  00986	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  0098b	8b ce		 mov	 ecx, esi
  0098d	8b d8		 mov	 ebx, eax
  0098f	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint
  00994	3b c3		 cmp	 eax, ebx

; 808  : 			{
; 809  : 				if( TRUE == IsPlayer() )
; 810  : 					( (CUser*)this )->AddDefinedText( TID_GAME_REQMP, "" );
; 811  : 				return FALSE;

  00996	75 4a		 jne	 SHORT $L284352

; 812  : 			}
; 813  : 			if( GetFatiguePoint() != GetMaxFatiguePoint())

  00998	8b ce		 mov	 ecx, esi
  0099a	e8 00 00 00 00	 call	 ?GetFatiguePoint@CMover@@QAEHXZ ; CMover::GetFatiguePoint
  0099f	8b ce		 mov	 ecx, esi
  009a1	8b d8		 mov	 ebx, eax
  009a3	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  009a8	3b d8		 cmp	 ebx, eax
  009aa	74 52		 je	 SHORT $L274525

; 814  : 			{
; 815  : 				if( TRUE == IsPlayer() )

  009ac	83 be 34 02 00
	00 01		 cmp	 DWORD PTR [esi+564], 1
$L284354:
  009b3	0f 85 f0 f7 ff
	ff		 jne	 $L284347

; 816  : 					( (CUser*)this )->AddDefinedText( TID_GAME_REQFP, "" );

  009b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  009be	68 67 02 00 00	 push	 615			; 00000267H

; 817  : 				return FALSE;

  009c3	e9 a6 fb ff ff	 jmp	 $L284350
$L274517:

; 818  : 			}
; 819  : 		}
; 820  : 		else
; 821  : 		{
; 822  : 			if( GetManaPoint() - GetReqMp( pAddSkillProp->nReqMp ) < 0 )		//   

  009c8	8b 54 24 14	 mov	 edx, DWORD PTR _pAddSkillProp$[esp+52]
  009cc	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  009cf	50		 push	 eax
  009d0	e8 00 00 00 00	 call	 ?GetReqMp@CMover@@QAEHH@Z ; CMover::GetReqMp
  009d5	8b ce		 mov	 ecx, esi
  009d7	8b d8		 mov	 ebx, eax
  009d9	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint
  009de	2b c3		 sub	 eax, ebx
  009e0	79 1c		 jns	 SHORT $L274525
$L284352:

; 823  : 			{
; 824  : 				if( TRUE == IsPlayer() )

  009e2	83 be 34 02 00
	00 01		 cmp	 DWORD PTR [esi+564], 1
$L284353:
  009e9	0f 85 ba f7 ff
	ff		 jne	 $L284347

; 825  : 					( (CUser*)this )->AddDefinedText( TID_GAME_REQMP, "" );

  009ef	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  009f4	68 68 02 00 00	 push	 616			; 00000268H

; 826  : 				return FALSE;

  009f9	e9 70 fb ff ff	 jmp	 $L284350
$L274525:

; 827  : 			}
; 828  : 		}
; 829  : #else //__LEGEND	//	10 	Neuz, World, Trans
; 830  : 		if( GetManaPoint() - GetReqMp( pAddSkillProp->nReqMp ) < 0 )		//   
; 831  : 		{
; 832  : 			if( TRUE == IsPlayer() )
; 833  : 				( (CUser*)this )->AddDefinedText( TID_GAME_REQMP, "" );
; 834  : 			return FALSE;
; 835  : 		}
; 836  : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 837  : 
; 838  : 	#endif // worldserver
; 839  : 		if( sutType == SUT_QUEUESTART )		//   . -      .

  009fe	8b 5c 24 44	 mov	 ebx, DWORD PTR _sutType$[esp+48]
  00a02	83 fb 01	 cmp	 ebx, 1
  00a05	75 11		 jne	 SHORT $L274528

; 840  : 		{
; 841  : 			if( IsPlayer() )

  00a07	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00a0d	85 c0		 test	 eax, eax
  00a0f	74 38		 je	 SHORT $L284334

; 842  : 				dwMsg = OBJMSG_MAGICCASTING;

  00a11	bf 27 00 00 00	 mov	 edi, 39			; 00000027H

; 843  : 		} 
; 844  : 		else if( sutType == SUT_QUEUEING )	//   . -   .

  00a16	eb 31		 jmp	 SHORT $L284334
$L274528:
  00a18	83 fb 02	 cmp	 ebx, 2
  00a1b	75 07		 jne	 SHORT $L274531

; 845  : 		{
; 846  : 			nMotion += 2;
; 847  : 			dwMsg = OBJMSG_MAGICSKILL;

  00a1d	bf 26 00 00 00	 mov	 edi, 38			; 00000026H

; 848  : 		} 
; 849  : 		else

  00a22	eb 39		 jmp	 SHORT $L284346
$L274531:

; 850  : 		{									//     -   .
; 851  : 			dwMsg = OBJMSG_MAGICCASTING;

  00a24	bf 27 00 00 00	 mov	 edi, 39			; 00000027H

; 852  : 		}
; 853  : 	}
; 854  : 	else

  00a29	eb 19		 jmp	 SHORT $L274533
$L274515:

; 855  : 		Error( "DoUseSkill : %s dwSkillType = %d", m_szName, pSkillProp->dwSkillType );	//  .

  00a2b	50		 push	 eax
  00a2c	8d 8e 90 16 00
	00		 lea	 ecx, DWORD PTR [esi+5776]
  00a32	51		 push	 ecx
  00a33	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CB@HOKPNGH@DoUseSkill?5?3?5?$CFs?5dwSkillType?5?$DN?5?$CFd@
  00a38	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00a3d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L284345:
  00a40	8b 5c 24 44	 mov	 ebx, DWORD PTR _sutType$[esp+48]
$L274533:

; 856  : 
; 857  : 	if( sutType != SUT_QUEUEING && nCastingTime == 0 && pSkillProp->dwID != SI_GEN_ATK_COUNTER )

  00a44	83 fb 02	 cmp	 ebx, 2
  00a47	74 17		 je	 SHORT $L274535
$L284334:
  00a49	8b 44 24 4c	 mov	 eax, DWORD PTR _nCastingTime$[esp+48]
  00a4d	85 c0		 test	 eax, eax
  00a4f	75 0f		 jne	 SHORT $L274535
  00a51	8b 54 24 10	 mov	 edx, DWORD PTR _pSkillProp$[esp+52]
  00a55	81 3a df 00 00
	00		 cmp	 DWORD PTR [edx], 223	; 000000dfH
  00a5b	74 03		 je	 SHORT $L274535
$L284346:

; 858  : 		nMotion += 2;

  00a5d	83 c5 02	 add	 ebp, 2
$L274535:

; 859  : 	
; 860  : 	//---   -----------------------------------------------------------------
; 861  : #if __VER >= 10 // __LEGEND	//	9 	Neuz, World, Trans
; 862  : 	int nRet = m_pActMover->SendActMsg( dwMsg, nMotion, idFocusObj, nCastingTime, dwSkill );

  00a60	8b 54 24 38	 mov	 edx, DWORD PTR _dwSkill$[esp+48]
  00a64	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00a6a	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a6c	6a 00		 push	 0
  00a6e	52		 push	 edx
  00a6f	8b 54 24 54	 mov	 edx, DWORD PTR _nCastingTime$[esp+56]
  00a73	52		 push	 edx
  00a74	8b 54 24 4c	 mov	 edx, DWORD PTR _idFocusObj$[esp+60]
  00a78	52		 push	 edx
  00a79	55		 push	 ebp
  00a7a	57		 push	 edi
  00a7b	ff 50 04	 call	 DWORD PTR [eax+4]

; 863  : #else //__LEGEND	//	9 	Neuz, World, Trans
; 864  : 	int nRet = m_pActMover->SendActMsg( dwMsg, nMotion, idFocusObj, nCastingTime );
; 865  : #endif	//__LEGEND	//	9 	Neuz, World, Trans
; 866  : 
; 867  : 	if( nRet == 1 )	//   .

  00a7e	83 f8 01	 cmp	 eax, 1
  00a81	0f 85 19 01 00
	00		 jne	 $L274537

; 868  : 	{
; 869  : 		//   .
; 870  : 		SetActParam( OBJACT_USESKILL, dwSkill, idFocusObj );	

  00a87	8b 44 24 40	 mov	 eax, DWORD PTR _idFocusObj$[esp+48]
  00a8b	8b 4c 24 38	 mov	 ecx, DWORD PTR _dwSkill$[esp+48]
  00a8f	6a 00		 push	 0
  00a91	50		 push	 eax
  00a92	51		 push	 ecx
  00a93	6a 05		 push	 5
  00a95	8b ce		 mov	 ecx, esi
  00a97	e8 00 00 00 00	 call	 ?SetActParam@CMover@@AAEXW4OBJACT@@HHH@Z ; CMover::SetActParam

; 871  : 		m_nAParam[3]	= nLevel;

  00a9c	8b 6c 24 3c	 mov	 ebp, DWORD PTR _nLevel$[esp+48]

; 872  : #if __VER >= 8 // __S8_PK
; 873  : 		m_nAParam[4]	= bControl;

  00aa0	8b 54 24 48	 mov	 edx, DWORD PTR _bControl$[esp+48]

; 874  : #endif // __VER >= 8 // __S8_PK
; 875  : 
; 876  : 	#ifdef __WORLDSERVER
; 877  : 		if( pSkillProp->dwSkillType == KT_SKILL )

  00aa4	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  00aa8	89 ae b0 12 00
	00		 mov	 DWORD PTR [esi+4784], ebp
  00aae	89 96 b4 12 00
	00		 mov	 DWORD PTR [esi+4788], edx
  00ab4	83 b8 18 02 00
	00 02		 cmp	 DWORD PTR [eax+536], 2
  00abb	75 3a		 jne	 SHORT $L284331

; 878  : 		{
; 879  : 			//    fp.
; 880  : 			if( (int)pAddSkillProp->nReqFp > 0 )

  00abd	8b 4c 24 14	 mov	 ecx, DWORD PTR _pAddSkillProp$[esp+52]
  00ac1	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00ac4	85 c0		 test	 eax, eax
  00ac6	7e 12		 jle	 SHORT $L274540

; 881  : 				IncFatiguePoint( -GetReqFp( pAddSkillProp->nReqFp ) );			// FP

  00ac8	50		 push	 eax
  00ac9	8b ce		 mov	 ecx, esi
  00acb	e8 00 00 00 00	 call	 ?GetReqFp@CMover@@QAEHH@Z ; CMover::GetReqFp
  00ad0	f7 d8		 neg	 eax
  00ad2	50		 push	 eax
  00ad3	8b ce		 mov	 ecx, esi
  00ad5	e8 00 00 00 00	 call	 ?IncFatiguePoint@CMover@@QAEXH@Z ; CMover::IncFatiguePoint
$L274540:

; 882  : 
; 883  : 			int nReqMp	= GetReqMp( pAddSkillProp->nReqMp );

  00ada	8b 54 24 14	 mov	 edx, DWORD PTR _pAddSkillProp$[esp+52]
  00ade	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00ae1	50		 push	 eax
  00ae2	8b ce		 mov	 ecx, esi
  00ae4	e8 00 00 00 00	 call	 ?GetReqMp@CMover@@QAEHH@Z ; CMover::GetReqMp

; 884  : 			if( nReqMp > 0 )

  00ae9	85 c0		 test	 eax, eax
  00aeb	7e 0a		 jle	 SHORT $L284331

; 885  : 			{
; 886  : 				IncManaPoint( -nReqMp );

  00aed	f7 d8		 neg	 eax
  00aef	50		 push	 eax
  00af0	8b ce		 mov	 ecx, esi
  00af2	e8 00 00 00 00	 call	 ?IncManaPoint@CMover@@QAEXH@Z ; CMover::IncManaPoint
$L284331:

; 887  : 			}
; 888  : 		}
; 889  : 	#if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 890  : 		if( pSkillProp->dwSkillType == KT_MAGIC )

  00af7	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  00afb	8b 81 18 02 00
	00		 mov	 eax, DWORD PTR [ecx+536]
  00b01	bf 01 00 00 00	 mov	 edi, 1
  00b06	3b c7		 cmp	 eax, edi
  00b08	75 38		 jne	 SHORT $L284332

; 891  : 		{
; 892  : 			if( GetReqMp( pAddSkillProp->nReqMp ) == 9999999 )

  00b0a	8b 54 24 14	 mov	 edx, DWORD PTR _pAddSkillProp$[esp+52]
  00b0e	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00b11	50		 push	 eax
  00b12	8b ce		 mov	 ecx, esi
  00b14	e8 00 00 00 00	 call	 ?GetReqMp@CMover@@QAEHH@Z ; CMover::GetReqMp
  00b19	3d 7f 96 98 00	 cmp	 eax, 9999999		; 0098967fH
  00b1e	75 22		 jne	 SHORT $L284332

; 893  : 			{
; 894  : 				IncFatiguePoint( -GetFatiguePoint() );			// FP

  00b20	8b ce		 mov	 ecx, esi
  00b22	e8 00 00 00 00	 call	 ?GetFatiguePoint@CMover@@QAEHXZ ; CMover::GetFatiguePoint
  00b27	f7 d8		 neg	 eax
  00b29	50		 push	 eax
  00b2a	8b ce		 mov	 ecx, esi
  00b2c	e8 00 00 00 00	 call	 ?IncFatiguePoint@CMover@@QAEXH@Z ; CMover::IncFatiguePoint

; 895  : 				IncManaPoint( -GetManaPoint() );

  00b31	8b ce		 mov	 ecx, esi
  00b33	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint
  00b38	f7 d8		 neg	 eax
  00b3a	50		 push	 eax
  00b3b	8b ce		 mov	 ecx, esi
  00b3d	e8 00 00 00 00	 call	 ?IncManaPoint@CMover@@QAEXH@Z ; CMover::IncManaPoint
$L284332:

; 896  : 			}
; 897  : 		}
; 898  : 	#endif	//__LEGEND	//	10 	Neuz, World, Trans
; 899  : 		
; 900  : 		if( pSkillProp->dwLinkKindBullet != NULL_ID )	// (?)  

  00b42	8b 4c 24 10	 mov	 ecx, DWORD PTR _pSkillProp$[esp+52]
  00b46	83 b9 dc 00 00
	00 ff		 cmp	 DWORD PTR [ecx+220], -1
  00b4d	74 15		 je	 SHORT $L284333

; 901  : 		{
; 902  : 			CItemElem *pItemElem = GetEquipItem( PARTS_BULLET );

  00b4f	6a 19		 push	 25			; 00000019H
  00b51	8b ce		 mov	 ecx, esi
  00b53	e8 00 00 00 00	 call	 ?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetEquipItem

; 903  : 			if( pItemElem )

  00b58	85 c0		 test	 eax, eax
  00b5a	74 08		 je	 SHORT $L284333

; 904  : 				ArrowDown( 1 );

  00b5c	57		 push	 edi
  00b5d	8b ce		 mov	 ecx, esi
  00b5f	e8 00 00 00 00	 call	 ?ArrowDown@CMover@@QAEXH@Z ; CMover::ArrowDown
$L284333:

; 905  : 		}
; 906  : 
; 907  : 		if( pSkillProp->nEvildoing < 0 )		//    .

  00b64	8b 54 24 10	 mov	 edx, DWORD PTR _pSkillProp$[esp+52]
  00b68	8b 82 34 02 00
	00		 mov	 eax, DWORD PTR [edx+564]
  00b6e	85 c0		 test	 eax, eax
  00b70	7d 10		 jge	 SHORT $L274548

; 908  : 		{
; 909  : 			pTarget->SetJJim( this );			// pTarget  .

  00b72	8b 4c 24 18	 mov	 ecx, DWORD PTR _pTarget$[esp+52]
  00b76	56		 push	 esi
  00b77	e8 00 00 00 00	 call	 ?SetJJim@CMover@@QAEXPAV1@@Z ; CMover::SetJJim

; 910  : 			m_nAtkCnt = 1;						//      .

  00b7c	89 be b0 06 00
	00		 mov	 DWORD PTR [esi+1712], edi
$L274548:

; 911  : 		}
; 912  : 
; 913  : 		// DST param    .
; 914  : 		g_UserMng.AddUseSkill( this, dwSkill, nLevel, idFocusObj, sutType, nCastingTime );

  00b82	8b 44 24 4c	 mov	 eax, DWORD PTR _nCastingTime$[esp+48]
  00b86	8b 4c 24 40	 mov	 ecx, DWORD PTR _idFocusObj$[esp+48]
  00b8a	8b 54 24 38	 mov	 edx, DWORD PTR _dwSkill$[esp+48]
  00b8e	50		 push	 eax
  00b8f	53		 push	 ebx
  00b90	51		 push	 ecx
  00b91	55		 push	 ebp
  00b92	52		 push	 edx
  00b93	56		 push	 esi
  00b94	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00b99	e8 00 00 00 00	 call	 ?AddUseSkill@CUserMng@@QAEXPAVCMover@@KKKHH@Z ; CUserMng::AddUseSkill

; 915  : 	#endif	// __WORLDSERVER
; 916  : 	} 
; 917  : 	else if( nRet == -2 )	// 0:  -1:  -2:    -3:

  00b9e	eb 09		 jmp	 SHORT $L274550
$L274537:
  00ba0	83 f8 fe	 cmp	 eax, -2			; fffffffeH

; 918  : 	{
; 919  : 		return FALSE;

  00ba3	0f 84 00 f6 ff
	ff		 je	 $L284347
$L274550:

; 920  : 	}
; 921  : 	
; 922  : 	m_dwFlag |= MVRF_SKILL;		//   .

  00ba9	8b be 48 02 00
	00		 mov	 edi, DWORD PTR [esi+584]
  00baf	83 cf 01	 or	 edi, 1

; 923  : #ifdef __CLIENT
; 924  : 	if( IsActiveMover() )		// g_pPlayer 
; 925  : 	{
; 926  : 		CWndTaskBar* pTaskBar = g_WndMng.m_pWndTaskBar;
; 927  : 		if( pTaskBar->m_nExecute == 1 )		//   
; 928  : 			pTaskBar->m_nExecute = 2;		//    .
; 929  : 	}
; 930  : #endif
; 931  : 
; 932  : #ifdef __CLIENT
; 933  : 	{
; 934  : 		DWORD dwLinkSfxDouble = NULL_ID;
; 935  : 		switch( dwSkill )
; 936  : 		{	//  XI_  CreateSfx CSfxPartsLink()  /
; 937  : 		case SI_BLD_DOUBLEAX_SPRINGATTACK:	dwLinkSfxDouble = XI_SKILL_BLD_DOUBLEAX_SPRINGATTACK01;	break;
; 938  : 		case SI_BLD_DOUBLE_SONICBLADE:		dwLinkSfxDouble = XI_SKILL_BLD_DOUBLE_SONICBLADE01;	break;
; 939  : 		case SI_KNT_TWOSW_CHARGE:			dwLinkSfxDouble = XI_SKILL_KNT_TWOSW_CHARGE01;	break;
; 940  : 		case SI_BLD_DOUBLESW_BLADEDANCE:	dwLinkSfxDouble = XI_SKILL_BLD_DOUBLESW_BLADEDANCE01;      break;
; 941  : 
; 942  : 		//    : sfx  
; 943  : 		case SI_JST_YOYO_VATALSTAB:	dwLinkSfxDouble = XI_SKILL_JST_YOYO_VATALSTAB01;	break;
; 944  : 		case SI_JST_YOYO_HITOFPENYA:	dwLinkSfxDouble = XI_SKILL_JST_YOYO_HITOFPENYA01;	break;
; 945  : 
; 946  : 		case SI_JST_YOYO_CRITICALSWING:	dwLinkSfxDouble = XI_SKILL_JST_SUP_CRITICALSWING01;	break;
; 947  : 		case SI_ACR_SUP_SLOWSTEP:	dwLinkSfxDouble = XI_SKILL_ACR_YOYO_SLOWSTEP01;	break;
; 948  : 		case SI_JST_SUP_POISON:		dwLinkSfxDouble = XI_SKILL_JST_SUP_POISON01;	break;
; 949  : 		case SI_JST_SUP_BLEEDING:	dwLinkSfxDouble = XI_SKILL_JST_SUP_BLEEDING01;	break;
; 950  : 		case SI_JST_YOYO_BACKSTAB:	dwLinkSfxDouble = XI_SKILL_JST_YOYO_BACKSTAB01;	break;
; 951  : 		case SI_JST_SUP_ABSORB:	dwLinkSfxDouble = XI_SKILL_JST_SUP_ABSORB01;	break;
; 952  : 			break;
; 953  : 		}
; 954  : 		if( dwLinkSfxDouble != NULL_ID )
; 955  : 		{
; 956  : 			CSfx *pSfx = CreateSfx( g_Neuz.m_pd3dDevice, dwLinkSfxDouble, GetPos(), GetId() );  //    .
; 957  : 			if( pSfx )
; 958  : 			{
; 959  : 				pSfx->SetPartLink( 0 );		//  .
; 960  : 				pSfx = CreateSfx( g_Neuz.m_pd3dDevice, dwLinkSfxDouble, GetPos(), GetId() );  //   .
; 961  : 				if( pSfx )
; 962  : 					pSfx->SetPartLink( 1 );		//  .
; 963  : 			}
; 964  : 		}
; 965  : 	}
; 966  : 
; 967  : 	//   
; 968  : 	DWORD dwLinkSfxLeft = NULL_ID;
; 969  : 	switch( dwSkill )
; 970  : 	{	//       
; 971  : 	case SI_RAG_BOW_ICEARROW:	dwLinkSfxLeft = XI_SKILL_RAG_BOW_ICEARROW01;	break;
; 972  : 	case SI_ACR_BOW_JUNKBOW:	dwLinkSfxLeft = XI_SKILL_ACR_BOW_JUNKBOW01;	break;
; 973  : 	case SI_ACR_BOW_AIMEDSHOT:	dwLinkSfxLeft = XI_SKILL_ACR_BOW_AIMEDSHOT01;	break;
; 974  : 	case SI_ACR_BOW_SILENTSHOT:	dwLinkSfxLeft = XI_SKILL_ACR_BOW_SILENTSHOT01;	break;
; 975  : 	case SI_ACR_BOW_ARROWRAIN:	dwLinkSfxLeft = XI_SKILL_ACR_BOW_ARROWRAIN01;      break;
; 976  : 	case SI_ACR_BOW_AUTOSHOT:	dwLinkSfxLeft = XI_SKILL_ACR_BOW_AUTOSHOT01;      break;
; 977  : 		
; 978  : 	case SI_RAG_SUP_FASTATTACK:	  dwLinkSfxLeft = XI_SKILL_RAG_SUP_FASTATTACK01;break;
; 979  : 	case SI_RAG_BOW_FLAMEARROW:	  dwLinkSfxLeft = XI_SKILL_RAG_BOW_FLAMEARROW01;break;
; 980  : 	case SI_RAG_BOW_PIRCINGARROW: dwLinkSfxLeft = XI_SKILL_RAG_BOW_PIRCINGARROW01;break;
; 981  : 	case SI_RAG_BOW_POISONARROW:  dwLinkSfxLeft = XI_SKILL_RAG_BOW_POISONARROW01;break;
; 982  : 	case SI_RAG_BOW_SILENTARROW:  dwLinkSfxLeft = XI_SKILL_RAG_BOW_SILENTARROW01;break;
; 983  : 	case SI_RAG_BOW_TRIPLESHOT:   dwLinkSfxLeft = XI_SKILL_RAG_BOW_TRIPLESHOT01;break;
; 984  : 		
; 985  : 		break;
; 986  : 	}
; 987  : 	
; 988  : 	if( dwLinkSfxLeft != NULL_ID )
; 989  : 	{
; 990  : 		CSfx *pSfx = CreateSfx( g_Neuz.m_pd3dDevice, dwLinkSfxLeft, GetPos(), GetId() );  //    .
; 991  : 		if( pSfx )
; 992  : 			pSfx->SetPartLink( 1 );		//  .
; 993  : 	}
; 994  : 
; 995  : 	//   
; 996  : 	DWORD dwLinkSfxRight = NULL_ID;
; 997  : 	switch( dwSkill )
; 998  : 	{
; 999  : 	case SI_MER_ONE_SPLMASH: dwLinkSfxRight = XI_SKILL_MER_ONE_SUPPORT04; break;
; 1000 : 	case SI_MER_ONE_GUILOTINE: dwLinkSfxRight = XI_SKILL_MER_ONE_SUPPORT02; break;
; 1001 : 	case SI_MER_ONE_REFLEXHIT: dwLinkSfxRight = XI_SKILL_MER_ONE_SUPPORT01; break;
; 1002 : 	case SI_MER_ONE_SPECIALHIT: dwLinkSfxRight = XI_SKILL_MER_ONE_SUPPORT03; break;
; 1003 : 	case SI_ASS_KNU_POWERFIST:	dwLinkSfxRight = XI_SKILL_ASS_KNU_SUPPORT03;	break;
; 1004 : 	case SI_ASS_KNU_TAMPINGHOLE:	dwLinkSfxRight = XI_SKILL_ASS_KNU_SUPPORT02;	break;
; 1005 : 	case SI_ASS_KNU_BURSTCRACK:	dwLinkSfxRight = XI_SKILL_ASS_KNU_SUPPORT01;	break;
; 1006 : 	case SI_GEN_ATK_COUNTER:	dwLinkSfxRight = XI_SKILL_JST_YOYO_BACKSTAB01;	break;
; 1007 : 		break;
; 1008 : 	}
; 1009 : 	
; 1010 : 	if( dwLinkSfxRight != NULL_ID )
; 1011 : 	{
; 1012 : 		CSfx *pSfx = CreateSfx( g_Neuz.m_pd3dDevice, dwLinkSfxRight, GetPos(), GetId() );  //    .
; 1013 : 		if( pSfx )
; 1014 : 			pSfx->SetPartLink( 0 );		//  .
; 1015 : 	}
; 1016 : 
; 1017 : 	//     
; 1018 : 	// id GetId()
; 1019 : 	// id idFocusObj
; 1020 : 	if( pSkillProp->dwSfxObj != NULL_ID )
; 1021 : 	{
; 1022 : 		CreateSfx( g_Neuz.m_pd3dDevice, pSkillProp->dwSfxObj, GetPos(), GetId() );  //    .
; 1023 : 	}	
; 1024 : 	//       
; 1025 : 	if( pSkillProp->dwExeTarget != EXT_MELEEATK && 
; 1026 : 		pSkillProp->dwExeTarget != EXT_MAGICATK && 
; 1027 : 		pSkillProp->dwExeTarget != EXT_AROUNDATK &&  
; 1028 : 		pSkillProp->dwExeTarget != EXT_MAGICATKSHOT && 
; 1029 : 		pTarget->IsPlayer() )
; 1030 : 	{
; 1031 : 		CString str;
; 1032 : 		if( this == g_pPlayer ) //  
; 1033 : 		{
; 1034 : 			str.Format( prj.GetText( TID_GAME_SKILL_SELF ), pSkillProp->szName );
; 1035 : 			g_WndMng.PutString( (LPCTSTR)str, NULL, prj.GetTextColor( TID_GAME_SKILL_SELF ) );	
; 1036 : 		}
; 1037 : 		else
; 1038 : 		if( pTarget == g_pPlayer && ( this != pTarget || pSkillProp->dwID == SI_ASS_CHEER_CIRCLEHEALING ) ) //   
; 1039 : 		{
; 1040 : 			str.Format( prj.GetText( TID_GAME_SKILL_MATE ), GetName(), pSkillProp->szName );
; 1041 : 			g_WndMng.PutString( (LPCTSTR)str, NULL, prj.GetTextColor( TID_GAME_SKILL_MATE ) );	
; 1042 : 		}
; 1043 : 	}
; 1044 : #endif	// __CLIENT
; 1045 : 
; 1046 : #ifdef __CLIENT	
; 1047 : 	if( ::GetLanguage() == LANG_JAP )
; 1048 : 	{
; 1049 : 		if( g_pPlayer )
; 1050 : 		{
; 1051 : 			if( g_Option.m_bVoice )
; 1052 : 			{
; 1053 : 				if( IsActiveMover() )
; 1054 : 				{
; 1055 : 					int nindex = 0;
; 1056 : 					
; 1057 : 					if( pSkillProp->dwID != -1 )
; 1058 : 					{
; 1059 : 						if( GetSex() == 0 )
; 1060 : 							nindex = pSkillProp->dwID+3000;
; 1061 : 						else
; 1062 : 							nindex = pSkillProp->dwID+3500;
; 1063 : 
; 1064 : 						g_SoundMng.m_nOldSoundVolume = g_SoundMng.m_nSoundVolume;
; 1065 : 						g_SoundMng.m_nSoundVolume = 0;
; 1066 : 						PLAYSND( nindex );
; 1067 : 
; 1068 : 						g_SoundMng.m_nSoundVolume = g_SoundMng.m_nOldSoundVolume;
; 1069 : 					}
; 1070 : 				}
; 1071 : 			}
; 1072 : 		}
; 1073 : 	}
; 1074 : #endif	// __CLIENT
; 1075 : 
; 1076 : #if __VER >= 8 // __S8_PK
; 1077 : #ifdef __WORLDSERVER
; 1078 : 	if( g_eLocal.GetState( EVE_PK ) )

  00bb2	6a 0b		 push	 11			; 0000000bH
  00bb4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00bb9	89 be 48 02 00
	00		 mov	 DWORD PTR [esi+584], edi
  00bbf	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00bc4	84 c0		 test	 al, al
  00bc6	74 59		 je	 SHORT $L274552

; 1079 : 	{
; 1080 : 		if( !IsChaotic() && ( pTarget->IsPKPink() || ( pTarget->IsChaotic() && pSkillProp->nEvildoing > 0 ) ) )

  00bc8	8b 86 60 07 00
	00		 mov	 eax, DWORD PTR [esi+1888]
  00bce	85 c0		 test	 eax, eax
  00bd0	77 4f		 ja	 SHORT $L274552
  00bd2	8b 44 24 18	 mov	 eax, DWORD PTR _pTarget$[esp+52]
  00bd6	8b 88 58 07 00
	00		 mov	 ecx, DWORD PTR [eax+1880]
  00bdc	85 c9		 test	 ecx, ecx
  00bde	77 18		 ja	 SHORT $L274553
  00be0	8b 88 60 07 00
	00		 mov	 ecx, DWORD PTR [eax+1888]
  00be6	85 c9		 test	 ecx, ecx
  00be8	76 37		 jbe	 SHORT $L274552
  00bea	8b 44 24 10	 mov	 eax, DWORD PTR _pSkillProp$[esp+52]
  00bee	8b 88 34 02 00
	00		 mov	 ecx, DWORD PTR [eax+564]
  00bf4	85 c9		 test	 ecx, ecx
  00bf6	7e 29		 jle	 SHORT $L274552
$L274553:

; 1081 : 		{
; 1082 : 			SetPKPink( GetTickCount() + SEC(prj.m_PKSetting.nReadyAttack) );

  00bf8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00bfe	8b 0d 80 46 0f
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+1001088
  00c04	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  00c0a	03 c1		 add	 eax, ecx
  00c0c	50		 push	 eax
  00c0d	8b ce		 mov	 ecx, esi
  00c0f	e8 00 00 00 00	 call	 ?SetPKPink@CMover@@QAEXK@Z ; CMover::SetPKPink

; 1083 : 			g_UserMng.AddPKPink( this, 1 );	

  00c14	6a 01		 push	 1
  00c16	56		 push	 esi
  00c17	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00c1c	e8 00 00 00 00	 call	 ?AddPKPink@CUserMng@@QAEXPAVCMover@@E@Z ; CUserMng::AddPKPink
$L274552:
  00c21	5f		 pop	 edi
  00c22	5d		 pop	 ebp
  00c23	5b		 pop	 ebx

; 1084 : 		}
; 1085 : 	}
; 1086 : #endif // __WORLDSERVER
; 1087 : #endif // __VER >= 8 // __S8_PK
; 1088 : 	
; 1089 : 	return TRUE;

  00c24	b8 01 00 00 00	 mov	 eax, 1
  00c29	5e		 pop	 esi

; 1090 : }

  00c2a	83 c4 24	 add	 esp, 36			; 00000024H
  00c2d	c2 18 00	 ret	 24			; 00000018H
$L284355:
  00c30	00 00 00 00	 DD	 $L274437
  00c34	00 00 00 00	 DD	 $L274433
  00c38	00 00 00 00	 DD	 $L274415
  00c3c	00 00 00 00	 DD	 $L274429
  00c40	00 00 00 00	 DD	 $L274441
$L284322:
  00c44	00		 DB	 0
  00c45	01		 DB	 1
  00c46	04		 DB	 4
  00c47	04		 DB	 4
  00c48	04		 DB	 4
  00c49	04		 DB	 4
  00c4a	04		 DB	 4
  00c4b	04		 DB	 4
  00c4c	04		 DB	 4
  00c4d	04		 DB	 4
  00c4e	04		 DB	 4
  00c4f	04		 DB	 4
  00c50	04		 DB	 4
  00c51	04		 DB	 4
  00c52	04		 DB	 4
  00c53	04		 DB	 4
  00c54	04		 DB	 4
  00c55	04		 DB	 4
  00c56	04		 DB	 4
  00c57	04		 DB	 4
  00c58	04		 DB	 4
  00c59	04		 DB	 4
  00c5a	04		 DB	 4
  00c5b	04		 DB	 4
  00c5c	04		 DB	 4
  00c5d	04		 DB	 4
  00c5e	04		 DB	 4
  00c5f	04		 DB	 4
  00c60	04		 DB	 4
  00c61	04		 DB	 4
  00c62	04		 DB	 4
  00c63	04		 DB	 4
  00c64	04		 DB	 4
  00c65	04		 DB	 4
  00c66	04		 DB	 4
  00c67	04		 DB	 4
  00c68	04		 DB	 4
  00c69	04		 DB	 4
  00c6a	04		 DB	 4
  00c6b	02		 DB	 2
  00c6c	04		 DB	 4
  00c6d	04		 DB	 4
  00c6e	03		 DB	 3
?DoUseSkill@CMover@@QAEHKHKW4SKILLUSETYPE@@HH@Z ENDP	; CMover::DoUseSkill
_TEXT	ENDS
PUBLIC	?DoUseItemVirtual@CMover@@QAEHKH@Z		; CMover::DoUseItemVirtual
EXTRN	?IsItemRedyTime@CMover@@QAEHPAUItemProp@@KH@Z:NEAR ; CMover::IsItemRedyTime
EXTRN	?RemoveBuff@CMover@@QAEXGG@Z:NEAR		; CMover::RemoveBuff
EXTRN	?GetReturnPos@CUser@@QAEAAUD3DXVECTOR3@@PAK@Z:NEAR ; CUser::GetReturnPos
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemVirtual@CMover@@QAEHKH@Z
_TEXT	SEGMENT
_vPos$274611 = -12					; size = 12
_dwWorldID$274610 = 8					; size = 4
_dwItemId$ = 8						; size = 4
_bEffectSkip$ = 12					; size = 4
?DoUseItemVirtual@CMover@@QAEHKH@Z PROC NEAR		; CMover::DoUseItemVirtual, COMDAT
; _this$ = ecx

; 1209 : #ifdef __WORLDSERVER
; 1210 : 	//     .
; 1211 : 
; 1212 : 	ItemProp* pItemProp = prj.GetItemProp( dwItemId );

  00000	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	53		 push	 ebx
  00009	8b 5c 24 14	 mov	 ebx, DWORD PTR _dwItemId$[esp+12]
  0000d	85 db		 test	 ebx, ebx
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8b f1		 mov	 esi, ecx
  00013	0f 8c a0 00 00
	00		 jl	 $L284386
  00019	3b d8		 cmp	 ebx, eax
  0001b	0f 8d 98 00 00
	00		 jge	 $L284386
  00021	0f 83 24 01 00
	00		 jae	 $L274620
  00027	a1 4c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+588
  0002c	8b 3c 98	 mov	 edi, DWORD PTR [eax+ebx*4]

; 1213 : 
; 1214 : 	if( pItemProp )

  0002f	85 ff		 test	 edi, edi
  00031	0f 84 14 01 00
	00		 je	 $L274620

; 1215 : 	{
; 1216 : 		if( IsItemRedyTime( pItemProp, pItemProp->dwID, FALSE ) == FALSE )

  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	6a 00		 push	 0
  0003b	51		 push	 ecx
  0003c	57		 push	 edi
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?IsItemRedyTime@CMover@@QAEHPAUItemProp@@KH@Z ; CMover::IsItemRedyTime
  00044	85 c0		 test	 eax, eax

; 1217 : 			return FALSE;

  00046	0f 84 cd 00 00
	00		 je	 $L274617

; 1218 : 
; 1219 : 		D3DXVECTOR3 sPos = D3DXVECTOR3(0.0f,0.0f,0.0f);
; 1220 : 
; 1221 : 		if( dwItemId == II_SYS_SYS_SCR_RETURN )

  0004c	81 fb e5 28 00
	00		 cmp	 ebx, 10469		; 000028e5H
  00052	0f 85 85 00 00
	00		 jne	 $L274608

; 1222 : 		{
; 1223 : 			//  
; 1224 : 			if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_RETURN ) )

  00058	53		 push	 ebx
  00059	6a 00		 push	 0
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00062	85 c0		 test	 eax, eax
  00064	74 0a		 je	 SHORT $L274609

; 1225 : 				RemoveBuff( BUFF_ITEM, II_SYS_SYS_SCR_RETURN );

  00066	53		 push	 ebx
  00067	6a 00		 push	 0
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?RemoveBuff@CMover@@QAEXGG@Z ; CMover::RemoveBuff
$L274609:

; 1226 : 
; 1227 : 			DWORD dwWorldID;
; 1228 : 			D3DXVECTOR3 vPos = ((CUser*)this)->GetReturnPos( &dwWorldID );

  00070	8d 54 24 1c	 lea	 edx, DWORD PTR _dwWorldID$274610[esp+20]
  00074	52		 push	 edx
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?GetReturnPos@CUser@@QAEAAUD3DXVECTOR3@@PAK@Z ; CUser::GetReturnPos
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	89 4c 24 0c	 mov	 DWORD PTR _vPos$274611[esp+24], ecx
  00082	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1229 : 			((CUser*)this)->REPLACE( g_uIdofMulti, dwWorldID, vPos, REPLACE_NORMAL, nTempLayer );

  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	89 54 24 18	 mov	 DWORD PTR _vPos$274611[esp+36], edx
  0008d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00090	8b 54 24 24	 mov	 edx, DWORD PTR _dwWorldID$274610[esp+28]
  00094	8d 4c 24 14	 lea	 ecx, DWORD PTR _vPos$274611[esp+32]
  00098	51		 push	 ecx
  00099	89 44 24 20	 mov	 DWORD PTR _vPos$274611[esp+44], eax
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  000a2	52		 push	 edx
  000a3	50		 push	 eax
  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi

; 1254 : 		}	
; 1255 : 	}
; 1256 : #endif //__WORLDSERVER
; 1257 : 
; 1258 : 	return TRUE;

  000ad	b8 01 00 00 00	 mov	 eax, 1
  000b2	5b		 pop	 ebx

; 1259 : }

  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	c2 08 00	 ret	 8

; 1209 : #ifdef __WORLDSERVER
; 1210 : 	//     .
; 1211 : 
; 1212 : 	ItemProp* pItemProp = prj.GetItemProp( dwItemId );

$L284386:
  000b9	53		 push	 ebx
  000ba	50		 push	 eax
  000bb	6a 00		 push	 0
  000bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000c7	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000cc	83 c4 14	 add	 esp, 20			; 00000014H
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi

; 1254 : 		}	
; 1255 : 	}
; 1256 : #endif //__WORLDSERVER
; 1257 : 
; 1258 : 	return TRUE;

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	5b		 pop	 ebx

; 1259 : }

  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	c2 08 00	 ret	 8
$L274608:

; 1230 : 			return TRUE;
; 1231 : 		}
; 1232 : 
; 1233 : 
; 1234 : 		if( dwItemId == II_CHR_SYS_SCR_ESCAPEBLINKWING )

  000dd	81 fb c3 28 00
	00		 cmp	 ebx, 10435		; 000028c3H
  000e3	75 3f		 jne	 SHORT $L274614

; 1235 : 		{
; 1236 : 			if( pItemProp->dwCircleTime != (DWORD)-1 )

  000e5	8b 87 ec 01 00
	00		 mov	 eax, DWORD PTR [edi+492]
  000eb	83 f8 ff	 cmp	 eax, -1
  000ee	74 14		 je	 SHORT $L274618

; 1237 : 			{
; 1238 : 				if( !IsSMMode( SM_ESCAPE ) )

  000f0	8b 8e 50 03 00
	00		 mov	 ecx, DWORD PTR [esi+848]
  000f6	85 c9		 test	 ecx, ecx
  000f8	77 1f		 ja	 SHORT $L274617

; 1239 : 				{
; 1240 : 					SetSMMode( SM_ESCAPE, pItemProp->dwCircleTime );

  000fa	50		 push	 eax
  000fb	6a 13		 push	 19			; 00000013H
  000fd	8b ce		 mov	 ecx, esi
  000ff	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode
$L274618:

; 1245 : 				}
; 1246 : 			}
; 1247 : 			return DoUseItemBlinkWing( pItemProp, NULL, FALSE );

  00104	6a 00		 push	 0
  00106	6a 00		 push	 0
  00108	57		 push	 edi
  00109	8b ce		 mov	 ecx, esi
  0010b	e8 00 00 00 00	 call	 ?DoUseItemBlinkWing@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemBlinkWing
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx

; 1259 : }

  00113	83 c4 0c	 add	 esp, 12			; 0000000cH
  00116	c2 08 00	 ret	 8
$L274617:
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 1241 : 				}
; 1242 : 				else
; 1243 : 				{
; 1244 : 					return FALSE;

  0011b	33 c0		 xor	 eax, eax
  0011d	5b		 pop	 ebx

; 1259 : }

  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00121	c2 08 00	 ret	 8
$L274614:

; 1248 : 		}
; 1249 : 
; 1250 : 		DWORD	dwSfxID = pItemProp->dwSfxObj3;

  00124	8b bf dc 01 00
	00		 mov	 edi, DWORD PTR [edi+476]

; 1251 : 		if( dwSfxID != NULL_ID && !bEffectSkip )		//    

  0012a	83 ff ff	 cmp	 edi, -1
  0012d	74 1c		 je	 SHORT $L274620
  0012f	8b 44 24 20	 mov	 eax, DWORD PTR _bEffectSkip$[esp+20]
  00133	85 c0		 test	 eax, eax
  00135	75 14		 jne	 SHORT $L274620

; 1252 : 		{
; 1253 : 			g_UserMng.AddCreateSfxObj( this, dwSfxID, sPos.x, sPos.y, sPos.z );	//  .

  00137	6a 00		 push	 0
  00139	6a 00		 push	 0
  0013b	6a 00		 push	 0
  0013d	6a 00		 push	 0
  0013f	57		 push	 edi
  00140	56		 push	 esi
  00141	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00146	e8 00 00 00 00	 call	 ?AddCreateSfxObj@CUserMng@@QAEXPAVCCtrl@@KMMMH@Z ; CUserMng::AddCreateSfxObj
$L274620:
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi

; 1254 : 		}	
; 1255 : 	}
; 1256 : #endif //__WORLDSERVER
; 1257 : 
; 1258 : 	return TRUE;

  0014d	b8 01 00 00 00	 mov	 eax, 1
  00152	5b		 pop	 ebx

; 1259 : }

  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
  00156	c2 08 00	 ret	 8
?DoUseItemVirtual@CMover@@QAEHKH@Z ENDP			; CMover::DoUseItemVirtual
_TEXT	ENDS
PUBLIC	?DoAttackMagic@CMover@@QAEHPAVCObj@@HH@Z	; CMover::DoAttackMagic
EXTRN	?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z:NEAR ; CUserMng::AddMagicAttack
; Function compile flags: /Ogty
;	COMDAT ?DoAttackMagic@CMover@@QAEHPAVCObj@@HH@Z
_TEXT	SEGMENT
$T284409 = -24						; size = 12
$T284410 = -12						; size = 12
$T284475 = 8						; size = 4
_pTargetObj$ = 8					; size = 4
_nMagicPower$ = 12					; size = 4
_idSfxHit$ = 16						; size = 4
?DoAttackMagic@CMover@@QAEHPAVCObj@@HH@Z PROC NEAR	; CMover::DoAttackMagic, COMDAT
; _this$ = ecx

; 3453 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx

; 3454 : 	if( IsInvalidObj(pTargetObj) )		//    

  00004	8b 5c 24 20	 mov	 ebx, DWORD PTR _pTargetObj$[esp+24]
  00008	85 db		 test	 ebx, ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	74 06		 je	 SHORT $L284428
  0000f	f6 43 04 01	 test	 BYTE PTR [ebx+4], 1
  00013	74 0d		 je	 SHORT $L275515
$L284428:
  00015	5e		 pop	 esi

; 3455 : 		return( -1 );

  00016	b8 ff ff ff ff	 mov	 eax, -1
  0001b	5b		 pop	 ebx

; 3530 : }

  0001c	83 c4 18	 add	 esp, 24			; 00000018H
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$L275515:

; 3456 : 
; 3457 : 	ItemProp* pItemProp;
; 3458 : #ifndef __CLIENT
; 3459 : 	CItemElem* pItemElem = GetWeaponItem();	//    

  00022	6a 0a		 push	 10			; 0000000aH
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?GetWeaponItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetWeaponItem

; 3460 : 	if( pItemElem == NULL )

  0002b	85 c0		 test	 eax, eax

; 3461 : 		return( - 1 ) ;

  0002d	74 52		 je	 SHORT $L284508

; 3462 : 	pItemProp	= pItemElem->GetProp();

  0002f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00032	85 c0		 test	 eax, eax
  00034	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0003a	7c 1d		 jl	 SHORT $L284483
  0003c	3b c1		 cmp	 eax, ecx
  0003e	7d 19		 jge	 SHORT $L284483
  00040	72 08		 jb	 SHORT $L284495
  00042	33 c0		 xor	 eax, eax
  00044	89 44 24 24	 mov	 DWORD PTR $T284475[esp+28], eax
  00048	eb 2d		 jmp	 SHORT $L284478
$L284495:
  0004a	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00050	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00053	89 44 24 24	 mov	 DWORD PTR $T284475[esp+28], eax
  00057	eb 1e		 jmp	 SHORT $L284478
$L284483:
  00059	50		 push	 eax
  0005a	51		 push	 ecx
  0005b	6a 00		 push	 0
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00067	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T284475[esp+28], 0
$L284478:

; 3463 : #else	// __CLIENT
; 3464 : 	if( IsActiveMover() ) {
; 3465 : 		CItemElem* pItemElem = GetWeaponItem();
; 3466 : 		if( pItemElem == NULL )
; 3467 : 			return( - 1 ) ;
; 3468 : 		pItemProp	= pItemElem->GetProp();
; 3469 : 	}
; 3470 : 	else {
; 3471 : 		DWORD dwItemId	= m_aEquipInfo[PARTS_RWEAPON].dwId;
; 3472 : 		if( dwItemId == NULL_ID )
; 3473 : 			return( -1 );
; 3474 : 		pItemProp	= prj.GetItemProp( dwItemId );
; 3475 : 	}
; 3476 : #endif	// __CLIENT
; 3477 : 
; 3478 : 	if( pItemProp->dwItemKind3 != IK3_WAND )		//     .

  00077	8b 54 24 24	 mov	 edx, DWORD PTR $T284475[esp+28]
  0007b	83 7a 78 06	 cmp	 DWORD PTR [edx+120], 6
  0007f	74 0b		 je	 SHORT $L275519
$L284508:
  00081	5e		 pop	 esi

; 3479 : 		return( -1 );

  00082	83 c8 ff	 or	 eax, -1
  00085	5b		 pop	 ebx

; 3530 : }

  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	c2 0c 00	 ret	 12			; 0000000cH
$L275519:

; 3480 : 
; 3481 : #ifdef __CLIENT
; 3482 : 	//        
; 3483 : 	CWorld *pWorld = GetWorld();
; 3484 : 	D3DXVECTOR3 vStart = GetPos();				vStart.y += 0.5f;
; 3485 : 	D3DXVECTOR3 vEnd   = pTargetObj->GetPos();	vEnd.y += 0.5f;
; 3486 : 
; 3487 : 	if( pWorld->IntersectObjLine( NULL, vStart, vEnd, FALSE, FALSE ) )
; 3488 : 	{
; 3489 : 		g_WndMng.PutString( prj.GetText( TID_GAME_BLOCKTARGETING ), NULL, prj.GetTextColor( TID_GAME_BLOCKTARGETING ) );
; 3490 : 		return -1;
; 3491 : 	}
; 3492 : #endif  // CLIENT
; 3493 : 
; 3494 : 	OBJID	idTarget = ((CCtrl*)pTargetObj)->GetId();
; 3495 : 
; 3496 : 	int nError;
; 3497 : 	if( ( nError = m_pActMover->SendActMsg( OBJMSG_ATK_MAGIC1, idTarget ) ) == 1 )	//   .

  0008c	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00092	8b 01		 mov	 eax, DWORD PTR [ecx]
  00094	55		 push	 ebp
  00095	57		 push	 edi
  00096	8b bb bc 01 00
	00		 mov	 edi, DWORD PTR [ebx+444]
  0009c	6a 00		 push	 0
  0009e	6a 00		 push	 0
  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	57		 push	 edi
  000a5	6a 24		 push	 36			; 00000024H
  000a7	ff 50 04	 call	 DWORD PTR [eax+4]
  000aa	8b e8		 mov	 ebp, eax
  000ac	83 fd 01	 cmp	 ebp, 1
  000af	0f 85 a4 00 00
	00		 jne	 $L275523

; 3498 : 	{
; 3499 : 		if( m_pActMover->IsFly() == FALSE )		

  000b5	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  000bb	f6 41 08 08	 test	 BYTE PTR [ecx+8], 8
  000bf	75 2d		 jne	 SHORT $L275524

; 3500 : 			SetAngle( GetDegree(pTargetObj->GetPos(), GetPos()) );		//   .

  000c1	8d 54 24 10	 lea	 edx, DWORD PTR $T284409[esp+40]
  000c5	52		 push	 edx
  000c6	8b ce		 mov	 ecx, esi
  000c8	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  000cd	50		 push	 eax
  000ce	8d 44 24 20	 lea	 eax, DWORD PTR $T284410[esp+44]
  000d2	50		 push	 eax
  000d3	8b cb		 mov	 ecx, ebx
  000d5	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?GetDegree@@YAMABUD3DXVECTOR3@@0@Z ; GetDegree
  000e0	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  000e4	83 c4 04	 add	 esp, 4
  000e7	8b ce		 mov	 ecx, esi
  000e9	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle
$L275524:

; 3501 : 		SetActParam( OBJACT_MAGIC_ATTACK, idTarget, nMagicPower );		//    

  000ee	8b 5c 24 30	 mov	 ebx, DWORD PTR _nMagicPower$[esp+36]
  000f2	6a 00		 push	 0
  000f4	53		 push	 ebx
  000f5	57		 push	 edi
  000f6	6a 02		 push	 2
  000f8	8b ce		 mov	 ecx, esi
  000fa	e8 00 00 00 00	 call	 ?SetActParam@CMover@@AAEXW4OBJACT@@HHH@Z ; CMover::SetActParam

; 3502 : 		
; 3503 : #ifdef __CLIENT	
; 3504 : 		if( nMagicPower >= 1 )	//  2    .
; 3505 : 		{
; 3506 : 			if( g_WndMng.m_pWndTaskBar->m_nActionPoint < 100 )
; 3507 : 				g_WndMng.m_pWndTaskBar->m_nActionPoint ++;
; 3508 : 		}
; 3509 : #endif
; 3510 : 		
; 3511 : #ifdef __WORLDSERVER
; 3512 : 		if( IsPlayer() )

  000ff	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00105	85 c0		 test	 eax, eax
  00107	74 17		 je	 SHORT $L275529

; 3513 : 		{
; 3514 : 			if( nMagicPower >= 1 && ((CUser*)this)->m_playTaskBar.m_nActionPoint < 100 )	// 2   .

  00109	83 fb 01	 cmp	 ebx, 1
  0010c	7c 12		 jl	 SHORT $L275529
  0010e	8b 86 40 95 00
	00		 mov	 eax, DWORD PTR [esi+38208]
  00114	83 f8 64	 cmp	 eax, 100		; 00000064H
  00117	7d 07		 jge	 SHORT $L275529

; 3515 : 				((CUser*)this)->m_playTaskBar.m_nActionPoint ++;

  00119	40		 inc	 eax
  0011a	89 86 40 95 00
	00		 mov	 DWORD PTR [esi+38208], eax
$L275529:

; 3516 : 		}
; 3517 : 		if( nMagicPower == 3 )		// 4   5 

  00120	83 fb 03	 cmp	 ebx, 3
  00123	75 1c		 jne	 SHORT $L275531

; 3518 : 			IncManaPoint( -GetReqMp( pItemProp->dwReqMp ) );	

  00125	8b 4c 24 2c	 mov	 ecx, DWORD PTR $T284475[esp+36]
  00129	8b 91 a8 01 00
	00		 mov	 edx, DWORD PTR [ecx+424]
  0012f	52		 push	 edx
  00130	8b ce		 mov	 ecx, esi
  00132	e8 00 00 00 00	 call	 ?GetReqMp@CMover@@QAEHH@Z ; CMover::GetReqMp
  00137	f7 d8		 neg	 eax
  00139	50		 push	 eax
  0013a	8b ce		 mov	 ecx, esi
  0013c	e8 00 00 00 00	 call	 ?IncManaPoint@CMover@@QAEXH@Z ; CMover::IncManaPoint
$L275531:

; 3519 : 		g_UserMng.AddMagicAttack( this, OBJMSG_ATK_MAGIC1, idTarget, 0, 0, nMagicPower, idSfxHit );

  00141	8b 44 24 34	 mov	 eax, DWORD PTR _idSfxHit$[esp+36]
  00145	50		 push	 eax
  00146	53		 push	 ebx
  00147	6a 00		 push	 0
  00149	6a 00		 push	 0
  0014b	57		 push	 edi
  0014c	6a 24		 push	 36			; 00000024H
  0014e	56		 push	 esi
  0014f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00154	e8 00 00 00 00	 call	 ?AddMagicAttack@CUserMng@@QAEXPAVCMover@@KKHHHH@Z ; CUserMng::AddMagicAttack
$L275523:
  00159	5f		 pop	 edi

; 3520 : #else	// __WORLDSERVER
; 3521 : #ifdef __CLIENT
; 3522 : 		if( IsActiveMover() ) {
; 3523 : 			SetActParam( OBJACT_MAGIC_ATTACK, idTarget, nMagicPower );	//   
; 3524 : 			g_DPlay.SendMagicAttack( OBJMSG_ATK_MAGIC1, ( (CCtrl*)pTargetObj )->GetId(), 0, 0, nMagicPower, m_idSfxHit );
; 3525 : 		}
; 3526 : #endif	// __CLIENT
; 3527 : #endif	// __WORLDSERVER
; 3528 : 	}
; 3529 : 	return( nError );

  0015a	8b c5		 mov	 eax, ebp
  0015c	5d		 pop	 ebp
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx

; 3530 : }

  0015f	83 c4 18	 add	 esp, 24			; 00000018H
  00162	c2 0c 00	 ret	 12			; 0000000cH
?DoAttackMagic@CMover@@QAEHPAVCObj@@HH@Z ENDP		; CMover::DoAttackMagic
_TEXT	ENDS
PUBLIC	??_C@_0CG@EOHFKLIK@DoAttackSP?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L?5NU@ ; `string'
PUBLIC	??_C@_0DJ@FIKMOPND@DoAttackSP?5?3?5?$CFs?$MA?G?5?$LA?x?$LA?$NN?$CFd?$MA?G?5dwUse@ ; `string'
PUBLIC	?DoAttackSP@CMover@@QAEHPAVCObj@@K@Z		; CMover::DoAttackSP
EXTRN	?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z:NEAR ; CUserMng::AddAttackSP
;	COMDAT ??_C@_0CG@EOHFKLIK@DoAttackSP?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L?5NU@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
CONST	SEGMENT
??_C@_0CG@EOHFKLIK@DoAttackSP?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L?5NU@ DB 'D'
	DB	'oAttackSP : %s ', 0c0H, 0c7H, ' ItemProp', 0c0H, 0ccH, ' NULL'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FIKMOPND@DoAttackSP?5?3?5?$CFs?$MA?G?5?$LA?x?$LA?$NN?$CFd?$MA?G?5dwUse@
CONST	SEGMENT
??_C@_0DJ@FIKMOPND@DoAttackSP?5?3?5?$CFs?$MA?G?5?$LA?x?$LA?$NN?$CFd?$MA?G?5dwUse@ DB 'D'
	DB	'oAttackSP : %s', 0c0H, 0c7H, ' ', 0b0H, 0f8H, 0b0H, 0ddH, '%d'
	DB	0c0H, 0c7H, ' dwUseMotion', 0c0H, 0ccH, ' ', 0c1H, 0f6H, 0c1H, 0a4H
	DB	0b5H, 0c7H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0beH, 0d2H, 0b4H, 0d9H
	DB	00H						; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoAttackSP@CMover@@QAEHPAVCObj@@K@Z
_TEXT	SEGMENT
$T284512 = -24						; size = 12
$T284513 = -12						; size = 12
_pTargetObj$ = 8					; size = 4
_dwItemID$ = 12						; size = 4
?DoAttackSP@CMover@@QAEHPAVCObj@@K@Z PROC NEAR		; CMover::DoAttackSP, COMDAT
; _this$ = ecx

; 3635 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3636 : 	if( IsInvalidObj(pTargetObj) )

  00005	8b 7c 24 24	 mov	 edi, DWORD PTR _pTargetObj$[esp+28]
  00009	85 ff		 test	 edi, edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	74 06		 je	 SHORT $L284531
  0000f	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  00013	74 0d		 je	 SHORT $L275569
$L284531:
  00015	5f		 pop	 edi

; 3637 : 		return( -1 );

  00016	b8 ff ff ff ff	 mov	 eax, -1
  0001b	5e		 pop	 esi

; 3685 : }

  0001c	83 c4 18	 add	 esp, 24			; 00000018H
  0001f	c2 08 00	 ret	 8
$L275569:
  00022	53		 push	 ebx

; 3638 : 	
; 3639 : 	ItemProp* pItemProp;
; 3640 : 	if( dwItemID == NULL_ID || dwItemID == 0 )	

  00023	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwItemID$[esp+32]
  00027	83 fb ff	 cmp	 ebx, -1
  0002a	74 11		 je	 SHORT $L275572
  0002c	85 db		 test	 ebx, ebx
  0002e	74 0d		 je	 SHORT $L275572

; 3642 : 	else
; 3643 : 		pItemProp = prj.GetItemProp( dwItemID );	//      (  )

  00030	53		 push	 ebx
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00036	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp
  0003b	eb 09		 jmp	 SHORT $L275573
$L275572:

; 3641 : 		pItemProp = GetActiveHandItemProp();	//     ( )

  0003d	6a 0a		 push	 10			; 0000000aH
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?GetActiveHandItemProp@CMover@@QAEPAUItemProp@@H@Z ; CMover::GetActiveHandItemProp
$L275573:

; 3644 : 	if( pItemProp == NULL )

  00046	85 c0		 test	 eax, eax
  00048	75 20		 jne	 SHORT $L275574

; 3645 : 	{
; 3646 : 		Error( "DoAttackSP : %s  ItemProp NULL %d", m_szName, (int)dwItemID );

  0004a	53		 push	 ebx
  0004b	81 c6 90 16 00
	00		 add	 esi, 5776		; 00001690H
  00051	56		 push	 esi
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@EOHFKLIK@DoAttackSP?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L?5NU@
  00057	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	5b		 pop	 ebx
  00060	5f		 pop	 edi

; 3647 : 		return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	5e		 pop	 esi

; 3685 : }

  00064	83 c4 18	 add	 esp, 24			; 00000018H
  00067	c2 08 00	 ret	 8
$L275574:

; 3648 : 	}
; 3649 : 
; 3650 : 	DWORD dwUseMotion = pItemProp->dwUseMotion;

  0006a	8b 90 e8 01 00
	00		 mov	 edx, DWORD PTR [eax+488]

; 3651 : 	if( dwUseMotion == NULL_ID )

  00070	83 fa ff	 cmp	 edx, -1
  00073	75 1c		 jne	 SHORT $L275578

; 3652 : 	{
; 3653 : 		Error( "DoAttackSP : %s %d dwUseMotion  ", m_szName, pItemProp->dwID );

  00075	8b 00		 mov	 eax, DWORD PTR [eax]
  00077	50		 push	 eax
  00078	8d 8e 90 16 00
	00		 lea	 ecx, DWORD PTR [esi+5776]
  0007e	51		 push	 ecx
  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DJ@FIKMOPND@DoAttackSP?5?3?5?$CFs?$MA?G?5?$LA?x?$LA?$NN?$CFd?$MA?G?5dwUse@
  00084	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3654 : 		dwUseMotion = MTI_ATK1;		//         .

  0008c	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
$L275578:

; 3655 : 	}
; 3656 : 	
; 3657 : 	OBJID	idTarget = ((CCtrl*)pTargetObj)->GetId();

  00091	8b bf bc 01 00
	00		 mov	 edi, DWORD PTR [edi+444]

; 3658 : 	
; 3659 : 	int nError;
; 3660 : 	if( ( nError = m_pActMover->SendActMsg( OBJMSG_SP_ATK1, idTarget, (int)dwItemID, (int)dwUseMotion ) ) == 1 )	// .

  00097	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	55		 push	 ebp
  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	52		 push	 edx
  000a5	53		 push	 ebx
  000a6	57		 push	 edi
  000a7	6a 21		 push	 33			; 00000021H
  000a9	ff 50 04	 call	 DWORD PTR [eax+4]
  000ac	8b e8		 mov	 ebp, eax
  000ae	83 fd 01	 cmp	 ebp, 1
  000b1	75 73		 jne	 SHORT $L275585

; 3661 : 	{
; 3662 : 		SetAngle( GetDegree(pTargetObj->GetPos(), GetPos()) );		//   .

  000b3	8d 8e 60 01 00
	00		 lea	 ecx, DWORD PTR [esi+352]
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000be	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000c1	89 54 24 10	 mov	 DWORD PTR $T284512[esp+40], edx
  000c5	8b 54 24 2c	 mov	 edx, DWORD PTR _pTargetObj$[esp+36]
  000c9	81 c2 60 01 00
	00		 add	 edx, 352		; 00000160H
  000cf	89 44 24 14	 mov	 DWORD PTR $T284512[esp+44], eax
  000d3	8b 02		 mov	 eax, DWORD PTR [edx]
  000d5	89 4c 24 18	 mov	 DWORD PTR $T284512[esp+48], ecx
  000d9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000dc	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000df	89 44 24 1c	 mov	 DWORD PTR $T284513[esp+40], eax
  000e3	8d 44 24 10	 lea	 eax, DWORD PTR $T284512[esp+40]
  000e7	89 4c 24 20	 mov	 DWORD PTR $T284513[esp+44], ecx
  000eb	50		 push	 eax
  000ec	8d 4c 24 20	 lea	 ecx, DWORD PTR $T284513[esp+44]
  000f0	51		 push	 ecx
  000f1	89 54 24 2c	 mov	 DWORD PTR $T284513[esp+56], edx
  000f5	e8 00 00 00 00	 call	 ?GetDegree@@YAMABUD3DXVECTOR3@@0@Z ; GetDegree
  000fa	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  000fe	83 c4 04	 add	 esp, 4
  00101	8b ce		 mov	 ecx, esi
  00103	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle

; 3663 : 		SetActParam( OBJACT_SP_ATTACK, idTarget, (int)dwItemID );	//   

  00108	6a 00		 push	 0
  0010a	53		 push	 ebx
  0010b	57		 push	 edi
  0010c	6a 04		 push	 4
  0010e	8b ce		 mov	 ecx, esi
  00110	e8 00 00 00 00	 call	 ?SetActParam@CMover@@AAEXW4OBJACT@@HHH@Z ; CMover::SetActParam

; 3664 : 		
; 3665 : #ifdef __WORLDSERVER
; 3666 : 		g_UserMng.AddAttackSP( this, OBJMSG_SP_ATK1, idTarget, dwItemID, 0 );

  00115	6a 00		 push	 0
  00117	53		 push	 ebx
  00118	57		 push	 edi
  00119	6a 21		 push	 33			; 00000021H
  0011b	56		 push	 esi
  0011c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00121	e8 00 00 00 00	 call	 ?AddAttackSP@CUserMng@@QAEXPAVCMover@@KKHH@Z ; CUserMng::AddAttackSP
$L275585:

; 3667 : #else	// __WORLDSERVER
; 3668 : 	
; 3669 : #if 0 //2009_12_18    :      
; 3670 : 		DWORD dwSfxObj = pItemProp->dwSfxObj3;		//    3.
; 3671 : 		if( dwSfxObj != NULL_ID )
; 3672 : 			CreateSfx( D3DDEVICE, dwSfxObj, GetPos(), GetId(), D3DXVECTOR3(0,0,0), idTarget );
; 3673 : #endif 
; 3674 : 
; 3675 : 	//gmpbigsun:     effect
; 3676 : 	DWORD dwSfxObj = pItemProp->dwSfxObj;
; 3677 : 	if( NULL_ID != dwSfxObj )
; 3678 : 		CreateSfx( D3DDEVICE, dwSfxObj, GetPos() );
; 3679 : 
; 3680 : 		
; 3681 : #endif	// __WORLDSERVER
; 3682 : 	}
; 3683 : 
; 3684 : 	return( nError );

  00126	8b c5		 mov	 eax, ebp
  00128	5d		 pop	 ebp
  00129	5b		 pop	 ebx
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi

; 3685 : }

  0012c	83 c4 18	 add	 esp, 24			; 00000018H
  0012f	c2 08 00	 ret	 8
?DoAttackSP@CMover@@QAEHPAVCObj@@K@Z ENDP		; CMover::DoAttackSP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BKJEKCBD@DoAttackMelee?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L@ ; `string'
PUBLIC	?DoAttackMelee@CMover@@QAEHPAV1@W4OBJMSG@@K@Z	; CMover::DoAttackMelee
EXTRN	?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z:NEAR ; CUserMng::AddMeleeAttack
EXTRN	?GetName@CMover@@QAEPBDH@Z:NEAR			; CMover::GetName
;	COMDAT ??_C@_0CJ@BKJEKCBD@DoAttackMelee?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ctrl.h
CONST	SEGMENT
??_C@_0CJ@BKJEKCBD@DoAttackMelee?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L@ DB 'D'
	DB	'oAttackMelee : %s ', 0c0H, 0c7H, ' ItemProp', 0c0H, 0ccH, ' N'
	DB	'ULL %d', 00H				; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoAttackMelee@CMover@@QAEHPAV1@W4OBJMSG@@K@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_dwMsg$ = 12						; size = 4
_dwItemID$ = 16						; size = 4
?DoAttackMelee@CMover@@QAEHPAV1@W4OBJMSG@@K@Z PROC NEAR	; CMover::DoAttackMelee, COMDAT
; _this$ = ecx

; 3688 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 3689 : 	SendActMsg( OBJMSG_STOP );		//  .

  00004	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0000a	85 c0		 test	 eax, eax
  0000c	74 13		 je	 SHORT $L284551
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	8b c8		 mov	 ecx, eax
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 00		 push	 0
  0001c	6a 06		 push	 6
  0001e	ff 50 04	 call	 DWORD PTR [eax+4]
$L284551:

; 3690 : 
; 3691 : 	if( IsInvalidObj(pTarget) )

  00021	8b 5c 24 0c	 mov	 ebx, DWORD PTR _pTarget$[esp+4]
  00025	85 db		 test	 ebx, ebx
  00027	74 06		 je	 SHORT $L284571
  00029	f6 43 04 01	 test	 BYTE PTR [ebx+4], 1
  0002d	74 07		 je	 SHORT $L275595
$L284571:
  0002f	5e		 pop	 esi

; 3692 : 		return 0;

  00030	33 c0		 xor	 eax, eax
  00032	5b		 pop	 ebx

; 3739 : }	

  00033	c2 0c 00	 ret	 12			; 0000000cH
$L275595:
  00036	57		 push	 edi

; 3693 : 	
; 3694 : 	ItemProp* pItemProp;
; 3695 : 	if( dwItemID == NULL_ID || dwItemID == 0 )	

  00037	8b 7c 24 18	 mov	 edi, DWORD PTR _dwItemID$[esp+8]
  0003b	83 ff ff	 cmp	 edi, -1
  0003e	74 11		 je	 SHORT $L275598
  00040	85 ff		 test	 edi, edi
  00042	74 0d		 je	 SHORT $L275598

; 3697 : 	else
; 3698 : 		pItemProp = prj.GetItemProp( dwItemID );	//      (  )

  00044	57		 push	 edi
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0004a	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp
  0004f	eb 09		 jmp	 SHORT $L275599
$L275598:

; 3696 : 		pItemProp = GetActiveHandItemProp();	//     ( )

  00051	6a 0a		 push	 10			; 0000000aH
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?GetActiveHandItemProp@CMover@@QAEPAUItemProp@@H@Z ; CMover::GetActiveHandItemProp
$L275599:

; 3699 : 	if( pItemProp == NULL )

  0005a	85 c0		 test	 eax, eax
  0005c	75 1f		 jne	 SHORT $L275600

; 3700 : 	{
; 3701 : 		Error( "DoAttackMelee : %s  ItemProp NULL %d", GetName(), (int)dwItemID );

  0005e	57		 push	 edi
  0005f	50		 push	 eax
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@BKJEKCBD@DoAttackMelee?5?3?5?$CFs?5?$MA?G?5ItemProp?$MA?L@
  0006d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 3702 : 		return FALSE;

  00077	33 c0		 xor	 eax, eax
  00079	5b		 pop	 ebx

; 3739 : }	

  0007a	c2 0c 00	 ret	 12			; 0000000cH
$L275600:

; 3703 : 	}
; 3704 : 
; 3705 : 	//  .
; 3706 : 	int nError	= SendActMsg( dwMsg, pTarget->GetId(), MAKELONG( 0, 0 ), MAKELONG( 0, 0 ) );

  0007d	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00083	85 c9		 test	 ecx, ecx
  00085	8b 83 bc 01 00
	00		 mov	 eax, DWORD PTR [ebx+444]
  0008b	74 4e		 je	 SHORT $L284593
  0008d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008f	55		 push	 ebp
  00090	8b 6c 24 18	 mov	 ebp, DWORD PTR _dwMsg$[esp+12]
  00094	6a 00		 push	 0
  00096	6a 00		 push	 0
  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	50		 push	 eax
  0009d	55		 push	 ebp
  0009e	ff 52 04	 call	 DWORD PTR [edx+4]
  000a1	8b f8		 mov	 edi, eax

; 3707 : 	if( nError > 0 )

  000a3	85 ff		 test	 edi, edi
  000a5	7e 33		 jle	 SHORT $L284595

; 3708 : 	{
; 3709 : 		SetActParam( OBJACT_MELEE_ATTACK, pTarget->GetId(), (int)dwItemID );	// OnAttackMelee    .

  000a7	8b 44 24 1c	 mov	 eax, DWORD PTR _dwItemID$[esp+12]
  000ab	8b 8b bc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+444]
  000b1	6a 00		 push	 0
  000b3	50		 push	 eax
  000b4	51		 push	 ecx
  000b5	6a 01		 push	 1
  000b7	8b ce		 mov	 ecx, esi
  000b9	e8 00 00 00 00	 call	 ?SetActParam@CMover@@AAEXW4OBJACT@@HHH@Z ; CMover::SetActParam

; 3710 : 
; 3711 : #ifdef __CLIENT
; 3712 : #ifdef __HACK_1023
; 3713 : 		ItemProp* pHandItemProp		= GetActiveHandItemProp();
; 3714 : 		FLOAT fVal	= pHandItemProp? pHandItemProp->fAttackSpeed: 0.0F;
; 3715 : 		g_DPlay.SendMeleeAttack( dwMsg, pTarget->GetId(), MAKELONG( 0, 0 ), MAKELONG( 0, (WORD)nError ), fVal );
; 3716 : #else	// __HACK_1023
; 3717 : 		g_DPlay.SendMeleeAttack( dwMsg, pTarget->GetId(), MAKELONG( 0, 0 ), MAKELONG( 0, (WORD)nError ) );
; 3718 : #endif	// __HACK_1023
; 3719 : 		if( IsActiveMover() )
; 3720 : 		{
; 3721 : 			PlayCombatMusic();
; 3722 : #if __VER < 11 // __REMOVE_ENDURANCE
; 3723 : 			CItemElem* pWeapon	= GetWeaponItem();
; 3724 : 			if( pWeapon )
; 3725 : 			{
; 3726 : 				ItemProp* pItemProp		= pWeapon->GetProp();
; 3727 : 				if( pItemProp )
; 3728 : 					if( ( ( pWeapon->m_nHitPoint * 100 ) / pItemProp->dwEndurance ) == 0 )
; 3729 : 						g_WndMng.PutString( prj.GetText( TID_GAME_WASTEENDURANCE ), NULL, prj.GetTextColor( TID_GAME_WASTEENDURANCE ) );
; 3730 : 			}
; 3731 : #endif // __REMOVE_ENDURANCE
; 3732 : 		}
; 3733 : #else	// __CLIENT
; 3734 : 		g_UserMng.AddMeleeAttack( this, dwMsg, pTarget->GetId(), MAKELONG( 0, 0 ), MAKELONG( 0, (WORD)nError ) );

  000be	8b 83 bc 01 00
	00		 mov	 eax, DWORD PTR [ebx+444]
  000c4	0f b7 d7	 movzx	 edx, di
  000c7	c1 e2 10	 shl	 edx, 16			; 00000010H
  000ca	52		 push	 edx
  000cb	6a 00		 push	 0
  000cd	50		 push	 eax
  000ce	55		 push	 ebp
  000cf	56		 push	 esi
  000d0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000d5	e8 00 00 00 00	 call	 ?AddMeleeAttack@CUserMng@@QAEXPAVCMover@@KKHH@Z ; CUserMng::AddMeleeAttack
$L284595:
  000da	5d		 pop	 ebp
$L284593:
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi

; 3735 : #endif	// __CLIENT
; 3736 : 	}
; 3737 : 
; 3738 : 	return TRUE;	

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	5b		 pop	 ebx

; 3739 : }	

  000e3	c2 0c 00	 ret	 12			; 0000000cH
?DoAttackMelee@CMover@@QAEHPAV1@W4OBJMSG@@K@Z ENDP	; CMover::DoAttackMelee
_TEXT	ENDS
PUBLIC	??_C@_0CL@JELFJLED@CMover?3?3SendDamageAround?5?3?5D?3?$CFs?5@ ; `string'
PUBLIC	??_C@_0DL@FEJEHPAL@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LN@ ; `string'
PUBLIC	??_C@_0DN@BLLPBDJB@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LO@ ; `string'
PUBLIC	__real@40800000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@3f800000
PUBLIC	?SendDamageAround@CMover@@QAEXHPAV1@HHMMM@Z	; CMover::SendDamageAround
EXTRN	?SendDamageForce@CActionMover@@QAEHKKHH@Z:NEAR	; CActionMover::SendDamageForce
EXTRN	?GetLinkWidth@CLayeredLinkMap@@QAEHKHH@Z:NEAR	; CLayeredLinkMap::GetLinkWidth
EXTRN	?GetObj@CLayeredLinkMap@@QAEPAPAVCObj@@KKH@Z:NEAR ; CLayeredLinkMap::GetObj
EXTRN	?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z:NEAR	; CLayeredLinkMap::GetMaxLinkLevel
;	COMDAT __real@40800000
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT ??_C@_0CL@JELFJLED@CMover?3?3SendDamageAround?5?3?5D?3?$CFs?5@
CONST	SEGMENT
??_C@_0CL@JELFJLED@CMover?3?3SendDamageAround?5?3?5D?3?$CFs?5@ DB 'CMover'
	DB	'::SendDamageAround : D:%s A:%s %d %f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FEJEHPAL@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LN@
CONST	SEGMENT
??_C@_0DL@FEJEHPAL@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LN@ DB 'CMo'
	DB	'ver::SendDamageAround : %s. ', 0bdH, 0baH, 0c5H, 0b3H, '(%d)', 0c0H
	DB	0c7H, ' ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH, 0c6H, 0bcH, 0b0H
	DB	0a1H, ' ', 0beH, 0f7H, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BLLPBDJB@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LO@
CONST	SEGMENT
??_C@_0DN@BLLPBDJB@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LO@ DB 'CMo'
	DB	'ver::SendDamageAround : %s. ', 0beH, 0c6H, 0c0H, 0ccH, 0c5H, 0dbH
	DB	'(%d)', 0c0H, 0c7H, ' ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH, 0c6H
	DB	0bcH, 0b0H, 0a1H, ' ', 0beH, 0f7H, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?SendDamageAround@CMover@@QAEXHPAV1@HHMMM@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
tv1496 = -124						; size = 4
_nRange$ = -124						; size = 4
tv1342 = -120						; size = 4
__i$275740 = -120					; size = 4
tv1492 = -116						; size = 4
__nLinkXMin$275678 = -116				; size = 4
tv1388 = -112						; size = 4
__nLinkXMin$275732 = -112				; size = 4
__nX$275682 = -112					; size = 4
tv1446 = -108						; size = 4
__i$275686 = -108					; size = 4
tv845 = -104						; size = 4
tv851 = -100						; size = 4
_pProp$ = -96						; size = 4
tv640 = -92						; size = 4
__nLinkXMax$275680 = -92				; size = 4
___limit$275706 = -88					; size = 4
tv239 = -88						; size = 4
tv416 = -84						; size = 4
___limit$275760 = -84					; size = 4
tv369 = -80						; size = 4
__nLinkXMax$275734 = -80				; size = 4
__nX$275736 = -80					; size = 4
__pObjs$275690 = -80					; size = 4
__pObjs$275744 = -76					; size = 4
__nLinkX$275670 = -76					; size = 4
tv1010 = -72						; size = 4
__nLinkZ$275672 = -72					; size = 4
tv1005 = -68						; size = 4
tv854 = -68						; size = 4
tv1000 = -64						; size = 4
tv859 = -64						; size = 4
tv995 = -60						; size = 4
tv864 = -60						; size = 4
tv869 = -56						; size = 4
__nLinkZ$275726 = -56					; size = 4
tv1392 = -52						; size = 4
__nLinkX$275724 = -52					; size = 4
_vDist$ = -48						; size = 12
_vPos$ = -36						; size = 12
$T284602 = -24						; size = 12
$T284599 = -24						; size = 12
$T284601 = -12						; size = 12
$T284600 = -12						; size = 12
_nDmgType$ = 8						; size = 4
_pAttacker$ = 12					; size = 4
_nApplyType$ = 16					; size = 4
_nAttackID$ = 20					; size = 4
_fRange$ = 24						; size = 4
_fTargetRatio$ = 28					; size = 4
_fAroundRatio$ = 32					; size = 4
?SendDamageAround@CMover@@QAEXHPAV1@HHMMM@Z PROC NEAR	; CMover::SendDamageAround, COMDAT
; _this$ = ecx

; 3793 : {

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H

; 3794 : #ifdef __WORLDSERVER
; 3795 : 	int nRange	= 4;	// 4m
; 3796 : 	float fDistSq;
; 3797 : 	CObj* pObj;
; 3798 : 	CMover *pTarget;
; 3799 : 	D3DXVECTOR3 vPos = GetPos();
; 3800 : 	D3DXVECTOR3 vDist;
; 3801 : 
; 3802 : 	if( fRange <= 4.0f )

  00006	d9 84 24 94 00
	00 00		 fld	 DWORD PTR _fRange$[esp+124]
  0000d	53		 push	 ebx
  0000e	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@40800000
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	8d 86 60 01 00
	00		 lea	 eax, DWORD PTR [esi+352]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00025	89 44 24 6c	 mov	 DWORD PTR _vPos$[esp+144], eax
  00029	df e0		 fnstsw	 ax
  0002b	57		 push	 edi
  0002c	f6 c4 41	 test	 ah, 65			; 00000041H
  0002f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+140], esi
  00033	89 4c 24 68	 mov	 DWORD PTR _vPos$[esp+140], ecx
  00037	89 54 24 6c	 mov	 DWORD PTR _vPos$[esp+144], edx
  0003b	7a 07		 jp	 SHORT $L275651

; 3803 : 		nRange = 4;

  0003d	bb 04 00 00 00	 mov	 ebx, 4

; 3804 : 	else if( fRange <= 8.0f )

  00042	eb 39		 jmp	 SHORT $L284958
$L275651:
  00044	d9 84 24 a0 00
	00 00		 fld	 DWORD PTR _fRange$[esp+136]
  0004b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41000000
  00051	df e0		 fnstsw	 ax
  00053	f6 c4 41	 test	 ah, 65			; 00000041H
  00056	7a 07		 jp	 SHORT $L275653

; 3805 : 		nRange = 8;

  00058	bb 08 00 00 00	 mov	 ebx, 8

; 3806 : 	else if( fRange <= 16.0f )

  0005d	eb 1e		 jmp	 SHORT $L284958
$L275653:
  0005f	d9 84 24 a0 00
	00 00		 fld	 DWORD PTR _fRange$[esp+136]

; 3807 : 		nRange = 16;

  00066	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  0006b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41800000
  00071	df e0		 fnstsw	 ax
  00073	f6 c4 41	 test	 ah, 65			; 00000041H
  00076	7b 05		 jnp	 SHORT $L284958

; 3808 : 	else
; 3809 : 		nRange = 32;

  00078	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$L284958:

; 3810 : 	
; 3811 : 	if( fRange <= 0 )	//  0  .

  0007d	d9 84 24 a0 00
	00 00		 fld	 DWORD PTR _fRange$[esp+136]
  00084	8b bc 24 9c 00
	00 00		 mov	 edi, DWORD PTR _nAttackID$[esp+136]
  0008b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  00091	89 5c 24 10	 mov	 DWORD PTR _nRange$[esp+140], ebx
  00095	df e0		 fnstsw	 ax
  00097	f6 c4 41	 test	 ah, 65			; 00000041H
  0009a	7a 34		 jp	 SHORT $L284956

; 3812 : 		Error( "CMover::SendDamageAround : D:%s A:%s %d %f", GetName(), pAttacker->GetName(), nAttackID, fRange );

  0009c	d9 84 24 a0 00
	00 00		 fld	 DWORD PTR _fRange$[esp+136]
  000a3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _pAttacker$[esp+136]
  000aa	83 ec 08	 sub	 esp, 8
  000ad	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b0	57		 push	 edi
  000b1	6a 00		 push	 0
  000b3	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  000b8	50		 push	 eax
  000b9	6a 00		 push	 0
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  000c2	50		 push	 eax
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CL@JELFJLED@CMover?3?3SendDamageAround?5?3?5D?3?$CFs?5@
  000c8	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000cd	83 c4 18	 add	 esp, 24			; 00000018H
$L284956:

; 3813 : 
; 3814 : 	ItemProp* pProp;
; 3815 : 	if( nDmgType == AF_MAGICSKILL )

  000d0	83 bc 24 90 00
	00 00 20	 cmp	 DWORD PTR _nDmgType$[esp+136], 32 ; 00000020H
  000d8	75 61		 jne	 SHORT $L284668

; 3816 : 	{
; 3817 : 		pProp = prj.GetSkillProp( nAttackID );		// UseSkill    

  000da	85 ff		 test	 edi, edi
  000dc	a1 80 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+640
  000e1	7c 40		 jl	 SHORT $L284633
  000e3	3b f8		 cmp	 edi, eax
  000e5	7d 3c		 jge	 SHORT $L284633
  000e7	72 04		 jb	 SHORT $L284643
  000e9	33 c0		 xor	 eax, eax
  000eb	eb 09		 jmp	 SHORT $L284642
$L284643:
  000ed	8b 0d 70 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+624
  000f3	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
$L284642:

; 3818 : 		if( pProp == NULL )

  000f6	85 c0		 test	 eax, eax
  000f8	89 44 24 2c	 mov	 DWORD PTR _pProp$[esp+140], eax
  000fc	0f 85 96 00 00
	00		 jne	 $L275665
$L284935:

; 3819 : 		{
; 3820 : 			Error( "CMover::SendDamageAround : %s. (%d)  .", m_szName, nAttackID );

  00102	57		 push	 edi
  00103	81 c6 90 16 00
	00		 add	 esi, 5776		; 00001690H
  00109	56		 push	 esi
  0010a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@FEJEHPAL@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LN@
  0010f	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx

; 3907 : 	}
; 3908 : 		
; 3909 : #endif // WORLDSERVER		
; 3910 : } // SendDamageAround()

  0011a	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00120	c2 1c 00	 ret	 28			; 0000001cH

; 3816 : 	{
; 3817 : 		pProp = prj.GetSkillProp( nAttackID );		// UseSkill    

$L284633:
  00123	57		 push	 edi
  00124	50		 push	 eax
  00125	6a 00		 push	 0
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  0012c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00131	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00136	83 c4 14	 add	 esp, 20			; 00000014H

; 3818 : 		if( pProp == NULL )

  00139	eb c7		 jmp	 SHORT $L284935

; 3821 : 			return;	// property not found
; 3822 : 		}
; 3823 : 	} else
; 3824 : 	{
; 3825 : 		pProp = prj.GetItemProp( nAttackID );		//  

$L284668:
  0013b	85 ff		 test	 edi, edi
  0013d	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  00142	7c 3c		 jl	 SHORT $L284672
  00144	3b f8		 cmp	 edi, eax
  00146	7d 38		 jge	 SHORT $L284672
  00148	72 04		 jb	 SHORT $L284684
  0014a	33 c0		 xor	 eax, eax
  0014c	eb 09		 jmp	 SHORT $L284683
$L284684:
  0014e	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  00154	8b 04 ba	 mov	 eax, DWORD PTR [edx+edi*4]
$L284683:

; 3826 : 		if( pProp == NULL )

  00157	85 c0		 test	 eax, eax
  00159	89 44 24 2c	 mov	 DWORD PTR _pProp$[esp+140], eax
  0015d	75 39		 jne	 SHORT $L275665
$L284936:

; 3827 : 		{
; 3828 : 			Error( "CMover::SendDamageAround : %s. (%d)  .", m_szName, nAttackID );

  0015f	57		 push	 edi
  00160	81 c6 90 16 00
	00		 add	 esi, 5776		; 00001690H
  00166	56		 push	 esi
  00167	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@BLLPBDJB@CMover?3?3SendDamageAround?5?3?5?$CFs?4?5?$LO@
  0016c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00171	83 c4 0c	 add	 esp, 12			; 0000000cH
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx

; 3907 : 	}
; 3908 : 		
; 3909 : #endif // WORLDSERVER		
; 3910 : } // SendDamageAround()

  00177	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  0017d	c2 1c 00	 ret	 28			; 0000001cH

; 3821 : 			return;	// property not found
; 3822 : 		}
; 3823 : 	} else
; 3824 : 	{
; 3825 : 		pProp = prj.GetItemProp( nAttackID );		//  

$L284672:
  00180	57		 push	 edi
  00181	50		 push	 eax
  00182	6a 00		 push	 0
  00184	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00189	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0018e	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00193	83 c4 14	 add	 esp, 20			; 00000014H

; 3826 : 		if( pProp == NULL )

  00196	eb c7		 jmp	 SHORT $L284936
$L275665:

; 3829 : 			return;	// property not found
; 3830 : 		}
; 3831 : 	}
; 3832 : 	
; 3833 : 	BOOL	bDamage = FALSE;
; 3834 : 	BOOL	bTarget = FALSE;
; 3835 : 
; 3836 : 	if( nApplyType & OBJTYPE_PLAYER )	//   

  00198	f6 84 24 98 00
	00 00 01	 test	 BYTE PTR _nApplyType$[esp+136], 1
  001a0	55		 push	 ebp
  001a1	0f 84 d6 03 00
	00		 je	 $L284949

; 3837 : 	{
; 3838 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkPlayer, GetLayer() )

  001a7	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  001ad	db 40 14	 fild	 DWORD PTR [eax+20]
  001b0	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  001b6	d9 44 24 6c	 fld	 DWORD PTR _vPos$[esp+144]
  001ba	d8 c9		 fmul	 ST(0), ST(1)
  001bc	e8 00 00 00 00	 call	 __ftol2
  001c1	d8 4c 24 74	 fmul	 DWORD PTR _vPos$[esp+152]
  001c5	8b f8		 mov	 edi, eax
  001c7	89 7c 24 44	 mov	 DWORD PTR __nLinkX$275670[esp+144], edi
  001cb	e8 00 00 00 00	 call	 __ftol2
  001d0	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  001d6	8b e8		 mov	 ebp, eax
  001d8	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  001de	50		 push	 eax
  001df	6a 02		 push	 2
  001e1	83 c1 24	 add	 ecx, 36			; 00000024H
  001e4	89 6c 24 50	 mov	 DWORD PTR __nLinkZ$275672[esp+152], ebp
  001e8	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR __i$275686[esp+152], 0
  001f0	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  001f5	85 c0		 test	 eax, eax
  001f7	0f 8e 80 03 00
	00		 jle	 $L284949
  001fd	d9 44 24 6c	 fld	 DWORD PTR _vPos$[esp+144]
  00201	e8 00 00 00 00	 call	 __ftol2
  00206	d9 44 24 74	 fld	 DWORD PTR _vPos$[esp+152]
  0020a	89 44 24 28	 mov	 DWORD PTR tv845[esp+144], eax
  0020e	e8 00 00 00 00	 call	 __ftol2
  00213	89 44 24 2c	 mov	 DWORD PTR tv851[esp+144], eax
  00217	8b c7		 mov	 eax, edi
  00219	2b c3		 sub	 eax, ebx
  0021b	89 44 24 4c	 mov	 DWORD PTR tv854[esp+144], eax
  0021f	8b c5		 mov	 eax, ebp
  00221	2b c3		 sub	 eax, ebx
  00223	03 fb		 add	 edi, ebx
  00225	03 eb		 add	 ebp, ebx
  00227	89 44 24 50	 mov	 DWORD PTR tv859[esp+144], eax
  0022b	89 7c 24 54	 mov	 DWORD PTR tv864[esp+144], edi
  0022f	89 6c 24 58	 mov	 DWORD PTR tv869[esp+144], ebp
  00233	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$L275687:
  00240	8b 74 24 10	 mov	 esi, DWORD PTR _this$[esp+144]
  00244	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  0024a	8b 7c 24 24	 mov	 edi, DWORD PTR __i$275686[esp+144]
  0024e	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00254	50		 push	 eax
  00255	57		 push	 edi
  00256	6a 02		 push	 2
  00258	83 c1 24	 add	 ecx, 36			; 00000024H
  0025b	e8 00 00 00 00	 call	 ?GetLinkWidth@CLayeredLinkMap@@QAEHKHH@Z ; CLayeredLinkMap::GetLinkWidth
  00260	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00266	8b e8		 mov	 ebp, eax
  00268	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  0026e	50		 push	 eax
  0026f	57		 push	 edi
  00270	6a 02		 push	 2
  00272	83 c1 24	 add	 ecx, 36			; 00000024H
  00275	e8 00 00 00 00	 call	 ?GetObj@CLayeredLinkMap@@QAEPAPAVCObj@@KKH@Z ; CLayeredLinkMap::GetObj
  0027a	8b b6 6c 01 00
	00		 mov	 esi, DWORD PTR [esi+364]
  00280	89 44 24 40	 mov	 DWORD PTR __pObjs$275690[esp+144], eax
  00284	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00287	8b f8		 mov	 edi, eax
  00289	c1 e0 07	 shl	 eax, 7
  0028c	0f af fd	 imul	 edi, ebp
  0028f	99		 cdq
  00290	f7 ff		 idiv	 edi
  00292	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00295	0f af dd	 imul	 ebx, ebp
  00298	8b 6e 14	 mov	 ebp, DWORD PTR [esi+20]
  0029b	8b c8		 mov	 ecx, eax
  0029d	8b c5		 mov	 eax, ebp
  0029f	0f af c1	 imul	 eax, ecx
  002a2	99		 cdq
  002a3	2b c2		 sub	 eax, edx
  002a5	8b f0		 mov	 esi, eax
  002a7	8b 44 24 44	 mov	 eax, DWORD PTR __nLinkX$275670[esp+144]
  002ab	99		 cdq
  002ac	f7 f9		 idiv	 ecx
  002ae	8b 54 24 28	 mov	 edx, DWORD PTR tv845[esp+144]
  002b2	d1 fe		 sar	 esi, 1
  002b4	0f af c5	 imul	 eax, ebp
  002b7	0f af c1	 imul	 eax, ecx
  002ba	2b d0		 sub	 edx, eax
  002bc	33 c0		 xor	 eax, eax
  002be	3b d6		 cmp	 edx, esi
  002c0	0f 9f c0	 setg	 al
  002c3	89 44 24 20	 mov	 DWORD PTR __nX$275682[esp+144], eax
  002c7	8b 44 24 48	 mov	 eax, DWORD PTR __nLinkZ$275672[esp+144]
  002cb	99		 cdq
  002cc	f7 f9		 idiv	 ecx
  002ce	8b 54 24 2c	 mov	 edx, DWORD PTR tv851[esp+144]
  002d2	0f af c5	 imul	 eax, ebp
  002d5	0f af c1	 imul	 eax, ecx
  002d8	2b d0		 sub	 edx, eax
  002da	33 c0		 xor	 eax, eax
  002dc	3b d6		 cmp	 edx, esi
  002de	0f 9f c0	 setg	 al
  002e1	8b f0		 mov	 esi, eax
  002e3	8b 44 24 4c	 mov	 eax, DWORD PTR tv854[esp+144]
  002e7	99		 cdq
  002e8	f7 f9		 idiv	 ecx
  002ea	8b 54 24 20	 mov	 edx, DWORD PTR __nX$275682[esp+144]
  002ee	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  002f2	85 c0		 test	 eax, eax
  002f4	89 44 24 1c	 mov	 DWORD PTR __nLinkXMin$275678[esp+144], eax
  002f8	7d 08		 jge	 SHORT $L284952
  002fa	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __nLinkXMin$275678[esp+144], 0
$L284952:
  00302	8b 44 24 50	 mov	 eax, DWORD PTR tv859[esp+144]
  00306	99		 cdq
  00307	f7 f9		 idiv	 ecx
  00309	8d 6c 30 ff	 lea	 ebp, DWORD PTR [eax+esi-1]
  0030d	85 ed		 test	 ebp, ebp
  0030f	7d 02		 jge	 SHORT $L275695
  00311	33 ed		 xor	 ebp, ebp
$L275695:
  00313	8b 44 24 54	 mov	 eax, DWORD PTR tv864[esp+144]
  00317	99		 cdq
  00318	f7 f9		 idiv	 ecx
  0031a	03 44 24 20	 add	 eax, DWORD PTR __nX$275682[esp+144]
  0031e	3b c7		 cmp	 eax, edi
  00320	89 44 24 34	 mov	 DWORD PTR __nLinkXMax$275680[esp+144], eax
  00324	7c 07		 jl	 SHORT $L275696
  00326	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00329	89 44 24 34	 mov	 DWORD PTR __nLinkXMax$275680[esp+144], eax
$L275696:
  0032d	8b 44 24 58	 mov	 eax, DWORD PTR tv869[esp+144]
  00331	99		 cdq
  00332	f7 f9		 idiv	 ecx
  00334	03 c6		 add	 eax, esi
  00336	3b c3		 cmp	 eax, ebx
  00338	7c 03		 jl	 SHORT $L275697
  0033a	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
$L275697:
  0033d	3b e8		 cmp	 ebp, eax
  0033f	0f 8f 04 02 00
	00		 jg	 $L275688
  00345	8b 74 24 40	 mov	 esi, DWORD PTR __pObjs$275690[esp+144]
  00349	8b 9c 24 a0 00
	00 00		 mov	 ebx, DWORD PTR _nAttackID$[esp+140]
  00350	8b d5		 mov	 edx, ebp
  00352	0f af d7	 imul	 edx, edi
  00355	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  0035c	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _pAttacker$[esp+140]
  00363	89 4c 24 5c	 mov	 DWORD PTR tv1392[esp+144], ecx
  00367	8b 4c 24 1c	 mov	 ecx, DWORD PTR __nLinkXMin$275678[esp+144]
  0036b	03 d1		 add	 edx, ecx
  0036d	2b c5		 sub	 eax, ebp
  0036f	8b ac 24 94 00
	00 00		 mov	 ebp, DWORD PTR _nDmgType$[esp+140]
  00376	8d 14 96	 lea	 edx, DWORD PTR [esi+edx*4]
  00379	40		 inc	 eax
  0037a	89 54 24 20	 mov	 DWORD PTR tv1388[esp+144], edx
  0037e	89 44 24 40	 mov	 DWORD PTR tv369[esp+144], eax
$L275699:
  00382	8b 44 24 34	 mov	 eax, DWORD PTR __nLinkXMax$275680[esp+144]
  00386	3b c8		 cmp	 ecx, eax
  00388	0f 8f 9e 01 00
	00		 jg	 $L275700
  0038e	8b 54 24 20	 mov	 edx, DWORD PTR tv1388[esp+144]
  00392	2b c1		 sub	 eax, ecx
  00394	40		 inc	 eax
  00395	89 54 24 18	 mov	 DWORD PTR tv1342[esp+144], edx
  00399	89 44 24 3c	 mov	 DWORD PTR tv416[esp+144], eax
  0039d	8d 49 00	 npad	 3
$L275703:
  003a0	8b 44 24 18	 mov	 eax, DWORD PTR tv1342[esp+144]
  003a4	8b 30		 mov	 esi, DWORD PTR [eax]
  003a6	85 f6		 test	 esi, esi
  003a8	c7 44 24 38 e8
	03 00 00	 mov	 DWORD PTR ___limit$275706[esp+144], 1000 ; 000003e8H
  003b0	0f 84 58 01 00
	00		 je	 $L275704
$L275708:
  003b6	8b 44 24 38	 mov	 eax, DWORD PTR ___limit$275706[esp+144]
  003ba	8b c8		 mov	 ecx, eax
  003bc	48		 dec	 eax
  003bd	85 c9		 test	 ecx, ecx
  003bf	89 44 24 38	 mov	 DWORD PTR ___limit$275706[esp+144], eax
  003c3	0f 84 45 01 00
	00		 je	 $L275704

; 3839 : 		{
; 3840 : 			if( pObj->GetType() == OT_MOVER )

  003c9	83 be 70 01 00
	00 05		 cmp	 DWORD PTR [esi+368], 5
  003d0	0f 85 2a 01 00
	00		 jne	 $L284797

; 3841 : 			{
; 3842 : 				bDamage = TRUE;
; 3843 : 
; 3844 : 				if( bDamage )
; 3845 : 				{
; 3846 : 					vDist = pObj->GetPos() - vPos;		// this ->  

  003d6	8d 96 60 01 00
	00		 lea	 edx, DWORD PTR [esi+352]
  003dc	8b 02		 mov	 eax, DWORD PTR [edx]
  003de	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  003e1	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  003e4	89 44 24 78	 mov	 DWORD PTR $T284599[esp+144], eax
  003e8	d9 44 24 78	 fld	 DWORD PTR $T284599[esp+144]
  003ec	d8 64 24 6c	 fsub	 DWORD PTR _vPos$[esp+144]
  003f0	89 4c 24 7c	 mov	 DWORD PTR $T284599[esp+148], ecx
  003f4	89 94 24 80 00
	00 00		 mov	 DWORD PTR $T284599[esp+152], edx
  003fb	d9 9c 24 84 00
	00 00		 fstp	 DWORD PTR $T284600[esp+144]
  00402	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR $T284600[esp+144]
  00409	d9 44 24 7c	 fld	 DWORD PTR $T284599[esp+148]
  0040d	89 44 24 60	 mov	 DWORD PTR _vDist$[esp+144], eax
  00411	d8 64 24 70	 fsub	 DWORD PTR _vPos$[esp+148]
  00415	d9 9c 24 88 00
	00 00		 fstp	 DWORD PTR $T284600[esp+148]
  0041c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR $T284600[esp+148]
  00423	d9 84 24 80 00
	00 00		 fld	 DWORD PTR $T284599[esp+152]
  0042a	89 4c 24 64	 mov	 DWORD PTR _vDist$[esp+148], ecx
  0042e	d8 64 24 74	 fsub	 DWORD PTR _vPos$[esp+152]
  00432	d9 9c 24 8c 00
	00 00		 fstp	 DWORD PTR $T284600[esp+152]
  00439	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR $T284600[esp+152]

; 3847 : 					fDistSq = D3DXVec3LengthSq( &vDist );

  00440	d9 44 24 60	 fld	 DWORD PTR _vDist$[esp+144]
  00444	89 54 24 68	 mov	 DWORD PTR _vDist$[esp+152], edx
  00448	d8 4c 24 60	 fmul	 DWORD PTR _vDist$[esp+144]
  0044c	d9 44 24 68	 fld	 DWORD PTR _vDist$[esp+152]
  00450	d8 4c 24 68	 fmul	 DWORD PTR _vDist$[esp+152]

; 3878 : 	{
; 3879 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkDynamic, GetLayer() )

  00454	de c1		 faddp	 ST(1), ST(0)
  00456	d9 44 24 64	 fld	 DWORD PTR _vDist$[esp+148]
  0045a	d8 4c 24 64	 fmul	 DWORD PTR _vDist$[esp+148]
  0045e	de c1		 faddp	 ST(1), ST(0)
  00460	d9 84 24 a4 00
	00 00		 fld	 DWORD PTR _fRange$[esp+140]
  00467	d8 8c 24 a4 00
	00 00		 fmul	 DWORD PTR _fRange$[esp+140]
  0046e	de d9		 fcompp
  00470	df e0		 fnstsw	 ax
  00472	f6 c4 41	 test	 ah, 65			; 00000041H
  00475	0f 85 85 00 00
	00		 jne	 $L284797
  0047b	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+144]
  0047f	3b f1		 cmp	 esi, ecx
  00481	75 16		 jne	 SHORT $L275715
  00483	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00489	d9 84 24 a8 00
	00 00		 fld	 DWORD PTR _fTargetRatio$[esp+140]
  00490	da e9		 fucompp
  00492	df e0		 fnstsw	 ax
  00494	f6 c4 44	 test	 ah, 68			; 00000044H
  00497	7b 67		 jnp	 SHORT $L284797
$L275715:

; 3848 : 					if( fDistSq < fRange * fRange )		//   fRange  .
; 3849 : 					{
; 3850 : 						if( pObj == this && fTargetRatio == 0.0f )	//   0 ()  .
; 3851 : 						{
; 3852 : 						} else
; 3853 : 						{
; 3854 : 							if( pObj != pAttacker )		//   .

  00499	3b f7		 cmp	 esi, edi
  0049b	74 63		 je	 SHORT $L284797

; 3855 : 							{
; 3856 : 								pTarget = (CMover *)pObj;
; 3857 : 								bTarget = ( pTarget == this );

  0049d	33 c0		 xor	 eax, eax
  0049f	3b f1		 cmp	 esi, ecx

; 3858 : 								if( IsValidObj( (CObj*)pTarget ) && pTarget->IsLive() )

  004a1	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  004a4	0f 94 c0	 sete	 al
  004a7	f6 c1 01	 test	 cl, 1
  004aa	75 54		 jne	 SHORT $L284797
  004ac	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  004b2	f7 41 04 00 00
	00 08		 test	 DWORD PTR [ecx+4], 134217728 ; 08000000H
  004b9	74 0a		 je	 SHORT $L284782
  004bb	8b 96 00 06 00
	00		 mov	 edx, DWORD PTR [esi+1536]
  004c1	85 d2		 test	 edx, edx
  004c3	7e 3b		 jle	 SHORT $L284797
$L284782:

; 3859 : 								{
; 3860 : 									if( pProp->dwComboStyle == CT_FINISH )

  004c5	8b 54 24 30	 mov	 edx, DWORD PTR _pProp$[esp+144]
  004c9	83 ba 48 02 00
	00 03		 cmp	 DWORD PTR [edx+584], 3
  004d0	75 16		 jne	 SHORT $L275721

; 3861 : 										pTarget->m_pActMover->SendDamageForce( nDmgType, pAttacker->GetId(), (nAttackID << 16), bTarget );

  004d2	8b 97 bc 01 00
	00		 mov	 edx, DWORD PTR [edi+444]
  004d8	50		 push	 eax
  004d9	8b c3		 mov	 eax, ebx
  004db	c1 e0 10	 shl	 eax, 16			; 00000010H
  004de	50		 push	 eax
  004df	52		 push	 edx
  004e0	55		 push	 ebp
  004e1	e8 00 00 00 00	 call	 ?SendDamageForce@CActionMover@@QAEHKKHH@Z ; CActionMover::SendDamageForce

; 3862 : 									else

  004e6	eb 18		 jmp	 SHORT $L284797
$L275721:

; 3863 : 										pTarget->m_pActMover->SendDamage( nDmgType, pAttacker->GetId(), (nAttackID << 16), bTarget );

  004e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  004ea	6a 00		 push	 0
  004ec	50		 push	 eax
  004ed	8b c3		 mov	 eax, ebx
  004ef	c1 e0 10	 shl	 eax, 16			; 00000010H
  004f2	50		 push	 eax
  004f3	8b 87 bc 01 00
	00		 mov	 eax, DWORD PTR [edi+444]
  004f9	50		 push	 eax
  004fa	55		 push	 ebp
  004fb	6a 29		 push	 41			; 00000029H
  004fd	ff 52 04	 call	 DWORD PTR [edx+4]
$L284797:

; 3864 : 								}
; 3865 : 							}
; 3866 : 						}
; 3867 : 					}
; 3868 : 					
; 3869 : 					bDamage = FALSE;	//    .
; 3870 : 				} // bDamage
; 3871 : 			}
; 3872 : 		}
; 3873 : 		END_LINKMAP

  00500	8b b6 80 01 00
	00		 mov	 esi, DWORD PTR [esi+384]
  00506	85 f6		 test	 esi, esi
  00508	0f 85 a8 fe ff
	ff		 jne	 $L275708
$L275704:

; 3837 : 	{
; 3838 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkPlayer, GetLayer() )

  0050e	8b 4c 24 18	 mov	 ecx, DWORD PTR tv1342[esp+144]
  00512	8b 44 24 3c	 mov	 eax, DWORD PTR tv416[esp+144]
  00516	83 c1 04	 add	 ecx, 4
  00519	48		 dec	 eax
  0051a	89 4c 24 18	 mov	 DWORD PTR tv1342[esp+144], ecx
  0051e	89 44 24 3c	 mov	 DWORD PTR tv416[esp+144], eax
  00522	0f 85 78 fe ff
	ff		 jne	 $L275703
  00528	8b 4c 24 1c	 mov	 ecx, DWORD PTR __nLinkXMin$275678[esp+144]
$L275700:
  0052c	8b 74 24 20	 mov	 esi, DWORD PTR tv1388[esp+144]
  00530	8b 54 24 5c	 mov	 edx, DWORD PTR tv1392[esp+144]
  00534	8b 44 24 40	 mov	 eax, DWORD PTR tv369[esp+144]
  00538	03 f2		 add	 esi, edx
  0053a	48		 dec	 eax
  0053b	89 74 24 20	 mov	 DWORD PTR tv1388[esp+144], esi
  0053f	89 44 24 40	 mov	 DWORD PTR tv369[esp+144], eax
  00543	0f 85 39 fe ff
	ff		 jne	 $L275699
$L275688:
  00549	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+144]
  0054d	8b 81 b8 01 00
	00		 mov	 eax, DWORD PTR [ecx+440]
  00553	8b 74 24 24	 mov	 esi, DWORD PTR __i$275686[esp+144]
  00557	8b 89 6c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+364]
  0055d	50		 push	 eax
  0055e	46		 inc	 esi
  0055f	6a 02		 push	 2
  00561	83 c1 24	 add	 ecx, 36			; 00000024H
  00564	89 74 24 2c	 mov	 DWORD PTR __i$275686[esp+152], esi
  00568	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  0056d	3b f0		 cmp	 esi, eax
  0056f	0f 8c cb fc ff
	ff		 jl	 $L275687
  00575	8b 74 24 10	 mov	 esi, DWORD PTR _this$[esp+144]
  00579	8b 5c 24 14	 mov	 ebx, DWORD PTR _nRange$[esp+144]
$L284949:

; 3874 : 	}
; 3875 : 
; 3876 : 	//  .
; 3877 : 	if( nApplyType & OBJTYPE_MONSTER )

  0057d	f6 84 24 9c 00
	00 00 02	 test	 BYTE PTR _nApplyType$[esp+140], 2
  00585	0f 84 ca 03 00
	00		 je	 $L284957

; 3878 : 	{
; 3879 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkDynamic, GetLayer() )

  0058b	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  00591	db 40 14	 fild	 DWORD PTR [eax+20]
  00594	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  0059a	d9 44 24 6c	 fld	 DWORD PTR _vPos$[esp+144]
  0059e	d8 c9		 fmul	 ST(0), ST(1)
  005a0	e8 00 00 00 00	 call	 __ftol2
  005a5	d8 4c 24 74	 fmul	 DWORD PTR _vPos$[esp+152]
  005a9	8b f8		 mov	 edi, eax
  005ab	89 7c 24 5c	 mov	 DWORD PTR __nLinkX$275724[esp+144], edi
  005af	e8 00 00 00 00	 call	 __ftol2
  005b4	8b e8		 mov	 ebp, eax
  005b6	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  005bc	8b b6 6c 01 00
	00		 mov	 esi, DWORD PTR [esi+364]
  005c2	50		 push	 eax
  005c3	6a 01		 push	 1
  005c5	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  005c8	89 6c 24 60	 mov	 DWORD PTR __nLinkZ$275726[esp+152], ebp
  005cc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __i$275740[esp+152], 0
  005d4	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  005d9	85 c0		 test	 eax, eax
  005db	0f 8e 74 03 00
	00		 jle	 $L284957
  005e1	d9 44 24 6c	 fld	 DWORD PTR _vPos$[esp+144]
  005e5	e8 00 00 00 00	 call	 __ftol2
  005ea	d9 44 24 74	 fld	 DWORD PTR _vPos$[esp+152]
  005ee	89 44 24 28	 mov	 DWORD PTR tv845[esp+144], eax
  005f2	e8 00 00 00 00	 call	 __ftol2
  005f7	89 44 24 2c	 mov	 DWORD PTR tv851[esp+144], eax
  005fb	8b c7		 mov	 eax, edi
  005fd	2b c3		 sub	 eax, ebx
  005ff	89 44 24 54	 mov	 DWORD PTR tv995[esp+144], eax
  00603	8b c5		 mov	 eax, ebp
  00605	2b c3		 sub	 eax, ebx
  00607	03 fb		 add	 edi, ebx
  00609	03 eb		 add	 ebp, ebx
  0060b	89 44 24 50	 mov	 DWORD PTR tv1000[esp+144], eax
  0060f	89 7c 24 4c	 mov	 DWORD PTR tv1005[esp+144], edi
  00613	89 6c 24 48	 mov	 DWORD PTR tv1010[esp+144], ebp
  00617	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L275741:
  00620	8b 74 24 10	 mov	 esi, DWORD PTR _this$[esp+144]
  00624	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  0062a	8b 7c 24 18	 mov	 edi, DWORD PTR __i$275740[esp+144]
  0062e	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00634	50		 push	 eax
  00635	57		 push	 edi
  00636	6a 01		 push	 1
  00638	83 c1 24	 add	 ecx, 36			; 00000024H
  0063b	e8 00 00 00 00	 call	 ?GetLinkWidth@CLayeredLinkMap@@QAEHKHH@Z ; CLayeredLinkMap::GetLinkWidth
  00640	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00646	8b e8		 mov	 ebp, eax
  00648	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  0064e	50		 push	 eax
  0064f	57		 push	 edi
  00650	6a 01		 push	 1
  00652	83 c1 24	 add	 ecx, 36			; 00000024H
  00655	e8 00 00 00 00	 call	 ?GetObj@CLayeredLinkMap@@QAEPAPAVCObj@@KKH@Z ; CLayeredLinkMap::GetObj
  0065a	8b b6 6c 01 00
	00		 mov	 esi, DWORD PTR [esi+364]
  00660	89 44 24 44	 mov	 DWORD PTR __pObjs$275744[esp+144], eax
  00664	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00667	8b f8		 mov	 edi, eax
  00669	c1 e0 07	 shl	 eax, 7
  0066c	0f af fd	 imul	 edi, ebp
  0066f	99		 cdq
  00670	f7 ff		 idiv	 edi
  00672	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00675	0f af dd	 imul	 ebx, ebp
  00678	8b 6e 14	 mov	 ebp, DWORD PTR [esi+20]
  0067b	8b c8		 mov	 ecx, eax
  0067d	8b c5		 mov	 eax, ebp
  0067f	0f af c1	 imul	 eax, ecx
  00682	99		 cdq
  00683	2b c2		 sub	 eax, edx
  00685	8b f0		 mov	 esi, eax
  00687	8b 44 24 5c	 mov	 eax, DWORD PTR __nLinkX$275724[esp+144]
  0068b	99		 cdq
  0068c	f7 f9		 idiv	 ecx
  0068e	8b 54 24 28	 mov	 edx, DWORD PTR tv845[esp+144]
  00692	d1 fe		 sar	 esi, 1
  00694	0f af c5	 imul	 eax, ebp
  00697	0f af c1	 imul	 eax, ecx
  0069a	2b d0		 sub	 edx, eax
  0069c	33 c0		 xor	 eax, eax
  0069e	3b d6		 cmp	 edx, esi
  006a0	0f 9f c0	 setg	 al
  006a3	89 44 24 40	 mov	 DWORD PTR __nX$275736[esp+144], eax
  006a7	8b 44 24 58	 mov	 eax, DWORD PTR __nLinkZ$275726[esp+144]
  006ab	99		 cdq
  006ac	f7 f9		 idiv	 ecx
  006ae	8b 54 24 2c	 mov	 edx, DWORD PTR tv851[esp+144]
  006b2	0f af c5	 imul	 eax, ebp
  006b5	0f af c1	 imul	 eax, ecx
  006b8	2b d0		 sub	 edx, eax
  006ba	33 c0		 xor	 eax, eax
  006bc	3b d6		 cmp	 edx, esi
  006be	0f 9f c0	 setg	 al
  006c1	8b f0		 mov	 esi, eax
  006c3	8b 44 24 54	 mov	 eax, DWORD PTR tv995[esp+144]
  006c7	99		 cdq
  006c8	f7 f9		 idiv	 ecx
  006ca	8b 54 24 40	 mov	 edx, DWORD PTR __nX$275736[esp+144]
  006ce	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  006d2	85 c0		 test	 eax, eax
  006d4	89 44 24 20	 mov	 DWORD PTR __nLinkXMin$275732[esp+144], eax
  006d8	7d 08		 jge	 SHORT $L284950
  006da	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __nLinkXMin$275732[esp+144], 0
$L284950:
  006e2	8b 44 24 50	 mov	 eax, DWORD PTR tv1000[esp+144]
  006e6	99		 cdq
  006e7	f7 f9		 idiv	 ecx
  006e9	8d 6c 30 ff	 lea	 ebp, DWORD PTR [eax+esi-1]
  006ed	85 ed		 test	 ebp, ebp
  006ef	7d 02		 jge	 SHORT $L275749
  006f1	33 ed		 xor	 ebp, ebp
$L275749:
  006f3	8b 44 24 4c	 mov	 eax, DWORD PTR tv1005[esp+144]
  006f7	99		 cdq
  006f8	f7 f9		 idiv	 ecx
  006fa	03 44 24 40	 add	 eax, DWORD PTR __nX$275736[esp+144]
  006fe	3b c7		 cmp	 eax, edi
  00700	89 44 24 40	 mov	 DWORD PTR __nLinkXMax$275734[esp+144], eax
  00704	7c 07		 jl	 SHORT $L275750
  00706	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00709	89 44 24 40	 mov	 DWORD PTR __nLinkXMax$275734[esp+144], eax
$L275750:
  0070d	8b 44 24 48	 mov	 eax, DWORD PTR tv1010[esp+144]
  00711	99		 cdq
  00712	f7 f9		 idiv	 ecx
  00714	03 c6		 add	 eax, esi
  00716	3b c3		 cmp	 eax, ebx
  00718	7c 03		 jl	 SHORT $L275751
  0071a	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
$L275751:
  0071d	3b e8		 cmp	 ebp, eax
  0071f	0f 8f 04 02 00
	00		 jg	 $L275742
  00725	8b 74 24 44	 mov	 esi, DWORD PTR __pObjs$275744[esp+144]
  00729	8b 9c 24 a0 00
	00 00		 mov	 ebx, DWORD PTR _nAttackID$[esp+140]
  00730	8b d5		 mov	 edx, ebp
  00732	0f af d7	 imul	 edx, edi
  00735	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  0073c	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _pAttacker$[esp+140]
  00743	89 4c 24 14	 mov	 DWORD PTR tv1496[esp+144], ecx
  00747	8b 4c 24 20	 mov	 ecx, DWORD PTR __nLinkXMin$275732[esp+144]
  0074b	03 d1		 add	 edx, ecx
  0074d	2b c5		 sub	 eax, ebp
  0074f	8b ac 24 94 00
	00 00		 mov	 ebp, DWORD PTR _nDmgType$[esp+140]
  00756	8d 14 96	 lea	 edx, DWORD PTR [esi+edx*4]
  00759	40		 inc	 eax
  0075a	89 54 24 1c	 mov	 DWORD PTR tv1492[esp+144], edx
  0075e	89 44 24 34	 mov	 DWORD PTR tv640[esp+144], eax
$L275753:
  00762	8b 44 24 40	 mov	 eax, DWORD PTR __nLinkXMax$275734[esp+144]
  00766	3b c8		 cmp	 ecx, eax
  00768	0f 8f 9e 01 00
	00		 jg	 $L275754
  0076e	8b 54 24 1c	 mov	 edx, DWORD PTR tv1492[esp+144]
  00772	2b c1		 sub	 eax, ecx
  00774	40		 inc	 eax
  00775	89 54 24 24	 mov	 DWORD PTR tv1446[esp+144], edx
  00779	89 44 24 38	 mov	 DWORD PTR tv239[esp+144], eax
  0077d	8d 49 00	 npad	 3
$L275757:
  00780	8b 44 24 24	 mov	 eax, DWORD PTR tv1446[esp+144]
  00784	8b 30		 mov	 esi, DWORD PTR [eax]
  00786	85 f6		 test	 esi, esi
  00788	c7 44 24 3c e8
	03 00 00	 mov	 DWORD PTR ___limit$275760[esp+144], 1000 ; 000003e8H
  00790	0f 84 58 01 00
	00		 je	 $L275758
$L275762:
  00796	8b 44 24 3c	 mov	 eax, DWORD PTR ___limit$275760[esp+144]
  0079a	8b c8		 mov	 ecx, eax
  0079c	48		 dec	 eax
  0079d	85 c9		 test	 ecx, ecx
  0079f	89 44 24 3c	 mov	 DWORD PTR ___limit$275760[esp+144], eax
  007a3	0f 84 45 01 00
	00		 je	 $L275758

; 3880 : 		{
; 3881 : 			if( pObj->GetType() == OT_MOVER && ((CMover *)pObj)->IsPeaceful() == FALSE )

  007a9	83 be 70 01 00
	00 05		 cmp	 DWORD PTR [esi+368], 5
  007b0	0f 85 2a 01 00
	00		 jne	 $L284915
  007b6	83 be 6c 06 00
	00 01		 cmp	 DWORD PTR [esi+1644], 1
  007bd	0f 84 1d 01 00
	00		 je	 $L284915

; 3882 : 			{
; 3883 : 				vDist = pObj->GetPos() - vPos;		// this ->  

  007c3	8d 96 60 01 00
	00		 lea	 edx, DWORD PTR [esi+352]
  007c9	8b 02		 mov	 eax, DWORD PTR [edx]
  007cb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  007ce	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  007d1	89 84 24 84 00
	00 00		 mov	 DWORD PTR $T284601[esp+144], eax
  007d8	d9 84 24 84 00
	00 00		 fld	 DWORD PTR $T284601[esp+144]
  007df	d8 64 24 6c	 fsub	 DWORD PTR _vPos$[esp+144]
  007e3	89 8c 24 88 00
	00 00		 mov	 DWORD PTR $T284601[esp+148], ecx
  007ea	89 94 24 8c 00
	00 00		 mov	 DWORD PTR $T284601[esp+152], edx
  007f1	d9 5c 24 78	 fstp	 DWORD PTR $T284602[esp+144]
  007f5	8b 44 24 78	 mov	 eax, DWORD PTR $T284602[esp+144]
  007f9	d9 84 24 88 00
	00 00		 fld	 DWORD PTR $T284601[esp+148]
  00800	89 44 24 60	 mov	 DWORD PTR _vDist$[esp+144], eax
  00804	d8 64 24 70	 fsub	 DWORD PTR _vPos$[esp+148]
  00808	d9 5c 24 7c	 fstp	 DWORD PTR $T284602[esp+148]
  0080c	8b 4c 24 7c	 mov	 ecx, DWORD PTR $T284602[esp+148]
  00810	d9 84 24 8c 00
	00 00		 fld	 DWORD PTR $T284601[esp+152]
  00817	89 4c 24 64	 mov	 DWORD PTR _vDist$[esp+148], ecx
  0081b	d8 64 24 74	 fsub	 DWORD PTR _vPos$[esp+152]
  0081f	d9 9c 24 80 00
	00 00		 fstp	 DWORD PTR $T284602[esp+152]
  00826	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR $T284602[esp+152]

; 3884 : 				fDistSq = D3DXVec3LengthSq( &vDist );

  0082d	d9 44 24 60	 fld	 DWORD PTR _vDist$[esp+144]
  00831	89 54 24 68	 mov	 DWORD PTR _vDist$[esp+152], edx
  00835	d8 4c 24 60	 fmul	 DWORD PTR _vDist$[esp+144]
  00839	d9 44 24 68	 fld	 DWORD PTR _vDist$[esp+152]
  0083d	d8 4c 24 68	 fmul	 DWORD PTR _vDist$[esp+152]
  00841	de c1		 faddp	 ST(1), ST(0)
  00843	d9 44 24 64	 fld	 DWORD PTR _vDist$[esp+148]
  00847	d8 4c 24 64	 fmul	 DWORD PTR _vDist$[esp+148]

; 3885 : 				if( fDistSq < fRange * fRange )		//   fRange  .

  0084b	de c1		 faddp	 ST(1), ST(0)
  0084d	d9 84 24 a4 00
	00 00		 fld	 DWORD PTR _fRange$[esp+140]
  00854	d8 8c 24 a4 00
	00 00		 fmul	 DWORD PTR _fRange$[esp+140]
  0085b	de d9		 fcompp
  0085d	df e0		 fnstsw	 ax
  0085f	f6 c4 41	 test	 ah, 65			; 00000041H
  00862	75 7c		 jne	 SHORT $L284915

; 3886 : 				{
; 3887 : 					if( pObj == this && fTargetRatio == 0.0f )	//   0 ()  .

  00864	3b 74 24 10	 cmp	 esi, DWORD PTR _this$[esp+144]
  00868	75 16		 jne	 SHORT $L275769
  0086a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00870	d9 84 24 a8 00
	00 00		 fld	 DWORD PTR _fTargetRatio$[esp+140]
  00877	da e9		 fucompp
  00879	df e0		 fnstsw	 ax
  0087b	f6 c4 44	 test	 ah, 68			; 00000044H
  0087e	7b 60		 jnp	 SHORT $L284915
$L275769:

; 3888 : 					{
; 3889 : 					} else
; 3890 : 					{
; 3891 : 						if( pObj != pAttacker )		//   .

  00880	3b f7		 cmp	 esi, edi
  00882	74 5c		 je	 SHORT $L284915

; 3892 : 						{
; 3893 : 							pTarget = (CMover *)pObj;
; 3894 : 							if( IsValidObj( (CObj*)pTarget ) && pTarget->IsLive() )

  00884	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00888	75 56		 jne	 SHORT $L284915
  0088a	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00890	f7 41 04 00 00
	00 08		 test	 DWORD PTR [ecx+4], 134217728 ; 08000000H
  00897	74 0a		 je	 SHORT $L284901
  00899	8b 86 00 06 00
	00		 mov	 eax, DWORD PTR [esi+1536]
  0089f	85 c0		 test	 eax, eax
  008a1	7e 3d		 jle	 SHORT $L284915
$L284901:

; 3895 : 							{
; 3896 : 								if( pProp->dwComboStyle == CT_FINISH )

  008a3	8b 44 24 30	 mov	 eax, DWORD PTR _pProp$[esp+144]
  008a7	83 b8 48 02 00
	00 03		 cmp	 DWORD PTR [eax+584], 3
  008ae	75 17		 jne	 SHORT $L275775

; 3897 : 									pTarget->m_pActMover->SendDamageForce( nDmgType, pAttacker->GetId(), (nAttackID << 16) );

  008b0	8b 87 bc 01 00
	00		 mov	 eax, DWORD PTR [edi+444]
  008b6	6a 01		 push	 1
  008b8	8b d3		 mov	 edx, ebx
  008ba	c1 e2 10	 shl	 edx, 16			; 00000010H
  008bd	52		 push	 edx
  008be	50		 push	 eax
  008bf	55		 push	 ebp
  008c0	e8 00 00 00 00	 call	 ?SendDamageForce@CActionMover@@QAEHKKHH@Z ; CActionMover::SendDamageForce

; 3898 : 								else

  008c5	eb 19		 jmp	 SHORT $L284915
$L275775:

; 3899 : 									pTarget->m_pActMover->SendDamage( nDmgType, pAttacker->GetId(), (nAttackID << 16) );

  008c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  008c9	6a 00		 push	 0
  008cb	6a 01		 push	 1
  008cd	8b c3		 mov	 eax, ebx
  008cf	c1 e0 10	 shl	 eax, 16			; 00000010H
  008d2	50		 push	 eax
  008d3	8b 87 bc 01 00
	00		 mov	 eax, DWORD PTR [edi+444]
  008d9	50		 push	 eax
  008da	55		 push	 ebp
  008db	6a 29		 push	 41			; 00000029H
  008dd	ff 52 04	 call	 DWORD PTR [edx+4]
$L284915:

; 3900 : 							}
; 3901 : 						}
; 3902 : 					}
; 3903 : 				}
; 3904 : 			}
; 3905 : 		}
; 3906 : 		END_LINKMAP

  008e0	8b b6 80 01 00
	00		 mov	 esi, DWORD PTR [esi+384]
  008e6	85 f6		 test	 esi, esi
  008e8	0f 85 a8 fe ff
	ff		 jne	 $L275762
$L275758:

; 3878 : 	{
; 3879 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkDynamic, GetLayer() )

  008ee	8b 4c 24 24	 mov	 ecx, DWORD PTR tv1446[esp+144]
  008f2	8b 44 24 38	 mov	 eax, DWORD PTR tv239[esp+144]
  008f6	83 c1 04	 add	 ecx, 4
  008f9	48		 dec	 eax
  008fa	89 4c 24 24	 mov	 DWORD PTR tv1446[esp+144], ecx
  008fe	89 44 24 38	 mov	 DWORD PTR tv239[esp+144], eax
  00902	0f 85 78 fe ff
	ff		 jne	 $L275757
  00908	8b 4c 24 20	 mov	 ecx, DWORD PTR __nLinkXMin$275732[esp+144]
$L275754:
  0090c	8b 74 24 1c	 mov	 esi, DWORD PTR tv1492[esp+144]
  00910	8b 54 24 14	 mov	 edx, DWORD PTR tv1496[esp+144]
  00914	8b 44 24 34	 mov	 eax, DWORD PTR tv640[esp+144]
  00918	03 f2		 add	 esi, edx
  0091a	48		 dec	 eax
  0091b	89 74 24 1c	 mov	 DWORD PTR tv1492[esp+144], esi
  0091f	89 44 24 34	 mov	 DWORD PTR tv640[esp+144], eax
  00923	0f 85 39 fe ff
	ff		 jne	 $L275753
$L275742:
  00929	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+144]
  0092d	8b 81 b8 01 00
	00		 mov	 eax, DWORD PTR [ecx+440]
  00933	8b 74 24 18	 mov	 esi, DWORD PTR __i$275740[esp+144]
  00937	8b 89 6c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+364]
  0093d	50		 push	 eax
  0093e	46		 inc	 esi
  0093f	6a 01		 push	 1
  00941	83 c1 24	 add	 ecx, 36			; 00000024H
  00944	89 74 24 20	 mov	 DWORD PTR __i$275740[esp+152], esi
  00948	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  0094d	3b f0		 cmp	 esi, eax
  0094f	0f 8c cb fc ff
	ff		 jl	 $L275741
$L284957:
  00955	5d		 pop	 ebp
  00956	5f		 pop	 edi
  00957	5e		 pop	 esi
  00958	5b		 pop	 ebx

; 3907 : 	}
; 3908 : 		
; 3909 : #endif // WORLDSERVER		
; 3910 : } // SendDamageAround()

  00959	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  0095f	c2 1c 00	 ret	 28			; 0000001cH
?SendDamageAround@CMover@@QAEXHPAV1@HHMMM@Z ENDP	; CMover::SendDamageAround
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BEJKIDOG@CMover?3?3SendDamageLine?5?3?5D?3?$CFs?5A?3@ ; `string'
PUBLIC	??_C@_0DL@KEBMKGCP@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LN?$LK?E@ ; `string'
PUBLIC	??_C@_0DN@LKDJCKJ@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LO?F?$MA@ ; `string'
PUBLIC	__real@bf000000
PUBLIC	__real@3f000000
PUBLIC	?SendDamageLine@CMover@@QAEXHHHMMM@Z		; CMover::SendDamageLine
EXTRN	?IsTouchAABB@@YAHABUD3DXVECTOR3@@000@Z:NEAR	; IsTouchAABB
EXTRN	_D3DXVec3TransformCoord@12:NEAR
EXTRN	_D3DXMatrixMultiply@12:NEAR
EXTRN	_D3DXMatrixInverse@12:NEAR
EXTRN	_D3DXMatrixTranslation@16:NEAR
EXTRN	_D3DXMatrixRotationY@8:NEAR
;	COMDAT __real@bf000000
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_C@_0CJ@BEJKIDOG@CMover?3?3SendDamageLine?5?3?5D?3?$CFs?5A?3@
CONST	SEGMENT
??_C@_0CJ@BEJKIDOG@CMover?3?3SendDamageLine?5?3?5D?3?$CFs?5A?3@ DB 'CMove'
	DB	'r::SendDamageLine : D:%s A:%s %d %f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KEBMKGCP@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LN?$LK?E@
CONST	SEGMENT
??_C@_0DL@KEBMKGCP@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LN?$LK?E@ DB 'C'
	DB	'Mover::SendDamageLine : %s. ', 0bdH, 0baH, 0c5H, 0b3H, '(%d)', 0c0H
	DB	0c7H, ' ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH, 0c6H, 0bcH, 0b0H
	DB	0a1H, ' ', 0beH, 0f7H, 0a4H, 0b2H, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@LKDJCKJ@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LO?F?$MA@
CONST	SEGMENT
??_C@_0DN@LKDJCKJ@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LO?F?$MA@ DB 'C'
	DB	'Mover::SendDamageLine : %s. ', 0beH, 0c6H, 0c0H, 0ccH, 0c5H, 0dbH
	DB	'(%d)', 0c0H, 0c7H, ' ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH, 0c6H
	DB	0bcH, 0b0H, 0a1H, ' ', 0beH, 0f7H, 0a4H, 0b2H, 0b4H, 0d9H, '.', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?SendDamageLine@CMover@@QAEXHHHMMM@Z
_TEXT	SEGMENT
__nLinkXMax$275884 = -412				; size = 4
__nX$275886 = -412					; size = 4
tv408 = -412						; size = 4
__nMaxHeight$275829 = -412				; size = 4
__i$275890 = -408					; size = 4
__nLinkXMax$275833 = -408				; size = 4
__nX$275835 = -408					; size = 4
tv1603 = -404						; size = 4
_nRange$ = -404						; size = 4
tv1499 = -400						; size = 4
___limit$275910 = -400					; size = 4
__pObjs$275843 = -400					; size = 4
__nLinkXMin$275882 = -396				; size = 4
__nLinkXMin$275831 = -396				; size = 4
tv1557 = -392						; size = 4
__i$275839 = -392					; size = 4
tv371 = -388						; size = 4
__pObjs$275894 = -388					; size = 4
__nLinkZ$275825 = -388					; size = 4
__nMaxHeight$275880 = -384				; size = 4
tv345 = -384						; size = 4
__nLinkX$275823 = -384					; size = 4
$T284966 = -380						; size = 12
_vMin2$275868 = -380					; size = 12
$T284964 = -380						; size = 12
$T284963 = -380						; size = 12
$T284962 = -380						; size = 12
_vDestLocal$ = -368					; size = 12
tv1071 = -356						; size = 4
tv945 = -356						; size = 4
__nLinkZ$275876 = -352					; size = 4
___limit$275859 = -352					; size = 4
tv921 = -348						; size = 4
tv1503 = -344						; size = 4
__nLinkX$275874 = -344					; size = 4
tv1076 = -340						; size = 4
tv940 = -340						; size = 4
tv927 = -336						; size = 4
tv1081 = -332						; size = 4
tv935 = -332						; size = 4
tv1086 = -328						; size = 4
tv930 = -328						; size = 4
_vPos$ = -324						; size = 12
_pProp$ = -312						; size = 4
_vMax2$275921 = -308					; size = 12
_vMax2$275870 = -308					; size = 12
_vMin2$275919 = -296					; size = 12
$T284965 = -296						; size = 12
tv1607 = -284						; size = 4
_vMax1$ = -280						; size = 12
_vMin1$ = -268						; size = 12
_mInv$ = -256						; size = 64
_m2$ = -192						; size = 64
_m1$ = -128						; size = 64
_m3$ = -64						; size = 64
_nDmgType$ = 8						; size = 4
_nApplyType$ = 12					; size = 4
_nAttackID$ = 16					; size = 4
_fWidth$ = 20						; size = 4
_fHeight$ = 24						; size = 4
_fDepth$ = 28						; size = 4
?SendDamageLine@CMover@@QAEXHHHMMM@Z PROC NEAR		; CMover::SendDamageLine, COMDAT
; _this$ = ecx

; 3932 : {

  00000	81 ec 9c 01 00
	00		 sub	 esp, 412		; 0000019cH

; 3933 : #ifdef __WORLDSERVER
; 3934 : 	int nRange	= 4;	// 4m
; 3935 : 
; 3936 : 	CObj* pObj;
; 3937 : 	CMover *pTarget;
; 3938 : 	D3DXVECTOR3 vPos = GetPos();
; 3939 : 	D3DXVECTOR3 vDist;
; 3940 : 
; 3941 : 	//   Local AABB.
; 3942 : 	D3DXVECTOR3 vMin1 = D3DXVECTOR3( -fWidth / 2.0f, -fHeight / 2.0f, -fDepth );

  00006	d9 84 24 ac 01
	00 00		 fld	 DWORD PTR _fWidth$[esp+408]
  0000d	53		 push	 ebx
  0000e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@bf000000
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b f9		 mov	 edi, ecx
  00018	d9 9c 24 9c 00
	00 00		 fstp	 DWORD PTR _vMin1$[esp+424]
  0001f	8d b7 60 01 00
	00		 lea	 esi, DWORD PTR [edi+352]
  00025	d9 84 24 bc 01
	00 00		 fld	 DWORD PTR _fHeight$[esp+420]
  0002c	8b c6		 mov	 eax, esi
  0002e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@bf000000
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00039	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003c	d9 9c 24 a0 00
	00 00		 fstp	 DWORD PTR _vMin1$[esp+428]

; 3943 : 	D3DXVECTOR3 vMax1 = D3DXVECTOR3(  fWidth / 2.0f,  fHeight / 2.0f, 0 );
; 3944 : 
; 3945 : 	D3DXMATRIX mInv;		//  
; 3946 : 	D3DXMATRIX m1, m2, m3;
; 3947 : 	D3DXMatrixRotationY( &m1, D3DXToRadian( -GetAngle() ) );

  00043	51		 push	 ecx
  00044	d9 84 24 c4 01
	00 00		 fld	 DWORD PTR _fDepth$[esp+424]
  0004b	89 4c 24 68	 mov	 DWORD PTR _vPos$[esp+428], ecx
  0004f	d9 e0		 fchs
  00051	8d 8c 24 2c 01
	00 00		 lea	 ecx, DWORD PTR _m1$[esp+428]
  00058	d9 9c 24 a8 00
	00 00		 fstp	 DWORD PTR _vMin1$[esp+436]
  0005f	89 54 24 6c	 mov	 DWORD PTR _vPos$[esp+432], edx
  00063	d9 84 24 bc 01
	00 00		 fld	 DWORD PTR _fWidth$[esp+424]
  0006a	89 44 24 70	 mov	 DWORD PTR _vPos$[esp+436], eax
  0006e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00074	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _vMax1$[esp+436], 0
  0007f	d9 9c 24 94 00
	00 00		 fstp	 DWORD PTR _vMax1$[esp+428]
  00086	d9 84 24 c0 01
	00 00		 fld	 DWORD PTR _fHeight$[esp+424]
  0008d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00093	d9 9c 24 98 00
	00 00		 fstp	 DWORD PTR _vMax1$[esp+432]
  0009a	d9 47 18	 fld	 DWORD PTR [edi+24]
  0009d	d9 e0		 fchs
  0009f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c8efa35
  000a5	d9 1c 24	 fstp	 DWORD PTR [esp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _D3DXMatrixRotationY@8

; 3948 : 	D3DXMatrixTranslation( &m2, GetPos().x, GetPos().y, GetPos().z );

  000ae	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  000b1	8b d6		 mov	 edx, esi
  000b3	8b 02		 mov	 eax, DWORD PTR [edx]
  000b5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000b8	89 44 24 2c	 mov	 DWORD PTR $T284962[esp+424], eax
  000bc	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000bf	89 4c 24 30	 mov	 DWORD PTR $T284962[esp+428], ecx
  000c3	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000c5	89 4c 24 2c	 mov	 DWORD PTR $T284963[esp+424], ecx
  000c9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000cc	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000cf	50		 push	 eax
  000d0	89 54 24 38	 mov	 DWORD PTR $T284963[esp+436], edx
  000d4	8b 16		 mov	 edx, DWORD PTR [esi]
  000d6	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  000d9	51		 push	 ecx
  000da	52		 push	 edx
  000db	8d 84 24 f4 00
	00 00		 lea	 eax, DWORD PTR _m2$[esp+436]
  000e2	50		 push	 eax
  000e3	89 5c 24 40	 mov	 DWORD PTR $T284964[esp+444], ebx
  000e7	89 74 24 44	 mov	 DWORD PTR $T284964[esp+448], esi
  000eb	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 3949 : 	D3DXMatrixMultiply( &m3, &m1, &m2 );	// world = rot * trans

  000f0	8d 8c 24 e8 00
	00 00		 lea	 ecx, DWORD PTR _m2$[esp+424]
  000f7	51		 push	 ecx
  000f8	8d 94 24 2c 01
	00 00		 lea	 edx, DWORD PTR _m1$[esp+428]
  000ff	52		 push	 edx
  00100	8d 84 24 70 01
	00 00		 lea	 eax, DWORD PTR _m3$[esp+432]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 3950 : 	
; 3951 : 	D3DXMatrixInverse( &mInv, NULL, &m3 );		//   .

  0010d	8d 8c 24 68 01
	00 00		 lea	 ecx, DWORD PTR _m3$[esp+424]
  00114	51		 push	 ecx
  00115	6a 00		 push	 0
  00117	8d 94 24 b0 00
	00 00		 lea	 edx, DWORD PTR _mInv$[esp+432]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _D3DXMatrixInverse@12

; 3952 : 
; 3953 : 	//      .
; 3954 : 	D3DXVECTOR3 vDestLocal;
; 3955 : 
; 3956 : 	//  fDepth     fDepth . 
; 3957 : 	if( fDepth <= 4.0f )

  00124	d9 84 24 c0 01
	00 00		 fld	 DWORD PTR _fDepth$[esp+420]
  0012b	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@40800000
  00131	df e0		 fnstsw	 ax
  00133	f6 c4 41	 test	 ah, 65			; 00000041H
  00136	7a 07		 jp	 SHORT $L275805

; 3958 : 		nRange = 4;

  00138	bb 04 00 00 00	 mov	 ebx, 4

; 3959 : 	else if( fDepth <= 8.0f )

  0013d	eb 39		 jmp	 SHORT $L285359
$L275805:
  0013f	d9 84 24 c0 01
	00 00		 fld	 DWORD PTR _fDepth$[esp+420]
  00146	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41000000
  0014c	df e0		 fnstsw	 ax
  0014e	f6 c4 41	 test	 ah, 65			; 00000041H
  00151	7a 07		 jp	 SHORT $L275807

; 3960 : 		nRange = 8;

  00153	bb 08 00 00 00	 mov	 ebx, 8

; 3961 : 	else if( fDepth <= 16.0f )

  00158	eb 1e		 jmp	 SHORT $L285359
$L275807:
  0015a	d9 84 24 c0 01
	00 00		 fld	 DWORD PTR _fDepth$[esp+420]

; 3962 : 		nRange = 16;

  00161	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  00166	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@41800000
  0016c	df e0		 fnstsw	 ax
  0016e	f6 c4 41	 test	 ah, 65			; 00000041H
  00171	7b 05		 jnp	 SHORT $L285359

; 3963 : 	else
; 3964 : 		nRange = 32;

  00173	bb 20 00 00 00	 mov	 ebx, 32			; 00000020H
$L285359:

; 3965 : 	
; 3966 : 	if( fDepth <= 0 )	//  0  .

  00178	d9 84 24 c0 01
	00 00		 fld	 DWORD PTR _fDepth$[esp+420]
  0017f	8b b4 24 b4 01
	00 00		 mov	 esi, DWORD PTR _nAttackID$[esp+420]
  00186	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0018c	89 5c 24 14	 mov	 DWORD PTR _nRange$[esp+424], ebx
  00190	df e0		 fnstsw	 ax
  00192	f6 c4 41	 test	 ah, 65			; 00000041H
  00195	7a 25		 jp	 SHORT $L275811

; 3967 : 		Error( "CMover::SendDamageLine : D:%s A:%s %d %f", GetName(), nAttackID, fDepth );

  00197	d9 84 24 c0 01
	00 00		 fld	 DWORD PTR _fDepth$[esp+420]
  0019e	83 ec 08	 sub	 esp, 8
  001a1	dd 1c 24	 fstp	 QWORD PTR [esp]
  001a4	56		 push	 esi
  001a5	6a 00		 push	 0
  001a7	8b cf		 mov	 ecx, edi
  001a9	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  001ae	50		 push	 eax
  001af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@BEJKIDOG@CMover?3?3SendDamageLine?5?3?5D?3?$CFs?5A?3@
  001b4	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  001b9	83 c4 14	 add	 esp, 20			; 00000014H
$L275811:

; 3968 : 
; 3969 : 	ItemProp* pProp;
; 3970 : 	if( nDmgType == AF_MAGICSKILL )

  001bc	83 bc 24 ac 01
	00 00 20	 cmp	 DWORD PTR _nDmgType$[esp+420], 32 ; 00000020H
  001c4	75 60		 jne	 SHORT $L285066

; 3971 : 	{
; 3972 : 		pProp = prj.GetSkillProp( nAttackID );		// UseSkill    

  001c6	85 f6		 test	 esi, esi
  001c8	a1 80 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+640
  001cd	7c 3f		 jl	 SHORT $L285031
  001cf	3b f0		 cmp	 esi, eax
  001d1	7d 3b		 jge	 SHORT $L285031
  001d3	72 04		 jb	 SHORT $L285041
  001d5	33 c0		 xor	 eax, eax
  001d7	eb 08		 jmp	 SHORT $L285040
$L285041:
  001d9	a1 70 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+624
  001de	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
$L285040:

; 3973 : 		if( pProp == NULL )

  001e1	85 c0		 test	 eax, eax
  001e3	89 44 24 70	 mov	 DWORD PTR _pProp$[esp+424], eax
  001e7	0f 85 96 00 00
	00		 jne	 $L275819
$L285341:

; 3974 : 		{
; 3975 : 			Error( "CMover::SendDamageLine : %s. (%d)  .", m_szName, nAttackID );

  001ed	56		 push	 esi
  001ee	81 c7 90 16 00
	00		 add	 edi, 5776		; 00001690H
  001f4	57		 push	 edi
  001f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DL@KEBMKGCP@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LN?$LK?E@
  001fa	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  001ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx

; 4048 : 	}
; 4049 : 		
; 4050 : #endif // WORLDSERVER		
; 4051 : } // SendDamageLine()

  00205	81 c4 9c 01 00
	00		 add	 esp, 412		; 0000019cH
  0020b	c2 18 00	 ret	 24			; 00000018H

; 3971 : 	{
; 3972 : 		pProp = prj.GetSkillProp( nAttackID );		// UseSkill    

$L285031:
  0020e	56		 push	 esi
  0020f	50		 push	 eax
  00210	6a 00		 push	 0
  00212	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  00217	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0021c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00221	83 c4 14	 add	 esp, 20			; 00000014H

; 3973 : 		if( pProp == NULL )

  00224	eb c7		 jmp	 SHORT $L285341

; 3976 : 			return;	// property not found
; 3977 : 		}
; 3978 : 	} else
; 3979 : 	{
; 3980 : 		pProp = prj.GetItemProp( nAttackID );		//  

$L285066:
  00226	85 f6		 test	 esi, esi
  00228	a1 5c 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+604
  0022d	7c 3c		 jl	 SHORT $L285070
  0022f	3b f0		 cmp	 esi, eax
  00231	7d 38		 jge	 SHORT $L285070
  00233	72 04		 jb	 SHORT $L285082
  00235	33 c0		 xor	 eax, eax
  00237	eb 09		 jmp	 SHORT $L285081
$L285082:
  00239	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0023f	8b 04 b1	 mov	 eax, DWORD PTR [ecx+esi*4]
$L285081:

; 3981 : 		if( pProp == NULL )

  00242	85 c0		 test	 eax, eax
  00244	89 44 24 70	 mov	 DWORD PTR _pProp$[esp+424], eax
  00248	75 39		 jne	 SHORT $L275819
$L285342:

; 3982 : 		{
; 3983 : 			Error( "CMover::SendDamageLine : %s. (%d)  .", m_szName, nAttackID );

  0024a	56		 push	 esi
  0024b	81 c7 90 16 00
	00		 add	 edi, 5776		; 00001690H
  00251	57		 push	 edi
  00252	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@LKDJCKJ@CMover?3?3SendDamageLine?5?3?5?$CFs?4?5?$LO?F?$MA@
  00257	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0025c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025f	5f		 pop	 edi
  00260	5e		 pop	 esi
  00261	5b		 pop	 ebx

; 4048 : 	}
; 4049 : 		
; 4050 : #endif // WORLDSERVER		
; 4051 : } // SendDamageLine()

  00262	81 c4 9c 01 00
	00		 add	 esp, 412		; 0000019cH
  00268	c2 18 00	 ret	 24			; 00000018H

; 3976 : 			return;	// property not found
; 3977 : 		}
; 3978 : 	} else
; 3979 : 	{
; 3980 : 		pProp = prj.GetItemProp( nAttackID );		//  

$L285070:
  0026b	56		 push	 esi
  0026c	50		 push	 eax
  0026d	6a 00		 push	 0
  0026f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00274	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00279	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0027e	83 c4 14	 add	 esp, 20			; 00000014H

; 3981 : 		if( pProp == NULL )

  00281	eb c7		 jmp	 SHORT $L285342
$L275819:

; 3984 : 			return;	// property not found
; 3985 : 		}
; 3986 : 	}
; 3987 : 	
; 3988 : 	BOOL	bDamage = FALSE;
; 3989 : 
; 3990 : 	if( nApplyType & OBJTYPE_PLAYER )	//   

  00283	f6 84 24 b0 01
	00 00 01	 test	 BYTE PTR _nApplyType$[esp+420], 1
  0028b	55		 push	 ebp
  0028c	0f 84 4f 03 00
	00		 je	 $L285351

; 3991 : 	{
; 3992 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkPlayer, GetLayer() )

  00292	8b 97 6c 01 00
	00		 mov	 edx, DWORD PTR [edi+364]
  00298	db 42 14	 fild	 DWORD PTR [edx+20]
  0029b	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  002a1	d9 44 24 68	 fld	 DWORD PTR _vPos$[esp+428]
  002a5	d8 c9		 fmul	 ST(0), ST(1)
  002a7	e8 00 00 00 00	 call	 __ftol2
  002ac	d8 4c 24 70	 fmul	 DWORD PTR _vPos$[esp+436]
  002b0	8b f0		 mov	 esi, eax
  002b2	89 74 24 2c	 mov	 DWORD PTR __nLinkX$275823[esp+428], esi
  002b6	e8 00 00 00 00	 call	 __ftol2
  002bb	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  002c1	8b e8		 mov	 ebp, eax
  002c3	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  002c9	50		 push	 eax
  002ca	6a 02		 push	 2
  002cc	83 c1 24	 add	 ecx, 36			; 00000024H
  002cf	89 6c 24 30	 mov	 DWORD PTR __nLinkZ$275825[esp+436], ebp
  002d3	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR __i$275839[esp+436], 0
  002db	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  002e0	85 c0		 test	 eax, eax
  002e2	0f 8e f9 02 00
	00		 jle	 $L285351
  002e8	d9 44 24 68	 fld	 DWORD PTR _vPos$[esp+428]
  002ec	e8 00 00 00 00	 call	 __ftol2
  002f1	d9 44 24 70	 fld	 DWORD PTR _vPos$[esp+436]
  002f5	89 44 24 50	 mov	 DWORD PTR tv921[esp+428], eax
  002f9	e8 00 00 00 00	 call	 __ftol2
  002fe	89 44 24 5c	 mov	 DWORD PTR tv927[esp+428], eax
  00302	8b c6		 mov	 eax, esi
  00304	2b c3		 sub	 eax, ebx
  00306	89 44 24 64	 mov	 DWORD PTR tv930[esp+428], eax
  0030a	8b c5		 mov	 eax, ebp
  0030c	2b c3		 sub	 eax, ebx
  0030e	03 f3		 add	 esi, ebx
  00310	03 eb		 add	 ebp, ebx
  00312	89 44 24 60	 mov	 DWORD PTR tv935[esp+428], eax
  00316	89 74 24 58	 mov	 DWORD PTR tv940[esp+428], esi
  0031a	89 6c 24 48	 mov	 DWORD PTR tv945[esp+428], ebp
  0031e	8b ff		 npad	 2
$L275840:
  00320	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  00326	8b 74 24 24	 mov	 esi, DWORD PTR __i$275839[esp+428]
  0032a	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  00330	50		 push	 eax
  00331	56		 push	 esi
  00332	6a 02		 push	 2
  00334	83 c1 24	 add	 ecx, 36			; 00000024H
  00337	e8 00 00 00 00	 call	 ?GetLinkWidth@CLayeredLinkMap@@QAEHKHH@Z ; CLayeredLinkMap::GetLinkWidth
  0033c	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  00342	8b d8		 mov	 ebx, eax
  00344	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  0034a	50		 push	 eax
  0034b	56		 push	 esi
  0034c	6a 02		 push	 2
  0034e	83 c1 24	 add	 ecx, 36			; 00000024H
  00351	e8 00 00 00 00	 call	 ?GetObj@CLayeredLinkMap@@QAEPAPAVCObj@@KKH@Z ; CLayeredLinkMap::GetObj
  00356	8b b7 6c 01 00
	00		 mov	 esi, DWORD PTR [edi+364]
  0035c	89 44 24 1c	 mov	 DWORD PTR __pObjs$275843[esp+428], eax
  00360	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00363	8b e8		 mov	 ebp, eax
  00365	c1 e0 07	 shl	 eax, 7
  00368	0f af eb	 imul	 ebp, ebx
  0036b	99		 cdq
  0036c	f7 fd		 idiv	 ebp
  0036e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00371	0f af cb	 imul	 ecx, ebx
  00374	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00377	89 4c 24 10	 mov	 DWORD PTR __nMaxHeight$275829[esp+428], ecx
  0037b	8b c8		 mov	 ecx, eax
  0037d	8b c3		 mov	 eax, ebx
  0037f	0f af c1	 imul	 eax, ecx
  00382	99		 cdq
  00383	2b c2		 sub	 eax, edx
  00385	8b f0		 mov	 esi, eax
  00387	8b 44 24 2c	 mov	 eax, DWORD PTR __nLinkX$275823[esp+428]
  0038b	99		 cdq
  0038c	f7 f9		 idiv	 ecx
  0038e	8b 54 24 50	 mov	 edx, DWORD PTR tv921[esp+428]
  00392	d1 fe		 sar	 esi, 1
  00394	0f af c3	 imul	 eax, ebx
  00397	0f af c1	 imul	 eax, ecx
  0039a	2b d0		 sub	 edx, eax
  0039c	33 c0		 xor	 eax, eax
  0039e	3b d6		 cmp	 edx, esi
  003a0	0f 9f c0	 setg	 al
  003a3	89 44 24 14	 mov	 DWORD PTR __nX$275835[esp+428], eax
  003a7	8b 44 24 28	 mov	 eax, DWORD PTR __nLinkZ$275825[esp+428]
  003ab	99		 cdq
  003ac	f7 f9		 idiv	 ecx
  003ae	8b 54 24 5c	 mov	 edx, DWORD PTR tv927[esp+428]
  003b2	0f af c3	 imul	 eax, ebx
  003b5	0f af c1	 imul	 eax, ecx
  003b8	2b d0		 sub	 edx, eax
  003ba	33 c0		 xor	 eax, eax
  003bc	3b d6		 cmp	 edx, esi
  003be	0f 9f c0	 setg	 al
  003c1	8b f0		 mov	 esi, eax
  003c3	8b 44 24 64	 mov	 eax, DWORD PTR tv930[esp+428]
  003c7	99		 cdq
  003c8	f7 f9		 idiv	 ecx
  003ca	8b 54 24 14	 mov	 edx, DWORD PTR __nX$275835[esp+428]
  003ce	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  003d2	85 c0		 test	 eax, eax
  003d4	89 44 24 20	 mov	 DWORD PTR __nLinkXMin$275831[esp+428], eax
  003d8	7d 08		 jge	 SHORT $L285354
  003da	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __nLinkXMin$275831[esp+428], 0
$L285354:
  003e2	8b 44 24 60	 mov	 eax, DWORD PTR tv935[esp+428]
  003e6	99		 cdq
  003e7	f7 f9		 idiv	 ecx
  003e9	8d 5c 30 ff	 lea	 ebx, DWORD PTR [eax+esi-1]
  003ed	85 db		 test	 ebx, ebx
  003ef	7d 02		 jge	 SHORT $L275848
  003f1	33 db		 xor	 ebx, ebx
$L275848:
  003f3	8b 44 24 58	 mov	 eax, DWORD PTR tv940[esp+428]
  003f7	99		 cdq
  003f8	f7 f9		 idiv	 ecx
  003fa	03 44 24 14	 add	 eax, DWORD PTR __nX$275835[esp+428]
  003fe	3b c5		 cmp	 eax, ebp
  00400	89 44 24 14	 mov	 DWORD PTR __nLinkXMax$275833[esp+428], eax
  00404	7c 07		 jl	 SHORT $L275849
  00406	8d 45 ff	 lea	 eax, DWORD PTR [ebp-1]
  00409	89 44 24 14	 mov	 DWORD PTR __nLinkXMax$275833[esp+428], eax
$L275849:
  0040d	8b 44 24 48	 mov	 eax, DWORD PTR tv945[esp+428]
  00411	99		 cdq
  00412	f7 f9		 idiv	 ecx
  00414	8b 4c 24 10	 mov	 ecx, DWORD PTR __nMaxHeight$275829[esp+428]
  00418	03 c6		 add	 eax, esi
  0041a	3b c1		 cmp	 eax, ecx
  0041c	7c 03		 jl	 SHORT $L275850
  0041e	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$L275850:
  00421	3b d8		 cmp	 ebx, eax
  00423	0f 8f 8c 01 00
	00		 jg	 $L275841
  00429	8b 74 24 1c	 mov	 esi, DWORD PTR __pObjs$275843[esp+428]
  0042d	8b d3		 mov	 edx, ebx
  0042f	0f af d5	 imul	 edx, ebp
  00432	8d 0c ad 00 00
	00 00		 lea	 ecx, DWORD PTR [ebp*4]
  00439	89 4c 24 54	 mov	 DWORD PTR tv1503[esp+428], ecx
  0043d	8b 4c 24 20	 mov	 ecx, DWORD PTR __nLinkXMin$275831[esp+428]
  00441	03 d1		 add	 edx, ecx
  00443	2b c3		 sub	 eax, ebx
  00445	8d 14 96	 lea	 edx, DWORD PTR [esi+edx*4]
  00448	40		 inc	 eax
  00449	89 54 24 1c	 mov	 DWORD PTR tv1499[esp+428], edx
  0044d	89 44 24 10	 mov	 DWORD PTR tv408[esp+428], eax
$L275852:
  00451	8b 6c 24 14	 mov	 ebp, DWORD PTR __nLinkXMax$275833[esp+428]
  00455	3b cd		 cmp	 ecx, ebp
  00457	0f 8f 3b 01 00
	00		 jg	 $L275853
  0045d	2b e9		 sub	 ebp, ecx
  0045f	8b da		 mov	 ebx, edx
  00461	45		 inc	 ebp
$L275856:
  00462	8b 33		 mov	 esi, DWORD PTR [ebx]
  00464	85 f6		 test	 esi, esi
  00466	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0046b	0f 84 19 01 00
	00		 je	 $L275857
$L275861:
  00471	8b c8		 mov	 ecx, eax
  00473	48		 dec	 eax
  00474	85 c9		 test	 ecx, ecx
  00476	89 44 24 4c	 mov	 DWORD PTR ___limit$275859[esp+428], eax
  0047a	0f 84 0a 01 00
	00		 je	 $L275857

; 3993 : 		{
; 3994 : 			if( pObj->GetType() == OT_MOVER )

  00480	83 be 70 01 00
	00 05		 cmp	 DWORD PTR [esi+368], 5
  00487	0f 85 ef 00 00
	00		 jne	 $L275872

; 3995 : 			{
; 3996 : 				bDamage = TRUE;	
; 3997 : 
; 3998 : 				if( bDamage && pObj != this )		// this  .

  0048d	3b f7		 cmp	 esi, edi
  0048f	0f 84 e7 00 00
	00		 je	 $L275872

; 3999 : 				{
; 4000 : 					pTarget = (CMover *)pObj;
; 4001 : 					if( IsValidObj( pTarget ) && pTarget->IsLive() )

  00495	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00499	0f 85 dd 00 00
	00		 jne	 $L275872
  0049f	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  004a5	f7 42 04 00 00
	00 08		 test	 DWORD PTR [edx+4], 134217728 ; 08000000H
  004ac	74 0e		 je	 SHORT $L285164
  004ae	8b 8e 00 06 00
	00		 mov	 ecx, DWORD PTR [esi+1536]
  004b4	85 c9		 test	 ecx, ecx
  004b6	0f 8e c0 00 00
	00		 jle	 $L275872
$L285164:

; 4002 : 					{
; 4003 : 						//   .
; 4004 : 						D3DXVec3TransformCoord( &vDestLocal, &pTarget->GetPos(), &mInv );

  004bc	8d 86 60 01 00
	00		 lea	 eax, DWORD PTR [esi+352]
  004c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  004c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004c7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004ca	89 8c 24 84 00
	00 00		 mov	 DWORD PTR $T284965[esp+428], ecx
  004d1	8d 8c 24 ac 00
	00 00		 lea	 ecx, DWORD PTR _mInv$[esp+428]
  004d8	89 94 24 88 00
	00 00		 mov	 DWORD PTR $T284965[esp+432], edx
  004df	51		 push	 ecx
  004e0	8d 94 24 88 00
	00 00		 lea	 edx, DWORD PTR $T284965[esp+432]
  004e7	89 84 24 90 00
	00 00		 mov	 DWORD PTR $T284965[esp+440], eax
  004ee	52		 push	 edx
  004ef	8d 44 24 44	 lea	 eax, DWORD PTR _vDestLocal$[esp+436]
  004f3	50		 push	 eax
  004f4	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 4005 : 						//  AABB
; 4006 : 						D3DXVECTOR3 vMin2 = vDestLocal + pTarget->m_pModel->m_vMin;

  004f9	d9 44 24 44	 fld	 DWORD PTR _vDestLocal$[esp+436]
  004fd	8b 86 78 01 00
	00		 mov	 eax, DWORD PTR [esi+376]
  00503	d8 80 80 00 00
	00		 fadd	 DWORD PTR [eax+128]

; 4007 : 						D3DXVECTOR3 vMax2 = vDestLocal + pTarget->m_pModel->m_vMax;
; 4008 : 						if( ::IsTouchAABB( vMin1, vMax1, vMin2, vMax2 ) )		// AABB.

  00509	8d 4c 24 78	 lea	 ecx, DWORD PTR _vMax2$275870[esp+428]
  0050d	d9 44 24 40	 fld	 DWORD PTR _vDestLocal$[esp+432]
  00511	51		 push	 ecx
  00512	d8 40 7c	 fadd	 DWORD PTR [eax+124]
  00515	8d 54 24 34	 lea	 edx, DWORD PTR _vMin2$275868[esp+432]
  00519	d9 44 24 40	 fld	 DWORD PTR _vDestLocal$[esp+432]
  0051d	52		 push	 edx
  0051e	d8 40 78	 fadd	 DWORD PTR [eax+120]
  00521	8d 8c 24 a8 00
	00 00		 lea	 ecx, DWORD PTR _vMin1$[esp+436]
  00528	d9 5c 24 38	 fstp	 DWORD PTR _vMin2$275868[esp+436]
  0052c	d9 5c 24 3c	 fstp	 DWORD PTR _vMin2$275868[esp+440]
  00530	d9 5c 24 40	 fstp	 DWORD PTR _vMin2$275868[esp+444]
  00534	d9 44 24 4c	 fld	 DWORD PTR _vDestLocal$[esp+444]
  00538	d8 80 8c 00 00
	00		 fadd	 DWORD PTR [eax+140]
  0053e	d9 44 24 48	 fld	 DWORD PTR _vDestLocal$[esp+440]
  00542	d8 80 88 00 00
	00		 fadd	 DWORD PTR [eax+136]
  00548	d9 44 24 44	 fld	 DWORD PTR _vDestLocal$[esp+436]
  0054c	d8 80 84 00 00
	00		 fadd	 DWORD PTR [eax+132]
  00552	8d 84 24 9c 00
	00 00		 lea	 eax, DWORD PTR _vMax1$[esp+436]
  00559	50		 push	 eax
  0055a	51		 push	 ecx
  0055b	d9 9c 24 88 00
	00 00		 fstp	 DWORD PTR _vMax2$275870[esp+444]
  00562	d9 9c 24 8c 00
	00 00		 fstp	 DWORD PTR _vMax2$275870[esp+448]
  00569	d9 9c 24 90 00
	00 00		 fstp	 DWORD PTR _vMax2$275870[esp+452]
  00570	e8 00 00 00 00	 call	 ?IsTouchAABB@@YAHABUD3DXVECTOR3@@000@Z ; IsTouchAABB
  00575	8b 44 24 5c	 mov	 eax, DWORD PTR ___limit$275859[esp+444]
  00579	83 c4 10	 add	 esp, 16			; 00000010H
$L275872:

; 4009 : 						{
; 4010 : 						//	if( pProp->dwComboStyle == CT_FINISH )
; 4011 : 						//		pTarget->m_pActMover->SendDamageForce( nDmgType, pAttacker->GetId(), (nAttackID << 16) );
; 4012 : 						//	else
; 4013 : 						//		pTarget->m_pActMover->SendDamage( nDmgType, pAttacker->GetId(), (nAttackID << 16) ); 					
; 4014 : 						}
; 4015 : 					}
; 4016 : 				} // bDamage
; 4017 : 			}
; 4018 : 		}
; 4019 : 		END_LINKMAP

  0057c	8b b6 80 01 00
	00		 mov	 esi, DWORD PTR [esi+384]
  00582	85 f6		 test	 esi, esi
  00584	0f 85 e7 fe ff
	ff		 jne	 $L275861
$L275857:

; 3991 : 	{
; 3992 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkPlayer, GetLayer() )

  0058a	83 c3 04	 add	 ebx, 4
  0058d	4d		 dec	 ebp
  0058e	0f 85 ce fe ff
	ff		 jne	 $L275856
  00594	8b 4c 24 20	 mov	 ecx, DWORD PTR __nLinkXMin$275831[esp+428]
$L275853:
  00598	8b 54 24 1c	 mov	 edx, DWORD PTR tv1499[esp+428]
  0059c	8b 74 24 54	 mov	 esi, DWORD PTR tv1503[esp+428]
  005a0	8b 44 24 10	 mov	 eax, DWORD PTR tv408[esp+428]
  005a4	03 d6		 add	 edx, esi
  005a6	48		 dec	 eax
  005a7	89 54 24 1c	 mov	 DWORD PTR tv1499[esp+428], edx
  005ab	89 44 24 10	 mov	 DWORD PTR tv408[esp+428], eax
  005af	0f 85 9c fe ff
	ff		 jne	 $L275852
$L275841:
  005b5	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  005bb	8b 74 24 24	 mov	 esi, DWORD PTR __i$275839[esp+428]
  005bf	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  005c5	50		 push	 eax
  005c6	46		 inc	 esi
  005c7	6a 02		 push	 2
  005c9	83 c1 24	 add	 ecx, 36			; 00000024H
  005cc	89 74 24 2c	 mov	 DWORD PTR __i$275839[esp+436], esi
  005d0	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  005d5	3b f0		 cmp	 esi, eax
  005d7	0f 8c 43 fd ff
	ff		 jl	 $L275840
  005dd	8b 5c 24 18	 mov	 ebx, DWORD PTR _nRange$[esp+428]
$L285351:

; 4020 : 	}
; 4021 : 
; 4022 : 	//  .
; 4023 : 	if( nApplyType & OBJTYPE_MONSTER )

  005e1	f6 84 24 b4 01
	00 00 02	 test	 BYTE PTR _nApplyType$[esp+424], 2
  005e9	0f 84 d6 03 00
	00		 je	 $L285358

; 4024 : 	{
; 4025 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkDynamic, GetLayer() )

  005ef	8b 97 6c 01 00
	00		 mov	 edx, DWORD PTR [edi+364]
  005f5	db 42 14	 fild	 DWORD PTR [edx+20]
  005f8	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
  005fe	d9 44 24 68	 fld	 DWORD PTR _vPos$[esp+428]
  00602	d8 c9		 fmul	 ST(0), ST(1)
  00604	e8 00 00 00 00	 call	 __ftol2
  00609	d9 44 24 70	 fld	 DWORD PTR _vPos$[esp+436]
  0060d	8b f0		 mov	 esi, eax
  0060f	d8 c9		 fmul	 ST(0), ST(1)
  00611	89 74 24 54	 mov	 DWORD PTR __nLinkX$275874[esp+428], esi
  00615	e8 00 00 00 00	 call	 __ftol2
  0061a	dd d8		 fstp	 ST(0)
  0061c	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  00622	8b e8		 mov	 ebp, eax
  00624	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  0062a	50		 push	 eax
  0062b	6a 01		 push	 1
  0062d	83 c1 24	 add	 ecx, 36			; 00000024H
  00630	89 6c 24 54	 mov	 DWORD PTR __nLinkZ$275876[esp+436], ebp
  00634	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __i$275890[esp+436], 0
  0063c	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  00641	85 c0		 test	 eax, eax
  00643	0f 8e 7c 03 00
	00		 jle	 $L285358
  00649	d9 44 24 68	 fld	 DWORD PTR _vPos$[esp+428]
  0064d	e8 00 00 00 00	 call	 __ftol2
  00652	d9 44 24 70	 fld	 DWORD PTR _vPos$[esp+436]
  00656	89 44 24 50	 mov	 DWORD PTR tv921[esp+428], eax
  0065a	e8 00 00 00 00	 call	 __ftol2
  0065f	89 44 24 5c	 mov	 DWORD PTR tv927[esp+428], eax
  00663	8b c6		 mov	 eax, esi
  00665	2b c3		 sub	 eax, ebx
  00667	89 44 24 48	 mov	 DWORD PTR tv1071[esp+428], eax
  0066b	8b c5		 mov	 eax, ebp
  0066d	2b c3		 sub	 eax, ebx
  0066f	03 f3		 add	 esi, ebx
  00671	03 eb		 add	 ebp, ebx
  00673	89 44 24 58	 mov	 DWORD PTR tv1076[esp+428], eax
  00677	89 74 24 60	 mov	 DWORD PTR tv1081[esp+428], esi
  0067b	89 6c 24 64	 mov	 DWORD PTR tv1086[esp+428], ebp
  0067f	90		 npad	 1
$L275891:
  00680	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  00686	8b 74 24 14	 mov	 esi, DWORD PTR __i$275890[esp+428]
  0068a	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  00690	50		 push	 eax
  00691	56		 push	 esi
  00692	6a 01		 push	 1
  00694	83 c1 24	 add	 ecx, 36			; 00000024H
  00697	e8 00 00 00 00	 call	 ?GetLinkWidth@CLayeredLinkMap@@QAEHKHH@Z ; CLayeredLinkMap::GetLinkWidth
  0069c	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  006a2	8b d8		 mov	 ebx, eax
  006a4	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  006aa	50		 push	 eax
  006ab	56		 push	 esi
  006ac	6a 01		 push	 1
  006ae	83 c1 24	 add	 ecx, 36			; 00000024H
  006b1	e8 00 00 00 00	 call	 ?GetObj@CLayeredLinkMap@@QAEPAPAVCObj@@KKH@Z ; CLayeredLinkMap::GetObj
  006b6	8b b7 6c 01 00
	00		 mov	 esi, DWORD PTR [edi+364]
  006bc	89 44 24 28	 mov	 DWORD PTR __pObjs$275894[esp+428], eax
  006c0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  006c3	8b eb		 mov	 ebp, ebx
  006c5	0f af e8	 imul	 ebp, eax
  006c8	c1 e0 07	 shl	 eax, 7
  006cb	99		 cdq
  006cc	f7 fd		 idiv	 ebp
  006ce	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006d1	0f af cb	 imul	 ecx, ebx
  006d4	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  006d7	89 4c 24 2c	 mov	 DWORD PTR __nMaxHeight$275880[esp+428], ecx
  006db	8b c8		 mov	 ecx, eax
  006dd	0f af c3	 imul	 eax, ebx
  006e0	99		 cdq
  006e1	2b c2		 sub	 eax, edx
  006e3	8b f0		 mov	 esi, eax
  006e5	8b 44 24 54	 mov	 eax, DWORD PTR __nLinkX$275874[esp+428]
  006e9	99		 cdq
  006ea	f7 f9		 idiv	 ecx
  006ec	8b 54 24 50	 mov	 edx, DWORD PTR tv921[esp+428]
  006f0	d1 fe		 sar	 esi, 1
  006f2	0f af c1	 imul	 eax, ecx
  006f5	0f af c3	 imul	 eax, ebx
  006f8	2b d0		 sub	 edx, eax
  006fa	33 c0		 xor	 eax, eax
  006fc	3b d6		 cmp	 edx, esi
  006fe	0f 9f c0	 setg	 al
  00701	89 44 24 10	 mov	 DWORD PTR __nX$275886[esp+428], eax
  00705	8b 44 24 4c	 mov	 eax, DWORD PTR __nLinkZ$275876[esp+428]
  00709	99		 cdq
  0070a	f7 f9		 idiv	 ecx
  0070c	8b 54 24 5c	 mov	 edx, DWORD PTR tv927[esp+428]
  00710	0f af c1	 imul	 eax, ecx
  00713	0f af c3	 imul	 eax, ebx
  00716	2b d0		 sub	 edx, eax
  00718	33 c0		 xor	 eax, eax
  0071a	3b d6		 cmp	 edx, esi
  0071c	0f 9f c0	 setg	 al
  0071f	8b f0		 mov	 esi, eax
  00721	8b 44 24 48	 mov	 eax, DWORD PTR tv1071[esp+428]
  00725	99		 cdq
  00726	f7 f9		 idiv	 ecx
  00728	8b 54 24 10	 mov	 edx, DWORD PTR __nX$275886[esp+428]
  0072c	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  00730	85 c0		 test	 eax, eax
  00732	89 44 24 20	 mov	 DWORD PTR __nLinkXMin$275882[esp+428], eax
  00736	7d 08		 jge	 SHORT $L285352
  00738	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __nLinkXMin$275882[esp+428], 0
$L285352:
  00740	8b 44 24 58	 mov	 eax, DWORD PTR tv1076[esp+428]
  00744	99		 cdq
  00745	f7 f9		 idiv	 ecx
  00747	8d 5c 30 ff	 lea	 ebx, DWORD PTR [eax+esi-1]
  0074b	85 db		 test	 ebx, ebx
  0074d	7d 02		 jge	 SHORT $L275899
  0074f	33 db		 xor	 ebx, ebx
$L275899:
  00751	8b 44 24 60	 mov	 eax, DWORD PTR tv1081[esp+428]
  00755	99		 cdq
  00756	f7 f9		 idiv	 ecx
  00758	03 44 24 10	 add	 eax, DWORD PTR __nX$275886[esp+428]
  0075c	3b c5		 cmp	 eax, ebp
  0075e	89 44 24 10	 mov	 DWORD PTR __nLinkXMax$275884[esp+428], eax
  00762	7c 07		 jl	 SHORT $L275900
  00764	8d 45 ff	 lea	 eax, DWORD PTR [ebp-1]
  00767	89 44 24 10	 mov	 DWORD PTR __nLinkXMax$275884[esp+428], eax
$L275900:
  0076b	8b 44 24 64	 mov	 eax, DWORD PTR tv1086[esp+428]
  0076f	99		 cdq
  00770	f7 f9		 idiv	 ecx
  00772	8b 4c 24 2c	 mov	 ecx, DWORD PTR __nMaxHeight$275880[esp+428]
  00776	03 c6		 add	 eax, esi
  00778	3b c1		 cmp	 eax, ecx
  0077a	7c 03		 jl	 SHORT $L275901
  0077c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$L275901:
  0077f	3b d8		 cmp	 ebx, eax
  00781	0f 8f 16 02 00
	00		 jg	 $L275892
  00787	8b 74 24 28	 mov	 esi, DWORD PTR __pObjs$275894[esp+428]
  0078b	8b d3		 mov	 edx, ebx
  0078d	0f af d5	 imul	 edx, ebp
  00790	8d 0c ad 00 00
	00 00		 lea	 ecx, DWORD PTR [ebp*4]
  00797	8b ac 24 b8 01
	00 00		 mov	 ebp, DWORD PTR _nAttackID$[esp+424]
  0079e	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv1607[esp+428], ecx
  007a5	8b 4c 24 20	 mov	 ecx, DWORD PTR __nLinkXMin$275882[esp+428]
  007a9	03 d1		 add	 edx, ecx
  007ab	2b c3		 sub	 eax, ebx
  007ad	8b 9c 24 b0 01
	00 00		 mov	 ebx, DWORD PTR _nDmgType$[esp+424]
  007b4	8d 14 96	 lea	 edx, DWORD PTR [esi+edx*4]
  007b7	40		 inc	 eax
  007b8	89 54 24 18	 mov	 DWORD PTR tv1603[esp+428], edx
  007bc	89 44 24 2c	 mov	 DWORD PTR tv345[esp+428], eax
$L275903:
  007c0	8b 44 24 10	 mov	 eax, DWORD PTR __nLinkXMax$275884[esp+428]
  007c4	3b c8		 cmp	 ecx, eax
  007c6	0f 8f b1 01 00
	00		 jg	 $L275904
  007cc	8b 54 24 18	 mov	 edx, DWORD PTR tv1603[esp+428]
  007d0	2b c1		 sub	 eax, ecx
  007d2	40		 inc	 eax
  007d3	89 54 24 24	 mov	 DWORD PTR tv1557[esp+428], edx
  007d7	89 44 24 28	 mov	 DWORD PTR tv371[esp+428], eax
  007db	eb 03 8d 49 00	 npad	 5
$L275907:
  007e0	8b 44 24 24	 mov	 eax, DWORD PTR tv1557[esp+428]
  007e4	8b 30		 mov	 esi, DWORD PTR [eax]
  007e6	85 f6		 test	 esi, esi
  007e8	c7 44 24 1c e8
	03 00 00	 mov	 DWORD PTR ___limit$275910[esp+428], 1000 ; 000003e8H
  007f0	0f 84 69 01 00
	00		 je	 $L275908
$L275912:
  007f6	8b 44 24 1c	 mov	 eax, DWORD PTR ___limit$275910[esp+428]
  007fa	8b c8		 mov	 ecx, eax
  007fc	48		 dec	 eax
  007fd	85 c9		 test	 ecx, ecx
  007ff	89 44 24 1c	 mov	 DWORD PTR ___limit$275910[esp+428], eax
  00803	0f 84 56 01 00
	00		 je	 $L275908

; 4026 : 		{
; 4027 : 			if( pObj->GetType() == OT_MOVER && ((CMover *)pObj)->IsPeaceful() == FALSE )

  00809	83 be 70 01 00
	00 05		 cmp	 DWORD PTR [esi+368], 5
  00810	0f 85 3b 01 00
	00		 jne	 $L285356
  00816	83 be 6c 06 00
	00 01		 cmp	 DWORD PTR [esi+1644], 1
  0081d	0f 84 2e 01 00
	00		 je	 $L285356

; 4028 : 			{
; 4029 : 				pTarget = (CMover *)pObj;
; 4030 : 				if( IsValidObj( pTarget ) && pTarget->IsLive() )

  00823	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00827	0f 85 24 01 00
	00		 jne	 $L285356
  0082d	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  00833	f7 42 04 00 00
	00 08		 test	 DWORD PTR [edx+4], 134217728 ; 08000000H
  0083a	74 0e		 je	 SHORT $L285281
  0083c	8b 86 00 06 00
	00		 mov	 eax, DWORD PTR [esi+1536]
  00842	85 c0		 test	 eax, eax
  00844	0f 8e 07 01 00
	00		 jle	 $L285356
$L285281:

; 4031 : 				{
; 4032 : 					//   .
; 4033 : 					D3DXVec3TransformCoord( &vDestLocal, &pTarget->GetPos(), &mInv );

  0084a	8d 86 60 01 00
	00		 lea	 eax, DWORD PTR [esi+352]
  00850	8b 08		 mov	 ecx, DWORD PTR [eax]
  00852	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00855	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00858	89 4c 24 30	 mov	 DWORD PTR $T284966[esp+428], ecx
  0085c	8d 8c 24 ac 00
	00 00		 lea	 ecx, DWORD PTR _mInv$[esp+428]
  00863	89 54 24 34	 mov	 DWORD PTR $T284966[esp+432], edx
  00867	51		 push	 ecx
  00868	8d 54 24 34	 lea	 edx, DWORD PTR $T284966[esp+432]
  0086c	89 44 24 3c	 mov	 DWORD PTR $T284966[esp+440], eax
  00870	52		 push	 edx
  00871	8d 44 24 44	 lea	 eax, DWORD PTR _vDestLocal$[esp+436]
  00875	50		 push	 eax
  00876	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 4034 : 					//  AABB
; 4035 : 					D3DXVECTOR3 vMin2 = vDestLocal + pTarget->m_pModel->m_vMin;

  0087b	d9 44 24 44	 fld	 DWORD PTR _vDestLocal$[esp+436]
  0087f	8b 86 78 01 00
	00		 mov	 eax, DWORD PTR [esi+376]
  00885	d8 80 80 00 00
	00		 fadd	 DWORD PTR [eax+128]

; 4036 : 					D3DXVECTOR3 vMax2 = vDestLocal + pTarget->m_pModel->m_vMax;
; 4037 : 					if( ::IsTouchAABB( vMin1, vMax1, vMin2, vMax2 ) )		// AABB.

  0088b	8d 4c 24 78	 lea	 ecx, DWORD PTR _vMax2$275921[esp+428]
  0088f	d9 44 24 40	 fld	 DWORD PTR _vDestLocal$[esp+432]
  00893	51		 push	 ecx
  00894	d8 40 7c	 fadd	 DWORD PTR [eax+124]
  00897	8d 94 24 88 00
	00 00		 lea	 edx, DWORD PTR _vMin2$275919[esp+432]
  0089e	d9 44 24 40	 fld	 DWORD PTR _vDestLocal$[esp+432]
  008a2	52		 push	 edx
  008a3	d8 40 78	 fadd	 DWORD PTR [eax+120]
  008a6	8d 8c 24 a8 00
	00 00		 lea	 ecx, DWORD PTR _vMin1$[esp+436]
  008ad	d9 9c 24 8c 00
	00 00		 fstp	 DWORD PTR _vMin2$275919[esp+436]
  008b4	d9 9c 24 90 00
	00 00		 fstp	 DWORD PTR _vMin2$275919[esp+440]
  008bb	d9 9c 24 94 00
	00 00		 fstp	 DWORD PTR _vMin2$275919[esp+444]
  008c2	d9 44 24 4c	 fld	 DWORD PTR _vDestLocal$[esp+444]
  008c6	d8 80 8c 00 00
	00		 fadd	 DWORD PTR [eax+140]
  008cc	d9 44 24 48	 fld	 DWORD PTR _vDestLocal$[esp+440]
  008d0	d8 80 88 00 00
	00		 fadd	 DWORD PTR [eax+136]
  008d6	d9 44 24 44	 fld	 DWORD PTR _vDestLocal$[esp+436]
  008da	d8 80 84 00 00
	00		 fadd	 DWORD PTR [eax+132]
  008e0	8d 84 24 9c 00
	00 00		 lea	 eax, DWORD PTR _vMax1$[esp+436]
  008e7	50		 push	 eax
  008e8	51		 push	 ecx
  008e9	d9 9c 24 88 00
	00 00		 fstp	 DWORD PTR _vMax2$275921[esp+444]
  008f0	d9 9c 24 8c 00
	00 00		 fstp	 DWORD PTR _vMax2$275921[esp+448]
  008f7	d9 9c 24 90 00
	00 00		 fstp	 DWORD PTR _vMax2$275921[esp+452]
  008fe	e8 00 00 00 00	 call	 ?IsTouchAABB@@YAHABUD3DXVECTOR3@@000@Z ; IsTouchAABB
  00903	83 c4 10	 add	 esp, 16			; 00000010H
  00906	85 c0		 test	 eax, eax
  00908	74 47		 je	 SHORT $L285356

; 4038 : 					{
; 4039 : 						if( pProp->dwComboStyle == CT_FINISH )

  0090a	8b 54 24 74	 mov	 edx, DWORD PTR _pProp$[esp+428]
  0090e	83 ba 48 02 00
	00 03		 cmp	 DWORD PTR [edx+584], 3

; 4040 : 							pTarget->m_pActMover->SendDamageForce( nDmgType, GetId(), (nAttackID << 16) );

  00915	8b c5		 mov	 eax, ebp
  00917	75 1b		 jne	 SHORT $L275924
  00919	8b 8f bc 01 00
	00		 mov	 ecx, DWORD PTR [edi+444]
  0091f	6a 01		 push	 1
  00921	c1 e0 10	 shl	 eax, 16			; 00000010H
  00924	50		 push	 eax
  00925	51		 push	 ecx
  00926	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  0092c	53		 push	 ebx
  0092d	e8 00 00 00 00	 call	 ?SendDamageForce@CActionMover@@QAEHKKHH@Z ; CActionMover::SendDamageForce

; 4041 : 						else

  00932	eb 1d		 jmp	 SHORT $L285356
$L275924:

; 4042 : 							pTarget->m_pActMover->SendDamage( nDmgType, GetId(), (nAttackID << 16) ); 

  00934	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  0093a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0093c	6a 00		 push	 0
  0093e	6a 01		 push	 1
  00940	c1 e0 10	 shl	 eax, 16			; 00000010H
  00943	50		 push	 eax
  00944	8b 87 bc 01 00
	00		 mov	 eax, DWORD PTR [edi+444]
  0094a	50		 push	 eax
  0094b	53		 push	 ebx
  0094c	6a 29		 push	 41			; 00000029H
  0094e	ff 52 04	 call	 DWORD PTR [edx+4]
$L285356:

; 4043 : 					}
; 4044 : 				}
; 4045 : 			}
; 4046 : 		}
; 4047 : 		END_LINKMAP

  00951	8b b6 80 01 00
	00		 mov	 esi, DWORD PTR [esi+384]
  00957	85 f6		 test	 esi, esi
  00959	0f 85 97 fe ff
	ff		 jne	 $L275912
$L275908:

; 4024 : 	{
; 4025 : 		FOR_LINKMAP( GetWorld(), vPos, pObj, nRange, CObj::linkDynamic, GetLayer() )

  0095f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv1557[esp+428]
  00963	8b 44 24 28	 mov	 eax, DWORD PTR tv371[esp+428]
  00967	83 c1 04	 add	 ecx, 4
  0096a	48		 dec	 eax
  0096b	89 4c 24 24	 mov	 DWORD PTR tv1557[esp+428], ecx
  0096f	89 44 24 28	 mov	 DWORD PTR tv371[esp+428], eax
  00973	0f 85 67 fe ff
	ff		 jne	 $L275907
  00979	8b 4c 24 20	 mov	 ecx, DWORD PTR __nLinkXMin$275882[esp+428]
$L275904:
  0097d	8b 74 24 18	 mov	 esi, DWORD PTR tv1603[esp+428]
  00981	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR tv1607[esp+428]
  00988	8b 44 24 2c	 mov	 eax, DWORD PTR tv345[esp+428]
  0098c	03 f2		 add	 esi, edx
  0098e	48		 dec	 eax
  0098f	89 74 24 18	 mov	 DWORD PTR tv1603[esp+428], esi
  00993	89 44 24 2c	 mov	 DWORD PTR tv345[esp+428], eax
  00997	0f 85 23 fe ff
	ff		 jne	 $L275903
$L275892:
  0099d	8b 87 b8 01 00
	00		 mov	 eax, DWORD PTR [edi+440]
  009a3	8b 74 24 14	 mov	 esi, DWORD PTR __i$275890[esp+428]
  009a7	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  009ad	50		 push	 eax
  009ae	46		 inc	 esi
  009af	6a 01		 push	 1
  009b1	83 c1 24	 add	 ecx, 36			; 00000024H
  009b4	89 74 24 1c	 mov	 DWORD PTR __i$275890[esp+436], esi
  009b8	e8 00 00 00 00	 call	 ?GetMaxLinkLevel@CLayeredLinkMap@@QAEHKH@Z ; CLayeredLinkMap::GetMaxLinkLevel
  009bd	3b f0		 cmp	 esi, eax
  009bf	0f 8c bb fc ff
	ff		 jl	 $L275891
$L285358:
  009c5	5d		 pop	 ebp
  009c6	5f		 pop	 edi
  009c7	5e		 pop	 esi
  009c8	5b		 pop	 ebx

; 4048 : 	}
; 4049 : 		
; 4050 : #endif // WORLDSERVER		
; 4051 : } // SendDamageLine()

  009c9	81 c4 9c 01 00
	00		 add	 esp, 412		; 0000019cH
  009cf	c2 18 00	 ret	 24			; 00000018H
?SendDamageLine@CMover@@QAEXHHHMMM@Z ENDP		; CMover::SendDamageLine
_TEXT	ENDS
PUBLIC	?DoUseItemFeedPocket@CMover@@QAEHPAVCItemElem@@@Z ; CMover::DoUseItemFeedPocket
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemFeedPocket@CMover@@QAEHPAVCItemElem@@@Z
_TEXT	SEGMENT
$T285406 = -12						; size = 4
_nResult$ = -8						; size = 4
_nMax$275995 = -4					; size = 4
_pPocket$ = 8						; size = 4
?DoUseItemFeedPocket@CMover@@QAEHPAVCItemElem@@@Z PROC NEAR ; CMover::DoUseItemFeedPocket, COMDAT
; _this$ = ecx

; 4178 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 4179 : 	int nResult = 0;

  00005	33 db		 xor	 ebx, ebx

; 4180 : 
; 4181 : #ifdef __JEFF_11_1
; 4182 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_PET_FEED_POCKET02 ) )

  00007	68 a3 67 00 00	 push	 26531			; 000067a3H
  0000c	53		 push	 ebx
  0000d	8b f9		 mov	 edi, ecx
  0000f	89 5c 24 14	 mov	 DWORD PTR _nResult$[esp+28], ebx
  00013	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00018	85 c0		 test	 eax, eax

; 4183 : 	{
; 4184 : 		( (CUser*)this )->AddDefinedText( TID_GAME_DONOTUSE_PETPOCKET );

  0001a	8b cf		 mov	 ecx, edi
  0001c	74 17		 je	 SHORT $L275985
  0001e	68 e4 0c 00 00	 push	 3300			; 00000ce4H
  00023	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  00028	5f		 pop	 edi

; 4185 : 		return	4;

  00029	b8 04 00 00 00	 mov	 eax, 4
  0002e	5b		 pop	 ebx

; 4228 : }

  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	c2 04 00	 ret	 4
$L275985:
  00035	55		 push	 ebp
  00036	56		 push	 esi

; 4186 : 	}
; 4187 : #endif	// __JEFF_11_1
; 4188 : 	//  
; 4189 : 	if( HasBuff( BUFF_ITEM, (WORD)( pPocket->m_dwItemId ) ) )

  00037	8b 74 24 20	 mov	 esi, DWORD PTR _pPocket$[esp+24]
  0003b	33 c0		 xor	 eax, eax
  0003d	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  00041	50		 push	 eax
  00042	53		 push	 ebx
  00043	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00048	85 c0		 test	 eax, eax
  0004a	74 43		 je	 SHORT $L275988

; 4190 : 	{
; 4191 : 		if( pPocket->m_dwKeepTime != 0 )

  0004c	39 9e b0 00 00
	00		 cmp	 DWORD PTR [esi+176], ebx
  00052	74 25		 je	 SHORT $L275989

; 4192 : 		{
; 4193 : 			RemoveBuff( BUFF_ITEM, (WORD)( pPocket->m_dwItemId ) );

  00054	33 c9		 xor	 ecx, ecx
  00056	66 8b 4e 0c	 mov	 cx, WORD PTR [esi+12]
  0005a	51		 push	 ecx
  0005b	53		 push	 ebx
  0005c	8b cf		 mov	 ecx, edi
  0005e	e8 00 00 00 00	 call	 ?RemoveBuff@CMover@@QAEXGG@Z ; CMover::RemoveBuff
  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp

; 4194 : 			nResult = 4;

  00065	c7 44 24 0c 04
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 4

; 4225 : 	}
; 4226 : 
; 4227 : 	return nResult;

  0006d	8b 44 24 0c	 mov	 eax, DWORD PTR _nResult$[esp+20]
  00071	5f		 pop	 edi
  00072	5b		 pop	 ebx

; 4228 : }

  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	c2 04 00	 ret	 4
$L275989:
  00079	5e		 pop	 esi
  0007a	5d		 pop	 ebp

; 4195 : 		}
; 4196 : 		else
; 4197 : 			nResult = 2;

  0007b	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR _nResult$[esp+20], 2

; 4225 : 	}
; 4226 : 
; 4227 : 	return nResult;

  00083	8b 44 24 0c	 mov	 eax, DWORD PTR _nResult$[esp+20]
  00087	5f		 pop	 edi
  00088	5b		 pop	 ebx

; 4228 : }

  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	c2 04 00	 ret	 4
$L275988:

; 4198 : 	}
; 4199 : 	else
; 4200 : 	{
; 4201 : 		ItemProp* pProp	= pPocket->GetProp();

  0008f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00092	3b c3		 cmp	 eax, ebx
  00094	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0009a	7c 1d		 jl	 SHORT $L285413
  0009c	3b c1		 cmp	 eax, ecx
  0009e	7d 19		 jge	 SHORT $L285413
  000a0	72 08		 jb	 SHORT $L285425
  000a2	33 c0		 xor	 eax, eax
  000a4	89 44 24 10	 mov	 DWORD PTR $T285406[esp+28], eax
  000a8	eb 28		 jmp	 SHORT $L285408
$L285425:
  000aa	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  000b0	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  000b3	89 44 24 10	 mov	 DWORD PTR $T285406[esp+28], eax
  000b7	eb 19		 jmp	 SHORT $L285408
$L285413:
  000b9	50		 push	 eax
  000ba	51		 push	 ecx
  000bb	53		 push	 ebx
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000c6	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000cb	83 c4 14	 add	 esp, 20			; 00000014H
  000ce	89 5c 24 10	 mov	 DWORD PTR $T285406[esp+28], ebx
$L285408:

; 4202 : 		if( pPocket->m_dwKeepTime == 0 )	//       .

  000d2	39 9e b0 00 00
	00		 cmp	 DWORD PTR [esi+176], ebx
  000d8	0f 85 8c 00 00
	00		 jne	 $L285456

; 4203 : 		{
; 4204 : 			int nMax	= m_Inventory.GetMax();

  000de	8b 87 9c 0b 00
	00		 mov	 eax, DWORD PTR [edi+2972]

; 4205 : 			CItemElem* pItemElem;
; 4206 : 			for( int i = 0 ; i < nMax; i++ )

  000e4	33 ed		 xor	 ebp, ebp
  000e6	3b c3		 cmp	 eax, ebx
  000e8	89 44 24 18	 mov	 DWORD PTR _nMax$275995[esp+28], eax
  000ec	7e 5f		 jle	 SHORT $L276000
  000ee	8b ff		 npad	 2
$L285455:

; 4207 : 			{
; 4208 : 				pItemElem	= m_Inventory.GetAtId( i );

  000f0	3b af 9c 0b 00
	00		 cmp	 ebp, DWORD PTR [edi+2972]
  000f6	72 04		 jb	 SHORT $L285440
  000f8	33 f6		 xor	 esi, esi
  000fa	eb 12		 jmp	 SHORT $L285442
$L285440:
  000fc	8b 87 a0 0b 00
	00		 mov	 eax, DWORD PTR [edi+2976]
  00102	8b 74 18 0c	 mov	 esi, DWORD PTR [eax+ebx+12]
  00106	03 c3		 add	 eax, ebx
  00108	f7 de		 neg	 esi
  0010a	1b f6		 sbb	 esi, esi
  0010c	23 f0		 and	 esi, eax
$L285442:

; 4209 : 				if( IsUsableItem( pItemElem )
; 4210 : 					&& pItemElem->m_dwItemId == pPocket->m_dwItemId
; 4211 : 					&& pItemElem->m_dwKeepTime > 0
; 4212 : 					&& !pItemElem->IsFlag( CItemElem::expired )
; 4213 : 					)

  0010e	56		 push	 esi
  0010f	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  00114	83 c4 04	 add	 esp, 4
  00117	85 c0		 test	 eax, eax
  00119	74 1f		 je	 SHORT $L275999
  0011b	8b 4c 24 20	 mov	 ecx, DWORD PTR _pPocket$[esp+24]
  0011f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00122	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00125	75 13		 jne	 SHORT $L275999
  00127	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0012d	85 c0		 test	 eax, eax
  0012f	76 09		 jbe	 SHORT $L275999
  00131	f6 86 82 00 00
	00 01		 test	 BYTE PTR [esi+130], 1
  00138	74 50		 je	 SHORT $L285453
$L275999:

; 4205 : 			CItemElem* pItemElem;
; 4206 : 			for( int i = 0 ; i < nMax; i++ )

  0013a	8b 44 24 18	 mov	 eax, DWORD PTR _nMax$275995[esp+28]
  0013e	45		 inc	 ebp
  0013f	81 c3 b8 00 00
	00		 add	 ebx, 184		; 000000b8H
  00145	3b e8		 cmp	 ebp, eax
  00147	7c a7		 jl	 SHORT $L285455

; 4209 : 				if( IsUsableItem( pItemElem )
; 4210 : 					&& pItemElem->m_dwItemId == pPocket->m_dwItemId
; 4211 : 					&& pItemElem->m_dwKeepTime > 0
; 4212 : 					&& !pItemElem->IsFlag( CItemElem::expired )
; 4213 : 					)

  00149	8b 74 24 20	 mov	 esi, DWORD PTR _pPocket$[esp+24]
$L276000:

; 4219 : 				}
; 4220 : 			}
; 4221 : 			ASSERT( pProp->dwAbilityMin < 259200 );
; 4222 : 			UpdateItem( (BYTE)( pPocket->m_dwObjId ), UI_KEEPTIME, pProp->dwAbilityMin );	// 1440	// 1 days

  0014d	8b 54 24 10	 mov	 edx, DWORD PTR $T285406[esp+28]
  00151	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00157	33 c9		 xor	 ecx, ecx
  00159	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  0015c	33 db		 xor	 ebx, ebx
  0015e	53		 push	 ebx
  0015f	50		 push	 eax
  00160	6a 0b		 push	 11			; 0000000bH
  00162	51		 push	 ecx
  00163	8b cf		 mov	 ecx, edi
  00165	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L285456:

; 4223 : 		}
; 4224 : 		DoApplySkill( (CCtrl*)this, pProp, NULL );

  0016a	8b 54 24 10	 mov	 edx, DWORD PTR $T285406[esp+28]
  0016e	53		 push	 ebx
  0016f	53		 push	 ebx
  00170	53		 push	 ebx
  00171	53		 push	 ebx
  00172	53		 push	 ebx
  00173	52		 push	 edx
  00174	57		 push	 edi
  00175	8b cf		 mov	 ecx, edi
  00177	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill

; 4225 : 	}
; 4226 : 
; 4227 : 	return nResult;

  0017c	8b 44 24 14	 mov	 eax, DWORD PTR _nResult$[esp+28]
  00180	5e		 pop	 esi
  00181	5d		 pop	 ebp
  00182	5f		 pop	 edi
  00183	5b		 pop	 ebx

; 4228 : }

  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
  00187	c2 04 00	 ret	 4
$L285453:

; 4214 : 				{
; 4215 : 					//         .
; 4216 : 					( (CUser*)this )->AddDefinedText( TID_GAME_DONOTUSE_PETPOCKET, "" );

  0018a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0018f	68 e4 0c 00 00	 push	 3300			; 00000ce4H
  00194	57		 push	 edi
  00195	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019d	5e		 pop	 esi
  0019e	5d		 pop	 ebp
  0019f	5f		 pop	 edi

; 4217 : 					nResult = 4;
; 4218 : 					return nResult;

  001a0	b8 04 00 00 00	 mov	 eax, 4
  001a5	5b		 pop	 ebx

; 4228 : }

  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a9	c2 04 00	 ret	 4
?DoUseItemFeedPocket@CMover@@QAEHPAVCItemElem@@@Z ENDP	; CMover::DoUseItemFeedPocket
_TEXT	ENDS
PUBLIC	?ProcessVisPet@CMover@@QAEXXZ			; CMover::ProcessVisPet
EXTRN	?RemovePetVisItem@CItemUpgrade@@QAEXPAVCUser@@HH@Z:NEAR ; CItemUpgrade::RemovePetVisItem
EXTRN	?GetInstance@CItemUpgrade@@SAPAV1@XZ:NEAR	; CItemUpgrade::GetInstance
; Function compile flags: /Ogty
;	COMDAT ?ProcessVisPet@CMover@@QAEXXZ
_TEXT	SEGMENT
?ProcessVisPet@CMover@@QAEXXZ PROC NEAR			; CMover::ProcessVisPet, COMDAT
; _this$ = ecx

; 4426 : {

  00000	55		 push	 ebp
  00001	8b e9		 mov	 ebp, ecx

; 4427 : 	if( HasActivatedVisPet() )

  00003	8b 85 94 11 00
	00		 mov	 eax, DWORD PTR [ebp+4500]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	0f 84 a0 00 00
	00		 je	 $L276117

; 4428 : 	{
; 4429 : 		CItemElem* pItemElem = GetVisPetItem();

  00012	3b 85 9c 0b 00
	00		 cmp	 eax, DWORD PTR [ebp+2972]
  00018	0f 83 94 00 00
	00		 jae	 $L276117
  0001e	8b 95 a0 0b 00
	00		 mov	 edx, DWORD PTR [ebp+2976]
  00024	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  0002a	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  0002e	03 c2		 add	 eax, edx
  00030	85 c9		 test	 ecx, ecx
  00032	74 7e		 je	 SHORT $L276117
  00034	56		 push	 esi
  00035	57		 push	 edi

; 4430 : 		if( pItemElem )
; 4431 : 		{
; 4432 : 			for( int i=0; i<pItemElem->GetPiercingSize(); i++ )

  00036	8d 78 3c	 lea	 edi, DWORD PTR [eax+60]
  00039	8b cf		 mov	 ecx, edi
  0003b	33 f6		 xor	 esi, esi
  0003d	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00042	85 c0		 test	 eax, eax
  00044	7e 6a		 jle	 SHORT $L285516
  00046	53		 push	 ebx
$L276115:

; 4433 : 			{
; 4434 : 				if( pItemElem->GetPiercingItem( i ) != 0 && time_null() >= pItemElem->GetVisKeepTime( i ) )

  00047	56		 push	 esi
  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  0004f	85 c0		 test	 eax, eax
  00051	74 50		 je	 SHORT $L276116
  00053	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  00059	56		 push	 esi
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?GetVisKeepTime@CPiercing@@QAEJH@Z ; CPiercing::GetVisKeepTime
  00061	3b d8		 cmp	 ebx, eax
  00063	7c 3e		 jl	 SHORT $L276116

; 4435 : 				{
; 4436 : 					ItemProp* pItemProp = prj.GetItemProp( pItemElem->GetPiercingItem( i ) );

  00065	56		 push	 esi
  00066	8b cf		 mov	 ecx, edi
  00068	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  0006d	50		 push	 eax
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00073	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 4437 : 					if( pItemProp )

  00078	85 c0		 test	 eax, eax
  0007a	74 17		 je	 SHORT $L276120

; 4438 : 						static_cast<CUser*>( this )->AddDefinedText( TID_GAME_BUFFPET_TIMEOUTVIS, "\"%s\"", pItemProp->szName );

  0007c	83 c0 04	 add	 eax, 4
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00085	68 82 10 00 00	 push	 4226			; 00001082H
  0008a	55		 push	 ebp
  0008b	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$L276120:

; 4439 : 					CItemUpgrade::GetInstance()->RemovePetVisItem( static_cast<CUser*>( this ), i, TRUE );

  00093	6a 01		 push	 1
  00095	56		 push	 esi
  00096	55		 push	 ebp
  00097	e8 00 00 00 00	 call	 ?GetInstance@CItemUpgrade@@SAPAV1@XZ ; CItemUpgrade::GetInstance
  0009c	8b c8		 mov	 ecx, eax
  0009e	e8 00 00 00 00	 call	 ?RemovePetVisItem@CItemUpgrade@@QAEXPAVCUser@@HH@Z ; CItemUpgrade::RemovePetVisItem
$L276116:
  000a3	8b cf		 mov	 ecx, edi
  000a5	46		 inc	 esi
  000a6	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000ab	3b f0		 cmp	 esi, eax
  000ad	7c 98		 jl	 SHORT $L276115
  000af	5b		 pop	 ebx
$L285516:
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
$L276117:
  000b2	5d		 pop	 ebp

; 4440 : 				}
; 4441 : 			}
; 4442 : 		}		
; 4443 : 	}
; 4444 : }

  000b3	c3		 ret	 0
?ProcessVisPet@CMover@@QAEXXZ ENDP			; CMover::ProcessVisPet
_TEXT	ENDS
PUBLIC	?DoUseItemPetTonic@CMover@@AAEHPAVCItemElem@@@Z	; CMover::DoUseItemPetTonic
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemPetTonic@CMover@@AAEHPAVCItemElem@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pItemElem$ = 8						; size = 4
?DoUseItemPetTonic@CMover@@AAEHPAVCItemElem@@@Z PROC NEAR ; CMover::DoUseItemPetTonic, COMDAT
; _this$ = ecx

; 4621 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 4622 : 	//        
; 4623 : 	if( ( pItemElem->m_dwItemId == II_SYS_SYS_SCR_PET_TONIC_A && HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_PET_TONIC_B ) )
; 4624 : 		|| ( pItemElem->m_dwItemId == II_SYS_SYS_SCR_PET_TONIC_B && HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_PET_TONIC_A ) )
; 4625 : 	)

  00002	8b 5c 24 0c	 mov	 ebx, DWORD PTR _pItemElem$[esp+4]
  00006	81 7b 0c 28 52
	00 00		 cmp	 DWORD PTR [ebx+12], 21032 ; 00005228H
  0000d	56		 push	 esi
  0000e	8b f1		 mov	 esi, ecx
  00010	89 74 24 08	 mov	 DWORD PTR _this$[esp+12], esi
  00014	75 10		 jne	 SHORT $L285726
  00016	68 29 52 00 00	 push	 21033			; 00005229H
  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00022	85 c0		 test	 eax, eax
  00024	75 1b		 jne	 SHORT $L276235
$L285726:
  00026	81 7b 0c 29 52
	00 00		 cmp	 DWORD PTR [ebx+12], 21033 ; 00005229H
  0002d	75 1d		 jne	 SHORT $L285728
  0002f	68 28 52 00 00	 push	 21032			; 00005228H
  00034	6a 00		 push	 0
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0003d	85 c0		 test	 eax, eax
  0003f	74 0b		 je	 SHORT $L285728
$L276235:
  00041	5e		 pop	 esi

; 4626 : 		return 2;

  00042	b8 02 00 00 00	 mov	 eax, 2
  00047	5b		 pop	 ebx

; 4643 : }

  00048	59		 pop	 ecx
  00049	c2 04 00	 ret	 4
$L285728:
  0004c	55		 push	 ebp
  0004d	57		 push	 edi

; 4627 : 
; 4628 : 	//   
; 4629 : 	DWORD dwCurr	= ::timeGetTime();

  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00054	8b e8		 mov	 ebp, eax

; 4630 : #ifdef __BUFF_1107
; 4631 : 	IBuff* pBuff	= m_buffs.GetBuff( BUFF_ITEM, (WORD)( pItemElem->m_dwItemId ) );

  00056	33 c0		 xor	 eax, eax
  00058	66 8b 43 0c	 mov	 ax, WORD PTR [ebx+12]
  0005c	8d 8e f0 02 00
	00		 lea	 ecx, DWORD PTR [esi+752]
  00062	50		 push	 eax
  00063	6a 00		 push	 0
  00065	e8 00 00 00 00	 call	 ?GetBuff@CBuffMgr@@QAEPAVIBuff@@GG@Z ; CBuffMgr::GetBuff

; 4632 : 	if( pBuff && static_cast<int>( pItemElem->GetProp()->dwSkillTime ) > static_cast<int>( pItemElem->GetProp()->dwSkillTime + ( pBuff->GetTotal() - ( dwCurr - pBuff->GetInst() ) ) ) )

  0006a	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00070	8b f8		 mov	 edi, eax
  00072	85 ff		 test	 edi, edi
  00074	0f 84 9d 00 00
	00		 je	 $L276242
  0007a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0007d	85 c0		 test	 eax, eax
  0007f	7c 19		 jl	 SHORT $L285573
  00081	3b c1		 cmp	 eax, ecx
  00083	7d 15		 jge	 SHORT $L285573
  00085	72 06		 jb	 SHORT $L285585
  00087	33 c0		 xor	 eax, eax
  00089	8b f0		 mov	 esi, eax
  0008b	eb 2b		 jmp	 SHORT $L285568
$L285585:
  0008d	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  00093	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00096	8b f0		 mov	 esi, eax
  00098	eb 1e		 jmp	 SHORT $L285568
$L285573:
  0009a	50		 push	 eax
  0009b	51		 push	 ecx
  0009c	6a 00		 push	 0
  0009e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000a8	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000ad	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
  000b6	33 f6		 xor	 esi, esi
$L285568:
  000b8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000bb	85 c0		 test	 eax, eax
  000bd	7c 11		 jl	 SHORT $L285638
  000bf	3b c1		 cmp	 eax, ecx
  000c1	7d 0d		 jge	 SHORT $L285638
  000c3	73 27		 jae	 SHORT $L285731
  000c5	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  000cb	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  000ce	eb 1e		 jmp	 SHORT $L285633
$L285638:
  000d0	50		 push	 eax
  000d1	51		 push	 ecx
  000d2	6a 00		 push	 0
  000d4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000d9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000de	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000e3	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  000e9	83 c4 14	 add	 esp, 20			; 00000014H
$L285731:
  000ec	33 c0		 xor	 eax, eax
$L285633:
  000ee	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [eax+496]
  000f4	03 47 10	 add	 eax, DWORD PTR [edi+16]
  000f7	03 47 0c	 add	 eax, DWORD PTR [edi+12]
  000fa	8b 96 f0 01 00
	00		 mov	 edx, DWORD PTR [esi+496]
  00100	2b c5		 sub	 eax, ebp
  00102	3b d0		 cmp	 edx, eax
  00104	7e 0d		 jle	 SHORT $L285727
  00106	5f		 pop	 edi
  00107	5d		 pop	 ebp
  00108	5e		 pop	 esi

; 4633 : 		return 1;

  00109	b8 01 00 00 00	 mov	 eax, 1
  0010e	5b		 pop	 ebx

; 4643 : }

  0010f	59		 pop	 ecx
  00110	c2 04 00	 ret	 4
$L285727:

; 4633 : 		return 1;

  00113	8b 74 24 10	 mov	 esi, DWORD PTR _this$[esp+20]
$L276242:

; 4634 : #else	// __BUFF_1107
; 4635 : 	LPSKILLINFLUENCE ptr	= m_SkillState.FindPtr( BUFF_ITEM, pItemElem->m_dwItemId );
; 4636 : 	if( ptr && static_cast<int>( pItemElem->GetProp()->dwSkillTime ) > static_cast<int>( pItemElem->GetProp()->dwSkillTime + ( ptr->tmCount - ( dwCurr - ptr->tmTime ) ) ) )
; 4637 : 		return 1;
; 4638 : #endif	// __BUFF_1107
; 4639 : 
; 4640 : 	//  
; 4641 : 	DoApplySkill( this, pItemElem->GetProp(), NULL );

  00117	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0011a	85 c0		 test	 eax, eax
  0011c	7c 11		 jl	 SHORT $L285717
  0011e	3b c1		 cmp	 eax, ecx
  00120	7d 0d		 jge	 SHORT $L285717
  00122	73 21		 jae	 SHORT $L285732
  00124	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0012a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0012d	eb 18		 jmp	 SHORT $L285712
$L285717:
  0012f	50		 push	 eax
  00130	51		 push	 ecx
  00131	6a 00		 push	 0
  00133	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0013d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00142	83 c4 14	 add	 esp, 20			; 00000014H
$L285732:
  00145	33 c0		 xor	 eax, eax
$L285712:
  00147	6a 00		 push	 0
  00149	6a 00		 push	 0
  0014b	6a 00		 push	 0
  0014d	6a 00		 push	 0
  0014f	6a 00		 push	 0
  00151	50		 push	 eax
  00152	56		 push	 esi
  00153	8b ce		 mov	 ecx, esi
  00155	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  0015a	5f		 pop	 edi
  0015b	5d		 pop	 ebp
  0015c	5e		 pop	 esi

; 4642 : 	return 0;

  0015d	33 c0		 xor	 eax, eax
  0015f	5b		 pop	 ebx

; 4643 : }

  00160	59		 pop	 ecx
  00161	c2 04 00	 ret	 4
?DoUseItemPetTonic@CMover@@AAEHPAVCItemElem@@@Z ENDP	; CMover::DoUseItemPetTonic
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::end
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAUAMP_STORE_INFO@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::erase
; Function compile flags: /Ogty
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::erase, COMDAT
; _this$ = ecx

; 732  : 		if (_First != _Last)

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	53		 push	 ebx
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR __First$[esp+4]
  0000a	3b f8		 cmp	 edi, eax
  0000c	8b d9		 mov	 ebx, ecx
  0000e	74 17		 je	 SHORT $L285832
  00010	56		 push	 esi

; 733  : 			{	// worth doing, copy down over hole
; 734  : 			pointer _Ptr = copy(_ITER_BASE(_Last), _Mylast,
; 735  : 				_ITER_BASE(_First));

  00011	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00014	2b f0		 sub	 esi, eax
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	03 c6		 add	 eax, esi

; 736  : 			_Destroy(_Ptr, _Mylast);
; 737  : 			_Mylast = _Ptr;

  00023	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00026	5e		 pop	 esi
$L285832:

; 738  : 			}
; 739  : 		return (_First);

  00027	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  0002b	89 38		 mov	 DWORD PTR [eax], edi
  0002d	5f		 pop	 edi
  0002e	5b		 pop	 ebx

; 740  : 		}

  0002f	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::erase
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Lbound
; Function compile flags: /Ogty
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L277934
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L277933:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $L277935

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  0001c	eb 04		 jmp	 SHORT $L277936
$L277935:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L277936:
  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L277933
  00029	5b		 pop	 ebx
$L277934:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L277945

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L285928

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L285909
  0001d	8d 49 00	 npad	 3
$L285908:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L285908
$L285909:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L285928:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L277949
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L277948:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L277949

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L277948
$L277949:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L277945:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetEquip
PUBLIC	??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@ ; `string'
EXTRN	?WriteError@@YAXPBDZZ:NEAR			; WriteError
;	COMDAT ??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
CONST	SEGMENT
??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@ DB 'GETEQUIP/'
	DB	'/%d, %d, %d', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetEquip, COMDAT
; _this$ = ecx

; 617  : {

  00000	56		 push	 esi

; 618  : 	if( m_dwIndexNum )

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	85 f6		 test	 esi, esi
  00006	74 32		 je	 SHORT $L279371

; 619  : 	{
; 620  : 		if( dwIndex < 0 || dwIndex >= ( m_dwItemMax - m_dwIndexNum ) )

  00008	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR _dwIndex$[esp]
  0000f	57		 push	 edi
  00010	8b f8		 mov	 edi, eax
  00012	2b fe		 sub	 edi, esi
  00014	3b d7		 cmp	 edx, edi
  00016	5f		 pop	 edi
  00017	73 0c		 jae	 SHORT $L279373

; 623  : 			return NULL;
; 624  : 		}
; 625  : 		return GetAt( m_dwIndexNum + dwIndex );

  00019	03 f2		 add	 esi, edx
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?GetAt@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAt
  00021	5e		 pop	 esi

; 628  : }

  00022	c2 04 00	 ret	 4
$L279373:

; 621  : 		{
; 622  : 			WriteError( "GETEQUIP//%d, %d, %d", m_dwIndexNum, m_dwItemMax - m_dwIndexNum, dwIndex );

  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00028	52		 push	 edx
  00029	2b c1		 sub	 eax, ecx
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OJMCJNHH@GETEQUIP?1?1?$CFd?0?5?$CFd?0?5?$CFd?$AA@
  00032	e8 00 00 00 00	 call	 ?WriteError@@YAXPBDZZ	; WriteError
  00037	83 c4 10	 add	 esp, 16			; 00000010H
$L279371:

; 626  : 	}
; 627  : 	return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	5e		 pop	 esi

; 628  : }

  0003d	c2 04 00	 ret	 4
?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetEquip
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __Last$[esp]
  00009	2b f0		 sub	 esi, eax
  0000b	56		 push	 esi
  0000c	50		 push	 eax
  0000d	8b 44 24 18	 mov	 eax, DWORD PTR __Ptr$[esp+8]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memmove
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	03 c6		 add	 eax, esi
  0001c	5e		 pop	 esi

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@@Z ; std::_Uninitialized_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 0e		 jbe	 SHORT $L285978
  0000c	56		 push	 esi
  0000d	8b 74 24 10	 mov	 esi, DWORD PTR __Val$[esp]
$L285976:
  00011	8a 16		 mov	 dl, BYTE PTR [esi]
  00013	88 10		 mov	 BYTE PTR [eax], dl
  00015	40		 inc	 eax
  00016	49		 dec	 ecx
  00017	75 f8		 jne	 SHORT $L285976
  00019	5e		 pop	 esi
$L285978:

; 258  : 	}

  0001a	c3		 ret	 0
??$_Uninitialized_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >
EXTRN	__CxxThrowException@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN
; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 0c	 mov	 eax, DWORD PTR __Dest$[esp-4]
  00008	56		 push	 esi
  00009	8b 74 24 0c	 mov	 esi, DWORD PTR __Last$[esp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 0e		 je	 SHORT $L280393
$L285990:

; 82   : 		_Al.construct(_Dest, *_First);

  00011	85 c0		 test	 eax, eax
  00013	74 04		 je	 SHORT $L280392
  00015	8a 11		 mov	 dl, BYTE PTR [ecx]
  00017	88 10		 mov	 BYTE PTR [eax], dl
$L280392:
  00019	40		 inc	 eax
  0001a	41		 inc	 ecx
  0001b	3b ce		 cmp	 ecx, esi
  0001d	75 f2		 jne	 SHORT $L285990
$L280393:
  0001f	5e		 pop	 esi

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)
; 85   : 		_Al.destroy(_Next);
; 86   : 	_RERAISE;
; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

  00020	c3		 ret	 0
??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?IsVisPet@CItemElem@@QAEHXZ			; CItemElem::IsVisPet
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsVisPet@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?IsVisPet@CItemElem@@QAEHXZ PROC NEAR			; CItemElem::IsVisPet, COMDAT
; _this$ = ecx

; 274  : 	BOOL	IsVisPet()	{ return ( GetProp() && GetProp()->IsVisPet() ) || IsTransformVisPet() ; }

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00007	85 c0		 test	 eax, eax
  00009	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000f	7c 21		 jl	 SHORT $L286089
  00011	3b c1		 cmp	 eax, ecx
  00013	7d 1d		 jge	 SHORT $L286089
  00015	73 5a		 jae	 SHORT $L286173
  00017	8b 35 4c 02 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+588
  0001d	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]
  00020	85 d2		 test	 edx, edx
  00022	74 4d		 je	 SHORT $L286173
  00024	85 c0		 test	 eax, eax
  00026	7c 22		 jl	 SHORT $L286154
  00028	3b c1		 cmp	 eax, ecx
  0002a	7d 1e		 jge	 SHORT $L286154
  0002c	73 32		 jae	 SHORT $L286176
  0002e	8b c2		 mov	 eax, edx
  00030	eb 30		 jmp	 SHORT $L286149
$L286089:
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	6a 00		 push	 0
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00040	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00045	83 c4 14	 add	 esp, 20			; 00000014H
  00048	eb 27		 jmp	 SHORT $L286173
$L286154:
  0004a	50		 push	 eax
  0004b	51		 push	 ecx
  0004c	6a 00		 push	 0
  0004e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00058	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
$L286176:
  00060	33 c0		 xor	 eax, eax
$L286149:
  00062	83 78 78 64	 cmp	 DWORD PTR [eax+120], 100 ; 00000064H
  00066	75 09		 jne	 SHORT $L286173
  00068	83 b8 00 02 00
	00 01		 cmp	 DWORD PTR [eax+512], 1
  0006f	74 0e		 je	 SHORT $L286037
$L286173:
  00071	8b cf		 mov	 ecx, edi
  00073	e8 00 00 00 00	 call	 ?IsTransformVisPet@CItemElem@@QAEHXZ ; CItemElem::IsTransformVisPet
  00078	85 c0		 test	 eax, eax
  0007a	75 03		 jne	 SHORT $L286037
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	c3		 ret	 0
$L286037:
  0007f	5f		 pop	 edi
  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	5e		 pop	 esi
  00086	c3		 ret	 0
?IsVisPet@CItemElem@@QAEHXZ ENDP			; CItemElem::IsVisPet
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 796  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	8b c8		 mov	 ecx, eax
  0000c	ff 52 0c	 call	 DWORD PTR [edx+12]
  0000f	83 c0 10	 add	 eax, 16			; 00000010H
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 797  : 	}

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	c3		 ret	 0
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Ogty
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 963  : 	}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H
  00005	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00008	83 ca ff	 or	 edx, -1
  0000b	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  0000f	4a		 dec	 edx
  00010	85 d2		 test	 edx, edx
  00012	7f 08		 jg	 SHORT $L286216
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	50		 push	 eax
  00019	ff 52 04	 call	 DWORD PTR [edx+4]
$L286216:
  0001c	c3		 ret	 0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	?Find@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Find
; Function compile flags: /Ogty
;	COMDAT ?Find@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
_TEXT	SEGMENT
_pszSub$ = 8						; size = 4
_iStart$ = 12						; size = 4
?Find@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Find, COMDAT
; _this$ = ecx

; 1391 : 		// iStart is in XCHARs
; 1392 : 		ATLASSERT( iStart >= 0 );
; 1393 : 		ATLASSERT( AtlIsValidString( pszSub ) );
; 1394 : 
; 1395 : 		if(pszSub == NULL)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSub$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1396 : 		{
; 1397 : 			return( -1 );

  00009	74 25		 je	 SHORT $L218583

; 1398 : 		}
; 1399 : 		// nLength is in XCHARs
; 1400 : 		int nLength = GetLength();
; 1401 : 		if( iStart < 0 || iStart > nLength )

  0000b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _iStart$[esp]
  0000f	85 c9		 test	 ecx, ecx
  00011	7c 1d		 jl	 SHORT $L218583
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	3b 48 f4	 cmp	 ecx, DWORD PTR [eax-12]
  00018	7f 16		 jg	 SHORT $L218583

; 1404 : 		}
; 1405 : 
; 1406 : 		// find first matching substring
; 1407 : 		PCXSTR psz = StringTraits::StringFindString( GetString()+iStart, pszSub );

  0001a	52		 push	 edx
  0001b	03 c1		 add	 eax, ecx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 __mbsstr
  00023	83 c4 08	 add	 esp, 8

; 1408 : 
; 1409 : 		// return -1 for not found, distance from beginning otherwise
; 1410 : 		return( (psz == NULL) ? -1 : int( psz-GetString() ) );

  00026	85 c0		 test	 eax, eax
  00028	74 06		 je	 SHORT $L218583
  0002a	2b 06		 sub	 eax, DWORD PTR [esi]
  0002c	5e		 pop	 esi

; 1411 : 	}

  0002d	c2 08 00	 ret	 8
$L218583:

; 1402 : 		{
; 1403 : 			return( -1 );

  00030	83 c8 ff	 or	 eax, -1
  00033	5e		 pop	 esi

; 1411 : 	}

  00034	c2 08 00	 ret	 8
?Find@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Find
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCMover@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 735  : 		CStringData* pOldData = GetData();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nLength$[esp]
  00019	2b d0		 sub	 edx, eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L286279

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L286279:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 744  : 	}

  0002a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1510 : 		if (!_Built)

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Built$[esp-4]
  00004	84 c0		 test	 al, al
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Newsize$[esp+4]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	74 2f		 je	 SHORT $L286287

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00010	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00014	72 29		 jb	 SHORT $L286287

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;
; 1515 : 			if (0 < _Newsize)

  00016	85 ed		 test	 ebp, ebp
  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	57		 push	 edi
  0001c	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  0001f	76 14		 jbe	 SHORT $L286284
  00021	56		 push	 esi

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  00022	8b cd		 mov	 ecx, ebp
  00024	8b d1		 mov	 edx, ecx
  00026	c1 e9 02	 shr	 ecx, 2
  00029	8b f0		 mov	 esi, eax
  0002b	f3 a5		 rep movsd
  0002d	8b ca		 mov	 ecx, edx
  0002f	83 e1 03	 and	 ecx, 3
  00032	f3 a4		 rep movsb
  00034	5e		 pop	 esi
$L286284:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
  0003e	5f		 pop	 edi
$L286287:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;
; 1520 : 		_Eos(_Newsize);

  0003f	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00042	c7 43 18 0f 00
	00 00		 mov	 DWORD PTR [ebx+24], 15	; 0000000fH
  00049	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0004e	5d		 pop	 ebp
  0004f	5b		 pop	 ebx

; 1521 : 		}

  00050	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 792  : 		if (_Myfirst != 0)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L286316

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L286316:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 798  : 		}

  00029	c3		 ret	 0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp

; 793  : 		if (_Mysize < _Off)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000b	57		 push	 edi
  0000c	73 05		 jae	 SHORT $L221371

; 794  : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L221371:

; 795  : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $L221372

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$L221372:

; 797  : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 47		 jbe	 SHORT $L286382

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002c	53		 push	 ebx
  0002d	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00030	72 04		 jb	 SHORT $L286348
  00032	8b 13		 mov	 edx, DWORD PTR [ebx]
  00034	eb 02		 jmp	 SHORT $L286349
$L286348:
  00036	8b d3		 mov	 edx, ebx
$L286349:
  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	72 04		 jb	 SHORT $L286355
  0003d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0003f	eb 02		 jmp	 SHORT $L286356
$L286355:
  00041	8b cb		 mov	 ecx, ebx
$L286356:
  00043	2b c7		 sub	 eax, edi

; 803  : 			}
; 804  : 		return (*this);

  00045	03 d5		 add	 edx, ebp
  00047	50		 push	 eax
  00048	03 d7		 add	 edx, edi
  0004a	52		 push	 edx
  0004b	03 cd		 add	 ecx, ebp
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _memmove
  00053	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00056	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00059	2b c7		 sub	 eax, edi
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00061	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00064	72 02		 jb	 SHORT $L286379

; 801  : 			size_type _Newsize = _Mysize - _Count;
; 802  : 			_Eos(_Newsize);

  00066	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$L286379:
  00068	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  0006c	5b		 pop	 ebx
$L286382:
  0006d	5f		 pop	 edi

; 803  : 			}
; 804  : 		return (*this);

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp

; 805  : 		}

  00072	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L222610
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L222609:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	73 05		 jae	 SHORT $L222611

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  0001c	eb 04		 jmp	 SHORT $L222612
$L222611:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L222612:
  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L222609
  00029	5b		 pop	 ebx
$L222610:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T286624 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T286626 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L286427
$T286627 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L286425
$T286625 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T286626
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T286627
$T286619 DD	019930520H
	DD	04H
	DD	FLAT:$T286624
	DD	02H
	DD	FLAT:$T286625
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b d8		 mov	 ebx, eax
  00022	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 1446 : 		if (max_size() < _Newres)

  00025	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00028	57		 push	 edi
  00029	8b f1		 mov	 esi, ecx
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00031	76 04		 jbe	 SHORT $L222778

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  00033	8b d8		 mov	 ebx, eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00035	eb 22		 jmp	 SHORT $L222780
$L222778:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00037	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  0003a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0003f	f7 e3		 mul	 ebx
  00041	8b cf		 mov	 ecx, edi
  00043	d1 e9		 shr	 ecx, 1
  00045	d1 ea		 shr	 edx, 1
  00047	3b d1		 cmp	 edx, ecx
  00049	73 0e		 jae	 SHORT $L222780
  0004b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00050	2b c1		 sub	 eax, ecx
  00052	3b f8		 cmp	 edi, eax
  00054	77 03		 ja	 SHORT $L222780

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00056	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
$L222780:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN
; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00059	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0005c	51		 push	 ecx
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00064	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00069	8b d0		 mov	 edx, eax
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
  00071	eb 29		 jmp	 SHORT $L222782
$L286425:

; 1455 : 		_CATCH_ALL
; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN
; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00079	40		 inc	 eax
  0007a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0007d	50		 push	 eax
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00087	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0008a	83 c4 04	 add	 esp, 4

; 1462 : 			_CATCH_END
; 1463 : 		_CATCH_END

  0008d	b8 00 00 00 00	 mov	 eax, $L286620
  00092	c3		 ret	 0
$L286620:
  00093	8b 5d e8	 mov	 ebx, DWORD PTR __Newres$[ebp]
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$L222782:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  0009f	85 c9		 test	 ecx, ecx
  000a1	76 24		 jbe	 SHORT $L286544

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000a3	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000a7	72 05		 jb	 SHORT $L286541
  000a9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000ac	eb 03		 jmp	 SHORT $L286542
$L286541:
  000ae	83 c6 04	 add	 esi, 4
$L286542:
  000b1	8b c1		 mov	 eax, ecx
  000b3	c1 e9 02	 shr	 ecx, 2
  000b6	8b fa		 mov	 edi, edx
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb
  000c1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
$L286544:

; 1467 : 		_Tidy(true);

  000c7	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000cb	72 12		 jb	 SHORT $L286580
  000cd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000dc	83 c4 04	 add	 esp, 4
$L286580:

; 1468 : 		_Bx._Ptr = _Ptr;
; 1469 : 		_Myres = _Newres;
; 1470 : 		_Eos(_Oldlen);

  000df	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000e5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e8	89 10		 mov	 DWORD PTR [eax], edx
  000ea	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000ed	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000f0	72 02		 jb	 SHORT $L286615
  000f2	8b c2		 mov	 eax, edx
$L286615:

; 1471 : 		}

  000f4	5f		 pop	 edi
  000f5	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fc	5e		 pop	 esi
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 08 00	 ret	 8
$L286427:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  0010b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0010e	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00112	72 0c		 jb	 SHORT $L286519
  00114	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011d	83 c4 04	 add	 esp, 4
$L286519:

; 1461 : 			_RERAISE;

  00120	6a 00		 push	 0
  00122	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00129	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00130	6a 00		 push	 0
  00132	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$L286628:
$L286623:
  0013b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T286619
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?DoUseSkill@CMover@@QAEHHHKW4SKILLUSETYPE@@H@Z	; CMover::DoUseSkill
PUBLIC	??_C@_0DN@POBPMOID@CMover?3?3DoUseSkill?5?3?5?$CFs?$LE?B?5nIdx?$LP?$KB@ ; `string'
PUBLIC	??_C@_0N@FIJAGOKJ@DoUseSkill_P?$AA@		; `string'
;	COMDAT ??_C@_0DN@POBPMOID@CMover?3?3DoUseSkill?5?3?5?$CFs?$LE?B?5nIdx?$LP?$KB@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_0DN@POBPMOID@CMover?3?3DoUseSkill?5?3?5?$CFs?$LE?B?5nIdx?$LP?$KB@ DB 'C'
	DB	'Mover::DoUseSkill : %s', 0b4H, 0c2H, ' nIdx', 0bfH, 0a1H, ' ', 0bdH
	DB	0baH, 0c5H, 0b3H, 0c0H, 0bbH, ' ', 0b0H, 0a1H, 0c1H, 0f6H, 0b0H
	DB	0edH, ' ', 0c0H, 0d6H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0b4H, 0d9H
	DB	'. %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FIJAGOKJ@DoUseSkill_P?$AA@
CONST	SEGMENT
??_C@_0N@FIJAGOKJ@DoUseSkill_P?$AA@ DB 'DoUseSkill_P', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseSkill@CMover@@QAEHHHKW4SKILLUSETYPE@@H@Z
_TEXT	SEGMENT
tv211 = -4						; size = 4
_pAddSkillProp$ = 8					; size = 4
_nType$ = 8						; size = 4
_pSkillProp$ = 12					; size = 4
_nIdx$ = 12						; size = 4
_idFocusObj$ = 16					; size = 4
_dwLevel$ = 20						; size = 4
_sutType$ = 20						; size = 4
_bControl$ = 24						; size = 4
?DoUseSkill@CMover@@QAEHHHKW4SKILLUSETYPE@@H@Z PROC NEAR ; CMover::DoUseSkill, COMDAT
; _this$ = ecx

; 185  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 186  : 	if( IsNPC() )	

  00004	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0000a	57		 push	 edi
  0000b	33 ff		 xor	 edi, edi
  0000d	3b c7		 cmp	 eax, edi
  0000f	75 08		 jne	 SHORT $L274300
  00011	5f		 pop	 edi

; 187  : 		return FALSE;		//    .

  00012	33 c0		 xor	 eax, eax
  00014	5e		 pop	 esi

; 288  : #else // __VER >= 8 // __S8_PK
; 289  : 	BOOL bSuccess = DoUseSkill( dwSkill, dwLevel, idFocusObj, sutType, nCastingTime );
; 290  : #endif // __VER >= 8 // __S8_PK
; 291  : 	return  bSuccess;
; 292  : }

  00015	59		 pop	 ecx
  00016	c2 14 00	 ret	 20			; 00000014H
$L274300:
  00019	53		 push	 ebx
  0001a	55		 push	 ebp

; 188  : 
; 189  : #ifdef __WORLDSERVER
; 190  : 	DWORD dwSkill = 0, dwLevel;
; 191  : #endif	// __WORLDSERVER
; 192  : 	
; 193  : 	if( nIdx >= 0 )

  0001b	8b 6c 24 1c	 mov	 ebp, DWORD PTR _nIdx$[esp+16]
  0001f	33 db		 xor	 ebx, ebx
  00021	3b ef		 cmp	 ebp, edi
  00023	7c 48		 jl	 SHORT $L286636

; 194  : 	{
; 195  : 		LPSKILL pSkill = GetSkill( nType, nIdx );

  00025	8b 44 24 18	 mov	 eax, DWORD PTR _nType$[esp+16]
  00029	55		 push	 ebp
  0002a	50		 push	 eax
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z ; CMover::GetSkill

; 196  : 		if( pSkill == NULL )

  00032	3b c7		 cmp	 eax, edi
  00034	75 1f		 jne	 SHORT $L274305

; 197  : 		{
; 198  : 			Error( "CMover::DoUseSkill : %s nIdx    . %d", m_szName, nIdx );

  00036	55		 push	 ebp
  00037	81 c6 90 16 00
	00		 add	 esi, 5776		; 00001690H
  0003d	56		 push	 esi
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DN@POBPMOID@CMover?3?3DoUseSkill?5?3?5?$CFs?$LE?B?5nIdx?$LP?$KB@
  00043	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	5d		 pop	 ebp
  0004c	5b		 pop	 ebx
  0004d	5f		 pop	 edi

; 199  : 			return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 288  : #else // __VER >= 8 // __S8_PK
; 289  : 	BOOL bSuccess = DoUseSkill( dwSkill, dwLevel, idFocusObj, sutType, nCastingTime );
; 290  : #endif // __VER >= 8 // __S8_PK
; 291  : 	return  bSuccess;
; 292  : }

  00051	59		 pop	 ecx
  00052	c2 14 00	 ret	 20			; 00000014H
$L274305:

; 200  : 		}
; 201  : 		dwSkill	= pSkill->dwSkill;

  00055	8b 18		 mov	 ebx, DWORD PTR [eax]

; 202  : 	#ifdef __SKILL0517
; 203  : 		dwLevel	= GetSkillLevel( pSkill );
; 204  : 	#else	// __SKILL0517
; 205  : 		dwLevel	= pSkill->dwLevel;
; 206  : 	#endif	// __SKILL0517
; 207  : 
; 208  : 		if( dwSkill == DWORD(-1) )

  00057	83 fb ff	 cmp	 ebx, -1
  0005a	8b 68 04	 mov	 ebp, DWORD PTR [eax+4]

; 209  : 			return FALSE;

  0005d	74 04		 je	 SHORT $L286641

; 210  : 
; 211  : 		if( dwLevel <= 0 )

  0005f	3b ef		 cmp	 ebp, edi
  00061	77 0e		 ja	 SHORT $L274308
$L286641:
  00063	5d		 pop	 ebp
  00064	5b		 pop	 ebx
  00065	5f		 pop	 edi

; 212  : 			return FALSE;

  00066	33 c0		 xor	 eax, eax
  00068	5e		 pop	 esi

; 288  : #else // __VER >= 8 // __S8_PK
; 289  : 	BOOL bSuccess = DoUseSkill( dwSkill, dwLevel, idFocusObj, sutType, nCastingTime );
; 290  : #endif // __VER >= 8 // __S8_PK
; 291  : 	return  bSuccess;
; 292  : }

  00069	59		 pop	 ecx
  0006a	c2 14 00	 ret	 20			; 00000014H
$L286636:

; 212  : 			return FALSE;

  0006d	8b 6c 24 24	 mov	 ebp, DWORD PTR _dwLevel$[esp+16]
$L274308:

; 213  : /*
; 214  : #ifdef __GUILD_COMBAT_1TO1 // chipi_071227  
; 215  : 		if( dwSkill == SI_KNT_HERO_DRAWING )
; 216  : 		{
; 217  : 		#ifdef __CLIENT
; 218  : 			if( g_GuildCombat1to1Mng.IsPossibleMover( this ) )
; 219  : 				return FALSE;
; 220  : 		#endif // __CLIENT
; 221  : 		#ifdef __WORLDSERVER
; 222  : 			if( g_GuildCombat1to1Mng.IsPossibleUser( (CUser*)this ) )
; 223  : 			{
; 224  : 				((CUser*)this)->AddDefinedText( TID_GAME_NEVERKILLSTOP );
; 225  : 				return FALSE;
; 226  : 			}
; 227  : 		#endif // __WORLDSERVER
; 228  : 		}
; 229  : #endif // __GUILD_COMBAT_1TO1
; 230  : */
; 231  : 	}
; 232  : 
; 233  : #ifdef __WORLDSERVER
; 234  : 	int nCastingTime = 0;
; 235  : #endif
; 236  : 
; 237  : 	ItemProp *pSkillProp = NULL;
; 238  : 	AddSkillProp *pAddSkillProp = NULL;
; 239  : 	GetSkillProp( &pSkillProp, &pAddSkillProp, dwSkill, dwLevel, "DoUseSkill_P" );

  00071	8b 16		 mov	 edx, DWORD PTR [esi]
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@FIJAGOKJ@DoUseSkill_P?$AA@
  00078	55		 push	 ebp
  00079	53		 push	 ebx
  0007a	8d 44 24 24	 lea	 eax, DWORD PTR _pAddSkillProp$[esp+28]
  0007e	50		 push	 eax
  0007f	8d 4c 24 2c	 lea	 ecx, DWORD PTR _pSkillProp$[esp+32]
  00083	51		 push	 ecx
  00084	8b ce		 mov	 ecx, esi
  00086	89 7c 24 30	 mov	 DWORD PTR _pSkillProp$[esp+36], edi
  0008a	89 7c 24 2c	 mov	 DWORD PTR _pAddSkillProp$[esp+36], edi
  0008e	ff 52 30	 call	 DWORD PTR [edx+48]

; 240  : 
; 241  : 	if(pSkillProp == NULL)

  00091	8b 44 24 1c	 mov	 eax, DWORD PTR _pSkillProp$[esp+16]
  00095	85 c0		 test	 eax, eax

; 242  : 		return FALSE;

  00097	74 ca		 je	 SHORT $L286641

; 243  : 
; 244  : 	OBJMSG dwMsg = OBJMSG_NONE;
; 245  : 	int nMotion = (int)pSkillProp->dwUseMotion;
; 246  : 	
; 247  : 	if( pSkillProp->dwSkillType == KT_MAGIC )

  00099	8b 80 18 02 00
	00		 mov	 eax, DWORD PTR [eax+536]
  0009f	83 f8 01	 cmp	 eax, 1
  000a2	75 4e		 jne	 SHORT $L274317

; 248  : 	{
; 249  : 		if( sutType == SUT_QUEUESTART )		//   

  000a4	8b 44 24 24	 mov	 eax, DWORD PTR _sutType$[esp+16]
  000a8	83 f8 01	 cmp	 eax, 1
  000ab	75 0b		 jne	 SHORT $L274318

; 250  : 		{
; 251  : 		#ifdef __WORLDSERVER
; 252  : 			nCastingTime = GetQueueCastingTime();	//      .

  000ad	8b ce		 mov	 ecx, esi
  000af	e8 00 00 00 00	 call	 ?GetQueueCastingTime@CMover@@QAEHXZ ; CMover::GetQueueCastingTime
  000b4	8b f8		 mov	 edi, eax

; 253  : 		#endif
; 254  : 			dwMsg = OBJMSG_MAGICCASTING;
; 255  : 		} 
; 256  : 		else if( sutType == SUT_QUEUEING )	//   

  000b6	eb 44		 jmp	 SHORT $L286637
$L274318:
  000b8	83 f8 02	 cmp	 eax, 2
  000bb	75 04		 jne	 SHORT $L274320

; 257  : 		{
; 258  : 		#ifdef __WORLDSERVER
; 259  : 			nCastingTime = 0;						//   .

  000bd	33 ff		 xor	 edi, edi

; 260  : 		#endif
; 261  : 			nMotion += 2;
; 262  : 			dwMsg = OBJMSG_MAGICSKILL;
; 263  : 		} 
; 264  : 		else

  000bf	eb 3b		 jmp	 SHORT $L286637
$L274320:

; 265  : 		{									//    
; 266  : 		#ifdef __WORLDSERVER
; 267  : 		
; 268  : 		#if __VER >= 9	// __SKILL_0706
; 269  : 			nCastingTime	= (int)( ( pAddSkillProp->dwCastingTime / 1000.0f ) * SEC1 );	//   .

  000c1	8b 54 24 18	 mov	 edx, DWORD PTR _pAddSkillProp$[esp+16]
  000c5	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000c8	db 42 60	 fild	 DWORD PTR [edx+96]
  000cb	85 c0		 test	 eax, eax
  000cd	7d 06		 jge	 SHORT $L286640
  000cf	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L286640:
  000d5	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a83126f
  000db	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41700000
  000e1	e8 00 00 00 00	 call	 __ftol2

; 270  : 		#else	// __SKILL_0706
; 271  : 			nCastingTime = (int)((pAddSkillProp->dwSkillReady / 1000.0f) * SEC1);	//   .
; 272  : 		#endif	// __SKILL_0706
; 273  : 		
; 274  : 			nCastingTime = GetCastingTime( nCastingTime );

  000e6	50		 push	 eax
  000e7	8b ce		 mov	 ecx, esi
  000e9	e8 00 00 00 00	 call	 ?GetCastingTime@CMover@@QAEHH@Z ; CMover::GetCastingTime
  000ee	8b f8		 mov	 edi, eax

; 275  : 		#endif	// __WORLDSERVER
; 276  : 			dwMsg = OBJMSG_MAGICCASTING;
; 277  : 		}
; 278  : 	}
; 279  : 	else if( pSkillProp->dwSkillType == KT_SKILL )

  000f0	eb 0a		 jmp	 SHORT $L286637
$L274317:
  000f2	83 f8 02	 cmp	 eax, 2
  000f5	75 05		 jne	 SHORT $L286637

; 280  : 	{
; 281  : 	#ifdef __WORLDSERVER
; 282  : 		nCastingTime = 1;

  000f7	bf 01 00 00 00	 mov	 edi, 1
$L286637:

; 283  : 	#endif
; 284  : 	}
; 285  : 
; 286  : #if __VER >= 8 // __S8_PK
; 287  : 	BOOL bSuccess = DoUseSkill( dwSkill, dwLevel, idFocusObj, sutType, bControl, nCastingTime );

  000fc	8b 4c 24 28	 mov	 ecx, DWORD PTR _bControl$[esp+16]
  00100	8b 54 24 24	 mov	 edx, DWORD PTR _sutType$[esp+16]
  00104	8b 44 24 20	 mov	 eax, DWORD PTR _idFocusObj$[esp+16]
  00108	57		 push	 edi
  00109	51		 push	 ecx
  0010a	52		 push	 edx
  0010b	50		 push	 eax
  0010c	55		 push	 ebp
  0010d	53		 push	 ebx
  0010e	8b ce		 mov	 ecx, esi
  00110	e8 00 00 00 00	 call	 ?DoUseSkill@CMover@@QAEHKHKW4SKILLUSETYPE@@HH@Z ; CMover::DoUseSkill
  00115	5d		 pop	 ebp
  00116	5b		 pop	 ebx
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi

; 288  : #else // __VER >= 8 // __S8_PK
; 289  : 	BOOL bSuccess = DoUseSkill( dwSkill, dwLevel, idFocusObj, sutType, nCastingTime );
; 290  : #endif // __VER >= 8 // __S8_PK
; 291  : 	return  bSuccess;
; 292  : }

  00119	59		 pop	 ecx
  0011a	c2 14 00	 ret	 20			; 00000014H
?DoUseSkill@CMover@@QAEHHHKW4SKILLUSETYPE@@H@Z ENDP	; CMover::DoUseSkill
_TEXT	ENDS
PUBLIC	?DoUseItemSexChange@CMover@@QAEHH@Z		; CMover::DoUseItemSexChange
EXTRN	?SendUpdatePlayerData@CDPDatabaseClient@@QAEXPAVCUser@@@Z:NEAR ; CDPDatabaseClient::SendUpdatePlayerData
EXTRN	?UpdateLocalMatrix@CObj@@QAEXXZ:NEAR		; CObj::UpdateLocalMatrix
EXTRN	?RedoEquip@CMover@@QAEXHH@Z:NEAR		; CMover::RedoEquip
EXTRN	?ResetScale@CObj@@QAEXXZ:NEAR			; CObj::ResetScale
EXTRN	?SetTypeIndex@CObj@@QAEHPAUIDirect3DDevice9@@KKH@Z:NEAR ; CObj::SetTypeIndex
EXTRN	?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z:NEAR	; CUserMng::AddSexChange
EXTRN	?AddChangeFace@CUserMng@@QAEXKK@Z:NEAR		; CUserMng::AddChangeFace
; Function compile flags: /Ogty
;	COMDAT ?DoUseItemSexChange@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nFace$ = 8						; size = 4
?DoUseItemSexChange@CMover@@QAEHH@Z PROC NEAR		; CMover::DoUseItemSexChange, COMDAT
; _this$ = ecx

; 3390 : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 3391 : 	// 1.
; 3392 : 	for( DWORD dwParts = 0; dwParts < MAX_HUMAN_PARTS; dwParts++ )

  00004	33 ff		 xor	 edi, edi
$L275495:

; 3393 : 	{
; 3394 : 		if( dwParts == PARTS_HEAD || dwParts == PARTS_HAIR || dwParts == PARTS_LWEAPON
; 3395 : 			|| dwParts == PARTS_RWEAPON || dwParts == PARTS_SHIELD || dwParts == PARTS_RIDE
; 3396 : 			|| ( dwParts >= PARTS_NECKLACE1 && dwParts <= PARTS_BULLET ) )

  00006	85 ff		 test	 edi, edi
  00008	74 33		 je	 SHORT $L275496
  0000a	83 ff 01	 cmp	 edi, 1
  0000d	74 2e		 je	 SHORT $L275496
  0000f	83 ff 09	 cmp	 edi, 9
  00012	74 29		 je	 SHORT $L275496
  00014	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00017	74 24		 je	 SHORT $L275496
  00019	83 ff 0b	 cmp	 edi, 11			; 0000000bH
  0001c	74 1f		 je	 SHORT $L275496
  0001e	83 ff 0d	 cmp	 edi, 13			; 0000000dH
  00021	74 1a		 je	 SHORT $L275496
  00023	83 ff 13	 cmp	 edi, 19			; 00000013H
  00026	72 05		 jb	 SHORT $L275498
  00028	83 ff 19	 cmp	 edi, 25			; 00000019H
  0002b	76 10		 jbe	 SHORT $L275496
$L275498:

; 3397 : 			continue;
; 3398 : 		
; 3399 : 		CItemElem* pArmor	= m_Inventory.GetEquip( dwParts );

  0002d	57		 push	 edi
  0002e	8d 8e 90 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2960]
  00034	e8 00 00 00 00	 call	 ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetEquip

; 3400 : 		if( pArmor )

  00039	85 c0		 test	 eax, eax
  0003b	75 1e		 jne	 SHORT $L286656
$L275496:

; 3391 : 	// 1.
; 3392 : 	for( DWORD dwParts = 0; dwParts < MAX_HUMAN_PARTS; dwParts++ )

  0003d	47		 inc	 edi
  0003e	83 ff 1f	 cmp	 edi, 31			; 0000001fH
  00041	72 c3		 jb	 SHORT $L275495

; 3404 : 		}
; 3405 : 	}
; 3406 : 
; 3407 : 	// 2.
; 3408 : 	DWORD dwIndex;
; 3409 : 	if( GetSex() == SEX_MALE )

  00043	8a 86 20 06 00
	00		 mov	 al, BYTE PTR [esi+1568]
  00049	84 c0		 test	 al, al
  0004b	75 28		 jne	 SHORT $L275504

; 3410 : 	{
; 3411 : 		dwIndex		= MI_FEMALE;

  0004d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 3412 : 		SetSex( SEX_FEMALE );

  00052	c6 86 20 06 00
	00 01		 mov	 BYTE PTR [esi+1568], 1

; 3413 : 	}
; 3414 : 	else

  00059	eb 26		 jmp	 SHORT $L286653
$L286656:

; 3401 : 		{
; 3402 : 			((CUser*)this)->AddDefinedText( TID_GAME_CHECK_EQUIP, "" );

  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00060	68 3f 0a 00 00	 push	 2623			; 00000a3fH
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	5f		 pop	 edi

; 3403 : 				return FALSE;

  0006f	33 c0		 xor	 eax, eax
  00071	5e		 pop	 esi

; 3439 : }

  00072	c2 04 00	 ret	 4
$L275504:

; 3415 : 	{
; 3416 : 		dwIndex	= MI_MALE;

  00075	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 3417 : 		SetSex( SEX_MALE );

  0007a	c6 86 20 06 00
	00 00		 mov	 BYTE PTR [esi+1568], 0
$L286653:

; 3418 : 	}
; 3419 : 
; 3420 : 	SetTypeIndex( D3DDEVICE, OT_MOVER, dwIndex );

  00081	6a 00		 push	 0
  00083	50		 push	 eax
  00084	6a 05		 push	 5
  00086	6a 00		 push	 0
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 ?SetTypeIndex@CObj@@QAEHPAUIDirect3DDevice9@@KKH@Z ; CObj::SetTypeIndex

; 3421 : 	ResetScale();

  0008f	8b ce		 mov	 ecx, esi
  00091	e8 00 00 00 00	 call	 ?ResetScale@CObj@@QAEXXZ ; CObj::ResetScale

; 3422 : 	SetMotion( MTI_WALK );

  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	6a 00		 push	 0
  0009a	6a 04		 push	 4
  0009c	6a 03		 push	 3
  0009e	8b ce		 mov	 ecx, esi
  000a0	ff 50 04	 call	 DWORD PTR [eax+4]

; 3423 : 	//RedoEquip( FALSE );		// chipi_091125 
; 3424 : 	RedoEquip( FALSE, FALSE );	// chipi_091125  - ,         ()   .

  000a3	6a 00		 push	 0
  000a5	6a 00		 push	 0
  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?RedoEquip@CMover@@QAEXHH@Z ; CMover::RedoEquip

; 3425 : 	UpdateLocalMatrix();

  000ae	8b ce		 mov	 ecx, esi
  000b0	e8 00 00 00 00	 call	 ?UpdateLocalMatrix@CObj@@QAEXXZ ; CObj::UpdateLocalMatrix

; 3426 : 
; 3427 : 	// 3.
; 3428 : 	g_UserMng.AddSexChange( this );

  000b5	56		 push	 esi
  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000bb	e8 00 00 00 00	 call	 ?AddSexChange@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddSexChange

; 3429 : 
; 3430 : 	// 4.
; 3431 : 	m_dwHeadMesh	= (DWORD)nFace;

  000c0	8b 44 24 0c	 mov	 eax, DWORD PTR _nFace$[esp+4]

; 3432 : 	g_UserMng.AddChangeFace( m_idPlayer, (DWORD)nFace );

  000c4	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  000ca	50		 push	 eax
  000cb	51		 push	 ecx
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000d1	89 86 34 06 00
	00		 mov	 DWORD PTR [esi+1588], eax
  000d7	e8 00 00 00 00	 call	 ?AddChangeFace@CUserMng@@QAEXKK@Z ; CUserMng::AddChangeFace

; 3433 : 
; 3434 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 3435 : 	g_dpDBClient.SendUpdatePlayerData( static_cast<CUser*>(this) );

  000dc	56		 push	 esi
  000dd	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  000e2	e8 00 00 00 00	 call	 ?SendUpdatePlayerData@CDPDatabaseClient@@QAEXPAVCUser@@@Z ; CDPDatabaseClient::SendUpdatePlayerData
  000e7	5f		 pop	 edi

; 3436 : #endif // __SYS_PLAYER_DATA
; 3437 : 
; 3438 : 	return TRUE;

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	5e		 pop	 esi

; 3439 : }

  000ee	c2 04 00	 ret	 4
?DoUseItemSexChange@CMover@@QAEHH@Z ENDP		; CMover::DoUseItemSexChange
_TEXT	ENDS
PUBLIC	??_C@_0CN@DCNDELEC@DoAttackRange?5?3?5?$CFs?5ActiveHandIte@ ; `string'
PUBLIC	??_C@_0DA@HDIEHEPJ@DoAttackRange?5?3?5?$CFs?5?$FL?$CFd?$FN?8s?5dwUseM@ ; `string'
PUBLIC	?DoAttackRange@CMover@@QAEHPAVCObj@@KH@Z	; CMover::DoAttackRange
EXTRN	?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z:NEAR ; CUserMng::AddRangeAttack
;	COMDAT ??_C@_0CN@DCNDELEC@DoAttackRange?5?3?5?$CFs?5ActiveHandIte@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
CONST	SEGMENT
??_C@_0CN@DCNDELEC@DoAttackRange?5?3?5?$CFs?5ActiveHandIte@ DB 'DoAttackR'
	DB	'ange : %s ActiveHandItemProp = NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HDIEHEPJ@DoAttackRange?5?3?5?$CFs?5?$FL?$CFd?$FN?8s?5dwUseM@
CONST	SEGMENT
??_C@_0DA@HDIEHEPJ@DoAttackRange?5?3?5?$CFs?5?$FL?$CFd?$FN?8s?5dwUseM@ DB 'D'
	DB	'oAttackRange : %s [%d]''s dwUseMotion = NULL_ID', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoAttackRange@CMover@@QAEHPAVCObj@@KH@Z
_TEXT	SEGMENT
$T286661 = -24						; size = 12
$T286662 = -12						; size = 12
_pTargetObj$ = 8					; size = 4
_dwItemID$ = 12						; size = 4
_idSfxHit$ = 16						; size = 4
?DoAttackRange@CMover@@QAEHPAVCObj@@KH@Z PROC NEAR	; CMover::DoAttackRange, COMDAT
; _this$ = ecx

; 3544 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx

; 3545 : 	ItemProp* pItemProp = NULL;
; 3546 : 	int nPower = 0;
; 3547 : 
; 3548 : 	if( IsInvalidObj(pTargetObj) )

  00004	8b 5c 24 20	 mov	 ebx, DWORD PTR _pTargetObj$[esp+24]
  00008	85 db		 test	 ebx, ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	74 06		 je	 SHORT $L286680
  0000f	f6 43 04 01	 test	 BYTE PTR [ebx+4], 1
  00013	74 0d		 je	 SHORT $L275540
$L286680:
  00015	5e		 pop	 esi

; 3549 : 		return -1;

  00016	b8 ff ff ff ff	 mov	 eax, -1
  0001b	5b		 pop	 ebx

; 3631 : }

  0001c	83 c4 18	 add	 esp, 24			; 00000018H
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$L275540:

; 3550 : 	
; 3551 : 
; 3552 : #ifdef __CLIENT
; 3553 : 	if( IsActiveMover() )
; 3554 : 	{
; 3555 : 		//        
; 3556 : 		CWorld *pWorld = GetWorld();
; 3557 : 		D3DXVECTOR3 vStart = GetPos();				vStart.y += 0.5f;
; 3558 : 		D3DXVECTOR3 vEnd   = pTargetObj->GetPos();	vEnd.y += 0.5f;
; 3559 : 
; 3560 : 		if( pWorld->IntersectObjLine( NULL, vStart, vEnd, FALSE, FALSE ) )
; 3561 : 		{
; 3562 : 			g_WndMng.PutString( prj.GetText( TID_GAME_BLOCKTARGETING ), NULL, prj.GetTextColor( TID_GAME_BLOCKTARGETING ) );
; 3563 : 			
; 3564 : 			return -1;
; 3565 : 		}
; 3566 : 	}
; 3567 : #endif  // CLIENT
; 3568 : 	
; 3569 : 
; 3570 : 	if( IsPlayer() )

  00022	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00028	85 c0		 test	 eax, eax
  0002a	57		 push	 edi
  0002b	74 35		 je	 SHORT $L275541

; 3571 : 	{
; 3572 : 		pItemProp = GetActiveHandItemProp();			

  0002d	6a 0a		 push	 10			; 0000000aH
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?GetActiveHandItemProp@CMover@@QAEPAUItemProp@@H@Z ; CMover::GetActiveHandItemProp

; 3573 : 		nPower = dwItemID;
; 3574 : 
; 3575 : 	#ifdef __WORLDSERVER
; 3576 : 		CItemElem* pItemElem = m_Inventory.GetEquip( PARTS_BULLET );	//   

  00036	6a 19		 push	 25			; 00000019H
  00038	8d 8e 90 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2960]
  0003e	8b f8		 mov	 edi, eax
  00040	e8 00 00 00 00	 call	 ?GetEquip@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetEquip

; 3577 : 		if( pItemElem == NULL || pItemElem->GetProp()->dwItemKind3 != IK3_ARROW )

  00045	85 c0		 test	 eax, eax
  00047	74 0d		 je	 SHORT $L275544
  00049	8b c8		 mov	 ecx, eax
  0004b	e8 00 00 00 00	 call	 ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ; CItemElem::GetPropA
  00050	83 78 78 3c	 cmp	 DWORD PTR [eax+120], 60	; 0000003cH
  00054	74 31		 je	 SHORT $L275548
$L275544:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 3578 : 			return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	5b		 pop	 ebx

; 3631 : }

  0005c	83 c4 18	 add	 esp, 24			; 00000018H
  0005f	c2 0c 00	 ret	 12			; 0000000cH
$L275541:

; 3579 : 	#endif // __WORLDSERVER
; 3580 : 	}
; 3581 : 	else
; 3582 : 	{
; 3583 : 		if( dwItemID == NULL_ID || dwItemID == 0 )	

  00062	8b 44 24 2c	 mov	 eax, DWORD PTR _dwItemID$[esp+32]
  00066	83 f8 ff	 cmp	 eax, -1
  00069	74 11		 je	 SHORT $L275547
  0006b	85 c0		 test	 eax, eax
  0006d	74 0d		 je	 SHORT $L275547

; 3585 : 		else
; 3586 : 			pItemProp = prj.GetItemProp( dwItemID );

  0006f	50		 push	 eax
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00075	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp
  0007a	eb 09		 jmp	 SHORT $L286703
$L275547:

; 3584 : 			pItemProp = GetActiveHandItemProp();		//     ( )

  0007c	6a 0a		 push	 10			; 0000000aH
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?GetActiveHandItemProp@CMover@@QAEPAUItemProp@@H@Z ; CMover::GetActiveHandItemProp
$L286703:
  00085	8b f8		 mov	 edi, eax
$L275548:

; 3587 : 	}
; 3588 : 	
; 3589 : 	if( pItemProp == NULL )

  00087	85 ff		 test	 edi, edi
  00089	75 20		 jne	 SHORT $L275549

; 3590 : 	{
; 3591 : 		Error( "DoAttackRange : %s ActiveHandItemProp = NULL", m_szName );

  0008b	81 c6 90 16 00
	00		 add	 esi, 5776		; 00001690H
  00091	56		 push	 esi
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@DCNDELEC@DoAttackRange?5?3?5?$CFs?5ActiveHandIte@
  00097	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0009c	83 c4 08	 add	 esp, 8
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi

; 3592 : 		return -1;

  000a1	83 c8 ff	 or	 eax, -1
  000a4	5b		 pop	 ebx

; 3631 : }

  000a5	83 c4 18	 add	 esp, 24			; 00000018H
  000a8	c2 0c 00	 ret	 12			; 0000000cH
$L275549:

; 3593 : 	}
; 3594 : 
; 3595 : 	if( pItemProp->dwWeaponType != WT_RANGE && pItemProp->dwWeaponType != WT_RANGE_BOW )		//   RANGE  

  000ab	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  000b1	83 f8 08	 cmp	 eax, 8
  000b4	74 05		 je	 SHORT $L275551
  000b6	83 f8 15	 cmp	 eax, 21			; 00000015H

; 3596 : 	{
; 3597 : 		return -1;

  000b9	75 9b		 jne	 SHORT $L275544
$L275551:

; 3598 : 	}
; 3599 : 	
; 3600 : 	DWORD dwUseMotion = pItemProp->dwUseMotion;	

  000bb	8b 87 e8 01 00
	00		 mov	 eax, DWORD PTR [edi+488]

; 3601 : 	if( dwUseMotion == NULL_ID )

  000c1	83 f8 ff	 cmp	 eax, -1
  000c4	75 26		 jne	 SHORT $L275555

; 3602 : 	{
; 3603 : 		if( IsPlayer() )

  000c6	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  000cc	85 c0		 test	 eax, eax

; 3604 : 		{
; 3605 : 			dwUseMotion = MTI_ATK_13 - MTI_STAND_13;//23;
; 3606 : 		}
; 3607 : 		else

  000ce	75 17		 jne	 SHORT $L286704

; 3608 : 		{
; 3609 : 			Error( "DoAttackRange : %s [%d]'s dwUseMotion = NULL_ID", m_szName, pItemProp->dwID );

  000d0	8b 07		 mov	 eax, DWORD PTR [edi]
  000d2	50		 push	 eax
  000d3	8d 8e 90 16 00
	00		 lea	 ecx, DWORD PTR [esi+5776]
  000d9	51		 push	 ecx
  000da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DA@HDIEHEPJ@DoAttackRange?5?3?5?$CFs?5?$FL?$CFd?$FN?8s?5dwUseM@
  000df	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$L286704:

; 3610 : 			dwUseMotion = MTI_ATK1;		//         .

  000e7	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
$L275555:

; 3611 : 		}
; 3612 : 	}
; 3613 : 
; 3614 : 	OBJID	idTarget = ((CCtrl*)pTargetObj)->GetId();

  000ec	8b bb bc 01 00
	00		 mov	 edi, DWORD PTR [ebx+444]

; 3615 : 
; 3616 : 	int nError;
; 3617 : 	if( ( nError = m_pActMover->SendActMsg( OBJMSG_ATK_RANGE1, idTarget, (int)dwUseMotion ) ) == 1 )	// .

  000f2	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  000f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fa	55		 push	 ebp
  000fb	6a 00		 push	 0
  000fd	6a 00		 push	 0
  000ff	6a 00		 push	 0
  00101	50		 push	 eax
  00102	57		 push	 edi
  00103	6a 23		 push	 35			; 00000023H
  00105	ff 52 04	 call	 DWORD PTR [edx+4]
  00108	8b e8		 mov	 ebp, eax
  0010a	83 fd 01	 cmp	 ebp, 1
  0010d	0f 85 83 00 00
	00		 jne	 $L275561

; 3618 : 	{
; 3619 : 		SetAngle( GetDegree(pTargetObj->GetPos(), GetPos()) );			//   .

  00113	8d 86 60 01 00
	00		 lea	 eax, DWORD PTR [esi+352]
  00119	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0011e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00121	89 4c 24 10	 mov	 DWORD PTR $T286661[esp+40], ecx
  00125	81 c3 60 01 00
	00		 add	 ebx, 352		; 00000160H
  0012b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0012d	89 54 24 14	 mov	 DWORD PTR $T286661[esp+44], edx
  00131	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00134	89 4c 24 1c	 mov	 DWORD PTR $T286662[esp+40], ecx
  00138	8d 4c 24 10	 lea	 ecx, DWORD PTR $T286661[esp+40]
  0013c	89 54 24 20	 mov	 DWORD PTR $T286662[esp+44], edx
  00140	89 44 24 18	 mov	 DWORD PTR $T286661[esp+48], eax
  00144	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00147	51		 push	 ecx
  00148	8d 54 24 20	 lea	 edx, DWORD PTR $T286662[esp+44]
  0014c	52		 push	 edx
  0014d	89 44 24 2c	 mov	 DWORD PTR $T286662[esp+56], eax
  00151	e8 00 00 00 00	 call	 ?GetDegree@@YAMABUD3DXVECTOR3@@0@Z ; GetDegree
  00156	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  0015a	83 c4 04	 add	 esp, 4
  0015d	8b ce		 mov	 ecx, esi
  0015f	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle

; 3620 : 		SetActParam( OBJACT_RANGE_ATTACK, idTarget, dwItemID, idSfxHit );	//   

  00164	8b 5c 24 34	 mov	 ebx, DWORD PTR _idSfxHit$[esp+36]
  00168	8b 44 24 30	 mov	 eax, DWORD PTR _dwItemID$[esp+36]
  0016c	53		 push	 ebx
  0016d	50		 push	 eax
  0016e	57		 push	 edi
  0016f	6a 03		 push	 3
  00171	8b ce		 mov	 ecx, esi
  00173	e8 00 00 00 00	 call	 ?SetActParam@CMover@@AAEXW4OBJACT@@HHH@Z ; CMover::SetActParam

; 3621 : 		
; 3622 : 	#ifdef __WORLDSERVER
; 3623 : 		g_UserMng.AddRangeAttack( this, OBJMSG_ATK_RANGE1, idTarget, dwItemID, 0, idSfxHit );

  00178	8b 4c 24 30	 mov	 ecx, DWORD PTR _dwItemID$[esp+36]
  0017c	53		 push	 ebx
  0017d	6a 00		 push	 0
  0017f	51		 push	 ecx
  00180	57		 push	 edi
  00181	6a 23		 push	 35			; 00000023H
  00183	56		 push	 esi
  00184	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00189	e8 00 00 00 00	 call	 ?AddRangeAttack@CUserMng@@QAEXPAVCMover@@KKHHH@Z ; CUserMng::AddRangeAttack

; 3624 : 		ArrowDown( 1 );		//  1 

  0018e	55		 push	 ebp
  0018f	8b ce		 mov	 ecx, esi
  00191	e8 00 00 00 00	 call	 ?ArrowDown@CMover@@QAEXH@Z ; CMover::ArrowDown
$L275561:

; 3625 : 	#else	// __WORLDSERVER
; 3626 : 		if( IsActiveMover() )	//      .
; 3627 : 			g_DPlay.SendRangeAttack( OBJMSG_ATK_RANGE1, ( (CCtrl*)pTargetObj )->GetId(), dwItemID, m_idSfxHit ); 
; 3628 : 	#endif	// __WORLDSERVER
; 3629 : 	}
; 3630 : 	return nError;

  00196	8b c5		 mov	 eax, ebp
  00198	5d		 pop	 ebp
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5b		 pop	 ebx

; 3631 : }

  0019c	83 c4 18	 add	 esp, 24			; 00000018H
  0019f	c2 0c 00	 ret	 12			; 0000000cH
?DoAttackRange@CMover@@QAEHPAVCObj@@KH@Z ENDP		; CMover::DoAttackRange
_TEXT	ENDS
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	03 44 24 04	 add	 eax, DWORD PTR __Pos$[esp-4]

; 556  : 		}

  00007	c2 04 00	 ret	 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::lower_bound
; Function compile flags: /Ogty
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L286833
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L286820:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $L286822
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $L286823
$L286822:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L286823:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L286820
  00029	5b		 pop	 ebx
$L286833:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 811  : 		}

  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Ptr$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 10	 mov	 edi, DWORD PTR __Count$[esp+4]
  0000a	85 ff		 test	 edi, edi
  0000c	8b c5		 mov	 eax, ebp
  0000e	76 10		 jbe	 SHORT $L286877
  00010	56		 push	 esi
  00011	8b 74 24 18	 mov	 esi, DWORD PTR __Val$[esp+8]
  00015	8b cf		 mov	 ecx, edi
$L286870:
  00017	8a 16		 mov	 dl, BYTE PTR [esi]
  00019	88 10		 mov	 BYTE PTR [eax], dl
  0001b	40		 inc	 eax
  0001c	49		 dec	 ecx
  0001d	75 f8		 jne	 SHORT $L286870
  0001f	5e		 pop	 esi
$L286877:

; 879  : 		return (_Ptr + _Count);

  00020	8d 04 2f	 lea	 eax, DWORD PTR [edi+ebp]
  00023	5f		 pop	 edi
  00024	5d		 pop	 ebp

; 880  : 		}

  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Cat$286885 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00001	8b 04 24	 mov	 eax, DWORD PTR __Cat$286885[esp+4]
  00004	8b 4c 24 14	 mov	 ecx, DWORD PTR __Al$[esp]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR __Dest$[esp]
  0000c	50		 push	 eax
  0000d	8b 44 24 10	 mov	 eax, DWORD PTR __Last$[esp+4]
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR __First$[esp+8]
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >

; 129  : 	}

  0001e	83 c4 18	 add	 esp, 24			; 00000018H
  00021	c3		 ret	 0
??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nMinBufferLength$[esp]
  00019	2b d0		 sub	 edx, eax
  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L286902
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L286902:
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 491  : 	}

  0002a	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 457  : 		_Tidy(true);

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $L286940
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$L286940:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi

; 458  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC NEAR	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		_Tidy();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $L286967
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$L286967:
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00028	5e		 pop	 esi

; 389  : 		}

  00029	c3		 ret	 0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_nID$ = 12						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1981 : 	{

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 1982 : 		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID );

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _nID$[esp+4]
  00006	8b c6		 mov	 eax, esi
  00008	c1 e8 04	 shr	 eax, 4
  0000b	57		 push	 edi
  0000c	8b 7c 24 10	 mov	 edi, DWORD PTR _hInstance$[esp+8]
  00010	40		 inc	 eax
  00011	8b d9		 mov	 ebx, ecx
  00013	0f b7 c8	 movzx	 ecx, ax
  00016	6a 06		 push	 6
  00018	51		 push	 ecx
  00019	57		 push	 edi
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  00020	85 c0		 test	 eax, eax
  00022	74 11		 je	 SHORT $L287049
  00024	56		 push	 esi
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  0002c	8b f8		 mov	 edi, eax
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1983 : 		if( pImage == NULL )

  00031	85 ff		 test	 edi, edi
  00033	75 08		 jne	 SHORT $L219928
$L287049:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 1984 : 		{
; 1985 : 			return( FALSE );

  00037	33 c0		 xor	 eax, eax
  00039	5b		 pop	 ebx

; 1994 : 	}

  0003a	c2 08 00	 ret	 8
$L219928:

; 1986 : 		}
; 1987 : 
; 1988 : 		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );

  0003d	0f b7 37	 movzx	 esi, WORD PTR [edi]
  00040	55		 push	 ebp
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	56		 push	 esi
  00050	8d 6f 02	 lea	 ebp, DWORD PTR [edi+2]
  00053	55		 push	 ebp
  00054	6a 00		 push	 0
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0005d	8b f0		 mov	 esi, eax

; 1989 : 		PXSTR pszBuffer = GetBuffer( nLength );

  0005f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00061	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00064	83 e8 10	 sub	 eax, 16			; 00000010H
  00067	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006a	ba 01 00 00 00	 mov	 edx, 1
  0006f	2b d1		 sub	 edx, ecx
  00071	2b c6		 sub	 eax, esi
  00073	0b d0		 or	 edx, eax
  00075	7d 08		 jge	 SHORT $L287010
  00077	56		 push	 esi
  00078	8b cb		 mov	 ecx, ebx
  0007a	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L287010:
  0007f	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1990 : 		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );

  00081	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	56		 push	 esi
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	55		 push	 ebp
  0008c	6a 00		 push	 0
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 1991 : 		ReleaseBufferSetLength( nLength );

  0009b	85 f6		 test	 esi, esi
  0009d	5d		 pop	 ebp
  0009e	7c 1b		 jl	 SHORT $L287046
  000a0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a2	3b 70 f8	 cmp	 esi, DWORD PTR [eax-8]
  000a5	7f 14		 jg	 SHORT $L287046
  000a7	89 70 f4	 mov	 DWORD PTR [eax-12], esi
  000aa	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ac	5f		 pop	 edi
  000ad	c6 04 0e 00	 mov	 BYTE PTR [esi+ecx], 0
  000b1	5e		 pop	 esi

; 1992 : 
; 1993 : 		return( TRUE );

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	5b		 pop	 ebx

; 1994 : 	}

  000b8	c2 08 00	 ret	 8
$L287046:
  000bb	68 57 00 07 80	 push	 -2147024809		; 80070057H
  000c0	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L287051:
$L287050:
  000c5	cc		 int	 3
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L287124
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L287111:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	73 05		 jae	 SHORT $L287113
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $L287114
$L287113:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L287114:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L287111
  00029	5b		 pop	 ebx
$L287124:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 811  : 		}

  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	53		 push	 ebx

; 584  : 		if( nLength == 0 )

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nLength$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	8b e9		 mov	 ebp, ecx
  0000a	75 0a		 jne	 SHORT $L221330

; 585  : 		{
; 586  : 			Empty();

  0000c	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty
  00011	5d		 pop	 ebp
  00012	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00013	c2 08 00	 ret	 8
$L221330:

; 587  : 		}
; 588  : 		else
; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

  00016	8b 54 24 0c	 mov	 edx, DWORD PTR _pszSrc$[esp+4]
  0001a	85 d2		 test	 edx, edx
  0001c	75 0a		 jne	 SHORT $L221332

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

$L287196:
  0001e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L287200:
$L221332:

; 597  : 				AtlThrow(E_INVALIDARG);			
; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

  00028	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0002b	56		 push	 esi

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

  0002c	8b f2		 mov	 esi, edx
  0002e	2b f0		 sub	 esi, eax

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  00038	57		 push	 edi
  00039	8b 78 f4	 mov	 edi, DWORD PTR [eax-12]
  0003c	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0003f	2b c3		 sub	 eax, ebx
  00041	0b c8		 or	 ecx, eax
  00043	7d 0c		 jge	 SHORT $L287163
  00045	53		 push	 ebx
  00046	8b cd		 mov	 ecx, ebp
  00048	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  0004d	8b 54 24 14	 mov	 edx, DWORD PTR _pszSrc$[esp+12]
$L287163:

; 605  : 			if( nOffset <= nOldLength )

  00051	3b f7		 cmp	 esi, edi
  00053	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00056	77 10		 ja	 SHORT $L221337

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

  00058	53		 push	 ebx
  00059	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0005c	51		 push	 ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memmove
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 			}
; 609  : 			else

  00066	eb 14		 jmp	 SHORT $L287170
$L221337:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

  00068	8b cb		 mov	 ecx, ebx
  0006a	8b f2		 mov	 esi, edx
  0006c	8b d1		 mov	 edx, ecx
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	8b f8		 mov	 edi, eax
  00073	f3 a5		 rep movsd
  00075	8b ca		 mov	 ecx, edx
  00077	83 e1 03	 and	 ecx, 3
  0007a	f3 a4		 rep movsb
$L287170:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

  0007c	85 db		 test	 ebx, ebx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	7c 9c		 jl	 SHORT $L287196
  00082	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00085	3b 58 f8	 cmp	 ebx, DWORD PTR [eax-8]
  00088	7f 94		 jg	 SHORT $L287196
  0008a	89 58 f4	 mov	 DWORD PTR [eax-12], ebx
  0008d	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00090	5d		 pop	 ebp
  00091	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  00095	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00096	c2 08 00	 ret	 8
$L287199:
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 1481 : 		if (max_size() < _Newsize)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR __Newsize$[esp+4]
  00006	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00009	8b e9		 mov	 ebp, ecx
  0000b	76 05		 jbe	 SHORT $L221380

; 1482 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L221380:

; 1483 : 		if (_Myres < _Newsize)

  00012	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00015	3b c6		 cmp	 eax, esi
  00017	73 19		 jae	 SHORT $L221381

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  00019	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	8b cd		 mov	 ecx, ebp
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  00025	33 c0		 xor	 eax, eax
  00027	3b c6		 cmp	 eax, esi
  00029	1b c0		 sbb	 eax, eax
  0002b	5e		 pop	 esi
  0002c	f7 d8		 neg	 eax
  0002e	5d		 pop	 ebp

; 1491 : 		}

  0002f	c2 08 00	 ret	 8
$L221381:

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00032	8a 4c 24 10	 mov	 cl, BYTE PTR __Trim$[esp+4]
  00036	84 c9		 test	 cl, cl
  00038	74 5c		 je	 SHORT $L221383
  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0003d	73 57		 jae	 SHORT $L221383
  0003f	53		 push	 ebx

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00040	8b 5d 14	 mov	 ebx, DWORD PTR [ebp+20]
  00043	3b f3		 cmp	 esi, ebx
  00045	73 02		 jae	 SHORT $L287205
  00047	8b de		 mov	 ebx, esi
$L287205:
  00049	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004c	72 2b		 jb	 SHORT $L287259
  0004e	85 db		 test	 ebx, ebx
  00050	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00053	57		 push	 edi
  00054	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  00057	76 16		 jbe	 SHORT $L287257
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b d1		 mov	 edx, ecx
  0005d	c1 e9 02	 shr	 ecx, 2
  00060	8b f0		 mov	 esi, eax
  00062	f3 a5		 rep movsd
  00064	8b ca		 mov	 ecx, edx
  00066	83 e1 03	 and	 ecx, 3
  00069	f3 a4		 rep movsb
  0006b	8b 74 24 14	 mov	 esi, DWORD PTR __Newsize$[esp+12]
$L287257:
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00075	83 c4 04	 add	 esp, 4
  00078	5f		 pop	 edi
$L287259:
  00079	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0007c	33 c0		 xor	 eax, eax
  0007e	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00085	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0008a	3b c6		 cmp	 eax, esi
  0008c	5b		 pop	 ebx
  0008d	1b c0		 sbb	 eax, eax
  0008f	5e		 pop	 esi
  00090	f7 d8		 neg	 eax
  00092	5d		 pop	 ebp

; 1491 : 		}

  00093	c2 08 00	 ret	 8
$L221383:

; 1488 : 		else if (_Newsize == 0)

  00096	85 f6		 test	 esi, esi
  00098	75 23		 jne	 SHORT $L287296

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  0009a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009d	89 75 14	 mov	 DWORD PTR [ebp+20], esi
  000a0	72 14		 jb	 SHORT $L287294
  000a2	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000a5	33 c0		 xor	 eax, eax
  000a7	3b c6		 cmp	 eax, esi
  000a9	1b c0		 sbb	 eax, eax
  000ab	5e		 pop	 esi
  000ac	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  000b0	f7 d8		 neg	 eax
  000b2	5d		 pop	 ebp

; 1491 : 		}

  000b3	c2 08 00	 ret	 8

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

$L287294:
  000b6	83 c5 04	 add	 ebp, 4
  000b9	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
$L287296:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000bd	33 c0		 xor	 eax, eax
  000bf	3b c6		 cmp	 eax, esi
  000c1	1b c0		 sbb	 eax, eax
  000c3	5e		 pop	 esi
  000c4	f7 d8		 neg	 eax
  000c6	5d		 pop	 ebp

; 1491 : 		}

  000c7	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$287312 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR __Cat$287312[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR __Last$[esp-4]
  00008	50		 push	 eax
  00009	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp]
  0000d	51		 push	 ecx
  0000e	8b 4c 24 14	 mov	 ecx, DWORD PTR __Ptr$[esp+4]
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 805  : 		}

  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator>
_TEXT	ENDS
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	??_C@_0DA@GIPACFEO@II_SYS_SYS_SCR_RETURN?5selected?5v@ ; `string'
PUBLIC	??_C@_0BB@KDNJAMCD@MaFl_InstantBank?$AA@	; `string'
PUBLIC	??_C@_09FAFPDOMC@USE_PERIN?$AA@			; `string'
PUBLIC	__real@4eee6b28
PUBLIC	?DoUseItemSystem@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemSystem
EXTRN	?ReState@CMover@@QAEXXZ:NEAR			; CMover::ReState
EXTRN	?ReStateOne@CMover@@QAEXH@Z:NEAR		; CMover::ReStateOne
EXTRN	?ReStateOneLow@CMover@@QAEXH@Z:NEAR		; CMover::ReStateOneLow
EXTRN	?AddDiagText@CUser@@QAEXPBD@Z:NEAR		; CUser::AddDiagText
EXTRN	?InitSkillExp@CMover@@QAEHXZ:NEAR		; CMover::InitSkillExp
EXTRN	?InitCharacter@CMover@@QAEXPAUtagCHARACTER@@@Z:NEAR ; CMover::InitCharacter
EXTRN	?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ:NEAR ; CMover::GetCharacter
EXTRN	?InitNPCProperty@CMover@@QAEXXZ:NEAR		; CMover::InitNPCProperty
EXTRN	?AddObj@CWorld@@QAEHPAVCObj@@HH@Z:NEAR		; CWorld::AddObj
EXTRN	?RemoveIk3Buffs@CMover@@QAEXK@Z:NEAR		; CMover::RemoveIk3Buffs
EXTRN	?GetSummonState@CMover@@QAEHXZ:NEAR		; CMover::GetSummonState
EXTRN	?RemoveDebufBuffs@CMover@@QAEXXZ:NEAR		; CMover::RemoveDebufBuffs
EXTRN	?IsShoutFull@CMover@@QAEHXZ:NEAR		; CMover::IsShoutFull
EXTRN	?IsCommBank@CMover@@QAEHXZ:NEAR			; CMover::IsCommBank
EXTRN	?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z:NEAR	; CObj::SetPos
EXTRN	_sprintf:NEAR
EXTRN	?IsGuildQuestRegion@CProject@@QAEHABUD3DXVECTOR3@@@Z:NEAR ; CProject::IsGuildQuestRegion
EXTRN	?SetPartyLevel@CParty@@QAEXPAVCUser@@KKK@Z:NEAR	; CParty::SetPartyLevel
EXTRN	?GetLife@CPet@@QAEGXZ:NEAR			; CPet::GetLife
EXTRN	?GetParty@CPartyMng@@QAEPAVCParty@@K@Z:NEAR	; CPartyMng::GetParty
EXTRN	?GetPet@CMover@@QAEPAVCPet@@XZ:NEAR		; CMover::GetPet
EXTRN	?GetPetItem@CMover@@QAEPAVCItemElem@@XZ:NEAR	; CMover::GetPetItem
EXTRN	?PetLevelup@CMover@@QAEXXZ:NEAR			; CMover::PetLevelup
EXTRN	?AddGold@CMover@@QAEHHH@Z:NEAR			; CMover::AddGold
EXTRN	?AddInitSkill@CUser@@QAEXXZ:NEAR		; CUser::AddInitSkill
EXTRN	__imp__lstrcpyA@8:NEAR
EXTRN	?AddSummonFriendUse@CUser@@QAEXPAVCItemElem@@@Z:NEAR ; CUser::AddSummonFriendUse
EXTRN	?CreateObj@@YAPAVCObj@@PAUIDirect3DDevice9@@KKH@Z:NEAR ; CreateObj
EXTRN	?AddPetState@CUser@@QAEXKGGK@Z:NEAR		; CUser::AddPetState
EXTRN	?DoUseItemBattery@CUser@@QAEHXZ:NEAR		; CUser::DoUseItemBattery
EXTRN	?DoUseItemInput@CUser@@QAEHPAUItemProp@@PAVCItemElem@@@Z:NEAR ; CUser::DoUseItemInput
EXTRN	?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z:NEAR ; CDPSrvr::OnLogItem
EXTRN	?SendUserPartySkill@CDPCoreClient@@QAEXKHKHH@Z:NEAR ; CDPCoreClient::SendUserPartySkill
EXTRN	?g_DPSrvr@@3VCDPSrvr@@A:BYTE			; g_DPSrvr
EXTRN	?g_DPCoreClient@@3VCDPCoreClient@@A:BYTE	; g_DPCoreClient
EXTRN	?g_PartyMng@@3VCPartyMng@@A:BYTE		; g_PartyMng
EXTRN	?GetAddLife@CPetProperty@@QAEGXZ:NEAR		; CPetProperty::GetAddLife
EXTRN	?GetInstance@CPetProperty@@SAPAV1@XZ:NEAR	; CPetProperty::GetInstance
EXTRN	?SetReturnPos@CUser@@QAEXABUD3DXVECTOR3@@@Z:NEAR ; CUser::SetReturnPos
;	COMDAT ??_C@_0DA@GIPACFEO@II_SYS_SYS_SCR_RETURN?5selected?5v@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
CONST	SEGMENT
??_C@_0DA@GIPACFEO@II_SYS_SYS_SCR_RETURN?5selected?5v@ DB 'II_SYS_SYS_SCR'
	DB	'_RETURN selected village is NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDNJAMCD@MaFl_InstantBank?$AA@
CONST	SEGMENT
??_C@_0BB@KDNJAMCD@MaFl_InstantBank?$AA@ DB 'MaFl_InstantBank', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4eee6b28
CONST	SEGMENT
__real@4eee6b28 DD 04eee6b28r			; 2e+009
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAFPDOMC@USE_PERIN?$AA@
CONST	SEGMENT
??_C@_09FAFPDOMC@USE_PERIN?$AA@ DB 'USE_PERIN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseItemSystem@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT
$T287473 = -236						; size = 4
_fTmpGold$275168 = -236					; size = 4
_nResult$ = -232					; size = 4
_vPos$275111 = -228					; size = 12
$T287324 = -216						; size = 12
_aLogItem$275176 = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_pItemProp$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
_nPart$ = 16						; size = 4
?DoUseItemSystem@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z PROC NEAR ; CMover::DoUseItemSystem, COMDAT
; _this$ = ecx

; 2018 : {

  00000	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	53		 push	 ebx
  0000e	8b 9c 24 f4 00
	00 00		 mov	 ebx, DWORD PTR _pItemProp$[esp+236]
  00015	55		 push	 ebp
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx

; 2019 : 	int nResult = 0;
; 2020 : #ifdef __WORLDSERVER
; 2021 : #ifdef __AZRIA_1023
; 2022 : 	if( IsPlayer() )

  00019	8b 8e 34 02 00
	00		 mov	 ecx, DWORD PTR [esi+564]
  0001f	33 ed		 xor	 ebp, ebp
  00021	85 c9		 test	 ecx, ecx
  00023	57		 push	 edi
  00024	8b bc 24 04 01
	00 00		 mov	 edi, DWORD PTR _pItemElem$[esp+248]
  0002b	89 84 24 f8 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+252], eax
  00032	89 5c 24 10	 mov	 DWORD PTR $T287473[esp+252], ebx
  00036	89 6c 24 14	 mov	 DWORD PTR _nResult$[esp+252], ebp
  0003a	74 18		 je	 SHORT $L274980

; 2023 : 	{
; 2024 : 		CUser* pThis	= static_cast<CUser*>( this );
; 2025 : 		if( pThis->HasInput() )

  0003c	8a 86 44 96 00
	00		 mov	 al, BYTE PTR [esi+38468]
  00042	84 c0		 test	 al, al
  00044	74 0e		 je	 SHORT $L274980

; 2026 : 			return pThis->DoUseItemInput( pItemProp, pItemElem );

  00046	57		 push	 edi
  00047	53		 push	 ebx
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?DoUseItemInput@CUser@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CUser::DoUseItemInput
  0004f	e9 69 0b 00 00	 jmp	 $L274975
$L274980:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  00054	8b 03		 mov	 eax, DWORD PTR [ebx]
  00056	3d 1e 28 00 00	 cmp	 eax, 10270		; 0000281eH
  0005b	0f 87 21 02 00
	00		 ja	 $L287325
  00061	0f 84 ea 01 00
	00		 je	 $L275062
  00067	2d e3 27 00 00	 sub	 eax, 10211		; 000027e3H
  0006c	83 f8 09	 cmp	 eax, 9
  0006f	77 3a		 ja	 SHORT $L275200
  00071	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L287492[eax*4]
$L274985:

; 2030 : 	{
; 2031 : 	case II_CHR_SYS_SCR_RESTATE:
; 2032 : 		{
; 2033 : 			if( m_nInt == 15 && m_nSta == 15 && m_nStr == 15 && m_nDex == 15 )

  00078	8b 8e dc 05 00
	00		 mov	 ecx, DWORD PTR [esi+1500]
  0007e	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  00083	3b c8		 cmp	 ecx, eax
  00085	75 54		 jne	 SHORT $L274986
  00087	39 86 d4 05 00
	00		 cmp	 DWORD PTR [esi+1492], eax
  0008d	75 4c		 jne	 SHORT $L274986
  0008f	39 86 d0 05 00
	00		 cmp	 DWORD PTR [esi+1488], eax
  00095	75 44		 jne	 SHORT $L274986
  00097	39 86 d8 05 00
	00		 cmp	 DWORD PTR [esi+1496], eax
  0009d	75 3c		 jne	 SHORT $L274986

; 2034 : 			{
; 2035 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );

  0009f	8b ce		 mov	 ecx, esi
$L287485:

; 2929 : 			{
; 2930 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  000a1	68 62 0f 00 00	 push	 3938			; 00000f62H
$L287491:
  000a6	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L275200:

; 2948 : #endif // __ADD_RESTATE_LOW
; 2949 : 
; 2950 : 	default:
; 2951 : 			nResult = 1;

  000ab	bd 01 00 00 00	 mov	 ebp, 1
$L274982:

; 2952 : 		break;
; 2953 : 	}
; 2954 : 
; 2955 : #ifndef __AZRIA_1023
; 2956 : #ifdef __SYS_TICKET
; 2957 : 	if( pItemProp->dwItemKind3 == IK3_TICKET )
; 2958 : 	{
; 2959 : 		( (CUser*)this )->DoUseItemTicket( pItemElem );
; 2960 : 		nResult		= 0;
; 2961 : 	}
; 2962 : #endif	// __SYS_TICKET
; 2963 : #endif	// __AZRIA_1023
; 2964 : 
; 2965 : #if __VER >= 14 // __BALLOON_CODE_IMPROVEMENT
; 2966 : 	if( pItemProp->dwItemKind3 == IK3_BALLOON )

  000b0	81 7b 78 88 00
	00 00		 cmp	 DWORD PTR [ebx+120], 136 ; 00000088H
  000b7	0f 85 fe 0a 00
	00		 jne	 $L275203

; 2967 : 	{
; 2968 : 		if( HasBuffByIk3( IK3_BALLOON ) != FALSE )

  000bd	68 88 00 00 00	 push	 136			; 00000088H
  000c2	8b ce		 mov	 ecx, esi
  000c4	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  000c9	85 c0		 test	 eax, eax
  000cb	0f 84 d5 0a 00
	00		 je	 $L275202

; 2969 : 			nResult = 2;

  000d1	bd 02 00 00 00	 mov	 ebp, 2

; 2970 : 		else

  000d6	e9 e0 0a 00 00	 jmp	 $L275203
$L274986:

; 2036 : 				nResult = 1;
; 2037 : 			}
; 2038 : 			else
; 2039 : 				ReState();

  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?ReState@CMover@@QAEXXZ	; CMover::ReState

; 2040 : 		}
; 2041 : 		break;

  000e2	eb cc		 jmp	 SHORT $L274982
$L275005:

; 2087 : #endif // __S_ADD_RESTATE
; 2088 : 	case II_CHR_SYS_SCR_TRANSY:
; 2089 : 		{
; 2090 : 			if( DoUseItemSexChange( nPart ) == FALSE )

  000e4	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR _nPart$[esp+248]
  000eb	50		 push	 eax
  000ec	8b ce		 mov	 ecx, esi
  000ee	e8 00 00 00 00	 call	 ?DoUseItemSexChange@CMover@@QAEHH@Z ; CMover::DoUseItemSexChange
  000f3	85 c0		 test	 eax, eax

; 2091 : 			{
; 2092 : 				nResult = 1;
; 2093 : 			}
; 2094 : 			else

  000f5	74 b4		 je	 SHORT $L275200

; 2095 : 			{
; 2096 : 				if( HasBuffByIk3( IK3_TEXT_DISGUISE ) )

  000f7	6a 51		 push	 81			; 00000051H
  000f9	8b ce		 mov	 ecx, esi
  000fb	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  00100	85 c0		 test	 eax, eax
  00102	74 ac		 je	 SHORT $L274982

; 2097 : 					RemoveIk3Buffs( IK3_TEXT_DISGUISE );

  00104	6a 51		 push	 81			; 00000051H
  00106	8b ce		 mov	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs

; 2098 : 			}
; 2099 : 		}
; 2100 : 		break;

  0010d	eb a1		 jmp	 SHORT $L274982
$L275029:

; 2165 : 		}
; 2166 : #endif	// __SYS_COLLECTING
; 2167 : 	case II_CHR_SYS_SCR_SHOUTFULL15:
; 2168 : 		{
; 2169 : 			if( !IsShoutFull() )

  0010f	8b ce		 mov	 ecx, esi
  00111	e8 00 00 00 00	 call	 ?IsShoutFull@CMover@@QAEHXZ ; CMover::IsShoutFull
  00116	85 c0		 test	 eax, eax
  00118	0f 85 ad 08 00
	00		 jne	 $L287489

; 2170 : 				SetSMMode( SM_SHOUT15, pItemProp->dwCircleTime );

  0011e	8b 8b ec 01 00
	00		 mov	 ecx, DWORD PTR [ebx+492]
  00124	51		 push	 ecx
  00125	6a 04		 push	 4
  00127	8b ce		 mov	 ecx, esi
  00129	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2171 : 			else

  0012e	eb 80		 jmp	 SHORT $L274982
$L275032:

; 2172 : 				nResult = 2;
; 2173 : 		}
; 2174 : 		break;
; 2175 : 	case II_CHR_SYS_SCR_SHOUTFULL30:
; 2176 : 		{
; 2177 : 			if( !IsShoutFull() )

  00130	8b ce		 mov	 ecx, esi
  00132	e8 00 00 00 00	 call	 ?IsShoutFull@CMover@@QAEHXZ ; CMover::IsShoutFull
  00137	85 c0		 test	 eax, eax
  00139	0f 85 8c 08 00
	00		 jne	 $L287489

; 2178 : 				SetSMMode( SM_SHOUT30, pItemProp->dwCircleTime );

  0013f	8b 93 ec 01 00
	00		 mov	 edx, DWORD PTR [ebx+492]
  00145	52		 push	 edx
  00146	6a 05		 push	 5
  00148	8b ce		 mov	 ecx, esi
  0014a	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2179 : 			else

  0014f	e9 5c ff ff ff	 jmp	 $L274982
$L275041:

; 2203 : 				nResult = 2;
; 2204 : 		}
; 2205 : 		break;
; 2206 : 	case II_CHR_SYS_SCR_PSKILLFULL15:
; 2207 : 		{
; 2208 : 			if( !( IsSMMode( SM_PARTYSKILL1 ) || IsSMMode( SM_PARTYSKILL15 ) || IsSMMode( SM_PARTYSKILL30 ) ) )

  00154	8b 86 5c 03 00
	00		 mov	 eax, DWORD PTR [esi+860]
  0015a	85 c0		 test	 eax, eax
  0015c	0f 87 69 08 00
	00		 ja	 $L287489
  00162	8b 86 0c 03 00
	00		 mov	 eax, DWORD PTR [esi+780]
  00168	85 c0		 test	 eax, eax
  0016a	0f 87 5b 08 00
	00		 ja	 $L287489
  00170	8b 86 10 03 00
	00		 mov	 eax, DWORD PTR [esi+784]
  00176	85 c0		 test	 eax, eax
  00178	0f 87 4d 08 00
	00		 ja	 $L287489

; 2209 : #if __VER >= 12 // __PARSKILL1001	//12     world,core,neuz
; 2210 : 			{
; 2211 : 				SetSMMode( SM_PARTYSKILL15, pItemProp->dwCircleTime );

  0017e	8b 83 ec 01 00
	00		 mov	 eax, DWORD PTR [ebx+492]
  00184	50		 push	 eax
  00185	6a 02		 push	 2
  00187	8b ce		 mov	 ecx, esi
  00189	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2212 : 				g_DPCoreClient.SendUserPartySkill( m_idPlayer, PARTY_PARSKILL_MODE, 1000, 0, 1 );

  0018e	8b 8e 38 02 00
	00		 mov	 ecx, DWORD PTR [esi+568]
  00194	6a 01		 push	 1
  00196	6a 00		 push	 0
  00198	68 e8 03 00 00	 push	 1000			; 000003e8H
  0019d	6a 04		 push	 4
  0019f	51		 push	 ecx
  001a0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  001a5	e8 00 00 00 00	 call	 ?SendUserPartySkill@CDPCoreClient@@QAEXKHKHH@Z ; CDPCoreClient::SendUserPartySkill
  001aa	e9 01 ff ff ff	 jmp	 $L274982
$L275044:

; 2213 : 			}
; 2214 : #else	//__PARSKILL1001	//12     world,core,neuz
; 2215 : 				SetSMMode( SM_PARTYSKILL15, pItemProp->dwCircleTime );
; 2216 : #endif //__PARSKILL1001	//12     world,core,neuz
; 2217 : 			else
; 2218 : 				nResult = 2;
; 2219 : 		}
; 2220 : 		break;
; 2221 : 	case II_CHR_SYS_SCR_PSKILLFULL30:
; 2222 : 		{
; 2223 : 			if( !( IsSMMode( SM_PARTYSKILL1 ) || IsSMMode( SM_PARTYSKILL15 ) || IsSMMode( SM_PARTYSKILL30 ) ) )

  001af	8b 86 5c 03 00
	00		 mov	 eax, DWORD PTR [esi+860]
  001b5	85 c0		 test	 eax, eax
  001b7	0f 87 0e 08 00
	00		 ja	 $L287489
  001bd	8b 86 0c 03 00
	00		 mov	 eax, DWORD PTR [esi+780]
  001c3	85 c0		 test	 eax, eax
  001c5	0f 87 00 08 00
	00		 ja	 $L287489
  001cb	8b 86 10 03 00
	00		 mov	 eax, DWORD PTR [esi+784]
  001d1	85 c0		 test	 eax, eax
  001d3	0f 87 f2 07 00
	00		 ja	 $L287489

; 2224 : #if __VER >= 12 // __PARSKILL1001	//12     world,core,neuz
; 2225 : 			{
; 2226 : 				SetSMMode( SM_PARTYSKILL30, pItemProp->dwCircleTime );

  001d9	8b 93 ec 01 00
	00		 mov	 edx, DWORD PTR [ebx+492]
  001df	52		 push	 edx
  001e0	6a 03		 push	 3

; 2227 : 				g_DPCoreClient.SendUserPartySkill( m_idPlayer, PARTY_PARSKILL_MODE, 1000, 0, 1 );
; 2228 : 			}
; 2229 : #else	//__PARSKILL1001	//12     world,core,neuz
; 2230 : 				SetSMMode( SM_PARTYSKILL30, pItemProp->dwCircleTime );
; 2231 : #endif //__PARSKILL1001	//12     world,core,neuz
; 2232 : 			else

  001e2	e9 31 08 00 00	 jmp	 $L287486
$L275047:

; 2233 : 				nResult = 2;
; 2234 : 		}
; 2235 : 		break;
; 2236 : 	case II_CHR_SYS_SCR_COMMBANK15:
; 2237 : 		{
; 2238 : 			if( !IsCommBank() )

  001e7	8b ce		 mov	 ecx, esi
  001e9	e8 00 00 00 00	 call	 ?IsCommBank@CMover@@QAEHXZ ; CMover::IsCommBank
  001ee	85 c0		 test	 eax, eax
  001f0	0f 85 d5 07 00
	00		 jne	 $L287489

; 2239 : 				SetSMMode( SM_BANK15, pItemProp->dwCircleTime );

  001f6	8b 8b ec 01 00
	00		 mov	 ecx, DWORD PTR [ebx+492]
  001fc	51		 push	 ecx
  001fd	50		 push	 eax
  001fe	8b ce		 mov	 ecx, esi
  00200	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2240 : 			else

  00205	e9 a6 fe ff ff	 jmp	 $L274982
$L275050:

; 2241 : 				nResult = 2;
; 2242 : 		}
; 2243 : 		break;
; 2244 : 	case II_CHR_SYS_SCR_COMMBANK30:
; 2245 : 		{
; 2246 : 			if( !IsCommBank() )

  0020a	8b ce		 mov	 ecx, esi
  0020c	e8 00 00 00 00	 call	 ?IsCommBank@CMover@@QAEHXZ ; CMover::IsCommBank
  00211	85 c0		 test	 eax, eax
  00213	0f 85 b2 07 00
	00		 jne	 $L287489

; 2247 : 				SetSMMode( SM_BANK30, pItemProp->dwCircleTime );

  00219	8b 93 ec 01 00
	00		 mov	 edx, DWORD PTR [ebx+492]
  0021f	52		 push	 edx
  00220	6a 01		 push	 1
  00222	8b ce		 mov	 ecx, esi
  00224	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2248 : 			else

  00229	e9 82 fe ff ff	 jmp	 $L274982
$L275056:

; 2257 : 				nResult = 2;
; 2258 : 		}
; 2259 : 		break;
; 2260 : 	case II_CHR_SYS_SCR_ACTIVITION:
; 2261 : 		{
; 2262 : 			if( !( IsSMMode( SM_ACTPOINT ) ) )

  0022e	8b 86 2c 03 00
	00		 mov	 eax, DWORD PTR [esi+812]
  00234	85 c0		 test	 eax, eax
  00236	0f 87 8f 07 00
	00		 ja	 $L287489

; 2263 : 				SetSMMode( SM_ACTPOINT, pItemProp->dwCircleTime );

  0023c	8b 83 ec 01 00
	00		 mov	 eax, DWORD PTR [ebx+492]
  00242	50		 push	 eax
  00243	6a 0a		 push	 10			; 0000000aH
  00245	8b ce		 mov	 ecx, esi
  00247	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2264 : 			else

  0024c	e9 5f fe ff ff	 jmp	 $L274982
$L275062:

; 2273 : 				nResult = 2;
; 2274 : 		}
; 2275 : 		break;
; 2276 : 	case II_CHR_SYS_SCR_UPCUTSTONE:
; 2277 : 		{
; 2278 : 			if( !( IsSMMode( SM_ATTACK_UP1 ) || IsSMMode( SM_ATTACK_UP ) ) )

  00251	8b 86 60 03 00
	00		 mov	 eax, DWORD PTR [esi+864]
  00257	85 c0		 test	 eax, eax
  00259	0f 87 6c 07 00
	00		 ja	 $L287489
  0025f	8b 86 40 03 00
	00		 mov	 eax, DWORD PTR [esi+832]
  00265	85 c0		 test	 eax, eax
  00267	0f 87 5e 07 00
	00		 ja	 $L287489

; 2279 : 			{
; 2280 : 				SetSMMode( SM_ATTACK_UP, pItemProp->dwCircleTime );

  0026d	8b 8b ec 01 00
	00		 mov	 ecx, DWORD PTR [ebx+492]
  00273	51		 push	 ecx
  00274	6a 0f		 push	 15			; 0000000fH
  00276	8b ce		 mov	 ecx, esi
  00278	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2281 : 			}
; 2282 : 			else

  0027d	e9 2e fe ff ff	 jmp	 $L274982
$L287325:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  00282	3d e0 28 00 00	 cmp	 eax, 10464		; 000028e0H
  00287	0f 87 13 01 00
	00		 ja	 $L287326
  0028d	0f 84 21 07 00
	00		 je	 $L275088
  00293	2d ba 28 00 00	 sub	 eax, 10426		; 000028baH
  00298	83 f8 08	 cmp	 eax, 8
  0029b	0f 87 0a fe ff
	ff		 ja	 $L275200
  002a1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L287493[eax*4]
$L275065:

; 2283 : 				nResult = 2;
; 2284 : 		}
; 2285 : 		break;
; 2286 : #if __VER < 8 // __S8_PK
; 2287 : 	case II_SYS_SYS_SCR_FORGIVE:
; 2288 : 		if( IsPlayer() )
; 2289 : 		{
; 2290 : 			if( IsChaotic() )
; 2291 : 			{
; 2292 : 				UpgradeKarma();
; 2293 : 				((CUser*)this)->AddDefinedText( TID_GAME_GETKARMA );	//  1 						
; 2294 : 			}
; 2295 : 			else
; 2296 : 			{
; 2297 : 				//       .
; 2298 : 				((CUser*)this)->AddDefinedText( TID_GAME_NOTCHOAS );
; 2299 : 				nResult = 1;		// 1 -   .
; 2300 : 			}
; 2301 : 		}
; 2302 : 		break;
; 2303 : #endif // __VER < 8 // __S8_PK
; 2304 : 	case II_SYS_SYS_SCR_BLESSING:
; 2305 : 		{
; 2306 : 			if( !( IsSMMode( SM_REVIVAL ) ) )

  002a8	8b 86 54 03 00
	00		 mov	 eax, DWORD PTR [esi+852]
  002ae	85 c0		 test	 eax, eax
  002b0	0f 87 15 07 00
	00		 ja	 $L287489

; 2307 : 				SetSMMode( SM_REVIVAL, pItemProp->dwCircleTime );

  002b6	8b 93 ec 01 00
	00		 mov	 edx, DWORD PTR [ebx+492]
  002bc	52		 push	 edx
  002bd	6a 14		 push	 20			; 00000014H
  002bf	8b ce		 mov	 ecx, esi
  002c1	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2308 : 			else

  002c6	e9 e5 fd ff ff	 jmp	 $L274982
$L275068:

; 2309 : 				nResult = 2;					
; 2310 : 		}
; 2311 : 		break;
; 2312 : 	case II_SYS_SYS_SCR_SELPAR:
; 2313 : 		{
; 2314 : 			CParty* pParty;
; 2315 : 			pParty = g_PartyMng.GetParty( GetPartyId() );

  002cb	8b 86 18 07 00
	00		 mov	 eax, DWORD PTR [esi+1816]
  002d1	50		 push	 eax
  002d2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_PartyMng@@3VCPartyMng@@A
  002d7	e8 00 00 00 00	 call	 ?GetParty@CPartyMng@@QAEPAVCParty@@K@Z ; CPartyMng::GetParty

; 2316 : 			if( pParty )

  002dc	85 c0		 test	 eax, eax
  002de	74 1f		 je	 SHORT $L275070

; 2317 : 			{
; 2318 : 				if( pParty->m_nLevel < MAX_PARTYLEVEL )	//  

  002e0	83 b8 d0 01 00
	00 0a		 cmp	 DWORD PTR [eax+464], 10	; 0000000aH
  002e7	7d 16		 jge	 SHORT $L275070

; 2319 : 					pParty->SetPartyLevel( ((CUser*)this), 10, 180, 0 );

  002e9	6a 00		 push	 0
  002eb	68 b4 00 00 00	 push	 180			; 000000b4H
  002f0	6a 0a		 push	 10			; 0000000aH
  002f2	56		 push	 esi
  002f3	8b c8		 mov	 ecx, eax
  002f5	e8 00 00 00 00	 call	 ?SetPartyLevel@CParty@@QAEXPAVCUser@@KKK@Z ; CParty::SetPartyLevel

; 2320 : 				else

  002fa	e9 b1 fd ff ff	 jmp	 $L274982
$L275070:

; 2321 : 					nResult = 1;
; 2322 : 			}
; 2323 : 			else
; 2324 : 			{
; 2325 : 				nResult = 1;
; 2326 : 			}
; 2327 : 			if( nResult == 1 )
; 2328 : 				((CUser*)this)->AddDefinedText( TID_GAME_NTROUPEO10, "" );

  002ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00304	68 3e 0a 00 00	 push	 2622			; 00000a3eH
  00309	56		 push	 esi
  0030a	bd 01 00 00 00	 mov	 ebp, 1
  0030f	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00314	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2329 : 		}
; 2330 : 		break;

  00317	e9 94 fd ff ff	 jmp	 $L274982
$L275077:

; 2331 : 	case II_SYS_SYS_SCR_HOLY:
; 2332 : 		RemoveDebufBuffs();

  0031c	8b ce		 mov	 ecx, esi
  0031e	e8 00 00 00 00	 call	 ?RemoveDebufBuffs@CMover@@QAEXXZ ; CMover::RemoveDebufBuffs

; 2333 : 		break;

  00323	e9 88 fd ff ff	 jmp	 $L274982
$L275078:

; 2334 : 	case II_SYS_SYS_SCR_VELOCIJUMP:
; 2335 : 		{
; 2336 : 			if( !( IsSMMode( SM_VELOCIJUMP ) ) )

  00328	8b 86 58 03 00
	00		 mov	 eax, DWORD PTR [esi+856]
  0032e	85 c0		 test	 eax, eax
  00330	0f 87 95 06 00
	00		 ja	 $L287489

; 2337 : 			{
; 2338 : 				if( pItemProp->dwDestParam1 != -1 )

  00336	8b 8b 40 01 00
	00		 mov	 ecx, DWORD PTR [ebx+320]
  0033c	83 f9 ff	 cmp	 ecx, -1
  0033f	74 12		 je	 SHORT $L275080

; 2339 : 					SetDestParam( pItemProp->dwDestParam1, pItemProp->nAdjParamVal1, pItemProp->nAdjParamVal1 );

  00341	8b 83 58 01 00
	00		 mov	 eax, DWORD PTR [ebx+344]
  00347	6a 01		 push	 1
  00349	50		 push	 eax
  0034a	50		 push	 eax
  0034b	51		 push	 ecx
  0034c	8b ce		 mov	 ecx, esi
  0034e	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275080:

; 2340 : 				if( pItemProp->dwDestParam2 != -1 )

  00353	8b 8b 44 01 00
	00		 mov	 ecx, DWORD PTR [ebx+324]
  00359	83 f9 ff	 cmp	 ecx, -1
  0035c	74 12		 je	 SHORT $L275081

; 2341 : 					SetDestParam( pItemProp->dwDestParam2, pItemProp->nAdjParamVal2, pItemProp->nAdjParamVal2 );

  0035e	8b 83 5c 01 00
	00		 mov	 eax, DWORD PTR [ebx+348]
  00364	6a 01		 push	 1
  00366	50		 push	 eax
  00367	50		 push	 eax
  00368	51		 push	 ecx
  00369	8b ce		 mov	 ecx, esi
  0036b	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275081:

; 2342 : 				SetSMMode( SM_VELOCIJUMP, pItemProp->dwCircleTime );

  00370	8b 83 ec 01 00
	00		 mov	 eax, DWORD PTR [ebx+492]
  00376	50		 push	 eax
  00377	6a 15		 push	 21			; 00000015H
  00379	8b ce		 mov	 ecx, esi
  0037b	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2343 : 			}
; 2344 : 			else

  00380	e9 2b fd ff ff	 jmp	 $L274982
$L275083:

; 2345 : 			{
; 2346 : 				nResult = 2;	
; 2347 : 			}
; 2348 : 		}
; 2349 : 		break;
; 2350 : 	case II_SYS_SYS_SCR_RECCURENCE:
; 2351 : 		{
; 2352 : 			if( InitSkillExp() )

  00385	8b ce		 mov	 ecx, esi
  00387	e8 00 00 00 00	 call	 ?InitSkillExp@CMover@@QAEHXZ ; CMover::InitSkillExp
  0038c	85 c0		 test	 eax, eax
  0038e	0f 84 17 fd ff
	ff		 je	 $L275200

; 2353 : 				((CUser*)this)->AddInitSkill();

  00394	8b ce		 mov	 ecx, esi
  00396	e8 00 00 00 00	 call	 ?AddInitSkill@CUser@@QAEXXZ ; CUser::AddInitSkill

; 2354 : 			else
; 2355 : 				nResult = 1;
; 2356 : 		}
; 2357 : 		break;

  0039b	e9 10 fd ff ff	 jmp	 $L274982
$L287326:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  003a0	3d bf 67 00 00	 cmp	 eax, 26559		; 000067bfH
  003a5	0f 87 e1 04 00
	00		 ja	 $L287327
  003ab	0f 84 b7 04 00
	00		 je	 $L275053
  003b1	3d 2c 52 00 00	 cmp	 eax, 21036		; 0000522cH
  003b6	0f 87 2f 02 00
	00		 ja	 $L287328
  003bc	0f 84 f5 01 00
	00		 je	 $L275019
  003c2	3d 74 3b 00 00	 cmp	 eax, 15220		; 00003b74H
  003c7	0f 87 b7 01 00
	00		 ja	 $L287329
  003cd	0f 84 2a 01 00
	00		 je	 $L275128
  003d3	2d e3 28 00 00	 sub	 eax, 10467		; 000028e3H
  003d8	83 f8 16	 cmp	 eax, 22			; 00000016H
  003db	0f 87 ca fc ff
	ff		 ja	 $L275200
  003e1	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $L287476[eax]
  003e8	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L287494[edx*4]
$L275105:

; 2752 : 		}
; 2753 : 		break;
; 2754 : #endif // __II_SYS_SYS_SCR_GET
; 2755 : 	case II_SYS_SYS_SCR_RETURN:		// " "		
; 2756 : 		{
; 2757 : 			if( IsPlayer() )

  003ef	85 c9		 test	 ecx, ecx
  003f1	0f 84 b9 fc ff
	ff		 je	 $L274982

; 2758 : 			{
; 2759 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_RETURN ) )

  003f7	68 e5 28 00 00	 push	 10469			; 000028e5H
  003fc	6a 00		 push	 0
  003fe	8b ce		 mov	 ecx, esi
  00400	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00405	85 c0		 test	 eax, eax

; 2760 : 					nResult = 2;
; 2761 : 				else

  00407	0f 85 be 05 00
	00		 jne	 $L287489

; 2762 : 				{
; 2763 : 					CWorld* pWorld	= GetWorld();

  0040d	8b be 6c 01 00
	00		 mov	 edi, DWORD PTR [esi+364]

; 2764 : 					if( !pWorld )

  00413	85 ff		 test	 edi, edi

; 2765 : 						return 0;

  00415	74 55		 je	 SHORT $L287490

; 2766 : 
; 2767 : 					D3DXVECTOR3 vPos = GetPos();

  00417	8d 44 24 18	 lea	 eax, DWORD PTR _vPos$275111[esp+252]
  0041b	50		 push	 eax
  0041c	8b ce		 mov	 ecx, esi
  0041e	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos

; 2768 : 					// /           '       .'  
; 2769 : 					if( pWorld->GetID() == WI_WORLD_GUILDWAR || pWorld->GetID() == WI_WORLD_KEBARAS || prj.IsGuildQuestRegion( vPos ) )

  00423	8b 3f		 mov	 edi, DWORD PTR [edi]
  00425	81 ff ca 00 00
	00		 cmp	 edi, 202		; 000000caH
  0042b	0f 84 b9 00 00
	00		 je	 $L275114
  00431	83 ff 02	 cmp	 edi, 2
  00434	0f 84 b0 00 00
	00		 je	 $L275114
  0043a	8d 4c 24 18	 lea	 ecx, DWORD PTR _vPos$275111[esp+252]
  0043e	51		 push	 ecx
  0043f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00444	e8 00 00 00 00	 call	 ?IsGuildQuestRegion@CProject@@QAEHABUD3DXVECTOR3@@@Z ; CProject::IsGuildQuestRegion
  00449	85 c0		 test	 eax, eax
  0044b	0f 85 99 00 00
	00		 jne	 $L275114

; 2773 : 					}
; 2774 : 
; 2775 : #if __VER >= 11 // __GUILD_COMBAT_1TO1
; 2776 : 					if( g_GuildCombat1to1Mng.IsPossibleUser( (CUser*)this ) )

  00451	56		 push	 esi
  00452	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  00457	e8 00 00 00 00	 call	 ?IsPossibleUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::IsPossibleUser
  0045c	85 c0		 test	 eax, eax

; 2777 : 					{
; 2778 : 						((CUser*) this)->AddDefinedText( TID_GAME_LIMITZONE_USE );

  0045e	8b ce		 mov	 ecx, esi
  00460	74 11		 je	 SHORT $L275117
  00462	68 68 0a 00 00	 push	 2664			; 00000a68H
  00467	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L287490:

; 2779 : 						return 0;

  0046c	33 c0		 xor	 eax, eax
  0046e	e9 4a 07 00 00	 jmp	 $L274975
$L275117:

; 2780 : 					}
; 2781 : #endif // __GUILD_COMBAT_1TO1
; 2782 : 
; 2783 : 					((CUser*) this)->SetReturnPos( vPos );

  00473	8d 54 24 18	 lea	 edx, DWORD PTR _vPos$275111[esp+252]
  00477	52		 push	 edx
  00478	e8 00 00 00 00	 call	 ?SetReturnPos@CUser@@QAEXABUD3DXVECTOR3@@@Z ; CUser::SetReturnPos

; 2784 : 
; 2785 : 					//1.  
; 2786 : 					DoApplySkill( (CCtrl*)this, pItemProp, NULL );

  0047d	6a 00		 push	 0
  0047f	6a 00		 push	 0
  00481	6a 00		 push	 0
  00483	6a 00		 push	 0
  00485	6a 00		 push	 0
  00487	53		 push	 ebx
  00488	56		 push	 esi
  00489	8b ce		 mov	 ecx, esi
  0048b	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill

; 2787 : 					//2.    
; 2788 : 					LPCTSTR lpszKey = ((CUser*)this)->m_lpszVillage;

  00490	8b 86 d4 95 00
	00		 mov	 eax, DWORD PTR [esi+38356]

; 2789 : 					if( lpszKey )

  00496	85 c0		 test	 eax, eax
  00498	74 3e		 je	 SHORT $L275123

; 2790 : 					{
; 2791 : 						PRegionElem pRgnElem = g_WorldMng.GetRevivalPos( GetWorld()->GetID(), lpszKey );

  0049a	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  004a0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004a2	50		 push	 eax
  004a3	51		 push	 ecx
  004a4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_WorldMng@@3VCWorldMng@@A
  004a9	e8 00 00 00 00	 call	 ?GetRevivalPos@CWorldMng@@QAEPAUREGIONELEM@@KPBD@Z ; CWorldMng::GetRevivalPos

; 2792 : 						if( pRgnElem )

  004ae	85 c0		 test	 eax, eax
  004b0	0f 84 fa fb ff
	ff		 je	 $L274982

; 2793 : 							REPLACE( g_uIdofMulti, pRgnElem->m_dwWorldId, pRgnElem->m_vPos, REPLACE_NORMAL, nRevivalLayer );

  004b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_uIdofMulti@@3KA ; g_uIdofMulti
  004bc	6a 00		 push	 0
  004be	6a 00		 push	 0
  004c0	8d 50 10	 lea	 edx, DWORD PTR [eax+16]
  004c3	8b 80 c0 02 00
	00		 mov	 eax, DWORD PTR [eax+704]
  004c9	52		 push	 edx
  004ca	50		 push	 eax
  004cb	51		 push	 ecx
  004cc	8b ce		 mov	 ecx, esi
  004ce	e8 00 00 00 00	 call	 ?Replace@CMover@@QAEHKKAAUD3DXVECTOR3@@W4REPLACE_TYPE@@H@Z ; CMover::Replace

; 2794 : 					}
; 2795 : 					else

  004d3	e9 d8 fb ff ff	 jmp	 $L274982
$L275123:

; 2796 : 					{
; 2797 : 						Error( "II_SYS_SYS_SCR_RETURN selected village is NULL\n" );

  004d8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DA@GIPACFEO@II_SYS_SYS_SCR_RETURN?5selected?5v@
  004dd	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  004e2	83 c4 04	 add	 esp, 4
  004e5	e9 c6 fb ff ff	 jmp	 $L274982
$L275114:

; 2770 : 					{			
; 2771 : 						((CUser*) this)->AddDefinedText( TID_GAME_LIMITZONE_USE );

  004ea	68 68 0a 00 00	 push	 2664			; 00000a68H
  004ef	8b ce		 mov	 ecx, esi
  004f1	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 2772 : 						return 0;

  004f6	33 c0		 xor	 eax, eax
  004f8	e9 c0 06 00 00	 jmp	 $L274975
$L275128:

; 2798 : 					}
; 2799 : 				}
; 2800 : 			}
; 2801 : 		}
; 2802 : 		break;
; 2803 : 	case II_SYS_SYS_SCR_CUSTODY2:
; 2804 : 		{
; 2805 : 			CMover* pMover	= (CMover*)CreateObj( D3DDEVICE, OT_MOVER, MI_INFO_PENG );

  004fd	6a 01		 push	 1
  004ff	68 c8 00 00 00	 push	 200			; 000000c8H
  00504	6a 05		 push	 5
  00506	6a 00		 push	 0
  00508	e8 00 00 00 00	 call	 ?CreateObj@@YAPAVCObj@@PAUIDirect3DDevice9@@KKH@Z ; CreateObj
  0050d	83 c4 10	 add	 esp, 16			; 00000010H
  00510	8b f8		 mov	 edi, eax

; 2806 : 			lstrcpy( pMover->m_szCharacterKey, "MaFl_InstantBank" );

  00512	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@KDNJAMCD@MaFl_InstantBank?$AA@
  00517	8d 97 4c 06 00
	00		 lea	 edx, DWORD PTR [edi+1612]
  0051d	52		 push	 edx
  0051e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 2807 : 			pMover->InitNPCProperty();

  00524	8b cf		 mov	 ecx, edi
  00526	e8 00 00 00 00	 call	 ?InitNPCProperty@CMover@@QAEXXZ ; CMover::InitNPCProperty

; 2808 : 			pMover->InitCharacter( pMover->GetCharacter() );

  0052b	8b cf		 mov	 ecx, edi
  0052d	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  00532	50		 push	 eax
  00533	8b cf		 mov	 ecx, edi
  00535	e8 00 00 00 00	 call	 ?InitCharacter@CMover@@QAEXPAUtagCHARACTER@@@Z ; CMover::InitCharacter

; 2809 : 			pMover->SetPos( GetPos() );

  0053a	8d 44 24 24	 lea	 eax, DWORD PTR $T287324[esp+252]
  0053e	50		 push	 eax
  0053f	8b ce		 mov	 ecx, esi
  00541	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  00546	50		 push	 eax
  00547	8b cf		 mov	 ecx, edi
  00549	e8 00 00 00 00	 call	 ?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z ; CObj::SetPos

; 2810 : 			pMover->InitMotion( MTI_STAND );

  0054e	8b 17		 mov	 edx, DWORD PTR [edi]
  00550	6a 00		 push	 0
  00552	8b cf		 mov	 ecx, edi
  00554	ff 52 08	 call	 DWORD PTR [edx+8]

; 2811 : 			pMover->UpdateLocalMatrix();

  00557	8b cf		 mov	 ecx, edi
  00559	e8 00 00 00 00	 call	 ?UpdateLocalMatrix@CObj@@QAEXXZ ; CObj::UpdateLocalMatrix

; 2812 : 			pMover->m_dwTickCreated		= GetTickCount();

  0055e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00564	89 87 d4 0e 00
	00		 mov	 DWORD PTR [edi+3796], eax

; 2813 : 			GetWorld()->ADDOBJ( pMover, TRUE, GetLayer() );

  0056a	8b 86 b8 01 00
	00		 mov	 eax, DWORD PTR [esi+440]
  00570	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00576	50		 push	 eax
  00577	6a 01		 push	 1
  00579	57		 push	 edi
  0057a	e8 00 00 00 00	 call	 ?AddObj@CWorld@@QAEHPAVCObj@@HH@Z ; CWorld::AddObj

; 2814 : 			break;

  0057f	e9 2c fb ff ff	 jmp	 $L274982
$L287329:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  00584	2d 28 52 00 00	 sub	 eax, 21032		; 00005228H
  00589	83 f8 03	 cmp	 eax, 3
  0058c	0f 87 19 fb ff
	ff		 ja	 $L275200
  00592	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L287495[eax*4]
$L275098:

; 2692 : 			{
; 2693 : 				DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 2694 : 			}
; 2695 : 		}
; 2696 : 		break;
; 2697 : #endif	//__PROTECT_AWAKE
; 2698 : 		//	mulcom	END100405	  
; 2699 : 
; 2700 : 
; 2701 : #if __VER >= 9	// __PET_0410
; 2702 : 	case II_SYS_SYS_SCR_PET_TONIC_A:
; 2703 : 	case II_SYS_SYS_SCR_PET_TONIC_B:
; 2704 : #if __VER >= 12 // __PET_0519
; 2705 : 		nResult		= DoUseItemPetTonic( pItemElem );	//   

  00599	57		 push	 edi
  0059a	8b ce		 mov	 ecx, esi
  0059c	e8 00 00 00 00	 call	 ?DoUseItemPetTonic@CMover@@AAEHPAVCItemElem@@@Z ; CMover::DoUseItemPetTonic
  005a1	8b e8		 mov	 ebp, eax

; 2706 : 		break;

  005a3	e9 08 fb ff ff	 jmp	 $L274982
$L275099:

; 2707 : #else	// __PET_0519
; 2708 : 		if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_PET_TONIC_A ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_PET_TONIC_B ) )
; 2709 : 			nResult = 2;
; 2710 : 		else
; 2711 : 			DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 2712 : 		break;
; 2713 : #endif	// __PET_0519
; 2714 : 	case II_SYS_SYS_SCR_PET_FEED_POCKET:
; 2715 : 		{
; 2716 : 			nResult = DoUseItemFeedPocket( pItemElem );

  005a8	57		 push	 edi
  005a9	8b ce		 mov	 ecx, esi
  005ab	e8 00 00 00 00	 call	 ?DoUseItemFeedPocket@CMover@@QAEHPAVCItemElem@@@Z ; CMover::DoUseItemFeedPocket
  005b0	8b e8		 mov	 ebp, eax

; 2717 : 			break;

  005b2	e9 f9 fa ff ff	 jmp	 $L274982
$L275019:

; 2135 : 		}
; 2136 : 	case II_SYS_SYS_SCR_PET_HATCH:
; 2137 : 		{
; 2138 : 			CPet* pPet	= GetPet();

  005b7	8b ce		 mov	 ecx, esi
  005b9	e8 00 00 00 00	 call	 ?GetPet@CMover@@QAEPAVCPet@@XZ ; CMover::GetPet

; 2139 : 			if( pPet == NULL )

  005be	85 c0		 test	 eax, eax
  005c0	75 0c		 jne	 SHORT $L275021

; 2140 : 			{
; 2141 : 				( (CUser*)this )->AddDefinedText( TID_GAME_PET_NOT_FOUND );

  005c2	68 8d 0c 00 00	 push	 3213			; 00000c8dH
  005c7	8b ce		 mov	 ecx, esi

; 2142 : 				nResult	= 1;
; 2143 : 				break;

  005c9	e9 d8 fa ff ff	 jmp	 $L287491
$L275021:

; 2144 : 			}
; 2145 : 			if( pPet->GetLevel() != PL_EGG )

  005ce	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  005d1	84 c9		 test	 cl, cl

; 2146 : 			{
; 2147 : 				( (CUser*)this )->AddDefinedText( TID_GAME_PET_4EGG );

  005d3	8b ce		 mov	 ecx, esi
  005d5	74 0a		 je	 SHORT $L275023
  005d7	68 91 0c 00 00	 push	 3217			; 00000c91H

; 2148 : 				nResult	= 1;
; 2149 : 				break;

  005dc	e9 c5 fa ff ff	 jmp	 $L287491
$L275023:

; 2150 : 			}
; 2151 : 			PetLevelup();

  005e1	e8 00 00 00 00	 call	 ?PetLevelup@CMover@@QAEXXZ ; CMover::PetLevelup

; 2152 : 			break;

  005e6	e9 c5 fa ff ff	 jmp	 $L274982
$L287328:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  005eb	3d 55 67 00 00	 cmp	 eax, 26453		; 00006755H
  005f0	0f 87 d5 00 00
	00		 ja	 $L287330
  005f6	0f 84 b4 00 00
	00		 je	 $L275025
  005fc	2d 58 66 00 00	 sub	 eax, 26200		; 00006658H
  00601	83 f8 11	 cmp	 eax, 17			; 00000011H
  00604	0f 87 a1 fa ff
	ff		 ja	 $L275200
  0060a	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L287477[eax]
  00611	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L287496[ecx*4]
$L275133:

; 2815 : 		}
; 2816 : 	
; 2817 : 	case II_SYS_SYS_SCR_FRIENDSUMMON_A:
; 2818 : 	case II_SYS_SYS_SCR_FRIENDSUMMON_B:
; 2819 : 		{
; 2820 : 			int nState = GetSummonState();

  00618	8b ce		 mov	 ecx, esi
  0061a	e8 00 00 00 00	 call	 ?GetSummonState@CMover@@QAEHXZ ; CMover::GetSummonState

; 2821 : 			if( nState != 0 )

  0061f	85 c0		 test	 eax, eax
  00621	74 65		 je	 SHORT $L275135

; 2822 : 			{
; 2823 : 				DWORD dwMsgId = 0;

  00623	33 c9		 xor	 ecx, ecx

; 2824 : 				if( nState == 1 )	// 

  00625	83 f8 01	 cmp	 eax, 1
  00628	75 07		 jne	 SHORT $L275137

; 2825 : 					dwMsgId = TID_GAME_TRADE_NOTUSE;

  0062a	b9 0d 0b 00 00	 mov	 ecx, 2829		; 00000b0dH

; 2826 : 				else if( nState == 2 ) // 

  0062f	eb 2e		 jmp	 SHORT $L275145
$L275137:
  00631	83 f8 02	 cmp	 eax, 2
  00634	75 07		 jne	 SHORT $L275139

; 2827 : 					dwMsgId = TID_GAME_DIE_NOTUSE;

  00636	b9 0f 0b 00 00	 mov	 ecx, 2831		; 00000b0fH

; 2828 : 				else if( nState == 3 ) //  

  0063b	eb 22		 jmp	 SHORT $L275145
$L275139:
  0063d	83 f8 03	 cmp	 eax, 3
  00640	75 07		 jne	 SHORT $L275141

; 2829 : 					dwMsgId = TID_GAME_VENDOR_NOTUSE;

  00642	b9 11 0b 00 00	 mov	 ecx, 2833		; 00000b11H

; 2830 : 				else if( nState == 4 ) // 

  00647	eb 16		 jmp	 SHORT $L275145
$L275141:
  00649	83 f8 04	 cmp	 eax, 4
  0064c	75 07		 jne	 SHORT $L275143

; 2831 : 					dwMsgId = TID_GAME_ATTACK_NOTUSE;

  0064e	b9 13 0b 00 00	 mov	 ecx, 2835		; 00000b13H

; 2832 : 				else if( nState == 5 ) // 

  00653	eb 0a		 jmp	 SHORT $L275145
$L275143:
  00655	83 f8 05	 cmp	 eax, 5
  00658	75 05		 jne	 SHORT $L275145

; 2833 : 					dwMsgId = TID_GAME_FLY_NOTUSE;

  0065a	b9 15 0b 00 00	 mov	 ecx, 2837		; 00000b15H
$L275145:

; 2834 : 				
; 2835 : 				((CUser*) this)->AddDefinedText( TID_GAME_STATE_NOTUSE , "\"%s\"", prj.GetText( dwMsgId ) );

  0065f	51		 push	 ecx
$L287484:
  00660	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00665	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0066a	50		 push	 eax
  0066b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00670	68 17 0b 00 00	 push	 2839			; 00000b17H
  00675	56		 push	 esi
  00676	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0067b	83 c4 10	 add	 esp, 16			; 00000010H

; 2846 : 			}
; 2847 : 			nResult = 99;

  0067e	bd 63 00 00 00	 mov	 ebp, 99			; 00000063H

; 2848 : 		}
; 2849 : 		break;

  00683	e9 28 fa ff ff	 jmp	 $L274982
$L275135:

; 2836 : 			}
; 2837 : #if __VER >= 11 // __GUILD_COMBAT_1TO1
; 2838 : 			else if( g_GuildCombat1to1Mng.IsPossibleUser( (CUser*)this ) )

  00688	56		 push	 esi
  00689	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_GuildCombat1to1Mng@@3VCGuildCombat1to1Mng@@A
  0068e	e8 00 00 00 00	 call	 ?IsPossibleUser@CGuildCombat1to1Mng@@QAEHPAVCUser@@@Z ; CGuildCombat1to1Mng::IsPossibleUser
  00693	85 c0		 test	 eax, eax
  00695	74 07		 je	 SHORT $L275149

; 2839 : 			{
; 2840 : 				((CUser*) this)->AddDefinedText( TID_GAME_STATE_NOTUSE , "\"%s\"", prj.GetText( TID_GAME_ATTACK_NOTUSE ) );

  00697	68 13 0b 00 00	 push	 2835			; 00000b13H

; 2841 : 			}
; 2842 : #endif // __GUILD_COMBAT_1TO1
; 2843 : 			else

  0069c	eb c2		 jmp	 SHORT $L287484
$L275149:

; 2844 : 			{
; 2845 : 				((CUser*) this)->AddSummonFriendUse( pItemElem );	

  0069e	57		 push	 edi
  0069f	8b ce		 mov	 ecx, esi
  006a1	e8 00 00 00 00	 call	 ?AddSummonFriendUse@CUser@@QAEXPAVCItemElem@@@Z ; CUser::AddSummonFriendUse

; 2846 : 			}
; 2847 : 			nResult = 99;

  006a6	bd 63 00 00 00	 mov	 ebp, 99			; 00000063H

; 2848 : 		}
; 2849 : 		break;

  006ab	e9 00 fa ff ff	 jmp	 $L274982
$L275025:

; 2153 : 		}
; 2154 : #endif	// __PET_0410
; 2155 : #if __VER >= 11 // __SYS_COLLECTING
; 2156 : 	case II_GEN_TOO_COL_NORMALBATTERY:
; 2157 : 		{
; 2158 : 			CUser* pThis	= (CUser*)this;
; 2159 : 			if( !pThis->DoUseItemBattery() )

  006b0	8b ce		 mov	 ecx, esi
  006b2	e8 00 00 00 00	 call	 ?DoUseItemBattery@CUser@@QAEHXZ ; CUser::DoUseItemBattery
  006b7	85 c0		 test	 eax, eax
  006b9	0f 85 f1 f9 ff
	ff		 jne	 $L274982

; 2160 : 			{
; 2161 : 				pThis->AddDefinedText( TID_GAME_CANT_USE_BATTERY );

  006bf	68 31 0d 00 00	 push	 3377			; 00000d31H
  006c4	8b ce		 mov	 ecx, esi

; 2162 : 				nResult	= 1;
; 2163 : 			}
; 2164 : 			break;

  006c6	e9 db f9 ff ff	 jmp	 $L287491
$L287330:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  006cb	2d 58 67 00 00	 sub	 eax, 26456		; 00006758H
  006d0	74 36		 je	 SHORT $L275153
  006d2	83 e8 11	 sub	 eax, 17			; 00000011H
  006d5	0f 84 d9 02 00
	00		 je	 $L275088
  006db	83 e8 54	 sub	 eax, 84			; 00000054H
  006de	0f 85 c7 f9 ff
	ff		 jne	 $L275200

; 2180 : 				nResult = 2;
; 2181 : 		}
; 2182 : 		break;
; 2183 : 	case II_CHR_SYS_SCR_SHOUTFULL001:
; 2184 : 		{
; 2185 : 			if( !IsShoutFull() )

  006e4	8b ce		 mov	 ecx, esi
  006e6	e8 00 00 00 00	 call	 ?IsShoutFull@CMover@@QAEHXZ ; CMover::IsShoutFull
  006eb	85 c0		 test	 eax, eax
  006ed	0f 85 d8 02 00
	00		 jne	 $L287489

; 2186 : 				SetSMMode( SM_SHOUT001, pItemProp->dwCircleTime );

  006f3	8b 93 ec 01 00
	00		 mov	 edx, DWORD PTR [ebx+492]
  006f9	52		 push	 edx
  006fa	6a 18		 push	 24			; 00000018H
  006fc	8b ce		 mov	 ecx, esi
  006fe	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2187 : 			else

  00703	e9 a8 f9 ff ff	 jmp	 $L274982
$L275153:

; 2850 : 
; 2851 : #if __VER >= 11 // __MA_VER11_02	//    '' 
; 2852 : 	case II_SYS_SYS_SCR_PERIN:
; 2853 : 		{
; 2854 : 			int nState = GetSummonState();

  00708	8b ce		 mov	 ecx, esi
  0070a	e8 00 00 00 00	 call	 ?GetSummonState@CMover@@QAEHXZ ; CMover::GetSummonState

; 2855 : 			if( nState != 0 )

  0070f	85 c0		 test	 eax, eax
  00711	74 65		 je	 SHORT $L275155

; 2856 : 			{
; 2857 : 				DWORD dwMsgId = 0;

  00713	33 c9		 xor	 ecx, ecx

; 2858 : 				if( nState == 1 )	// 

  00715	83 f8 01	 cmp	 eax, 1
  00718	75 07		 jne	 SHORT $L275157

; 2859 : 					dwMsgId = TID_GAME_TRADE_NOTUSE;

  0071a	b9 0d 0b 00 00	 mov	 ecx, 2829		; 00000b0dH

; 2860 : 				else if( nState == 2 ) // 

  0071f	eb 2e		 jmp	 SHORT $L275165
$L275157:
  00721	83 f8 02	 cmp	 eax, 2
  00724	75 07		 jne	 SHORT $L275159

; 2861 : 					dwMsgId = TID_GAME_DIE_NOTUSE;

  00726	b9 0f 0b 00 00	 mov	 ecx, 2831		; 00000b0fH

; 2862 : 				else if( nState == 3 ) //  

  0072b	eb 22		 jmp	 SHORT $L275165
$L275159:
  0072d	83 f8 03	 cmp	 eax, 3
  00730	75 07		 jne	 SHORT $L275161

; 2863 : 					dwMsgId = TID_GAME_VENDOR_NOTUSE;

  00732	b9 11 0b 00 00	 mov	 ecx, 2833		; 00000b11H

; 2864 : 				else if( nState == 4 ) // 

  00737	eb 16		 jmp	 SHORT $L275165
$L275161:
  00739	83 f8 04	 cmp	 eax, 4
  0073c	75 07		 jne	 SHORT $L275163

; 2865 : 					dwMsgId = TID_GAME_ATTACK_NOTUSE;

  0073e	b9 13 0b 00 00	 mov	 ecx, 2835		; 00000b13H

; 2866 : 				else if( nState == 5 ) // 

  00743	eb 0a		 jmp	 SHORT $L275165
$L275163:
  00745	83 f8 05	 cmp	 eax, 5
  00748	75 05		 jne	 SHORT $L275165

; 2867 : 					dwMsgId = TID_GAME_FLY_NOTUSE;

  0074a	b9 15 0b 00 00	 mov	 ecx, 2837		; 00000b15H
$L275165:

; 2868 : 				
; 2869 : 				((CUser*) this)->AddDefinedText( TID_GAME_STATE_NOTUSE , "\"%s\"", prj.GetText( dwMsgId ) );

  0074f	51		 push	 ecx
  00750	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00755	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  0075a	50		 push	 eax
  0075b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00760	68 17 0b 00 00	 push	 2839			; 00000b17H
  00765	56		 push	 esi
  00766	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0076b	83 c4 10	 add	 esp, 16			; 00000010H

; 2870 : 				nResult = 99;

  0076e	bd 63 00 00 00	 mov	 ebp, 99			; 00000063H

; 2871 : 			}
; 2872 : 			else

  00773	e9 38 f9 ff ff	 jmp	 $L274982
$L275155:

; 2873 : 			{
; 2874 : 				float	fTmpGold = (float)( ((CUser*) this)->GetGold() );

  00778	db 86 84 16 00
	00		 fild	 DWORD PTR [esi+5764]
  0077e	d9 54 24 10	 fst	 DWORD PTR _fTmpGold$275168[esp+252]

; 2875 : 				if( fTmpGold >= 2000000000 || fTmpGold < 0  )

  00782	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@4eee6b28
  00788	df e0		 fnstsw	 ax
  0078a	f6 c4 01	 test	 ah, 1
  0078d	0f 84 b4 00 00
	00		 je	 $L275172
  00793	d9 44 24 10	 fld	 DWORD PTR _fTmpGold$275168[esp+252]
  00797	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@00000000
  0079d	df e0		 fnstsw	 ax
  0079f	f6 c4 05	 test	 ah, 5
  007a2	0f 8b 9f 00 00
	00		 jnp	 $L275172

; 2879 : 				}
; 2880 : 				else
; 2881 : 				{
; 2882 : 					((CUser*) this)->AddGold(100000000,true);

  007a8	6a 01		 push	 1
  007aa	68 00 e1 f5 05	 push	 100000000		; 05f5e100H
  007af	8b ce		 mov	 ecx, esi
  007b1	e8 00 00 00 00	 call	 ?AddGold@CMover@@QAEHHH@Z ; CMover::AddGold

; 2883 : 
; 2884 : 					// chipi080711 -  
; 2885 : 					LogItemInfo aLogItem;

  007b6	8d 4c 24 30	 lea	 ecx, DWORD PTR _aLogItem$275176[esp+252]
  007ba	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 2886 : 					aLogItem.Action = "C";
; 2887 : 					aLogItem.SendName = ((CUser*) this)->GetName();

  007bf	6a 00		 push	 0
  007c1	8b ce		 mov	 ecx, esi
  007c3	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _aLogItem$275176[esp+256], OFFSET FLAT:??_C@_01GFHCPBMG@C?$AA@
  007cb	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 2888 : 					aLogItem.RecvName = "USE_PERIN";
; 2889 : 					aLogItem.WorldId = ((CUser*) this)->GetWorld()->GetID();
; 2890 : 					aLogItem.Gold = (DWORD)( fTmpGold );

  007d0	d9 44 24 10	 fld	 DWORD PTR _fTmpGold$275168[esp+252]
  007d4	89 44 24 34	 mov	 DWORD PTR _aLogItem$275176[esp+256], eax
  007d8	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  007de	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _aLogItem$275176[esp+260], OFFSET FLAT:??_C@_09FAFPDOMC@USE_PERIN?$AA@
  007e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  007e8	89 4c 24 3c	 mov	 DWORD PTR _aLogItem$275176[esp+264], ecx
  007ec	e8 00 00 00 00	 call	 __ftol2

; 2891 : 					aLogItem.Gold2 = ((CUser*) this)->GetGold();

  007f1	8b 8e 84 16 00
	00		 mov	 ecx, DWORD PTR [esi+5764]

; 2892 : 					aLogItem.Gold_1  = ((CUser*) this)->GetGold() - static_cast<int>(fTmpGold);
; 2893 : 					//aLogItem.ItemName = pItemElem->GetName();
; 2894 : 					_stprintf( aLogItem.szItemName, "%d", pItemProp->dwID );

  007f7	8b 13		 mov	 edx, DWORD PTR [ebx]
  007f9	52		 push	 edx
  007fa	89 4c 24 48	 mov	 DWORD PTR _aLogItem$275176[esp+276], ecx
  007fe	2b c8		 sub	 ecx, eax
  00800	89 44 24 44	 mov	 DWORD PTR _aLogItem$275176[esp+272], eax
  00804	8d 44 24 58	 lea	 eax, DWORD PTR _aLogItem$275176[esp+292]
  00808	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0080d	50		 push	 eax
  0080e	89 8c 24 88 00
	00 00		 mov	 DWORD PTR _aLogItem$275176[esp+340], ecx
  00815	e8 00 00 00 00	 call	 _sprintf

; 2895 : 					aLogItem.itemNumber = 1;
; 2896 : 					aLogItem.ItemNo = pItemElem->GetSerialNumber();

  0081a	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  0081d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2897 : 					g_DPSrvr.OnLogItem( aLogItem );

  00820	6a 00		 push	 0
  00822	6a 00		 push	 0
  00824	8d 54 24 38	 lea	 edx, DWORD PTR _aLogItem$275176[esp+260]
  00828	89 4c 24 50	 mov	 DWORD PTR _aLogItem$275176[esp+284], ecx
  0082c	52		 push	 edx
  0082d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  00832	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR _aLogItem$275176[esp+332], 1
  0083d	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 2898 : 				}
; 2899 : 			}
; 2900 : 		}
; 2901 : 		break;

  00842	e9 69 f8 ff ff	 jmp	 $L274982
$L275172:

; 2876 : 				{
; 2877 : 					((CUser*) this)->AddDiagText( prj.GetText(TID_GAME_TOOMANYMONEY_USE_PERIN) );

  00847	68 8c 0d 00 00	 push	 3468			; 00000d8cH
  0084c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00851	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  00856	50		 push	 eax
  00857	8b ce		 mov	 ecx, esi
  00859	e8 00 00 00 00	 call	 ?AddDiagText@CUser@@QAEXPBD@Z ; CUser::AddDiagText

; 2878 : 					return 99;

  0085e	b8 63 00 00 00	 mov	 eax, 99			; 00000063H
  00863	e9 55 03 00 00	 jmp	 $L274975
$L275053:

; 2249 : 				nResult = 2;
; 2250 : 		}
; 2251 : 		break;
; 2252 : 	case II_CHR_SYS_SCR_COMMBANK001:
; 2253 : 		{
; 2254 : 			if( !IsCommBank() )

  00868	8b ce		 mov	 ecx, esi
  0086a	e8 00 00 00 00	 call	 ?IsCommBank@CMover@@QAEHXZ ; CMover::IsCommBank
  0086f	85 c0		 test	 eax, eax
  00871	0f 85 54 01 00
	00		 jne	 $L287489

; 2255 : 				SetSMMode( SM_BANK001, pItemProp->dwCircleTime );

  00877	8b 83 ec 01 00
	00		 mov	 eax, DWORD PTR [ebx+492]
  0087d	50		 push	 eax
  0087e	6a 19		 push	 25			; 00000019H
  00880	8b ce		 mov	 ecx, esi
  00882	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2256 : 			else

  00887	e9 24 f8 ff ff	 jmp	 $L274982
$L287327:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  0088c	3d c7 75 00 00	 cmp	 eax, 30151		; 000075c7H
  00891	0f 87 34 02 00
	00		 ja	 $L287331
  00897	0f 84 13 02 00
	00		 je	 $L274989
  0089d	3d 49 75 00 00	 cmp	 eax, 30025		; 00007549H
  008a2	0f 87 2d 01 00
	00		 ja	 $L287332
  008a8	0f 84 06 01 00
	00		 je	 $L275088
  008ae	3d 3b 75 00 00	 cmp	 eax, 30011		; 0000753bH
  008b3	0f 87 eb 00 00
	00		 ja	 $L287333
  008b9	0f 84 f5 00 00
	00		 je	 $L275088
  008bf	3d c2 67 00 00	 cmp	 eax, 26562		; 000067c2H
  008c4	74 16		 je	 SHORT $L275009
  008c6	3d 51 69 00 00	 cmp	 eax, 26961		; 00006951H
  008cb	0f 85 da f7 ff
	ff		 jne	 $L275200

; 2680 : 				DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 2681 : 		}
; 2682 : 		break;
; 2683 : 		//	mulcom	BEGIN100405	  
; 2684 : #ifdef	__PROTECT_AWAKE
; 2685 : 	case	II_SYS_SYS_SCR_AWAKESAFE:
; 2686 : 		{
; 2687 : 			if( HasBuff( BUFF_ITEM, (WORD)( pItemProp->dwID ) ) )

  008d1	33 c9		 xor	 ecx, ecx
  008d3	66 8b 0b	 mov	 cx, WORD PTR [ebx]
  008d6	51		 push	 ecx

; 2688 : 			{
; 2689 : 				nResult = 2;
; 2690 : 			}
; 2691 : 			else

  008d7	e9 de 00 00 00	 jmp	 $L287488
$L275009:

; 2101 : #if __VER >= 9	// __PET_0410
; 2102 : 	case II_SYS_SYS_SCR_PET_LIFE:
; 2103 : 	case II_SYS_SYS_SCR_PET_LIFE02:
; 2104 : 		{
; 2105 : 			CPet* pPet	= GetPet();

  008dc	8b ce		 mov	 ecx, esi
  008de	e8 00 00 00 00	 call	 ?GetPet@CMover@@QAEPAVCPet@@XZ ; CMover::GetPet
  008e3	8b f8		 mov	 edi, eax

; 2106 : 			if( pPet == NULL )

  008e5	85 ff		 test	 edi, edi
  008e7	75 0c		 jne	 SHORT $L275011

; 2107 : 			{
; 2108 : 				( (CUser*)this )->AddDefinedText( TID_GAME_PET_NOT_FOUND );

  008e9	68 8d 0c 00 00	 push	 3213			; 00000c8dH
  008ee	8b ce		 mov	 ecx, esi

; 2109 : 				nResult	= 1;
; 2110 : 				break;

  008f0	e9 b1 f7 ff ff	 jmp	 $L287491
$L275011:

; 2111 : 			}
; 2112 : 
; 2113 : 			if( pPet->GetLevel() == PL_EGG )

  008f5	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  008f8	84 c0		 test	 al, al
  008fa	75 0c		 jne	 SHORT $L275013

; 2114 : 			{
; 2115 : 				( (CUser*)this )->AddDefinedText( TID_GAME_PET_CANT_USE_TO_EGG );

  008fc	68 de 0c 00 00	 push	 3294			; 00000cdeH
  00901	8b ce		 mov	 ecx, esi

; 2116 : 				nResult	= 1;
; 2117 : 				break;

  00903	e9 9e f7 ff ff	 jmp	 $L287491
$L275013:

; 2118 : 			}
; 2119 : 			
; 2120 : 			if( pPet->GetLife() >= MAX_PET_LIFE )

  00908	8b cf		 mov	 ecx, edi
  0090a	e8 00 00 00 00	 call	 ?GetLife@CPet@@QAEGXZ	; CPet::GetLife
  0090f	66 3d 63 00	 cmp	 ax, 99			; 00000063H

; 2121 : 			{
; 2122 : 				nResult	= 1;
; 2123 : 				break;

  00913	0f 83 92 f7 ff
	ff		 jae	 $L275200

; 2124 : 			}
; 2125 : 
; 2126 : 			WORD wLife	= pPet->GetLife();

  00919	8b cf		 mov	 ecx, edi
  0091b	e8 00 00 00 00	 call	 ?GetLife@CPet@@QAEGXZ	; CPet::GetLife
  00920	8b e8		 mov	 ebp, eax

; 2127 : 			wLife	+= ( pItemProp->dwID == II_SYS_SYS_SCR_PET_LIFE? CPetProperty::GetInstance()->GetAddLife(): 1 );

  00922	81 3b 2a 52 00
	00		 cmp	 DWORD PTR [ebx], 21034	; 0000522aH
  00928	75 11		 jne	 SHORT $L287320
  0092a	e8 00 00 00 00	 call	 ?GetInstance@CPetProperty@@SAPAV1@XZ ; CPetProperty::GetInstance
  0092f	8b c8		 mov	 ecx, eax
  00931	e8 00 00 00 00	 call	 ?GetAddLife@CPetProperty@@QAEGXZ ; CPetProperty::GetAddLife
  00936	0f b7 c0	 movzx	 eax, ax
  00939	eb 05		 jmp	 SHORT $L287321
$L287320:
  0093b	b8 01 00 00 00	 mov	 eax, 1
$L287321:
  00940	03 e8		 add	 ebp, eax

; 2128 : 
; 2129 : 			pPet->SetLife( wLife > MAX_PET_LIFE? MAX_PET_LIFE: wLife );

  00942	66 83 fd 63	 cmp	 bp, 99			; 00000063H
  00946	b8 63 00 00 00	 mov	 eax, 99			; 00000063H
  0094b	77 03		 ja	 SHORT $L287323
  0094d	0f b7 c5	 movzx	 eax, bp
$L287323:

; 2130 : 				
; 2131 : 			CItemElem* pItemElem	= GetPetItem();

  00950	8b ce		 mov	 ecx, esi
  00952	66 89 47 0e	 mov	 WORD PTR [edi+14], ax
  00956	e8 00 00 00 00	 call	 ?GetPetItem@CMover@@QAEPAVCItemElem@@XZ ; CMover::GetPetItem

; 2132 : 			( (CUser*)this )->AddPetState( pItemElem->m_dwObjId, pPet->GetLife(), pPet->GetEnergy(), pPet->GetExp() );

  0095b	33 c9		 xor	 ecx, ecx
  0095d	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]
  00961	8b d8		 mov	 ebx, eax
  00963	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00966	50		 push	 eax
  00967	51		 push	 ecx
  00968	8b cf		 mov	 ecx, edi
  0096a	e8 00 00 00 00	 call	 ?GetLife@CPet@@QAEGXZ	; CPet::GetLife
  0096f	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00972	8b ce		 mov	 ecx, esi
  00974	50		 push	 eax
  00975	52		 push	 edx
  00976	e8 00 00 00 00	 call	 ?AddPetState@CUser@@QAEXKGGK@Z ; CUser::AddPetState

; 2133 : 			g_dpDBClient.CalluspPetLog( m_idPlayer, pItemElem->GetSerialNumber(), wLife, PETLOGTYPE_LIFE, pPet );

  0097b	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  0097e	8b 96 38 02 00
	00		 mov	 edx, DWORD PTR [esi+568]
  00984	57		 push	 edi
  00985	6a 08		 push	 8
  00987	0f b7 c5	 movzx	 eax, bp
  0098a	50		 push	 eax
  0098b	51		 push	 ecx
  0098c	52		 push	 edx
  0098d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00992	e8 00 00 00 00	 call	 ?CalluspPetLog@CDPDatabaseClient@@QAEXKKKHPAVCPet@@@Z ; CDPDatabaseClient::CalluspPetLog

; 2134 : 			break;

  00997	8b 5c 24 10	 mov	 ebx, DWORD PTR $T287473[esp+252]
  0099b	8b 6c 24 14	 mov	 ebp, DWORD PTR _nResult$[esp+252]
  0099f	e9 0c f7 ff ff	 jmp	 $L274982
$L287333:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  009a4	3d 48 75 00 00	 cmp	 eax, 30024		; 00007548H
  009a9	0f 85 fc f6 ff
	ff		 jne	 $L275200

; 2358 : #ifndef __NEW_STACKABLE_AMPS
; 2359 : 	case II_SYS_SYS_SCR_AMPES:	// "ES "		
; 2360 : 		{
; 2361 : 			// ES, EM  .. I   .
; 2362 : 			if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPES ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPEM ) ||
; 2363 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA2) ||
; 2364 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB2) ||
; 2365 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC2) || 
; 2366 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD2) ||
; 2367 : #ifdef __S_ADD_EXP
; 2368 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS2) ||
; 2369 : #endif // __S_ADD_EXP
; 2370 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESE )
; 2371 : 				)
; 2372 : 				nResult = 2;
; 2373 : 			else if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPI ) )
; 2374 : 				nResult = 3;
; 2375 : 			else
; 2376 : 				DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 2377 : 		}
; 2378 : 		break;
; 2379 : 	case II_SYS_SYS_SCR_AMPESA:
; 2380 : 	case II_SYS_SYS_SCR_AMPESB:
; 2381 : 	case II_SYS_SYS_SCR_AMPESC:
; 2382 : 	case II_SYS_SYS_SCR_AMPESD:
; 2383 : 	case II_SYS_SYS_SCR_AMPESE:
; 2384 : #ifdef __S_ADD_EXP
; 2385 : 	case II_SYS_SYS_SCR_AMPESS:
; 2386 : #endif // __S_ADD_EXP
; 2387 : 		{
; 2388 : 			if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPES ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPEM ) )
; 2389 : 				nResult = 2;
; 2390 : 			else if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPI ) )
; 2391 : 				nResult = 3;
; 2392 : 
; 2393 : 			//  
; 2394 : 			int nLevel = GetLevel();
; 2395 : 
; 2396 : 			CString str;
; 2397 : 			if( pItemProp->dwID == II_SYS_SYS_SCR_AMPESA )
; 2398 : 			{
; 2399 : 				if( 20 < nLevel )
; 2400 : 				{
; 2401 : 					str.Format( "%d - %d", 1, 20 );
; 2402 : 					((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSELEVEL, "\"%s\"", str ); // 
; 2403 : 					nResult = 99;
; 2404 : 				}
; 2405 : 			}
; 2406 : 			else if( pItemProp->dwID == II_SYS_SYS_SCR_AMPESB )
; 2407 : 			{
; 2408 : 				if( nLevel < 21 || 40 < nLevel )
; 2409 : 				{
; 2410 : 					str.Format( "%d - %d", 21, 40 );
; 2411 : 					((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSELEVEL, "\"%s\"", str ); // 
; 2412 : 					nResult = 99;
; 2413 : 				}
; 2414 : 			}
; 2415 : 			else if( pItemProp->dwID == II_SYS_SYS_SCR_AMPESC )
; 2416 : 			{
; 2417 : 				if( nLevel < 41 || 60 < nLevel )
; 2418 : 				{
; 2419 : 					str.Format( "%d - %d", 41, 60 );
; 2420 : 					((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSELEVEL, "\"%s\"", str ); // 
; 2421 : 					nResult = 99;
; 2422 : 				}
; 2423 : 			}
; 2424 : 			else if( pItemProp->dwID == II_SYS_SYS_SCR_AMPESD )
; 2425 : 			{
; 2426 : 				if( nLevel < 61 || 80 < nLevel )
; 2427 : 				{
; 2428 : 					str.Format( "%d - %d", 61, 80 );
; 2429 : 					((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSELEVEL, "\"%s\"", str ); // 
; 2430 : 					nResult = 99;
; 2431 : 				}
; 2432 : 			}
; 2433 : 			else if( pItemProp->dwID == II_SYS_SYS_SCR_AMPESE )
; 2434 : 			{
; 2435 : 				if( nLevel < 81 || 120 < nLevel )
; 2436 : 				{
; 2437 : 					str.Format( "%d - %d", 81, 120 );
; 2438 : 					((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSELEVEL, "\"%s\"", str ); // 
; 2439 : 					nResult = 99;
; 2440 : 				}
; 2441 : 			}
; 2442 : 
; 2443 : 			if( !(nResult == 2 || nResult == 3 || nResult == 99 ) )
; 2444 : 			{
; 2445 : 				BOOL bBuf[3];
; 2446 : 				int nBufCount = 0;
; 2447 : 				BOOL bSpecial = FALSE;
; 2448 : 				int nSpecialCount = 0;
; 2449 : 
; 2450 : 				ZeroMemory( bBuf, sizeof( bBuf ) );
; 2451 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA ) )
; 2452 : 				{
; 2453 : 					bBuf[0] = TRUE;		++nBufCount;
; 2454 : 				}
; 2455 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA1 ) )
; 2456 : 				{
; 2457 : 					bBuf[1] = TRUE;		++nBufCount;
; 2458 : 				}
; 2459 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA2 ) )
; 2460 : 				{
; 2461 : 					bBuf[2] = TRUE;		++nBufCount;
; 2462 : 				}
; 2463 : 
; 2464 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB ) )
; 2465 : 				{
; 2466 : 					bBuf[0] = TRUE;		++nBufCount;
; 2467 : 				}
; 2468 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB1 ) )
; 2469 : 				{
; 2470 : 					bBuf[1] = TRUE;		++nBufCount;
; 2471 : 				}
; 2472 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB2 ) )
; 2473 : 				{
; 2474 : 					bBuf[2] = TRUE;		++nBufCount;
; 2475 : 				}
; 2476 : 
; 2477 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC ) )
; 2478 : 				{
; 2479 : 					bBuf[0] = TRUE;		++nBufCount;
; 2480 : 				}
; 2481 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC1 ) )
; 2482 : 				{
; 2483 : 					bBuf[1] = TRUE;		++nBufCount;
; 2484 : 				}
; 2485 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC2 ) )
; 2486 : 				{
; 2487 : 					bBuf[2] = TRUE;		++nBufCount;
; 2488 : 				}
; 2489 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD ) )
; 2490 : 				{
; 2491 : 					bBuf[0] = TRUE;		++nBufCount;
; 2492 : 				}
; 2493 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD1 ) )
; 2494 : 				{
; 2495 : 					bBuf[1] = TRUE;		++nBufCount;
; 2496 : 				}
; 2497 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD2 ) )
; 2498 : 				{
; 2499 : 					bBuf[2] = TRUE;		++nBufCount;
; 2500 : 				}
; 2501 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESE ) )
; 2502 : 				{
; 2503 : 					bBuf[0] = TRUE;		++nBufCount;
; 2504 : 				}
; 2505 : #ifdef __S_ADD_EXP
; 2506 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS ) )
; 2507 : 				{
; 2508 : 					bBuf[0] = TRUE;		++nBufCount;	nSpecialCount++;//bSpecial = TRUE;
; 2509 : 				}
; 2510 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS1 ) )
; 2511 : 				{
; 2512 : 					bBuf[1] = TRUE;		++nBufCount;	nSpecialCount++;//bSpecial = TRUE;
; 2513 : 				}
; 2514 : 				if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS2 ) )
; 2515 : 				{
; 2516 : 					bBuf[2] = TRUE;		++nBufCount;	nSpecialCount++;//bSpecial = TRUE;
; 2517 : 				}
; 2518 : #endif // __S_ADD_EXP
; 2519 : 
; 2520 : 				int nMaxBuf = 3;
; 2521 : 				//if( bSpecial == FALSE )
; 2522 : 				{				
; 2523 : 					if( nLevel < 41 )
; 2524 : 						nMaxBuf = 3;				
; 2525 : 					else if( nLevel < 61 && nSpecialCount < 2 )
; 2526 : 						nMaxBuf = 2;
; 2527 : 					else if( nLevel <= 120 && nSpecialCount < 1 )
; 2528 : 						nMaxBuf = 1;
; 2529 : 					else
; 2530 : 						nMaxBuf = 3;
; 2531 : 				}
; 2532 : 
; 2533 : #ifdef __S_ADD_EXP
; 2534 : 				//if( bSpecial && pItemProp->dwID != II_SYS_SYS_SCR_AMPESS )
; 2535 : 				if( nSpecialCount && pItemProp->dwID != II_SYS_SYS_SCR_AMPESS )
; 2536 : 				{
; 2537 : 					nResult = 2;					
; 2538 : 				}
; 2539 : 				else
; 2540 : #endif // __S_ADD_EXP
; 2541 : 				if( nBufCount < nMaxBuf )
; 2542 : 				{
; 2543 : 					for( int i = 0 ; i < nMaxBuf ; ++i )
; 2544 : 					{
; 2545 : 						if( bBuf[i] == FALSE )
; 2546 : 						{
; 2547 : 							if( i == 0 )
; 2548 : 								pItemProp = prj.GetItemProp( pItemProp->dwID );
; 2549 : 							else if( i == 1 )
; 2550 : 								pItemProp = prj.GetItemProp( pItemProp->dwID + 1 );
; 2551 : 							else 
; 2552 : 								pItemProp = prj.GetItemProp( pItemProp->dwID + 2 );	
; 2553 : 							break;
; 2554 : 						}							
; 2555 : 					}
; 2556 : 
; 2557 : 					DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 2558 : 					float fFactor = 1;
; 2559 : 					switch( nBufCount + 1)
; 2560 : 					{
; 2561 : 					case 1:
; 2562 : 						{
; 2563 : 							fFactor *= 1.5f;
; 2564 : 						}
; 2565 : 						break;
; 2566 : 					case 2:
; 2567 : 						{
; 2568 : 							//if( bSpecial || nLevel < 61 )
; 2569 : 							if( nSpecialCount || nLevel < 61 )
; 2570 : 								fFactor *= 2.0f;
; 2571 : 							else
; 2572 : 								fFactor *= 1.5f;
; 2573 : 						}
; 2574 : 						break;
; 2575 : 					case 3:
; 2576 : 						{
; 2577 : 							//if( bSpecial || nLevel < 41 )
; 2578 : 							if( nSpecialCount || nLevel < 41 )
; 2579 : 								fFactor *= 2.5f;
; 2580 : 							else if( nLevel < 61 )
; 2581 : 								fFactor *= 2.0f;
; 2582 : 							else
; 2583 : 								fFactor *= 1.5f;
; 2584 : 						}
; 2585 : 						break;
; 2586 : 					}
; 2587 : 					CString strTemp;
; 2588 : #if __VER >= 11 // __EXPITEM_TOOLTIP_CHANGE
; 2589 : 					int nPercent = (int)( (fFactor - 1.0f) * 100.0f );
; 2590 : 					strTemp.Format( "%s %d%% %s", prj.GetText( TID_GAME_EXPITEM_TOOLTIP ), nPercent, prj.GetText( TID_GAME_EXPITEM_TOOLTIP1 ) );
; 2591 : #else //__EXPITEM_TOOLTIP_CHANGE
; 2592 : 					strTemp.Format( "%s%.1f%s", prj.GetText( TID_GAME_EXPTOOLTIP ), fFactor, prj.GetText( TID_GAME_EXPTOOLTIP1 ) );
; 2593 : #endif //__EXPITEM_TOOLTIP_CHANGE
; 2594 : 					((CUser*)this)->AddText( strTemp ); // 
; 2595 : 				}
; 2596 : 				else
; 2597 : 				{
; 2598 : #ifdef __S_ADD_EXP
; 2599 : 					//if( bSpecial )
; 2600 : 					//{
; 2601 : 					//	((CUser*)this)->AddDefinedText( TID_GAME_EXP_3 ); //
; 2602 : 					//}
; 2603 : //					else
; 2604 : #endif // __S_ADD_EXP
; 2605 : 					{
; 2606 : 						if( nLevel < 21 )
; 2607 : 							str.Format( "%d - %d", 1, 20 );
; 2608 : 						else if( nLevel < 41 )
; 2609 : 							str.Format( "%d - %d", 21, 40 );
; 2610 : 						else if( nLevel < 61 )
; 2611 : 							str.Format( "%d - %d", 41, 60 );
; 2612 : 						else if( nLevel < 81 )
; 2613 : 							str.Format( "%d - %d", 61, 80 );
; 2614 : 						else if( nLevel <= 120 )
; 2615 : 							str.Format( "%d - %d", 81, 120 );
; 2616 : 
; 2617 : 						CString szMaxBuf;
; 2618 : 						szMaxBuf.Format( "%d", nMaxBuf );
; 2619 : 						((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSE, "\"%s\" \"%s\"", str, szMaxBuf ); // 
; 2620 : 					}
; 2621 : 					nResult = 99;					
; 2622 : 				}				
; 2623 : 			}
; 2624 : 		}
; 2625 : 		break;
; 2626 : 	case II_SYS_SYS_SCR_AMPEM:	// "EM "		
; 2627 : 		{
; 2628 : 			// ES, EM  .. I   .
; 2629 : 			if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPES ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPEM ) ||
; 2630 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA2) ||
; 2631 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB2) ||
; 2632 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC2) || 
; 2633 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD2) ||
; 2634 : #ifdef __S_ADD_EXP
; 2635 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS ) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS1) || HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS2) ||
; 2636 : #endif // __S_ADD_EXP
; 2637 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESE ) 
; 2638 : 				)
; 2639 : 				nResult = 2;
; 2640 : 			else if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPI ) )
; 2641 : 				nResult = 3;
; 2642 : 			else
; 2643 : 				DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 2644 : 		}
; 2645 : 		break;
; 2646 : #endif // __NEW_STACKABLE_AMPS
; 2647 : #ifdef __Y_BEAUTY_SHOP_CHARGE
; 2648 : 	case II_SYS_SYS_SCR_BEAUTYSHOP: // "Beauty Shop Charge"		
; 2649 : 		{
; 2650 : 		}
; 2651 : 		break;

  009af	e9 fc f6 ff ff	 jmp	 $L274982
$L275088:

; 2652 : #endif // __Y_BEAUTY_SHOP_CHARGE
; 2653 : 	case II_SYS_SYS_SCR_GLVCHEER:	//   
; 2654 : 	case II_SYS_SYS_SCR_SMELPROT:	// " "		
; 2655 : #ifdef __SM_ITEM_2ND_EX
; 2656 : 	case II_SYS_SYS_SCR_SMELPROT2:
; 2657 : #endif	// __SM_ITEM_2ND_EX
; 2658 : #if __VER >= 9 // __ULTIMATE
; 2659 : 	case II_SYS_SYS_SCR_SMELPROT3: // "  ()
; 2660 : #endif // __ULTIMATE
; 2661 : #if __VER >= 11 // __SYS_COLLECTING
; 2662 : 	case II_SYS_SYS_SCR_SMELPROT4:	//   
; 2663 : #endif	// __SYS_COLLECTING
; 2664 : 	case II_SYS_SYS_SCR_SMELTING:	// " "	
; 2665 : 	case II_SYS_SYS_SCR_SUPERLEADERPARTY:	// " "		
; 2666 : 	case II_SYS_SYS_SCR_SUPERSMELTING:	// " ()"
; 2667 : 	case II_SYS_SYS_SCR_FONTEDIT:	// "Font Edit"		
; 2668 : #ifdef __Y_BEAUTY_SHOP_CHARGE
; 2669 : 	case II_SYS_SYS_SCR_VENDOR:	// "Vendor Charge"		
; 2670 : #endif //__Y_BEAUTY_SHOP_CHARGE
; 2671 : 	case II_SYS_SYS_SCR_SKLINSTRUCT:	// " "
; 2672 : #if __VER >= 14 // __EXT_ATTRIBUTE
; 2673 : 	case II_SYS_SYS_SCR_SMELTING2:	//   
; 2674 : #endif // __EXT_ATTRIBUTE
; 2675 : 
; 2676 : 		{
; 2677 : 			if( HasBuff( BUFF_ITEM, (WORD)( pItemProp->dwID ) ) )

  009b4	33 c0		 xor	 eax, eax
  009b6	66 8b 03	 mov	 ax, WORD PTR [ebx]
  009b9	50		 push	 eax
$L287488:
  009ba	6a 00		 push	 0
  009bc	8b ce		 mov	 ecx, esi
  009be	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  009c3	85 c0		 test	 eax, eax
  009c5	0f 84 cd 00 00
	00		 je	 $L275095
$L287489:

; 2678 : 				nResult = 2;

  009cb	bd 02 00 00 00	 mov	 ebp, 2

; 2679 : 			else

  009d0	e9 db f6 ff ff	 jmp	 $L274982
$L287332:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  009d5	2d 69 75 00 00	 sub	 eax, 30057		; 00007569H
  009da	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  009dd	0f 87 c8 f6 ff
	ff		 ja	 $L275200
  009e3	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L287478[eax]
  009ea	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L287497[ecx*4]
$L275038:

; 2188 : 				nResult = 2;
; 2189 : 		}
; 2190 : 		break;
; 2191 : 	case II_CHR_SYS_SCR_PSKILLFULL1:
; 2192 : 		{
; 2193 : 			if( !( IsSMMode( SM_PARTYSKILL1 ) || IsSMMode( SM_PARTYSKILL15 ) || IsSMMode( SM_PARTYSKILL30 ) ) )

  009f1	8b 86 5c 03 00
	00		 mov	 eax, DWORD PTR [esi+860]
  009f7	85 c0		 test	 eax, eax
  009f9	77 d0		 ja	 SHORT $L287489
  009fb	8b 86 0c 03 00
	00		 mov	 eax, DWORD PTR [esi+780]
  00a01	85 c0		 test	 eax, eax
  00a03	77 c6		 ja	 SHORT $L287489
  00a05	8b 86 10 03 00
	00		 mov	 eax, DWORD PTR [esi+784]
  00a0b	85 c0		 test	 eax, eax
  00a0d	77 bc		 ja	 SHORT $L287489

; 2194 : #if __VER >= 12 // __PARSKILL1001	//12     world,core,neuz
; 2195 : 			{
; 2196 : 				SetSMMode( SM_PARTYSKILL1, pItemProp->dwCircleTime );

  00a0f	8b 93 ec 01 00
	00		 mov	 edx, DWORD PTR [ebx+492]
  00a15	52		 push	 edx
  00a16	6a 16		 push	 22			; 00000016H
$L287486:
  00a18	8b ce		 mov	 ecx, esi
  00a1a	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2197 : 				g_DPCoreClient.SendUserPartySkill( m_idPlayer, PARTY_PARSKILL_MODE, 1000, 0, 1 );

  00a1f	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  00a25	6a 01		 push	 1
  00a27	6a 00		 push	 0
  00a29	68 e8 03 00 00	 push	 1000			; 000003e8H
  00a2e	6a 04		 push	 4
  00a30	50		 push	 eax
  00a31	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  00a36	e8 00 00 00 00	 call	 ?SendUserPartySkill@CDPCoreClient@@QAEXKHKHH@Z ; CDPCoreClient::SendUserPartySkill

; 2198 : 			}
; 2199 : #else	//__PARSKILL1001	//12     world,core,neuz
; 2200 : 				SetSMMode( SM_PARTYSKILL1, pItemProp->dwCircleTime );
; 2201 : #endif //__PARSKILL1001	//12     world,core,neuz
; 2202 : 			else

  00a3b	e9 70 f6 ff ff	 jmp	 $L274982
$L275059:

; 2265 : 				nResult = 2;
; 2266 : 		}
; 2267 : 		break;
; 2268 : 	case II_CHR_SYS_SCR_UPCUTSTONE01:
; 2269 : 		{
; 2270 : 			if( !( IsSMMode( SM_ATTACK_UP1 ) || IsSMMode( SM_ATTACK_UP ) ) )

  00a40	8b 86 60 03 00
	00		 mov	 eax, DWORD PTR [esi+864]
  00a46	85 c0		 test	 eax, eax
  00a48	77 81		 ja	 SHORT $L287489
  00a4a	8b 86 40 03 00
	00		 mov	 eax, DWORD PTR [esi+832]
  00a50	85 c0		 test	 eax, eax
  00a52	0f 87 73 ff ff
	ff		 ja	 $L287489

; 2271 : 				SetSMMode( SM_ATTACK_UP1, pItemProp->dwCircleTime );

  00a58	8b 8b ec 01 00
	00		 mov	 ecx, DWORD PTR [ebx+492]
  00a5e	51		 push	 ecx
  00a5f	6a 17		 push	 23			; 00000017H
  00a61	8b ce		 mov	 ecx, esi
  00a63	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode

; 2272 : 			else

  00a68	e9 43 f6 ff ff	 jmp	 $L274982
$L275100:

; 2718 : 		}
; 2719 : #endif	// __PET_0410
; 2720 : #ifdef __EVE_BALLOON
; 2721 : #if __VER < 14 // __BALLOON_CODE_IMPROVEMENT
; 2722 : 	case II_SYS_SYS_EVE_BALLOON:
; 2723 : 	case II_SYS_SYS_EVE_BALLOON01:
; 2724 : 	case II_SYS_SYS_EVE_BALLOON02:
; 2725 : 	case II_SYS_SYS_EVE_BALLOON_01:
; 2726 : 	case II_SYS_SYS_EVE_BALLOON01_01:
; 2727 : 	case II_SYS_SYS_EVE_BALLOON02_01:
; 2728 : 		{
; 2729 : 			if( HasBuff( BUFF_ITEM, II_SYS_SYS_EVE_BALLOON )
; 2730 : 				|| HasBuff( BUFF_ITEM, II_SYS_SYS_EVE_BALLOON01 )
; 2731 : 				|| HasBuff( BUFF_ITEM, II_SYS_SYS_EVE_BALLOON02 )
; 2732 : 				|| HasBuff( BUFF_ITEM, II_SYS_SYS_EVE_BALLOON_01 )
; 2733 : 				|| HasBuff( BUFF_ITEM, II_SYS_SYS_EVE_BALLOON01_01 )
; 2734 : 				|| HasBuff( BUFF_ITEM, II_SYS_SYS_EVE_BALLOON02_01 )
; 2735 : 			)
; 2736 : 				nResult = 2;
; 2737 : 			else
; 2738 : 				DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 2739 : 		}
; 2740 : 		break;
; 2741 : #endif // __BALLOON_CODE_IMPROVEMENT
; 2742 : #endif //__EVE_BALLOON
; 2743 : #if __VER >= 9 // __II_SYS_SYS_SCR_GET
; 2744 : 	case II_SYS_SYS_SCR_GET01:
; 2745 : 	case II_SYS_SYS_SCR_GET02:
; 2746 : 		{
; 2747 : 			if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_GET01 ) ||
; 2748 : 				HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_GET02 ) )

  00a6d	68 a3 75 00 00	 push	 30115			; 000075a3H
  00a72	6a 00		 push	 0
  00a74	8b ce		 mov	 ecx, esi
  00a76	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00a7b	85 c0		 test	 eax, eax
  00a7d	0f 85 48 ff ff
	ff		 jne	 $L287489
  00a83	68 a4 75 00 00	 push	 30116			; 000075a4H
  00a88	50		 push	 eax
  00a89	8b ce		 mov	 ecx, esi
  00a8b	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00a90	85 c0		 test	 eax, eax
  00a92	0f 85 33 ff ff
	ff		 jne	 $L287489
$L275095:

; 2749 : 				nResult = 2;
; 2750 : 			else
; 2751 : 				DoApplySkill( (CCtrl*)this, pItemProp, NULL );

  00a98	6a 00		 push	 0
  00a9a	6a 00		 push	 0
  00a9c	6a 00		 push	 0
  00a9e	6a 00		 push	 0
  00aa0	6a 00		 push	 0
  00aa2	53		 push	 ebx
  00aa3	56		 push	 esi
  00aa4	8b ce		 mov	 ecx, esi
  00aa6	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  00aab	e9 00 f6 ff ff	 jmp	 $L274982
$L274989:

; 2042 : #ifdef __S_ADD_RESTATE
; 2043 : 	case II_CHR_SYS_SCR_RESTATE_STR:
; 2044 : 		{
; 2045 : 			if( m_nStr == 15 )

  00ab0	83 be d0 05 00
	00 0f		 cmp	 DWORD PTR [esi+1488], 15 ; 0000000fH

; 2046 : 			{
; 2047 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00ab7	8b ce		 mov	 ecx, esi

; 2048 : 				nResult = 1;
; 2049 : 			}
; 2050 : 			else

  00ab9	0f 84 e2 f5 ff
	ff		 je	 $L287485

; 2051 : 				ReStateOne( 0 );

  00abf	6a 00		 push	 0
  00ac1	e8 00 00 00 00	 call	 ?ReStateOne@CMover@@QAEXH@Z ; CMover::ReStateOne

; 2052 : 		}
; 2053 : 		break;

  00ac6	e9 e5 f5 ff ff	 jmp	 $L274982
$L287331:

; 2027 : 	}
; 2028 : #endif	// __AZRIA_1023
; 2029 : 	switch( pItemProp->dwID )

  00acb	2d c8 75 00 00	 sub	 eax, 30152		; 000075c8H
  00ad0	3d bc 00 00 00	 cmp	 eax, 188		; 000000bcH
  00ad5	0f 87 d0 f5 ff
	ff		 ja	 $L275200
  00adb	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $L287479[eax]
  00ae2	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L287498[edx*4]
$L274993:

; 2054 : 	case II_CHR_SYS_SCR_RESTATE_STA:
; 2055 : 		{
; 2056 : 			if( m_nSta == 15 )

  00ae9	83 be d4 05 00
	00 0f		 cmp	 DWORD PTR [esi+1492], 15 ; 0000000fH

; 2057 : 			{
; 2058 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00af0	8b ce		 mov	 ecx, esi

; 2059 : 				nResult = 1;
; 2060 : 			}
; 2061 : 			else

  00af2	0f 84 a9 f5 ff
	ff		 je	 $L287485

; 2062 : 				ReStateOne( 1 );

  00af8	6a 01		 push	 1
  00afa	e8 00 00 00 00	 call	 ?ReStateOne@CMover@@QAEXH@Z ; CMover::ReStateOne

; 2063 : 		}
; 2064 : 		break;

  00aff	e9 ac f5 ff ff	 jmp	 $L274982
$L274997:

; 2065 : 	case II_CHR_SYS_SCR_RESTATE_DEX:
; 2066 : 		{
; 2067 : 			if( m_nDex == 15 )

  00b04	83 be d8 05 00
	00 0f		 cmp	 DWORD PTR [esi+1496], 15 ; 0000000fH

; 2068 : 			{
; 2069 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00b0b	8b ce		 mov	 ecx, esi

; 2070 : 				nResult = 1;
; 2071 : 			}
; 2072 : 			else

  00b0d	0f 84 8e f5 ff
	ff		 je	 $L287485

; 2073 : 				ReStateOne( 2 );

  00b13	6a 02		 push	 2
  00b15	e8 00 00 00 00	 call	 ?ReStateOne@CMover@@QAEXH@Z ; CMover::ReStateOne

; 2074 : 		}
; 2075 : 		break;

  00b1a	e9 91 f5 ff ff	 jmp	 $L274982
$L275001:

; 2076 : 	case II_CHR_SYS_SCR_RESTATE_INT:
; 2077 : 		{
; 2078 : 			if( m_nInt == 15 )

  00b1f	83 be dc 05 00
	00 0f		 cmp	 DWORD PTR [esi+1500], 15 ; 0000000fH

; 2079 : 			{
; 2080 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00b26	8b ce		 mov	 ecx, esi

; 2081 : 				nResult = 1;
; 2082 : 			}
; 2083 : 			else

  00b28	0f 84 73 f5 ff
	ff		 je	 $L287485

; 2084 : 				ReStateOne( 3 );

  00b2e	6a 03		 push	 3
  00b30	e8 00 00 00 00	 call	 ?ReStateOne@CMover@@QAEXH@Z ; CMover::ReStateOne

; 2085 : 		}
; 2086 : 		break;

  00b35	e9 76 f5 ff ff	 jmp	 $L274982
$L275184:

; 2902 : #endif	// __MA_VER11_02
; 2903 : #ifdef __ADD_RESTATE_LOW
; 2904 : 	case II_CHR_SYS_SCR_RESTATE_STR_LOW:
; 2905 : 		{
; 2906 : 			if( m_nStr == 15 )

  00b3a	83 be d0 05 00
	00 0f		 cmp	 DWORD PTR [esi+1488], 15 ; 0000000fH

; 2907 : 			{
; 2908 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00b41	8b ce		 mov	 ecx, esi

; 2909 : 				nResult = 1;
; 2910 : 			}
; 2911 : 			else

  00b43	0f 84 58 f5 ff
	ff		 je	 $L287485

; 2912 : 				ReStateOneLow( 0 );

  00b49	6a 00		 push	 0
  00b4b	e8 00 00 00 00	 call	 ?ReStateOneLow@CMover@@QAEXH@Z ; CMover::ReStateOneLow

; 2913 : 		}
; 2914 : 		break;

  00b50	e9 5b f5 ff ff	 jmp	 $L274982
$L275188:

; 2915 : 	case II_CHR_SYS_SCR_RESTATE_STA_LOW:
; 2916 : 		{
; 2917 : 			if( m_nSta == 15 )

  00b55	83 be d4 05 00
	00 0f		 cmp	 DWORD PTR [esi+1492], 15 ; 0000000fH

; 2918 : 			{
; 2919 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00b5c	8b ce		 mov	 ecx, esi

; 2920 : 				nResult = 1;
; 2921 : 			}
; 2922 : 			else

  00b5e	0f 84 3d f5 ff
	ff		 je	 $L287485

; 2923 : 				ReStateOneLow( 1 );

  00b64	6a 01		 push	 1
  00b66	e8 00 00 00 00	 call	 ?ReStateOneLow@CMover@@QAEXH@Z ; CMover::ReStateOneLow

; 2924 : 		}
; 2925 : 		break;

  00b6b	e9 40 f5 ff ff	 jmp	 $L274982
$L275192:

; 2926 : 	case II_CHR_SYS_SCR_RESTATE_DEX_LOW:
; 2927 : 		{
; 2928 : 			if( m_nDex == 15 )

  00b70	83 be d8 05 00
	00 0f		 cmp	 DWORD PTR [esi+1496], 15 ; 0000000fH

; 2929 : 			{
; 2930 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00b77	8b ce		 mov	 ecx, esi

; 2931 : 				nResult = 1;
; 2932 : 			}
; 2933 : 			else

  00b79	0f 84 22 f5 ff
	ff		 je	 $L287485

; 2934 : 				ReStateOneLow( 2 );

  00b7f	6a 02		 push	 2
  00b81	e8 00 00 00 00	 call	 ?ReStateOneLow@CMover@@QAEXH@Z ; CMover::ReStateOneLow

; 2935 : 		}
; 2936 : 		break;

  00b86	e9 25 f5 ff ff	 jmp	 $L274982
$L275196:

; 2937 : 	case II_CHR_SYS_SCR_RESTATE_INT_LOW:
; 2938 : 		{
; 2939 : 			if( m_nInt == 15 )

  00b8b	83 be dc 05 00
	00 0f		 cmp	 DWORD PTR [esi+1500], 15 ; 0000000fH

; 2940 : 			{
; 2941 : 				((CUser*)this)->AddDefinedText( TID_GAME_DONOTUSE_RESTATE );			

  00b92	8b ce		 mov	 ecx, esi

; 2942 : 				nResult = 1;
; 2943 : 			}
; 2944 : 			else

  00b94	0f 84 07 f5 ff
	ff		 je	 $L287485

; 2945 : 				ReStateOneLow( 3 );

  00b9a	6a 03		 push	 3
  00b9c	e8 00 00 00 00	 call	 ?ReStateOneLow@CMover@@QAEXH@Z ; CMover::ReStateOneLow

; 2946 : 		}
; 2947 : 		break;

  00ba1	e9 0a f5 ff ff	 jmp	 $L274982
$L275202:

; 2971 : 		{
; 2972 : 			DoApplySkill( (CCtrl*)this, pItemProp, NULL );

  00ba6	6a 00		 push	 0
  00ba8	6a 00		 push	 0
  00baa	6a 00		 push	 0
  00bac	6a 00		 push	 0
  00bae	6a 00		 push	 0
  00bb0	53		 push	 ebx
  00bb1	56		 push	 esi
  00bb2	8b ce		 mov	 ecx, esi
  00bb4	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill

; 2973 : 			nResult = 0;

  00bb9	33 ed		 xor	 ebp, ebp
$L275203:

; 2974 : 		}
; 2975 : 	}
; 2976 : #endif // __BALLOON_CODE_IMPROVEMENT
; 2977 : 
; 2978 : #endif // __WORLDSERVER
; 2979 : 
; 2980 : 	return nResult;

  00bbb	8b c5		 mov	 eax, ebp
$L274975:

; 2981 : }

  00bbd	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+252]
  00bc4	5f		 pop	 edi
  00bc5	5e		 pop	 esi
  00bc6	5d		 pop	 ebp
  00bc7	5b		 pop	 ebx
  00bc8	33 cc		 xor	 ecx, esp
  00bca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bcf	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00bd5	c2 0c 00	 ret	 12			; 0000000cH
$L287492:
  00bd8	00 00 00 00	 DD	 $L274985
  00bdc	00 00 00 00	 DD	 $L275029
  00be0	00 00 00 00	 DD	 $L275032
  00be4	00 00 00 00	 DD	 $L275041
  00be8	00 00 00 00	 DD	 $L275044
  00bec	00 00 00 00	 DD	 $L275047
  00bf0	00 00 00 00	 DD	 $L275050
  00bf4	00 00 00 00	 DD	 $L275056
  00bf8	00 00 00 00	 DD	 $L275200
  00bfc	00 00 00 00	 DD	 $L275005
$L287493:
  00c00	00 00 00 00	 DD	 $L275077
  00c04	00 00 00 00	 DD	 $L275200
  00c08	00 00 00 00	 DD	 $L275068
  00c0c	00 00 00 00	 DD	 $L275200
  00c10	00 00 00 00	 DD	 $L275065
  00c14	00 00 00 00	 DD	 $L275200
  00c18	00 00 00 00	 DD	 $L275078
  00c1c	00 00 00 00	 DD	 $L275200
  00c20	00 00 00 00	 DD	 $L275083
$L287494:
  00c24	00 00 00 00	 DD	 $L275088
  00c28	00 00 00 00	 DD	 $L275105
  00c2c	00 00 00 00	 DD	 $L275200
$L287476:
  00c30	00		 DB	 0
  00c31	00		 DB	 0
  00c32	01		 DB	 1
  00c33	02		 DB	 2
  00c34	02		 DB	 2
  00c35	02		 DB	 2
  00c36	02		 DB	 2
  00c37	02		 DB	 2
  00c38	02		 DB	 2
  00c39	02		 DB	 2
  00c3a	00		 DB	 0
  00c3b	02		 DB	 2
  00c3c	02		 DB	 2
  00c3d	02		 DB	 2
  00c3e	02		 DB	 2
  00c3f	02		 DB	 2
  00c40	02		 DB	 2
  00c41	02		 DB	 2
  00c42	02		 DB	 2
  00c43	02		 DB	 2
  00c44	02		 DB	 2
  00c45	00		 DB	 0
  00c46	00		 DB	 0
  00c47	90		 npad	 1
$L287495:
  00c48	00 00 00 00	 DD	 $L275098
  00c4c	00 00 00 00	 DD	 $L275098
  00c50	00 00 00 00	 DD	 $L275009
  00c54	00 00 00 00	 DD	 $L275099
$L287496:
  00c58	00 00 00 00	 DD	 $L275088
  00c5c	00 00 00 00	 DD	 $L275133
  00c60	00 00 00 00	 DD	 $L275200
$L287477:
  00c64	00		 DB	 0
  00c65	01		 DB	 1
  00c66	02		 DB	 2
  00c67	00		 DB	 0
  00c68	02		 DB	 2
  00c69	02		 DB	 2
  00c6a	02		 DB	 2
  00c6b	02		 DB	 2
  00c6c	02		 DB	 2
  00c6d	02		 DB	 2
  00c6e	02		 DB	 2
  00c6f	02		 DB	 2
  00c70	02		 DB	 2
  00c71	02		 DB	 2
  00c72	02		 DB	 2
  00c73	02		 DB	 2
  00c74	02		 DB	 2
  00c75	01		 DB	 1
  00c76	8b ff		 npad	 2
$L287497:
  00c78	00 00 00 00	 DD	 $L275038
  00c7c	00 00 00 00	 DD	 $L275059
  00c80	00 00 00 00	 DD	 $L275100
  00c84	00 00 00 00	 DD	 $L275200
$L287478:
  00c88	00		 DB	 0
  00c89	01		 DB	 1
  00c8a	03		 DB	 3
  00c8b	03		 DB	 3
  00c8c	03		 DB	 3
  00c8d	03		 DB	 3
  00c8e	03		 DB	 3
  00c8f	03		 DB	 3
  00c90	03		 DB	 3
  00c91	03		 DB	 3
  00c92	03		 DB	 3
  00c93	03		 DB	 3
  00c94	03		 DB	 3
  00c95	03		 DB	 3
  00c96	03		 DB	 3
  00c97	03		 DB	 3
  00c98	03		 DB	 3
  00c99	03		 DB	 3
  00c9a	03		 DB	 3
  00c9b	03		 DB	 3
  00c9c	03		 DB	 3
  00c9d	03		 DB	 3
  00c9e	03		 DB	 3
  00c9f	03		 DB	 3
  00ca0	03		 DB	 3
  00ca1	03		 DB	 3
  00ca2	03		 DB	 3
  00ca3	03		 DB	 3
  00ca4	03		 DB	 3
  00ca5	03		 DB	 3
  00ca6	03		 DB	 3
  00ca7	03		 DB	 3
  00ca8	03		 DB	 3
  00ca9	03		 DB	 3
  00caa	03		 DB	 3
  00cab	03		 DB	 3
  00cac	03		 DB	 3
  00cad	03		 DB	 3
  00cae	03		 DB	 3
  00caf	03		 DB	 3
  00cb0	03		 DB	 3
  00cb1	03		 DB	 3
  00cb2	03		 DB	 3
  00cb3	03		 DB	 3
  00cb4	03		 DB	 3
  00cb5	03		 DB	 3
  00cb6	03		 DB	 3
  00cb7	03		 DB	 3
  00cb8	03		 DB	 3
  00cb9	03		 DB	 3
  00cba	03		 DB	 3
  00cbb	03		 DB	 3
  00cbc	03		 DB	 3
  00cbd	03		 DB	 3
  00cbe	03		 DB	 3
  00cbf	03		 DB	 3
  00cc0	03		 DB	 3
  00cc1	03		 DB	 3
  00cc2	02		 DB	 2
  00cc3	02		 DB	 2
$L287498:
  00cc4	00 00 00 00	 DD	 $L274997
  00cc8	00 00 00 00	 DD	 $L274993
  00ccc	00 00 00 00	 DD	 $L275001
  00cd0	00 00 00 00	 DD	 $L275184
  00cd4	00 00 00 00	 DD	 $L275192
  00cd8	00 00 00 00	 DD	 $L275188
  00cdc	00 00 00 00	 DD	 $L275196
  00ce0	00 00 00 00	 DD	 $L275200
$L287479:
  00ce4	00		 DB	 0
  00ce5	01		 DB	 1
  00ce6	02		 DB	 2
  00ce7	07		 DB	 7
  00ce8	07		 DB	 7
  00ce9	07		 DB	 7
  00cea	07		 DB	 7
  00ceb	07		 DB	 7
  00cec	07		 DB	 7
  00ced	07		 DB	 7
  00cee	07		 DB	 7
  00cef	07		 DB	 7
  00cf0	07		 DB	 7
  00cf1	07		 DB	 7
  00cf2	07		 DB	 7
  00cf3	07		 DB	 7
  00cf4	07		 DB	 7
  00cf5	07		 DB	 7
  00cf6	07		 DB	 7
  00cf7	07		 DB	 7
  00cf8	07		 DB	 7
  00cf9	07		 DB	 7
  00cfa	07		 DB	 7
  00cfb	07		 DB	 7
  00cfc	07		 DB	 7
  00cfd	07		 DB	 7
  00cfe	07		 DB	 7
  00cff	07		 DB	 7
  00d00	07		 DB	 7
  00d01	07		 DB	 7
  00d02	07		 DB	 7
  00d03	07		 DB	 7
  00d04	07		 DB	 7
  00d05	07		 DB	 7
  00d06	07		 DB	 7
  00d07	07		 DB	 7
  00d08	07		 DB	 7
  00d09	07		 DB	 7
  00d0a	07		 DB	 7
  00d0b	07		 DB	 7
  00d0c	07		 DB	 7
  00d0d	07		 DB	 7
  00d0e	07		 DB	 7
  00d0f	07		 DB	 7
  00d10	07		 DB	 7
  00d11	07		 DB	 7
  00d12	07		 DB	 7
  00d13	07		 DB	 7
  00d14	07		 DB	 7
  00d15	07		 DB	 7
  00d16	07		 DB	 7
  00d17	07		 DB	 7
  00d18	07		 DB	 7
  00d19	07		 DB	 7
  00d1a	07		 DB	 7
  00d1b	07		 DB	 7
  00d1c	07		 DB	 7
  00d1d	07		 DB	 7
  00d1e	07		 DB	 7
  00d1f	07		 DB	 7
  00d20	07		 DB	 7
  00d21	07		 DB	 7
  00d22	07		 DB	 7
  00d23	07		 DB	 7
  00d24	07		 DB	 7
  00d25	07		 DB	 7
  00d26	07		 DB	 7
  00d27	07		 DB	 7
  00d28	07		 DB	 7
  00d29	07		 DB	 7
  00d2a	07		 DB	 7
  00d2b	07		 DB	 7
  00d2c	07		 DB	 7
  00d2d	07		 DB	 7
  00d2e	07		 DB	 7
  00d2f	07		 DB	 7
  00d30	07		 DB	 7
  00d31	07		 DB	 7
  00d32	07		 DB	 7
  00d33	07		 DB	 7
  00d34	07		 DB	 7
  00d35	07		 DB	 7
  00d36	07		 DB	 7
  00d37	07		 DB	 7
  00d38	07		 DB	 7
  00d39	07		 DB	 7
  00d3a	07		 DB	 7
  00d3b	07		 DB	 7
  00d3c	07		 DB	 7
  00d3d	07		 DB	 7
  00d3e	07		 DB	 7
  00d3f	07		 DB	 7
  00d40	07		 DB	 7
  00d41	07		 DB	 7
  00d42	07		 DB	 7
  00d43	07		 DB	 7
  00d44	07		 DB	 7
  00d45	07		 DB	 7
  00d46	07		 DB	 7
  00d47	07		 DB	 7
  00d48	07		 DB	 7
  00d49	07		 DB	 7
  00d4a	07		 DB	 7
  00d4b	07		 DB	 7
  00d4c	07		 DB	 7
  00d4d	07		 DB	 7
  00d4e	07		 DB	 7
  00d4f	07		 DB	 7
  00d50	07		 DB	 7
  00d51	07		 DB	 7
  00d52	07		 DB	 7
  00d53	07		 DB	 7
  00d54	07		 DB	 7
  00d55	07		 DB	 7
  00d56	07		 DB	 7
  00d57	07		 DB	 7
  00d58	07		 DB	 7
  00d59	07		 DB	 7
  00d5a	07		 DB	 7
  00d5b	07		 DB	 7
  00d5c	07		 DB	 7
  00d5d	07		 DB	 7
  00d5e	07		 DB	 7
  00d5f	07		 DB	 7
  00d60	07		 DB	 7
  00d61	07		 DB	 7
  00d62	07		 DB	 7
  00d63	07		 DB	 7
  00d64	07		 DB	 7
  00d65	07		 DB	 7
  00d66	07		 DB	 7
  00d67	07		 DB	 7
  00d68	07		 DB	 7
  00d69	07		 DB	 7
  00d6a	07		 DB	 7
  00d6b	07		 DB	 7
  00d6c	07		 DB	 7
  00d6d	07		 DB	 7
  00d6e	07		 DB	 7
  00d6f	07		 DB	 7
  00d70	07		 DB	 7
  00d71	07		 DB	 7
  00d72	07		 DB	 7
  00d73	07		 DB	 7
  00d74	07		 DB	 7
  00d75	07		 DB	 7
  00d76	07		 DB	 7
  00d77	07		 DB	 7
  00d78	07		 DB	 7
  00d79	07		 DB	 7
  00d7a	07		 DB	 7
  00d7b	07		 DB	 7
  00d7c	07		 DB	 7
  00d7d	07		 DB	 7
  00d7e	07		 DB	 7
  00d7f	07		 DB	 7
  00d80	07		 DB	 7
  00d81	07		 DB	 7
  00d82	07		 DB	 7
  00d83	07		 DB	 7
  00d84	07		 DB	 7
  00d85	07		 DB	 7
  00d86	07		 DB	 7
  00d87	07		 DB	 7
  00d88	07		 DB	 7
  00d89	07		 DB	 7
  00d8a	07		 DB	 7
  00d8b	07		 DB	 7
  00d8c	07		 DB	 7
  00d8d	07		 DB	 7
  00d8e	07		 DB	 7
  00d8f	07		 DB	 7
  00d90	07		 DB	 7
  00d91	07		 DB	 7
  00d92	07		 DB	 7
  00d93	07		 DB	 7
  00d94	07		 DB	 7
  00d95	07		 DB	 7
  00d96	07		 DB	 7
  00d97	07		 DB	 7
  00d98	07		 DB	 7
  00d99	07		 DB	 7
  00d9a	07		 DB	 7
  00d9b	07		 DB	 7
  00d9c	07		 DB	 7
  00d9d	03		 DB	 3
  00d9e	04		 DB	 4
  00d9f	05		 DB	 5
  00da0	06		 DB	 6
?DoUseItemSystem@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ENDP ; CMover::DoUseItemSystem
_TEXT	ENDS
PUBLIC	?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; CMover::SetValidNeedVis
; Function compile flags: /Ogty
;	COMDAT ?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
$T287637 = -8						; size = 4
_this$ = -4						; size = 4
_pItemElem$ = 8						; size = 4
_nPos$ = 12						; size = 4
_bResult1$ = 16						; size = 4
_vecValid$ = 16						; size = 4
?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z PROC NEAR ; CMover::SetValidNeedVis, COMDAT
; _this$ = ecx

; 4545 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi

; 4546 : 	if( vecValid[nPos] != UNDEFINED_NEEDVIS )

  00004	8b 74 24 14	 mov	 esi, DWORD PTR _nPos$[esp+8]
  00008	57		 push	 edi
  00009	8b 7c 24 1c	 mov	 edi, DWORD PTR _vecValid$[esp+12]
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00010	03 c6		 add	 eax, esi
  00012	89 4c 24 0c	 mov	 DWORD PTR _this$[esp+16], ecx
  00016	80 38 04	 cmp	 BYTE PTR [eax], 4
  00019	74 14		 je	 SHORT $L276186

; 4547 : 		return ( vecValid[nPos] == SUCCSESS_NEEDVIS );

  0001b	8a 10		 mov	 dl, BYTE PTR [eax]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	80 fa 03	 cmp	 dl, 3
  00022	0f 94 c1	 sete	 cl
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	8b c1		 mov	 eax, ecx

; 4588 : }

  00029	83 c4 08	 add	 esp, 8
  0002c	c2 0c 00	 ret	 12			; 0000000cH
$L276186:
  0002f	53		 push	 ebx

; 4548 : 	
; 4549 : 	ItemProp* pPropVis = prj.GetItemProp( pItemElem->GetPiercingItem( nPos ) );

  00030	8b 5c 24 18	 mov	 ebx, DWORD PTR _pItemElem$[esp+16]
  00034	55		 push	 ebp
  00035	83 c3 3c	 add	 ebx, 60			; 0000003cH
  00038	56		 push	 esi
  00039	8b cb		 mov	 ecx, ebx
  0003b	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  00040	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00046	33 ed		 xor	 ebp, ebp
  00048	3b c5		 cmp	 eax, ebp
  0004a	7c 2b		 jl	 SHORT $L287643
  0004c	3b c1		 cmp	 eax, ecx
  0004e	7d 27		 jge	 SHORT $L287643
  00050	73 11		 jae	 SHORT $L288002
  00052	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  00058	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]

; 4550 : 	if( !pPropVis )

  0005b	3b cd		 cmp	 ecx, ebp
  0005d	89 4c 24 10	 mov	 DWORD PTR $T287637[esp+24], ecx
  00061	75 3d		 jne	 SHORT $L276188
$L288002:

; 4551 : 	{
; 4552 : 		vecValid[nPos] = FAILED_BOTH_NEEDVIS;

  00063	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00066	5d		 pop	 ebp
  00067	03 c6		 add	 eax, esi
  00069	5b		 pop	 ebx
  0006a	5f		 pop	 edi

; 4585 : 	else
; 4586 : 		vecValid[nPos] = FAILED_BOTH_NEEDVIS;

  0006b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4587 : 	return FALSE;

  0006e	33 c0		 xor	 eax, eax
  00070	5e		 pop	 esi

; 4588 : }

  00071	83 c4 08	 add	 esp, 8
  00074	c2 0c 00	 ret	 12			; 0000000cH

; 4548 : 	
; 4549 : 	ItemProp* pPropVis = prj.GetItemProp( pItemElem->GetPiercingItem( nPos ) );

$L287643:
  00077	50		 push	 eax
  00078	51		 push	 ecx
  00079	55		 push	 ebp
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00084	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 4551 : 	{
; 4552 : 		vecValid[nPos] = FAILED_BOTH_NEEDVIS;

  00089	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008c	83 c4 14	 add	 esp, 20			; 00000014H
  0008f	5d		 pop	 ebp
  00090	03 c6		 add	 eax, esi
  00092	5b		 pop	 ebx
  00093	5f		 pop	 edi

; 4585 : 	else
; 4586 : 		vecValid[nPos] = FAILED_BOTH_NEEDVIS;

  00094	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4587 : 	return FALSE;

  00097	33 c0		 xor	 eax, eax
  00099	5e		 pop	 esi

; 4588 : }

  0009a	83 c4 08	 add	 esp, 8
  0009d	c2 0c 00	 ret	 12			; 0000000cH
$L276188:

; 4553 : 		return FALSE;
; 4554 : 	}
; 4555 : 
; 4556 : 	if( pPropVis->dwReferTarget1 == NULL_ID && pPropVis->dwReferTarget2 == NULL_ID )

  000a0	8b 81 08 02 00
	00		 mov	 eax, DWORD PTR [ecx+520]
  000a6	83 ca ff	 or	 edx, -1
  000a9	3b c2		 cmp	 eax, edx
  000ab	75 1f		 jne	 SHORT $L276189
  000ad	39 91 0c 02 00
	00		 cmp	 DWORD PTR [ecx+524], edx
  000b3	75 17		 jne	 SHORT $L276189

; 4557 : 	{
; 4558 : 		vecValid[nPos] = SUCCSESS_NEEDVIS;

  000b5	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000b8	5d		 pop	 ebp
  000b9	03 c6		 add	 eax, esi
  000bb	5b		 pop	 ebx
  000bc	5f		 pop	 edi
  000bd	c6 00 03	 mov	 BYTE PTR [eax], 3

; 4559 : 		return TRUE;

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	5e		 pop	 esi

; 4588 : }

  000c6	83 c4 08	 add	 esp, 8
  000c9	c2 0c 00	 ret	 12			; 0000000cH
$L276189:

; 4560 : 	}
; 4561 : 
; 4562 : 	BOOL bResult1 = FALSE, bResult2 = FALSE;
; 4563 : 	if( pPropVis->dwReferTarget1 == NULL_ID ) bResult1 = TRUE;

  000cc	3b c2		 cmp	 eax, edx
  000ce	89 6c 24 24	 mov	 DWORD PTR _bResult1$[esp+20], ebp
  000d2	75 08		 jne	 SHORT $L288003
  000d4	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR _bResult1$[esp+20], 1
$L288003:

; 4564 : 	if( pPropVis->dwReferTarget2 == NULL_ID ) bResult2 = TRUE;

  000dc	39 91 0c 02 00
	00		 cmp	 DWORD PTR [ecx+524], edx
  000e2	75 05		 jne	 SHORT $L276193
  000e4	bd 01 00 00 00	 mov	 ebp, 1
$L276193:

; 4565 : 
; 4566 : 	for( int i=0; i<pItemElem->GetPiercingSize(); i++ )

  000e9	8b cb		 mov	 ecx, ebx
  000eb	33 f6		 xor	 esi, esi
  000ed	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000f2	85 c0		 test	 eax, eax
  000f4	7e 66		 jle	 SHORT $L276197
$L276195:

; 4567 : 	{
; 4568 : 		if( pPropVis->dwReferTarget1 == pItemElem->GetPiercingItem( i ) )

  000f6	56		 push	 esi
  000f7	8b cb		 mov	 ecx, ebx
  000f9	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  000fe	8b 4c 24 10	 mov	 ecx, DWORD PTR $T287637[esp+24]
  00102	39 81 08 02 00
	00		 cmp	 DWORD PTR [ecx+520], eax
  00108	75 14		 jne	 SHORT $L276198

; 4569 : 			bResult1 = SetValidNeedVis( pItemElem, i, vecValid );

  0010a	8b 54 24 1c	 mov	 edx, DWORD PTR _pItemElem$[esp+20]
  0010e	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+24]
  00112	57		 push	 edi
  00113	56		 push	 esi
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; CMover::SetValidNeedVis
  0011a	89 44 24 24	 mov	 DWORD PTR _bResult1$[esp+20], eax
$L276198:

; 4570 : 
; 4571 : 		if( pPropVis->dwReferTarget2 == pItemElem->GetPiercingItem( i ) )

  0011e	56		 push	 esi
  0011f	8b cb		 mov	 ecx, ebx
  00121	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  00126	8b 4c 24 10	 mov	 ecx, DWORD PTR $T287637[esp+24]
  0012a	39 81 0c 02 00
	00		 cmp	 DWORD PTR [ecx+524], eax
  00130	75 12		 jne	 SHORT $L276199

; 4572 : 			bResult2 = SetValidNeedVis( pItemElem, i, vecValid );

  00132	8b 54 24 1c	 mov	 edx, DWORD PTR _pItemElem$[esp+20]
  00136	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+24]
  0013a	57		 push	 edi
  0013b	56		 push	 esi
  0013c	52		 push	 edx
  0013d	e8 00 00 00 00	 call	 ?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; CMover::SetValidNeedVis
  00142	8b e8		 mov	 ebp, eax
$L276199:

; 4573 : 
; 4574 : 		if( bResult1 && bResult2 )

  00144	8b 44 24 24	 mov	 eax, DWORD PTR _bResult1$[esp+20]
  00148	85 c0		 test	 eax, eax
  0014a	74 04		 je	 SHORT $L276196
  0014c	85 ed		 test	 ebp, ebp
  0014e	75 30		 jne	 SHORT $L287999
$L276196:

; 4565 : 
; 4566 : 	for( int i=0; i<pItemElem->GetPiercingSize(); i++ )

  00150	8b cb		 mov	 ecx, ebx
  00152	46		 inc	 esi
  00153	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00158	3b f0		 cmp	 esi, eax
  0015a	7c 9a		 jl	 SHORT $L276195
$L276197:

; 4578 : 		}
; 4579 : 	}
; 4580 : 
; 4581 : 	if( !bResult1 && bResult2 )

  0015c	8b 44 24 24	 mov	 eax, DWORD PTR _bResult1$[esp+20]
  00160	85 c0		 test	 eax, eax
  00162	75 37		 jne	 SHORT $L288001
  00164	85 ed		 test	 ebp, ebp
  00166	74 4f		 je	 SHORT $L276203

; 4582 : 		vecValid[nPos] = FAILED_1ST_NEEDVIS;

  00168	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0016b	8b 4c 24 20	 mov	 ecx, DWORD PTR _nPos$[esp+20]
  0016f	5d		 pop	 ebp
  00170	5b		 pop	 ebx
  00171	03 c1		 add	 eax, ecx
  00173	5f		 pop	 edi
  00174	c6 00 01	 mov	 BYTE PTR [eax], 1

; 4587 : 	return FALSE;

  00177	33 c0		 xor	 eax, eax
  00179	5e		 pop	 esi

; 4588 : }

  0017a	83 c4 08	 add	 esp, 8
  0017d	c2 0c 00	 ret	 12			; 0000000cH
$L287999:

; 4575 : 		{
; 4576 : 			vecValid[nPos] = SUCCSESS_NEEDVIS;

  00180	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00183	8b 4c 24 20	 mov	 ecx, DWORD PTR _nPos$[esp+20]
  00187	5d		 pop	 ebp
  00188	5b		 pop	 ebx
  00189	03 c1		 add	 eax, ecx
  0018b	5f		 pop	 edi
  0018c	c6 00 03	 mov	 BYTE PTR [eax], 3

; 4577 : 			return TRUE;

  0018f	b8 01 00 00 00	 mov	 eax, 1
  00194	5e		 pop	 esi

; 4588 : }

  00195	83 c4 08	 add	 esp, 8
  00198	c2 0c 00	 ret	 12			; 0000000cH
$L288001:

; 4583 : 	else if( bResult1 && !bResult2 )

  0019b	85 ed		 test	 ebp, ebp
  0019d	75 18		 jne	 SHORT $L276203

; 4584 : 		vecValid[nPos] = FAILED_2ND_NEEDVIS;

  0019f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001a2	8b 4c 24 20	 mov	 ecx, DWORD PTR _nPos$[esp+20]
  001a6	5d		 pop	 ebp
  001a7	5b		 pop	 ebx
  001a8	03 c1		 add	 eax, ecx
  001aa	5f		 pop	 edi
  001ab	c6 00 02	 mov	 BYTE PTR [eax], 2

; 4587 : 	return FALSE;

  001ae	33 c0		 xor	 eax, eax
  001b0	5e		 pop	 esi

; 4588 : }

  001b1	83 c4 08	 add	 esp, 8
  001b4	c2 0c 00	 ret	 12			; 0000000cH
$L276203:

; 4585 : 	else
; 4586 : 		vecValid[nPos] = FAILED_BOTH_NEEDVIS;

  001b7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001ba	8b 4c 24 20	 mov	 ecx, DWORD PTR _nPos$[esp+20]
  001be	5d		 pop	 ebp
  001bf	5b		 pop	 ebx
  001c0	03 c1		 add	 eax, ecx
  001c2	5f		 pop	 edi
  001c3	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4587 : 	return FALSE;

  001c6	33 c0		 xor	 eax, eax
  001c8	5e		 pop	 esi

; 4588 : }

  001c9	83 c4 08	 add	 esp, 8
  001cc	c2 0c 00	 ret	 12			; 0000000cH
?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; CMover::SetValidNeedVis
_TEXT	ENDS
PUBLIC	?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHDD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Replace
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHDD@Z
_TEXT	SEGMENT
_bCopied$276247 = -5					; size = 1
_nCount$ = -4						; size = 4
_chOld$ = 8						; size = 1
_chNew$ = 12						; size = 1
?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHDD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Replace, COMDAT
; _this$ = ecx

; 1192 : 	{

  00000	83 ec 08	 sub	 esp, 8

; 1193 : 		int nCount = 0;
; 1194 : 
; 1195 : 		// short-circuit the nop case
; 1196 : 		if( chOld != chNew )

  00003	8a 44 24 0c	 mov	 al, BYTE PTR _chOld$[esp+4]
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	8b d9		 mov	 ebx, ecx
  0000c	8a 4c 24 1c	 mov	 cl, BYTE PTR _chNew$[esp+16]
  00010	33 f6		 xor	 esi, esi
  00012	3a c1		 cmp	 al, cl
  00014	57		 push	 edi
  00015	89 74 24 14	 mov	 DWORD PTR _nCount$[esp+24], esi
  00019	0f 84 88 00 00
	00		 je	 $L288079

; 1197 : 		{
; 1198 : 			// otherwise modify each character that matches in the string
; 1199 : 			bool bCopied = false;
; 1200 : 			PXSTR pszBuffer = const_cast< PXSTR >( GetString() );  // We don't actually write to pszBuffer until we've called GetBuffer().

  0001f	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 1201 : 
; 1202 : 			int nLength = GetLength();

  00021	8b 6f f4	 mov	 ebp, DWORD PTR [edi-12]

; 1203 : 			int iChar = 0;
; 1204 : 			while( iChar < nLength )

  00024	3b ee		 cmp	 ebp, esi
  00026	c6 44 24 13 00	 mov	 BYTE PTR _bCopied$276247[esp+24], 0
  0002b	7e 7a		 jle	 SHORT $L288079
  0002d	8d 49 00	 npad	 3
$L276253:

; 1205 : 			{
; 1206 : 				// replace instances of the specified character only
; 1207 : 				if( pszBuffer[iChar] == chOld )

  00030	8a 4c 24 1c	 mov	 cl, BYTE PTR _chOld$[esp+20]
  00034	8a 14 3e	 mov	 dl, BYTE PTR [esi+edi]
  00037	3a d1		 cmp	 dl, cl
  00039	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0003c	75 3c		 jne	 SHORT $L276255

; 1208 : 				{
; 1209 : 					if( !bCopied )

  0003e	8a 44 24 13	 mov	 al, BYTE PTR _bCopied$276247[esp+24]
  00042	84 c0		 test	 al, al
  00044	75 27		 jne	 SHORT $L276256

; 1210 : 					{
; 1211 : 						bCopied = true;
; 1212 : 						pszBuffer = GetBuffer( nLength );

  00046	8b 03		 mov	 eax, DWORD PTR [ebx]
  00048	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0004b	83 e8 10	 sub	 eax, 16			; 00000010H
  0004e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00051	ba 01 00 00 00	 mov	 edx, 1
  00056	2b d1		 sub	 edx, ecx
  00058	2b c5		 sub	 eax, ebp
  0005a	0b d0		 or	 edx, eax
  0005c	c6 44 24 13 01	 mov	 BYTE PTR _bCopied$276247[esp+24], 1
  00061	7d 08		 jge	 SHORT $L288043
  00063	55		 push	 ebp
  00064	8b cb		 mov	 ecx, ebx
  00066	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L288043:
  0006b	8b 3b		 mov	 edi, DWORD PTR [ebx]
$L276256:

; 1213 : 					}
; 1214 : 					pszBuffer[iChar] = chNew;

  0006d	8a 4c 24 20	 mov	 cl, BYTE PTR _chNew$[esp+20]
  00071	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00074	88 08		 mov	 BYTE PTR [eax], cl

; 1215 : 					nCount++;

  00076	ff 44 24 14	 inc	 DWORD PTR _nCount$[esp+24]
$L276255:

; 1216 : 				}
; 1217 : 				iChar = int( StringTraits::CharNext( pszBuffer+iChar )-pszBuffer );

  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 __mbsinc
  00080	8b f0		 mov	 esi, eax
  00082	2b f7		 sub	 esi, edi
  00084	83 c4 04	 add	 esp, 4
  00087	3b f5		 cmp	 esi, ebp
  00089	7c a5		 jl	 SHORT $L276253

; 1218 : 			}
; 1219 : 			if( bCopied )

  0008b	8a 44 24 13	 mov	 al, BYTE PTR _bCopied$276247[esp+24]
  0008f	84 c0		 test	 al, al
  00091	74 14		 je	 SHORT $L288079

; 1220 : 			{
; 1221 : 				ReleaseBufferSetLength( nLength );

  00093	85 ed		 test	 ebp, ebp
  00095	7c 1e		 jl	 SHORT $L288073
  00097	8b 03		 mov	 eax, DWORD PTR [ebx]
  00099	3b 68 f8	 cmp	 ebp, DWORD PTR [eax-8]
  0009c	7f 17		 jg	 SHORT $L288073
  0009e	89 68 f4	 mov	 DWORD PTR [eax-12], ebp
  000a1	8b 13		 mov	 edx, DWORD PTR [ebx]
  000a3	c6 04 2a 00	 mov	 BYTE PTR [edx+ebp], 0
$L288079:

; 1222 : 			}
; 1223 : 		}
; 1224 : 
; 1225 : 		return( nCount );

  000a7	8b 44 24 14	 mov	 eax, DWORD PTR _nCount$[esp+24]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5d		 pop	 ebp
  000ae	5b		 pop	 ebx

; 1226 : 	}

  000af	83 c4 08	 add	 esp, 8
  000b2	c2 08 00	 ret	 8

; 1220 : 			{
; 1221 : 				ReleaseBufferSetLength( nLength );

$L288073:
  000b5	68 57 00 07 80	 push	 -2147024809		; 80070057H
  000ba	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L288081:
$L288080:
  000bf	cc		 int	 3
?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHDD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Replace
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
$T288088 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00001	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	53		 push	 ebx
  00008	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000b	84 db		 test	 bl, bl
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Keyval$[esp+12]
  00013	75 17		 jne	 SHORT $L288183
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$L288182:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $L288184
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $L288185
$L288184:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$L288185:
  00025	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00028	84 db		 test	 bl, bl
  0002a	74 eb		 je	 SHORT $L288182
$L288183:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	3b d0		 cmp	 edx, eax
  00031	89 54 24 18	 mov	 DWORD PTR __Where$[esp+12], edx
  00035	74 1a		 je	 SHORT $L288087
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003c	72 13		 jb	 SHORT $L288087
  0003e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$[esp+12]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 10		 mov	 DWORD PTR [eax], edx
  0004c	5b		 pop	 ebx

; 791  : 		}

  0004d	59		 pop	 ecx
  0004e	c2 08 00	 ret	 8
$L288087:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  00051	89 44 24 0c	 mov	 DWORD PTR $T288088[esp+16], eax
  00055	8d 44 24 0c	 lea	 eax, DWORD PTR $T288088[esp+16]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	89 10		 mov	 DWORD PTR [eax], edx
  00063	5b		 pop	 ebx

; 791  : 		}

  00064	59		 pop	 ecx
  00065	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::find
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV, COMDAT
; _this$ = ecx

; 1855 : 	{

  00000	53		 push	 ebx

; 1856 : 		ATLASSERT( AtlIsValidString( pszFormat ) );
; 1857 : 		if(pszFormat == NULL)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _pszFormat$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	75 0a		 jne	 SHORT $L277301

; 1858 : 			AtlThrow(E_INVALIDARG);

  0000c	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00011	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L288315:
$L277301:
  00016	55		 push	 ebp

; 1859 : 
; 1860 : 		int nLength = StringTraits::GetFormattedLength( pszFormat, args );

  00017	8b 6c 24 14	 mov	 ebp, DWORD PTR _args$[esp+8]
  0001b	56		 push	 esi
  0001c	55		 push	 ebp
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 __vscprintf
  00023	8b f0		 mov	 esi, eax

; 1861 : 		PXSTR pszBuffer = GetBuffer( nLength );

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
  00027	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002a	83 e8 10	 sub	 eax, 16			; 00000010H
  0002d	b9 01 00 00 00	 mov	 ecx, 1
  00032	2b ca		 sub	 ecx, edx
  00034	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00037	2b d6		 sub	 edx, esi
  00039	83 c4 08	 add	 esp, 8
  0003c	0b ca		 or	 ecx, edx
  0003e	7d 08		 jge	 SHORT $L288281
  00040	56		 push	 esi
  00041	8b cf		 mov	 ecx, edi
  00043	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L288281:

; 1862 : 		StringTraits::Format( pszBuffer, pszFormat, args );

  00048	8b 07		 mov	 eax, DWORD PTR [edi]
  0004a	55		 push	 ebp
  0004b	53		 push	 ebx
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _vsprintf
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1863 : 		ReleaseBufferSetLength( nLength );

  00055	85 f6		 test	 esi, esi
  00057	7c 17		 jl	 SHORT $L288310
  00059	8b 07		 mov	 eax, DWORD PTR [edi]
  0005b	3b 70 f8	 cmp	 esi, DWORD PTR [eax-8]
  0005e	7f 10		 jg	 SHORT $L288310
  00060	89 70 f4	 mov	 DWORD PTR [eax-12], esi
  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	c6 04 0e 00	 mov	 BYTE PTR [esi+ecx], 0
  00069	5e		 pop	 esi
  0006a	5d		 pop	 ebp
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx

; 1864 : 	}

  0006d	c2 08 00	 ret	 8
$L288310:
  00070	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00075	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L288316:
$L288314:
  0007a	cc		 int	 3
?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L288378
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L288378:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 27   : 		return (_Str.c_str());

  00000	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L288411
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  00009	c3		 ret	 0

; 27   : 		return (_Str.c_str());

$L288411:
  0000a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  0000d	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L288418
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L288418:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 1969 : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1970 : 		HINSTANCE hInst = StringTraits::FindStringResourceInstance( nID );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nID$[esp+4]
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle

; 1971 : 		if( hInst == NULL )

  0000e	85 c0		 test	 eax, eax
  00010	75 05		 jne	 SHORT $L218601
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi

; 1977 : 	}

  00014	c2 04 00	 ret	 4
$L218601:

; 1972 : 		{
; 1973 : 			return( FALSE );
; 1974 : 		}
; 1975 : 
; 1976 : 		return( LoadString( hInst, nID ) );		

  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1977 : 	}

  00022	c2 04 00	 ret	 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT
$T288431 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00001	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	53		 push	 ebx
  00008	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000b	84 db		 test	 bl, bl
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Keyval$[esp+12]
  00013	75 17		 jne	 SHORT $L288507
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$L288506:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	73 05		 jae	 SHORT $L288508
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $L288509
$L288508:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$L288509:
  00025	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00028	84 db		 test	 bl, bl
  0002a	74 eb		 je	 SHORT $L288506
$L288507:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	3b d0		 cmp	 edx, eax
  00031	89 54 24 18	 mov	 DWORD PTR __Where$[esp+12], edx
  00035	74 1a		 je	 SHORT $L288430
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003c	72 13		 jb	 SHORT $L288430
  0003e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$[esp+12]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 10		 mov	 DWORD PTR [eax], edx
  0004c	5b		 pop	 ebx

; 791  : 		}

  0004d	59		 pop	 ecx
  0004e	c2 08 00	 ret	 8
$L288430:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  00051	89 44 24 0c	 mov	 DWORD PTR $T288431[esp+16], eax
  00055	8d 44 24 0c	 lea	 eax, DWORD PTR $T288431[esp+16]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	89 10		 mov	 DWORD PTR [eax], edx
  00063	5b		 pop	 ebx

; 791  : 		}

  00064	59		 pop	 ecx
  00065	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find
_TEXT	ENDS
PUBLIC	?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad, COMDAT
; _this$ = ecx

; 2229 : 	{

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2230 : 		bool bRet = false;
; 2231 : 
; 2232 : 		if( (pv != NULL) && IS_INTRESOURCE( pv ) )

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _pv$[esp]
  00007	32 c0		 xor	 al, al
  00009	85 c9		 test	 ecx, ecx
  0000b	74 22		 je	 SHORT $L219935
  0000d	f7 c1 00 00 ff
	ff		 test	 ecx, -65536		; ffff0000H
  00013	75 1a		 jne	 SHORT $L219935
  00015	56		 push	 esi

; 2233 : 		{
; 2234 : 			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );

  00016	0f b7 f1	 movzx	 esi, cx

; 2235 : 			if( !LoadString( nID ) )

  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle
  0001f	85 c0		 test	 eax, eax
  00021	74 09		 je	 SHORT $L288596
  00023	56		 push	 esi
  00024	50		 push	 eax
  00025	8b cf		 mov	 ecx, edi
  00027	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
$L288596:

; 2236 : 			{
; 2237 : 				ATLTRACE( atlTraceString, 2, _T( "Warning: implicit LoadString(%u) failed\n" ), nID );
; 2238 : 			}
; 2239 : 			bRet = true;

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi
$L219935:
  0002f	5f		 pop	 edi

; 2240 : 		}
; 2241 : 
; 2242 : 		return( bRet );
; 2243 : 	}

  00030	c2 04 00	 ret	 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 591  : 		if (_Right.size() < _Roff)

  00003	8b 74 24 14	 mov	 esi, DWORD PTR __Roff$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 14	 mov	 edi, DWORD PTR __Right$[esp+12]
  0000c	39 77 14	 cmp	 DWORD PTR [edi+20], esi
  0000f	8b d9		 mov	 ebx, ecx
  00011	73 05		 jae	 SHORT $L220001

; 592  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L220001:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 6f 14	 mov	 ebp, DWORD PTR [edi+20]

; 594  : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b ee		 sub	 ebp, esi
  00021	3b c5		 cmp	 eax, ebp
  00023	73 02		 jae	 SHORT $L220003

; 595  : 			_Num = _Count;	// trim _Num to size

  00025	8b e8		 mov	 ebp, eax
$L220003:

; 596  : 
; 597  : 		if (this == &_Right)

  00027	3b df		 cmp	 ebx, edi
  00029	75 1f		 jne	 SHORT $L220004

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 ee		 add	 ebp, esi
  0002f	55		 push	 ebp
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00037	56		 push	 esi
  00038	6a 00		 push	 0
  0003a	8b cb		 mov	 ecx, ebx
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00044	8b c3		 mov	 eax, ebx
  00046	5b		 pop	 ebx

; 605  : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$L220004:

; 599  : 		else if (_Grow(_Num))

  0004a	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  0004d	76 07		 jbe	 SHORT $L288713
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L288713:
  00056	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00059	3b c5		 cmp	 eax, ebp
  0005b	73 21		 jae	 SHORT $L288714
  0005d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00060	50		 push	 eax
  00061	55		 push	 ebp
  00062	8b cb		 mov	 ecx, ebx
  00064	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00069	85 ed		 test	 ebp, ebp
$L288801:
  0006b	76 6d		 jbe	 SHORT $L288800

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0006d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00070	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00075	3b c8		 cmp	 ecx, eax
  00077	72 2f		 jb	 SHORT $L288766
  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	eb 2d		 jmp	 SHORT $L288767

; 599  : 		else if (_Grow(_Num))

$L288714:
  0007e	85 ed		 test	 ebp, ebp
  00080	75 e9		 jne	 SHORT $L288801
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00088	72 0f		 jb	 SHORT $L288757
  0008a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00093	8b c3		 mov	 eax, ebx
  00095	5b		 pop	 ebx

; 605  : 		}

  00096	c2 0c 00	 ret	 12			; 0000000cH

; 599  : 		else if (_Grow(_Num))

$L288757:
  00099	5f		 pop	 edi
  0009a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009d	5e		 pop	 esi
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a1	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000a2	8b c3		 mov	 eax, ebx
  000a4	5b		 pop	 ebx

; 605  : 		}

  000a5	c2 0c 00	 ret	 12			; 0000000cH

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$L288766:
  000a8	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
$L288767:
  000ab	39 43 18	 cmp	 DWORD PTR [ebx+24], eax
  000ae	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000b1	72 04		 jb	 SHORT $L288772
  000b3	8b 38		 mov	 edi, DWORD PTR [eax]
  000b5	eb 02		 jmp	 SHORT $L288773
$L288772:
  000b7	8b f8		 mov	 edi, eax
$L288773:
  000b9	03 f2		 add	 esi, edx
  000bb	8b cd		 mov	 ecx, ebp
  000bd	8b d1		 mov	 edx, ecx
  000bf	c1 e9 02	 shr	 ecx, 2
  000c2	f3 a5		 rep movsd
  000c4	8b ca		 mov	 ecx, edx
  000c6	83 e1 03	 and	 ecx, 3
  000c9	f3 a4		 rep movsb

; 602  : 			_Eos(_Num);

  000cb	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000cf	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000d2	72 02		 jb	 SHORT $L288795
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
$L288795:
  000d6	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L288800:
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000dd	8b c3		 mov	 eax, ebx
  000df	5b		 pop	 ebx

; 605  : 		}

  000e0	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 579  : 	{

  00000	56		 push	 esi

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pszSrc$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 0d		 jne	 SHORT $L288808
  00009	33 c0		 xor	 eax, eax
  0000b	50		 push	 eax
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00012	5e		 pop	 esi

; 581  : 	}

  00013	c2 04 00	 ret	 4

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

$L288808:
  00016	8b c6		 mov	 eax, esi
  00018	57		 push	 edi
  00019	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001c	8d 64 24 00	 npad	 4
$L288810:
  00020	8a 10		 mov	 dl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 d2		 test	 dl, dl
  00025	75 f9		 jne	 SHORT $L288810
  00027	2b c7		 sub	 eax, edi
  00029	5f		 pop	 edi
  0002a	50		 push	 eax
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00031	5e		 pop	 esi

; 581  : 	}

  00032	c2 04 00	 ret	 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 609  : 		if (_Inside(_Ptr))

  00003	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	72 05		 jb	 SHORT $L288831
  0000d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00010	eb 03		 jmp	 SHORT $L288832
$L288831:
  00012	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$L288832:
  00015	8b 74 24 10	 mov	 esi, DWORD PTR __Ptr$[esp+8]
  00019	3b f0		 cmp	 esi, eax
  0001b	72 34		 jb	 SHORT $L221367
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00023	72 04		 jb	 SHORT $L288835
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $L288836
$L288835:
  00029	8b c8		 mov	 ecx, eax
$L288836:
  0002b	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  0002e	03 f9		 add	 edi, ecx
  00030	3b fe		 cmp	 edi, esi
  00032	76 1d		 jbe	 SHORT $L221367

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  00034	83 fa 10	 cmp	 edx, 16			; 00000010H
  00037	72 02		 jb	 SHORT $L288848
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$L288848:
  0003b	8b 4c 24 14	 mov	 ecx, DWORD PTR __Num$[esp+8]
  0003f	51		 push	 ecx
  00040	2b f0		 sub	 esi, eax
  00042	56		 push	 esi
  00043	53		 push	 ebx
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 618  : 		}

  0004e	c2 08 00	 ret	 8
$L221367:
  00051	55		 push	 ebp

; 611  : 
; 612  : 		if (_Grow(_Num))

  00052	8b 6c 24 18	 mov	 ebp, DWORD PTR __Num$[esp+12]
  00056	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  00059	76 07		 jbe	 SHORT $L288989
  0005b	8b cb		 mov	 ecx, ebx
  0005d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L288989:
  00062	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00065	3b c5		 cmp	 eax, ebp
  00067	73 1b		 jae	 SHORT $L288990
  00069	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  0006c	52		 push	 edx
  0006d	55		 push	 ebp
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00075	85 ed		 test	 ebp, ebp
$L289028:
  00077	76 68		 jbe	 SHORT $L289025

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00079	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0007d	72 2f		 jb	 SHORT $L289000
  0007f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00082	eb 2d		 jmp	 SHORT $L289001

; 611  : 
; 612  : 		if (_Grow(_Num))

$L288990:
  00084	85 ed		 test	 ebp, ebp
  00086	75 ef		 jne	 SHORT $L289028
  00088	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008b	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  0008e	72 0f		 jb	 SHORT $L288982
  00090	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00093	5d		 pop	 ebp
  00094	5f		 pop	 edi
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0
  00098	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  00099	8b c3		 mov	 eax, ebx
  0009b	5b		 pop	 ebx

; 618  : 		}

  0009c	c2 08 00	 ret	 8

; 611  : 
; 612  : 		if (_Grow(_Num))

$L288982:
  0009f	5d		 pop	 ebp
  000a0	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000a3	5f		 pop	 edi
  000a4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a7	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx

; 618  : 		}

  000ab	c2 08 00	 ret	 8

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

$L289000:
  000ae	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
$L289001:
  000b1	8b cd		 mov	 ecx, ebp
  000b3	8b c1		 mov	 eax, ecx
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb

; 615  : 			_Eos(_Num);

  000c1	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000c5	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000c8	72 10		 jb	 SHORT $L289023
  000ca	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000cd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  000d1	5d		 pop	 ebp
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000d4	8b c3		 mov	 eax, ebx
  000d6	5b		 pop	 ebx

; 618  : 		}

  000d7	c2 08 00	 ret	 8

; 615  : 			_Eos(_Num);

$L289023:
  000da	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000dd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L289025:
  000e1	5d		 pop	 ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000e4	8b c3		 mov	 eax, ebx
  000e6	5b		 pop	 ebx

; 618  : 		}

  000e7	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?DoUseItemKeep@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemKeep
EXTRN	?AddBuff@CMover@@QAEHGGKKK@Z:NEAR		; CMover::AddBuff
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
;	COMDAT ?DoUseItemKeep@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z
_TEXT	SEGMENT
_i$275222 = -4						; size = 4
_i$275313 = 8						; size = 4
_pItemProp$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
_nPart$ = 16						; size = 4
?DoUseItemKeep@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z PROC NEAR ; CMover::DoUseItemKeep, COMDAT
; _this$ = ecx

; 2996 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	56		 push	 esi
  00003	8b f1		 mov	 esi, ecx

; 2997 : #ifdef __WORLDSERVER
; 2998 : #ifdef __NEW_STACKABLE_AMPS
; 2999 : // First Check how many Amps are currently active.
; 3000 : 	int nAmount = 0;
; 3001 : 
; 3002 : 	for( MAPBUFF::iterator i = m_buffs.m_mapBuffs.begin(); i != m_buffs.m_mapBuffs.end(); ++i )

  00005	8b 8e f8 02 00
	00		 mov	 ecx, DWORD PTR [esi+760]
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	33 db		 xor	 ebx, ebx
  0000f	3b c1		 cmp	 eax, ecx
  00011	57		 push	 edi
  00012	89 44 24 0c	 mov	 DWORD PTR _i$275222[esp+16], eax
  00016	74 56		 je	 SHORT $L289228
  00018	8b 3d 5c 02 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+604
  0001e	8b ff		 npad	 2
$L289227:

; 3003 : 	{
; 3004 : 		ItemProp* pItemProp = prj.GetItemProp( i->second->GetId());

  00020	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00023	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  00027	85 c0		 test	 eax, eax
  00029	0f 8c fe 00 00
	00		 jl	 $L289151
  0002f	3b c7		 cmp	 eax, edi
  00031	0f 8d f6 00 00
	00		 jge	 $L289151
  00037	73 17		 jae	 SHORT $L275226
  00039	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0003f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 3005 : 
; 3006 : 		if( pItemProp )

  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $L275226

; 3007 : 		{
; 3008 : 			if( pItemProp->dwItemKind3 == IK3_EXP_RATE )

  00046	81 78 78 a4 00
	00 00		 cmp	 DWORD PTR [eax+120], 164 ; 000000a4H
  0004d	75 01		 jne	 SHORT $L275226

; 3009 : 			{
; 3010 : 				nAmount++;

  0004f	43		 inc	 ebx
$L275226:

; 2997 : #ifdef __WORLDSERVER
; 2998 : #ifdef __NEW_STACKABLE_AMPS
; 2999 : // First Check how many Amps are currently active.
; 3000 : 	int nAmount = 0;
; 3001 : 
; 3002 : 	for( MAPBUFF::iterator i = m_buffs.m_mapBuffs.begin(); i != m_buffs.m_mapBuffs.end(); ++i )

  00050	8d 4c 24 0c	 lea	 ecx, DWORD PTR _i$275222[esp+16]
  00054	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc
  00059	8b 44 24 0c	 mov	 eax, DWORD PTR _i$275222[esp+16]
  0005d	3b 86 f8 02 00
	00		 cmp	 eax, DWORD PTR [esi+760]
  00063	75 bb		 jne	 SHORT $L289227

; 3011 : 			}
; 3012 : 		}
; 3013 : 	}
; 3014 : // Cant hold more Amps
; 3015 : 	if( nAmount >= MAX_AMP_STACK_COUNT )

  00065	83 fb 05	 cmp	 ebx, 5

; 3016 : 	{
; 3017 : 		return 2;

  00068	0f 8d b3 00 00
	00		 jge	 $L289231
$L289228:

; 3018 : 	}
; 3019 : // Check Level
; 3020 : 	if( GetLevel() < pItemProp->nMinLimitLevel || GetLevel() > pItemProp->nMaxLimitLevel )

  0006e	8b 5c 24 14	 mov	 ebx, DWORD PTR _pItemProp$[esp+12]
  00072	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  00078	3b 83 bc 02 00
	00		 cmp	 eax, DWORD PTR [ebx+700]
  0007e	0f 8c cc 01 00
	00		 jl	 $L275233
  00084	3b 83 c0 02 00
	00		 cmp	 eax, DWORD PTR [ebx+704]
  0008a	0f 8f c0 01 00
	00		 jg	 $L275233

; 3023 : 	}
; 3024 : // Can hold more Amps. Try activating scroll
; 3025 : 	if( HasBuff( BUFF_ITEM, (WORD) ( pItemProp->dwID )))

  00090	33 d2		 xor	 edx, edx
  00092	66 8b 13	 mov	 dx, WORD PTR [ebx]
  00095	8b ce		 mov	 ecx, esi
  00097	52		 push	 edx
  00098	6a 00		 push	 0
  0009a	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0009f	85 c0		 test	 eax, eax
  000a1	0f 84 6a 01 00
	00		 je	 $L275235

; 3026 : 	{
; 3027 : 		MAPAMPSTORE::iterator i	= prj.m_mapAmpStore.find( pItemProp->dwID );

  000a7	53		 push	 ebx
  000a8	8d 44 24 18	 lea	 eax, DWORD PTR _i$275313[esp+16]
  000ac	50		 push	 eax
  000ad	b9 2c 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+44
  000b2	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAUAMP_STORE_INFO@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAUAMP_STORE_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,AMP_STORE_INFO *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,AMP_STORE_INFO *> >,0> >::find

; 3028 : 		if( i != prj.m_mapAmpStore.end() )

  000b7	8b 44 24 14	 mov	 eax, DWORD PTR _i$275313[esp+12]
  000bb	3b 05 30 00 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+48
  000c1	0f 84 3e 01 00
	00		 je	 $L275359

; 3029 : 		{
; 3030 : 			AMP_STORE_INFO* info = i->second;

  000c7	8b 78 10	 mov	 edi, DWORD PTR [eax+16]

; 3031 : 			if( HasBuff( BUFF_ITEM, (WORD)(info->dwIDSecond)))

  000ca	33 c9		 xor	 ecx, ecx
  000cc	66 8b 0f	 mov	 cx, WORD PTR [edi]
  000cf	51		 push	 ecx
  000d0	6a 00		 push	 0
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  000d9	85 c0		 test	 eax, eax
  000db	0f 84 ef 00 00
	00		 je	 $L275339

; 3032 : 			{
; 3033 : 				if( HasBuff( BUFF_ITEM, (WORD)(info->dwIDThird)))

  000e1	33 d2		 xor	 edx, edx
  000e3	66 8b 57 04	 mov	 dx, WORD PTR [edi+4]
  000e7	8b ce		 mov	 ecx, esi
  000e9	52		 push	 edx
  000ea	6a 00		 push	 0
  000ec	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  000f1	85 c0		 test	 eax, eax
  000f3	0f 84 a1 00 00
	00		 je	 $L275341

; 3034 : 				{
; 3035 : 					if( HasBuff( BUFF_ITEM, (WORD) (info->dwIDFourth)))

  000f9	33 c0		 xor	 eax, eax
  000fb	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  000ff	8b ce		 mov	 ecx, esi
  00101	50		 push	 eax
  00102	6a 00		 push	 0
  00104	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00109	85 c0		 test	 eax, eax
  0010b	74 53		 je	 SHORT $L275343

; 3036 : 					{
; 3037 : 						if( HasBuff( BUFF_ITEM, (WORD) (info->dwIDFifth)))

  0010d	33 c9		 xor	 ecx, ecx
  0010f	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]
  00113	51		 push	 ecx
  00114	6a 00		 push	 0
  00116	8b ce		 mov	 ecx, esi
  00118	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0011d	85 c0		 test	 eax, eax
  0011f	74 2d		 je	 SHORT $L275345
$L289231:
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi

; 3038 : 						{
; 3039 : 							return 2;

  00123	b8 02 00 00 00	 mov	 eax, 2
  00128	5b		 pop	 ebx

; 3092 : }

  00129	59		 pop	 ecx
  0012a	c2 0c 00	 ret	 12			; 0000000cH

; 3003 : 	{
; 3004 : 		ItemProp* pItemProp = prj.GetItemProp( i->second->GetId());

$L289151:
  0012d	50		 push	 eax
  0012e	57		 push	 edi
  0012f	6a 00		 push	 0
  00131	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00136	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0013b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 3005 : 
; 3006 : 		if( pItemProp )

  00140	8b 3d 5c 02 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+604
  00146	83 c4 14	 add	 esp, 20			; 00000014H
  00149	e9 02 ff ff ff	 jmp	 $L275226
$L275345:

; 3040 : 						}
; 3041 : 						else
; 3042 : 						{
; 3043 : 							if( pItemProp->nMaxDuplication >= 5 )

  0014e	83 bb cc 02 00
	00 05		 cmp	 DWORD PTR [ebx+716], 5
  00155	0f 8c aa 00 00
	00		 jl	 $L275359

; 3044 : 							{
; 3045 : 								ItemProp* pAmpProp = prj.GetItemProp( info->dwIDFifth );

  0015b	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]

; 3046 : 								DoApplySkill( (CCtrl*)this, pAmpProp, NULL );
; 3047 : 								return 4;

  0015e	eb 7b		 jmp	 SHORT $L289230
$L275343:

; 3048 : 							}
; 3049 : 						}
; 3050 : 					}
; 3051 : 					else
; 3052 : 					{
; 3053 : 						if( pItemProp->nMaxDuplication >= 4 )

  00160	83 bb cc 02 00
	00 04		 cmp	 DWORD PTR [ebx+716], 4
  00167	0f 8c 98 00 00
	00		 jl	 $L275359

; 3054 : 						{
; 3055 : 							ItemProp* pAmpProp = prj.GetItemProp( info->dwIDFourth );

  0016d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00170	50		 push	 eax
  00171	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00176	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 3056 : 							DoApplySkill( (CCtrl*)this, pAmpProp, NULL );

  0017b	6a 00		 push	 0
  0017d	6a 00		 push	 0
  0017f	6a 00		 push	 0
  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	50		 push	 eax
  00186	56		 push	 esi
  00187	8b ce		 mov	 ecx, esi
  00189	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi

; 3057 : 							return 4;

  00190	b8 04 00 00 00	 mov	 eax, 4
  00195	5b		 pop	 ebx

; 3092 : }

  00196	59		 pop	 ecx
  00197	c2 0c 00	 ret	 12			; 0000000cH
$L275341:

; 3058 : 						}
; 3059 : 					}
; 3060 : 				}
; 3061 : 				else
; 3062 : 				{
; 3063 : 					if( pItemProp->nMaxDuplication >= 3 )

  0019a	83 bb cc 02 00
	00 03		 cmp	 DWORD PTR [ebx+716], 3
  001a1	7c 62		 jl	 SHORT $L275359

; 3064 : 					{
; 3065 : 						ItemProp* pAmpProp = prj.GetItemProp( info->dwIDThird );

  001a3	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  001a6	51		 push	 ecx
  001a7	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  001ac	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 3066 : 						DoApplySkill( (CCtrl*)this, pAmpProp, NULL );

  001b1	6a 00		 push	 0
  001b3	6a 00		 push	 0
  001b5	6a 00		 push	 0
  001b7	6a 00		 push	 0
  001b9	6a 00		 push	 0
  001bb	50		 push	 eax
  001bc	56		 push	 esi
  001bd	8b ce		 mov	 ecx, esi
  001bf	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  001c4	5f		 pop	 edi
  001c5	5e		 pop	 esi

; 3067 : 						return 4;

  001c6	b8 04 00 00 00	 mov	 eax, 4
  001cb	5b		 pop	 ebx

; 3092 : }

  001cc	59		 pop	 ecx
  001cd	c2 0c 00	 ret	 12			; 0000000cH
$L275339:

; 3068 : 					}
; 3069 : 				}
; 3070 : 			}
; 3071 : 			else
; 3072 : 			{
; 3073 : 				if( pItemProp->nMaxDuplication >= 2 )

  001d0	83 bb cc 02 00
	00 02		 cmp	 DWORD PTR [ebx+716], 2
  001d7	7c 2c		 jl	 SHORT $L275359

; 3074 : 				{
; 3075 : 					ItemProp* pAmpProp = prj.GetItemProp( info->dwIDSecond );

  001d9	8b 17		 mov	 edx, DWORD PTR [edi]
$L289230:
  001db	52		 push	 edx
  001dc	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  001e1	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 3076 : 					DoApplySkill( (CCtrl*)this, pAmpProp, NULL );

  001e6	6a 00		 push	 0
  001e8	6a 00		 push	 0
  001ea	6a 00		 push	 0
  001ec	6a 00		 push	 0
  001ee	6a 00		 push	 0
  001f0	50		 push	 eax
  001f1	56		 push	 esi
  001f2	8b ce		 mov	 ecx, esi
  001f4	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi

; 3077 : 					return 4;

  001fb	b8 04 00 00 00	 mov	 eax, 4
  00200	5b		 pop	 ebx

; 3092 : }

  00201	59		 pop	 ecx
  00202	c2 0c 00	 ret	 12			; 0000000cH
$L275359:
  00205	5f		 pop	 edi
  00206	5e		 pop	 esi

; 3088 : 	}
; 3089 : #endif // __NEW_STACKABLE_AMPS
; 3090 : #endif // __WORLDSERVER
; 3091 : 	return 3;

  00207	b8 03 00 00 00	 mov	 eax, 3
  0020c	5b		 pop	 ebx

; 3092 : }

  0020d	59		 pop	 ecx
  0020e	c2 0c 00	 ret	 12			; 0000000cH
$L275235:

; 3078 : 				}
; 3079 : 			}
; 3080 : 		}
; 3081 : 	}
; 3082 : 	else
; 3083 : 	{
; 3084 : //		DoApplySkill( (CCtrl*)this, pItemProp, NULL );
; 3085 : 		Error( "%d", (DWORD)pItemProp->dwSkillTime );

  00211	8b 83 f0 01 00
	00		 mov	 eax, DWORD PTR [ebx+496]
  00217	50		 push	 eax
  00218	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0021d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 3086 : 		AddBuff( BUFF_ITEM, (WORD)(pItemProp->dwID), 0, pItemProp->dwSkillTime, GetId() );

  00222	8b 8e bc 01 00
	00		 mov	 ecx, DWORD PTR [esi+444]
  00228	8b 93 f0 01 00
	00		 mov	 edx, DWORD PTR [ebx+496]
  0022e	83 c4 08	 add	 esp, 8
  00231	51		 push	 ecx
  00232	33 c0		 xor	 eax, eax
  00234	66 8b 03	 mov	 ax, WORD PTR [ebx]
  00237	52		 push	 edx
  00238	6a 00		 push	 0
  0023a	8b ce		 mov	 ecx, esi
  0023c	50		 push	 eax
  0023d	6a 00		 push	 0
  0023f	e8 00 00 00 00	 call	 ?AddBuff@CMover@@QAEHGGKKK@Z ; CMover::AddBuff
  00244	5f		 pop	 edi
  00245	5e		 pop	 esi

; 3087 : 		return 4;

  00246	b8 04 00 00 00	 mov	 eax, 4
  0024b	5b		 pop	 ebx

; 3092 : }

  0024c	59		 pop	 ecx
  0024d	c2 0c 00	 ret	 12			; 0000000cH
$L275233:
  00250	5f		 pop	 edi
  00251	5e		 pop	 esi

; 3021 : 	{
; 3022 : 		return 1;

  00252	b8 01 00 00 00	 mov	 eax, 1
  00257	5b		 pop	 ebx

; 3092 : }

  00258	59		 pop	 ecx
  00259	c2 0c 00	 ret	 12			; 0000000cH
?DoUseItemKeep@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ENDP ; CMover::DoUseItemKeep
_TEXT	ENDS
PUBLIC	?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format, COMDAT

; 1796 : 		ATLASSERT( AtlIsValidString( pszFormat ) );
; 1797 : 		
; 1798 : 		va_list argList;
; 1799 : 		va_start( argList, pszFormat );
; 1800 : 		FormatV( pszFormat, argList );

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _pszFormat$[esp-4]
  00004	8d 44 24 0c	 lea	 eax, DWORD PTR _pszFormat$[esp]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+4]
  0000e	e8 00 00 00 00	 call	 ?FormatV@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::FormatV

; 1801 : 		va_end( argList );
; 1802 : 	}

  00013	c3		 ret	 0
?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format
_TEXT	ENDS
PUBLIC	?GetUserByID@CProject@@QAEPAVCMover@@K@Z	; CProject::GetUserByID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
;	COMDAT ?GetUserByID@CProject@@QAEPAVCMover@@K@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_idPlayer$ = 8						; size = 4
?GetUserByID@CProject@@QAEPAVCMover@@K@Z PROC NEAR	; CProject::GetUserByID, COMDAT
; _this$ = ecx

; 1409 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1410 : 	map<u_long, CMover*>::iterator i = m_idPlayerToUserPtr.find( idPlayer );

  00004	8d 44 24 0c	 lea	 eax, DWORD PTR _idPlayer$[esp+4]
  00008	50		 push	 eax
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR _i$[esp+12]
  0000d	51		 push	 ecx
  0000e	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00011	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCMover@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCMover@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CMover *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CMover *> >,0> >::find

; 1411 : 	if( i != m_idPlayerToUserPtr.end() )

  00016	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00019	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp+8]
  0001d	3b c1		 cmp	 eax, ecx
  0001f	5e		 pop	 esi
  00020	74 07		 je	 SHORT $L198064

; 1412 : 		return i->second;

  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1414 : }

  00025	59		 pop	 ecx
  00026	c2 04 00	 ret	 4
$L198064:

; 1413 : 	return NULL;

  00029	33 c0		 xor	 eax, eax

; 1414 : }

  0002b	59		 pop	 ecx
  0002c	c2 04 00	 ret	 4
?GetUserByID@CProject@@QAEPAVCMover@@K@Z ENDP		; CProject::GetUserByID
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

  00000	56		 push	 esi

; 324  : 		_Tidy();

  00001	33 c0		 xor	 eax, eax
  00003	8b f1		 mov	 esi, ecx

; 325  : 		assign(_Right, 0, npos);

  00005	6a ff		 push	 -1
  00007	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	50		 push	 eax
  00012	88 46 04	 mov	 BYTE PTR [esi+4], al
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Right$[esp+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z	; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 316  : 		SetString( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L289367
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 319  : 	}

  00017	c2 04 00	 ret	 4

; 316  : 		SetString( pszSrc );

$L289367:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L289368:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L289368
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 319  : 	}

  00036	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L289375:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L289375
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 623  : 		}

  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	?DoUseItemWarp@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CMover::DoUseItemWarp
EXTRN	?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z:NEAR ; CPlayerDataCenter::GetPlayerString
EXTRN	?UpdateItemEx@CMover@@QAEXED_J@Z:NEAR		; CMover::UpdateItemEx
EXTRN	?SendTeleportPlayer@CDPCoreClient@@QAEXKK@Z:NEAR ; CDPCoreClient::SendTeleportPlayer
EXTRN	?GetInstance@CPlayerDataCenter@@SAPAV1@XZ:NEAR	; CPlayerDataCenter::GetInstance
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\world.h
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseItemWarp@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z
_TEXT	SEGMENT
$T289379 = -12						; size = 12
_pItemProp$ = 8						; size = 4
_pItemElem$ = 12					; size = 4
?DoUseItemWarp@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z PROC NEAR ; CMover::DoUseItemWarp, COMDAT
; _this$ = ecx

; 4056 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	55		 push	 ebp

; 4057 : 	switch( pItemProp->dwID )

  00004	8b 6c 24 14	 mov	 ebp, DWORD PTR _pItemProp$[esp+12]
  00008	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0000b	3d 10 0e 00 00	 cmp	 eax, 3600		; 00000e10H
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx
  00013	0f 82 6f 02 00
	00		 jb	 $L275971
  00019	3d 11 0e 00 00	 cmp	 eax, 3601		; 00000e11H
  0001e	76 0b		 jbe	 SHORT $L275935
  00020	3d 0a 47 00 00	 cmp	 eax, 18186		; 0000470aH
  00025	0f 85 5d 02 00
	00		 jne	 $L275971
$L275935:

; 4058 : 	{
; 4059 : 		case II_GEN_WARP_COUPLERING:
; 4060 : 		case II_GEN_WARP_WEDDING_BAND:
; 4061 : #if __VER >= 8 // __S_COUPLERING01
; 4062 : 		case II_GEN_WARP_COUPLERING01:
; 4063 : #endif // __VER >= 8
; 4064 : 			{
; 4065 : 				if( IsFly() )

  0002b	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  00031	f6 40 08 08	 test	 BYTE PTR [eax+8], 8

; 4066 : 				{
; 4067 : 					return FALSE;

  00035	0f 85 4d 02 00
	00		 jne	 $L275971

; 4068 : 				}
; 4069 : //				if( pItemElem->IsFlag( CItemElem::expired ) )
; 4070 : //				{
; 4071 : //					( (CUser*)this )->AddDefinedText( TID_GAME_ITEM_EXPIRED );
; 4072 : //					return FALSE;
; 4073 : //				}
; 4074 : 				u_long idCouple	= (u_long)( pItemElem->GetRandomOptItemId() );
; 4075 : 				if( idCouple == m_idPlayer )

  0003b	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  00041	53		 push	 ebx
  00042	57		 push	 edi
  00043	8b 7c 24 24	 mov	 edi, DWORD PTR _pItemElem$[esp+24]
  00047	8b 9f 98 00 00
	00		 mov	 ebx, DWORD PTR [edi+152]
  0004d	3b d8		 cmp	 ebx, eax
  0004f	75 29		 jne	 SHORT $L275939

; 4076 : 				{
; 4077 : 					( (CUser*)this )->AddDefinedText( TID_GAME_COUPLERING_ERR01, "%s", GetName() );

  00051	6a 00		 push	 0
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  00060	68 54 0b 00 00	 push	 2900			; 00000b54H
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	5f		 pop	 edi
  0006f	5b		 pop	 ebx
  00070	5e		 pop	 esi

; 4097 : 								return FALSE;

  00071	33 c0		 xor	 eax, eax
  00073	5d		 pop	 ebp

; 4159 : }

  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	c2 08 00	 ret	 8
$L275939:

; 4078 : 					return FALSE;
; 4079 : 				}
; 4080 : 
; 4081 : 				if( idCouple > 0 )

  0007a	85 db		 test	 ebx, ebx
  0007c	0f 86 a9 01 00
	00		 jbe	 $L275942

; 4082 : 				{
; 4083 : 					// teleport
; 4084 : #if __VER >= 11 // __SYS_PLAYER_DATA
; 4085 : 					const char* lpszPlayer	= CPlayerDataCenter::GetInstance()->GetPlayerString( idCouple );

  00082	53		 push	 ebx
  00083	e8 00 00 00 00	 call	 ?GetInstance@CPlayerDataCenter@@SAPAV1@XZ ; CPlayerDataCenter::GetInstance
  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 ?GetPlayerString@CPlayerDataCenter@@QAEPBDK@Z ; CPlayerDataCenter::GetPlayerString
  0008f	8b e8		 mov	 ebp, eax

; 4086 : #else	// __SYS_PLAYER_DATA
; 4087 : 					LPCSTR lpszPlayer	= prj.GetPlayerString( idCouple );
; 4088 : #endif	// __SYS_PLAYER_DATA
; 4089 : 					if( lpszPlayer )

  00091	85 ed		 test	 ebp, ebp
  00093	0f 84 e0 01 00
	00		 je	 $L275965

; 4090 : 					{
; 4091 : 						CUser* pUser	= (CUser*)prj.GetUserByID( idCouple );

  00099	53		 push	 ebx
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0009f	e8 00 00 00 00	 call	 ?GetUserByID@CProject@@QAEPAVCMover@@K@Z ; CProject::GetUserByID
  000a4	8b f8		 mov	 edi, eax

; 4092 : 						if( IsValidObj( (CObj*)pUser ) )

  000a6	57		 push	 edi
  000a7	e8 00 00 00 00	 call	 ?IsValidObj@@YAHPAVCObj@@@Z ; IsValidObj
  000ac	83 c4 04	 add	 esp, 4
  000af	85 c0		 test	 eax, eax
  000b1	0f 84 51 01 00
	00		 je	 $L275948

; 4093 : 						{
; 4094 : 							if( pUser->IsFly() )

  000b7	8b 8f 3c 02 00
	00		 mov	 ecx, DWORD PTR [edi+572]
  000bd	f6 41 08 08	 test	 BYTE PTR [ecx+8], 8
  000c1	74 18		 je	 SHORT $L275949

; 4095 : 							{
; 4096 : 								( (CUser*)this )->AddDefinedText( TID_GAME_COUPLERING_ERR03 );

  000c3	68 59 0b 00 00	 push	 2905			; 00000b59H
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
$L289501:
  000cf	5f		 pop	 edi
  000d0	5b		 pop	 ebx
  000d1	5e		 pop	 esi

; 4097 : 								return FALSE;

  000d2	33 c0		 xor	 eax, eax
  000d4	5d		 pop	 ebp

; 4159 : }

  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d8	c2 08 00	 ret	 8
$L275949:

; 4098 : 							}
; 4099 : 							if( pUser->GetWorld() && pUser->GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  000db	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  000e1	85 c9		 test	 ecx, ecx
  000e3	74 08		 je	 SHORT $L275951
  000e5	81 39 ca 00 00
	00		 cmp	 DWORD PTR [ecx], 202	; 000000caH

; 4100 : 								return FALSE;

  000eb	74 e2		 je	 SHORT $L289501
$L275951:

; 4101 : 							if( GetWorld() && GetWorld()->GetID() == WI_WORLD_GUILDWAR )

  000ed	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  000f3	85 c0		 test	 eax, eax
  000f5	74 1e		 je	 SHORT $L275953
  000f7	8b 10		 mov	 edx, DWORD PTR [eax]
  000f9	81 fa ca 00 00
	00		 cmp	 edx, 202		; 000000caH

; 4102 : 								return FALSE;

  000ff	74 ce		 je	 SHORT $L289501

; 4103 : #if __VER >= 11	// __GUILD_COMBAT_1TO1
; 4104 : 							if( GetWorld() && GetWorld()->GetID() >= WI_WORLD_GUILDWAR1TO1_0
; 4105 : 								          && GetWorld()->GetID() <= WI_WORLD_GUILDWAR1TO1_L )

  00101	85 c0		 test	 eax, eax
  00103	74 10		 je	 SHORT $L275953
  00105	8b c2		 mov	 eax, edx
  00107	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  0010c	72 07		 jb	 SHORT $L275953
  0010e	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H

; 4106 : 								return FALSE;

  00113	76 ba		 jbe	 SHORT $L289501
$L275953:

; 4107 : 							if( pUser->GetWorld() && pUser->GetWorld()->GetID() >= WI_WORLD_GUILDWAR1TO1_0
; 4108 : 												&& pUser->GetWorld()->GetID() <= WI_WORLD_GUILDWAR1TO1_L )

  00115	85 c9		 test	 ecx, ecx
  00117	74 10		 je	 SHORT $L275954
  00119	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011b	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00120	72 07		 jb	 SHORT $L275954
  00122	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H

; 4109 : 								return FALSE;

  00127	76 a6		 jbe	 SHORT $L289501
$L275954:

; 4110 : #endif // __GUILD_COMBAT_1TO1
; 4111 : #if __VER >= 13 // __RAINBOW_RACE
; 4112 : 							if( CRainbowRaceMng::GetInstance()->IsEntry( ((CUser*)this)->m_idPlayer )
; 4113 : 								|| CRainbowRaceMng::GetInstance()->IsEntry( idCouple ) )

  00129	8b 96 38 02 00
	00		 mov	 edx, DWORD PTR [esi+568]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  00135	8b c8		 mov	 ecx, eax
  00137	e8 00 00 00 00	 call	 ?IsEntry@CRainbowRaceMng@@QAEHK@Z ; CRainbowRaceMng::IsEntry
  0013c	85 c0		 test	 eax, eax
  0013e	0f 85 ac 00 00
	00		 jne	 $L275957
  00144	53		 push	 ebx
  00145	e8 00 00 00 00	 call	 ?GetInstance@CRainbowRaceMng@@SAPAV1@XZ ; CRainbowRaceMng::GetInstance
  0014a	8b c8		 mov	 ecx, eax
  0014c	e8 00 00 00 00	 call	 ?IsEntry@CRainbowRaceMng@@QAEHK@Z ; CRainbowRaceMng::IsEntry
  00151	85 c0		 test	 eax, eax
  00153	0f 85 97 00 00
	00		 jne	 $L275957

; 4116 : 								return FALSE;
; 4117 : 							}
; 4118 : #endif // __RAINBOW_RACE
; 4119 : 
; 4120 : 							if( GetWorld() == pUser->GetWorld() && !prj.IsGuildQuestRegion( pUser->GetPos() )
; 4121 : #if __VER >= 14 // __INSTANCE_DUNGEON
; 4122 : 								&& GetLayer() == pUser->GetLayer()
; 4123 : #endif // __INSTANCE_DUNGEON
; 4124 : #ifdef __QUIZ
; 4125 : 								&& GetWorld()->GetID() != WI_WORLD_QUIZ
; 4126 : 								&& pUser->GetWorld()->GetID() != WI_WORLD_QUIZ
; 4127 : #endif // __QUIZ
; 4128 : 								)

  00159	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  0015f	3b 87 6c 01 00
	00		 cmp	 eax, DWORD PTR [edi+364]
  00165	75 66		 jne	 SHORT $L275960
  00167	8d 4c 24 10	 lea	 ecx, DWORD PTR $T289379[esp+28]
  0016b	51		 push	 ecx
  0016c	8b cf		 mov	 ecx, edi
  0016e	e8 00 00 00 00	 call	 ?GetPos@CObj@@QAE?AUD3DXVECTOR3@@XZ ; CObj::GetPos
  00173	50		 push	 eax
  00174	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00179	e8 00 00 00 00	 call	 ?IsGuildQuestRegion@CProject@@QAEHABUD3DXVECTOR3@@@Z ; CProject::IsGuildQuestRegion
  0017e	85 c0		 test	 eax, eax
  00180	75 4b		 jne	 SHORT $L275960
  00182	8b 96 b8 01 00
	00		 mov	 edx, DWORD PTR [esi+440]
  00188	3b 97 b8 01 00
	00		 cmp	 edx, DWORD PTR [edi+440]
  0018e	75 3d		 jne	 SHORT $L275960
  00190	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  00196	81 38 d3 00 00
	00		 cmp	 DWORD PTR [eax], 211	; 000000d3H
  0019c	74 2f		 je	 SHORT $L275960
  0019e	8b 8f 6c 01 00
	00		 mov	 ecx, DWORD PTR [edi+364]
  001a4	81 39 d3 00 00
	00		 cmp	 DWORD PTR [ecx], 211	; 000000d3H
  001aa	74 21		 je	 SHORT $L275960

; 4129 : 							{
; 4130 : 								 g_DPCoreClient.SendTeleportPlayer( m_idPlayer, idCouple );

  001ac	8b 96 38 02 00
	00		 mov	 edx, DWORD PTR [esi+568]
  001b2	53		 push	 ebx
  001b3	52		 push	 edx
  001b4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  001b9	e8 00 00 00 00	 call	 ?SendTeleportPlayer@CDPCoreClient@@QAEXKK@Z ; CDPCoreClient::SendTeleportPlayer
  001be	5f		 pop	 edi
  001bf	5b		 pop	 ebx
  001c0	5e		 pop	 esi

; 4152 : 				}
; 4153 : 				return TRUE;

  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	5d		 pop	 ebp

; 4159 : }

  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ca	c2 08 00	 ret	 8
$L275960:

; 4131 : 							}
; 4132 : 							else
; 4133 : 							{
; 4134 : 								( (CUser*)this )->AddDefinedText( TID_GAME_COUPLERING_ERR02, "%s", lpszPlayer );

  001cd	55		 push	 ebp
  001ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  001d3	68 58 0b 00 00	 push	 2904			; 00000b58H

; 4151 : 					( (CUser*)this )->AddDefinedText( TID_GAME_COUPLERING_CARVE, "%s", GetName() );

  001d8	56		 push	 esi
  001d9	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  001de	83 c4 10	 add	 esp, 16			; 00000010H
  001e1	5f		 pop	 edi
  001e2	5b		 pop	 ebx
  001e3	5e		 pop	 esi

; 4152 : 				}
; 4153 : 				return TRUE;

  001e4	b8 01 00 00 00	 mov	 eax, 1
  001e9	5d		 pop	 ebp

; 4159 : }

  001ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ed	c2 08 00	 ret	 8
$L275957:

; 4114 : 							{
; 4115 : 								((CUser*)this)->AddDefinedText( TID_GAME_RAINBOWRACE_NOTELEPORT );

  001f0	68 c1 0f 00 00	 push	 4033			; 00000fc1H
  001f5	8b ce		 mov	 ecx, esi
  001f7	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  001fc	5f		 pop	 edi
  001fd	5b		 pop	 ebx
  001fe	5e		 pop	 esi
  001ff	33 c0		 xor	 eax, eax
  00201	5d		 pop	 ebp

; 4159 : }

  00202	83 c4 0c	 add	 esp, 12			; 0000000cH
  00205	c2 08 00	 ret	 8
$L275948:

; 4135 : 							}
; 4136 : 						}
; 4137 : 						else
; 4138 : 							( (CUser*)this )->AddDefinedText( TID_DIAG_0061, "%s", lpszPlayer );

  00208	55		 push	 ebp
  00209	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  0020e	68 0c 08 00 00	 push	 2060			; 0000080cH

; 4151 : 					( (CUser*)this )->AddDefinedText( TID_GAME_COUPLERING_CARVE, "%s", GetName() );

  00213	56		 push	 esi
  00214	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00219	83 c4 10	 add	 esp, 16			; 00000010H
  0021c	5f		 pop	 edi
  0021d	5b		 pop	 ebx
  0021e	5e		 pop	 esi

; 4152 : 				}
; 4153 : 				return TRUE;

  0021f	b8 01 00 00 00	 mov	 eax, 1
  00224	5d		 pop	 ebp

; 4159 : }

  00225	83 c4 0c	 add	 esp, 12			; 0000000cH
  00228	c2 08 00	 ret	 8
$L275942:

; 4139 : 					}
; 4140 : 				}
; 4141 : 				else
; 4142 : 				{
; 4143 : 					// carve
; 4144 : #if __VER >= 11 // __SYS_IDENTIFY
; 4145 : 					UpdateItemEx( (BYTE)( pItemElem->m_dwObjId ), UI_RANDOMOPTITEMID, (__int64)m_idPlayer );

  0022b	6a 00		 push	 0
  0022d	50		 push	 eax
  0022e	33 c0		 xor	 eax, eax
  00230	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00233	6a 0a		 push	 10			; 0000000aH
  00235	8b ce		 mov	 ecx, esi
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 ?UpdateItemEx@CMover@@QAEXED_J@Z ; CMover::UpdateItemEx

; 4146 : #else	// __SYS_IDENTIFY
; 4147 : 					UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_RANDOMOPTITEMID, m_idPlayer );
; 4148 : #endif	// __SYS_IDENTIFY
; 4149 : 					if( II_GEN_WARP_COUPLERING == pItemProp->dwID )

  0023d	81 7d 00 10 0e
	00 00		 cmp	 DWORD PTR [ebp], 3600	; 00000e10H
  00244	75 16		 jne	 SHORT $L289496

; 4150 : 						UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_KEEPTIME, 21600 );	// 15 days

  00246	33 c9		 xor	 ecx, ecx
  00248	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]
  0024b	6a 00		 push	 0
  0024d	68 60 54 00 00	 push	 21600			; 00005460H
  00252	6a 0b		 push	 11			; 0000000bH
  00254	51		 push	 ecx
  00255	8b ce		 mov	 ecx, esi
  00257	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L289496:

; 4151 : 					( (CUser*)this )->AddDefinedText( TID_GAME_COUPLERING_CARVE, "%s", GetName() );

  0025c	6a 00		 push	 0
  0025e	8b ce		 mov	 ecx, esi
  00260	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00265	50		 push	 eax
  00266	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  0026b	68 55 0b 00 00	 push	 2901			; 00000b55H
  00270	56		 push	 esi
  00271	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00276	83 c4 10	 add	 esp, 16			; 00000010H
$L275965:
  00279	5f		 pop	 edi
  0027a	5b		 pop	 ebx
  0027b	5e		 pop	 esi

; 4152 : 				}
; 4153 : 				return TRUE;

  0027c	b8 01 00 00 00	 mov	 eax, 1
  00281	5d		 pop	 ebp

; 4159 : }

  00282	83 c4 0c	 add	 esp, 12			; 0000000cH
  00285	c2 08 00	 ret	 8
$L275971:
  00288	5e		 pop	 esi

; 4154 : 			}
; 4155 : 		default:
; 4156 : 			break;
; 4157 : 	}
; 4158 : 	return FALSE;

  00289	33 c0		 xor	 eax, eax
  0028b	5d		 pop	 ebp

; 4159 : }

  0028c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028f	c2 08 00	 ret	 8
?DoUseItemWarp@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ENDP ; CMover::DoUseItemWarp
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T289606 DD	0ffffffffH
	DD	FLAT:$L289506
$T289604 DD	019930520H
	DD	01H
	DD	FLAT:$T289606
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	e8 00 00 00 00	 call	 ??0exception@@QAE@XZ	; exception::exception
  00022	33 c0		 xor	 eax, eax
  00024	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	6a ff		 push	 -1
  0002f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00032	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00039	50		 push	 eax
  0003a	89 44 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], eax
  0003e	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00041	8b 44 24 20	 mov	 eax, DWORD PTR __Message$[esp+24]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 20   : 		}

  0004b	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L289506:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T289604
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogty
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L289616
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L289616:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L289705
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L289705:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 983  : 		CThisSimpleString::operator=( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L289743
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 986  : 	}

  00017	c2 04 00	 ret	 4

; 983  : 		CThisSimpleString::operator=( pszSrc );

$L289743:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L289745:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L289745
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 986  : 	}

  00036	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 361  : 		_Tidy();
; 362  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b c2		 mov	 eax, edx
  00009	57		 push	 edi
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$L289821:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L289821
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 363  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T289942 DD	0ffffffffH
	DD	FLAT:$L289827
$T289939 DD	019930520H
	DD	01H
	DD	FLAT:$T289942
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T289826 = -80						; size = 28
$T289825 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T289826[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T289826[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T289826[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T289826[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T289826[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T289825[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T289825[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T289825[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L289943:
$L289941:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L289827:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T289826[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T289939
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
;	COMDAT xdata$x
xdata$x	SEGMENT
$T290049 DD	0ffffffffH
	DD	FLAT:$L289949
$T290047 DD	019930520H
	DD	01H
	DD	FLAT:$T290049
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	e8 00 00 00 00	 call	 ??0exception@@QAE@ABV0@@Z ; exception::exception
  00028	33 c0		 xor	 eax, eax
  0002a	6a ff		 push	 -1
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	50		 push	 eax
  00036	83 c7 0c	 add	 edi, 12			; 0000000cH
  00039	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00040	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00043	57		 push	 edi
  00044	89 44 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], eax
  00048	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00054	5f		 pop	 edi
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L289949:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T290047
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogty
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXViterator@12@IABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n
; Function compile flags: /Ogty
;	COMDAT ?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXViterator@12@IABE@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Count$290279 = 8					; size = 4
__Where$ = 8						; size = 4
__Newvec$277404 = 12					; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXViterator@12@IABE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	8a 08		 mov	 cl, BYTE PTR [eax]

; 811  : 		size_type _Capacity = capacity();

  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	85 c0		 test	 eax, eax
  0000f	57		 push	 edi
  00010	88 4c 24 18	 mov	 BYTE PTR __Tmp$[esp+8], cl
  00014	75 04		 jne	 SHORT $L290069
  00016	33 c9		 xor	 ecx, ecx
  00018	eb 09		 jmp	 SHORT $L290070
$L290069:
  0001a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0001d	2b c8		 sub	 ecx, eax
  0001f	89 4c 24 08	 mov	 DWORD PTR __Capacity$[esp+12], ecx
$L290070:

; 812  : 
; 813  : 		if (_Count == 0)

  00023	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00027	85 ff		 test	 edi, edi
  00029	0f 84 93 01 00
	00		 je	 $L277424

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $L290092
  00033	33 d2		 xor	 edx, edx
  00035	eb 05		 jmp	 SHORT $L290093
$L290092:
  00037	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003a	2b d0		 sub	 edx, eax
$L290093:
  0003c	53		 push	 ebx
  0003d	83 cb ff	 or	 ebx, -1
  00040	2b da		 sub	 ebx, edx
  00042	3b df		 cmp	 ebx, edi
  00044	73 07		 jae	 SHORT $L277400

; 816  : 			_Xlen();	// result too long

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
$L290308:
$L277400:

; 817  : 		else if (_Capacity < size() + _Count)

  0004d	85 c0		 test	 eax, eax
  0004f	75 04		 jne	 SHORT $L290099
  00051	33 d2		 xor	 edx, edx
  00053	eb 05		 jmp	 SHORT $L290100
$L290099:
  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	2b d0		 sub	 edx, eax
$L290100:
  0005a	03 d7		 add	 edx, edi
  0005c	3b ca		 cmp	 ecx, edx
  0005e	55		 push	 ebp
  0005f	0f 83 c7 00 00
	00		 jae	 $L277402

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00065	8b d1		 mov	 edx, ecx
  00067	d1 ea		 shr	 edx, 1
  00069	83 cb ff	 or	 ebx, -1
  0006c	2b da		 sub	 ebx, edx
  0006e	3b d9		 cmp	 ebx, ecx
  00070	73 0e		 jae	 SHORT $L290059
  00072	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __Capacity$[esp+20], 0
  0007a	8b 4c 24 10	 mov	 ecx, DWORD PTR __Capacity$[esp+20]
  0007e	eb 06		 jmp	 SHORT $L290060
$L290059:
  00080	03 ca		 add	 ecx, edx
  00082	89 4c 24 10	 mov	 DWORD PTR __Capacity$[esp+20], ecx
$L290060:

; 821  : 			if (_Capacity < size() + _Count)

  00086	85 c0		 test	 eax, eax
  00088	75 04		 jne	 SHORT $L290122
  0008a	33 d2		 xor	 edx, edx
  0008c	eb 05		 jmp	 SHORT $L290123
$L290122:
  0008e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00091	2b d0		 sub	 edx, eax
$L290123:
  00093	03 d7		 add	 edx, edi
  00095	3b ca		 cmp	 ecx, edx
  00097	73 13		 jae	 SHORT $L277403

; 822  : 				_Capacity = size() + _Count;

  00099	85 c0		 test	 eax, eax
  0009b	75 04		 jne	 SHORT $L290129
  0009d	33 c9		 xor	 ecx, ecx
  0009f	eb 05		 jmp	 SHORT $L290130
$L290129:
  000a1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a4	2b c8		 sub	 ecx, eax
$L290130:
  000a6	03 cf		 add	 ecx, edi
  000a8	89 4c 24 10	 mov	 DWORD PTR __Capacity$[esp+20], ecx
$L277403:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b2	8b 6c 24 1c	 mov	 ebp, DWORD PTR __Where$[esp+20]
  000b6	8b c8		 mov	 ecx, eax
  000b8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000bb	8b dd		 mov	 ebx, ebp
  000bd	2b d8		 sub	 ebx, eax
  000bf	53		 push	 ebx
  000c0	50		 push	 eax
  000c1	51		 push	 ecx
  000c2	89 4c 24 2c	 mov	 DWORD PTR __Newvec$277404[esp+32], ecx
  000c6	e8 00 00 00 00	 call	 _memmove
  000cb	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000ce	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000d2	52		 push	 edx
  000d3	03 c3		 add	 eax, ebx
  000d5	57		 push	 edi
  000d6	50		 push	 eax
  000d7	8b ce		 mov	 ecx, esi
  000d9	e8 00 00 00 00	 call	 ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000de	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e1	2b cd		 sub	 ecx, ebp
  000e3	51		 push	 ecx
  000e4	55		 push	 ebp
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000eb	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f1	85 c0		 test	 eax, eax
  000f3	75 04		 jne	 SHORT $L290211
  000f5	33 c9		 xor	 ecx, ecx
  000f7	eb 05		 jmp	 SHORT $L290212
$L290211:
  000f9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000fc	2b c8		 sub	 ecx, eax
$L290212:
  000fe	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00100	85 c0		 test	 eax, eax
  00102	74 09		 je	 SHORT $L290216

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010a	83 c4 04	 add	 esp, 4
$L290216:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  0010d	8b 44 24 1c	 mov	 eax, DWORD PTR __Newvec$277404[esp+16]
  00111	8b 54 24 10	 mov	 edx, DWORD PTR __Capacity$[esp+20]
  00115	5d		 pop	 ebp
  00116	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00119	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0011a	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  0011d	5f		 pop	 edi
  0011e	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00121	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 845  : 			_Myfirst = _Newvec;

  00124	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00127	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  00128	59		 pop	 ecx
  00129	c2 0c 00	 ret	 12			; 0000000cH
$L277402:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  0012c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0012f	8b 6c 24 18	 mov	 ebp, DWORD PTR __Where$[esp+16]
  00133	8b c3		 mov	 eax, ebx
  00135	2b c5		 sub	 eax, ebp
  00137	3b c7		 cmp	 eax, edi
  00139	73 48		 jae	 SHORT $L277415

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  0013b	50		 push	 eax
  0013c	8d 04 2f	 lea	 eax, DWORD PTR [edi+ebp]
  0013f	55		 push	 ebp
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _memmove

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014c	8b d5		 mov	 edx, ebp
  0014e	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00152	51		 push	 ecx
  00153	2b d0		 sub	 edx, eax
  00155	03 d7		 add	 edx, edi
  00157	52		 push	 edx
  00158	50		 push	 eax
  00159	8b ce		 mov	 ecx, esi
  0015b	e8 00 00 00 00	 call	 ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00160	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00163	03 d7		 add	 edx, edi
  00165	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00168	8b f2		 mov	 esi, edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  0016a	8d 44 24 20	 lea	 eax, DWORD PTR __Tmp$[esp+16]
  0016e	50		 push	 eax
  0016f	2b f7		 sub	 esi, edi
  00171	56		 push	 esi
  00172	55		 push	 ebp
  00173	e8 00 00 00 00	 call	 ??$fill@PAEE@std@@YAXPAE0ABE@Z ; std::fill<unsigned char *,unsigned char>
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017b	5d		 pop	 ebp
  0017c	5b		 pop	 ebx
  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0017f	59		 pop	 ecx
  00180	c2 0c 00	 ret	 12			; 0000000cH
$L277415:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  00183	8b c3		 mov	 eax, ebx
  00185	2b c7		 sub	 eax, edi
  00187	8b cb		 mov	 ecx, ebx
  00189	2b c8		 sub	 ecx, eax
  0018b	51		 push	 ecx
  0018c	50		 push	 eax
  0018d	53		 push	 ebx
  0018e	89 4c 24 24	 mov	 DWORD PTR __Count$290279[esp+28], ecx
  00192	e8 00 00 00 00	 call	 _memmove
  00197	03 44 24 24	 add	 eax, DWORD PTR __Count$290279[esp+28]
  0019b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  0019e	8b c3		 mov	 eax, ebx
  001a0	2b c5		 sub	 eax, ebp
  001a2	2b c7		 sub	 eax, edi
  001a4	50		 push	 eax
  001a5	2b d8		 sub	 ebx, eax
  001a7	55		 push	 ebp
  001a8	53		 push	 ebx
  001a9	e8 00 00 00 00	 call	 _memmove

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001ae	8d 4c 24 38	 lea	 ecx, DWORD PTR __Tmp$[esp+40]
  001b2	51		 push	 ecx
  001b3	8d 14 2f	 lea	 edx, DWORD PTR [edi+ebp]
  001b6	52		 push	 edx
  001b7	55		 push	 ebp
  001b8	e8 00 00 00 00	 call	 ??$fill@PAEE@std@@YAXPAE0ABE@Z ; std::fill<unsigned char *,unsigned char>
  001bd	83 c4 24	 add	 esp, 36			; 00000024H
  001c0	5d		 pop	 ebp
  001c1	5b		 pop	 ebx
$L277424:
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001c4	59		 pop	 ecx
  001c5	c2 0c 00	 ret	 12			; 0000000cH
$L290307:
?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXViterator@12@IABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n
_TEXT	ENDS
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T290393 DD	0ffffffffH
	DD	FLAT:$L290312
$T290387 DD	019930520H
	DD	01H
	DD	FLAT:$T290393
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pszSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 830  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	57		 push	 edi
  0001a	89 74 24 08	 mov	 DWORD PTR _this$[esp+24], esi
  0001e	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	8b c8		 mov	 ecx, eax
  00027	ff 52 0c	 call	 DWORD PTR [edx+12]
  0002a	83 c0 10	 add	 eax, 16			; 00000010H
  0002d	89 06		 mov	 DWORD PTR [esi], eax

; 831  : 		if( !CheckImplicitLoad( pszSrc ) )

  0002f	8b 54 24 1c	 mov	 edx, DWORD PTR _pszSrc$[esp+20]
  00033	85 d2		 test	 edx, edx
  00035	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0003d	74 33		 je	 SHORT $L290389
  0003f	f7 c2 00 00 ff
	ff		 test	 edx, -65536		; ffff0000H
  00045	75 2f		 jne	 SHORT $L290384
  00047	0f b7 fa	 movzx	 edi, dx
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle
  00050	85 c0		 test	 eax, eax
  00052	74 3e		 je	 SHORT $L290391
  00054	57		 push	 edi
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
  0005d	5f		 pop	 edi

; 835  : 		}
; 836  : 	}

  0005e	8b c6		 mov	 eax, esi
  00060	5e		 pop	 esi
  00061	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	c2 04 00	 ret	 4
$L290389:

; 832  : 		{
; 833  : 			// nDestLength is in XCHARs
; 834  : 			*this = pszSrc;

  00072	33 c0		 xor	 eax, eax
  00074	eb 13		 jmp	 SHORT $L290383
$L290384:
  00076	8b c2		 mov	 eax, edx
  00078	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0007b	eb 03 8d 49 00	 npad	 5
$L290390:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $L290390
  00087	2b c7		 sub	 eax, edi
$L290383:
  00089	50		 push	 eax
  0008a	52		 push	 edx
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
$L290391:

; 835  : 		}
; 836  : 	}

  00092	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00096	5f		 pop	 edi
  00097	8b c6		 mov	 eax, esi
  00099	5e		 pop	 esi
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a1	83 c4 10	 add	 esp, 16			; 00000010H
  000a4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L290312:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
__ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T290387
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	56		 push	 esi

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00001	33 c0		 xor	 eax, eax
  00003	57		 push	 edi

; 772  : 		if (_Capacity == 0)

  00004	8b 7c 24 0c	 mov	 edi, DWORD PTR __Capacity$[esp+4]
  00008	3b f8		 cmp	 edi, eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00012	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00015	75 07		 jne	 SHORT $L220671
  00017	5f		 pop	 edi

; 773  : 			return (false);

  00018	32 c0		 xor	 al, al
  0001a	5e		 pop	 esi

; 783  : 		}

  0001b	c2 04 00	 ret	 4
$L220671:

; 774  : 		else if (max_size() < _Capacity)

  0001e	83 ff ff	 cmp	 edi, -1
  00021	76 07		 jbe	 SHORT $L220673

; 775  : 			_Xlen();	// result too long

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
$L290424:
$L220673:

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00030	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 779  : 			_Mylast = _Myfirst;

  00033	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00036	83 c4 04	 add	 esp, 4

; 780  : 			_Myend = _Myfirst + _Capacity;

  00039	03 c7		 add	 eax, edi
  0003b	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0003e	5f		 pop	 edi

; 781  : 			}
; 782  : 		return (true);

  0003f	b0 01		 mov	 al, 1
  00041	5e		 pop	 esi

; 783  : 		}

  00042	c2 04 00	 ret	 4
$L290423:
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
_TEXT	ENDS
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogty
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC NEAR	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx

; 300  : 		_Buy(0);

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000d	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; Function compile flags: /Ogty
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 507  : 		{	// determine new length, padding with _Val elements as needed

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 508  : 		if (size() < _Newsize)

  00003	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00006	85 c9		 test	 ecx, ecx
  00008	57		 push	 edi
  00009	75 04		 jne	 SHORT $L290499
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 05		 jmp	 SHORT $L290500
$L290499:
  0000f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00012	2b c1		 sub	 eax, ecx
$L290500:
  00014	8b 7c 24 0c	 mov	 edi, DWORD PTR __Newsize$[esp+4]
  00018	3b c7		 cmp	 eax, edi
  0001a	73 25		 jae	 SHORT $L276292

; 509  : 			_Insert_n(end(), _Newsize - size(), _Val);

  0001c	85 c9		 test	 ecx, ecx
  0001e	75 04		 jne	 SHORT $L290506
  00020	33 c0		 xor	 eax, eax
  00022	eb 05		 jmp	 SHORT $L290507
$L290506:
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	2b c1		 sub	 eax, ecx
$L290507:
  00029	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002c	8d 54 24 10	 lea	 edx, DWORD PTR __Val$[esp+4]
  00030	52		 push	 edx
  00031	2b f8		 sub	 edi, eax
  00033	57		 push	 edi
  00034	51		 push	 ecx
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXViterator@12@IABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 512  : 		}

  0003e	c2 08 00	 ret	 8
$L276292:

; 510  : 		else if (_Newsize < size())

  00041	85 c9		 test	 ecx, ecx
  00043	74 25		 je	 SHORT $L290618
  00045	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00048	8b d0		 mov	 edx, eax
  0004a	2b d1		 sub	 edx, ecx
  0004c	3b fa		 cmp	 edi, edx
  0004e	73 1a		 jae	 SHORT $L290618

; 511  : 			erase(begin() + _Newsize, end());

  00050	03 cf		 add	 ecx, edi
  00052	3b c8		 cmp	 ecx, eax
  00054	74 14		 je	 SHORT $L290618
  00056	8b f8		 mov	 edi, eax
  00058	2b f8		 sub	 edi, eax
  0005a	57		 push	 edi
  0005b	50		 push	 eax
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 _memmove
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	03 c7		 add	 eax, edi
  00067	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L290618:
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 512  : 		}

  0006c	c2 08 00	 ret	 8
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T290744 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T290746 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L290629
$T290745 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T290746
$T290740 DD	019930520H
	DD	02H
	DD	FLAT:$T290744
	DD	01H
	DD	FLAT:$T290745
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$290734 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 329  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	53		 push	 ebx

; 330  : 		if (_Buy(_Right.size()))

  0001c	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  0001f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00022	56		 push	 esi
  00023	8b f1		 mov	 esi, ecx
  00025	33 c9		 xor	 ecx, ecx
  00027	3b c1		 cmp	 eax, ecx
  00029	57		 push	 edi
  0002a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00030	75 04		 jne	 SHORT $L290648
  00032	33 ff		 xor	 edi, edi
  00034	eb 05		 jmp	 SHORT $L290649
$L290648:
  00036	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  00039	2b f8		 sub	 edi, eax
$L290649:
  0003b	3b f9		 cmp	 edi, ecx
  0003d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00040	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00043	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00046	74 3e		 je	 SHORT $L219232
  00048	83 ff ff	 cmp	 edi, -1
  0004b	76 07		 jbe	 SHORT $L290678
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
$L290747:
$L290678:
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 331  : 			_TRY_BEGIN
; 332  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

  0005a	8b 55 08	 mov	 edx, DWORD PTR __Cat$290734[ebp]
  0005d	52		 push	 edx
  0005e	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00061	56		 push	 esi
  00062	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00068	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0006b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0006e	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00071	50		 push	 eax
  00072	51		 push	 ecx
  00073	53		 push	 ebx
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0007b	e8 00 00 00 00	 call	 ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<unsigned char,std::allocator<unsigned char> >::const_iterator,unsigned char *,std::allocator<unsigned char> >
  00080	83 c4 18	 add	 esp, 24			; 00000018H
  00083	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L219232:

; 336  : 			_CATCH_END
; 337  : 		}

  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00089	5f		 pop	 edi
  0008a	8b c6		 mov	 eax, esi
  0008c	5e		 pop	 esi
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
$L290629:

; 333  : 			_CATCH_ALL
; 334  : 			_Tidy();

  0009b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 335  : 			_RERAISE;

  000a3	6a 00		 push	 0
  000a5	6a 00		 push	 0
  000a7	e8 00 00 00 00	 call	 __CxxThrowException@8
$L290748:
$L290743:
  000ac	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T290740
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z ; CMover::GetValidVisTable
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T291000 DD	0ffffffffH
	DD	FLAT:$L290753
$T290993 DD	019930520H
	DD	01H
	DD	FLAT:$T291000
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
xdata$x	ENDS
;	COMDAT ?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z
_TEXT	SEGMENT
$T290755 = -32						; size = 4
_vecTemp$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pItemElem$ = 12					; size = 4
?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z PROC NEAR ; CMover::GetValidVisTable, COMDAT
; _this$ = ecx

; 4529 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 14	 sub	 esp, 20			; 00000014H
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	33 db		 xor	 ebx, ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b e9		 mov	 ebp, ecx
  00020	89 5c 24 10	 mov	 DWORD PTR $T290755[esp+48], ebx

; 4530 : 	vector<BYTE> vecTemp;

  00024	89 5c 24 18	 mov	 DWORD PTR _vecTemp$[esp+52], ebx
  00028	89 5c 24 1c	 mov	 DWORD PTR _vecTemp$[esp+56], ebx
  0002c	89 5c 24 20	 mov	 DWORD PTR _vecTemp$[esp+60], ebx

; 4531 : 	vecTemp.resize( pItemElem->GetPiercingSize(), UNDEFINED_NEEDVIS );

  00030	8b 7c 24 38	 mov	 edi, DWORD PTR _pItemElem$[esp+44]
  00034	83 c7 3c	 add	 edi, 60			; 0000003cH
  00037	6a 04		 push	 4
  00039	8b cf		 mov	 ecx, edi
  0003b	89 5c 24 30	 mov	 DWORD PTR __$EHRec$[esp+60], ebx
  0003f	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00044	50		 push	 eax
  00045	8d 4c 24 1c	 lea	 ecx, DWORD PTR _vecTemp$[esp+56]
  00049	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 4532 : 
; 4533 : 	for( DWORD i=0; i<vecTemp.size(); i++ )

  0004e	33 f6		 xor	 esi, esi
$L276170:
  00050	8b 4c 24 18	 mov	 ecx, DWORD PTR _vecTemp$[esp+52]
  00054	3b cb		 cmp	 ecx, ebx
  00056	74 20		 je	 SHORT $L290996
  00058	8b 44 24 1c	 mov	 eax, DWORD PTR _vecTemp$[esp+56]
  0005c	2b c1		 sub	 eax, ecx
  0005e	3b f0		 cmp	 esi, eax
  00060	73 16		 jae	 SHORT $L290996

; 4534 : 		if( pItemElem->GetPiercingItem( i ) == 0 )

  00062	56		 push	 esi
  00063	8b cf		 mov	 ecx, edi
  00065	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  0006a	85 c0		 test	 eax, eax
  0006c	75 07		 jne	 SHORT $L276171

; 4535 : 			vecTemp[i] = FAILED_BOTH_NEEDVIS;

  0006e	8b 44 24 18	 mov	 eax, DWORD PTR _vecTemp$[esp+52]
  00072	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
$L276171:

; 4532 : 
; 4533 : 	for( DWORD i=0; i<vecTemp.size(); i++ )

  00075	46		 inc	 esi
  00076	eb d8		 jmp	 SHORT $L276170
$L290996:

; 4536 : 	
; 4537 : 	for( DWORD i=0; i<vecTemp.size(); i++ )

  00078	33 f6		 xor	 esi, esi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$L276175:
  00080	3b cb		 cmp	 ecx, ebx
  00082	74 29		 je	 SHORT $L290997
  00084	8b 44 24 1c	 mov	 eax, DWORD PTR _vecTemp$[esp+56]
  00088	2b c1		 sub	 eax, ecx
  0008a	3b f0		 cmp	 esi, eax
  0008c	73 1f		 jae	 SHORT $L290997

; 4538 : 		if( vecTemp[i] == UNDEFINED_NEEDVIS )

  0008e	80 3c 31 04	 cmp	 BYTE PTR [ecx+esi], 4
  00092	75 16		 jne	 SHORT $L276176

; 4539 : 			SetValidNeedVis( pItemElem, i, vecTemp );

  00094	8b 54 24 38	 mov	 edx, DWORD PTR _pItemElem$[esp+44]
  00098	8d 4c 24 14	 lea	 ecx, DWORD PTR _vecTemp$[esp+48]
  0009c	51		 push	 ecx
  0009d	56		 push	 esi
  0009e	52		 push	 edx
  0009f	8b cd		 mov	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 ?SetValidNeedVis@CMover@@AAEHPAVCItemElem@@HAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; CMover::SetValidNeedVis
  000a6	8b 4c 24 18	 mov	 ecx, DWORD PTR _vecTemp$[esp+52]
$L276176:

; 4536 : 	
; 4537 : 	for( DWORD i=0; i<vecTemp.size(); i++ )

  000aa	46		 inc	 esi
  000ab	eb d3		 jmp	 SHORT $L276175
$L290997:

; 4540 : 
; 4541 : 	return vecTemp;

  000ad	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  000b1	8d 44 24 14	 lea	 eax, DWORD PTR _vecTemp$[esp+48]
  000b5	50		 push	 eax
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  000bd	8b 44 24 18	 mov	 eax, DWORD PTR _vecTemp$[esp+52]
  000c1	3b c3		 cmp	 eax, ebx
  000c3	74 09		 je	 SHORT $L290998
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000cb	83 c4 04	 add	 esp, 4
$L290998:

; 4542 : }

  000ce	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000d2	5f		 pop	 edi
  000d3	8b c6		 mov	 eax, esi
  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp
  000d7	5b		 pop	 ebx
  000d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000df	83 c4 20	 add	 esp, 32			; 00000020H
  000e2	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L290753:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _vecTemp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__ehhandler$?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T290993
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z ENDP ; CMover::GetValidVisTable
PUBLIC	?IsSatisfyNeedVis@CMover@@QAEEPAVCItemElem@@PAUItemProp@@@Z ; CMover::IsSatisfyNeedVis
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T291228 DD	0ffffffffH
	DD	FLAT:$L291009
$T291217 DD	019930520H
	DD	01H
	DD	FLAT:$T291228
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
xdata$x	ENDS
;	COMDAT ?IsSatisfyNeedVis@CMover@@QAEEPAVCItemElem@@PAUItemProp@@@Z
_TEXT	SEGMENT
_dwNeeds$276211 = -36					; size = 8
_vecValidTable$276214 = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pItemElemVisPet$ = 8					; size = 4
_pItemPropVis$ = 12					; size = 4
?IsSatisfyNeedVis@CMover@@QAEEPAVCItemElem@@PAUItemProp@@@Z PROC NEAR ; CMover::IsSatisfyNeedVis, COMDAT
; _this$ = ecx

; 4591 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?IsSatisfyNeedVis@CMover@@QAEEPAVCItemElem@@PAUItemProp@@@Z
  0000d	50		 push	 eax

; 4592 : 	if( pItemPropVis )

  0000e	8b 44 24 14	 mov	 eax, DWORD PTR _pItemPropVis$[esp+8]
  00012	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00019	83 ec 18	 sub	 esp, 24			; 00000018H
  0001c	53		 push	 ebx
  0001d	55		 push	 ebp
  0001e	56		 push	 esi
  0001f	33 f6		 xor	 esi, esi
  00021	3b c6		 cmp	 eax, esi
  00023	57		 push	 edi
  00024	0f 84 57 01 00
	00		 je	 $L291213

; 4593 : 	{
; 4594 : 		DWORD	dwNeeds[2] = { pItemPropVis->dwReferTarget1, pItemPropVis->dwReferTarget2 };

  0002a	8b 98 08 02 00
	00		 mov	 ebx, DWORD PTR [eax+520]

; 4595 : 		if( dwNeeds[0] == NULL_ID && dwNeeds[1] == NULL_ID )

  00030	83 fb ff	 cmp	 ebx, -1
  00033	8b a8 0c 02 00
	00		 mov	 ebp, DWORD PTR [eax+524]
  00039	89 5c 24 10	 mov	 DWORD PTR _dwNeeds$276211[esp+52], ebx
  0003d	89 6c 24 14	 mov	 DWORD PTR _dwNeeds$276211[esp+56], ebp
  00041	75 08		 jne	 SHORT $L276212
  00043	3b eb		 cmp	 ebp, ebx

; 4596 : 			return SUCCSESS_NEEDVIS;

  00045	0f 84 e1 00 00
	00		 je	 $L291156
$L276212:

; 4597 : 		
; 4598 : 		vector<BYTE> vecValidTable = GetValidVisTable( pItemElemVisPet );

  0004b	8b 7c 24 38	 mov	 edi, DWORD PTR _pItemElemVisPet$[esp+48]
  0004f	57		 push	 edi
  00050	8d 44 24 1c	 lea	 eax, DWORD PTR _vecValidTable$276214[esp+56]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z ; CMover::GetValidVisTable

; 4599 : 		for( int i=0; i<pItemElemVisPet->GetPiercingSize(); i++ )	//           .

  0005a	83 c7 3c	 add	 edi, 60			; 0000003cH
  0005d	8b cf		 mov	 ecx, edi
  0005f	89 74 24 30	 mov	 DWORD PTR __$EHRec$[esp+60], esi
  00063	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00068	85 c0		 test	 eax, eax
  0006a	7e 7d		 jle	 SHORT $L291226
  0006c	8d 64 24 00	 npad	 4
$L276217:

; 4600 : 		{
; 4601 : 			DWORD dwVis = pItemElemVisPet->GetPiercingItem( i );

  00070	56		 push	 esi
  00071	8b cf		 mov	 ecx, edi
  00073	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  00078	8b e8		 mov	 ebp, eax

; 4602 : 			if( dwNeeds[0] == dwVis && vecValidTable[i] == SUCCSESS_NEEDVIS && time_null() < pItemElemVisPet->GetVisKeepTime( i ) )	dwNeeds[0] = NULL_ID;

  0007a	3b dd		 cmp	 ebx, ebp
  0007c	75 24		 jne	 SHORT $L291222
  0007e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _vecValidTable$276214[esp+56]
  00082	80 3c 31 03	 cmp	 BYTE PTR [ecx+esi], 3
  00086	75 1a		 jne	 SHORT $L291222
  00088	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  0008e	56		 push	 esi
  0008f	8b cf		 mov	 ecx, edi
  00091	e8 00 00 00 00	 call	 ?GetVisKeepTime@CPiercing@@QAEJH@Z ; CPiercing::GetVisKeepTime
  00096	3b d8		 cmp	 ebx, eax
  00098	7d 08		 jge	 SHORT $L291222
  0009a	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR _dwNeeds$276211[esp+52], -1
$L291222:

; 4603 : 			if( dwNeeds[1] == dwVis && vecValidTable[i] == SUCCSESS_NEEDVIS && time_null() < pItemElemVisPet->GetVisKeepTime( i ) )	dwNeeds[1] = NULL_ID;

  000a2	39 6c 24 14	 cmp	 DWORD PTR _dwNeeds$276211[esp+56], ebp
  000a6	75 24		 jne	 SHORT $L291224
  000a8	8b 54 24 1c	 mov	 edx, DWORD PTR _vecValidTable$276214[esp+56]
  000ac	80 3c 32 03	 cmp	 BYTE PTR [edx+esi], 3
  000b0	75 1a		 jne	 SHORT $L291224
  000b2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  000b8	56		 push	 esi
  000b9	8b cf		 mov	 ecx, edi
  000bb	e8 00 00 00 00	 call	 ?GetVisKeepTime@CPiercing@@QAEJH@Z ; CPiercing::GetVisKeepTime
  000c0	3b d8		 cmp	 ebx, eax
  000c2	7d 08		 jge	 SHORT $L291224
  000c4	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _dwNeeds$276211[esp+56], -1
$L291224:

; 4604 : 			if( dwNeeds[0] == NULL_ID && dwNeeds[1] == NULL_ID )

  000cc	8b 5c 24 10	 mov	 ebx, DWORD PTR _dwNeeds$276211[esp+52]
  000d0	83 fb ff	 cmp	 ebx, -1
  000d3	8b 6c 24 14	 mov	 ebp, DWORD PTR _dwNeeds$276211[esp+56]
  000d7	75 04		 jne	 SHORT $L276218
  000d9	3b eb		 cmp	 ebp, ebx
  000db	74 3e		 je	 SHORT $L291219
$L276218:

; 4599 : 		for( int i=0; i<pItemElemVisPet->GetPiercingSize(); i++ )	//           .

  000dd	8b cf		 mov	 ecx, edi
  000df	46		 inc	 esi
  000e0	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000e5	3b f0		 cmp	 esi, eax
  000e7	7c 87		 jl	 SHORT $L276217
$L291226:

; 4606 : 		}
; 4607 : 			
; 4608 : 		if( dwNeeds[0] != NULL_ID && dwNeeds[1] == NULL_ID )

  000e9	83 fb ff	 cmp	 ebx, -1
  000ec	74 55		 je	 SHORT $L291221
  000ee	83 fd ff	 cmp	 ebp, -1
  000f1	75 7d		 jne	 SHORT $L276228

; 4609 : 			return FAILED_1ST_NEEDVIS;

  000f3	8b 44 24 1c	 mov	 eax, DWORD PTR _vecValidTable$276214[esp+56]
  000f7	85 c0		 test	 eax, eax
  000f9	74 09		 je	 SHORT $L291175
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00101	83 c4 04	 add	 esp, 4
$L291175:
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5d		 pop	 ebp
  00107	b0 01		 mov	 al, 1
  00109	5b		 pop	 ebx

; 4613 : 
; 4614 : 	return FAILED_BOTH_NEEDVIS;
; 4615 : }

  0010a	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  0010e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00115	83 c4 24	 add	 esp, 36			; 00000024H
  00118	c2 08 00	 ret	 8
$L291219:

; 4605 : 				return SUCCSESS_NEEDVIS;

  0011b	8b 44 24 1c	 mov	 eax, DWORD PTR _vecValidTable$276214[esp+56]
  0011f	85 c0		 test	 eax, eax
  00121	74 09		 je	 SHORT $L291156
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00129	83 c4 04	 add	 esp, 4
$L291156:
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5d		 pop	 ebp
  0012f	b0 03		 mov	 al, 3
  00131	5b		 pop	 ebx

; 4613 : 
; 4614 : 	return FAILED_BOTH_NEEDVIS;
; 4615 : }

  00132	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00136	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0013d	83 c4 24	 add	 esp, 36			; 00000024H
  00140	c2 08 00	 ret	 8
$L291221:

; 4610 : 		else if( dwNeeds[0] == NULL_ID && dwNeeds[1] != NULL_ID )

  00143	83 fd ff	 cmp	 ebp, -1
  00146	74 28		 je	 SHORT $L276228

; 4611 : 			return FAILED_2ND_NEEDVIS;

  00148	8b 44 24 1c	 mov	 eax, DWORD PTR _vecValidTable$276214[esp+56]
  0014c	85 c0		 test	 eax, eax
  0014e	74 09		 je	 SHORT $L291194
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00156	83 c4 04	 add	 esp, 4
$L291194:
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5d		 pop	 ebp
  0015c	b0 02		 mov	 al, 2
  0015e	5b		 pop	 ebx

; 4613 : 
; 4614 : 	return FAILED_BOTH_NEEDVIS;
; 4615 : }

  0015f	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00163	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0016a	83 c4 24	 add	 esp, 36			; 00000024H
  0016d	c2 08 00	 ret	 8
$L276228:

; 4612 : 	}

  00170	8b 44 24 1c	 mov	 eax, DWORD PTR _vecValidTable$276214[esp+56]
  00174	85 c0		 test	 eax, eax
  00176	74 09		 je	 SHORT $L291213
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0017e	83 c4 04	 add	 esp, 4
$L291213:

; 4613 : 
; 4614 : 	return FAILED_BOTH_NEEDVIS;
; 4615 : }

  00181	8b 4c 24 28	 mov	 ecx, DWORD PTR __$EHRec$[esp+52]
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	5d		 pop	 ebp
  00188	32 c0		 xor	 al, al
  0018a	5b		 pop	 ebx
  0018b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00192	83 c4 24	 add	 esp, 36			; 00000024H
  00195	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L291009:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _vecValidTable$276214[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__ehhandler$?IsSatisfyNeedVis@CMover@@QAEEPAVCItemElem@@PAUItemProp@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T291217
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?IsSatisfyNeedVis@CMover@@QAEEPAVCItemElem@@PAUItemProp@@@Z ENDP ; CMover::IsSatisfyNeedVis
PUBLIC	?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z	; CMover::SetPetVisDST
EXTRN	?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z:NEAR ; CMover::SetDestParam
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T291367 DD	0ffffffffH
	DD	FLAT:$L291234
$T291362 DD	019930520H
	DD	01H
	DD	FLAT:$T291367
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
xdata$x	ENDS
;	COMDAT ?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_vecValidTable$276082 = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pItemElem$ = 8						; size = 4
?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z PROC NEAR	; CMover::SetPetVisDST, COMDAT
; _this$ = ecx

; 4381 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	53		 push	 ebx
  00019	56		 push	 esi

; 4382 : 	if( pItemElem && pItemElem->IsVisPet() )

  0001a	8b 74 24 28	 mov	 esi, DWORD PTR _pItemElem$[esp+32]
  0001e	33 db		 xor	 ebx, ebx
  00020	3b f3		 cmp	 esi, ebx
  00022	57		 push	 edi
  00023	8b f9		 mov	 edi, ecx
  00025	0f 84 0a 01 00
	00		 je	 $L291360
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?IsVisPet@CItemElem@@QAEHXZ ; CItemElem::IsVisPet
  00032	85 c0		 test	 eax, eax
  00034	0f 84 fb 00 00
	00		 je	 $L291360
  0003a	55		 push	 ebp

; 4383 : 	{
; 4384 : 		AddBuff( BUFF_EQUIP, (WORD)( pItemElem->m_dwItemId ), 1, 999999999 );

  0003b	33 c0		 xor	 eax, eax
  0003d	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  00041	6a ff		 push	 -1
  00043	68 ff c9 9a 3b	 push	 999999999		; 3b9ac9ffH
  00048	6a 01		 push	 1
  0004a	8b cf		 mov	 ecx, edi
  0004c	50		 push	 eax
  0004d	6a 04		 push	 4
  0004f	e8 00 00 00 00	 call	 ?AddBuff@CMover@@QAEHGGKKK@Z ; CMover::AddBuff

; 4385 : 		
; 4386 : 		vector<BYTE> vecValidTable = GetValidVisTable( pItemElem );

  00054	56		 push	 esi
  00055	8d 4c 24 14	 lea	 ecx, DWORD PTR _vecValidTable$276082[esp+48]
  00059	51		 push	 ecx
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z ; CMover::GetValidVisTable

; 4387 : 		for( int i=0; i<pItemElem->GetPiercingSize(); i++ )

  00061	8d 6e 3c	 lea	 ebp, DWORD PTR [esi+60]
  00064	8b cd		 mov	 ecx, ebp
  00066	89 5c 24 28	 mov	 DWORD PTR __$EHRec$[esp+52], ebx
  0006a	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  0006f	85 c0		 test	 eax, eax
  00071	0f 8e ac 00 00
	00		 jle	 $L276087
$L276085:

; 4388 : 		{
; 4389 : 			ItemProp* pItemProp = prj.GetItemProp( pItemElem->GetPiercingItem( i ) );

  00077	53		 push	 ebx
  00078	8b cd		 mov	 ecx, ebp
  0007a	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  0007f	85 c0		 test	 eax, eax
  00081	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00087	7c 19		 jl	 SHORT $L291269
  00089	3b c1		 cmp	 eax, ecx
  0008b	7d 15		 jge	 SHORT $L291269
  0008d	72 06		 jb	 SHORT $L291281
  0008f	33 c0		 xor	 eax, eax
  00091	8b f0		 mov	 esi, eax
  00093	eb 25		 jmp	 SHORT $L291264
$L291281:
  00095	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  0009b	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0009e	8b f0		 mov	 esi, eax
  000a0	eb 18		 jmp	 SHORT $L291264
$L291269:
  000a2	50		 push	 eax
  000a3	51		 push	 ecx
  000a4	6a 00		 push	 0
  000a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000ab	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000b0	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000b5	83 c4 14	 add	 esp, 20			; 00000014H
  000b8	33 f6		 xor	 esi, esi
$L291264:

; 4390 : 			if( vecValidTable[i] == SUCCSESS_NEEDVIS && pItemProp )

  000ba	8b 44 24 14	 mov	 eax, DWORD PTR _vecValidTable$276082[esp+48]
  000be	80 3c 18 03	 cmp	 BYTE PTR [eax+ebx], 3
  000c2	75 2a		 jne	 SHORT $L291365
  000c4	85 f6		 test	 esi, esi
  000c6	74 26		 je	 SHORT $L291365

; 4391 : 			{
; 4392 : 				SetDestParam( 0, pItemProp );

  000c8	6a 01		 push	 1
  000ca	56		 push	 esi
  000cb	6a 00		 push	 0
  000cd	8b cf		 mov	 ecx, edi
  000cf	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ; CMover::SetDestParam

; 4393 : 				SetDestParam( 1, pItemProp );

  000d4	6a 01		 push	 1
  000d6	56		 push	 esi
  000d7	6a 01		 push	 1
  000d9	8b cf		 mov	 ecx, edi
  000db	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ; CMover::SetDestParam

; 4394 : 				SetDestParam( 2, pItemProp );

  000e0	6a 01		 push	 1
  000e2	56		 push	 esi
  000e3	6a 02		 push	 2
  000e5	8b cf		 mov	 ecx, edi
  000e7	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ; CMover::SetDestParam

; 4395 : 			}
; 4396 : 			else

  000ec	eb 25		 jmp	 SHORT $L276086
$L291365:

; 4397 : 			{
; 4398 : 				if( IsPlayer() && pItemProp )

  000ee	8b 87 34 02 00
	00		 mov	 eax, DWORD PTR [edi+564]
  000f4	85 c0		 test	 eax, eax
  000f6	74 1b		 je	 SHORT $L276086
  000f8	85 f6		 test	 esi, esi
  000fa	74 17		 je	 SHORT $L276086

; 4399 : 					static_cast<CUser*>( this )->AddDefinedText( TID_GAME_BUFFPET_NOTREQVIS, "\"%s\"", pItemProp->szName );

  000fc	83 c6 04	 add	 esi, 4
  000ff	56		 push	 esi
  00100	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00105	68 85 10 00 00	 push	 4229			; 00001085H
  0010a	57		 push	 edi
  0010b	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00110	83 c4 10	 add	 esp, 16			; 00000010H
$L276086:
  00113	8b cd		 mov	 ecx, ebp
  00115	43		 inc	 ebx
  00116	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  0011b	3b d8		 cmp	 ebx, eax
  0011d	0f 8c 54 ff ff
	ff		 jl	 $L276085
$L276087:

; 4400 : 			}
; 4401 : 		}
; 4402 : 	}

  00123	8b 44 24 14	 mov	 eax, DWORD PTR _vecValidTable$276082[esp+48]
  00127	85 c0		 test	 eax, eax
  00129	5d		 pop	 ebp
  0012a	74 09		 je	 SHORT $L291360
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00132	83 c4 04	 add	 esp, 4
$L291360:

; 4403 : }

  00135	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00143	83 c4 1c	 add	 esp, 28			; 0000001cH
  00146	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L291234:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _vecValidTable$276082[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__ehhandler$?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T291362
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z ENDP		; CMover::SetPetVisDST
PUBLIC	?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z	; CMover::ResetPetVisDST
EXTRN	?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z:NEAR ; CMover::ResetDestParam
EXTRN	?RemoveBuff@CBuffMgr@@QAEXGGH@Z:NEAR		; CBuffMgr::RemoveBuff
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T291501 DD	0ffffffffH
	DD	FLAT:$L291373
$T291497 DD	019930520H
	DD	01H
	DD	FLAT:$T291501
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
xdata$x	ENDS
;	COMDAT ?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_vecValidTable$276100 = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pItemElem$ = 8						; size = 4
?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z PROC NEAR	; CMover::ResetPetVisDST, COMDAT
; _this$ = ecx

; 4406 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	53		 push	 ebx
  00019	56		 push	 esi

; 4407 : 	if( pItemElem && pItemElem->IsVisPet() )

  0001a	8b 74 24 28	 mov	 esi, DWORD PTR _pItemElem$[esp+32]
  0001e	33 db		 xor	 ebx, ebx
  00020	3b f3		 cmp	 esi, ebx
  00022	57		 push	 edi
  00023	8b f9		 mov	 edi, ecx
  00025	0f 84 df 00 00
	00		 je	 $L291495
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?IsVisPet@CItemElem@@QAEHXZ ; CItemElem::IsVisPet
  00032	85 c0		 test	 eax, eax
  00034	0f 84 d0 00 00
	00		 je	 $L291495

; 4408 : 	{
; 4409 : 		m_buffs.RemoveBuff( BUFF_EQUIP, (WORD)( pItemElem->m_dwItemId ), FALSE );

  0003a	33 c0		 xor	 eax, eax
  0003c	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  00040	55		 push	 ebp
  00041	53		 push	 ebx
  00042	8d 8f f0 02 00
	00		 lea	 ecx, DWORD PTR [edi+752]
  00048	50		 push	 eax
  00049	6a 04		 push	 4
  0004b	e8 00 00 00 00	 call	 ?RemoveBuff@CBuffMgr@@QAEXGGH@Z ; CBuffMgr::RemoveBuff

; 4410 : 
; 4411 : 		vector<BYTE> vecValidTable = GetValidVisTable( pItemElem );

  00050	56		 push	 esi
  00051	8d 4c 24 14	 lea	 ecx, DWORD PTR _vecValidTable$276100[esp+48]
  00055	51		 push	 ecx
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?GetValidVisTable@CMover@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@PAVCItemElem@@@Z ; CMover::GetValidVisTable

; 4412 : 		for( int i=0; i<pItemElem->GetPiercingSize(); i++ )

  0005d	8d 6e 3c	 lea	 ebp, DWORD PTR [esi+60]
  00060	8b cd		 mov	 ecx, ebp
  00062	89 5c 24 28	 mov	 DWORD PTR __$EHRec$[esp+52], ebx
  00066	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  0006b	85 c0		 test	 eax, eax
  0006d	0f 8e 85 00 00
	00		 jle	 $L276105
$L276103:

; 4413 : 		{
; 4414 : 			ItemProp* pItemProp = prj.GetItemProp( pItemElem->GetPiercingItem( i ) );

  00073	53		 push	 ebx
  00074	8b cd		 mov	 ecx, ebp
  00076	e8 00 00 00 00	 call	 ?GetPiercingItem@CPiercing@@QAEKH@Z ; CPiercing::GetPiercingItem
  0007b	85 c0		 test	 eax, eax
  0007d	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00083	7c 19		 jl	 SHORT $L291408
  00085	3b c1		 cmp	 eax, ecx
  00087	7d 15		 jge	 SHORT $L291408
  00089	72 06		 jb	 SHORT $L291420
  0008b	33 c0		 xor	 eax, eax
  0008d	8b f0		 mov	 esi, eax
  0008f	eb 25		 jmp	 SHORT $L291403
$L291420:
  00091	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+588
  00097	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0009a	8b f0		 mov	 esi, eax
  0009c	eb 18		 jmp	 SHORT $L291403
$L291408:
  0009e	50		 push	 eax
  0009f	51		 push	 ecx
  000a0	6a 00		 push	 0
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000ac	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
  000b4	33 f6		 xor	 esi, esi
$L291403:

; 4415 : 			if( vecValidTable[i] == SUCCSESS_NEEDVIS && pItemProp )

  000b6	8b 44 24 14	 mov	 eax, DWORD PTR _vecValidTable$276100[esp+48]
  000ba	80 3c 18 03	 cmp	 BYTE PTR [eax+ebx], 3
  000be	75 28		 jne	 SHORT $L276104
  000c0	85 f6		 test	 esi, esi
  000c2	74 24		 je	 SHORT $L276104

; 4416 : 			{
; 4417 : 				ResetDestParam( 0, pItemProp );

  000c4	6a 01		 push	 1
  000c6	56		 push	 esi
  000c7	6a 00		 push	 0
  000c9	8b cf		 mov	 ecx, edi
  000cb	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ; CMover::ResetDestParam

; 4418 : 				ResetDestParam( 1, pItemProp );

  000d0	6a 01		 push	 1
  000d2	56		 push	 esi
  000d3	6a 01		 push	 1
  000d5	8b cf		 mov	 ecx, edi
  000d7	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ; CMover::ResetDestParam

; 4419 : 				ResetDestParam( 2, pItemProp );

  000dc	6a 01		 push	 1
  000de	56		 push	 esi
  000df	6a 02		 push	 2
  000e1	8b cf		 mov	 ecx, edi
  000e3	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ; CMover::ResetDestParam
$L276104:
  000e8	8b cd		 mov	 ecx, ebp
  000ea	43		 inc	 ebx
  000eb	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  000f0	3b d8		 cmp	 ebx, eax
  000f2	0f 8c 7b ff ff
	ff		 jl	 $L276103
$L276105:

; 4420 : 			}
; 4421 : 		}
; 4422 : 	}

  000f8	8b 44 24 14	 mov	 eax, DWORD PTR _vecValidTable$276100[esp+48]
  000fc	85 c0		 test	 eax, eax
  000fe	5d		 pop	 ebp
  000ff	74 09		 je	 SHORT $L291495
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00107	83 c4 04	 add	 esp, 4
$L291495:

; 4423 : }

  0010a	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00118	83 c4 1c	 add	 esp, 28			; 0000001cH
  0011b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L291373:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _vecValidTable$276100[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__ehhandler$?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T291497
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z ENDP	; CMover::ResetPetVisDST
PUBLIC	?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z	; CMover::ActivateEatPet
EXTRN	?SetItem@CAIPet@@QAEXPAVCMover@@PAVCItemElem@@@Z:NEAR ; CAIPet::SetItem
EXTRN	?CreateMover@@YAPAVCMover@@PAVCWorld@@KABUD3DXVECTOR3@@H@Z:NEAR ; CreateMover
EXTRN	?GetVisPetSfxId@CItemElem@@QAEKXZ:NEAR		; CItemElem::GetVisPetSfxId
EXTRN	?AddActivateVisPet@CUser@@QAEXKK@Z:NEAR		; CUser::AddActivateVisPet
; Function compile flags: /Ogty
;	COMDAT ?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
$T291507 = -12						; size = 12
_pItemElem$ = 8						; size = 4
?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z PROC NEAR	; CMover::ActivateEatPet, COMDAT
; _this$ = ecx

; 4304 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx

; 4305 : 	ItemProp* pProp	= pItemElem->GetProp();

  00004	8b 5c 24 14	 mov	 ebx, DWORD PTR _pItemElem$[esp+12]
  00008	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0000b	85 c0		 test	 eax, eax
  0000d	56		 push	 esi
  0000e	8b f1		 mov	 esi, ecx
  00010	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00016	7c 51		 jl	 SHORT $L291558
  00018	3b c1		 cmp	 eax, ecx
  0001a	7d 4d		 jge	 SHORT $L291558
  0001c	72 40		 jb	 SHORT $L291570
  0001e	33 c0		 xor	 eax, eax
$L291553:

; 4306 : 	if( !pProp )

  00020	85 c0		 test	 eax, eax
  00022	0f 84 23 01 00
	00		 je	 $L276059

; 4307 : 		return;
; 4308 : 
; 4309 : #ifdef __QUIZ
; 4310 : 	if( GetWorld() && GetWorld()->GetID() == WI_WORLD_QUIZ )

  00028	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  0002e	85 c9		 test	 ecx, ecx
  00030	74 0c		 je	 SHORT $L276050
  00032	81 39 d3 00 00
	00		 cmp	 DWORD PTR [ecx], 211	; 000000d3H
  00038	0f 84 0d 01 00
	00		 je	 $L276059
$L276050:

; 4311 : 		return;
; 4312 : #endif // __QUIZ
; 4313 : 
; 4314 : 	if( IsFly() )

  0003e	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  00044	f6 42 08 08	 test	 BYTE PTR [edx+8], 8
  00048	74 3d		 je	 SHORT $L276051

; 4315 : 	{
; 4316 : 		static_cast<CUser*>( this )->AddDefinedText( TID_GAME_CANNOT_CALL_PET_ON_FLYING );

  0004a	68 8a 0c 00 00	 push	 3210			; 00000c8aH
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx

; 4345 : 			}
; 4346 : #endif // __PETVIS
; 4347 : 		}
; 4348 : 	}
; 4349 : }

  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	c2 04 00	 ret	 4

; 4305 : 	ItemProp* pProp	= pItemElem->GetProp();

$L291570:
  0005e	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00064	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00067	eb b7		 jmp	 SHORT $L291553
$L291558:
  00069	50		 push	 eax
  0006a	51		 push	 ecx
  0006b	6a 00		 push	 0
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00072	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00077	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0007c	83 c4 14	 add	 esp, 20			; 00000014H
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 4345 : 			}
; 4346 : #endif // __PETVIS
; 4347 : 		}
; 4348 : 	}
; 4349 : }

  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	c2 04 00	 ret	 4
$L276051:

; 4317 : 		return;
; 4318 : 	}
; 4319 : //		ASSERT( pItemProp->dwLinkKind != NULL_ID )
; 4320 : #ifdef __LAYER_1015
; 4321 : 	CMover *pEatPet	= CreateMover( GetWorld(), pProp->dwLinkKind, GetPos(), GetLayer() );

  00087	8b 96 b8 01 00
	00		 mov	 edx, DWORD PTR [esi+440]
  0008d	8b 80 e0 00 00
	00		 mov	 eax, DWORD PTR [eax+224]
  00093	55		 push	 ebp
  00094	57		 push	 edi
  00095	52		 push	 edx
  00096	8d be 60 01 00
	00		 lea	 edi, DWORD PTR [esi+352]
  0009c	8b 2f		 mov	 ebp, DWORD PTR [edi]
  0009e	8d 54 24 14	 lea	 edx, DWORD PTR $T291507[esp+32]
  000a2	52		 push	 edx
  000a3	89 6c 24 18	 mov	 DWORD PTR $T291507[esp+36], ebp
  000a7	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  000aa	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000ad	50		 push	 eax
  000ae	51		 push	 ecx
  000af	89 6c 24 24	 mov	 DWORD PTR $T291507[esp+48], ebp
  000b3	89 7c 24 28	 mov	 DWORD PTR $T291507[esp+52], edi
  000b7	e8 00 00 00 00	 call	 ?CreateMover@@YAPAVCMover@@PAVCWorld@@KABUD3DXVECTOR3@@H@Z ; CreateMover
  000bc	8b f8		 mov	 edi, eax
  000be	83 c4 10	 add	 esp, 16			; 00000010H

; 4322 : #else	// __LAYER_1015
; 4323 : 	CMover *pEatPet	= CreateMover( GetWorld(), pProp->dwLinkKind, GetPos() );
; 4324 : #endif	// __LAYER_1015
; 4325 : 	if( pEatPet )

  000c1	85 ff		 test	 edi, edi
  000c3	0f 84 80 00 00
	00		 je	 $L291629

; 4326 : 	{
; 4327 : 		CAIPet *pAIPet	= static_cast<CAIPet*>( pEatPet->m_pAIInterface );

  000c9	8b 8f 88 01 00
	00		 mov	 ecx, DWORD PTR [edi+392]

; 4328 : 		if( pAIPet )

  000cf	85 c9		 test	 ecx, ecx
  000d1	74 76		 je	 SHORT $L291629

; 4329 : 		{
; 4330 : 			pAIPet->SetOwner( GetId() );

  000d3	8b 96 bc 01 00
	00		 mov	 edx, DWORD PTR [esi+444]
  000d9	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 4331 : 			SetEatPetId( pEatPet->GetId() );

  000dc	8b 87 bc 01 00
	00		 mov	 eax, DWORD PTR [edi+444]

; 4332 : #if __VER >= 12 // __PET_0519
; 4333 : 			pAIPet->SetItem( this, pItemElem );		//      

  000e2	53		 push	 ebx
  000e3	56		 push	 esi
  000e4	89 86 7c 06 00
	00		 mov	 DWORD PTR [esi+1660], eax
  000ea	e8 00 00 00 00	 call	 ?SetItem@CAIPet@@QAEXPAVCMover@@PAVCItemElem@@@Z ; CAIPet::SetItem

; 4334 : #endif	// __PET_0519
; 4335 : #if __VER >= 15 // __PETVIS
; 4336 : 			if( pItemElem->IsVisPet() )

  000ef	8b cb		 mov	 ecx, ebx
  000f1	e8 00 00 00 00	 call	 ?IsVisPet@CItemElem@@QAEHXZ ; CItemElem::IsVisPet
  000f6	85 c0		 test	 eax, eax
  000f8	74 4f		 je	 SHORT $L291629

; 4337 : 			{
; 4338 : 				if( pItemElem->GetPiercingSize() <= 0 )	//      2() 

  000fa	8d 4b 3c	 lea	 ecx, DWORD PTR [ebx+60]
  000fd	e8 00 00 00 00	 call	 ?GetPiercingSize@CPiercing@@QAEHXZ ; CPiercing::GetPiercingSize
  00102	85 c0		 test	 eax, eax
  00104	7f 13		 jg	 SHORT $L276060

; 4339 : 					UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_PETVIS_SIZE, PETVIS_DEFAULT_VIS_SLOT_SZIE );

  00106	33 c9		 xor	 ecx, ecx
  00108	8a 4b 04	 mov	 cl, BYTE PTR [ebx+4]
  0010b	6a 00		 push	 0
  0010d	6a 02		 push	 2
  0010f	6a 0f		 push	 15			; 0000000fH
  00111	51		 push	 ecx
  00112	8b ce		 mov	 ecx, esi
  00114	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L276060:

; 4340 : 
; 4341 : 				SetVisPetItem( pItemElem->m_dwObjId );	//        .

  00119	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 4342 : 				SetPetVisDST( pItemElem );

  0011c	53		 push	 ebx
  0011d	8b ce		 mov	 ecx, esi
  0011f	89 96 94 11 00
	00		 mov	 DWORD PTR [esi+4500], edx
  00125	e8 00 00 00 00	 call	 ?SetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z ; CMover::SetPetVisDST

; 4343 : 				pEatPet->m_dwMoverSfxId = pItemElem->GetVisPetSfxId();

  0012a	8b cb		 mov	 ecx, ebx
  0012c	e8 00 00 00 00	 call	 ?GetVisPetSfxId@CItemElem@@QAEKXZ ; CItemElem::GetVisPetSfxId
  00131	89 87 90 11 00
	00		 mov	 DWORD PTR [edi+4496], eax

; 4344 : 				static_cast<CUser*>(this)->AddActivateVisPet( pItemElem->m_dwObjId, GetEatPetId() );

  00137	8b 86 7c 06 00
	00		 mov	 eax, DWORD PTR [esi+1660]
  0013d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00140	50		 push	 eax
  00141	51		 push	 ecx
  00142	8b ce		 mov	 ecx, esi
  00144	e8 00 00 00 00	 call	 ?AddActivateVisPet@CUser@@QAEXKK@Z ; CUser::AddActivateVisPet
$L291629:
  00149	5f		 pop	 edi
  0014a	5d		 pop	 ebp
$L276059:
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx

; 4345 : 			}
; 4346 : #endif // __PETVIS
; 4347 : 		}
; 4348 : 	}
; 4349 : }

  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00150	c2 04 00	 ret	 4
?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z ENDP	; CMover::ActivateEatPet
_TEXT	ENDS
PUBLIC	?InactivateEatPet@CMover@@QAEXXZ		; CMover::InactivateEatPet
EXTRN	?ResetItem@CAIPet@@QAEXXZ:NEAR			; CAIPet::ResetItem
; Function compile flags: /Ogty
;	COMDAT ?InactivateEatPet@CMover@@QAEXXZ
_TEXT	SEGMENT
?InactivateEatPet@CMover@@QAEXXZ PROC NEAR		; CMover::InactivateEatPet, COMDAT
; _this$ = ecx

; 4352 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4353 : 	CMover* pEatPet		= prj.GetMover( GetEatPetId() );

  00003	8b 86 7c 06 00
	00		 mov	 eax, DWORD PTR [esi+1660]
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00010	e8 00 00 00 00	 call	 ?GetMover@CProject@@QAEPAVCMover@@K@Z ; CProject::GetMover
  00015	8b f8		 mov	 edi, eax

; 4354 : 	if( IsValidObj( pEatPet ) )

  00017	85 ff		 test	 edi, edi
  00019	74 61		 je	 SHORT $L291689
  0001b	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  0001f	75 5b		 jne	 SHORT $L291689
  00021	53		 push	 ebx

; 4355 : 	{
; 4356 : #if __VER >= 12 // __PET_0519
; 4357 : 		//       
; 4358 : 		CAIPet *pAIPet	= static_cast<CAIPet*>( pEatPet->m_pAIInterface );

  00022	8b 9f 88 01 00
	00		 mov	 ebx, DWORD PTR [edi+392]

; 4359 : 		if( pAIPet )

  00028	85 db		 test	 ebx, ebx
  0002a	74 48		 je	 SHORT $L276071

; 4360 : 		{
; 4361 : #if __VER >= 15 // __PETVIS
; 4362 : 			CItemElem* pItemElem = GetVisPetItem();

  0002c	8b 86 94 11 00
	00		 mov	 eax, DWORD PTR [esi+4500]
  00032	3b 86 9c 0b 00
	00		 cmp	 eax, DWORD PTR [esi+2972]
  00038	73 33		 jae	 SHORT $L276073
  0003a	8b 96 a0 0b 00
	00		 mov	 edx, DWORD PTR [esi+2976]
  00040	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00046	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  0004a	03 c2		 add	 eax, edx
  0004c	85 c9		 test	 ecx, ecx
  0004e	74 1d		 je	 SHORT $L276073

; 4363 : 			if( pItemElem )
; 4364 : 			{
; 4365 : 				ResetPetVisDST( pItemElem );

  00050	50		 push	 eax
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?ResetPetVisDST@CMover@@QAEXPAVCItemElem@@@Z ; CMover::ResetPetVisDST

; 4366 : 				SetVisPetItem( NULL_ID );
; 4367 : 				static_cast<CUser*>(this)->AddActivateVisPet( NULL_ID, NULL_ID );

  00058	6a ff		 push	 -1
  0005a	6a ff		 push	 -1
  0005c	8b ce		 mov	 ecx, esi
  0005e	c7 86 94 11 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4500], -1
  00068	e8 00 00 00 00	 call	 ?AddActivateVisPet@CUser@@QAEXKK@Z ; CUser::AddActivateVisPet
$L276073:

; 4368 : 			}
; 4369 : #endif // __PETVIS
; 4370 : 			pAIPet->ResetItem();

  0006d	8b cb		 mov	 ecx, ebx
  0006f	e8 00 00 00 00	 call	 ?ResetItem@CAIPet@@QAEXXZ ; CAIPet::ResetItem
$L276071:

; 4371 : 		}
; 4372 : #endif	// __PET_0519
; 4373 : 
; 4374 : 		pEatPet->Delete();

  00074	8b cf		 mov	 ecx, edi
  00076	e8 00 00 00 00	 call	 ?Delete@CObj@@QAEXXZ	; CObj::Delete
  0007b	5b		 pop	 ebx
$L291689:
  0007c	5f		 pop	 edi

; 4375 : 	}
; 4376 : 	SetEatPetId( NULL_ID );

  0007d	c7 86 7c 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1660], -1
  00087	5e		 pop	 esi

; 4377 : }

  00088	c3		 ret	 0
?InactivateEatPet@CMover@@QAEXXZ ENDP			; CMover::InactivateEatPet
_TEXT	ENDS
PUBLIC	?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z	; CMover::DoUseBarunaPet
PUBLIC	??_C@_0N@EGNMKPHL@Pet_Seltpiyo?$AA@		; `string'
PUBLIC	??_C@_0N@BOLHNAPJ@Pet_Seltpudi?$AA@		; `string'
PUBLIC	??_C@_0N@CNOPGOC@Pet_Seltcobi?$AA@		; `string'
PUBLIC	??_C@_0P@NPNKEHMC@Pet_Seltpierce?$AA@		; `string'
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ctrl.h
xdata$x	SEGMENT
$T291857 DD	0ffffffffH
	DD	FLAT:$L291694
$T291849 DD	019930520H
	DD	01H
	DD	FLAT:$T291857
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0N@BOLHNAPJ@Pet_Seltpudi?$AA@
CONST	SEGMENT
??_C@_0N@BOLHNAPJ@Pet_Seltpudi?$AA@ DB 'Pet_Seltpudi', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CNOPGOC@Pet_Seltcobi?$AA@
CONST	SEGMENT
??_C@_0N@CNOPGOC@Pet_Seltcobi?$AA@ DB 'Pet_Seltcobi', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NPNKEHMC@Pet_Seltpierce?$AA@
CONST	SEGMENT
??_C@_0P@NPNKEHMC@Pet_Seltpierce?$AA@ DB 'Pet_Seltpierce', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EGNMKPHL@Pet_Seltpiyo?$AA@
CONST	SEGMENT
??_C@_0N@EGNMKPHL@Pet_Seltpiyo?$AA@ DB 'Pet_Seltpiyo', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
$T291693 = -24						; size = 12
__$EHRec$ = -12						; size = 12
_szCharacterKey$276139 = 8				; size = 4
_pItemElem$ = 8						; size = 4
?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z PROC NEAR	; CMover::DoUseBarunaPet, COMDAT
; _this$ = ecx

; 4448 : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	57		 push	 edi
  00019	8b f9		 mov	 edi, ecx

; 4449 : 	if( HasActivatedEatPet() )

  0001b	8b 87 7c 06 00
	00		 mov	 eax, DWORD PTR [edi+1660]
  00021	83 f8 ff	 cmp	 eax, -1
  00024	74 4f		 je	 SHORT $L276130

; 4450 : 	{
; 4451 : 		CMover* pPet = prj.GetMover( GetEatPetId() );

  00026	50		 push	 eax
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0002c	e8 00 00 00 00	 call	 ?GetMover@CProject@@QAEPAVCMover@@K@Z ; CProject::GetMover

; 4452 : 		if( pPet && pPet->GetProp()->dwAI == AII_NONE )

  00031	85 c0		 test	 eax, eax
  00033	74 27		 je	 SHORT $L276129
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?GetPropA@CMover@@QAEPAUMoverProp@@XZ ; CMover::GetPropA
  0003c	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0003f	85 c9		 test	 ecx, ecx
  00041	75 19		 jne	 SHORT $L276129

; 4453 : 		{
; 4454 : 			InactivateBarunaPet();

  00043	8b cf		 mov	 ecx, edi
  00045	e8 00 00 00 00	 call	 ?InactivateBarunaPet@CMover@@QAEXXZ ; CMover::InactivateBarunaPet
  0004a	5f		 pop	 edi

; 4512 : }

  0004b	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	c2 04 00	 ret	 4
$L276129:

; 4455 : 			return;
; 4456 : 		}
; 4457 : 		else
; 4458 : 		{
; 4459 : 			InactivateEatPet();

  0005c	8b cf		 mov	 ecx, edi
  0005e	e8 00 00 00 00	 call	 ?InactivateEatPet@CMover@@QAEXXZ ; CMover::InactivateEatPet
  00063	5f		 pop	 edi

; 4512 : }

  00064	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006f	83 c4 18	 add	 esp, 24			; 00000018H
  00072	c2 04 00	 ret	 4
$L276130:

; 4460 : 			return;
; 4461 : 		}
; 4462 : 	}
; 4463 : 
; 4464 : 	ItemProp* pProp	= pItemElem->GetProp();

  00075	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0007b	55		 push	 ebp
  0007c	8b 6c 24 24	 mov	 ebp, DWORD PTR _pItemElem$[esp+28]
  00080	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00083	85 c0		 test	 eax, eax
  00085	7c 5e		 jl	 SHORT $L291753
  00087	3b c1		 cmp	 eax, ecx
  00089	7d 5a		 jge	 SHORT $L291753
  0008b	53		 push	 ebx
  0008c	72 4c		 jb	 SHORT $L291765
  0008e	33 db		 xor	 ebx, ebx
$L291748:

; 4465 : 	if( !pProp )

  00090	85 db		 test	 ebx, ebx
  00092	0f 84 7d 01 00
	00		 je	 $L291853

; 4466 : 		return;
; 4467 : 
; 4468 : #ifdef __QUIZ
; 4469 : 	if( GetWorld() && GetWorld()->GetID() == WI_WORLD_QUIZ )

  00098	8b 87 6c 01 00
	00		 mov	 eax, DWORD PTR [edi+364]
  0009e	85 c0		 test	 eax, eax
  000a0	74 0c		 je	 SHORT $L276133
  000a2	81 38 d3 00 00
	00		 cmp	 DWORD PTR [eax], 211	; 000000d3H
  000a8	0f 84 67 01 00
	00		 je	 $L291853
$L276133:

; 4470 : 		return;
; 4471 : #endif // __QUIZ
; 4472 : 
; 4473 : 	if( IsFly() )

  000ae	8b 97 3c 02 00
	00		 mov	 edx, DWORD PTR [edi+572]
  000b4	f6 42 08 08	 test	 BYTE PTR [edx+8], 8
  000b8	74 54		 je	 SHORT $L276134

; 4474 : 	{
; 4475 : 		static_cast<CUser*>( this )->AddDefinedText( TID_GAME_CANNOT_CALL_PET_ON_FLYING );

  000ba	68 8a 0c 00 00	 push	 3210			; 00000c8aH
  000bf	8b cf		 mov	 ecx, edi
  000c1	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText
  000c6	5b		 pop	 ebx
  000c7	5d		 pop	 ebp
  000c8	5f		 pop	 edi

; 4512 : }

  000c9	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  000cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d4	83 c4 18	 add	 esp, 24			; 00000018H
  000d7	c2 04 00	 ret	 4

; 4460 : 			return;
; 4461 : 		}
; 4462 : 	}
; 4463 : 
; 4464 : 	ItemProp* pProp	= pItemElem->GetProp();

$L291765:
  000da	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  000e0	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]
  000e3	eb ab		 jmp	 SHORT $L291748
$L291753:
  000e5	50		 push	 eax
  000e6	51		 push	 ecx
  000e7	6a 00		 push	 0
  000e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000ee	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000f3	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000f8	83 c4 14	 add	 esp, 20			; 00000014H
  000fb	5d		 pop	 ebp
  000fc	5f		 pop	 edi

; 4512 : }

  000fd	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00108	83 c4 18	 add	 esp, 24			; 00000018H
  0010b	c2 04 00	 ret	 4
$L276134:

; 4476 : 		return;
; 4477 : 	}
; 4478 : 
; 4479 : 	CMover *pBarunaPet	= CreateMover( GetWorld(), pProp->dwLinkKind, GetPos(), GetLayer() );

  0010e	8b 8f b8 01 00
	00		 mov	 ecx, DWORD PTR [edi+440]
  00114	56		 push	 esi
  00115	8d 97 60 01 00
	00		 lea	 edx, DWORD PTR [edi+352]
  0011b	8b 32		 mov	 esi, DWORD PTR [edx]
  0011d	89 74 24 10	 mov	 DWORD PTR $T291693[esp+40], esi
  00121	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00124	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00127	51		 push	 ecx
  00128	8d 4c 24 14	 lea	 ecx, DWORD PTR $T291693[esp+44]
  0012c	89 54 24 1c	 mov	 DWORD PTR $T291693[esp+52], edx
  00130	8b 93 e0 00 00
	00		 mov	 edx, DWORD PTR [ebx+224]
  00136	51		 push	 ecx
  00137	52		 push	 edx
  00138	50		 push	 eax
  00139	89 74 24 24	 mov	 DWORD PTR $T291693[esp+60], esi
  0013d	e8 00 00 00 00	 call	 ?CreateMover@@YAPAVCMover@@PAVCWorld@@KABUD3DXVECTOR3@@H@Z ; CreateMover
  00142	8b f0		 mov	 esi, eax
  00144	83 c4 10	 add	 esp, 16			; 00000010H

; 4480 : 
; 4481 : 	if( pBarunaPet )

  00147	85 f6		 test	 esi, esi
  00149	0f 84 c5 00 00
	00		 je	 $L291854

; 4482 : 	{
; 4483 : 		CString szCharacterKey;

  0014f	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
  00154	8b 10		 mov	 edx, DWORD PTR [eax]
  00156	8b c8		 mov	 ecx, eax
  00158	ff 52 0c	 call	 DWORD PTR [edx+12]
  0015b	83 c0 10	 add	 eax, 16			; 00000010H
  0015e	89 44 24 2c	 mov	 DWORD PTR _szCharacterKey$276139[esp+36], eax

; 4484 : 		switch( pProp->dwLinkKind )

  00162	8b 9b e0 00 00
	00		 mov	 ebx, DWORD PTR [ebx+224]
  00168	8d 83 3c fb ff
	ff		 lea	 eax, DWORD PTR [ebx-1220]
  0016e	3d db 00 00 00	 cmp	 eax, 219		; 000000dbH
  00173	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 0
  0017b	77 23		 ja	 SHORT $L276152
  0017d	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $L291850[eax]
  00184	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L291856[eax*4]
$L276146:

; 4485 : 		{
; 4486 : 		case MI_PET_SMELTPIYO:
; 4487 : 			szCharacterKey = "Pet_Seltpiyo";
; 4488 : 			break;
; 4489 : 		case MI_PET_SMELTUDI:
; 4490 : 			szCharacterKey = "Pet_Seltpudi";

  0018b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@BOLHNAPJ@Pet_Seltpudi?$AA@

; 4491 : 			break;

  00190	eb 13		 jmp	 SHORT $L291855
$L276148:

; 4492 : 		case MI_PET_SMELTCOBI:
; 4493 : 			szCharacterKey = "Pet_Seltcobi";

  00192	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@CNOPGOC@Pet_Seltcobi?$AA@

; 4494 : 			break;

  00197	eb 0c		 jmp	 SHORT $L291855
$L276150:

; 4495 : 		case MI_PET_SMELTPIERCE:
; 4496 : 			szCharacterKey = "Pet_Seltpierce";

  00199	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@NPNKEHMC@Pet_Seltpierce?$AA@

; 4497 : 			break;

  0019e	eb 05		 jmp	 SHORT $L291855
$L276152:

; 4498 : 		default:
; 4499 : 			szCharacterKey = "Pet_Seltpiyo";

  001a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@EGNMKPHL@Pet_Seltpiyo?$AA@
$L291855:
  001a5	8d 4c 24 30	 lea	 ecx, DWORD PTR _szCharacterKey$276139[esp+40]
  001a9	e8 00 00 00 00	 call	 ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=

; 4500 : 			break;
; 4501 : 		}
; 4502 : 
; 4503 : 		lstrcpy( pBarunaPet->m_szCharacterKey, szCharacterKey );

  001ae	8b 4c 24 2c	 mov	 ecx, DWORD PTR _szCharacterKey$276139[esp+36]
  001b2	51		 push	 ecx
  001b3	8d 96 4c 06 00
	00		 lea	 edx, DWORD PTR [esi+1612]
  001b9	52		 push	 edx
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 4504 : 
; 4505 : 		pBarunaPet->InitNPCProperty();

  001c0	8b ce		 mov	 ecx, esi
  001c2	e8 00 00 00 00	 call	 ?InitNPCProperty@CMover@@QAEXXZ ; CMover::InitNPCProperty

; 4506 : 		pBarunaPet->InitCharacter( pBarunaPet->GetCharacter() );

  001c7	8b ce		 mov	 ecx, esi
  001c9	e8 00 00 00 00	 call	 ?GetCharacter@CMover@@QAEPAUtagCHARACTER@@XZ ; CMover::GetCharacter
  001ce	50		 push	 eax
  001cf	8b ce		 mov	 ecx, esi
  001d1	e8 00 00 00 00	 call	 ?InitCharacter@CMover@@QAEXPAUtagCHARACTER@@@Z ; CMover::InitCharacter

; 4507 : 		pBarunaPet->m_idBarunaPetOwner = GetId();

  001d6	8b 87 bc 01 00
	00		 mov	 eax, DWORD PTR [edi+444]
  001dc	89 86 7c 16 00
	00		 mov	 DWORD PTR [esi+5756], eax

; 4508 : 		dwBarunaPetItemId = pItemElem->m_dwObjId;

  001e2	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001e5	89 8f 78 16 00
	00		 mov	 DWORD PTR [edi+5752], ecx

; 4509 : 		SetEatPetId( pBarunaPet->GetId() );

  001eb	8b 96 bc 01 00
	00		 mov	 edx, DWORD PTR [esi+444]
  001f1	89 97 7c 06 00
	00		 mov	 DWORD PTR [edi+1660], edx

; 4510 : 		static_cast<CUser*>(this)->AddActivateBarunaPet( pItemElem->m_dwObjId, pBarunaPet->GetId(), TRUE );

  001f7	8b 86 bc 01 00
	00		 mov	 eax, DWORD PTR [esi+444]
  001fd	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  00200	6a 01		 push	 1
  00202	50		 push	 eax
  00203	51		 push	 ecx
  00204	8b cf		 mov	 ecx, edi
  00206	e8 00 00 00 00	 call	 ?AddActivateBarunaPet@CUser@@QAEXKKH@Z ; CUser::AddActivateBarunaPet

; 4511 : 	}

  0020b	8d 4c 24 2c	 lea	 ecx, DWORD PTR _szCharacterKey$276139[esp+36]
  0020f	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L291854:
  00214	5e		 pop	 esi
$L291853:

; 4512 : }

  00215	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00219	5b		 pop	 ebx
  0021a	5d		 pop	 ebp
  0021b	5f		 pop	 edi
  0021c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00223	83 c4 18	 add	 esp, 24			; 00000018H
  00226	c2 04 00	 ret	 4
  00229	8d 49 00	 npad	 3
$L291856:
  0022c	00 00 00 00	 DD	 $L276152
  00230	00 00 00 00	 DD	 $L276146
  00234	00 00 00 00	 DD	 $L276148
  00238	00 00 00 00	 DD	 $L276150
  0023c	00 00 00 00	 DD	 $L276152
$L291850:
  00240	00		 DB	 0
  00241	01		 DB	 1
  00242	04		 DB	 4
  00243	04		 DB	 4
  00244	04		 DB	 4
  00245	04		 DB	 4
  00246	04		 DB	 4
  00247	04		 DB	 4
  00248	04		 DB	 4
  00249	04		 DB	 4
  0024a	04		 DB	 4
  0024b	04		 DB	 4
  0024c	04		 DB	 4
  0024d	04		 DB	 4
  0024e	04		 DB	 4
  0024f	04		 DB	 4
  00250	04		 DB	 4
  00251	04		 DB	 4
  00252	04		 DB	 4
  00253	04		 DB	 4
  00254	04		 DB	 4
  00255	04		 DB	 4
  00256	04		 DB	 4
  00257	04		 DB	 4
  00258	04		 DB	 4
  00259	04		 DB	 4
  0025a	04		 DB	 4
  0025b	04		 DB	 4
  0025c	04		 DB	 4
  0025d	04		 DB	 4
  0025e	04		 DB	 4
  0025f	04		 DB	 4
  00260	04		 DB	 4
  00261	04		 DB	 4
  00262	04		 DB	 4
  00263	04		 DB	 4
  00264	04		 DB	 4
  00265	04		 DB	 4
  00266	04		 DB	 4
  00267	04		 DB	 4
  00268	04		 DB	 4
  00269	04		 DB	 4
  0026a	04		 DB	 4
  0026b	04		 DB	 4
  0026c	04		 DB	 4
  0026d	04		 DB	 4
  0026e	04		 DB	 4
  0026f	04		 DB	 4
  00270	04		 DB	 4
  00271	04		 DB	 4
  00272	04		 DB	 4
  00273	04		 DB	 4
  00274	04		 DB	 4
  00275	04		 DB	 4
  00276	04		 DB	 4
  00277	04		 DB	 4
  00278	04		 DB	 4
  00279	04		 DB	 4
  0027a	04		 DB	 4
  0027b	04		 DB	 4
  0027c	04		 DB	 4
  0027d	04		 DB	 4
  0027e	04		 DB	 4
  0027f	04		 DB	 4
  00280	04		 DB	 4
  00281	04		 DB	 4
  00282	04		 DB	 4
  00283	04		 DB	 4
  00284	04		 DB	 4
  00285	04		 DB	 4
  00286	04		 DB	 4
  00287	04		 DB	 4
  00288	04		 DB	 4
  00289	04		 DB	 4
  0028a	04		 DB	 4
  0028b	04		 DB	 4
  0028c	04		 DB	 4
  0028d	04		 DB	 4
  0028e	04		 DB	 4
  0028f	04		 DB	 4
  00290	04		 DB	 4
  00291	04		 DB	 4
  00292	04		 DB	 4
  00293	04		 DB	 4
  00294	04		 DB	 4
  00295	04		 DB	 4
  00296	04		 DB	 4
  00297	04		 DB	 4
  00298	04		 DB	 4
  00299	04		 DB	 4
  0029a	04		 DB	 4
  0029b	04		 DB	 4
  0029c	04		 DB	 4
  0029d	04		 DB	 4
  0029e	04		 DB	 4
  0029f	04		 DB	 4
  002a0	04		 DB	 4
  002a1	04		 DB	 4
  002a2	04		 DB	 4
  002a3	04		 DB	 4
  002a4	04		 DB	 4
  002a5	04		 DB	 4
  002a6	04		 DB	 4
  002a7	04		 DB	 4
  002a8	04		 DB	 4
  002a9	04		 DB	 4
  002aa	04		 DB	 4
  002ab	04		 DB	 4
  002ac	04		 DB	 4
  002ad	04		 DB	 4
  002ae	04		 DB	 4
  002af	04		 DB	 4
  002b0	04		 DB	 4
  002b1	04		 DB	 4
  002b2	04		 DB	 4
  002b3	04		 DB	 4
  002b4	04		 DB	 4
  002b5	04		 DB	 4
  002b6	04		 DB	 4
  002b7	04		 DB	 4
  002b8	04		 DB	 4
  002b9	04		 DB	 4
  002ba	04		 DB	 4
  002bb	04		 DB	 4
  002bc	04		 DB	 4
  002bd	04		 DB	 4
  002be	04		 DB	 4
  002bf	04		 DB	 4
  002c0	04		 DB	 4
  002c1	04		 DB	 4
  002c2	04		 DB	 4
  002c3	04		 DB	 4
  002c4	04		 DB	 4
  002c5	04		 DB	 4
  002c6	04		 DB	 4
  002c7	04		 DB	 4
  002c8	04		 DB	 4
  002c9	04		 DB	 4
  002ca	04		 DB	 4
  002cb	04		 DB	 4
  002cc	04		 DB	 4
  002cd	04		 DB	 4
  002ce	04		 DB	 4
  002cf	04		 DB	 4
  002d0	04		 DB	 4
  002d1	04		 DB	 4
  002d2	04		 DB	 4
  002d3	04		 DB	 4
  002d4	04		 DB	 4
  002d5	04		 DB	 4
  002d6	04		 DB	 4
  002d7	04		 DB	 4
  002d8	04		 DB	 4
  002d9	04		 DB	 4
  002da	04		 DB	 4
  002db	04		 DB	 4
  002dc	04		 DB	 4
  002dd	04		 DB	 4
  002de	04		 DB	 4
  002df	04		 DB	 4
  002e0	04		 DB	 4
  002e1	04		 DB	 4
  002e2	04		 DB	 4
  002e3	04		 DB	 4
  002e4	04		 DB	 4
  002e5	04		 DB	 4
  002e6	04		 DB	 4
  002e7	04		 DB	 4
  002e8	04		 DB	 4
  002e9	04		 DB	 4
  002ea	04		 DB	 4
  002eb	04		 DB	 4
  002ec	04		 DB	 4
  002ed	04		 DB	 4
  002ee	04		 DB	 4
  002ef	04		 DB	 4
  002f0	04		 DB	 4
  002f1	04		 DB	 4
  002f2	04		 DB	 4
  002f3	04		 DB	 4
  002f4	04		 DB	 4
  002f5	04		 DB	 4
  002f6	04		 DB	 4
  002f7	04		 DB	 4
  002f8	04		 DB	 4
  002f9	04		 DB	 4
  002fa	04		 DB	 4
  002fb	04		 DB	 4
  002fc	04		 DB	 4
  002fd	04		 DB	 4
  002fe	04		 DB	 4
  002ff	04		 DB	 4
  00300	04		 DB	 4
  00301	04		 DB	 4
  00302	04		 DB	 4
  00303	04		 DB	 4
  00304	04		 DB	 4
  00305	04		 DB	 4
  00306	04		 DB	 4
  00307	04		 DB	 4
  00308	04		 DB	 4
  00309	04		 DB	 4
  0030a	04		 DB	 4
  0030b	04		 DB	 4
  0030c	04		 DB	 4
  0030d	04		 DB	 4
  0030e	04		 DB	 4
  0030f	04		 DB	 4
  00310	04		 DB	 4
  00311	04		 DB	 4
  00312	04		 DB	 4
  00313	04		 DB	 4
  00314	04		 DB	 4
  00315	04		 DB	 4
  00316	04		 DB	 4
  00317	04		 DB	 4
  00318	04		 DB	 4
  00319	04		 DB	 4
  0031a	02		 DB	 2
  0031b	03		 DB	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L291694:
  00000	8d 4d 04	 lea	 ecx, DWORD PTR _szCharacterKey$276139[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T291849
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z ENDP	; CMover::DoUseBarunaPet
PUBLIC	?DoUseEatPet@CMover@@AAEXPAVCItemElem@@@Z	; CMover::DoUseEatPet
; Function compile flags: /Ogty
;	COMDAT ?DoUseEatPet@CMover@@AAEXPAVCItemElem@@@Z
_TEXT	SEGMENT
_pItemElem$ = 8						; size = 4
?DoUseEatPet@CMover@@AAEXPAVCItemElem@@@Z PROC NEAR	; CMover::DoUseEatPet, COMDAT
; _this$ = ecx

; 4285 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4286 : #ifdef __NEW_ITEM_VARUNA
; 4287 : 	if( HasActivatedEatPet() )

  00003	8b 86 7c 06 00
	00		 mov	 eax, DWORD PTR [esi+1660]
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	74 33		 je	 SHORT $L276039

; 4288 : 	{
; 4289 : 		CMover* pPet = prj.GetMover( GetEatPetId() );

  0000e	50		 push	 eax
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00014	e8 00 00 00 00	 call	 ?GetMover@CProject@@QAEPAVCMover@@K@Z ; CProject::GetMover

; 4290 : 		if( pPet && pPet->GetProp()->dwAI == AII_NONE )

  00019	85 c0		 test	 eax, eax
  0001b	74 19		 je	 SHORT $L276041
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ?GetPropA@CMover@@QAEPAUMoverProp@@XZ ; CMover::GetPropA
  00024	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00027	85 c9		 test	 ecx, ecx
  00029	75 0b		 jne	 SHORT $L276041

; 4291 : 			InactivateBarunaPet();

  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?InactivateBarunaPet@CMover@@QAEXXZ ; CMover::InactivateBarunaPet
  00032	5e		 pop	 esi

; 4301 : }		

  00033	c2 04 00	 ret	 4
$L276041:

; 4292 : 		else
; 4293 : 			InactivateEatPet();

  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?InactivateEatPet@CMover@@QAEXXZ ; CMover::InactivateEatPet
  0003d	5e		 pop	 esi

; 4301 : }		

  0003e	c2 04 00	 ret	 4
$L276039:

; 4294 : 	}
; 4295 : #else // __NEW_ITEM_VARUNA
; 4296 : 	if( HasActivatedEatPet() )
; 4297 : 		InactivateEatPet();
; 4298 : #endif // __NEW_ITEM_VARUNA
; 4299 : 	else
; 4300 : 		ActivateEatPet( pItemElem );

  00041	8b 44 24 08	 mov	 eax, DWORD PTR _pItemElem$[esp]
  00045	50		 push	 eax
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z ; CMover::ActivateEatPet
  0004d	5e		 pop	 esi

; 4301 : }		

  0004e	c2 04 00	 ret	 4
?DoUseEatPet@CMover@@AAEXPAVCItemElem@@@Z ENDP		; CMover::DoUseEatPet
_TEXT	ENDS
PUBLIC	??_C@_0BC@PPLMFBOE@GUILDHOUSE_LISTUP?$AA@	; `string'
PUBLIC	??_C@_01INIBCBCB@f?$AA@				; `string'
PUBLIC	??_C@_0M@HGMIEEBN@HOUSING_USE?$AA@		; `string'
PUBLIC	??_C@_01HNPIGOCE@?$CG?$AA@			; `string'
PUBLIC	??_C@_0N@OINNJKEM@ANGEL_SUMMON?$AA@		; `string'
PUBLIC	??_C@_04PNFMAOFG@?$CC?$CFd?$CC?$AA@		; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_0BE@COEAJDGE@USE_RECCURENCE_ITEM?$AA@	; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BB@KAAKNBKL@USE_RESTATE_ITEM?$AA@	; `string'
PUBLIC	??_C@_07PFGKEPEH@?$CFd?5?9?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_09DPACILDJ@?$CC?$CFs?$CC?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0L@PGLFOAIL@?$CFs?5?$CFd?$CF?$CF?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0DD@FCPHEJAC@DoUseItem?0?5IK2_SKILL?0?5item?5?$CFs?5?9?$DO@ ; `string'
PUBLIC	?DoUseItem@CMover@@QAEHKKH@Z			; CMover::DoUseItem
EXTRN	_strncpy:NEAR
EXTRN	?GetInstance@CHousingMng@@SAPAV1@XZ:NEAR	; CHousingMng::GetInstance
EXTRN	?ReqSetFurnitureList@CHousingMng@@QAEHPAVCUser@@K@Z:NEAR ; CHousingMng::ReqSetFurnitureList
EXTRN	?GetGroup@CCooltimeMgr@@SAKPAUItemProp@@@Z:NEAR	; CCooltimeMgr::GetGroup
EXTRN	?CanUse@CCooltimeMgr@@QAEHK@Z:NEAR		; CCooltimeMgr::CanUse
EXTRN	?SetTime@CCooltimeMgr@@QAEXKK@Z:NEAR		; CCooltimeMgr::SetTime
EXTRN	?DoActiveSkill@CCtrl@@QAEXKHPAV1@_NH@Z:NEAR	; CCtrl::DoActiveSkill
EXTRN	?AddSetFuel@CUser@@QAEXHK@Z:NEAR		; CUser::AddSetFuel
EXTRN	?GetInstance@CGuildHouseMng@@SAPAV1@XZ:NEAR	; CGuildHouseMng::GetInstance
EXTRN	?EnteranceGuildHouse@CGuildHouseMng@@QAEHPAVCUser@@K@Z:NEAR ; CGuildHouseMng::EnteranceGuildHouse
EXTRN	?SendWorldToDatabase@CGuildHouseMng@@QAEHPAVCUser@@HAAUGuildHouse_Furniture_Info@CGuildHouseBase@@H@Z:NEAR ; CGuildHouseMng::SendWorldToDatabase
EXTRN	?GetPropA@CItemBase@@QAEPAUItemProp@@XZ:NEAR	; CItemBase::GetPropA
EXTRN	?AddAngelInfo@CUser@@QAEXH@Z:NEAR		; CUser::AddAngelInfo
EXTRN	?GetInstance@CInstanceDungeonHelper@@SAPAV1@XZ:NEAR ; CInstanceDungeonHelper::GetInstance
EXTRN	?ParsingCommand@@YAHPBDPAVCMover@@H@Z:NEAR	; ParsingCommand
EXTRN	?GetItemId@CMover@@QAEPAVCItemBase@@K@Z:NEAR	; CMover::GetItemId
EXTRN	?PutItemLog@CDPSrvr@@QAEXPAVCUser@@PBD1PAVCItemElem@@H@Z:NEAR ; CDPSrvr::PutItemLog
EXTRN	?GetInstance@CFunnyCoin@@SAPAV1@XZ:NEAR		; CFunnyCoin::GetInstance
EXTRN	?DoUseFunnyCoin@CFunnyCoin@@QAEHPAVCUser@@PAVCItemElem@@@Z:NEAR ; CFunnyCoin::DoUseFunnyCoin
EXTRN	?DoUseEquipmentItem@CMover@@QAEHPAVCItemElem@@KH@Z:NEAR ; CMover::DoUseEquipmentItem
EXTRN	?__SetQuest@@YAXKH@Z:NEAR			; __SetQuest
EXTRN	?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z:NEAR ; CDPDatabaseClient::SendLogSMItemUse
EXTRN	??0GuildHouse_Furniture_Info@CGuildHouseBase@@QAE@KHUD3DXVECTOR3@@MJ@Z:NEAR ; CGuildHouseBase::GuildHouse_Furniture_Info::GuildHouse_Furniture_Info
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\projectcmn.h
xdata$x	SEGMENT
$T292183 DD	0ffffffffH
	DD	FLAT:$L291882
	DD	0ffffffffH
	DD	FLAT:$L291883
	DD	01H
	DD	FLAT:$L291884
	DD	0ffffffffH
	DD	FLAT:$L291885
	DD	0ffffffffH
	DD	FLAT:$L291886
$T292161 DD	019930520H
	DD	05H
	DD	FLAT:$T292183
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BC@PPLMFBOE@GUILDHOUSE_LISTUP?$AA@
CONST	SEGMENT
??_C@_0BC@PPLMFBOE@GUILDHOUSE_LISTUP?$AA@ DB 'GUILDHOUSE_LISTUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01INIBCBCB@f?$AA@
CONST	SEGMENT
??_C@_01INIBCBCB@f?$AA@ DB 'f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HGMIEEBN@HOUSING_USE?$AA@
CONST	SEGMENT
??_C@_0M@HGMIEEBN@HOUSING_USE?$AA@ DB 'HOUSING_USE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG?$AA@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OINNJKEM@ANGEL_SUMMON?$AA@
CONST	SEGMENT
??_C@_0N@OINNJKEM@ANGEL_SUMMON?$AA@ DB 'ANGEL_SUMMON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNFMAOFG@?$CC?$CFd?$CC?$AA@
CONST	SEGMENT
??_C@_04PNFMAOFG@?$CC?$CFd?$CC?$AA@ DB '"%d"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@COEAJDGE@USE_RECCURENCE_ITEM?$AA@
CONST	SEGMENT
??_C@_0BE@COEAJDGE@USE_RECCURENCE_ITEM?$AA@ DB 'USE_RECCURENCE_ITEM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KAAKNBKL@USE_RESTATE_ITEM?$AA@
CONST	SEGMENT
??_C@_0BB@KAAKNBKL@USE_RESTATE_ITEM?$AA@ DB 'USE_RESTATE_ITEM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFGKEPEH@?$CFd?5?9?5?$CFd?$AA@
CONST	SEGMENT
??_C@_07PFGKEPEH@?$CFd?5?9?5?$CFd?$AA@ DB '%d - %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPACILDJ@?$CC?$CFs?$CC?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_09DPACILDJ@?$CC?$CFs?$CC?5?$CC?$CFs?$CC?$AA@ DB '"%s" "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGLFOAIL@?$CFs?5?$CFd?$CF?$CF?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@PGLFOAIL@?$CFs?5?$CFd?$CF?$CF?5?$CFs?$AA@ DB '%s %d%% %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FCPHEJAC@DoUseItem?0?5IK2_SKILL?0?5item?5?$CFs?5?9?$DO@
CONST	SEGMENT
??_C@_0DD@FCPHEJAC@DoUseItem?0?5IK2_SKILL?0?5item?5?$CFs?5?9?$DO@ DB 'DoU'
	DB	'seItem, IK2_SKILL, item %s -> %d skill not prop', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverskill.cpp
CONST	ENDS
;	COMDAT ?DoUseItem@CMover@@QAEHKKH@Z
_TEXT	SEGMENT
_szGMText$274860 = -352					; size = 4
_szMaxBuf$274787 = -352					; size = 4
_str$274777 = -352					; size = 4
_cUIParam$274898 = -348					; size = 1
$T291950 = -348						; size = 8
_strTemp$274803 = -348					; size = 4
_i$274794 = -348					; size = 4
_str$274786 = -348					; size = 4
_pItemBase$ = -348					; size = 4
_dwGroup$274683 = -340					; size = 4
$T291876 = -336						; size = 8
$T291875 = -336						; size = 12
_dwId$ = -324						; size = 2
$T291877 = -320						; size = 8
$T291874 = -312						; size = 32
_aLogItem$274728 = -280					; size = 200
_aLogItem$274708 = -280					; size = 200
_szGMCommand$274859 = -80				; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_dwData$ = 8						; size = 4
_dwFocusId$ = 12					; size = 4
_nPart$ = 16						; size = 4
?DoUseItem@CMover@@QAEHKKH@Z PROC NEAR			; CMover::DoUseItem, COMDAT
; _this$ = ecx

; 1311 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?DoUseItem@CMover@@QAEHKKH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c4		 xor	 eax, esp
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	8b f1		 mov	 esi, ecx
  00027	89 84 24 5c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+364], eax

; 1312 : #ifdef __WORLDSERVER
; 1313 : 	if( IsDie() )

  0002e	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  00034	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  0003b	57		 push	 edi
  0003c	0f 85 44 08 00
	00		 jne	 $L274886
  00042	8b 86 00 06 00
	00		 mov	 eax, DWORD PTR [esi+1536]
  00048	85 c0		 test	 eax, eax

; 1314 : 		return FALSE;

  0004a	0f 84 36 08 00
	00		 je	 $L274886

; 1315 : #ifdef __S_SERVER_UNIFY
; 1316 : 	if( ((CUser*)this)->m_bAllAction == FALSE )

  00050	8b 86 f8 95 00
	00		 mov	 eax, DWORD PTR [esi+38392]
  00056	85 c0		 test	 eax, eax

; 1317 : 		return FALSE;

  00058	0f 84 28 08 00
	00		 je	 $L274886

; 1318 : #endif // __S_SERVER_UNIFY
; 1319 : 
; 1320 : 	WORD dwType = LOWORD( dwData );
; 1321 : 	WORD dwId   = HIWORD( dwData );

  0005e	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR _dwData$[esp+364]
  00065	c1 e8 10	 shr	 eax, 16			; 00000010H

; 1322 : 
; 1323 : 	CItemBase* pItemBase = GetItemId( dwId ); 

  00068	0f b7 f8	 movzx	 edi, ax
  0006b	57		 push	 edi
  0006c	8b ce		 mov	 ecx, esi
  0006e	89 44 24 30	 mov	 DWORD PTR _dwId$[esp+372], eax
  00072	e8 00 00 00 00	 call	 ?GetItemId@CMover@@QAEPAVCItemBase@@K@Z ; CMover::GetItemId
  00077	8b d8		 mov	 ebx, eax

; 1324 : 	if( IsUsableItem( pItemBase ) == FALSE )

  00079	53		 push	 ebx
  0007a	89 5c 24 18	 mov	 DWORD PTR _pItemBase$[esp+372], ebx
  0007e	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  00083	83 c4 04	 add	 esp, 4
  00086	85 c0		 test	 eax, eax

; 1325 : 		return FALSE;

  00088	0f 84 f8 07 00
	00		 je	 $L274886

; 1326 : 
; 1327 : 	CItemElem* pItemElem = (CItemElem*)pItemBase;
; 1328 : 	ItemProp* pItemProp  = pItemBase->GetProp();

  0008e	8b cb		 mov	 ecx, ebx
  00090	e8 00 00 00 00	 call	 ?GetPropA@CItemBase@@QAEPAUItemProp@@XZ ; CItemBase::GetPropA
  00095	8b e8		 mov	 ebp, eax

; 1329 : 
; 1330 : 	if( pItemProp->dwItemKind3 == IK3_LINK )

  00097	83 7d 78 68	 cmp	 DWORD PTR [ebp+120], 104 ; 00000068H
  0009b	75 1b		 jne	 SHORT $L274669

; 1331 : 	{
; 1332 : 		pItemProp	= prj.GetItemProp( pItemProp->dwActiveSkill );

  0009d	8b 8d a0 01 00
	00		 mov	 ecx, DWORD PTR [ebp+416]
  000a3	51		 push	 ecx
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000a9	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp
  000ae	8b e8		 mov	 ebp, eax

; 1333 : 		if( pItemProp == NULL )

  000b0	85 ed		 test	 ebp, ebp

; 1334 : 			return FALSE;

  000b2	0f 84 ce 07 00
	00		 je	 $L274886
$L274669:

; 1335 : 	}
; 1336 : 
; 1337 : 	DWORD dwItemKind1    = pItemProp->dwItemKind1;
; 1338 : 	DWORD dwItemKind2    = pItemProp->dwItemKind2;
; 1339 : 	DWORD dwItemKind3    = pItemProp->dwItemKind3;
; 1340 : 
; 1341 : 	//   
; 1342 : 	CWorld* pWorld	= GetWorld();

  000b8	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]

; 1343 : 	if( pWorld && pWorld->GetID() == WI_WORLD_GUILDWAR )

  000be	85 c0		 test	 eax, eax
  000c0	74 3a		 je	 SHORT $L274675
  000c2	81 38 ca 00 00
	00		 cmp	 DWORD PTR [eax], 202	; 000000caH
  000c8	75 32		 jne	 SHORT $L274675

; 1344 : 	{			
; 1345 : 		if( m_nGuildCombatState == 0 )

  000ca	8b 86 98 0e 00
	00		 mov	 eax, DWORD PTR [esi+3736]
  000d0	85 c0		 test	 eax, eax
  000d2	75 28		 jne	 SHORT $L274675

; 1346 : 		{
; 1347 : 			if( IsPlayer() )

  000d4	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  000da	85 c0		 test	 eax, eax
  000dc	74 17		 je	 SHORT $L274676

; 1348 : 				((CUser*) this)->AddText( prj.GetText( TID_GAME_GUILDCOMBAT_STANDS_NOTUSEITEM ) );	//" :    " );

  000de	68 a3 0b 00 00	 push	 2979			; 00000ba3H
  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000e8	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  000ed	50		 push	 eax
  000ee	8b ce		 mov	 ecx, esi
  000f0	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText
$L274676:

; 1349 : 			return FALSE;

  000f5	33 c0		 xor	 eax, eax
  000f7	e9 d5 0a 00 00	 jmp	 $L274653
$L274675:

; 1350 : 		}
; 1351 : 	}
; 1352 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans    
; 1353 : 	if( GetAdjParam( DST_CHRSTATE ) & CHS_SETSTONE)

  000fc	6a 40		 push	 64			; 00000040H
  000fe	8b ce		 mov	 ecx, esi
  00100	e8 00 00 00 00	 call	 ?GetAdjParam@CMover@@QAEHH@Z ; CMover::GetAdjParam
  00105	a9 00 00 10 00	 test	 eax, 1048576		; 00100000H

; 1354 : 		return FALSE;

  0010a	0f 85 76 07 00
	00		 jne	 $L274886

; 1355 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1356 : 	if( pItemProp->dwParts != NULL_ID )

  00110	83 bd a8 00 00
	00 ff		 cmp	 DWORD PTR [ebp+168], -1
  00117	74 29		 je	 SHORT $L274679

; 1357 : 	{
; 1358 : 		// armor, weapon
; 1359 : 		if( m_pActMover->IsActAttack() == FALSE )	//   .

  00119	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  0011f	f7 42 04 00 00
	ff 00		 test	 DWORD PTR [edx+4], 16711680 ; 00ff0000H
  00126	0f 85 a0 0a 00
	00		 jne	 $L274681

; 1360 : 		{
; 1361 : 			DoUseEquipmentItem( pItemElem, dwId, nPart );

  0012c	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR _nPart$[esp+364]
  00133	50		 push	 eax
  00134	57		 push	 edi
  00135	53		 push	 ebx
  00136	8b ce		 mov	 ecx, esi
  00138	e8 00 00 00 00	 call	 ?DoUseEquipmentItem@CMover@@QAEHPAVCItemElem@@KH@Z ; CMover::DoUseEquipmentItem

; 1362 : 		}
; 1363 : 		//          .
; 1364 : 	}
; 1365 : 	else	//    

  0013d	e9 8a 0a 00 00	 jmp	 $L274681
$L274679:

; 1366 : 	{
; 1367 : 		if( IsItemRedyTime( pItemProp, pItemElem->m_dwObjId, TRUE ) == FALSE )

  00142	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00145	bf 01 00 00 00	 mov	 edi, 1
  0014a	57		 push	 edi
  0014b	51		 push	 ecx
  0014c	55		 push	 ebp
  0014d	8b ce		 mov	 ecx, esi
  0014f	e8 00 00 00 00	 call	 ?IsItemRedyTime@CMover@@QAEHPAUItemProp@@KH@Z ; CMover::IsItemRedyTime
  00154	85 c0		 test	 eax, eax

; 1368 : 			return FALSE;

  00156	0f 84 2a 07 00
	00		 je	 $L274886

; 1369 : 
; 1370 : 		DWORD dwGroup = 0;
; 1371 : 
; 1372 : 		if( IsPlayer() )

  0015c	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00162	85 c0		 test	 eax, eax
  00164	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _dwGroup$274683[esp+368], 0
  0016c	74 25		 je	 SHORT $L292171

; 1373 : 		{
; 1374 : 			CUser* pUser = (CUser*)this;
; 1375 : 
; 1376 : 			dwGroup = pUser->m_cooltimeMgr.GetGroup( pItemProp );

  0016e	55		 push	 ebp
  0016f	e8 00 00 00 00	 call	 ?GetGroup@CCooltimeMgr@@SAKPAUItemProp@@@Z ; CCooltimeMgr::GetGroup
  00174	83 c4 04	 add	 esp, 4

; 1377 : 			if( dwGroup )

  00177	85 c0		 test	 eax, eax
  00179	89 44 24 1c	 mov	 DWORD PTR _dwGroup$274683[esp+368], eax
  0017d	74 14		 je	 SHORT $L292171

; 1378 : 			{
; 1379 : 				if( pUser->m_cooltimeMgr.CanUse( dwGroup ) == FALSE )

  0017f	50		 push	 eax
  00180	8d 8e a4 95 00
	00		 lea	 ecx, DWORD PTR [esi+38308]
  00186	e8 00 00 00 00	 call	 ?CanUse@CCooltimeMgr@@QAEHK@Z ; CCooltimeMgr::CanUse
  0018b	85 c0		 test	 eax, eax

; 1380 : 				{
; 1381 : 					return FALSE;

  0018d	0f 84 f3 06 00
	00		 je	 $L274886
$L292171:

; 1382 : 				}
; 1383 : 			}
; 1384 : 		}
; 1385 : 
; 1386 : 		//   
; 1387 : 		switch( pItemProp->dwItemKind2 )

  00193	8b 45 74	 mov	 eax, DWORD PTR [ebp+116]
  00196	83 c0 f5	 add	 eax, -11		; fffffff5H
  00199	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0019c	0f 87 8a 09 00
	00		 ja	 $L274887
  001a2	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $L292166[eax]
  001a9	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L292182[edx*4]
$L274693:

; 1388 : 		{
; 1389 : #if __VER >= 15 // __GUILD_HOUSE
; 1390 : 			case IK2_GUILDHOUSE_FURNITURE:
; 1391 : 			case IK2_GUILDHOUSE_NPC:
; 1392 : 			case IK2_GUILDHOUSE_PAPERING:
; 1393 : 				{
; 1394 : 					if( GuildHouseMng->SendWorldToDatabase( static_cast<CUser*>( this ), GUILDHOUSE_PCKTTYPE_LISTUP, GH_Fntr_Info( pItemProp->dwID ) ) )

  001b0	6a ff		 push	 -1
  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001b9	8b c4		 mov	 eax, esp
  001bb	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR $T291875[esp+392], 0
  001c3	8b 4c 24 38	 mov	 ecx, DWORD PTR $T291875[esp+392]
  001c7	89 08		 mov	 DWORD PTR [eax], ecx
  001c9	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR $T291875[esp+396], 0
  001d1	8b 54 24 3c	 mov	 edx, DWORD PTR $T291875[esp+396]
  001d5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR $T291875[esp+400], 0
  001dd	8b 4c 24 40	 mov	 ecx, DWORD PTR $T291875[esp+400]
  001e1	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001e4	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  001e7	6a 00		 push	 0
  001e9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001ec	52		 push	 edx
  001ed	8d 4c 24 58	 lea	 ecx, DWORD PTR $T291874[esp+400]
  001f1	e8 00 00 00 00	 call	 ??0GuildHouse_Furniture_Info@CGuildHouseBase@@QAE@KHUD3DXVECTOR3@@MJ@Z ; CGuildHouseBase::GuildHouse_Furniture_Info::GuildHouse_Furniture_Info
  001f6	50		 push	 eax
  001f7	6a 00		 push	 0
  001f9	56		 push	 esi
  001fa	e8 00 00 00 00	 call	 ?GetInstance@CGuildHouseMng@@SAPAV1@XZ ; CGuildHouseMng::GetInstance
  001ff	8b c8		 mov	 ecx, eax
  00201	e8 00 00 00 00	 call	 ?SendWorldToDatabase@CGuildHouseMng@@QAEHPAVCUser@@HAAUGuildHouse_Furniture_Info@CGuildHouseBase@@H@Z ; CGuildHouseMng::SendWorldToDatabase
  00206	85 c0		 test	 eax, eax
  00208	0f 84 78 06 00
	00		 je	 $L274886

; 1395 : 						g_DPSrvr.PutItemLog( static_cast<CUser*>( this ), "f", "GUILDHOUSE_LISTUP", pItemElem, 1 );

  0020e	57		 push	 edi
  0020f	53		 push	 ebx
  00210	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@PPLMFBOE@GUILDHOUSE_LISTUP?$AA@
  00215	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01INIBCBCB@f?$AA@

; 1532 : 							{
; 1533 : 								g_DPSrvr.PutItemLog( (CUser*)( this ), "w", "USE_RECCURENCE_ITEM", pItemElem, 1 );

  0021a	56		 push	 esi
  0021b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  00220	e8 00 00 00 00	 call	 ?PutItemLog@CDPSrvr@@QAEXPAVCUser@@PBD1PAVCItemElem@@H@Z ; CDPSrvr::PutItemLog

; 1534 : 							}
; 1535 : 							else if(  pItemElem->m_dwItemId == II_CHR_SYS_SCR_RESTATE && pItemElem->m_bCharged != TRUE )

  00225	e9 b7 08 00 00	 jmp	 $L274888
$L274702:

; 1396 : 					else
; 1397 : 						return FALSE;
; 1398 : 					break;
; 1399 : 				}
; 1400 : 			case IK2_GUILDHOUES_COMEBACK:
; 1401 : 				{
; 1402 : 					if( !GuildHouseMng->EnteranceGuildHouse( static_cast<CUser*>( this ), pItemProp->dwID ) )

  0022a	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0022d	50		 push	 eax
  0022e	56		 push	 esi
  0022f	e8 00 00 00 00	 call	 ?GetInstance@CGuildHouseMng@@SAPAV1@XZ ; CGuildHouseMng::GetInstance
  00234	8b c8		 mov	 ecx, eax
  00236	e8 00 00 00 00	 call	 ?EnteranceGuildHouse@CGuildHouseMng@@QAEHPAVCUser@@K@Z ; CGuildHouseMng::EnteranceGuildHouse
  0023b	85 c0		 test	 eax, eax
  0023d	0f 85 9e 08 00
	00		 jne	 $L274888

; 1403 : 						return FALSE;

  00243	e9 89 09 00 00	 jmp	 $L274653
$L274705:

; 1404 : 					break;
; 1405 : 				}			
; 1406 : #endif // __GUILD_HOUSE
; 1407 : #if __VER >= 13 // __HOUSING
; 1408 : 			case IK2_FURNITURE:
; 1409 : 			case IK2_PAPERING:
; 1410 : 				{
; 1411 : 					if(	CHousingMng::GetInstance()->ReqSetFurnitureList( (CUser*)this, pItemElem->m_dwItemId ) )

  00248	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0024b	51		 push	 ecx
  0024c	56		 push	 esi
  0024d	e8 00 00 00 00	 call	 ?GetInstance@CHousingMng@@SAPAV1@XZ ; CHousingMng::GetInstance
  00252	8b c8		 mov	 ecx, eax
  00254	e8 00 00 00 00	 call	 ?ReqSetFurnitureList@CHousingMng@@QAEHPAVCUser@@K@Z ; CHousingMng::ReqSetFurnitureList
  00259	85 c0		 test	 eax, eax
  0025b	0f 84 25 06 00
	00		 je	 $L274886

; 1412 : 					{
; 1413 : 						//    
; 1414 : 						LogItemInfo aLogItem;

  00261	8d 4c 24 58	 lea	 ecx, DWORD PTR _aLogItem$274708[esp+368]
  00265	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 1415 : 						aLogItem.SendName	= GetName();

  0026a	6a 00		 push	 0
  0026c	8b ce		 mov	 ecx, esi
  0026e	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 1416 : 						aLogItem.RecvName = "HOUSING_USE";
; 1417 : 						aLogItem.WorldId	= GetWorld()->GetID();

  00273	8b 96 6c 01 00
	00		 mov	 edx, DWORD PTR [esi+364]
  00279	89 44 24 5c	 mov	 DWORD PTR _aLogItem$274708[esp+372], eax

; 1418 : 						aLogItem.Gold	= GetGold();
; 1419 : 						aLogItem.Gold2	= GetGold();
; 1420 : 						aLogItem.Action	= "f";
; 1421 : 						g_DPSrvr.OnLogItem( aLogItem, pItemElem );

  0027d	6a 00		 push	 0
  0027f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR _aLogItem$274708[esp+380], OFFSET FLAT:??_C@_0M@HGMIEEBN@HOUSING_USE?$AA@
  00287	8b 02		 mov	 eax, DWORD PTR [edx]
  00289	53		 push	 ebx
  0028a	8d 4c 24 60	 lea	 ecx, DWORD PTR _aLogItem$274708[esp+376]
  0028e	89 44 24 6c	 mov	 DWORD PTR _aLogItem$274708[esp+388], eax
  00292	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  00298	51		 push	 ecx
  00299	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  0029e	89 44 24 74	 mov	 DWORD PTR _aLogItem$274708[esp+396], eax
  002a2	89 44 24 78	 mov	 DWORD PTR _aLogItem$274708[esp+400], eax
  002a6	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR _aLogItem$274708[esp+380], OFFSET FLAT:??_C@_01INIBCBCB@f?$AA@
  002ae	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 1422 : 					}
; 1423 : 					else
; 1424 : 						return FALSE;
; 1425 : 					break;

  002b3	e9 29 08 00 00	 jmp	 $L274888
$L274711:

; 1426 : 				}
; 1427 : #endif // __HOUSING
; 1428 : #ifdef __FUNNY_COIN
; 1429 : 			case IK2_TOCASH:
; 1430 : 				{
; 1431 : 					if( !CFunnyCoin::GetInstance()->DoUseFunnyCoin( (CUser*)this, pItemElem ) )

  002b8	53		 push	 ebx
  002b9	56		 push	 esi
  002ba	e8 00 00 00 00	 call	 ?GetInstance@CFunnyCoin@@SAPAV1@XZ ; CFunnyCoin::GetInstance
  002bf	8b c8		 mov	 ecx, eax
  002c1	e8 00 00 00 00	 call	 ?DoUseFunnyCoin@CFunnyCoin@@QAEHPAVCUser@@PAVCItemElem@@@Z ; CFunnyCoin::DoUseFunnyCoin
  002c6	85 c0		 test	 eax, eax
  002c8	0f 85 13 08 00
	00		 jne	 $L274888

; 1432 : 						return FALSE;

  002ce	e9 fe 08 00 00	 jmp	 $L274653
$L274714:

; 1433 : 				}
; 1434 : 				break;
; 1435 : #endif // __FUNNY_COIN
; 1436 : 			case IK2_WARP:
; 1437 : 				return DoUseItemWarp( pItemProp, pItemElem );

  002d3	53		 push	 ebx
  002d4	55		 push	 ebp
  002d5	8b ce		 mov	 ecx, esi
  002d7	e8 00 00 00 00	 call	 ?DoUseItemWarp@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CMover::DoUseItemWarp
  002dc	e9 f0 08 00 00	 jmp	 $L274653
$L274715:

; 1438 : #if __VER >= 11 // __SYS_COLLECTING
; 1439 : 			case IK2_BUFF2:
; 1440 : 				{
; 1441 : 					if( IsDoUseBuff( pItemProp ) != 0 )

  002e1	55		 push	 ebp
  002e2	8b ce		 mov	 ecx, esi
  002e4	e8 00 00 00 00	 call	 ?IsDoUseBuff@CMover@@QAEHPAUItemProp@@@Z ; CMover::IsDoUseBuff
  002e9	85 c0		 test	 eax, eax

; 1442 : 						return FALSE;

  002eb	0f 85 95 05 00
	00		 jne	 $L274886

; 1443 : 					CTime tm	= CTime::GetCurrentTime() + CTimeSpan( 0, 0, pItemProp->dwAbilityMin, 0 );

  002f1	8b 95 e4 00 00
	00		 mov	 edx, DWORD PTR [ebp+228]
  002f7	50		 push	 eax
  002f8	52		 push	 edx
  002f9	50		 push	 eax
  002fa	50		 push	 eax
  002fb	8d 4c 24 40	 lea	 ecx, DWORD PTR $T291877[esp+384]
  002ff	e8 00 00 00 00	 call	 ??0CTimeSpan@ATL@@QAE@JHHH@Z ; ATL::CTimeSpan::CTimeSpan
  00304	8b 38		 mov	 edi, DWORD PTR [eax]
  00306	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00309	8d 4c 24 20	 lea	 ecx, DWORD PTR $T291876[esp+368]
  0030d	51		 push	 ecx
  0030e	89 44 24 1c	 mov	 DWORD PTR $T291950[esp+376], eax
  00312	e8 00 00 00 00	 call	 ?GetTickCount@CTime@ATL@@SG?AV12@XZ ; ATL::CTime::GetTickCount
  00317	8b 10		 mov	 edx, DWORD PTR [eax]

; 1444 : 					time_t t	= (time_t)( tm.GetTime() );
; 1445 : 					// wID: dwItemId
; 1446 : 					// dwLevel
; 1447 : 					AddBuff( BUFF_ITEM2, (WORD)( pItemElem->m_dwItemId ), t, 0 ); 

  00319	33 c0		 xor	 eax, eax
  0031b	66 8b 43 0c	 mov	 ax, WORD PTR [ebx+12]
  0031f	6a ff		 push	 -1
  00321	6a 00		 push	 0
  00323	03 d7		 add	 edx, edi
  00325	52		 push	 edx
  00326	8b ce		 mov	 ecx, esi
  00328	50		 push	 eax
  00329	6a 03		 push	 3
  0032b	e8 00 00 00 00	 call	 ?AddBuff@CMover@@QAEHGGKKK@Z ; CMover::AddBuff

; 1448 : 					break;

  00330	e9 ac 07 00 00	 jmp	 $L274888
$L274724:

; 1449 : 				}
; 1450 : #endif	// __SYS_COLLECTING
; 1451 : #ifdef __BUFF_TOGIFT
; 1452 : 			case IK2_BUFF_TOGIFT:
; 1453 : #endif // __BUFF_TOGIFT
; 1454 : 			case IK2_BUFF:
; 1455 : 				{
; 1456 : 					if( IsDoUseBuff( pItemProp ) != 0 )

  00335	55		 push	 ebp
  00336	8b ce		 mov	 ecx, esi
  00338	e8 00 00 00 00	 call	 ?IsDoUseBuff@CMover@@QAEHPAUItemProp@@@Z ; CMover::IsDoUseBuff
  0033d	85 c0		 test	 eax, eax

; 1457 : 						return FALSE;

  0033f	0f 85 41 05 00
	00		 jne	 $L274886

; 1458 : 					DoApplySkill( this, pItemProp, NULL );		//   . 

  00345	50		 push	 eax
  00346	50		 push	 eax
  00347	50		 push	 eax
  00348	50		 push	 eax
  00349	50		 push	 eax
  0034a	55		 push	 ebp
  0034b	56		 push	 esi
  0034c	8b ce		 mov	 ecx, esi
  0034e	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill

; 1459 : #if __VER >= 8 //__CSC_VER8_5
; 1460 : 					if( pItemProp->dwItemKind3 == IK3_ANGEL_BUFF )

  00353	83 7d 78 5f	 cmp	 DWORD PTR [ebp+120], 95	; 0000005fH
  00357	0f 85 84 07 00
	00		 jne	 $L274888

; 1461 : 					{
; 1462 : 		#ifdef __EXP_ANGELEXP_LOG
; 1463 : 						((CUser*)this)->m_nAngelExpLog = 0;

  0035d	33 ff		 xor	 edi, edi

; 1464 : 		#endif // __EXP_ANGELEXP_LOG
; 1465 : 		#ifdef __ANGEL_LOG
; 1466 : 						LogItemInfo aLogItem;

  0035f	8d 4c 24 58	 lea	 ecx, DWORD PTR _aLogItem$274728[esp+368]
  00363	89 be 20 96 00
	00		 mov	 DWORD PTR [esi+38432], edi
  00369	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 1467 : 						aLogItem.Action = "&";
; 1468 : 						aLogItem.SendName = ((CUser*)this)->GetName();

  0036e	57		 push	 edi
  0036f	8b ce		 mov	 ecx, esi
  00371	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR _aLogItem$274728[esp+372], OFFSET FLAT:??_C@_01HNPIGOCE@?$CG?$AA@
  00379	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 1469 : 						aLogItem.RecvName = "ANGEL_SUMMON";
; 1470 : 						aLogItem.WorldId = ((CUser*)this)->GetWorld()->GetID();

  0037e	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00384	89 44 24 5c	 mov	 DWORD PTR _aLogItem$274728[esp+372], eax

; 1471 : 						aLogItem.Gold = aLogItem.Gold2 = ((CUser*)this)->GetGold();

  00388	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  0038e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR _aLogItem$274728[esp+376], OFFSET FLAT:??_C@_0N@OINNJKEM@ANGEL_SUMMON?$AA@
  00396	8b 11		 mov	 edx, DWORD PTR [ecx]
  00398	89 44 24 6c	 mov	 DWORD PTR _aLogItem$274728[esp+388], eax
  0039c	89 44 24 68	 mov	 DWORD PTR _aLogItem$274728[esp+384], eax

; 1472 : 						//aLogItem.ItemName = pItemProp->szName;
; 1473 : 						_stprintf( aLogItem.szItemName, "%d", pItemProp->dwID );

  003a0	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  003a3	50		 push	 eax
  003a4	8d 8c 24 80 00
	00 00		 lea	 ecx, DWORD PTR _aLogItem$274728[esp+408]
  003ab	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  003b0	51		 push	 ecx
  003b1	89 54 24 70	 mov	 DWORD PTR _aLogItem$274728[esp+392], edx
  003b5	e8 00 00 00 00	 call	 _sprintf
  003ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1474 : 						g_DPSrvr.OnLogItem( aLogItem );

  003bd	57		 push	 edi
  003be	57		 push	 edi
  003bf	8d 54 24 60	 lea	 edx, DWORD PTR _aLogItem$274728[esp+376]
  003c3	52		 push	 edx
  003c4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  003c9	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem

; 1475 : 		#endif // __ANGEL_LOG
; 1476 : 						m_nAngelExp = 0;
; 1477 : 						m_nAngelLevel = GetLevel() + 1;

  003ce	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  003d4	40		 inc	 eax

; 1478 : 						((CUser*)this)->AddAngelInfo();

  003d5	57		 push	 edi
  003d6	8b ce		 mov	 ecx, esi
  003d8	89 be 68 07 00
	00		 mov	 DWORD PTR [esi+1896], edi
  003de	89 be 6c 07 00
	00		 mov	 DWORD PTR [esi+1900], edi
  003e4	89 86 70 07 00
	00		 mov	 DWORD PTR [esi+1904], eax
  003ea	e8 00 00 00 00	 call	 ?AddAngelInfo@CUser@@QAEXH@Z ; CUser::AddAngelInfo

; 1479 : 					}
; 1480 : #endif // __CSC_VER8_5
; 1481 : 				}
; 1482 : 				break;

  003ef	e9 ed 06 00 00	 jmp	 $L274888
$L274736:

; 1483 : 			case IK2_TEXT: //   
; 1484 : 				//     
; 1485 : 				if( pItemProp->dwQuestId && pItemElem->m_bItemResist == FALSE )

  003f4	8b 85 70 02 00
	00		 mov	 eax, DWORD PTR [ebp+624]
  003fa	85 c0		 test	 eax, eax
  003fc	0f 84 df 06 00
	00		 je	 $L274888
  00402	8a 8b 88 00 00
	00		 mov	 cl, BYTE PTR [ebx+136]
  00408	84 c9		 test	 cl, cl
  0040a	0f 85 d1 06 00
	00		 jne	 $L274888

; 1486 : 				{
; 1487 : 					::__SetQuest( GetId(), pItemProp->dwQuestId );

  00410	8b 8e bc 01 00
	00		 mov	 ecx, DWORD PTR [esi+444]
  00416	50		 push	 eax
  00417	51		 push	 ecx
  00418	e8 00 00 00 00	 call	 ?__SetQuest@@YAXKH@Z	; __SetQuest
  0041d	83 c4 08	 add	 esp, 8

; 1488 : 					pItemElem->m_bItemResist = TRUE;
; 1489 : 					UpdateItem( (BYTE)( pItemElem->m_dwObjId ), UI_IR, pItemElem->m_bItemResist );	

  00420	33 d2		 xor	 edx, edx
  00422	8a 53 04	 mov	 dl, BYTE PTR [ebx+4]
  00425	6a 00		 push	 0
  00427	6a 01		 push	 1
  00429	6a 05		 push	 5
  0042b	8b ce		 mov	 ecx, esi
  0042d	c6 83 88 00 00
	00 01		 mov	 BYTE PTR [ebx+136], 1
  00434	52		 push	 edx
  00435	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 1490 : 				}
; 1491 : 				break;

  0043a	e9 a2 06 00 00	 jmp	 $L274888
$L274739:

; 1492 : 			case IK2_SYSTEM:
; 1493 : 				{
; 1494 : #ifdef __JEFF_9_20
; 1495 : #ifdef __WORLDSERVER
; 1496 : 					if( pItemProp->dwLimitLevel1 != 0xFFFFFFFF )

  0043f	8b 85 60 02 00
	00		 mov	 eax, DWORD PTR [ebp+608]
  00445	83 f8 ff	 cmp	 eax, -1
  00448	74 23		 je	 SHORT $L274742

; 1497 : 					{
; 1498 : 						if( GetLevel() < (int)( pItemProp->dwLimitLevel1 ) )

  0044a	39 86 e0 05 00
	00		 cmp	 DWORD PTR [esi+1504], eax
  00450	7d 1b		 jge	 SHORT $L274742

; 1499 : 						{
; 1500 : 							( (CUser*)this )->AddDefinedText( TID_GAME_ITEM_LEVEL, "\"%d\"", pItemProp->dwLimitLevel1 );

  00452	50		 push	 eax
  00453	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PNFMAOFG@?$CC?$CFd?$CC?$AA@
  00458	68 29 0e 00 00	 push	 3625			; 00000e29H
  0045d	56		 push	 esi
  0045e	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00463	83 c4 10	 add	 esp, 16			; 00000010H

; 1501 : 							return FALSE;

  00466	33 c0		 xor	 eax, eax
  00468	e9 64 07 00 00	 jmp	 $L274653
$L274742:

; 1502 : 						}
; 1503 : 					}
; 1504 : #endif	// __WORLDSERVER
; 1505 : #endif	// __JEFF_9_20
; 1506 : 					int nResult = 0;
; 1507 : 					nResult = DoUseItemSystem( pItemProp, pItemElem, nPart );

  0046d	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR _nPart$[esp+364]
  00474	50		 push	 eax
  00475	53		 push	 ebx
  00476	55		 push	 ebp
  00477	8b ce		 mov	 ecx, esi
  00479	e8 00 00 00 00	 call	 ?DoUseItemSystem@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemSystem

; 1508 : 					{
; 1509 : 						if( 0 < nResult )

  0047e	85 c0		 test	 eax, eax

; 1510 : 						{
; 1511 : 							if( nResult == 2 )
; 1512 : 							{
; 1513 : 								((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   
; 1514 : 							}
; 1515 : 							else if( nResult == 3 )

  00480	7f 74		 jg	 SHORT $L292181

; 1516 : 							{
; 1517 : 								((CUser*)this)->AddDefinedText( TID_GAME_NOTOVERLAP_USE, "" ); //      
; 1518 : 							}
; 1519 : 							return FALSE;
; 1520 : 						}
; 1521 : 						else
; 1522 : 						{
; 1523 : 							if( pItemElem->m_dwItemId == II_SYS_SYS_SCR_RECCURENCE_LINK )

  00482	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00485	3d cc 66 00 00	 cmp	 eax, 26316		; 000066ccH

; 1524 : 							{
; 1525 : 								g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemProp );
; 1526 : 							}
; 1527 : 
; 1528 : 							//////////////////////////////////////////////////////////////////////////
; 1529 : 							//	mulcom	BEGIN100125	         
; 1530 : 							//						( e-mail : []    ( 2010-01-25 17:33 )  )
; 1531 : 							else if( pItemElem->m_dwItemId == II_SYS_SYS_SCR_RECCURENCE && pItemElem->m_bCharged != TRUE )

  0048a	0f 84 21 03 00
	00		 je	 $L292178
  00490	3d c2 28 00 00	 cmp	 eax, 10434		; 000028c2H
  00495	75 24		 jne	 SHORT $L274757
  00497	39 bb ac 00 00
	00		 cmp	 DWORD PTR [ebx+172], edi
  0049d	74 1c		 je	 SHORT $L274757

; 1532 : 							{
; 1533 : 								g_DPSrvr.PutItemLog( (CUser*)( this ), "w", "USE_RECCURENCE_ITEM", pItemElem, 1 );

  0049f	57		 push	 edi
  004a0	53		 push	 ebx
  004a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@COEAJDGE@USE_RECCURENCE_ITEM?$AA@
$L292179:
  004a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  004ab	56		 push	 esi
  004ac	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  004b1	e8 00 00 00 00	 call	 ?PutItemLog@CDPSrvr@@QAEXPAVCUser@@PBD1PAVCItemElem@@H@Z ; CDPSrvr::PutItemLog

; 1534 : 							}
; 1535 : 							else if(  pItemElem->m_dwItemId == II_CHR_SYS_SCR_RESTATE && pItemElem->m_bCharged != TRUE )

  004b6	e9 26 06 00 00	 jmp	 $L274888
$L274757:
  004bb	3d e3 27 00 00	 cmp	 eax, 10211		; 000027e3H
  004c0	0f 85 1b 06 00
	00		 jne	 $L274888
  004c6	83 bb ac 00 00
	00 01		 cmp	 DWORD PTR [ebx+172], 1
  004cd	0f 84 0e 06 00
	00		 je	 $L274888

; 1536 : 							{
; 1537 : 								g_DPSrvr.PutItemLog( (CUser*)( this ), "w", "USE_RESTATE_ITEM", pItemElem, 1 );

  004d3	6a 01		 push	 1
  004d5	53		 push	 ebx
  004d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@KAAKNBKL@USE_RESTATE_ITEM?$AA@

; 1538 : 							}
; 1539 : 							//	mulcom	END100125	         
; 1540 : 							//////////////////////////////////////////////////////////////////////////
; 1541 : 						}
; 1542 : 					}
; 1543 : 				}
; 1544 : 				break;

  004db	eb c9		 jmp	 SHORT $L292179
$L274765:

; 1545 : #ifdef __NEW_PROP_PARAMETER
; 1546 : 			case IK2_ONCE:
; 1547 : 				{
; 1548 : 					int nResult = 0;
; 1549 : 					nResult = DoUseItemOnce( pItemProp, pItemElem, nPart );

  004dd	8b 8c 24 7c 01
	00 00		 mov	 ecx, DWORD PTR _nPart$[esp+364]
  004e4	51		 push	 ecx
  004e5	53		 push	 ebx
  004e6	55		 push	 ebp
  004e7	8b ce		 mov	 ecx, esi
  004e9	e8 00 00 00 00	 call	 ?DoUseItemOnce@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemOnce

; 1550 : 					{
; 1551 : 						if( 0 < nResult )

  004ee	85 c0		 test	 eax, eax
  004f0	0f 8e eb 05 00
	00		 jle	 $L274888
$L292181:

; 1552 : 						{
; 1553 : 							if( nResult == 2 )

  004f6	83 f8 02	 cmp	 eax, 2
  004f9	75 1a		 jne	 SHORT $L274768

; 1554 : 							{
; 1555 : 								((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   

  004fb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00500	68 30 08 00 00	 push	 2096			; 00000830H

; 1558 : 							{
; 1559 : 								((CUser*)this)->AddDefinedText( TID_GAME_NOTOVERLAP_USE, "" ); //      

  00505	56		 push	 esi
  00506	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0050b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1560 : 							}
; 1561 : 							return FALSE;

  0050e	33 c0		 xor	 eax, eax
  00510	e9 bc 06 00 00	 jmp	 $L274653
$L274768:

; 1556 : 							}
; 1557 : 							else if( nResult == 3 )

  00515	83 f8 03	 cmp	 eax, 3
  00518	0f 85 68 03 00
	00		 jne	 $L274886

; 1558 : 							{
; 1559 : 								((CUser*)this)->AddDefinedText( TID_GAME_NOTOVERLAP_USE, "" ); //      

  0051e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00523	68 63 0a 00 00	 push	 2659			; 00000a63H
  00528	56		 push	 esi
  00529	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0052e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1560 : 							}
; 1561 : 							return FALSE;

  00531	33 c0		 xor	 eax, eax
  00533	e9 99 06 00 00	 jmp	 $L274653
$L274773:

; 1562 : 						}
; 1563 : 					}
; 1564 : 				}
; 1565 : 				break;
; 1566 : 			case IK2_KEEP:
; 1567 : 				{
; 1568 : #ifndef __NEW_STACKABLE_AMPS
; 1569 : 					int nResult = 0;
; 1570 : 					nResult = DoUseItemSystem( pItemProp, pItemElem, nPart );
; 1571 : 					{
; 1572 : 						if( 0 < nResult )
; 1573 : 						{
; 1574 : 							if( nResult == 2 )
; 1575 : 							{
; 1576 : 								((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   
; 1577 : 							}
; 1578 : 							else if( nResult == 3 )
; 1579 : 							{
; 1580 : 								((CUser*)this)->AddDefinedText( TID_GAME_NOTOVERLAP_USE, "" ); //      
; 1581 : 							}
; 1582 : 							return FALSE;
; 1583 : 						}
; 1584 : 					}
; 1585 : #else //  __NEW_STACKABLE_AMPS
; 1586 : 					int nResult = 0;
; 1587 : 					nResult = DoUseItemKeep( pItemProp, pItemElem, nPart );

  00538	8b 94 24 7c 01
	00 00		 mov	 edx, DWORD PTR _nPart$[esp+364]
  0053f	52		 push	 edx
  00540	53		 push	 ebx
  00541	55		 push	 ebp
  00542	8b ce		 mov	 ecx, esi
  00544	e8 00 00 00 00	 call	 ?DoUseItemKeep@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemKeep

; 1588 : 					{
; 1589 : 						if( 0 < nResult )

  00549	85 c0		 test	 eax, eax
  0054b	0f 8e 90 05 00
	00		 jle	 $L274888

; 1590 : 						{
; 1591 : 
; 1592 : 							if( nResult == 1 )

  00551	83 f8 01	 cmp	 eax, 1
  00554	75 59		 jne	 SHORT $L274776

; 1593 : 							{
; 1594 : 								CString str;

  00556	8d 4c 24 10	 lea	 ecx, DWORD PTR _str$274777[esp+368]
  0055a	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 1595 : 								str.Format( "%d - %d", pItemProp->nMinLimitLevel, pItemProp->nMaxLimitLevel );

  0055f	8b 85 c0 02 00
	00		 mov	 eax, DWORD PTR [ebp+704]
  00565	8b 8d bc 02 00
	00		 mov	 ecx, DWORD PTR [ebp+700]
  0056b	50		 push	 eax
  0056c	51		 push	 ecx
  0056d	8d 54 24 18	 lea	 edx, DWORD PTR _str$274777[esp+376]
  00571	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07PFGKEPEH@?$CFd?5?9?5?$CFd?$AA@
  00576	52		 push	 edx
  00577	c7 84 24 7c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+392], 0
  00582	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 1596 : 								((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSELEVEL, "\"%s\"", str ); // 

  00587	8b 44 24 20	 mov	 eax, DWORD PTR _str$274777[esp+384]
  0058b	50		 push	 eax
  0058c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
  00591	68 fe 0a 00 00	 push	 2814			; 00000afeH
  00596	56		 push	 esi
  00597	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0059c	83 c4 20	 add	 esp, 32			; 00000020H

; 1597 : 								return FALSE;

  0059f	8d 4c 24 10	 lea	 ecx, DWORD PTR _str$274777[esp+368]
  005a3	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  005a8	33 c0		 xor	 eax, eax
  005aa	e9 22 06 00 00	 jmp	 $L274653
$L274776:

; 1598 : 							}
; 1599 : 							else if( nResult == 2 )

  005af	83 f8 02	 cmp	 eax, 2

; 1600 : 							{
; 1601 : 								((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   
; 1602 : 								return FALSE;

  005b2	0f 84 15 02 00
	00		 je	 $L274819

; 1603 : 							}
; 1604 : 							else if( nResult == 3 )

  005b8	83 f8 03	 cmp	 eax, 3
  005bb	0f 85 8a 00 00
	00		 jne	 $L274785

; 1605 : 							{
; 1606 : 								CString str;

  005c1	8d 4c 24 14	 lea	 ecx, DWORD PTR _str$274786[esp+368]
  005c5	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 1607 : 								str.Format( "%d", GetLevel());

  005ca	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  005d0	50		 push	 eax
  005d1	8d 4c 24 18	 lea	 ecx, DWORD PTR _str$274786[esp+372]
  005d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  005da	51		 push	 ecx
  005db	c7 84 24 78 01
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+388], 1
  005e6	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format
  005eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1608 : 								CString szMaxBuf;

  005ee	8d 4c 24 10	 lea	 ecx, DWORD PTR _szMaxBuf$274787[esp+368]
  005f2	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 1609 : 								szMaxBuf.Format( "%d", pItemProp->nMaxDuplication );

  005f7	8b 95 cc 02 00
	00		 mov	 edx, DWORD PTR [ebp+716]
  005fd	52		 push	 edx
  005fe	8d 44 24 14	 lea	 eax, DWORD PTR _szMaxBuf$274787[esp+372]
  00602	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00607	50		 push	 eax
  00608	c6 84 24 78 01
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+388], 2
  00610	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 1610 : 								((CUser*)this)->AddDefinedText( TID_GAME_EXP_NOTUSE, "\"%s\" \"%s\"", str, szMaxBuf ); // 

  00615	8b 4c 24 1c	 mov	 ecx, DWORD PTR _szMaxBuf$274787[esp+380]
  00619	8b 54 24 20	 mov	 edx, DWORD PTR _str$274786[esp+380]
  0061d	51		 push	 ecx
  0061e	52		 push	 edx
  0061f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09DPACILDJ@?$CC?$CFs?$CC?5?$CC?$CFs?$CC?$AA@
  00624	68 fd 0a 00 00	 push	 2813			; 00000afdH
  00629	56		 push	 esi
  0062a	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0062f	83 c4 20	 add	 esp, 32			; 00000020H

; 1611 : 								//((CUser*)this)->AddDefinedText( TID_GAME_NOTOVERLAP_USE, "" ); //      
; 1612 : 								return FALSE;

  00632	8d 4c 24 10	 lea	 ecx, DWORD PTR _szMaxBuf$274787[esp+368]
  00636	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  0063b	8d 4c 24 14	 lea	 ecx, DWORD PTR _str$274786[esp+368]
  0063f	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  00644	33 c0		 xor	 eax, eax
  00646	e9 86 05 00 00	 jmp	 $L274653
$L274785:

; 1613 : 							}
; 1614 : 							else if( nResult == 4 )

  0064b	83 f8 04	 cmp	 eax, 4
  0064e	0f 85 8d 04 00
	00		 jne	 $L274888

; 1615 : 							{
; 1616 : 								int nExtraEXP = 0;
; 1617 : 								for( MAPBUFF::iterator i = m_buffs.m_mapBuffs.begin(); i != m_buffs.m_mapBuffs.end(); ++i )

  00654	8b 8e f8 02 00
	00		 mov	 ecx, DWORD PTR [esi+760]
  0065a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0065c	33 ff		 xor	 edi, edi
  0065e	3b c1		 cmp	 eax, ecx
  00660	89 44 24 14	 mov	 DWORD PTR _i$274794[esp+368], eax
  00664	74 3c		 je	 SHORT $L292169
$L292019:

; 1618 : 								{
; 1619 : 									ItemProp* pAmpProp = prj.GetItemProp( i->second->GetId());

  00666	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00669	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  0066d	51		 push	 ecx
  0066e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00673	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 1620 : 
; 1621 : 									if( pAmpProp )

  00678	85 c0		 test	 eax, eax
  0067a	74 0f		 je	 SHORT $L274798

; 1622 : 									{
; 1623 : 										if( pAmpProp->dwItemKind3 == IK3_EXP_RATE )

  0067c	81 78 78 a4 00
	00 00		 cmp	 DWORD PTR [eax+120], 164 ; 000000a4H
  00683	75 06		 jne	 SHORT $L274798

; 1624 : 										{
; 1625 : 											nExtraEXP += pAmpProp->nEffectValue;

  00685	03 b8 d0 02 00
	00		 add	 edi, DWORD PTR [eax+720]
$L274798:
  0068b	8d 4c 24 14	 lea	 ecx, DWORD PTR _i$274794[esp+368]
  0068f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc
  00694	8b 8e f8 02 00
	00		 mov	 ecx, DWORD PTR [esi+760]
  0069a	8b 44 24 14	 mov	 eax, DWORD PTR _i$274794[esp+368]
  0069e	3b c1		 cmp	 eax, ecx
  006a0	75 c4		 jne	 SHORT $L292019
$L292169:

; 1626 : 										}
; 1627 : 									}
; 1628 : 								}
; 1629 : 								CString strTemp;

  006a2	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTemp$274803[esp+368]
  006a6	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 1630 : 								strTemp.Format( "%s %d%% %s", prj.GetText( TID_GAME_EXPITEM_TOOLTIP ), nExtraEXP, prj.GetText( TID_GAME_EXPITEM_TOOLTIP1 ) );

  006ab	68 25 0e 00 00	 push	 3621			; 00000e25H
  006b0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  006b5	c7 84 24 70 01
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+380], 3
  006c0	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  006c5	50		 push	 eax
  006c6	57		 push	 edi
  006c7	68 24 0e 00 00	 push	 3620			; 00000e24H
  006cc	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  006d1	e8 00 00 00 00	 call	 ?GetText@CProject@@QAEPBDK@Z ; CProject::GetText
  006d6	50		 push	 eax
  006d7	8d 54 24 20	 lea	 edx, DWORD PTR _strTemp$274803[esp+380]
  006db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@PGLFOAIL@?$CFs?5?$CFd?$CF?$CF?5?$CFs?$AA@
  006e0	52		 push	 edx
  006e1	e8 00 00 00 00	 call	 ?Format@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Format

; 1631 : 								((CUser*)this)->AddText( strTemp ); // 

  006e6	8b 44 24 28	 mov	 eax, DWORD PTR _strTemp$274803[esp+388]
  006ea	83 c4 14	 add	 esp, 20			; 00000014H
  006ed	50		 push	 eax
  006ee	8b ce		 mov	 ecx, esi
  006f0	e8 00 00 00 00	 call	 ?AddText@CUser@@QAEXPBD@Z ; CUser::AddText

; 1632 : 							}

  006f5	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTemp$274803[esp+368]
  006f9	c7 84 24 6c 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+376], -1
  00704	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 1633 : 						}
; 1634 : 					}
; 1635 : #endif // __NEW_STACKABLE_AMPS
; 1636 : 				}
; 1637 : 				break;

  00709	e9 d3 03 00 00	 jmp	 $L274888
$L274806:

; 1638 : #endif // __NEW_PROP_PARAMETER
; 1639 : 			case IK2_BLINKWING:
; 1640 : 				return DoUseItemBlinkWing( pItemProp, pItemElem );

  0070e	57		 push	 edi
  0070f	53		 push	 ebx
  00710	55		 push	 ebp
  00711	8b ce		 mov	 ecx, esi
  00713	e8 00 00 00 00	 call	 ?DoUseItemBlinkWing@CMover@@QAEHPAUItemProp@@PAVCItemElem@@H@Z ; CMover::DoUseItemBlinkWing
  00718	e9 b4 04 00 00	 jmp	 $L274653
$L274807:

; 1641 : 
; 1642 : 			case IK2_REFRESHER:
; 1643 : 				{
; 1644 : 					if( pItemProp->dwCircleTime != (DWORD)-1 )

  0071d	8b 85 ec 01 00
	00		 mov	 eax, DWORD PTR [ebp+492]
  00723	83 f8 ff	 cmp	 eax, -1
  00726	0f 84 bb 00 00
	00		 je	 $L274825

; 1645 : 					{
; 1646 : 						if( IsSMMode( SM_MAINTAIN_MP ) == FALSE && SetSMMode( SM_MAINTAIN_MP, pItemProp->dwCircleTime ) )

  0072c	8b 8e 1c 03 00
	00		 mov	 ecx, DWORD PTR [esi+796]
  00732	85 c9		 test	 ecx, ecx
  00734	0f 87 93 00 00
	00		 ja	 $L274819
  0073a	50		 push	 eax
  0073b	6a 06		 push	 6
  0073d	8b ce		 mov	 ecx, esi
  0073f	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode
  00744	85 c0		 test	 eax, eax
  00746	0f 84 81 00 00
	00		 je	 $L274819

; 1647 : 						{
; 1648 : 							SetPointParam( DST_MP, GetMaxManaPoint() );

  0074c	6a 00		 push	 0
  0074e	8b ce		 mov	 ecx, esi
  00750	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  00755	50		 push	 eax
  00756	6a 27		 push	 39			; 00000027H
  00758	8b ce		 mov	 ecx, esi
  0075a	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam

; 1649 : 						}
; 1650 : 						else
; 1651 : 						{
; 1652 : 							((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   
; 1653 : 							return FALSE;
; 1654 : 						}
; 1655 : 						g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemProp );

  0075f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00764	55		 push	 ebp
  00765	53		 push	 ebx
  00766	56		 push	 esi
  00767	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01HIHLOKLC@1?$AA@
  0076c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00771	e8 00 00 00 00	 call	 ?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z ; CDPDatabaseClient::SendLogSMItemUse

; 1656 : 					}
; 1657 : 					else

  00776	e9 66 03 00 00	 jmp	 $L274888
$L274816:

; 1658 : 					{
; 1659 : 						if( DoUseItemFood( pItemProp, pItemElem ) == FALSE )
; 1660 : 							return FALSE;
; 1661 : 					}
; 1662 : 					break;
; 1663 : 				}
; 1664 : 			case IK2_POTION:
; 1665 : 				if( pItemProp->dwCircleTime != (DWORD)-1 )	//  dwCircleTime .  dwSkillTime .

  0077b	8b 85 ec 01 00
	00		 mov	 eax, DWORD PTR [ebp+492]
  00781	83 f8 ff	 cmp	 eax, -1
  00784	74 61		 je	 SHORT $L274825

; 1666 : 				{
; 1667 : 					if( IsSMMode( SM_MAINTAIN_FP ) == FALSE && SetSMMode( SM_MAINTAIN_FP, pItemProp->dwCircleTime ) )

  00786	8b 8e 20 03 00
	00		 mov	 ecx, DWORD PTR [esi+800]
  0078c	85 c9		 test	 ecx, ecx
  0078e	77 3d		 ja	 SHORT $L274819
  00790	50		 push	 eax
  00791	6a 07		 push	 7
  00793	8b ce		 mov	 ecx, esi
  00795	e8 00 00 00 00	 call	 ?SetSMMode@CMover@@QAEHHK@Z ; CMover::SetSMMode
  0079a	85 c0		 test	 eax, eax
  0079c	74 2f		 je	 SHORT $L274819

; 1668 : 					{
; 1669 : 						SetPointParam( DST_FP, GetMaxFatiguePoint() );

  0079e	6a 00		 push	 0
  007a0	8b ce		 mov	 ecx, esi
  007a2	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  007a7	50		 push	 eax
  007a8	6a 28		 push	 40			; 00000028H
  007aa	8b ce		 mov	 ecx, esi
  007ac	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
$L292178:

; 1675 : 					}
; 1676 : 					g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemProp );

  007b1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  007b6	55		 push	 ebp
  007b7	53		 push	 ebx
  007b8	56		 push	 esi
  007b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01HIHLOKLC@1?$AA@
  007be	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  007c3	e8 00 00 00 00	 call	 ?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z ; CDPDatabaseClient::SendLogSMItemUse

; 1677 : 				}
; 1678 : 				else

  007c8	e9 14 03 00 00	 jmp	 $L274888
$L274819:

; 1670 : 					}
; 1671 : 					else
; 1672 : 					{
; 1673 : 						((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   

  007cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  007d2	68 30 08 00 00	 push	 2096			; 00000830H
  007d7	56		 push	 esi
  007d8	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  007dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1674 : 						return FALSE;

  007e0	33 c0		 xor	 eax, eax
  007e2	e9 ea 03 00 00	 jmp	 $L274653
$L274825:

; 1679 : 				{
; 1680 : 					if( DoUseItemFood( pItemProp, pItemElem ) == FALSE )
; 1681 : 						return FALSE;
; 1682 : 				}
; 1683 : 				break;
; 1684 : 			case IK2_FOOD:
; 1685 : 				if( DoUseItemFood( pItemProp, pItemElem ) == FALSE )

  007e7	53		 push	 ebx
  007e8	55		 push	 ebp
  007e9	8b ce		 mov	 ecx, esi
  007eb	e8 00 00 00 00	 call	 ?DoUseItemFood@CMover@@QAEHPAUItemProp@@PAVCItemElem@@@Z ; CMover::DoUseItemFood
  007f0	85 c0		 test	 eax, eax
  007f2	0f 85 e9 02 00
	00		 jne	 $L274888

; 1686 : 					return FALSE;

  007f8	e9 d4 03 00 00	 jmp	 $L274653
$L274827:

; 1687 : 				break;
; 1688 : 			case IK2_AIRFUEL:	// 
; 1689 : 				{
; 1690 : 					ItemProp *pRideProp = prj.GetItemProp( m_dwRideItemIdx );	//  

  007fd	8b 8e 88 16 00
	00		 mov	 ecx, DWORD PTR [esi+5768]
  00803	51		 push	 ecx
  00804	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00809	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 1691 : 					if( pRideProp && TRUE == IsPlayer() && m_pActMover->IsFly() )

  0080e	85 c0		 test	 eax, eax
  00810	74 74		 je	 SHORT $L274886
  00812	39 be 34 02 00
	00		 cmp	 DWORD PTR [esi+564], edi
  00818	75 6c		 jne	 SHORT $L274886
  0081a	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  00820	f6 42 08 08	 test	 BYTE PTR [edx+8], 8
  00824	74 60		 je	 SHORT $L274886

; 1692 : 					{
; 1693 : 						if( pItemProp->dwItemKind3 == IK3_ACCEL )	//  

  00826	8b 55 78	 mov	 edx, DWORD PTR [ebp+120]
  00829	83 fa 30	 cmp	 edx, 48			; 00000030H
  0082c	75 14		 jne	 SHORT $L274830

; 1694 : 						{
; 1695 : 							m_tmAccFuel = pItemProp->dwAFuelReMax * 1000;;	//   .

  0082e	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR [ebp+212]
  00834	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  0083a	89 86 84 06 00
	00		 mov	 DWORD PTR [esi+1668], eax

; 1696 : 						}
; 1697 : 						else

  00840	eb 71		 jmp	 SHORT $L274838
$L274830:

; 1698 : 						{	// 
; 1699 : 							if( pRideProp->dwItemKind3 == IK3_BOARD && pItemProp->dwItemKind3 == IK3_CFLIGHT )	//   /  

  00842	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00845	83 f9 28	 cmp	 ecx, 40			; 00000028H
  00848	75 1f		 jne	 SHORT $L274832
  0084a	83 fa 34	 cmp	 edx, 52			; 00000034H
  0084d	75 1a		 jne	 SHORT $L274832

; 1700 : 							{
; 1701 : 								((CUser*)this)->AddDefinedText( TID_GAME_COMBFUEL, "" );	//  ~

  0084f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00854	68 7b 04 00 00	 push	 1147			; 0000047bH
  00859	56		 push	 esi
  0085a	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0085f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1702 : 								return FALSE;

  00862	33 c0		 xor	 eax, eax
  00864	e9 68 03 00 00	 jmp	 $L274653
$L274832:

; 1703 : 							}
; 1704 : 							else
; 1705 : 							if( pRideProp->dwItemKind3 == IK3_STICK && pItemProp->dwItemKind3 == IK3_BFLIGHT )	//   /  

  00869	83 f9 29	 cmp	 ecx, 41			; 00000029H
  0086c	75 1f		 jne	 SHORT $L274835
  0086e	83 fa 35	 cmp	 edx, 53			; 00000035H
  00871	75 1a		 jne	 SHORT $L274835

; 1706 : 							{
; 1707 : 								((CUser*)this)->AddDefinedText( TID_GAME_BOARDFUEL, "" );	//  ~

  00873	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00878	68 7c 04 00 00	 push	 1148			; 0000047cH
  0087d	56		 push	 esi
  0087e	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00883	83 c4 0c	 add	 esp, 12			; 0000000cH
$L274886:

; 1708 : 								return FALSE;

  00886	33 c0		 xor	 eax, eax
  00888	e9 44 03 00 00	 jmp	 $L274653
$L274835:

; 1709 : 							}
; 1710 : 								
; 1711 : 							m_nFuel += pItemProp->dwFuelRe;		// .

  0088d	8b 8d d0 00 00
	00		 mov	 ecx, DWORD PTR [ebp+208]
  00893	8b be 80 06 00
	00		 mov	 edi, DWORD PTR [esi+1664]
  00899	03 f9		 add	 edi, ecx
  0089b	89 be 80 06 00
	00		 mov	 DWORD PTR [esi+1664], edi

; 1712 : 							if( (DWORD)( m_nFuel ) >= pRideProp->dwFFuelReMax )	//    .

  008a1	8b 80 5c 02 00
	00		 mov	 eax, DWORD PTR [eax+604]
  008a7	8b cf		 mov	 ecx, edi
  008a9	3b c8		 cmp	 ecx, eax
  008ab	72 06		 jb	 SHORT $L274838

; 1713 : 								m_nFuel = pRideProp->dwFFuelReMax;

  008ad	89 86 80 06 00
	00		 mov	 DWORD PTR [esi+1664], eax
$L274838:

; 1714 : 						}
; 1715 : 						((CUser *)this)->AddSetFuel( m_nFuel, m_tmAccFuel );		//   . - SetPointParam  ?

  008b3	8b 96 84 06 00
	00		 mov	 edx, DWORD PTR [esi+1668]
  008b9	8b 86 80 06 00
	00		 mov	 eax, DWORD PTR [esi+1664]
  008bf	52		 push	 edx
  008c0	50		 push	 eax
  008c1	8b ce		 mov	 ecx, esi
  008c3	e8 00 00 00 00	 call	 ?AddSetFuel@CUser@@QAEXHK@Z ; CUser::AddSetFuel

; 1716 : 					} else
; 1717 : 						return FALSE;
; 1718 : 				}
; 1719 : 				break;

  008c8	e9 14 02 00 00	 jmp	 $L274888
$L274841:

; 1720 : 
; 1721 : 			case IK2_GMTEXT:
; 1722 : 				{
; 1723 : 					BOOL bGMTime = TRUE;
; 1724 : 					if( pItemProp->dwSkillTime != NULL_ID )		//   

  008cd	83 bd f0 01 00
	00 ff		 cmp	 DWORD PTR [ebp+496], -1
  008d4	bf 01 00 00 00	 mov	 edi, 1
  008d9	74 79		 je	 SHORT $L274852

; 1725 : 					{
; 1726 : 						if( pItemProp->dwItemKind3 == IK3_TEXT_DISGUISE )	//     .

  008db	83 7d 78 51	 cmp	 DWORD PTR [ebp+120], 81	; 00000051H
  008df	75 3f		 jne	 SHORT $L292165

; 1727 : 						{
; 1728 : 							if( IsFly() )

  008e1	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  008e7	f6 41 08 08	 test	 BYTE PTR [ecx+8], 8
  008eb	74 0c		 je	 SHORT $L274845

; 1729 : 							{
; 1730 : 								((CUser*)this)->AddDefinedText( TID_PK_FLIGHT_NOUSE, "" ); //     .

  008ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  008f2	68 c2 09 00 00	 push	 2498			; 000009c2H

; 1731 : 								bGMTime = FALSE;
; 1732 : 							}
; 1733 : #if __VER >= 14	// __INSTANCE_DUNGEON	//       
; 1734 : 							else if( CInstanceDungeonHelper::GetInstance()->IsInstanceDungeon( GetWorld()->GetID() ) )

  008f7	eb 50		 jmp	 SHORT $L292176
$L274845:
  008f9	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  008ff	8b 00		 mov	 eax, DWORD PTR [eax]
  00901	50		 push	 eax
  00902	e8 00 00 00 00	 call	 ?GetInstance@CInstanceDungeonHelper@@SAPAV1@XZ ; CInstanceDungeonHelper::GetInstance
  00907	8b c8		 mov	 ecx, eax
  00909	e8 00 00 00 00	 call	 ?IsInstanceDungeon@CInstanceDungeonHelper@@QAEHK@Z ; CInstanceDungeonHelper::IsInstanceDungeon
  0090e	85 c0		 test	 eax, eax
  00910	74 0e		 je	 SHORT $L292165

; 1735 : 							{
; 1736 : 								((CUser*)this)->AddDefinedText( TID_GAME_INSTANCE_DISGUISE01 );

  00912	68 9a 10 00 00	 push	 4250			; 0000109aH
  00917	8b ce		 mov	 ecx, esi
  00919	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAEXH@Z ; CUser::AddDefinedText

; 1737 : 								bGMTime = FALSE;
; 1738 : 							}
; 1739 : #endif // __INSTANCE_DUNGEON	//       
; 1740 : 						}
; 1741 : 						if( bGMTime )

  0091e	eb 32		 jmp	 SHORT $L292177
$L292165:

; 1742 : 						{
; 1743 : 							if( !HasBuffByIk3( pItemProp->dwItemKind3 ) )

  00920	8b 55 78	 mov	 edx, DWORD PTR [ebp+120]
  00923	52		 push	 edx
  00924	8b ce		 mov	 ecx, esi
  00926	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  0092b	85 c0		 test	 eax, eax
  0092d	75 10		 jne	 SHORT $L274851

; 1744 : 							{
; 1745 : 								DoApplySkill( this, pItemProp, NULL );		//   . 

  0092f	50		 push	 eax
  00930	50		 push	 eax
  00931	50		 push	 eax
  00932	50		 push	 eax
  00933	50		 push	 eax
  00934	55		 push	 ebp
  00935	56		 push	 esi
  00936	8b ce		 mov	 ecx, esi
  00938	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill

; 1746 : 							}
; 1747 : 							else

  0093d	eb 15		 jmp	 SHORT $L274852
$L274851:

; 1748 : 							{
; 1749 : 								((CUser*)this)->AddDefinedText( TID_GAME_LIMITED_USE, "" ); //   

  0093f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00944	68 30 08 00 00	 push	 2096			; 00000830H
$L292176:
  00949	56		 push	 esi
  0094a	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  0094f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L292177:

; 1750 : 								bGMTime = FALSE;

  00952	33 ff		 xor	 edi, edi
$L274852:

; 1751 : 							}
; 1752 : 						}								
; 1753 : 					}
; 1754 : 
; 1755 : 					if(  pItemProp->dwID == II_SYS_SYS_GM_NODISGUISE )

  00954	81 7d 00 8f 65
	00 00		 cmp	 DWORD PTR [ebp], 25999	; 0000658fH
  0095b	75 1a		 jne	 SHORT $L274856

; 1756 : 					{
; 1757 : 						if( HasBuffByIk3( IK3_TEXT_DISGUISE ) )

  0095d	6a 51		 push	 81			; 00000051H
  0095f	8b ce		 mov	 ecx, esi
  00961	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  00966	85 c0		 test	 eax, eax
  00968	0f 84 18 ff ff
	ff		 je	 $L274886

; 1758 : 							RemoveIk3Buffs( IK3_TEXT_DISGUISE );

  0096e	6a 51		 push	 81			; 00000051H
  00970	8b ce		 mov	 ecx, esi
  00972	e8 00 00 00 00	 call	 ?RemoveIk3Buffs@CMover@@QAEXK@Z ; CMover::RemoveIk3Buffs
$L274856:

; 1759 : 						else
; 1760 : 							bGMTime = FALSE;
; 1761 : 					}
; 1762 : 
; 1763 : 					if( bGMTime )

  00977	85 ff		 test	 edi, edi
  00979	0f 84 07 ff ff
	ff		 je	 $L274886

; 1764 : 					{
; 1765 : 						if( pItemProp->dwID != II_SYS_SYS_GM_NODISGUISE )

  0097f	81 7d 00 8f 65
	00 00		 cmp	 DWORD PTR [ebp], 25999	; 0000658fH
  00986	0f 84 55 01 00
	00		 je	 $L274888

; 1766 : 						{
; 1767 : 							char szGMCommand[64] = {0,};

  0098c	33 c0		 xor	 eax, eax
  0098e	c6 84 24 20 01
	00 00 00	 mov	 BYTE PTR _szGMCommand$274859[esp+368], 0
  00996	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0099b	8d bc 24 21 01
	00 00		 lea	 edi, DWORD PTR _szGMCommand$274859[esp+369]
  009a2	f3 ab		 rep stosd
  009a4	66 ab		 stosw
  009a6	aa		 stosb

; 1768 : 							CString szGMText = pItemProp->szTextFileName;

  009a7	8d 85 74 02 00
	00		 lea	 eax, DWORD PTR [ebp+628]
  009ad	50		 push	 eax
  009ae	8d 4c 24 14	 lea	 ecx, DWORD PTR _szGMText$274860[esp+372]
  009b2	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 1769 : 							szGMText.Replace( '(', '\"' );

  009b7	6a 22		 push	 34			; 00000022H
  009b9	6a 28		 push	 40			; 00000028H
  009bb	8d 4c 24 18	 lea	 ecx, DWORD PTR _szGMText$274860[esp+376]
  009bf	c7 84 24 74 01
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+384], 4
  009ca	e8 00 00 00 00	 call	 ?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHDD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Replace

; 1770 : 							szGMText.Replace( ')', '\"' ); 

  009cf	6a 22		 push	 34			; 00000022H
  009d1	6a 29		 push	 41			; 00000029H
  009d3	8d 4c 24 18	 lea	 ecx, DWORD PTR _szGMText$274860[esp+376]
  009d7	e8 00 00 00 00	 call	 ?Replace@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHDD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::Replace

; 1771 : 							int nGMCount = szGMText.Find( "/", 1 );

  009dc	8b 44 24 10	 mov	 eax, DWORD PTR _szGMText$274860[esp+368]
  009e0	83 78 f4 01	 cmp	 DWORD PTR [eax-12], 1
  009e4	7c 34		 jl	 SHORT $L292170
  009e6	40		 inc	 eax
  009e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01KMDKNFGN@?1?$AA@
  009ec	50		 push	 eax
  009ed	e8 00 00 00 00	 call	 __mbsstr
  009f2	8b c8		 mov	 ecx, eax
  009f4	8b 44 24 18	 mov	 eax, DWORD PTR _szGMText$274860[esp+376]
  009f8	83 c4 08	 add	 esp, 8
  009fb	85 c9		 test	 ecx, ecx
  009fd	74 1b		 je	 SHORT $L292170
  009ff	2b c8		 sub	 ecx, eax

; 1772 : 							if( nGMCount != -1 )

  00a01	83 f9 ff	 cmp	 ecx, -1
  00a04	74 14		 je	 SHORT $L292170

; 1773 : 								strncpy( szGMCommand, szGMText, nGMCount );

  00a06	51		 push	 ecx
  00a07	50		 push	 eax
  00a08	8d 8c 24 28 01
	00 00		 lea	 ecx, DWORD PTR _szGMCommand$274859[esp+376]
  00a0f	51		 push	 ecx
  00a10	e8 00 00 00 00	 call	 _strncpy
  00a15	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1774 : 							else

  00a18	eb 13		 jmp	 SHORT $L274864
$L292170:

; 1775 : 								strcpy( szGMCommand, szGMText );

  00a1a	8d 94 24 20 01
	00 00		 lea	 edx, DWORD PTR _szGMCommand$274859[esp+368]
  00a21	2b d0		 sub	 edx, eax
$L291881:
  00a23	8a 08		 mov	 cl, BYTE PTR [eax]
  00a25	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00a28	40		 inc	 eax
  00a29	84 c9		 test	 cl, cl
  00a2b	75 f6		 jne	 SHORT $L291881
$L274864:

; 1776 : 							ParsingCommand( szGMCommand, (CMover*)this, TRUE );

  00a2d	6a 01		 push	 1
  00a2f	8d 94 24 24 01
	00 00		 lea	 edx, DWORD PTR _szGMCommand$274859[esp+372]
  00a36	56		 push	 esi
  00a37	52		 push	 edx
  00a38	e8 00 00 00 00	 call	 ?ParsingCommand@@YAHPBDPAVCMover@@H@Z ; ParsingCommand
  00a3d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1777 : 						}

  00a40	8d 4c 24 10	 lea	 ecx, DWORD PTR _szGMText$274860[esp+368]
  00a44	c7 84 24 6c 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+376], -1
  00a4f	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 1778 : 					}
; 1779 : 					else
; 1780 : 						return FALSE;
; 1781 : 				}
; 1782 : 				break;

  00a54	e9 88 00 00 00	 jmp	 $L274888
$L274867:

; 1783 : 			case IK2_SKILL:
; 1784 : 				{
; 1785 : 					BOOL bUseItem = FALSE;
; 1786 : 					DWORD dwActiveSkill = pItemProp->dwActiveSkill;

  00a59	8b bd a0 01 00
	00		 mov	 edi, DWORD PTR [ebp+416]

; 1787 : 					if( dwActiveSkill != NULL_ID )		//    .

  00a5f	83 ff ff	 cmp	 edi, -1
  00a62	74 7d		 je	 SHORT $L274888

; 1788 : 					{
; 1789 : 						if( pItemProp->dwActiveSkillRate == NULL_ID ||
; 1790 : 							xRandom(100) < pItemProp->dwActiveSkillRate )	//  .

  00a64	83 bd a4 01 00
	00 ff		 cmp	 DWORD PTR [ebp+420], -1
  00a6b	74 14		 je	 SHORT $L274872
  00a6d	6a 64		 push	 100			; 00000064H
  00a6f	e8 00 00 00 00	 call	 ?xRandom@@YAKK@Z	; xRandom
  00a74	8b 8d a4 01 00
	00		 mov	 ecx, DWORD PTR [ebp+420]
  00a7a	83 c4 04	 add	 esp, 4
  00a7d	3b c1		 cmp	 eax, ecx
  00a7f	73 60		 jae	 SHORT $L274888
$L274872:

; 1791 : 						{
; 1792 : 							ItemProp* pSkillProp;
; 1793 : 							pSkillProp = (ItemProp *)prj.GetSkillProp( dwActiveSkill );

  00a81	57		 push	 edi
  00a82	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00a87	e8 00 00 00 00	 call	 ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetSkillProp

; 1794 : 							if( pSkillProp )

  00a8c	85 c0		 test	 eax, eax
  00a8e	0f 84 84 00 00
	00		 je	 $L274875

; 1795 : 							{
; 1796 : 								if( pSkillProp->dwUseChance == WUI_TARGETINGOBJ )	//   .

  00a94	8b 80 f8 01 00
	00		 mov	 eax, DWORD PTR [eax+504]
  00a9a	83 f8 04	 cmp	 eax, 4
  00a9d	75 5e		 jne	 SHORT $L274876

; 1797 : 								{
; 1798 : 									if( IsPlayer() )

  00a9f	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00aa5	85 c0		 test	 eax, eax
  00aa7	74 38		 je	 SHORT $L274888

; 1799 : 									{
; 1800 : 										DWORD idTarget = ((CUser*)this)->m_idSetTarget;

  00aa9	8b 86 48 95 00
	00		 mov	 eax, DWORD PTR [esi+38216]

; 1801 : 										CMover *pTarget = prj.GetMover( idTarget );

  00aaf	50		 push	 eax
  00ab0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00ab5	e8 00 00 00 00	 call	 ?GetMover@CProject@@QAEPAVCMover@@K@Z ; CProject::GetMover
  00aba	8b d8		 mov	 ebx, eax

; 1802 : 										if( IsValidObj( pTarget ) )

  00abc	53		 push	 ebx
  00abd	e8 00 00 00 00	 call	 ?IsValidObj@@YAHPAVCObj@@@Z ; IsValidObj
  00ac2	83 c4 04	 add	 esp, 4
  00ac5	85 c0		 test	 eax, eax
  00ac7	74 14		 je	 SHORT $L292168

; 1803 : 										{
; 1804 : 											DoActiveSkill( dwActiveSkill, pItemProp->dwActiveSkillLv, pTarget );	// dwActiveSkill .

  00ac9	8b 85 cc 00 00
	00		 mov	 eax, DWORD PTR [ebp+204]
  00acf	6a 00		 push	 0
  00ad1	6a 00		 push	 0
  00ad3	53		 push	 ebx
  00ad4	50		 push	 eax
  00ad5	57		 push	 edi
  00ad6	8b ce		 mov	 ecx, esi
  00ad8	e8 00 00 00 00	 call	 ?DoActiveSkill@CCtrl@@QAEXKHPAV1@_NH@Z ; CCtrl::DoActiveSkill
$L292168:

; 1805 : 										}
; 1806 : 									}
; 1807 : 								} else

  00add	8b 5c 24 14	 mov	 ebx, DWORD PTR _pItemBase$[esp+368]
$L274888:

; 1828 : 					}
; 1829 : 				}
; 1830 : 		} // switch ik2
; 1831 : 
; 1832 : 		switch( pItemProp->dwItemKind3 )

  00ae1	8b 45 78	 mov	 eax, DWORD PTR [ebp+120]
  00ae4	83 e8 64	 sub	 eax, 100		; 00000064H
  00ae7	74 6b		 je	 SHORT $L274894
  00ae9	83 e8 14	 sub	 eax, 20			; 00000014H
  00aec	74 5c		 je	 SHORT $L274893
  00aee	83 e8 21	 sub	 eax, 33			; 00000021H
  00af1	75 69		 jne	 SHORT $L274890

; 1839 : 				break;
; 1840 : #ifdef __NEW_ITEM_VARUNA
; 1841 : 			case IK3_SUMMON_NPC:
; 1842 : 				DoUseBarunaPet(pItemElem);

  00af3	53		 push	 ebx
  00af4	8b ce		 mov	 ecx, esi
  00af6	e8 00 00 00 00	 call	 ?DoUseBarunaPet@CMover@@QAEXPAVCItemElem@@@Z ; CMover::DoUseBarunaPet

; 1843 : 				break;

  00afb	eb 5f		 jmp	 SHORT $L274890
$L274876:

; 1808 : 								if( pSkillProp->dwUseChance == WUI_NOW )		//   .

  00afd	83 f8 01	 cmp	 eax, 1
  00b00	75 df		 jne	 SHORT $L274888

; 1809 : 								{
; 1810 : 									DoActiveSkill( dwActiveSkill, pItemProp->dwActiveSkillLv, this );	// 

  00b02	8b 8d cc 00 00
	00		 mov	 ecx, DWORD PTR [ebp+204]
  00b08	6a 00		 push	 0
  00b0a	6a 00		 push	 0
  00b0c	56		 push	 esi
  00b0d	51		 push	 ecx
  00b0e	57		 push	 edi
  00b0f	8b ce		 mov	 ecx, esi
  00b11	e8 00 00 00 00	 call	 ?DoActiveSkill@CCtrl@@QAEXKHPAV1@_NH@Z ; CCtrl::DoActiveSkill

; 1811 : 								}
; 1812 : 							} else

  00b16	eb c9		 jmp	 SHORT $L274888
$L274875:

; 1813 : 								Error( "DoUseItem, IK2_SKILL, item %s -> %d skill not prop", pItemProp->szName, dwActiveSkill );

  00b18	57		 push	 edi
  00b19	8d 55 04	 lea	 edx, DWORD PTR [ebp+4]
  00b1c	52		 push	 edx
  00b1d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DD@FCPHEJAC@DoUseItem?0?5IK2_SKILL?0?5item?5?$CFs?5?9?$DO@
  00b22	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00b27	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1814 : 						}
; 1815 : 					}
; 1816 : 				}
; 1817 : 				break;

  00b2a	eb b5		 jmp	 SHORT $L274888
$L274887:

; 1818 : #ifdef __TREASUREBOX
; 1819 : 			case IK2_TREASURE:
; 1820 : 				return FALSE;
; 1821 : 				break;
; 1822 : #endif//__TREASUREBOX
; 1823 : 			default:
; 1824 : 				{
; 1825 : 					if( pItemProp->dwSkillTime != NULL_ID )		//   

  00b2c	83 bd f0 01 00
	00 ff		 cmp	 DWORD PTR [ebp+496], -1
  00b33	74 ac		 je	 SHORT $L274888

; 1826 : 					{
; 1827 : 						DoApplySkill( this, pItemProp, NULL );		//   . 

  00b35	6a 00		 push	 0
  00b37	6a 00		 push	 0
  00b39	6a 00		 push	 0
  00b3b	6a 00		 push	 0
  00b3d	6a 00		 push	 0
  00b3f	55		 push	 ebp
  00b40	56		 push	 esi
  00b41	8b ce		 mov	 ecx, esi
  00b43	e8 00 00 00 00	 call	 ?DoApplySkill@CCtrl@@QAEHPAV1@PAUItemProp@@PAUAddSkillProp@@_NHHH@Z ; CCtrl::DoApplySkill
  00b48	eb 97		 jmp	 SHORT $L274888
$L274893:

; 1833 : 		{
; 1834 : 			case IK3_EGG:
; 1835 : 				DoUseSystemPet( pItemElem );

  00b4a	53		 push	 ebx
  00b4b	8b ce		 mov	 ecx, esi
  00b4d	e8 00 00 00 00	 call	 ?DoUseSystemPet@CMover@@AAEXPAVCItemElem@@@Z ; CMover::DoUseSystemPet

; 1836 : 				break;

  00b52	eb 08		 jmp	 SHORT $L274890
$L274894:

; 1837 : 			case IK3_PET:
; 1838 : 				DoUseEatPet( pItemElem );

  00b54	53		 push	 ebx
  00b55	8b ce		 mov	 ecx, esi
  00b57	e8 00 00 00 00	 call	 ?DoUseEatPet@CMover@@AAEXPAVCItemElem@@@Z ; CMover::DoUseEatPet
$L274890:

; 1844 : #endif // __NEW_ITEM_VARUNA
; 1845 : 
; 1846 : 		}
; 1847 : 
; 1848 : 		OnAfterUseItem( pItemProp );	// raiders 06.04.20

  00b5c	55		 push	 ebp
  00b5d	8b ce		 mov	 ecx, esi
  00b5f	e8 00 00 00 00	 call	 ?OnAfterUseItem@CMover@@QAEXPBUItemProp@@@Z ; CMover::OnAfterUseItem

; 1849 : 		pItemElem->UseItem();			// --m_nItemNum;

  00b64	8b cb		 mov	 ecx, ebx
  00b66	e8 00 00 00 00	 call	 ?UseItem@CItemElem@@QAEXXZ ; CItemElem::UseItem

; 1850 : 
; 1851 : 		if( pItemElem->m_bCharged )		//   

  00b6b	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [ebx+172]
  00b71	85 c0		 test	 eax, eax
  00b73	74 17		 je	 SHORT $L274896

; 1852 : 			g_dpDBClient.SendLogSMItemUse( "1", (CUser*)this, pItemElem, pItemProp );		

  00b75	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00b7a	55		 push	 ebp
  00b7b	53		 push	 ebx
  00b7c	56		 push	 esi
  00b7d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01HIHLOKLC@1?$AA@
  00b82	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  00b87	e8 00 00 00 00	 call	 ?SendLogSMItemUse@CDPDatabaseClient@@QAEXPBDPAVCUser@@PAVCItemElem@@PAUItemProp@@0@Z ; CDPDatabaseClient::SendLogSMItemUse
$L274896:

; 1853 : 
; 1854 : 		CHAR cUIParam = UI_NUM;
; 1855 : 		if( dwGroup )	//    .

  00b8c	8b 44 24 1c	 mov	 eax, DWORD PTR _dwGroup$274683[esp+368]
  00b90	85 c0		 test	 eax, eax
  00b92	c6 44 24 14 00	 mov	 BYTE PTR _cUIParam$274898[esp+368], 0
  00b97	74 18		 je	 SHORT $L274899

; 1856 : 		{
; 1857 : 			CUser* pUser = (CUser*)this;
; 1858 : 			pUser->m_cooltimeMgr.SetTime( dwGroup, pItemProp->GetCoolTime() );	

  00b99	8b 8d c8 01 00
	00		 mov	 ecx, DWORD PTR [ebp+456]
  00b9f	51		 push	 ecx
  00ba0	50		 push	 eax
  00ba1	8d 8e a4 95 00
	00		 lea	 ecx, DWORD PTR [esi+38308]
  00ba7	e8 00 00 00 00	 call	 ?SetTime@CCooltimeMgr@@QAEXKK@Z ; CCooltimeMgr::SetTime

; 1859 : 			cUIParam = UI_COOLTIME;

  00bac	c6 44 24 14 08	 mov	 BYTE PTR _cUIParam$274898[esp+368], 8
$L274899:

; 1860 : 		}
; 1861 : 
; 1862 : 		UpdateItem( (BYTE)( dwId ), cUIParam, pItemElem->m_nItemNum );	//  0    ,  

  00bb1	0f bf 93 80 00
	00 00		 movsx	 edx, WORD PTR [ebx+128]
  00bb8	8b 44 24 14	 mov	 eax, DWORD PTR _cUIParam$274898[esp+368]
  00bbc	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dwId$[esp+368]
  00bc0	6a 00		 push	 0
  00bc2	52		 push	 edx
  00bc3	50		 push	 eax
  00bc4	51		 push	 ecx
  00bc5	8b ce		 mov	 ecx, esi
  00bc7	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L274681:

; 1863 : 	}
; 1864 : 	
; 1865 : #endif // WORLDSERVER
; 1866 : 
; 1867 : 	return TRUE;

  00bcc	b8 01 00 00 00	 mov	 eax, 1
$L274653:

; 1868 : }

  00bd1	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+368]
  00bd8	5f		 pop	 edi
  00bd9	5e		 pop	 esi
  00bda	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00be1	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+360]
  00be8	5d		 pop	 ebp
  00be9	5b		 pop	 ebx
  00bea	33 cc		 xor	 ecx, esp
  00bec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bf1	81 c4 60 01 00
	00		 add	 esp, 352		; 00000160H
  00bf7	c2 0c 00	 ret	 12			; 0000000cH
  00bfa	8b ff		 npad	 2
$L292182:
  00bfc	00 00 00 00	 DD	 $L274807
  00c00	00 00 00 00	 DD	 $L274816
  00c04	00 00 00 00	 DD	 $L274825
  00c08	00 00 00 00	 DD	 $L274739
  00c0c	00 00 00 00	 DD	 $L274806
  00c10	00 00 00 00	 DD	 $L274827
  00c14	00 00 00 00	 DD	 $L274736
  00c18	00 00 00 00	 DD	 $L274841
  00c1c	00 00 00 00	 DD	 $L274724
  00c20	00 00 00 00	 DD	 $L274714
  00c24	00 00 00 00	 DD	 $L274867
  00c28	00 00 00 00	 DD	 $L274715
  00c2c	00 00 00 00	 DD	 $L274705
  00c30	00 00 00 00	 DD	 $L274711
  00c34	00 00 00 00	 DD	 $L274693
  00c38	00 00 00 00	 DD	 $L274702
  00c3c	00 00 00 00	 DD	 $L274773
  00c40	00 00 00 00	 DD	 $L274765
  00c44	00 00 00 00	 DD	 $L274886
  00c48	00 00 00 00	 DD	 $L274887
$L292166:
  00c4c	00		 DB	 0
  00c4d	01		 DB	 1
  00c4e	13		 DB	 19			; 00000013H
  00c4f	02		 DB	 2
  00c50	13		 DB	 19			; 00000013H
  00c51	13		 DB	 19			; 00000013H
  00c52	13		 DB	 19			; 00000013H
  00c53	13		 DB	 19			; 00000013H
  00c54	03		 DB	 3
  00c55	13		 DB	 19			; 00000013H
  00c56	13		 DB	 19			; 00000013H
  00c57	04		 DB	 4
  00c58	05		 DB	 5
  00c59	13		 DB	 19			; 00000013H
  00c5a	13		 DB	 19			; 00000013H
  00c5b	06		 DB	 6
  00c5c	07		 DB	 7
  00c5d	13		 DB	 19			; 00000013H
  00c5e	08		 DB	 8
  00c5f	09		 DB	 9
  00c60	0a		 DB	 10			; 0000000aH
  00c61	13		 DB	 19			; 00000013H
  00c62	0b		 DB	 11			; 0000000bH
  00c63	0c		 DB	 12			; 0000000cH
  00c64	0c		 DB	 12			; 0000000cH
  00c65	0d		 DB	 13			; 0000000dH
  00c66	08		 DB	 8
  00c67	0e		 DB	 14			; 0000000eH
  00c68	0e		 DB	 14			; 0000000eH
  00c69	0e		 DB	 14			; 0000000eH
  00c6a	0f		 DB	 15			; 0000000fH
  00c6b	10		 DB	 16			; 00000010H
  00c6c	11		 DB	 17			; 00000011H
  00c6d	13		 DB	 19			; 00000013H
  00c6e	13		 DB	 19			; 00000013H
  00c6f	13		 DB	 19			; 00000013H
  00c70	13		 DB	 19			; 00000013H
  00c71	13		 DB	 19			; 00000013H
  00c72	13		 DB	 19			; 00000013H
  00c73	13		 DB	 19			; 00000013H
  00c74	13		 DB	 19			; 00000013H
  00c75	13		 DB	 19			; 00000013H
  00c76	13		 DB	 19			; 00000013H
  00c77	13		 DB	 19			; 00000013H
  00c78	12		 DB	 18			; 00000012H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L291882:
  00000	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _str$274777[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L291883:
  0000b	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _str$274786[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L291884:
  00016	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _szMaxBuf$274787[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L291885:
  00021	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _strTemp$274803[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L291886:
  0002c	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _szGMText$274860[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?DoUseItem@CMover@@QAEHKKH@Z:
  00037	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T292161
  0003c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DoUseItem@CMover@@QAEHKKH@Z ENDP			; CMover::DoUseItem
END
