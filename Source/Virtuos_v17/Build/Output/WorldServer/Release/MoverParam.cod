; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Common\MoverParam.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BC@MOGJFHKK@tr1?3?3bad_weak_ptr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@NIDLLMEN@CMover?3?3GetSkill?5?3?5?$CFs?5nId?5?$DN?5?$CFd?5?$LJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@OAFIFIPO@SetPointParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUse@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KNKGEAPB@ANGEL_EXP_LOG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@ODCCKCNB@CMover?3?3DecExperiencePercent?5?3?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FO@OOMNFAPD@1?5CMover?3?3DecExperiencePercent?5?3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GG@EIMKDIB@0?5CMover?3?3DecExperiencePercent?5?3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@JFCDNFPO@Parts?5Not?5Property?5?$DN?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@PFHOFKCA@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S?$LN?C?$LA?$KD@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@FNFHKMOG@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5tick?5?$LN?C?$LA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@BJJIDPPP@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g?5?$LF?$KF?$LJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@PECENGHI@SetDark?5?3?5?$CFs?5?$LO?n?$LF?R?H?$LP?$LA?z?$MA?G?5?$LI?m?A?$NP?$LH?$PM?5?$LM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@KMFJEAB@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@BBMBAHHG@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5tick@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@CJNNIDBD@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@LGNMPJME@SetDestParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUser@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@BNFMMDML@SetDestParam?5?3?5Adj?5?$DN?$DN?5?91?0?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@GBNLCJJD@CMover?3?3GetReistSpell?5?3?5?$CFd?5?G?A?$LH?N?F@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@LCMNFNMN@CMover?3?3GetResistSpell?5?3?5?$CFs?5?F?D?$LG?s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLCNDIKD@SetQuestCnt?5?3?5?D?y?$LN?$LK?F?$KO?5?C?J?$LA?z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?IsLeader@CParty@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectMemberClear@__GuildCombatMember@CGuildCombat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__MINIGAME_PACKET@@QAE@GHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@__MINIGAME_EXT_PACKET@@UAEXAAVCAr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MINIGMAME_PRIZE_LIST@CRainbowRaceMng@@QAE@KHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerId2CampusId@CCampusMng@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChild@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChild@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMapChildE@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMapChildE@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRecvHandle@CDPSock@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSPEvent@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSPEvent@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CEventItem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCEventItem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSpawn@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxSpawnProbability@CSpawn@@AAEKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSpawn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@bad_weak_ptr@boost@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sp_counted_base@detail@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@sp_counted_base@detail@boost@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_copy@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_ref_lock@sp_counted_base@detail@boost@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_add_ref@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?weak_release@sp_counted_base@detail@boost@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@sp_counted_base@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gsp_counted_base@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_count@shared_count@detail@boost@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_weak_ptr@boost@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_weak_ptr@boost@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCooltime@CLordSkillComponent@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTick@CLordSkillComponent@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CLordSkillComponentExecutable@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CLordSkillComponentExecutable@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Execute@CLordSkillComponentExecutable@@UAEXKKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLordSkillComponentExecutable@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDeposit@CCandidate@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVote@CCandidate@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCreate@CCandidate@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEvent@CLord@@QAEPAVILordEvent@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentEffect@CEnvironment@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkillIdx@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckSkill@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutLvUpSkillName_1@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSkillParent@@YAHPAVCMover@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsActive@@YAHPAVCMover@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutLvUpSkillName_2@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSummonState@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsJobType@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBaseJob@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExpert@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPro@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLegendChar@CMover@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMaster@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsHero@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLegendHero@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInteriorityJob@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetExpert@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetJob@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExpPercent@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRemainGP@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAdjHitRate@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParrying@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateParam@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemAbility@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemAbilityMin@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemAbilityMax@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncHitPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncManaPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncFatiguePoint@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeFame@CMover@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DuelResult@CMover@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHitPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetManaPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFatiguePoint@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPointParam@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPointParam@CMover@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncStrLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncStaLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncDexLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IncIntLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddExperience@CMover@@QAEH_JHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecExperience@CMover@@QAEH_JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecExperiencePercent@CMover@@QAEHMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFxp@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddChangeJob@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFxp@CMover@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetExperience@CMover@@QAEH_JH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEquipDstParam@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SumEquipDefenseAbility@CMover@@QAEHPAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SumEquipAdjValue@CMover@@QAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDarkCover@CMover@@QAEHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStun@CMover@@QAEHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPoison@CMover@@QAEHHKKKF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDark@CMover@@QAEHHKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBleeding@CMover@@QAEHHKKKF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveDebuff@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveBuffOne@CMover@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveBuffAll@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDestParam@CMover@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDestParam@CMover@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDestParam@CMover@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDestParamSync@CMover@@QAEXHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAdjParam@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChgParam@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParam@CMover@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHitPoint@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetManaPoint@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFatiguePoint@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxHitPoint@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxManaPoint@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxFatiguePoint@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxPoint@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxOriginHitPoint@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxOriginManaPoint@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHitPointPercent@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetManaPointPercent@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFatiguePointPercent@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHPRecovery@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMPRecovery@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFPRecovery@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetResistMagic@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetResistSpell@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNaturalArmor@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStr@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDex@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInt@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSta@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSpeed@CMover@@QAEMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BehaviorActionForceSet@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActionForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MKKHHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActionForceSet2@CMover@@QAEXAAUD3DXVECTOR3@@0MMMMKKHHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HalfForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCompleteQuest@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeCompleteQuest@CMover@@QAEHHPAUtagQuest@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAllQuest@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveCompleteQuest@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindQuest@CMover@@QAEPAUtagQuest@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveQuest@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetQuest@CMover@@QAEHPAUtagQuest@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__SetQuest@CMover@@AAEHPAUtagQuest@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetQuest@CMover@@QAEPAUtagQuest@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemNum@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveItemA@CMover@@QAEHKF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAllItem@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTradeRemoveUser@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abrade@CMover@@QAEXPAV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRandomPartsAbraded@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemEnduranceInfluence@CMover@@SAMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemEnduranceWeight@CMover@@SAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateItemEx@CMover@@QAEXED_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateItem@CMover@@QAEXEDKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemDropRateFactor@CMover@@QAEMPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPieceItemDropRateFactor@CMover@@QAEMPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExpFactor@CMover@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@@std@@QAEAAPAVCCtrl@@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuild@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuild@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAU_PlayerData@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAU_PlayerData@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEXABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCRainbowRace@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCRainbowRace@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAPAVCMiniGameBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampusMember@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampusMember@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@PAVsp_counted_base@detail@boost@@@std@@QBE_NABQAVsp_counted_base@detail@boost@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLordSkillComponentExecutable@@V?$allocator@PAVCLordSkillComponentExecutable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$shared_ptr@VCCandidate@@@boost@@V?$allocator@V?$shared_ptr@VCCandidate@@@boost@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$shared_ptr@VCCandidate@@@boost@@QBEPAVCCandidate@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCLEComponent@@V?$allocator@PAVCLEComponent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@M_J@std@@V?$allocator@U?$pair@M_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBKPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAE@V?$allocator@U__SECRETROOM_MONSTER@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@V312@ABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCGuildHouseBase@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCampus@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCampus@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEAAPAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEAAPAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEAAUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@IAEXPAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@QAEXPAPAU__JOINPLAYER@CGuildCombat@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IAEXPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U__SECRETROOM_MONSTER@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEPAU__SECRETROOM_MONSTER@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXViterator@12@IABUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCGuildHouseBase@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSock@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSock@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSock@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCClientSockE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCClientSockE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCClientSockE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QBEABQAU__JOINPLAYER@CGuildCombat@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QBEABQAVCMiniGameBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QBEABUGuildHouse_Furniture_Info@CGuildHouseBase@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U__SECRETROOM_MONSTER@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@QAE@PAPAU__JOINPLAYER@CGuildCombat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QAE@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVCMiniGameBase@@V?$allocator@PAVCMiniGameBase@@@std@@@std@@QAE@PAPAVCMiniGameBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UGuildHouse_Furniture_Info@CGuildHouseBase@@V?$allocator@UGuildHouse_Furniture_Info@CGuildHouseBase@@@std@@@std@@QAE@PAUGuildHouse_Furniture_Info@CGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCGuildHouseBase@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@K@1@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPCoreClient@@AEXAAVCAr@@KKK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPCoreClient@@AEXAAVCAr@@KKK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPDatabaseClient@@AEXAAVCAr@@KK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPDatabaseClient@@AEXAAVCAr@@KK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KP8CDPSrvr@@AEXAAVCAr@@KKPAEK@ZU?$less@K@std@@V?$allocator@U?$pair@$$CBKP8CDPSrvr@@AEXAAVCAr@@KKPAEK@Z@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKU_Friend@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKU_Friend@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBKK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@SAABKABU?$pair@$$CBKK@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@QAE@U?$less@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$make_pair@KPAVCGuildHouseBase@@@std@@YA?AU?$pair@KPAVCGuildHouseBase@@@0@KPAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0KPAVCGuildHouseBase@@@?$pair@$$CBKPAVCGuildHouseBase@@@std@@QAE@ABU?$pair@KPAVCGuildHouseBase@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$throw_exception@Vbad_weak_ptr@boost@@@boost@@YAXABVbad_weak_ptr@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U__SECRETROOM_MONSTER@@@std@@YAPAU__SECRETROOM_MONSTER@@IPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@?$vector@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@IAEPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCGuildHouseBase@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCGuildHouseBase@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSock@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSock@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSock@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBKPAVCClientSockE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCClientSockE@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCClientSockE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0bad_weak_ptr@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCGuildHouseBase@@@std@@QAE@ABKABQAVCGuildHouseBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@IABU12@AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U__JOINPLAYER@CGuildCombat@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU__JOINPLAYER@CGuildCombat@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU__JOINPLAYER@CGuildCombat@@V?$allocator@PAU__JOINPLAYER@CGuildCombat@@@std@@@std@@YAXPAPAU__JOINPLAYER@CGuildCombat@@0AAV?$allocator@PAU__JOINPLAYER@CGuildCombat@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SECRETROOM_MONSTER@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SECRETROOM_MONSTER@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SECRETROOM_MONSTER@@V?$allocator@U__SECRETROOM_MONSTER@@@std@@@std@@YAXPAU__SECRETROOM_MONSTER@@0AAV?$allocator@U__SECRETROOM_MONSTER@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@MV?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@0AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SECRETROOM_MONSTER@@@std@@QAEXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@QAEXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@V?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@@std@@YAPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@PAU12@00AAV?$allocator@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SECRETROOM_MONSTER@@@std@@YAXPAU__SECRETROOM_MONSTER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@U12@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@std@@YAXPAUMINIGMAME_PRIZE_LIST@CRainbowRaceMng@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_weak_ptr@boost@@@8??0bad_weak_ptr@boost@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_weak_ptr@boost@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_weak_ptr@boost@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@SAABKABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBKPAVCCtrl@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBKPAVCCtrl@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVCCtrl@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVCCtrl@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAABKPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasActivatedEatPet@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRandomOpt@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVisKeepTime@CItemElem@@QAEXHJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVisKeepTimeSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVisKeepTimeSize@CPiercing@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@J@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@J@std@@QAEPAJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@J@std@@YAPAJIPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@J@std@@QAEXPAJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetUltimatePiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAbilityOption@CItemElem@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCollector@CItemElem@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAccessory@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRandomOptItemId@CItemElem@@QAEX_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDest@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestObj@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestAngle@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearDestPos@CMover@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSpeedFactor@CMover@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pow@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAbilityOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInvalidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFlightLv@CMover@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFlightLv@CMover@@QAEXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevelExp@CProject@@QAEKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHK@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHK@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHK@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHK@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPKPropensity@CMover@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsChaotic@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetId@IBuff@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetId@CCtrl@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSMMode@CMover@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPropA@CMover@@QAEPAUMoverProp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsPlayer@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFly@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFly@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDie@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDie@CAction@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CLordSkillComponentExecutable@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_weak_ptr@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7sp_counted_base@detail@boost@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSpawn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CEventItem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSPEvent@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMapChildE@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMapChild@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBuffer2@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@ABK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YAAAVCAr@@AAV0@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVCAr@@AAV0@UD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_EXT_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7__MINIGAME_PACKET@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CAr@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CAr@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CAr@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?IsLeader@CParty@@QAEHK@Z			; CParty::IsLeader
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\party.h
;	COMDAT ?IsLeader@CParty@@QAEHK@Z
_TEXT	SEGMENT
_uPlayerId$ = 8						; size = 4
?IsLeader@CParty@@QAEHK@Z PROC NEAR			; CParty::IsLeader, COMDAT
; _this$ = ecx

; 120  : 	int		IsLeader( u_long uPlayerId )		{	return( m_aMember[0].m_uPlayerId == uPlayerId );	}

  00000	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00003	8b 54 24 04	 mov	 edx, DWORD PTR _uPlayerId$[esp-4]
  00007	33 c0		 xor	 eax, eax
  00009	3b ca		 cmp	 ecx, edx
  0000b	0f 94 c0	 sete	 al
  0000e	c2 04 00	 ret	 4
?IsLeader@CParty@@QAEHK@Z ENDP				; CParty::IsLeader
_TEXT	ENDS
PUBLIC	??0CTimeSpan@ATL@@QAE@JHHH@Z			; ATL::CTimeSpan::CTimeSpan
EXTRN	__allmul:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT
_lDays$ = 8						; size = 4
_nHours$ = 12						; size = 4
_nMins$ = 16						; size = 4
_nSecs$ = 20						; size = 4
??0CTimeSpan@ATL@@QAE@JHHH@Z PROC NEAR			; ATL::CTimeSpan::CTimeSpan, COMDAT
; _this$ = ecx

; 38   :  	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _lDays$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	6a 00		 push	 0
  00008	99		 cdq
  00009	6a 18		 push	 24			; 00000018H
  0000b	52		 push	 edx
  0000c	50		 push	 eax
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 __allmul
  00014	8b c8		 mov	 ecx, eax
  00016	8b 44 24 10	 mov	 eax, DWORD PTR _nHours$[esp+4]
  0001a	8b fa		 mov	 edi, edx
  0001c	99		 cdq
  0001d	6a 00		 push	 0
  0001f	03 c8		 add	 ecx, eax
  00021	6a 3c		 push	 60			; 0000003cH
  00023	13 fa		 adc	 edi, edx
  00025	57		 push	 edi
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 __allmul
  0002c	8b c8		 mov	 ecx, eax
  0002e	8b 44 24 14	 mov	 eax, DWORD PTR _nMins$[esp+4]
  00032	8b fa		 mov	 edi, edx
  00034	99		 cdq
  00035	6a 00		 push	 0
  00037	03 c8		 add	 ecx, eax
  00039	6a 3c		 push	 60			; 0000003cH
  0003b	13 fa		 adc	 edi, edx
  0003d	57		 push	 edi
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 __allmul
  00044	8b c8		 mov	 ecx, eax
  00046	8b 44 24 18	 mov	 eax, DWORD PTR _nSecs$[esp+4]
  0004a	8b fa		 mov	 edi, edx
  0004c	99		 cdq
  0004d	03 c8		 add	 ecx, eax
  0004f	13 fa		 adc	 edi, edx
  00051	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00054	5f		 pop	 edi
  00055	89 0e		 mov	 DWORD PTR [esi], ecx

; 39   : }

  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	c2 10 00	 ret	 16			; 00000010H
??0CTimeSpan@ATL@@QAE@JHHH@Z ENDP			; ATL::CTimeSpan::CTimeSpan
_TEXT	ENDS
PUBLIC	?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ		; ATL::CTimeSpan::GetTimeSpan
; Function compile flags: /Ogty
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ PROC NEAR		; ATL::CTimeSpan::GetTimeSpan, COMDAT
; _this$ = ecx

; 78   : 	return( m_timeSpan );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 79   : }

  00005	c3		 ret	 0
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ ENDP		; ATL::CTimeSpan::GetTimeSpan
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
; Function compile flags: /Ogty
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 167  : {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _time$[esp]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _time$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 168  : }

  0000f	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	?GetEvent@CLord@@QAEPAVILordEvent@@XZ		; CLord::GetEvent
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\lord.h
;	COMDAT ?GetEvent@CLord@@QAEPAVILordEvent@@XZ
_TEXT	SEGMENT
?GetEvent@CLord@@QAEPAVILordEvent@@XZ PROC NEAR		; CLord::GetEvent, COMDAT
; _this$ = ecx

; 261  : 	ILordEvent*	GetEvent( void )	{	return m_pEvent;	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetEvent@CLord@@QAEPAVILordEvent@@XZ ENDP		; CLord::GetEvent
_TEXT	ENDS
PUBLIC	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z		; ATL::CTime::operator+
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_span$ = 12						; size = 8
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z PROC NEAR	; ATL::CTime::operator+, COMDAT
; _this$ = ecx

; 286  : 	return( CTime( m_time+span.GetTimeSpan() ) );

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 44 24 08	 mov	 eax, DWORD PTR _span$[esp-4]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	03 d0		 add	 edx, eax
  0000b	13 4c 24 0c	 adc	 ecx, DWORD PTR _span$[esp]
  0000f	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00013	89 10		 mov	 DWORD PTR [eax], edx
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 287  : }

  00018	c2 0c 00	 ret	 12			; 0000000cH
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z ENDP		; ATL::CTime::operator+
_TEXT	ENDS
PUBLIC	?GetEnvironmentEffect@CEnvironment@@QAEHXZ	; CEnvironment::GetEnvironmentEffect
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\environment.h
;	COMDAT ?GetEnvironmentEffect@CEnvironment@@QAEHXZ
_TEXT	SEGMENT
?GetEnvironmentEffect@CEnvironment@@QAEHXZ PROC NEAR	; CEnvironment::GetEnvironmentEffect, COMDAT
; _this$ = ecx

; 14   : 	BOOL	GetEnvironmentEffect()	{	return m_bEffect;	}

  00000	8b 81 d0 02 00
	00		 mov	 eax, DWORD PTR [ecx+720]
  00006	c3		 ret	 0
?GetEnvironmentEffect@CEnvironment@@QAEHXZ ENDP		; CEnvironment::GetEnvironmentEffect
_TEXT	ENDS
PUBLIC	?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z		; CMover::GetSkill
PUBLIC	??_C@_0CN@NIDLLMEN@CMover?3?3GetSkill?5?3?5?$CFs?5nId?5?$DN?5?$CFd?5?$LJ@ ; `string'
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0CN@NIDLLMEN@CMover?3?3GetSkill?5?3?5?$CFs?5nId?5?$DN?5?$CFd?5?$LJ@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	SEGMENT
??_C@_0CN@NIDLLMEN@CMover?3?3GetSkill?5?3?5?$CFs?5nId?5?$DN?5?$CFd?5?$LJ@ DB 'C'
	DB	'Mover::GetSkill : %s nId = %d ', 0b9H, 0fcH, 0c0H, 0a7H, 0b8H
	DB	0a6H, ' ', 0b9H, 0feH, 0beH, 0eeH, 0b3H, 0b2H, 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z
_TEXT	SEGMENT
_nType$ = 8						; size = 4
_nIdx$ = 12						; size = 4
?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z PROC NEAR	; CMover::GetSkill, COMDAT
; _this$ = ecx

; 87   : 	// nType == 0  
; 88   : 	// nType == 1   
; 89   : 	if( nIdx >= MAX_SKILL_JOB )

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nIdx$[esp-4]
  00004	83 f8 33	 cmp	 eax, 51			; 00000033H
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	7c 17		 jl	 SHORT $L282419

; 90   : 	{
; 91   : 		Error( "CMover::GetSkill : %s nId = %d  ", m_szName, nIdx );

  0000c	50		 push	 eax
  0000d	8d 86 90 16 00
	00		 lea	 eax, DWORD PTR [esi+5776]
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@NIDLLMEN@CMover?3?3GetSkill?5?3?5?$CFs?5nId?5?$DN?5?$CFd?5?$LJ@
  00019	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 92   : 		nIdx = 0;

  00021	33 c0		 xor	 eax, eax
$L282419:

; 93   : 	}
; 94   : 	return &m_aJobSkill[ nIdx ];

  00023	8d 84 c6 6c 03
	00 00		 lea	 eax, DWORD PTR [esi+eax*8+876]
  0002a	5e		 pop	 esi

; 95   : }

  0002b	c2 08 00	 ret	 8
?GetSkill@CMover@@QAEPAUtagSkill@@HH@Z ENDP		; CMover::GetSkill
_TEXT	ENDS
PUBLIC	?GetSkill@CMover@@QAEPAUtagSkill@@K@Z		; CMover::GetSkill
; Function compile flags: /Ogty
;	COMDAT ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z
_TEXT	SEGMENT
_dwSkill$ = 8						; size = 4
?GetSkill@CMover@@QAEPAUtagSkill@@K@Z PROC NEAR		; CMover::GetSkill, COMDAT
; _this$ = ecx

; 97   : {

  00000	56		 push	 esi

; 98   : 	for( int i = 0; i < MAX_SKILL_JOB; i++ )	

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _dwSkill$[esp]
  00005	33 c0		 xor	 eax, eax
  00007	8d 91 6c 03 00
	00		 lea	 edx, DWORD PTR [ecx+876]
  0000d	8d 49 00	 npad	 3
$L275127:

; 99   : 	{
; 100  : 		if( m_aJobSkill[i].dwSkill == dwSkill )

  00010	39 32		 cmp	 DWORD PTR [edx], esi
  00012	74 0f		 je	 SHORT $L282424
  00014	40		 inc	 eax
  00015	83 c2 08	 add	 edx, 8
  00018	83 f8 33	 cmp	 eax, 51			; 00000033H
  0001b	7c f3		 jl	 SHORT $L275127

; 102  : 	}
; 103  : 	return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 104  : }

  00020	c2 04 00	 ret	 4
$L282424:

; 101  : 			return &m_aJobSkill[i];

  00023	8d 84 c1 6c 03
	00 00		 lea	 eax, DWORD PTR [ecx+eax*8+876]
  0002a	5e		 pop	 esi

; 104  : }

  0002b	c2 04 00	 ret	 4
?GetSkill@CMover@@QAEPAUtagSkill@@K@Z ENDP		; CMover::GetSkill
_TEXT	ENDS
PUBLIC	?GetSkillIdx@CMover@@QAEHK@Z			; CMover::GetSkillIdx
; Function compile flags: /Ogty
;	COMDAT ?GetSkillIdx@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwSkill$ = 8						; size = 4
?GetSkillIdx@CMover@@QAEHK@Z PROC NEAR			; CMover::GetSkillIdx, COMDAT
; _this$ = ecx

; 108  : 	for( int i = 0; i < MAX_SKILL_JOB; i++ )	

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _dwSkill$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	81 c1 6c 03 00
	00		 add	 ecx, 876		; 0000036cH
  0000c	8d 64 24 00	 npad	 4
$L275136:

; 109  : 	{
; 110  : 		if( m_aJobSkill[i].dwSkill == dwSkill )

  00010	39 11		 cmp	 DWORD PTR [ecx], edx
  00012	74 0c		 je	 SHORT $L275134
  00014	40		 inc	 eax
  00015	83 c1 08	 add	 ecx, 8
  00018	83 f8 33	 cmp	 eax, 51			; 00000033H
  0001b	7c f3		 jl	 SHORT $L275136

; 111  : 			return i;
; 112  : 	}
; 113  : 	return -1;

  0001d	83 c8 ff	 or	 eax, -1
$L275134:

; 114  : }

  00020	c2 04 00	 ret	 4
?GetSkillIdx@CMover@@QAEHK@Z ENDP			; CMover::GetSkillIdx
_TEXT	ENDS
PUBLIC	?PutLvUpSkillName_1@CMover@@QAEXK@Z		; CMover::PutLvUpSkillName_1
; Function compile flags: /Ogty
;	COMDAT ?PutLvUpSkillName_1@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwLevel$ = 8						; size = 4
?PutLvUpSkillName_1@CMover@@QAEXK@Z PROC NEAR		; CMover::PutLvUpSkillName_1, COMDAT
; _this$ = ecx

; 166  : #ifdef __CLIENT
; 167  : 	for( int i = 0; i < MAX_SKILL_JOB; i++ )	
; 168  : 	{
; 169  : 		if( m_aJobSkill[i].dwSkill == NULL_ID ) 
; 170  : 			continue;
; 171  : 		
; 172  : 		ItemProp* pSkillProp = prj.GetSkillProp( m_aJobSkill[i].dwSkill );
; 173  : 		
; 174  : 		if( pSkillProp && dwLevel == pSkillProp->dwReqDisLV )
; 175  : 		{
; 176  : 			if( pSkillProp->dwReSkill1 != -1 )
; 177  : 			{
; 178  : 				LPSKILL pSkill = GetSkill(pSkillProp->dwReSkill1);
; 179  : 
; 180  : 				if( pSkillProp->dwReSkillLevel1 > pSkill->dwLevel )
; 181  : 					continue;
; 182  : 			}
; 183  : 			if( pSkillProp->dwReSkill2 != -1 )
; 184  : 			{
; 185  : 				LPSKILL pSkill = GetSkill(pSkillProp->dwReSkill2);
; 186  : 				
; 187  : 				if( pSkillProp->dwReSkillLevel2 > pSkill->dwLevel )
; 188  : 					continue;
; 189  : 			}
; 190  : 
; 191  : 			CString str;
; 192  : 			str.Format( prj.GetText( TID_GAME_REAPSKILL ), pSkillProp->szName );
; 193  : 			g_WndMng.PutString( (LPCTSTR)str, NULL, prj.GetTextColor( TID_GAME_REAPSKILL ) );
; 194  : 		}
; 195  : 	}
; 196  : #endif //__CLIENT
; 197  : }		

  00000	c2 04 00	 ret	 4
?PutLvUpSkillName_1@CMover@@QAEXK@Z ENDP		; CMover::PutLvUpSkillName_1
_TEXT	ENDS
PUBLIC	?GetTime@CTime@ATL@@QBE_JXZ			; ATL::CTime::GetTime
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetTime@CTime@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTime@CTime@ATL@@QBE_JXZ PROC NEAR			; ATL::CTime::GetTime, COMDAT
; _this$ = ecx

; 372  : 	return( m_time );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 373  : }

  00005	c3		 ret	 0
?GetTime@CTime@ATL@@QBE_JXZ ENDP			; ATL::CTime::GetTime
_TEXT	ENDS
PUBLIC	?PutLvUpSkillName_2@CMover@@QAEXK@Z		; CMover::PutLvUpSkillName_2
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
;	COMDAT ?PutLvUpSkillName_2@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwSkill$ = 8						; size = 4
?PutLvUpSkillName_2@CMover@@QAEXK@Z PROC NEAR		; CMover::PutLvUpSkillName_2, COMDAT
; _this$ = ecx

; 300  : #ifdef __CLIENT
; 301  : 	LPSKILL pSkill = GetSkill( dwSkill );
; 302  : 	ItemProp* pSkillProp = prj.GetSkillProp( dwSkill );
; 303  : 	
; 304  : 	//  ?
; 305  : 	//        .
; 306  : 	for( int i = 0; i < MAX_SKILL_JOB; i++ )	
; 307  : 	{
; 308  : 		if( m_aJobSkill[i].dwSkill == NULL_ID ) 
; 309  : 			continue;
; 310  : 
; 311  : 		if( IsSkillParent( this, m_aJobSkill[i].dwSkill, dwSkill ) )
; 312  : 		{
; 313  : 			if( IsActive( this, m_aJobSkill[i].dwSkill ) )
; 314  : 			{
; 315  : 				ItemProp* pSkillProp1;
; 316  : 				pSkillProp1 = prj.GetSkillProp( m_aJobSkill[i].dwSkill );
; 317  : 
; 318  : 				CString str;
; 319  : 				str.Format( prj.GetText( TID_GAME_REAPSKILL ), pSkillProp1->szName );
; 320  : 				g_WndMng.PutString( (LPCTSTR)str, NULL, prj.GetTextColor( TID_GAME_REAPSKILL ) );	
; 321  : 			}
; 322  : 		}
; 323  : 	}
; 324  : #endif // CLIENT
; 325  : }

  00000	c2 04 00	 ret	 4
?PutLvUpSkillName_2@CMover@@QAEXK@Z ENDP		; CMover::PutLvUpSkillName_2
_TEXT	ENDS
PUBLIC	?IsBaseJob@CMover@@QAEHXZ			; CMover::IsBaseJob
EXTRN	?prj@@3VCProject@@A:BYTE			; prj
; Function compile flags: /Ogty
;	COMDAT ?IsBaseJob@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsBaseJob@CMover@@QAEHXZ PROC NEAR			; CMover::IsBaseJob, COMDAT
; _this$ = ecx

; 390  : 	return prj.m_aJob[ m_nJob ].dwJobType == JTYPE_BASE;

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8b 14 c5 e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00010	33 c9		 xor	 ecx, ecx
  00012	85 d2		 test	 edx, edx
  00014	0f 94 c1	 sete	 cl
  00017	8b c1		 mov	 eax, ecx

; 391  : }

  00019	c3		 ret	 0
?IsBaseJob@CMover@@QAEHXZ ENDP				; CMover::IsBaseJob
_TEXT	ENDS
PUBLIC	?IsExpert@CMover@@QAEHXZ			; CMover::IsExpert
; Function compile flags: /Ogty
;	COMDAT ?IsExpert@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsExpert@CMover@@QAEHXZ PROC NEAR			; CMover::IsExpert, COMDAT
; _this$ = ecx

; 394  : 	return prj.m_aJob[ m_nJob ].dwJobType == JTYPE_EXPERT;

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8b 14 c5 e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00010	33 c9		 xor	 ecx, ecx
  00012	83 fa 01	 cmp	 edx, 1
  00015	0f 94 c1	 sete	 cl
  00018	8b c1		 mov	 eax, ecx

; 395  : }

  0001a	c3		 ret	 0
?IsExpert@CMover@@QAEHXZ ENDP				; CMover::IsExpert
_TEXT	ENDS
PUBLIC	?IsPro@CMover@@QAEHXZ				; CMover::IsPro
; Function compile flags: /Ogty
;	COMDAT ?IsPro@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsPro@CMover@@QAEHXZ PROC NEAR				; CMover::IsPro, COMDAT
; _this$ = ecx

; 398  : 	return prj.m_aJob[ m_nJob ].dwJobType == JTYPE_PRO;

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8b 14 c5 e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00010	33 c9		 xor	 ecx, ecx
  00012	83 fa 02	 cmp	 edx, 2
  00015	0f 94 c1	 sete	 cl
  00018	8b c1		 mov	 eax, ecx

; 399  : }

  0001a	c3		 ret	 0
?IsPro@CMover@@QAEHXZ ENDP				; CMover::IsPro
_TEXT	ENDS
PUBLIC	?IsMaster@CMover@@QAEHXZ			; CMover::IsMaster
; Function compile flags: /Ogty
;	COMDAT ?IsMaster@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsMaster@CMover@@QAEHXZ PROC NEAR			; CMover::IsMaster, COMDAT
; _this$ = ecx

; 418  : 	return prj.m_aJob[ m_nJob ].dwJobType == 5;//temp JTYPE_MASTER;

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8b 14 c5 e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00010	33 c9		 xor	 ecx, ecx
  00012	83 fa 05	 cmp	 edx, 5
  00015	0f 94 c1	 sete	 cl
  00018	8b c1		 mov	 eax, ecx

; 419  : }

  0001a	c3		 ret	 0
?IsMaster@CMover@@QAEHXZ ENDP				; CMover::IsMaster
_TEXT	ENDS
PUBLIC	?IsHero@CMover@@QAEHXZ				; CMover::IsHero
; Function compile flags: /Ogty
;	COMDAT ?IsHero@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsHero@CMover@@QAEHXZ PROC NEAR			; CMover::IsHero, COMDAT
; _this$ = ecx

; 423  : 	return prj.m_aJob[ m_nJob ].dwJobType == 6;//temp JTYPE_HERO;

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8b 14 c5 e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00010	33 c9		 xor	 ecx, ecx
  00012	83 fa 06	 cmp	 edx, 6
  00015	0f 94 c1	 sete	 cl
  00018	8b c1		 mov	 eax, ecx

; 424  : }

  0001a	c3		 ret	 0
?IsHero@CMover@@QAEHXZ ENDP				; CMover::IsHero
_TEXT	ENDS
PUBLIC	?IsLegendHero@CMover@@QAEHXZ			; CMover::IsLegendHero
; Function compile flags: /Ogty
;	COMDAT ?IsLegendHero@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsLegendHero@CMover@@QAEHXZ PROC NEAR			; CMover::IsLegendHero, COMDAT
; _this$ = ecx

; 430  : 	return prj.m_aJob[ m_nJob ].dwJobType == JTYPE_LEGEND_HERO;

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8b 14 c5 e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00010	33 c9		 xor	 ecx, ecx
  00012	83 fa 07	 cmp	 edx, 7
  00015	0f 94 c1	 sete	 cl
  00018	8b c1		 mov	 eax, ecx

; 431  : }

  0001a	c3		 ret	 0
?IsLegendHero@CMover@@QAEHXZ ENDP			; CMover::IsLegendHero
_TEXT	ENDS
PUBLIC	?IsInteriorityJob@CMover@@QAEHH@Z		; CMover::IsInteriorityJob
; Function compile flags: /Ogty
;	COMDAT ?IsInteriorityJob@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nJob$ = 8						; size = 4
?IsInteriorityJob@CMover@@QAEHH@Z PROC NEAR		; CMover::IsInteriorityJob, COMDAT
; _this$ = ecx

; 436  : 	if( nJob == JOB_VAGRANT || nJob == m_nJob )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nJob$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	0f 84 fb 00 00
	00		 je	 $L275252
  0000c	8b 89 44 06 00
	00		 mov	 ecx, DWORD PTR [ecx+1604]
  00012	3b c1		 cmp	 eax, ecx
  00014	0f 84 ed 00 00
	00		 je	 $L275252

; 438  : 
; 439  : 	if( IsPro() && JOB_VAGRANT < nJob && nJob < MAX_EXPERT )

  0001a	8d 14 c9	 lea	 edx, DWORD PTR [ecx+ecx*8]
  0001d	8b 14 d5 e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[edx*8+10208]
  00024	83 fa 02	 cmp	 edx, 2
  00027	56		 push	 esi
  00028	75 19		 jne	 SHORT $L275254
  0002a	85 c0		 test	 eax, eax
  0002c	7e 15		 jle	 SHORT $L275254
  0002e	83 f8 06	 cmp	 eax, 6
  00031	7d 10		 jge	 SHORT $L275254

; 440  : 	{
; 441  : 		if( nJob * 2 + 4 == m_nJob || nJob * 2 + 5 == m_nJob )

  00033	8d 74 00 04	 lea	 esi, DWORD PTR [eax+eax+4]
  00037	3b f1		 cmp	 esi, ecx
  00039	74 50		 je	 SHORT $L275266
  0003b	8d 74 00 05	 lea	 esi, DWORD PTR [eax+eax+5]
  0003f	3b f1		 cmp	 esi, ecx

; 442  : 		{
; 443  : 			return TRUE;

  00041	74 48		 je	 SHORT $L275266
$L275254:

; 444  : 		}
; 445  : 	}
; 446  : 	if( IsMaster()  )	//   .				

  00043	83 fa 05	 cmp	 edx, 5
  00046	75 2a		 jne	 SHORT $L275262

; 447  : 	{
; 448  : 		if( nJob < MAX_EXPERT )

  00048	83 f8 06	 cmp	 eax, 6
  0004b	7d 19		 jge	 SHORT $L275257

; 449  : 		{
; 450  : 			if( nJob * 2 + 14 == m_nJob || nJob * 2 + 15 == m_nJob )

  0004d	8d 74 00 0e	 lea	 esi, DWORD PTR [eax+eax+14]
  00051	3b f1		 cmp	 esi, ecx
  00053	74 36		 je	 SHORT $L275266
  00055	8d 74 00 0f	 lea	 esi, DWORD PTR [eax+eax+15]
  00059	3b f1		 cmp	 esi, ecx
  0005b	75 15		 jne	 SHORT $L275262

; 464  : 				return TRUE;

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	5e		 pop	 esi

; 505  : }

  00063	c2 04 00	 ret	 4
$L275257:

; 451  : 				return TRUE;
; 452  : 		}
; 453  : 		else if( nJob < MAX_PROFESSIONAL )

  00066	83 f8 10	 cmp	 eax, 16			; 00000010H
  00069	7d 07		 jge	 SHORT $L275262

; 454  : 		{
; 455  : 			if( nJob + 10 == m_nJob )

  0006b	8d 70 0a	 lea	 esi, DWORD PTR [eax+10]
  0006e	3b f1		 cmp	 esi, ecx

; 456  : 				return TRUE;

  00070	74 19		 je	 SHORT $L275266
$L275262:

; 457  : 		}
; 458  : 	}
; 459  : 	if( IsHero()  )	//   .				

  00072	83 fa 06	 cmp	 edx, 6
  00075	75 31		 jne	 SHORT $L275272

; 460  : 	{
; 461  : 		if( nJob < MAX_EXPERT )

  00077	3b c2		 cmp	 eax, edx
  00079	7d 19		 jge	 SHORT $L275264

; 462  : 		{
; 463  : 			if( nJob * 2 + 22 == m_nJob || nJob * 2 + 23 == m_nJob )

  0007b	8d 74 00 16	 lea	 esi, DWORD PTR [eax+eax+22]
  0007f	3b f1		 cmp	 esi, ecx
  00081	74 08		 je	 SHORT $L275266
  00083	8d 74 00 17	 lea	 esi, DWORD PTR [eax+eax+23]
$L282475:

; 473  : 		{
; 474  : 			if( nJob + 8 == m_nJob )

  00087	3b f1		 cmp	 esi, ecx
  00089	75 1d		 jne	 SHORT $L275272
$L275266:

; 464  : 				return TRUE;

  0008b	b8 01 00 00 00	 mov	 eax, 1
  00090	5e		 pop	 esi

; 505  : }

  00091	c2 04 00	 ret	 4
$L275264:

; 465  : 		}
; 466  : 		else if( nJob < MAX_PROFESSIONAL )

  00094	83 f8 10	 cmp	 eax, 16			; 00000010H
  00097	7d 05		 jge	 SHORT $L275268

; 467  : 		{
; 468  : 			if( nJob + 18 == m_nJob )

  00099	8d 70 12	 lea	 esi, DWORD PTR [eax+18]

; 469  : 				return TRUE;

  0009c	eb e9		 jmp	 SHORT $L282475
$L275268:

; 470  : 		}
; 471  : #if __VER >= 14 // __NEW_ITEM_LIMIT_LEVEL
; 472  : 		else if( nJob < MAX_MASTER )	// Hero     .

  0009e	83 f8 18	 cmp	 eax, 24			; 00000018H
  000a1	7d 05		 jge	 SHORT $L275272

; 473  : 		{
; 474  : 			if( nJob + 8 == m_nJob )

  000a3	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 475  : 				return TRUE;

  000a6	eb df		 jmp	 SHORT $L282475
$L275272:

; 476  : 		}
; 477  : #endif // __NEW_ITEM_LIMIT_LEVEL
; 478  : 	}
; 479  : #ifdef __3RD_LEGEND16
; 480  : 	if( IsLegendHero() )

  000a8	83 fa 07	 cmp	 edx, 7
  000ab	75 54		 jne	 SHORT $L275285

; 481  : 	{
; 482  : 		if( nJob < MAX_EXPERT )

  000ad	83 f8 06	 cmp	 eax, 6
  000b0	7d 19		 jge	 SHORT $L275274

; 483  : 		{
; 484  : 			if( nJob * 2 + 30 == m_nJob || nJob * 2 + 31 == m_nJob )

  000b2	8d 54 00 1e	 lea	 edx, DWORD PTR [eax+eax+30]
  000b6	3b d1		 cmp	 edx, ecx
  000b8	74 d1		 je	 SHORT $L275266
  000ba	8d 44 00 1f	 lea	 eax, DWORD PTR [eax+eax+31]
  000be	3b c1		 cmp	 eax, ecx
  000c0	75 3f		 jne	 SHORT $L275285

; 464  : 				return TRUE;

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	5e		 pop	 esi

; 505  : }

  000c8	c2 04 00	 ret	 4
$L275274:

; 485  : 				return TRUE;
; 486  : 		}
; 487  : 		else if( nJob < MAX_PROFESSIONAL )

  000cb	83 f8 10	 cmp	 eax, 16			; 00000010H
  000ce	7d 10		 jge	 SHORT $L275278

; 488  : 		{
; 489  : 			if( nJob + 26 == m_nJob )

  000d0	83 c0 1a	 add	 eax, 26			; 0000001aH
  000d3	3b c1		 cmp	 eax, ecx
  000d5	75 2a		 jne	 SHORT $L275285

; 464  : 				return TRUE;

  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	5e		 pop	 esi

; 505  : }

  000dd	c2 04 00	 ret	 4
$L275278:

; 490  : 				return TRUE;
; 491  : 		}
; 492  : 		else if( nJob < MAX_MASTER )	// Hero     .

  000e0	83 f8 18	 cmp	 eax, 24			; 00000018H
  000e3	7d 10		 jge	 SHORT $L275281

; 493  : 		{
; 494  : 			if( nJob + 16 == m_nJob )

  000e5	83 c0 10	 add	 eax, 16			; 00000010H
  000e8	3b c1		 cmp	 eax, ecx
  000ea	75 15		 jne	 SHORT $L275285

; 464  : 				return TRUE;

  000ec	b8 01 00 00 00	 mov	 eax, 1
  000f1	5e		 pop	 esi

; 505  : }

  000f2	c2 04 00	 ret	 4
$L275281:

; 495  : 				return TRUE;
; 496  : 		}
; 497  : 		else if( nJob < MAX_HERO )

  000f5	83 f8 20	 cmp	 eax, 32			; 00000020H
  000f8	7d 07		 jge	 SHORT $L275285

; 498  : 		{
; 499  : 			if( nJob + 8 == m_nJob )

  000fa	83 c0 08	 add	 eax, 8
  000fd	3b c1		 cmp	 eax, ecx

; 500  : 				return TRUE;

  000ff	74 8a		 je	 SHORT $L275266
$L275285:

; 501  : 		}
; 502  : 	}
; 503  : #endif // __3RD_LEGEND16
; 504  : 	return FALSE;

  00101	33 c0		 xor	 eax, eax
  00103	5e		 pop	 esi

; 505  : }

  00104	c2 04 00	 ret	 4
$L275252:

; 437  : 		return TRUE;

  00107	b8 01 00 00 00	 mov	 eax, 1

; 505  : }

  0010c	c2 04 00	 ret	 4
?IsInteriorityJob@CMover@@QAEHH@Z ENDP			; CMover::IsInteriorityJob
_TEXT	ENDS
PUBLIC	?SetExpert@CMover@@QAEHH@Z			; CMover::SetExpert
; Function compile flags: /Ogty
;	COMDAT ?SetExpert@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nJob$ = 8						; size = 4
?SetExpert@CMover@@QAEHH@Z PROC NEAR			; CMover::SetExpert, COMDAT
; _this$ = ecx

; 511  : 	if( m_nJob == nJob )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nJob$[esp-4]
  00004	39 81 44 06 00
	00		 cmp	 DWORD PTR [ecx+1604], eax
  0000a	75 05		 jne	 SHORT $L275290

; 512  : 		return FALSE;

  0000c	33 c0		 xor	 eax, eax

; 526  : }

  0000e	c2 04 00	 ret	 4
$L275290:

; 513  : 	m_nJob = nJob;
; 514  : 
; 515  : 	int nNum = 3; // 3   . 3      
; 516  : 	LPSKILL lpSkill;
; 517  : 	ItemProp** apSkillProp = prj.m_aJobSkill[ m_nJob ];

  00011	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00014	89 81 44 06 00
	00		 mov	 DWORD PTR [ecx+1604], eax
  0001a	c1 e2 05	 shl	 edx, 5
  0001d	56		 push	 esi

; 518  : 	int nJobNum = prj.m_aJobSkillNum[ m_nJob ];

  0001e	8b 34 85 fc 26
	00 00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A[eax*4+9980]
  00025	81 c2 fc 0d 00
	00		 add	 edx, OFFSET FLAT:?prj@@3VCProject@@A+3580

; 519  : 	for( int i = 0; i < nJobNum; i++ )

  0002b	33 c0		 xor	 eax, eax
  0002d	85 f6		 test	 esi, esi
  0002f	7e 17		 jle	 SHORT $L275298
  00031	81 c1 84 03 00
	00		 add	 ecx, 900		; 00000384H
  00037	57		 push	 edi
$L275296:

; 520  : 	{
; 521  : 		ItemProp* pSkillProp = apSkillProp[ i ];

  00038	8b 3c 82	 mov	 edi, DWORD PTR [edx+eax*4]

; 522  : 		lpSkill = &m_aJobSkill[ nNum++ ];
; 523  : 		lpSkill->dwSkill = pSkillProp->dwID;

  0003b	8b 3f		 mov	 edi, DWORD PTR [edi]
  0003d	89 39		 mov	 DWORD PTR [ecx], edi
  0003f	40		 inc	 eax
  00040	83 c1 08	 add	 ecx, 8
  00043	3b c6		 cmp	 eax, esi
  00045	7c f1		 jl	 SHORT $L275296
  00047	5f		 pop	 edi
$L275298:

; 524  : 	}
; 525  : 	return TRUE;

  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	5e		 pop	 esi

; 526  : }

  0004e	c2 04 00	 ret	 4
?SetExpert@CMover@@QAEHH@Z ENDP				; CMover::SetExpert
_TEXT	ENDS
PUBLIC	?GetJob@CMover@@QAEHXZ				; CMover::GetJob
; Function compile flags: /Ogty
;	COMDAT ?GetJob@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetJob@CMover@@QAEHXZ PROC NEAR			; CMover::GetJob, COMDAT
; _this$ = ecx

; 530  : 	return m_nJob; 

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]

; 531  : }

  00006	c3		 ret	 0
?GetJob@CMover@@QAEHXZ ENDP				; CMover::GetJob
_TEXT	ENDS
PUBLIC	?GetRemainGP@CMover@@QAEHXZ			; CMover::GetRemainGP
; Function compile flags: /Ogty
;	COMDAT ?GetRemainGP@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetRemainGP@CMover@@QAEHXZ PROC NEAR			; CMover::GetRemainGP, COMDAT
; _this$ = ecx

; 545  : 	return m_nRemainGP;

  00000	8b 81 0c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1548]

; 546  : }

  00006	c3		 ret	 0
?GetRemainGP@CMover@@QAEHXZ ENDP			; CMover::GetRemainGP
_TEXT	ENDS
PUBLIC	?IncStrLevel@CMover@@QAEHXZ			; CMover::IncStrLevel
; Function compile flags: /Ogty
;	COMDAT ?IncStrLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?IncStrLevel@CMover@@QAEHXZ PROC NEAR			; CMover::IncStrLevel, COMDAT
; _this$ = ecx

; 1008 : #ifdef __S_ADD_RESTATE
; 1009 : 	if( m_nRemainGP > 0 )

  00000	8b 81 0c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1548]
  00006	85 c0		 test	 eax, eax
  00008	7e 1a		 jle	 SHORT $L275496

; 1010 : 	{
; 1011 : 		m_nStr += 1;

  0000a	8b 91 d0 05 00
	00		 mov	 edx, DWORD PTR [ecx+1488]
  00010	42		 inc	 edx

; 1012 : 		m_nRemainGP -= 1;

  00011	48		 dec	 eax
  00012	89 81 0c 06 00
	00		 mov	 DWORD PTR [ecx+1548], eax
  00018	89 91 d0 05 00
	00		 mov	 DWORD PTR [ecx+1488], edx

; 1013 : 		return TRUE;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 1029 : }

  00023	c3		 ret	 0
$L275496:

; 1014 : 	}
; 1015 : #else // __S_ADD_RESTATE
; 1016 : 	LPJOBABILITY pJobAbillity;
; 1017 : 	if( IsExpert() )
; 1018 : 		pJobAbillity = &prj.m_aJobAbillity[ GetJob() ];
; 1019 : 	else
; 1020 : 		pJobAbillity = &prj.m_aJobAbillity[ JOB_VAGRANT ];
; 1021 : 	if( (int)m_nRemainGP >= (int)pJobAbillity->dwStr )		//  (int)      .
; 1022 : 	{
; 1023 : 		m_nStr += pJobAbillity->dwStrAdd;
; 1024 : 		m_nRemainGP -= pJobAbillity->dwStr;
; 1025 : 		return TRUE;
; 1026 : 	}
; 1027 : #endif // __S_ADD_RESTATE
; 1028 : 	return FALSE;

  00024	33 c0		 xor	 eax, eax

; 1029 : }

  00026	c3		 ret	 0
?IncStrLevel@CMover@@QAEHXZ ENDP			; CMover::IncStrLevel
_TEXT	ENDS
PUBLIC	?IncStaLevel@CMover@@QAEHXZ			; CMover::IncStaLevel
; Function compile flags: /Ogty
;	COMDAT ?IncStaLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?IncStaLevel@CMover@@QAEHXZ PROC NEAR			; CMover::IncStaLevel, COMDAT
; _this$ = ecx

; 1032 : #ifdef __S_ADD_RESTATE
; 1033 : 	if( m_nRemainGP > 0 )

  00000	8b 81 0c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1548]
  00006	85 c0		 test	 eax, eax
  00008	7e 1a		 jle	 SHORT $L275500

; 1034 : 	{
; 1035 : 		m_nSta += 1;

  0000a	8b 91 d4 05 00
	00		 mov	 edx, DWORD PTR [ecx+1492]
  00010	42		 inc	 edx

; 1036 : 		m_nRemainGP -= 1;

  00011	48		 dec	 eax
  00012	89 81 0c 06 00
	00		 mov	 DWORD PTR [ecx+1548], eax
  00018	89 91 d4 05 00
	00		 mov	 DWORD PTR [ecx+1492], edx

; 1037 : 		return TRUE;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 1053 : }

  00023	c3		 ret	 0
$L275500:

; 1038 : 	}
; 1039 : #else // __S_ADD_RESTATE
; 1040 : 	LPJOBABILITY pJobAbillity;
; 1041 : 	if( IsExpert() )
; 1042 : 		pJobAbillity = &prj.m_aJobAbillity[ GetJob() ];
; 1043 : 	else
; 1044 : 		pJobAbillity = &prj.m_aJobAbillity[ JOB_VAGRANT ];
; 1045 : 	if( (int)m_nRemainGP >= (int)pJobAbillity->dwSta )
; 1046 : 	{
; 1047 : 		m_nSta += pJobAbillity->dwStaAdd;
; 1048 : 		m_nRemainGP -= pJobAbillity->dwSta;
; 1049 : 		return TRUE;
; 1050 : 	}
; 1051 : #endif // __S_ADD_RESTATE
; 1052 : 	return FALSE;

  00024	33 c0		 xor	 eax, eax

; 1053 : }

  00026	c3		 ret	 0
?IncStaLevel@CMover@@QAEHXZ ENDP			; CMover::IncStaLevel
_TEXT	ENDS
PUBLIC	?IncDexLevel@CMover@@QAEHXZ			; CMover::IncDexLevel
; Function compile flags: /Ogty
;	COMDAT ?IncDexLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?IncDexLevel@CMover@@QAEHXZ PROC NEAR			; CMover::IncDexLevel, COMDAT
; _this$ = ecx

; 1056 : #ifdef __S_ADD_RESTATE
; 1057 : 	if( m_nRemainGP > 0 )

  00000	8b 81 0c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1548]
  00006	85 c0		 test	 eax, eax
  00008	7e 1a		 jle	 SHORT $L275504

; 1058 : 	{
; 1059 : 		m_nDex += 1;

  0000a	8b 91 d8 05 00
	00		 mov	 edx, DWORD PTR [ecx+1496]
  00010	42		 inc	 edx

; 1060 : 		m_nRemainGP -= 1;

  00011	48		 dec	 eax
  00012	89 81 0c 06 00
	00		 mov	 DWORD PTR [ecx+1548], eax
  00018	89 91 d8 05 00
	00		 mov	 DWORD PTR [ecx+1496], edx

; 1061 : 		return TRUE;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 1077 : }

  00023	c3		 ret	 0
$L275504:

; 1062 : 	}
; 1063 : #else // __S_ADD_RESTATE
; 1064 : 	LPJOBABILITY pJobAbillity;
; 1065 : 	if( IsExpert() )
; 1066 : 		pJobAbillity = &prj.m_aJobAbillity[ GetJob() ];
; 1067 : 	else
; 1068 : 		pJobAbillity = &prj.m_aJobAbillity[ JOB_VAGRANT ];
; 1069 : 	if( (int)m_nRemainGP >= (int)pJobAbillity->dwDex )
; 1070 : 	{
; 1071 : 		m_nDex += pJobAbillity->dwDexAdd;
; 1072 : 		m_nRemainGP -= pJobAbillity->dwDex;
; 1073 : 		return TRUE;
; 1074 : 	}
; 1075 : #endif // __S_ADD_RESTATE
; 1076 : 	return FALSE;

  00024	33 c0		 xor	 eax, eax

; 1077 : }

  00026	c3		 ret	 0
?IncDexLevel@CMover@@QAEHXZ ENDP			; CMover::IncDexLevel
_TEXT	ENDS
PUBLIC	?IncIntLevel@CMover@@QAEHXZ			; CMover::IncIntLevel
; Function compile flags: /Ogty
;	COMDAT ?IncIntLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?IncIntLevel@CMover@@QAEHXZ PROC NEAR			; CMover::IncIntLevel, COMDAT
; _this$ = ecx

; 1080 : #ifdef __S_ADD_RESTATE
; 1081 : 	if( m_nRemainGP > 0 )

  00000	8b 81 0c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1548]
  00006	85 c0		 test	 eax, eax
  00008	7e 1a		 jle	 SHORT $L275508

; 1082 : 	{
; 1083 : 		m_nInt += 1;

  0000a	8b 91 dc 05 00
	00		 mov	 edx, DWORD PTR [ecx+1500]
  00010	42		 inc	 edx

; 1084 : 		m_nRemainGP -= 1;

  00011	48		 dec	 eax
  00012	89 81 0c 06 00
	00		 mov	 DWORD PTR [ecx+1548], eax
  00018	89 91 dc 05 00
	00		 mov	 DWORD PTR [ecx+1500], edx

; 1085 : 		return TRUE;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 1101 : }

  00023	c3		 ret	 0
$L275508:

; 1086 : 	}
; 1087 : #else // __S_ADD_RESTATE
; 1088 : 	LPJOBABILITY pJobAbillity;
; 1089 : 	if( IsExpert() )
; 1090 : 		pJobAbillity = &prj.m_aJobAbillity[ GetJob() ];
; 1091 : 	else
; 1092 : 		pJobAbillity = &prj.m_aJobAbillity[ JOB_VAGRANT ];
; 1093 : 	if( (int)m_nRemainGP >= (int)pJobAbillity->dwInt )
; 1094 : 	{
; 1095 : 		m_nInt += pJobAbillity->dwIntAdd;
; 1096 : 		m_nRemainGP -= pJobAbillity->dwInt;
; 1097 : 		return TRUE;
; 1098 : 	}
; 1099 : #endif // __S_ADD_RESTATE
; 1100 : 	return FALSE;

  00024	33 c0		 xor	 eax, eax

; 1101 : }

  00026	c3		 ret	 0
?IncIntLevel@CMover@@QAEHXZ ENDP			; CMover::IncIntLevel
_TEXT	ENDS
PUBLIC	?DecExperience@CMover@@QAEH_JHH@Z		; CMover::DecExperience
EXTRN	?g_dpDBClient@@3VCDPDatabaseClient@@A:BYTE	; g_dpDBClient
EXTRN	?SendLogLevelUp@CDPDatabaseClient@@QAEXPAVCMover@@H@Z:NEAR ; CDPDatabaseClient::SendLogLevelUp
; Function compile flags: /Ogty
;	COMDAT ?DecExperience@CMover@@QAEH_JHH@Z
_TEXT	SEGMENT
_nExp$ = 8						; size = 8
_bExp2Clear$ = 16					; size = 4
_bLvDown$ = 20						; size = 4
?DecExperience@CMover@@QAEH_JHH@Z PROC NEAR		; CMover::DecExperience, COMDAT
; _this$ = ecx

; 1610 : 	if( nExp < 0 )	//     .

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _nExp$[esp]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _nExp$[esp]
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	3b d7		 cmp	 edx, edi
  0000e	7f 06		 jg	 SHORT $L275628
  00010	7c 10		 jl	 SHORT $L282503
  00012	3b f7		 cmp	 esi, edi

; 1611 : 		return FALSE;

  00014	72 0c		 jb	 SHORT $L282503
$L275628:

; 1612 : 	
; 1613 : 	int nPrevLevel	= m_nLevel - 1;

  00016	8b 81 e0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1504]
  0001c	48		 dec	 eax

; 1614 : 	if( nPrevLevel < 1 )	//  1   .

  0001d	83 f8 01	 cmp	 eax, 1
  00020	7d 07		 jge	 SHORT $L275630
$L282503:
  00022	5f		 pop	 edi

; 1615 : 		return FALSE;

  00023	33 c0		 xor	 eax, eax
  00025	5e		 pop	 esi

; 1642 : }

  00026	c2 10 00	 ret	 16			; 00000010H
$L275630:
  00029	53		 push	 ebx

; 1616 : 
; 1617 : 	m_nExp1		-= nExp;	// nExp  . Exp2 0%.

  0002a	8b 99 e8 05 00
	00		 mov	 ebx, DWORD PTR [ecx+1512]
  00030	2b de		 sub	 ebx, esi
  00032	19 91 ec 05 00
	00		 sbb	 DWORD PTR [ecx+1516], edx

; 1618 : 
; 1619 : #if __VER < 8     // 8 
; 1620 : 	m_nSkillExp	-= nExp;
; 1621 : #endif	// __VER >= 8  
; 1622 : 
; 1623 : 	if( m_nExp1 < 0 )

  00038	8b 91 ec 05 00
	00		 mov	 edx, DWORD PTR [ecx+1516]
  0003e	3b d7		 cmp	 edx, edi
  00040	89 99 e8 05 00
	00		 mov	 DWORD PTR [ecx+1512], ebx
  00046	8b f3		 mov	 esi, ebx
  00048	7f 55		 jg	 SHORT $L275634
  0004a	7c 04		 jl	 SHORT $L282504
  0004c	3b f7		 cmp	 esi, edi
  0004e	73 4f		 jae	 SHORT $L275634
$L282504:

; 1624 : 	{
; 1625 : 		if( bLvDown )	//   .

  00050	39 7c 24 1c	 cmp	 DWORD PTR _bLvDown$[esp+8], edi
  00054	74 30		 je	 SHORT $L275632

; 1626 : 		{
; 1627 : #if __VER >= 8  
; 1628 : 			--m_nLevel;

  00056	89 81 e0 05 00
	00		 mov	 DWORD PTR [ecx+1504], eax

; 1629 : 			m_nExp1 = (EXPINTEGER)(prj.m_aExpCharacter[m_nLevel+1].nExp1 + m_nExp1 );

  0005c	c1 e0 05	 shl	 eax, 5
  0005f	8b b8 10 50 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A[eax+20496]
  00065	8b 80 14 50 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[eax+20500]
  0006b	03 fe		 add	 edi, esi
  0006d	5b		 pop	 ebx
  0006e	13 c2		 adc	 eax, edx
  00070	89 b9 e8 05 00
	00		 mov	 DWORD PTR [ecx+1512], edi
  00076	5f		 pop	 edi
  00077	89 81 ec 05 00
	00		 mov	 DWORD PTR [ecx+1516], eax

; 1630 : #endif //  __VER >= 8  
; 1631 : 			return TRUE;	//   TRUE

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	5e		 pop	 esi

; 1642 : }

  00083	c2 10 00	 ret	 16			; 00000010H
$L275632:

; 1632 : 		}
; 1633 : 		else
; 1634 : 		{
; 1635 : 			m_nExp1		= 0;
; 1636 : #ifdef __WORLDSERVER
; 1637 : 			g_dpDBClient.SendLogLevelUp( this, 7 );

  00086	6a 07		 push	 7
  00088	89 b9 e8 05 00
	00		 mov	 DWORD PTR [ecx+1512], edi
  0008e	89 b9 ec 05 00
	00		 mov	 DWORD PTR [ecx+1516], edi
  00094	51		 push	 ecx
  00095	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0009a	e8 00 00 00 00	 call	 ?SendLogLevelUp@CDPDatabaseClient@@QAEXPAVCMover@@H@Z ; CDPDatabaseClient::SendLogLevelUp
$L275634:
  0009f	5b		 pop	 ebx
  000a0	5f		 pop	 edi

; 1638 : #endif // __WORLDSERVER
; 1639 : 		}
; 1640 : 	}
; 1641 : 	return FALSE;

  000a1	33 c0		 xor	 eax, eax
  000a3	5e		 pop	 esi

; 1642 : }

  000a4	c2 10 00	 ret	 16			; 00000010H
?DecExperience@CMover@@QAEH_JHH@Z ENDP			; CMover::DecExperience
_TEXT	ENDS
PUBLIC	?AddChangeJob@CMover@@QAEHH@Z			; CMover::AddChangeJob
EXTRN	?CheckHonorStat@CMover@@QAEXXZ:NEAR		; CMover::CheckHonorStat
EXTRN	?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z:NEAR ; CUserMng::AddHonorTitleChange
EXTRN	?AddHonorListAck@CUser@@QAEXXZ:NEAR		; CUser::AddHonorListAck
EXTRN	?g_UserMng@@3VCUserMng@@A:BYTE			; g_UserMng
; Function compile flags: /Ogty
;	COMDAT ?AddChangeJob@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nJob$ = 8						; size = 4
?AddChangeJob@CMover@@QAEHH@Z PROC NEAR			; CMover::AddChangeJob, COMDAT
; _this$ = ecx

; 1723 : 	BOOL	bResult = FALSE;
; 1724 : 	LPSKILL lpSkill;
; 1725 : 	if( MAX_JOBBASE <= nJob && nJob < MAX_EXPERT ) // 1  ~~ ^^;;;;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nJob$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	83 f8 01	 cmp	 eax, 1
  0000c	57		 push	 edi
  0000d	8b d9		 mov	 ebx, ecx
  0000f	7c 44		 jl	 SHORT $L275680
  00011	83 f8 06	 cmp	 eax, 6
  00014	7d 44		 jge	 SHORT $L282522

; 1728 : 		
; 1729 : 		ItemProp** apSkillProp = prj.m_aJobSkill[ m_nJob ];

  00016	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00019	c1 e1 05	 shl	 ecx, 5
  0001c	89 83 44 06 00
	00		 mov	 DWORD PTR [ebx+1604], eax

; 1730 : 		int nJobNum = prj.m_aJobSkillNum[ m_nJob ];

  00022	8b 34 85 fc 26
	00 00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A[eax*4+9980]
  00029	81 c1 fc 0d 00
	00		 add	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+3580

; 1731 : 		for( int i = 0; i < nJobNum; i++ )

  0002f	33 d2		 xor	 edx, edx
  00031	85 f6		 test	 esi, esi
  00033	7e 1b		 jle	 SHORT $L275686

; 1726 : 	{
; 1727 : 		m_nJob = nJob;

  00035	8d bb 84 03 00
	00		 lea	 edi, DWORD PTR [ebx+900]
  0003b	eb 03 8d 49 00	 npad	 5
$L275684:

; 1732 : 		{
; 1733 : 			ItemProp* pSkillProp = apSkillProp[ i ];

  00040	8b 2c 91	 mov	 ebp, DWORD PTR [ecx+edx*4]

; 1734 : 			lpSkill = &m_aJobSkill[ i + MAX_JOB_SKILL ];
; 1735 : 			lpSkill->dwSkill = pSkillProp->dwID;

  00043	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
  00046	89 2f		 mov	 DWORD PTR [edi], ebp
  00048	42		 inc	 edx
  00049	83 c7 08	 add	 edi, 8
  0004c	3b d6		 cmp	 edx, esi
  0004e	7c f0		 jl	 SHORT $L275684
$L275686:

; 1736 : 		}
; 1737 : 		bResult = TRUE;

  00050	be 01 00 00 00	 mov	 esi, 1
$L275680:

; 1738 : 	}
; 1739 : 	if( MAX_EXPERT <= nJob && nJob < MAX_PROFESSIONAL ) // 2  ~~ ^^;;;;

  00055	83 f8 06	 cmp	 eax, 6
  00058	7c 3f		 jl	 SHORT $L275688
$L282522:
  0005a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005d	7d 3f		 jge	 SHORT $L282521

; 1742 : 		
; 1743 : 		ItemProp** apSkillProp = prj.m_aJobSkill[ m_nJob ];

  0005f	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00062	c1 e1 05	 shl	 ecx, 5
  00065	89 83 44 06 00
	00		 mov	 DWORD PTR [ebx+1604], eax

; 1744 : 		int nJobNum = prj.m_aJobSkillNum[ m_nJob ];

  0006b	8b 34 85 fc 26
	00 00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A[eax*4+9980]
  00072	81 c1 fc 0d 00
	00		 add	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+3580

; 1745 : 		for( int i = 0; i < nJobNum; i++ )

  00078	33 d2		 xor	 edx, edx
  0007a	85 f6		 test	 esi, esi
  0007c	7e 16		 jle	 SHORT $L275694

; 1740 : 	{
; 1741 : 		m_nJob = nJob;

  0007e	8d bb 24 04 00
	00		 lea	 edi, DWORD PTR [ebx+1060]
$L275692:

; 1746 : 		{
; 1747 : 			ItemProp* pSkillProp = apSkillProp[ i ];

  00084	8b 2c 91	 mov	 ebp, DWORD PTR [ecx+edx*4]

; 1748 : 			lpSkill = &m_aJobSkill[ i + MAX_JOB_SKILL + MAX_EXPERT_SKILL ];
; 1749 : 			lpSkill->dwSkill = pSkillProp->dwID;

  00087	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
  0008a	89 2f		 mov	 DWORD PTR [edi], ebp
  0008c	42		 inc	 edx
  0008d	83 c7 08	 add	 edi, 8
  00090	3b d6		 cmp	 edx, esi
  00092	7c f0		 jl	 SHORT $L275692
$L275694:

; 1750 : 		}
; 1751 : 		bResult = TRUE;

  00094	be 01 00 00 00	 mov	 esi, 1
$L275688:

; 1752 : 	}
; 1753 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1754 : 	if( MAX_PROFESSIONAL <= nJob && nJob < MAX_MASTER ) //  ~~ ^^;;;;

  00099	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009c	7c 46		 jl	 SHORT $L275696
$L282521:
  0009e	83 f8 18	 cmp	 eax, 24			; 00000018H
  000a1	7d 46		 jge	 SHORT $L282520

; 1757 : 		
; 1758 : 		ItemProp** apSkillProp = prj.m_aJobSkill[ m_nJob ];

  000a3	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  000a6	c1 e2 05	 shl	 edx, 5
  000a9	89 83 44 06 00
	00		 mov	 DWORD PTR [ebx+1604], eax

; 1759 : 		int nJobNum = prj.m_aJobSkillNum[ m_nJob ];

  000af	8b 3c 85 fc 26
	00 00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A[eax*4+9980]
  000b6	81 c2 fc 0d 00
	00		 add	 edx, OFFSET FLAT:?prj@@3VCProject@@A+3580

; 1760 : 		for( int i = 0; i < nJobNum; i++ )

  000bc	33 c9		 xor	 ecx, ecx
  000be	85 ff		 test	 edi, edi
  000c0	7e 1d		 jle	 SHORT $L275702

; 1755 : 	{
; 1756 : 		m_nJob = nJob;

  000c2	8d b3 c4 04 00
	00		 lea	 esi, DWORD PTR [ebx+1220]
$L275700:

; 1761 : 		{
; 1762 : 			ItemProp* pSkillProp = apSkillProp[ i ];

  000c8	8b 2c 8a	 mov	 ebp, DWORD PTR [edx+ecx*4]

; 1763 : 			lpSkill = &m_aJobSkill[ i + MAX_JOB_SKILL + MAX_EXPERT_SKILL + MAX_PRO_SKILL];
; 1764 : 			lpSkill->dwSkill = pSkillProp->dwID;

  000cb	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
  000ce	89 2e		 mov	 DWORD PTR [esi], ebp

; 1765 : 			lpSkill->dwLevel = 1;	//master 1 .

  000d0	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1
  000d7	41		 inc	 ecx
  000d8	83 c6 08	 add	 esi, 8
  000db	3b cf		 cmp	 ecx, edi
  000dd	7c e9		 jl	 SHORT $L275700
$L275702:

; 1766 : 		}
; 1767 : 		bResult = TRUE;

  000df	be 01 00 00 00	 mov	 esi, 1
$L275696:

; 1768 : 	}
; 1769 : 	
; 1770 : 	if( MAX_MASTER <= nJob && nJob < MAX_HERO ) //  ~~ ^^;;;;

  000e4	83 f8 18	 cmp	 eax, 24			; 00000018H
  000e7	7c 3f		 jl	 SHORT $L275704
$L282520:
  000e9	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ec	7d 3f		 jge	 SHORT $L282519

; 1773 : 		
; 1774 : 		ItemProp** apSkillProp = prj.m_aJobSkill[ m_nJob ];

  000ee	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000f1	c1 e1 05	 shl	 ecx, 5
  000f4	89 83 44 06 00
	00		 mov	 DWORD PTR [ebx+1604], eax

; 1775 : 		int nJobNum = prj.m_aJobSkillNum[ m_nJob ];

  000fa	8b 34 85 fc 26
	00 00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A[eax*4+9980]
  00101	81 c1 fc 0d 00
	00		 add	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+3580

; 1776 : 		for( int i = 0; i < nJobNum; i++ )

  00107	33 d2		 xor	 edx, edx
  00109	85 f6		 test	 esi, esi
  0010b	7e 16		 jle	 SHORT $L275710

; 1771 : 	{
; 1772 : 		m_nJob = nJob;

  0010d	8d bb cc 04 00
	00		 lea	 edi, DWORD PTR [ebx+1228]
$L275708:

; 1777 : 		{
; 1778 : 			ItemProp* pSkillProp = apSkillProp[ i ];

  00113	8b 2c 91	 mov	 ebp, DWORD PTR [ecx+edx*4]

; 1779 : 			lpSkill = &m_aJobSkill[ i + MAX_JOB_SKILL + MAX_EXPERT_SKILL + MAX_PRO_SKILL + MAX_MASTER_SKILL ];
; 1780 : 			lpSkill->dwSkill = pSkillProp->dwID;

  00116	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]
  00119	89 2f		 mov	 DWORD PTR [edi], ebp
  0011b	42		 inc	 edx
  0011c	83 c7 08	 add	 edi, 8
  0011f	3b d6		 cmp	 edx, esi
  00121	7c f0		 jl	 SHORT $L275708
$L275710:

; 1781 : 		}
; 1782 : 		bResult = TRUE;

  00123	be 01 00 00 00	 mov	 esi, 1
$L275704:

; 1783 : 	}
; 1784 : #ifdef __3RD_LEGEND16
; 1785 : 	if( MAX_HERO <= nJob && nJob < MAX_LEGEND_HERO )

  00128	83 f8 20	 cmp	 eax, 32			; 00000020H
  0012b	7c 3e		 jl	 SHORT $L275712
$L282519:
  0012d	83 f8 28	 cmp	 eax, 40			; 00000028H
  00130	7d 39		 jge	 SHORT $L275712

; 1788 : 		
; 1789 : 		ItemProp** apSkillProp = prj.m_aJobSkill[ m_nJob ];

  00132	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00135	c1 e1 05	 shl	 ecx, 5
  00138	89 83 44 06 00
	00		 mov	 DWORD PTR [ebx+1604], eax

; 1790 : 		int nJobNum = prj.m_aJobSkillNum[ m_nJob ];

  0013e	8b 04 85 fc 26
	00 00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[eax*4+9980]
  00145	81 c1 fc 0d 00
	00		 add	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+3580

; 1791 : 		for( int i = 0; i < nJobNum; i++ )

  0014b	33 d2		 xor	 edx, edx
  0014d	85 c0		 test	 eax, eax
  0014f	7e 15		 jle	 SHORT $L275718

; 1786 : 	{
; 1787 : 		m_nJob = nJob;

  00151	8d b3 d4 04 00
	00		 lea	 esi, DWORD PTR [ebx+1236]
$L275716:

; 1792 : 		{
; 1793 : 			ItemProp* pSkillProp = apSkillProp[ i ];

  00157	8b 3c 91	 mov	 edi, DWORD PTR [ecx+edx*4]

; 1794 : 			lpSkill = &m_aJobSkill[ i + MAX_JOB_SKILL + MAX_EXPERT_SKILL + MAX_PRO_SKILL + MAX_MASTER_SKILL + MAX_HERO_SKILL ];
; 1795 : 			lpSkill->dwSkill = pSkillProp->dwID;

  0015a	8b 3f		 mov	 edi, DWORD PTR [edi]
  0015c	89 3e		 mov	 DWORD PTR [esi], edi
  0015e	42		 inc	 edx
  0015f	83 c6 08	 add	 esi, 8
  00162	3b d0		 cmp	 edx, eax
  00164	7c f1		 jl	 SHORT $L275716
$L275718:

; 1796 : 		}
; 1797 : 		bResult = TRUE;

  00166	be 01 00 00 00	 mov	 esi, 1
$L275712:

; 1798 : 	}
; 1799 : #endif // __3RD_LEGEND16
; 1800 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1801 : 
; 1802 : 
; 1803 : #ifdef __WORLDSERVER
; 1804 : #ifdef __S_NEW_SKILL_2
; 1805 : 	g_dpDBClient.SaveSkill( (CUser*)this );
; 1806 : #endif // __S_NEW_SKILL_2
; 1807 : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 1808 : 	((CUser*)this)->CheckHonorStat();

  0016b	8b cb		 mov	 ecx, ebx
  0016d	e8 00 00 00 00	 call	 ?CheckHonorStat@CMover@@QAEXXZ ; CMover::CheckHonorStat

; 1809 : 	((CUser*)this)->AddHonorListAck();

  00172	8b cb		 mov	 ecx, ebx
  00174	e8 00 00 00 00	 call	 ?AddHonorListAck@CUser@@QAEXXZ ; CUser::AddHonorListAck

; 1810 : 	g_UserMng.AddHonorTitleChange( this, m_nHonor);

  00179	8b 83 04 09 00
	00		 mov	 eax, DWORD PTR [ebx+2308]
  0017f	50		 push	 eax
  00180	53		 push	 ebx
  00181	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00186	e8 00 00 00 00	 call	 ?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddHonorTitleChange
  0018b	5f		 pop	 edi

; 1811 : #endif	// __HONORABLE_TITLE			// 
; 1812 : #endif // __WORLDSERVER
; 1813 : 	return bResult;

  0018c	8b c6		 mov	 eax, esi
  0018e	5e		 pop	 esi
  0018f	5d		 pop	 ebp
  00190	5b		 pop	 ebx

; 1814 : }

  00191	c2 04 00	 ret	 4
?AddChangeJob@CMover@@QAEHH@Z ENDP			; CMover::AddChangeJob
_TEXT	ENDS
PUBLIC	?RemoveBuffOne@CMover@@QAEXK@Z			; CMover::RemoveBuffOne
EXTRN	?RemoveBuffs@CBuffMgr@@QAEXKK@Z:NEAR		; CBuffMgr::RemoveBuffs
; Function compile flags: /Ogty
;	COMDAT ?RemoveBuffOne@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwSkill$ = 8						; size = 4
?RemoveBuffOne@CMover@@QAEXK@Z PROC NEAR		; CMover::RemoveBuffOne, COMDAT
; _this$ = ecx

; 2335 : #ifdef __BUFF_1107
; 2336 : 	m_buffs.RemoveBuffs( RBF_ONCE | RBF_GOODSKILL, 0 );

  00000	6a 00		 push	 0
  00002	68 04 00 00 10	 push	 268435460		; 10000004H
  00007	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  0000d	e8 00 00 00 00	 call	 ?RemoveBuffs@CBuffMgr@@QAEXKK@Z ; CBuffMgr::RemoveBuffs

; 2337 : #else	// __BUFF_1107
; 2338 : 	m_SkillState.RemoveOneSkillBuff();		//    .
; 2339 : #endif	// __BUFF_1107
; 2340 : }	

  00012	c2 04 00	 ret	 4
?RemoveBuffOne@CMover@@QAEXK@Z ENDP			; CMover::RemoveBuffOne
_TEXT	ENDS
PUBLIC	?RemoveBuffAll@CMover@@QAEXXZ			; CMover::RemoveBuffAll
; Function compile flags: /Ogty
;	COMDAT ?RemoveBuffAll@CMover@@QAEXXZ
_TEXT	SEGMENT
?RemoveBuffAll@CMover@@QAEXXZ PROC NEAR			; CMover::RemoveBuffAll, COMDAT
; _this$ = ecx

; 2344 : #ifdef __BUFF_1107
; 2345 : 	m_buffs.RemoveBuffs( RBF_GOODSKILL, 0 );

  00000	6a 00		 push	 0
  00002	6a 04		 push	 4
  00004	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  0000a	e8 00 00 00 00	 call	 ?RemoveBuffs@CBuffMgr@@QAEXKK@Z ; CBuffMgr::RemoveBuffs

; 2346 : #else	// __BUFF_1107
; 2347 : 	m_SkillState.RemoveAllSkillBuff();		//     .
; 2348 : #endif	// __BUFF_1107
; 2349 : }

  0000f	c3		 ret	 0
?RemoveBuffAll@CMover@@QAEXXZ ENDP			; CMover::RemoveBuffAll
_TEXT	ENDS
PUBLIC	?ResetDestParamSync@CMover@@QAEXHHHH@Z		; CMover::ResetDestParamSync
; Function compile flags: /Ogty
;	COMDAT ?ResetDestParamSync@CMover@@QAEXHHHH@Z
_TEXT	SEGMENT
_nDstParameter$ = 8					; size = 4
_nAdjParameterValue$ = 12				; size = 4
_nParameterValue$ = 16					; size = 4
_fSend$ = 20						; size = 4
?ResetDestParamSync@CMover@@QAEXHHHH@Z PROC NEAR	; CMover::ResetDestParamSync, COMDAT
; _this$ = ecx

; 2861 : #ifdef __CLIENT
; 2862 : 	if( nDstParameter >= MAX_ADJPARAMARY || nDstParameter < 0 )
; 2863 : 	{
; 2864 : //		Error( "ResetDestParam %s :   nDstParam : %d", m_szName, nDstParameter );
; 2865 : 		return;
; 2866 : 	}
; 2867 : 
; 2868 : 	switch( nDstParameter )
; 2869 : 	{
; 2870 : 		case DST_SPEED:
; 2871 : 			{
; 2872 : 				m_adjParamAry[nDstParameter] = nParameterValue;
; 2873 : 				if( nAdjParameterValue == 0 && m_chgParamAry[nDstParameter] != 0x7FFFFFFF && m_chgParamAry[nDstParameter] > 0 )
; 2874 : 				{
; 2875 : 					if( --m_chgParamAry[nDstParameter] == 0 )
; 2876 : 						m_chgParamAry[nDstParameter]		= 0x7FFFFFFF;
; 2877 : 				}
; 2878 : 			}
; 2879 : 			break;
; 2880 : 	}
; 2881 : #endif	// __CLIENT
; 2882 : }

  00000	c2 10 00	 ret	 16			; 00000010H
?ResetDestParamSync@CMover@@QAEXHHHH@Z ENDP		; CMover::ResetDestParamSync
_TEXT	ENDS
PUBLIC	?GetAdjParam@CMover@@QAEHH@Z			; CMover::GetAdjParam
; Function compile flags: /Ogty
;	COMDAT ?GetAdjParam@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nDestParameter$ = 8					; size = 4
?GetAdjParam@CMover@@QAEHH@Z PROC NEAR			; CMover::GetAdjParam, COMDAT
; _this$ = ecx

; 2888 : 	if( nDestParameter < MAX_ADJPARAMARY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nDestParameter$[esp-4]
  00004	83 f8 75	 cmp	 eax, 117		; 00000075H
  00007	7d 0a		 jge	 SHORT $L276085

; 2889 : 		return m_adjParamAry[ nDestParameter ];

  00009	8b 84 81 b8 12
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+4792]

; 2891 : }

  00010	c2 04 00	 ret	 4
$L276085:

; 2890 : 	return 0;

  00013	33 c0		 xor	 eax, eax

; 2891 : }

  00015	c2 04 00	 ret	 4
?GetAdjParam@CMover@@QAEHH@Z ENDP			; CMover::GetAdjParam
_TEXT	ENDS
PUBLIC	?GetChgParam@CMover@@QAEHH@Z			; CMover::GetChgParam
; Function compile flags: /Ogty
;	COMDAT ?GetChgParam@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nDestParameter$ = 8					; size = 4
?GetChgParam@CMover@@QAEHH@Z PROC NEAR			; CMover::GetChgParam, COMDAT
; _this$ = ecx

; 2895 : 	if( nDestParameter < MAX_ADJPARAMARY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nDestParameter$[esp-4]
  00004	83 f8 75	 cmp	 eax, 117		; 00000075H
  00007	7d 0a		 jge	 SHORT $L276090

; 2896 : 		return m_chgParamAry[ nDestParameter ];

  00009	8b 84 81 8c 14
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+5260]

; 2898 : }

  00010	c2 04 00	 ret	 4
$L276090:

; 2897 : 	return 0x7FFFFFFF;

  00013	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 2898 : }

  00018	c2 04 00	 ret	 4
?GetChgParam@CMover@@QAEHH@Z ENDP			; CMover::GetChgParam
_TEXT	ENDS
PUBLIC	?GetParam@CMover@@QAEHHH@Z			; CMover::GetParam
; Function compile flags: /Ogty
;	COMDAT ?GetParam@CMover@@QAEHHH@Z
_TEXT	SEGMENT
_nDest$ = 8						; size = 4
_nParam$ = 12						; size = 4
?GetParam@CMover@@QAEHHH@Z PROC NEAR			; CMover::GetParam, COMDAT
; _this$ = ecx

; 2903 : 	int nChgParam = GetChgParam( nDest );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _nDest$[esp-4]
  00004	83 fa 75	 cmp	 edx, 117		; 00000075H
  00007	7d 22		 jge	 SHORT $L276099
  00009	8b 84 91 8c 14
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+5260]

; 2904 : 	if( nChgParam != 0x7FFFFFFF ) 

  00010	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH

; 2905 : 		return nChgParam;

  00015	75 18		 jne	 SHORT $L276100

; 2906 : 
; 2907 : 	int nAdjParam = GetAdjParam( nDest );

  00017	8b 84 91 b8 12
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+4792]

; 2908 : 	if( nAdjParam )	

  0001e	85 c0		 test	 eax, eax
  00020	74 09		 je	 SHORT $L276099

; 2909 : 		return nParam + nAdjParam;

  00022	8b 4c 24 08	 mov	 ecx, DWORD PTR _nParam$[esp-4]
  00026	03 c1		 add	 eax, ecx

; 2912 : }

  00028	c2 08 00	 ret	 8
$L276099:

; 2910 : 	else
; 2911 : 		return nParam;

  0002b	8b 44 24 08	 mov	 eax, DWORD PTR _nParam$[esp-4]
$L276100:

; 2912 : }

  0002f	c2 08 00	 ret	 8
?GetParam@CMover@@QAEHHH@Z ENDP				; CMover::GetParam
_TEXT	ENDS
PUBLIC	?GetHitPoint@CMover@@QAEHXZ			; CMover::GetHitPoint
; Function compile flags: /Ogty
;	COMDAT ?GetHitPoint@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetHitPoint@CMover@@QAEHXZ PROC NEAR			; CMover::GetHitPoint, COMDAT
; _this$ = ecx

; 2921 : 	return GetParam( DST_HP, m_nHitPoint );

  00000	8b 81 24 15 00
	00		 mov	 eax, DWORD PTR [ecx+5412]
  00006	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000b	8b 91 00 06 00
	00		 mov	 edx, DWORD PTR [ecx+1536]
  00011	75 0f		 jne	 SHORT $L282566
  00013	8b 89 50 13 00
	00		 mov	 ecx, DWORD PTR [ecx+4944]
  00019	85 c9		 test	 ecx, ecx
  0001b	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0001e	75 02		 jne	 SHORT $L282566
  00020	8b c2		 mov	 eax, edx
$L282566:

; 2922 : }

  00022	c3		 ret	 0
?GetHitPoint@CMover@@QAEHXZ ENDP			; CMover::GetHitPoint
_TEXT	ENDS
PUBLIC	?GetManaPoint@CMover@@QAEHXZ			; CMover::GetManaPoint
; Function compile flags: /Ogty
;	COMDAT ?GetManaPoint@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetManaPoint@CMover@@QAEHXZ PROC NEAR			; CMover::GetManaPoint, COMDAT
; _this$ = ecx

; 2926 : #ifdef __EVENT1206
; 2927 : 	if( IsPlayer() && g_eLocal.GetState( EVE_EVENT1206 ) )  // raiders_fix051217
; 2928 : 		return GetMaxManaPoint();
; 2929 : #endif	// __EVENT1206
; 2930 : 	return GetParam( DST_MP, m_nManaPoint );

  00000	8b 81 28 15 00
	00		 mov	 eax, DWORD PTR [ecx+5416]
  00006	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000b	8b 91 04 06 00
	00		 mov	 edx, DWORD PTR [ecx+1540]
  00011	75 0f		 jne	 SHORT $L282593
  00013	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [ecx+4948]
  00019	85 c9		 test	 ecx, ecx
  0001b	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0001e	75 02		 jne	 SHORT $L282593
  00020	8b c2		 mov	 eax, edx
$L282593:

; 2931 : }

  00022	c3		 ret	 0
?GetManaPoint@CMover@@QAEHXZ ENDP			; CMover::GetManaPoint
_TEXT	ENDS
PUBLIC	?GetFatiguePoint@CMover@@QAEHXZ			; CMover::GetFatiguePoint
; Function compile flags: /Ogty
;	COMDAT ?GetFatiguePoint@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetFatiguePoint@CMover@@QAEHXZ PROC NEAR		; CMover::GetFatiguePoint, COMDAT
; _this$ = ecx

; 2935 : #ifdef __EVENT1206
; 2936 : 	if(  IsPlayer() && g_eLocal.GetState( EVE_EVENT1206 ) )	// raiders_fix051217
; 2937 : 		return GetMaxFatiguePoint();
; 2938 : #endif	// __EVENT1206
; 2939 : 	return GetParam( DST_FP, m_nFatiguePoint );

  00000	8b 81 2c 15 00
	00		 mov	 eax, DWORD PTR [ecx+5420]
  00006	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000b	8b 91 08 06 00
	00		 mov	 edx, DWORD PTR [ecx+1544]
  00011	75 0f		 jne	 SHORT $L282620
  00013	8b 89 58 13 00
	00		 mov	 ecx, DWORD PTR [ecx+4952]
  00019	85 c9		 test	 ecx, ecx
  0001b	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0001e	75 02		 jne	 SHORT $L282620
  00020	8b c2		 mov	 eax, edx
$L282620:

; 2940 : }

  00022	c3		 ret	 0
?GetFatiguePoint@CMover@@QAEHXZ ENDP			; CMover::GetFatiguePoint
_TEXT	ENDS
PUBLIC	?GetResistMagic@CMover@@QAEHXZ			; CMover::GetResistMagic
; Function compile flags: /Ogty
;	COMDAT ?GetResistMagic@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetResistMagic@CMover@@QAEHXZ PROC NEAR		; CMover::GetResistMagic, COMDAT
; _this$ = ecx

; 3289 : 	return GetParam( DST_RESIST_MAGIC, 0 );

  00000	8b 81 f8 14 00
	00		 mov	 eax, DWORD PTR [ecx+5368]
  00006	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000b	75 06		 jne	 SHORT $L282653
  0000d	8b 81 24 13 00
	00		 mov	 eax, DWORD PTR [ecx+4900]
$L282653:

; 3290 : }

  00013	c3		 ret	 0
?GetResistMagic@CMover@@QAEHXZ ENDP			; CMover::GetResistMagic
_TEXT	ENDS
PUBLIC	?GetStr@CMover@@QAEHXZ				; CMover::GetStr
; Function compile flags: /Ogty
;	COMDAT ?GetStr@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetStr@CMover@@QAEHXZ PROC NEAR			; CMover::GetStr, COMDAT
; _this$ = ecx

; 3320 : 	int nResult = m_nStr + GetParam( DST_STR, 0 );

  00000	8b 91 90 14 00
	00		 mov	 edx, DWORD PTR [ecx+5264]
  00006	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  0000c	75 06		 jne	 SHORT $L282679
  0000e	8b 91 bc 12 00
	00		 mov	 edx, DWORD PTR [ecx+4796]
$L282679:
  00014	8b 81 d0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1488]
  0001a	03 c2		 add	 eax, edx

; 3321 : 
; 3322 : #if __VER < 8 // __S8_PK
; 3323 : 	//    
; 3324 : 	if( IsMode( RECOVERCHAO_MODE ) && IsSMMode(SM_STR_DOWN) )
; 3325 : 	{
; 3326 : 		KarmaProp* pKarmaProp = prj.GetKarmaProp(m_nSlaughter);
; 3327 : 		if( pKarmaProp )
; 3328 : 			nResult -= (int)(nResult * (pKarmaProp->nStatLimitRate / 100.0f));
; 3329 : 	}
; 3330 : #endif // __VER < 8 // __S8_PK
; 3331 : 
; 3332 : #ifdef __JEFF_11
; 3333 : 	if( nResult < 1 )

  0001c	83 f8 01	 cmp	 eax, 1
  0001f	7d 05		 jge	 SHORT $L276268

; 3334 : 		nResult	= 1;

  00021	b8 01 00 00 00	 mov	 eax, 1
$L276268:

; 3335 : #endif	// __JEFF_11
; 3336 : 
; 3337 : 	return nResult;
; 3338 : }

  00026	c3		 ret	 0
?GetStr@CMover@@QAEHXZ ENDP				; CMover::GetStr
_TEXT	ENDS
PUBLIC	?GetDex@CMover@@QAEHXZ				; CMover::GetDex
; Function compile flags: /Ogty
;	COMDAT ?GetDex@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetDex@CMover@@QAEHXZ PROC NEAR			; CMover::GetDex, COMDAT
; _this$ = ecx

; 3341 : 	int nResult = m_nDex + GetParam( DST_DEX, 0 );

  00000	8b 91 94 14 00
	00		 mov	 edx, DWORD PTR [ecx+5268]
  00006	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  0000c	75 06		 jne	 SHORT $L282706
  0000e	8b 91 c0 12 00
	00		 mov	 edx, DWORD PTR [ecx+4800]
$L282706:
  00014	8b 81 d8 05 00
	00		 mov	 eax, DWORD PTR [ecx+1496]
  0001a	03 c2		 add	 eax, edx

; 3342 : 
; 3343 : #if __VER < 8 // __S8_PK
; 3344 : 	//    
; 3345 : 	if( IsMode( RECOVERCHAO_MODE ) && IsSMMode(SM_DEX_DOWN) )
; 3346 : 	{
; 3347 : 		KarmaProp* pKarmaProp = prj.GetKarmaProp(m_nSlaughter);
; 3348 : 		if( pKarmaProp )
; 3349 : 			nResult -= (int)(nResult * (pKarmaProp->nStatLimitRate / 100.0f));
; 3350 : 	}
; 3351 : #endif // __VER < 8 // __S8_PK
; 3352 : 
; 3353 : #ifdef __JEFF_11
; 3354 : 	if( nResult < 1 )

  0001c	83 f8 01	 cmp	 eax, 1
  0001f	7d 05		 jge	 SHORT $L276273

; 3355 : 		nResult	= 1;

  00021	b8 01 00 00 00	 mov	 eax, 1
$L276273:

; 3356 : #endif	// __JEFF_11
; 3357 : 
; 3358 : 	return nResult;
; 3359 : }

  00026	c3		 ret	 0
?GetDex@CMover@@QAEHXZ ENDP				; CMover::GetDex
_TEXT	ENDS
PUBLIC	?GetInt@CMover@@QAEHXZ				; CMover::GetInt
; Function compile flags: /Ogty
;	COMDAT ?GetInt@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetInt@CMover@@QAEHXZ PROC NEAR			; CMover::GetInt, COMDAT
; _this$ = ecx

; 3362 : 	int nResult = m_nInt + GetParam( DST_INT, 0 );

  00000	8b 91 98 14 00
	00		 mov	 edx, DWORD PTR [ecx+5272]
  00006	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  0000c	75 06		 jne	 SHORT $L282733
  0000e	8b 91 c4 12 00
	00		 mov	 edx, DWORD PTR [ecx+4804]
$L282733:
  00014	8b 81 dc 05 00
	00		 mov	 eax, DWORD PTR [ecx+1500]
  0001a	03 c2		 add	 eax, edx

; 3363 : 
; 3364 : #if __VER < 8 // __S8_PK
; 3365 : 	//    
; 3366 : 	if( IsMode( RECOVERCHAO_MODE ) && IsSMMode(SM_INT_DOWN) )
; 3367 : 	{
; 3368 : 		KarmaProp* pKarmaProp = prj.GetKarmaProp(m_nSlaughter);
; 3369 : 		if( pKarmaProp )
; 3370 : 			nResult -= (int)(nResult * (pKarmaProp->nStatLimitRate / 100.0f));
; 3371 : 	}
; 3372 : #endif // __VER < 8 // __S8_PK
; 3373 : 
; 3374 : #ifdef __JEFF_11
; 3375 : 	if( nResult < 1 )

  0001c	83 f8 01	 cmp	 eax, 1
  0001f	7d 05		 jge	 SHORT $L276278

; 3376 : 		nResult	= 1;

  00021	b8 01 00 00 00	 mov	 eax, 1
$L276278:

; 3377 : #endif	// __JEFF_11
; 3378 : 
; 3379 : 	return nResult;
; 3380 : }

  00026	c3		 ret	 0
?GetInt@CMover@@QAEHXZ ENDP				; CMover::GetInt
_TEXT	ENDS
PUBLIC	?GetSta@CMover@@QAEHXZ				; CMover::GetSta
; Function compile flags: /Ogty
;	COMDAT ?GetSta@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetSta@CMover@@QAEHXZ PROC NEAR			; CMover::GetSta, COMDAT
; _this$ = ecx

; 3383 : 	int nResult = m_nSta + GetParam( DST_STA, 0 );

  00000	8b 91 9c 14 00
	00		 mov	 edx, DWORD PTR [ecx+5276]
  00006	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  0000c	75 06		 jne	 SHORT $L282760
  0000e	8b 91 c8 12 00
	00		 mov	 edx, DWORD PTR [ecx+4808]
$L282760:
  00014	8b 81 d4 05 00
	00		 mov	 eax, DWORD PTR [ecx+1492]
  0001a	03 c2		 add	 eax, edx

; 3384 : 
; 3385 : #if __VER < 8 // __S8_PK
; 3386 : 	//    
; 3387 : 	if( IsMode( RECOVERCHAO_MODE ) && IsSMMode(SM_STA_DOWN) )
; 3388 : 	{
; 3389 : 		KarmaProp* pKarmaProp = prj.GetKarmaProp(m_nSlaughter);
; 3390 : 		if( pKarmaProp )
; 3391 : 			nResult -= (int)(nResult * (pKarmaProp->nStatLimitRate / 100.0f));
; 3392 : 	}
; 3393 : #endif // __VER < 8 // __S8_PK
; 3394 : 
; 3395 : #ifdef __JEFF_11
; 3396 : 	if( nResult < 1 )

  0001c	83 f8 01	 cmp	 eax, 1
  0001f	7d 05		 jge	 SHORT $L276283

; 3397 : 		nResult	= 1;

  00021	b8 01 00 00 00	 mov	 eax, 1
$L276283:

; 3398 : #endif	// __JEFF_11
; 3399 : 
; 3400 : 	return nResult;
; 3401 : }

  00026	c3		 ret	 0
?GetSta@CMover@@QAEHXZ ENDP				; CMover::GetSta
_TEXT	ENDS
PUBLIC	?IsCompleteQuest@CMover@@QAEHH@Z		; CMover::IsCompleteQuest
; Function compile flags: /Ogty
;	COMDAT ?IsCompleteQuest@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nQuestId$ = 8						; size = 4
?IsCompleteQuest@CMover@@QAEHH@Z PROC NEAR		; CMover::IsCompleteQuest, COMDAT
; _this$ = ecx

; 3538 : 		}
; 3539 : 	}
; 3540 : 	return FALSE;

  00000	0f b6 91 84 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3716]
  00007	56		 push	 esi
  00008	33 c0		 xor	 eax, eax
  0000a	85 d2		 test	 edx, edx
  0000c	57		 push	 edi
  0000d	7e 20		 jle	 SHORT $L276354
  0000f	8b 89 88 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3720]
  00015	8b 74 24 0c	 mov	 esi, DWORD PTR _nQuestId$[esp+4]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$L276352:
  00020	0f b7 39	 movzx	 edi, WORD PTR [ecx]
  00023	3b fe		 cmp	 edi, esi
  00025	74 0f		 je	 SHORT $L282768
  00027	40		 inc	 eax
  00028	83 c1 02	 add	 ecx, 2
  0002b	3b c2		 cmp	 eax, edx
  0002d	7c f1		 jl	 SHORT $L276352
$L276354:
  0002f	5f		 pop	 edi
  00030	33 c0		 xor	 eax, eax
  00032	5e		 pop	 esi

; 3541 : }

  00033	c2 04 00	 ret	 4
$L282768:
  00036	5f		 pop	 edi

; 3533 : 	for( int i = 0; i < m_nCompleteQuestSize; i++ )
; 3534 : 	{
; 3535 : 		if( m_aCompleteQuest[ i ] == nQuestId )
; 3536 : 		{
; 3537 : 			return TRUE;

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	5e		 pop	 esi

; 3541 : }

  0003d	c2 04 00	 ret	 4
?IsCompleteQuest@CMover@@QAEHH@Z ENDP			; CMover::IsCompleteQuest
_TEXT	ENDS
PUBLIC	?MakeCompleteQuest@CMover@@QAEHHPAUtagQuest@@@Z	; CMover::MakeCompleteQuest
; Function compile flags: /Ogty
;	COMDAT ?MakeCompleteQuest@CMover@@QAEHHPAUtagQuest@@@Z
_TEXT	SEGMENT
_nQuestId$ = 8						; size = 4
_lpQuest$ = 12						; size = 4
?MakeCompleteQuest@CMover@@QAEHHPAUtagQuest@@@Z PROC NEAR ; CMover::MakeCompleteQuest, COMDAT
; _this$ = ecx

; 3553 : 		}
; 3554 : 	}
; 3555 : 	return FALSE;

  00000	0f b6 91 84 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3716]
  00007	56		 push	 esi
  00008	33 c0		 xor	 eax, eax
  0000a	85 d2		 test	 edx, edx
  0000c	57		 push	 edi
  0000d	7e 20		 jle	 SHORT $L276364
  0000f	8b 89 88 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3720]
  00015	8b 74 24 0c	 mov	 esi, DWORD PTR _nQuestId$[esp+4]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$L276362:
  00020	0f b7 39	 movzx	 edi, WORD PTR [ecx]
  00023	3b fe		 cmp	 edi, esi
  00025	74 0f		 je	 SHORT $L282775
  00027	40		 inc	 eax
  00028	83 c1 02	 add	 ecx, 2
  0002b	3b c2		 cmp	 eax, edx
  0002d	7c f1		 jl	 SHORT $L276362
$L276364:
  0002f	5f		 pop	 edi
  00030	33 c0		 xor	 eax, eax
  00032	5e		 pop	 esi

; 3556 : }

  00033	c2 08 00	 ret	 8
$L282775:

; 3545 : 	for( int i = 0; i < m_nCompleteQuestSize; i++ )
; 3546 : 	{
; 3547 : 		if( m_aCompleteQuest[ i ] == nQuestId )
; 3548 : 		{
; 3549 : 			ZeroMemory( lpQuest, sizeof( QUEST ) );

  00036	8b 44 24 10	 mov	 eax, DWORD PTR _lpQuest$[esp+4]
  0003a	33 c9		 xor	 ecx, ecx
  0003c	8b d0		 mov	 edx, eax
  0003e	89 0a		 mov	 DWORD PTR [edx], ecx
  00040	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00043	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00046	66 89 4a 0c	 mov	 WORD PTR [edx+12], cx

; 3550 : 			lpQuest->m_wId = nQuestId;

  0004a	66 89 70 04	 mov	 WORD PTR [eax+4], si
  0004e	5f		 pop	 edi

; 3551 : 			lpQuest->m_nState = QS_END;

  0004f	c6 00 0e	 mov	 BYTE PTR [eax], 14	; 0000000eH

; 3552 : 			return TRUE;

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	5e		 pop	 esi

; 3556 : }

  00058	c2 08 00	 ret	 8
?MakeCompleteQuest@CMover@@QAEHHPAUtagQuest@@@Z ENDP	; CMover::MakeCompleteQuest
_TEXT	ENDS
PUBLIC	?RemoveAllQuest@CMover@@QAEXXZ			; CMover::RemoveAllQuest
; Function compile flags: /Ogty
;	COMDAT ?RemoveAllQuest@CMover@@QAEXXZ
_TEXT	SEGMENT
?RemoveAllQuest@CMover@@QAEXXZ PROC NEAR		; CMover::RemoveAllQuest, COMDAT
; _this$ = ecx

; 3559 : 	m_nQuestSize = 0;

  00000	32 c0		 xor	 al, al
  00002	88 81 7e 0e 00
	00		 mov	 BYTE PTR [ecx+3710], al

; 3560 : 	m_nCompleteQuestSize = 0;

  00008	88 81 84 0e 00
	00		 mov	 BYTE PTR [ecx+3716], al

; 3561 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 3562 : 	m_nCheckedQuestSize = 0;

  0000e	88 81 8c 0e 00
	00		 mov	 BYTE PTR [ecx+3724], al

; 3563 : #endif // __IMPROVE_QUEST_INTERFACE
; 3564 : }

  00014	c3		 ret	 0
?RemoveAllQuest@CMover@@QAEXXZ ENDP			; CMover::RemoveAllQuest
_TEXT	ENDS
PUBLIC	?RemoveCompleteQuest@CMover@@QAEXXZ		; CMover::RemoveCompleteQuest
; Function compile flags: /Ogty
;	COMDAT ?RemoveCompleteQuest@CMover@@QAEXXZ
_TEXT	SEGMENT
?RemoveCompleteQuest@CMover@@QAEXXZ PROC NEAR		; CMover::RemoveCompleteQuest, COMDAT
; _this$ = ecx

; 3567 : 	m_nCompleteQuestSize = 0;

  00000	c6 81 84 0e 00
	00 00		 mov	 BYTE PTR [ecx+3716], 0

; 3568 : }

  00007	c3		 ret	 0
?RemoveCompleteQuest@CMover@@QAEXXZ ENDP		; CMover::RemoveCompleteQuest
_TEXT	ENDS
PUBLIC	?FindQuest@CMover@@QAEPAUtagQuest@@H@Z		; CMover::FindQuest
; Function compile flags: /Ogty
;	COMDAT ?FindQuest@CMover@@QAEPAUtagQuest@@H@Z
_TEXT	SEGMENT
_nQuestId$ = 8						; size = 4
?FindQuest@CMover@@QAEPAUtagQuest@@H@Z PROC NEAR	; CMover::FindQuest, COMDAT
; _this$ = ecx

; 3578 : 		}
; 3579 : 	}
; 3580 : 
; 3581 : 	return NULL;

  00000	0f b6 91 7e 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3710]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	33 c0		 xor	 eax, eax
  0000b	85 d2		 test	 edx, edx
  0000d	57		 push	 edi
  0000e	7e 1f		 jle	 SHORT $L276380
  00010	8b b1 80 0e 00
	00		 mov	 esi, DWORD PTR [ecx+3712]
  00016	8b 7c 24 10	 mov	 edi, DWORD PTR _nQuestId$[esp+8]
  0001a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0001d	8d 49 00	 npad	 3
$L276378:
  00020	0f b7 19	 movzx	 ebx, WORD PTR [ecx]
  00023	3b df		 cmp	 ebx, edi
  00025	74 10		 je	 SHORT $L282788
  00027	40		 inc	 eax
  00028	83 c1 0e	 add	 ecx, 14			; 0000000eH
  0002b	3b c2		 cmp	 eax, edx
  0002d	7c f1		 jl	 SHORT $L276378
$L276380:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	33 c0		 xor	 eax, eax
  00033	5b		 pop	 ebx

; 3582 : }

  00034	c2 04 00	 ret	 4
$L282788:

; 3573 : 	for( int i = 0; i < m_nQuestSize; i++ )
; 3574 : 	{
; 3575 : 		if( m_aQuest[ i ].m_wId == nQuestId )
; 3576 : 		{
; 3577 : 			return &m_aQuest[ i ];

  00037	6b c0 0e	 imul	 eax, 14			; 0000000eH
  0003a	5f		 pop	 edi
  0003b	03 c6		 add	 eax, esi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 3582 : }

  0003f	c2 04 00	 ret	 4
?FindQuest@CMover@@QAEPAUtagQuest@@H@Z ENDP		; CMover::FindQuest
_TEXT	ENDS
PUBLIC	?GetQuest@CMover@@QAEPAUtagQuest@@H@Z		; CMover::GetQuest
; Function compile flags: /Ogty
;	COMDAT ?GetQuest@CMover@@QAEPAUtagQuest@@H@Z
_TEXT	SEGMENT
_nQuestId$ = 8						; size = 4
?GetQuest@CMover@@QAEPAUtagQuest@@H@Z PROC NEAR		; CMover::GetQuest, COMDAT
; _this$ = ecx

; 3737 : 	return FindQuest( nQuestId );

  00000	e9 00 00 00 00	 jmp	 ?FindQuest@CMover@@QAEPAUtagQuest@@H@Z ; CMover::FindQuest
?GetQuest@CMover@@QAEPAUtagQuest@@H@Z ENDP		; CMover::GetQuest
_TEXT	ENDS
PUBLIC	?Abrade@CMover@@QAEXPAV1@H@Z			; CMover::Abrade
; Function compile flags: /Ogty
;	COMDAT ?Abrade@CMover@@QAEXPAV1@H@Z
_TEXT	SEGMENT
_pAttacker$ = 8						; size = 4
_nParts$ = 12						; size = 4
?Abrade@CMover@@QAEXPAV1@H@Z PROC NEAR			; CMover::Abrade, COMDAT
; _this$ = ecx

; 3852 : #if __VER < 11 // __REMOVE_ENDURANCE
; 3853 : 	if( NULL == pAttacker )
; 3854 : 		return;
; 3855 : 
; 3856 : 	if( pAttacker->IsPlayer() )
; 3857 : 	{
; 3858 : 		CItemElem* pWeapon	= pAttacker->GetWeaponItem( nParts );
; 3859 : 		if( pWeapon == NULL )
; 3860 : 			return;
; 3861 : 
; 3862 : 		ItemProp* pWeaponProp	= pWeapon->GetProp();
; 3863 : 		if( pWeaponProp == NULL )
; 3864 : 			return;
; 3865 : 		
; 3866 : 		int nWpn = pWeapon->m_nHitPoint;
; 3867 : 		pWeapon->m_nHitPoint	-= ( pWeaponProp->nAbrasion  / 5 ) * GetItemEnduranceWeight(0);			//      2 .
; 3868 : 		if( pWeapon->m_nHitPoint < 0 )		pWeapon->m_nHitPoint = 0;
; 3869 : 		
; 3870 : 		if( nWpn != pWeapon->m_nHitPoint )
; 3871 : 			pAttacker->UpdateItem( pWeapon->m_dwObjId, UI_HP, pWeapon->m_nHitPoint );
; 3872 : 		
; 3873 : 		if( !IsPlayer() )	// PVP
; 3874 : 			return;
; 3875 : 		
; 3876 : 		DWORD dwParts	= GetRandomPartsAbraded();
; 3877 : 		CItemElem* pArmorElem	= m_Inventory.GetEquip( dwParts );
; 3878 : 		if( pArmorElem )
; 3879 : 		{
; 3880 : 			ItemProp* pArmorProp		= pArmorElem->GetProp();
; 3881 : 			if( pArmorProp && ( pArmorProp->dwItemKind2 == IK2_ARMOR || pArmorProp->dwItemKind2 == IK2_ARMORETC ))
; 3882 : 			{
; 3883 : 				int nArm = pArmorElem->m_nHitPoint;
; 3884 : 				pArmorElem->m_nHitPoint		-= pArmorProp->nAbrasion * GetItemEnduranceWeight(0);
; 3885 : 				if( pArmorElem->m_nHitPoint < 0 )	pArmorElem->m_nHitPoint	= 0;
; 3886 : 				
; 3887 : 				if( nArm != pArmorElem->m_nHitPoint )
; 3888 : 					UpdateItem( pArmorElem->m_dwObjId, UI_HP, pArmorElem->m_nHitPoint );
; 3889 : 			}
; 3890 : 		}
; 3891 : 	}
; 3892 : 	else
; 3893 : 	{
; 3894 : 		if( !IsPlayer() )	// MVP
; 3895 : 			return;
; 3896 : 
; 3897 : 		DWORD dwParts	= GetRandomPartsAbraded();
; 3898 : 		CItemElem* pArmorElem	= m_Inventory.GetEquip( dwParts );
; 3899 : 		if( pArmorElem == NULL )
; 3900 : 			return;
; 3901 : 		
; 3902 : 		ItemProp* pArmorProp		= pArmorElem->GetProp();
; 3903 : 		if( pArmorProp && ( pArmorProp->dwItemKind2 == IK2_ARMOR || pArmorProp->dwItemKind2 == IK2_ARMORETC ) )
; 3904 : 		{
; 3905 : 			ItemProp* pWeaponProp	= pAttacker->GetActiveHandItemProp( nParts );
; 3906 : 			if( pWeaponProp )
; 3907 : 			{
; 3908 : 				int nArm = pArmorElem->m_nHitPoint;
; 3909 : 				pArmorElem->m_nHitPoint		-= pArmorProp->nAbrasion * GetItemEnduranceWeight(0);
; 3910 : 				if( pArmorElem->m_nHitPoint < 0 )
; 3911 : 					pArmorElem->m_nHitPoint	= 0;
; 3912 : 				if( nArm != pArmorElem->m_nHitPoint )
; 3913 : 					UpdateItem( pArmorElem->m_dwObjId, UI_HP, pArmorElem->m_nHitPoint );
; 3914 : 			}
; 3915 : 		}
; 3916 : 	}
; 3917 : #endif // __REMOVE_ENDURANCE
; 3918 : }

  00000	c2 08 00	 ret	 8
?Abrade@CMover@@QAEXPAV1@H@Z ENDP			; CMover::Abrade
_TEXT	ENDS
PUBLIC	?GetItemEnduranceInfluence@CMover@@SAMH@Z	; CMover::GetItemEnduranceInfluence
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
EXTRN	__fltused:NEAR
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetItemEnduranceInfluence@CMover@@SAMH@Z
_TEXT	SEGMENT
_nEndurance$ = 8					; size = 4
?GetItemEnduranceInfluence@CMover@@SAMH@Z PROC NEAR	; CMover::GetItemEnduranceInfluence, COMDAT

; 3942 : 	if( nEndurance == 0 )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nEndurance$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 07		 jne	 SHORT $L276535

; 3943 : 		return 0.0f;

  00008	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000

; 3949 : }

  0000e	c3		 ret	 0
$L276535:

; 3944 : /*	else if( nEndurance <= 50 )
; 3945 : 		return 0.6f;
; 3946 : 	else if( nEndurance <= 75 )
; 3947 : 		return 0.8f;
; 3948 : */	return 1.0f;

  0000f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000

; 3949 : }

  00015	c3		 ret	 0
?GetItemEnduranceInfluence@CMover@@SAMH@Z ENDP		; CMover::GetItemEnduranceInfluence
_TEXT	ENDS
PUBLIC	?GetItemEnduranceWeight@CMover@@SAHH@Z		; CMover::GetItemEnduranceWeight
; Function compile flags: /Ogty
;	COMDAT ?GetItemEnduranceWeight@CMover@@SAHH@Z
_TEXT	SEGMENT
_nEndurance$ = 8					; size = 4
?GetItemEnduranceWeight@CMover@@SAHH@Z PROC NEAR	; CMover::GetItemEnduranceWeight, COMDAT

; 3953 : 	int nMinusMultyPly = 5;
; 3954 : /*	if( nEndurance <= 50 )
; 3955 : 		return (int)3 * nMinusMultyPly;
; 3956 : 	else if( nEndurance <= 75 )
; 3957 : 		return (int)2 * nMinusMultyPly;
; 3958 : */	return 1 * nMinusMultyPly;

  00000	b8 05 00 00 00	 mov	 eax, 5

; 3959 : }

  00005	c3		 ret	 0
?GetItemEnduranceWeight@CMover@@SAHH@Z ENDP		; CMover::GetItemEnduranceWeight
_TEXT	ENDS
PUBLIC	?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ	; CItemContainer<CItemElem>::GetMax
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ PROC NEAR	; CItemContainer<CItemElem>::GetMax, COMDAT
; _this$ = ecx

; 412  : 	int		GetMax() { return int( m_dwItemMax ); }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ ENDP	; CItemContainer<CItemElem>::GetMax
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<long *,long *>
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<long *,long *>, COMDAT

; 1031 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 1032 : 	return ((_OutIt)::memmove(&*_Dest, &*_First,
; 1033 : 		_Off * sizeof (*_First)) + _Off);

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1034 : 	}

  00027	c3		 ret	 0
??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<long *,long *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<long *,long *>
; Function compile flags: /Ogty
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<long *,long *>, COMDAT

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00021	c3		 ret	 0
??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<long *,long *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<long,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<long,std::allocator<long> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<long,std::allocator<long> >
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 331  : 		_Left = _Right;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Right$[esp-4]
  00004	8a 08		 mov	 cl, BYTE PTR [eax]
  00006	8b 54 24 04	 mov	 edx, DWORD PTR __Left$[esp-4]
  0000a	88 0a		 mov	 BYTE PTR [edx], cl

; 332  : 		}

  0000c	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogty
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 352  : 		return (::strlen(_First));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L282827:
  00007	8a 08		 mov	 cl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 c9		 test	 cl, cl
  0000c	75 f9		 jne	 SHORT $L282827
  0000e	2b c2		 sub	 eax, edx

; 353  : 		}

  00010	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Ogty
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR __First2$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR __First1$[esp+4]
  0000e	8b c1		 mov	 eax, ecx
  00010	8b d7		 mov	 edx, edi
  00012	c1 e9 02	 shr	 ecx, 2
  00015	f3 a5		 rep movsd
  00017	8b c8		 mov	 ecx, eax
  00019	83 e1 03	 and	 ecx, 3
  0001c	f3 a4		 rep movsb
  0001e	5f		 pop	 edi
  0001f	8b c2		 mov	 eax, edx
  00021	5e		 pop	 esi

; 359  : 		}

  00022	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Ogty
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

  00000	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<long,long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<long,long>, COMDAT

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 109  : 	}

  00027	c3		 ret	 0
??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<long,long>
_TEXT	ENDS
PUBLIC	??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z		; std::fill_n<long *,unsigned int,long>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z PROC NEAR		; std::fill_n<long *,unsigned int,long>, COMDAT

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	76 14		 jbe	 SHORT $L280624
  00008	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00010	56		 push	 esi
$L280622:

; 1161 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L280622
  0001b	5e		 pop	 esi
$L280624:

; 1162 : 	}

  0001c	c3		 ret	 0
??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z ENDP			; std::fill_n<long *,unsigned int,long>
_TEXT	ENDS
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z ; std::_Ptr_cat
; Function compile flags: /Ogty
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 359  : 	{	// return pointer category from pointer to long arguments

  00000	51		 push	 ecx

; 360  : 	_Scalar_ptr_iterator_tag _Cat;
; 361  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 362  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z ENDP ; std::_Ptr_cat
_TEXT	ENDS
PUBLIC	_powf
EXTRN	__CIpow:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT _powf
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_powf	PROC NEAR					; COMDAT

; 464  :         {return ((float)pow((double)_X, (double)_Y)); }

  00000	d9 44 24 04	 fld	 DWORD PTR __X$[esp-4]
  00004	d9 44 24 08	 fld	 DWORD PTR __Y$[esp-4]
  00008	e8 00 00 00 00	 call	 __CIpow
  0000d	c3		 ret	 0
_powf	ENDP
_TEXT	ENDS
PUBLIC	?pow@@YAMMM@Z					; pow
; Function compile flags: /Ogty
;	COMDAT ?pow@@YAMMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?pow@@YAMMM@Z PROC NEAR					; pow, COMDAT

; 571  :         {return (powf(_X, _Y)); }

  00000	d9 44 24 04	 fld	 DWORD PTR __X$[esp-4]
  00004	d9 44 24 08	 fld	 DWORD PTR __Y$[esp-4]
  00008	e8 00 00 00 00	 call	 __CIpow
  0000d	c3		 ret	 0
?pow@@YAMMM@Z ENDP					; pow
_TEXT	ENDS
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\dx_sdk\d3dx9math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC NEAR			; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 300  :     x = fx;
; 301  :     y = fy;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _fy$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _fx$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 302  :     z = fz;

  0000c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _fz$[esp-4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 303  : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0_LogItemInfo@@QAE@XZ				; _LogItemInfo::_LogItemInfo
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\cmnhdr.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0_LogItemInfo@@QAE@XZ
_TEXT	SEGMENT
??0_LogItemInfo@@QAE@XZ PROC NEAR			; _LogItemInfo::_LogItemInfo, COMDAT
; _this$ = ecx

; 641  : 	_LogItemInfo()

  00000	8b c1		 mov	 eax, ecx
  00002	56		 push	 esi

; 642  : 	{
; 643  : 		Action = _T("");
; 644  : 		SendName = _T("");
; 645  : 		RecvName = _T("");
; 646  : 		WorldId = Gold = Gold2 = 0;
; 647  : 		Negudo = 0;
; 648  : 		MaxNegudo = 0;
; 649  : 		ItemNo = 0;
; 650  : 		//ItemName = _T("");
; 651  : 		::memset( szItemName, 0, sizeof(szItemName) );

  00003	33 d2		 xor	 edx, edx
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00012	33 c9		 xor	 ecx, ecx
  00014	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00017	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001d	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00020	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00023	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00026	8d 70 24	 lea	 esi, DWORD PTR [eax+36]
  00029	89 16		 mov	 DWORD PTR [esi], edx
  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0002e	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00031	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00034	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00037	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0003a	89 56 18	 mov	 DWORD PTR [esi+24], edx
  0003d	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 652  : 		itemNumber = 0;

  00040	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 653  : 		nAbilityOption = 0;

  00043	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 654  : 		Gold_1 = 0;

  00046	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 655  : 		nSlot = 100;
; 656  : 		nSlot1 = 100;
; 657  : 		nItemResist = 0;

  00049	89 48 58	 mov	 DWORD PTR [eax+88], ecx

; 658  : 		nResistAbilityOption = 0;

  0004c	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 659  : 		m_bCharged = FALSE;

  0004f	89 48 60	 mov	 DWORD PTR [eax+96], ecx

; 660  : 		m_dwKeepTime = 0;

  00052	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 661  : #if __VER >= 11 // __SYS_IDENTIFY
; 662  : 		m_iRandomOptItemId = 0;

  00055	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00058	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 663  : #else	//__SYS_IDENTIFY
; 664  : 		m_nRandomOptItemId = 0;
; 665  : #endif	// __SYS_IDENTIFY
; 666  : #if __VER >= 12 // __EXT_PIERCING
; 667  : 		nPiercedSize = 0;

  0005b	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  0005e	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00063	89 50 50	 mov	 DWORD PTR [eax+80], edx
  00066	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 668  : //		for( int i=0; i<MAX_PIERCING_WEAPON; i++ )
; 669  : //			adwItemId[i] = 0;
; 670  : 		memset( adwItemId, 0, sizeof(adwItemId) );

  00069	33 d2		 xor	 edx, edx
  0006b	8d 70 74	 lea	 esi, DWORD PTR [eax+116]
  0006e	89 16		 mov	 DWORD PTR [esi], edx
  00070	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00073	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00076	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00079	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0007c	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0007f	89 56 18	 mov	 DWORD PTR [esi+24], edx
  00082	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  00085	89 56 20	 mov	 DWORD PTR [esi+32], edx
  00088	89 56 24	 mov	 DWORD PTR [esi+36], edx

; 671  : 		nUMPiercedSize = 0;

  0008b	89 88 9c 00 00
	00		 mov	 DWORD PTR [eax+156], ecx

; 672  : //		for( i=0; i<MAX_PIERCING_ULTIMATE; i++ )
; 673  : //	adwUMItemId[i] = 0;
; 674  : 		memset( adwUMItemId, 0, sizeof(adwUMItemId) );

  00091	8d b0 a0 00 00
	00		 lea	 esi, DWORD PTR [eax+160]
  00097	89 16		 mov	 DWORD PTR [esi], edx
  00099	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0009c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009f	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000a2	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 675  : #else // __EXT_PIERCING
; 676  : 		nPiercedSize = 0;
; 677  : 		adwItemId0 = 0;
; 678  : 		adwItemId1 = 0;
; 679  : 		adwItemId2 = 0;
; 680  : 		adwItemId3 = 0;
; 681  : #if __VER >= 9 // __ULTIMATE
; 682  : 		adwItemId4 = 0;
; 683  : #endif // __ULTIMATE
; 684  : #endif // __EXT_PIERCING
; 685  : #if __VER >= 9 // __PET_0410
; 686  : 		nPetKind = 0;

  000a5	88 88 b4 00 00
	00		 mov	 BYTE PTR [eax+180], cl

; 687  : 		nPetLevel = 0;

  000ab	88 88 b5 00 00
	00		 mov	 BYTE PTR [eax+181], cl

; 688  : 		dwPetExp = 0;

  000b1	89 88 b8 00 00
	00		 mov	 DWORD PTR [eax+184], ecx

; 689  : 		wPetEnergy = 0;

  000b7	66 89 88 bc 00
	00 00		 mov	 WORD PTR [eax+188], cx

; 690  : 		wPetLife = 0;

  000be	66 89 88 be 00
	00 00		 mov	 WORD PTR [eax+190], cx

; 691  : 		nPetAL_D = 0;

  000c5	88 88 c0 00 00
	00		 mov	 BYTE PTR [eax+192], cl

; 692  : 		nPetAL_C = 0;

  000cb	88 88 c1 00 00
	00		 mov	 BYTE PTR [eax+193], cl

; 693  : 		nPetAL_B = 0;

  000d1	88 88 c2 00 00
	00		 mov	 BYTE PTR [eax+194], cl

; 694  : 		nPetAL_A = 0;

  000d7	88 88 c3 00 00
	00		 mov	 BYTE PTR [eax+195], cl

; 695  : 		nPetAL_S = 0;

  000dd	88 88 c4 00 00
	00		 mov	 BYTE PTR [eax+196], cl
  000e3	5e		 pop	 esi

; 696  : #endif // __PET_0410
; 697  : 	}

  000e4	c3		 ret	 0
??0_LogItemInfo@@QAE@XZ ENDP				; _LogItemInfo::_LogItemInfo
_TEXT	ENDS
PUBLIC	?time_null@@YAJXZ				; time_null
EXTRN	?g_tCurrent@@3JA:DWORD				; g_tCurrent
; Function compile flags: /Ogty
;	COMDAT ?time_null@@YAJXZ
_TEXT	SEGMENT
?time_null@@YAJXZ PROC NEAR				; time_null, COMDAT

; 702  : #if defined(__WORLDSERVER) || defined(__CLIENT)
; 703  : 	return	g_tCurrent;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent

; 704  : #else	//
; 705  : 	return time( NULL );
; 706  : #endif	//
; 707  : }

  00005	c3		 ret	 0
?time_null@@YAJXZ ENDP					; time_null
_TEXT	ENDS
PUBLIC	?xRand@@YAKXZ					; xRand
EXTRN	?g_next@@3KA:DWORD				; g_next
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\xutil.h
;	COMDAT ?xRand@@YAKXZ
_TEXT	SEGMENT
?xRand@@YAKXZ PROC NEAR					; xRand, COMDAT

; 16   : 	g_next = g_next * 1103515245 + 12345;// + nRandomSeed[ i++ ];

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next

; 17   : 	return g_next;	//   .
; 18   : }

  00015	c3		 ret	 0
?xRand@@YAKXZ ENDP					; xRand
_TEXT	ENDS
PUBLIC	?IsDelete@CObj@@QAEHXZ				; CObj::IsDelete
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\obj.h
;	COMDAT ?IsDelete@CObj@@QAEHXZ
_TEXT	SEGMENT
?IsDelete@CObj@@QAEHXZ PROC NEAR			; CObj::IsDelete, COMDAT
; _this$ = ecx

; 180  : 	BOOL			IsDelete()	{ return (m_dwFlags & OBJ_FLAG_DELETE);  }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e0 01	 and	 eax, 1
  00006	c3		 ret	 0
?IsDelete@CObj@@QAEHXZ ENDP				; CObj::IsDelete
_TEXT	ENDS
PUBLIC	?GetWorld@CObj@@QAEPAVCWorld@@XZ		; CObj::GetWorld
; Function compile flags: /Ogty
;	COMDAT ?GetWorld@CObj@@QAEPAVCWorld@@XZ
_TEXT	SEGMENT
?GetWorld@CObj@@QAEPAVCWorld@@XZ PROC NEAR		; CObj::GetWorld, COMDAT
; _this$ = ecx

; 221  : 	CWorld*			GetWorld()	{ return m_pWorld; }

  00000	8b 81 6c 01 00
	00		 mov	 eax, DWORD PTR [ecx+364]
  00006	c3		 ret	 0
?GetWorld@CObj@@QAEPAVCWorld@@XZ ENDP			; CObj::GetWorld
_TEXT	ENDS
PUBLIC	?IsValidObj@@YAHPAVCObj@@@Z			; IsValidObj
; Function compile flags: /Ogty
;	COMDAT ?IsValidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?IsValidObj@@YAHPAVCObj@@@Z PROC NEAR			; IsValidObj, COMDAT

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pObj$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 0c		 je	 SHORT $L282877
  00008	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0000c	75 06		 jne	 SHORT $L282877
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 328  : }

  00013	c3		 ret	 0
$L282877:

; 327  : 	return pObj && ( pObj->IsDelete() == FALSE ); 

  00014	33 c0		 xor	 eax, eax

; 328  : }

  00016	c3		 ret	 0
?IsValidObj@@YAHPAVCObj@@@Z ENDP			; IsValidObj
_TEXT	ENDS
PUBLIC	?IsInvalidObj@@YAHPAVCObj@@@Z			; IsInvalidObj
; Function compile flags: /Ogty
;	COMDAT ?IsInvalidObj@@YAHPAVCObj@@@Z
_TEXT	SEGMENT
_pObj$ = 8						; size = 4
?IsInvalidObj@@YAHPAVCObj@@@Z PROC NEAR			; IsInvalidObj, COMDAT

; 332  : 	return !IsValidObj( pObj ); 

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pObj$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 15		 je	 SHORT $L282892
  00008	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  0000c	75 0f		 jne	 SHORT $L282892
  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	33 c9		 xor	 ecx, ecx
  00015	85 c0		 test	 eax, eax
  00017	0f 94 c1	 sete	 cl
  0001a	8b c1		 mov	 eax, ecx

; 333  : }

  0001c	c3		 ret	 0

; 332  : 	return !IsValidObj( pObj ); 

$L282892:
  0001d	33 c0		 xor	 eax, eax
  0001f	33 c9		 xor	 ecx, ecx
  00021	85 c0		 test	 eax, eax
  00023	0f 94 c1	 sete	 cl
  00026	8b c1		 mov	 eax, ecx

; 333  : }

  00028	c3		 ret	 0
?IsInvalidObj@@YAHPAVCObj@@@Z ENDP			; IsInvalidObj
_TEXT	ENDS
PUBLIC	?GetId@CCtrl@@QAEKXZ				; CCtrl::GetId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\ctrl.h
;	COMDAT ?GetId@CCtrl@@QAEKXZ
_TEXT	SEGMENT
?GetId@CCtrl@@QAEKXZ PROC NEAR				; CCtrl::GetId, COMDAT
; _this$ = ecx

; 58   : 	OBJID			GetId()					{ return m_objid;   }

  00000	8b 81 bc 01 00
	00		 mov	 eax, DWORD PTR [ecx+444]
  00006	c3		 ret	 0
?GetId@CCtrl@@QAEKXZ ENDP				; CCtrl::GetId
_TEXT	ENDS
PUBLIC	?LOG_RANGE@@YAXPBDHHH@Z				; LOG_RANGE
PUBLIC	??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ ; `string'
;	COMDAT ??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	SEGMENT
??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@ DB '%'
	DB	's min:%d, max:%d, index:%d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?LOG_RANGE@@YAXPBDHHH@Z
_TEXT	SEGMENT
_szMsg$ = 8						; size = 4
_nMin$ = 12						; size = 4
_nMax$ = 16						; size = 4
_nIndex$ = 20						; size = 4
?LOG_RANGE@@YAXPBDHHH@Z PROC NEAR			; LOG_RANGE, COMDAT

; 559  : 	LPCTSTR szErr = Error( _T( "%s min:%d, max:%d, index:%d" ), szMsg, nMin, nMax, nIndex ); 

  00000	8b 44 24 10	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMax$[esp-4]
  00008	8b 54 24 08	 mov	 edx, DWORD PTR _nMin$[esp-4]
  0000c	50		 push	 eax
  0000d	8b 44 24 08	 mov	 eax, DWORD PTR _szMsg$[esp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00019	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 560  : 	ADDERRORMSG( szErr ); 
; 561  : }

  00021	c3		 ret	 0
?LOG_RANGE@@YAXPBDHHH@Z ENDP				; LOG_RANGE
_TEXT	ENDS
PUBLIC	?LOG_CALLSTACK@@YAXXZ				; LOG_CALLSTACK
; Function compile flags: /Ogty
;	COMDAT ?LOG_CALLSTACK@@YAXXZ
_TEXT	SEGMENT
?LOG_CALLSTACK@@YAXXZ PROC NEAR				; LOG_CALLSTACK, COMDAT

; 565  : #ifdef _DEBUG
; 566  : 	__asm int 3
; 567  : #endif
; 568  : 
; 569  : #if defined(__INTERNALSERVER)
; 570  : 	int *p = NULL;		//    
; 571  : 	*p = 1;
; 572  : #endif
; 573  : }

  00000	c3		 ret	 0
?LOG_CALLSTACK@@YAXXZ ENDP				; LOG_CALLSTACK
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@ ; `string'
PUBLIC	?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z	; CProject::GetMoverProp
;	COMDAT ??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
CONST	SEGMENT
??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@ DB 'GetMoverProp range_'
	DB	'error', 00H					; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z PROC NEAR	; CProject::GetMoverProp, COMDAT
; _this$ = ecx

; 1381 : 	VERIFY_RANGE( nIndex, 0, m_nMoverPropSize, "GetMoverProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 19		 jl	 SHORT $L197938
  00008	3b 81 d0 01 00
	00		 cmp	 eax, DWORD PTR [ecx+464]
  0000e	7d 11		 jge	 SHORT $L197938

; 1382 : 	return m_pPropMover + nIndex;

  00010	8b 91 d4 01 00
	00		 mov	 edx, DWORD PTR [ecx+468]
  00016	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  0001c	03 c2		 add	 eax, edx

; 1383 : }

  0001e	c2 04 00	 ret	 4
$L197938:

; 1381 : 	VERIFY_RANGE( nIndex, 0, m_nMoverPropSize, "GetMoverProp range_error", NULL );

  00021	50		 push	 eax
  00022	8b 81 d0 01 00
	00		 mov	 eax, DWORD PTR [ecx+464]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00035	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003a	83 c4 14	 add	 esp, 20			; 00000014H
  0003d	33 c0		 xor	 eax, eax

; 1383 : }

  0003f	c2 04 00	 ret	 4
?GetMoverProp@CProject@@QAEPAUMoverProp@@H@Z ENDP	; CProject::GetMoverProp
_TEXT	ENDS
PUBLIC	?IsEmpty@CItemBase@@QAEHXZ			; CItemBase::IsEmpty
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?IsEmpty@CItemBase@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CItemBase@@QAEHXZ PROC NEAR			; CItemBase::IsEmpty, COMDAT
; _this$ = ecx

; 48   : 	BOOL			IsEmpty() { return m_dwItemId ? FALSE : TRUE; }

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CItemBase@@QAEHXZ ENDP				; CItemBase::IsEmpty
_TEXT	ENDS
PUBLIC	?SetPiercingSize@CItemElem@@QAEXH@Z		; CItemElem::SetPiercingSize
EXTRN	?SetPiercingSize@CPiercing@@QAEXH@Z:NEAR	; CPiercing::SetPiercingSize
; Function compile flags: /Ogty
;	COMDAT ?SetPiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetPiercingSize@CItemElem@@QAEXH@Z PROC NEAR		; CItemElem::SetPiercingSize, COMDAT
; _this$ = ecx

; 100  : 	void	SetPiercingSize( int nSize )	{	m_piercing.SetPiercingSize( nSize );	}

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?SetPiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetPiercingSize
?SetPiercingSize@CItemElem@@QAEXH@Z ENDP		; CItemElem::SetPiercingSize
_TEXT	ENDS
PUBLIC	?SetPiercingItem@CItemElem@@QAEXHK@Z		; CItemElem::SetPiercingItem
EXTRN	?SetPiercingItem@CPiercing@@QAEXHK@Z:NEAR	; CPiercing::SetPiercingItem
; Function compile flags: /Ogty
;	COMDAT ?SetPiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
_dwItem$ = 12						; size = 4
?SetPiercingItem@CItemElem@@QAEXHK@Z PROC NEAR		; CItemElem::SetPiercingItem, COMDAT
; _this$ = ecx

; 103  : 	void	SetPiercingItem( int nth, DWORD dwItem )	{	m_piercing.SetPiercingItem( nth, dwItem );	}

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?SetPiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetPiercingItem
?SetPiercingItem@CItemElem@@QAEXHK@Z ENDP		; CItemElem::SetPiercingItem
_TEXT	ENDS
PUBLIC	?SetUltimatePiercingSize@CItemElem@@QAEXH@Z	; CItemElem::SetUltimatePiercingSize
EXTRN	?SetUltimatePiercingSize@CPiercing@@QAEXH@Z:NEAR ; CPiercing::SetUltimatePiercingSize
; Function compile flags: /Ogty
;	COMDAT ?SetUltimatePiercingSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetUltimatePiercingSize@CItemElem@@QAEXH@Z PROC NEAR	; CItemElem::SetUltimatePiercingSize, COMDAT
; _this$ = ecx

; 109  : 	void	SetUltimatePiercingSize( int nSize )	{	m_piercing.SetUltimatePiercingSize( nSize );	}

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?SetUltimatePiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetUltimatePiercingSize
?SetUltimatePiercingSize@CItemElem@@QAEXH@Z ENDP	; CItemElem::SetUltimatePiercingSize
_TEXT	ENDS
PUBLIC	?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z	; CItemElem::SetUltimatePiercingItem
EXTRN	?SetUltimatePiercingItem@CPiercing@@QAEXHK@Z:NEAR ; CPiercing::SetUltimatePiercingItem
; Function compile flags: /Ogty
;	COMDAT ?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
_dwItem$ = 12						; size = 4
?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z PROC NEAR	; CItemElem::SetUltimatePiercingItem, COMDAT
; _this$ = ecx

; 111  : 	void	SetUltimatePiercingItem( int nth, DWORD dwItem )	{	m_piercing.SetUltimatePiercingItem( nth, dwItem );	}

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?SetUltimatePiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetUltimatePiercingItem
?SetUltimatePiercingItem@CItemElem@@QAEXHK@Z ENDP	; CItemElem::SetUltimatePiercingItem
_TEXT	ENDS
PUBLIC	?IsCollector@CItemElem@@QAEHH@Z			; CItemElem::IsCollector
; Function compile flags: /Ogty
;	COMDAT ?IsCollector@CItemElem@@QAEHH@Z
_TEXT	SEGMENT
_bRefinable$ = 8					; size = 4
?IsCollector@CItemElem@@QAEHH@Z PROC NEAR		; CItemElem::IsCollector, COMDAT
; _this$ = ecx

; 152  : 	BOOL	IsCollector( BOOL bRefinable = FALSE )	{	return( m_dwItemId == II_GEN_TOO_COL_NORMAL || ( !bRefinable && m_dwItemId == II_GEN_TOO_COL_EVENT ) );		}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	3d 54 67 00 00	 cmp	 eax, 26452		; 00006754H
  00008	74 14		 je	 SHORT $L282933
  0000a	8b 4c 24 04	 mov	 ecx, DWORD PTR _bRefinable$[esp-4]
  0000e	85 c9		 test	 ecx, ecx
  00010	75 07		 jne	 SHORT $L282932
  00012	3d c5 67 00 00	 cmp	 eax, 26565		; 000067c5H
  00017	74 05		 je	 SHORT $L282933
$L282932:
  00019	33 c0		 xor	 eax, eax
  0001b	c2 04 00	 ret	 4
$L282933:
  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	c2 04 00	 ret	 4
?IsCollector@CItemElem@@QAEHH@Z ENDP			; CItemElem::IsCollector
_TEXT	ENDS
PUBLIC	?IsAccessory@CItemElem@@QAEHXZ			; CItemElem::IsAccessory
EXTRN	?GetInstance@CAccessoryProperty@@SAPAV1@XZ:NEAR	; CAccessoryProperty::GetInstance
EXTRN	?IsAccessory@CAccessoryProperty@@QAEHK@Z:NEAR	; CAccessoryProperty::IsAccessory
; Function compile flags: /Ogty
;	COMDAT ?IsAccessory@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?IsAccessory@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::IsAccessory, COMDAT
; _this$ = ecx

; 153  : 	BOOL	IsAccessory( void )		{	return CAccessoryProperty::GetInstance()->IsAccessory( m_dwItemId );	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ?GetInstance@CAccessoryProperty@@SAPAV1@XZ ; CAccessoryProperty::GetInstance
  00009	8b c8		 mov	 ecx, eax
  0000b	e8 00 00 00 00	 call	 ?IsAccessory@CAccessoryProperty@@QAEHK@Z ; CAccessoryProperty::IsAccessory
  00010	c3		 ret	 0
?IsAccessory@CItemElem@@QAEHXZ ENDP			; CItemElem::IsAccessory
_TEXT	ENDS
PUBLIC	?SetRandomOptItemId@CItemElem@@QAEX_J@Z		; CItemElem::SetRandomOptItemId
; Function compile flags: /Ogty
;	COMDAT ?SetRandomOptItemId@CItemElem@@QAEX_J@Z
_TEXT	SEGMENT
_iRandomOptItemId$ = 8					; size = 8
?SetRandomOptItemId@CItemElem@@QAEX_J@Z PROC NEAR	; CItemElem::SetRandomOptItemId, COMDAT
; _this$ = ecx

; 168  : 	void	SetRandomOptItemId( __int64 iRandomOptItemId )	{	m_iRandomOptItemId	= iRandomOptItemId;	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _iRandomOptItemId$[esp-4]
  00004	8b 54 24 08	 mov	 edx, DWORD PTR _iRandomOptItemId$[esp]
  00008	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax
  0000e	89 91 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], edx
  00014	c2 08 00	 ret	 8
?SetRandomOptItemId@CItemElem@@QAEX_J@Z ENDP		; CItemElem::SetRandomOptItemId
_TEXT	ENDS
PUBLIC	?SetRandomOpt@CItemElem@@QAEXH@Z		; CItemElem::SetRandomOpt
; Function compile flags: /Ogty
;	COMDAT ?SetRandomOpt@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nRandomOpt$ = 8					; size = 4
?SetRandomOpt@CItemElem@@QAEXH@Z PROC NEAR		; CItemElem::SetRandomOpt, COMDAT
; _this$ = ecx

; 170  : 	void	SetRandomOpt( int nRandomOpt )	{	m_iRandomOptItemId	= ( m_iRandomOptItemId & 0xFFFFFFFFFFFFFF00 ) | static_cast<__int64>( nRandomOpt & 0x00000000000000FF );	}

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nRandomOpt$[esp-4]
  00004	56		 push	 esi
  00005	8b b1 98 00 00
	00		 mov	 esi, DWORD PTR [ecx+152]
  0000b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00010	57		 push	 edi
  00011	8b b9 9c 00 00
	00		 mov	 edi, DWORD PTR [ecx+156]
  00017	99		 cdq
  00018	81 e6 00 ff ff
	ff		 and	 esi, -256		; ffffff00H
  0001e	0b d7		 or	 edx, edi
  00020	0b c6		 or	 eax, esi
  00022	5f		 pop	 edi
  00023	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax
  00029	89 91 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], edx
  0002f	5e		 pop	 esi
  00030	c2 04 00	 ret	 4
?SetRandomOpt@CItemElem@@QAEXH@Z ENDP			; CItemElem::SetRandomOpt
_TEXT	ENDS
PUBLIC	?GetAbilityOption@CItemElem@@QAEHXZ		; CItemElem::GetAbilityOption
; Function compile flags: /Ogty
;	COMDAT ?GetAbilityOption@CItemElem@@QAEHXZ
_TEXT	SEGMENT
?GetAbilityOption@CItemElem@@QAEHXZ PROC NEAR		; CItemElem::GetAbilityOption, COMDAT
; _this$ = ecx

; 231  : 	int			GetAbilityOption() { return m_nAbilityOption; }

  00000	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00003	c3		 ret	 0
?GetAbilityOption@CItemElem@@QAEHXZ ENDP		; CItemElem::GetAbilityOption
_TEXT	ENDS
PUBLIC	?SetAbilityOption@CItemElem@@QAEXH@Z		; CItemElem::SetAbilityOption
; Function compile flags: /Ogty
;	COMDAT ?SetAbilityOption@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nAbilityOption$ = 8					; size = 4
?SetAbilityOption@CItemElem@@QAEXH@Z PROC NEAR		; CItemElem::SetAbilityOption, COMDAT
; _this$ = ecx

; 237  : 	void		SetAbilityOption( int nAbilityOption ) { m_nAbilityOption = nAbilityOption; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nAbilityOption$[esp-4]
  00004	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00007	c2 04 00	 ret	 4
?SetAbilityOption@CItemElem@@QAEXH@Z ENDP		; CItemElem::SetAbilityOption
_TEXT	ENDS
PUBLIC	?SetVisKeepTime@CItemElem@@QAEXHJ@Z		; CItemElem::SetVisKeepTime
EXTRN	?SetVisKeepTime@CPiercing@@QAEXHJ@Z:NEAR	; CPiercing::SetVisKeepTime
; Function compile flags: /Ogty
;	COMDAT ?SetVisKeepTime@CItemElem@@QAEXHJ@Z
_TEXT	SEGMENT
_nth$ = 8						; size = 4
_tmKeep$ = 12						; size = 4
?SetVisKeepTime@CItemElem@@QAEXHJ@Z PROC NEAR		; CItemElem::SetVisKeepTime, COMDAT
; _this$ = ecx

; 277  : 	void	SetVisKeepTime( int nth, time_t tmKeep )	{ m_piercing.SetVisKeepTime( nth, tmKeep ); }

  00000	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00003	e9 00 00 00 00	 jmp	 ?SetVisKeepTime@CPiercing@@QAEXHJ@Z ; CPiercing::SetVisKeepTime
?SetVisKeepTime@CItemElem@@QAEXHJ@Z ENDP		; CItemElem::SetVisKeepTime
_TEXT	ENDS
PUBLIC	?GetId@IBuff@@QAEGXZ				; IBuff::GetId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\buff.h
;	COMDAT ?GetId@IBuff@@QAEGXZ
_TEXT	SEGMENT
?GetId@IBuff@@QAEGXZ PROC NEAR				; IBuff::GetId, COMDAT
; _this$ = ecx

; 31   : 	WORD	GetId()		{	return m_wId;	}

  00000	66 8b 41 06	 mov	 ax, WORD PTR [ecx+6]
  00004	c3		 ret	 0
?GetId@IBuff@@QAEGXZ ENDP				; IBuff::GetId
_TEXT	ENDS
PUBLIC	?IsFly@CAction@@QAEHXZ				; CAction::IsFly
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\action.h
;	COMDAT ?IsFly@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsFly@CAction@@QAEHXZ PROC NEAR			; CAction::IsFly, COMDAT
; _this$ = ecx

; 309  : 	BOOL			IsFly() { return (m_dwStateFlag & OBJSTAF_FLY) ? TRUE : FALSE; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c1 e8 03	 shr	 eax, 3
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsFly@CAction@@QAEHXZ ENDP				; CAction::IsFly
_TEXT	ENDS
PUBLIC	?IsDie@CAction@@QAEHXZ				; CAction::IsDie
; Function compile flags: /Ogty
;	COMDAT ?IsDie@CAction@@QAEHXZ
_TEXT	SEGMENT
?IsDie@CAction@@QAEHXZ PROC NEAR			; CAction::IsDie, COMDAT
; _this$ = ecx

; 310  : 	BOOL			IsDie() { return (m_dwState & OBJSTA_DIE_ALL) ? TRUE : FALSE; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?IsDie@CAction@@QAEHXZ ENDP				; CAction::IsDie
_TEXT	ENDS
PUBLIC	?SetFlightLv@CMover@@QAEXJ@Z			; CMover::SetFlightLv
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
;	COMDAT ?SetFlightLv@CMover@@QAEXJ@Z
_TEXT	SEGMENT
_nFlightLv$ = 8						; size = 4
?SetFlightLv@CMover@@QAEXJ@Z PROC NEAR			; CMover::SetFlightLv, COMDAT
; _this$ = ecx

; 558  : 	void	SetFlightLv( LONG nFlightLv )	{}

  00000	c2 04 00	 ret	 4
?SetFlightLv@CMover@@QAEXJ@Z ENDP			; CMover::SetFlightLv
_TEXT	ENDS
PUBLIC	?GetSpeedFactor@CMover@@QAEMXZ			; CMover::GetSpeedFactor
; Function compile flags: /Ogty
;	COMDAT ?GetSpeedFactor@CMover@@QAEMXZ
_TEXT	SEGMENT
?GetSpeedFactor@CMover@@QAEMXZ PROC NEAR		; CMover::GetSpeedFactor, COMDAT
; _this$ = ecx

; 628  : 	FLOAT	GetSpeedFactor( void )	{	return m_fSpeedFactor;	}

  00000	d9 81 10 07 00
	00		 fld	 DWORD PTR [ecx+1808]
  00006	c3		 ret	 0
?GetSpeedFactor@CMover@@QAEMXZ ENDP			; CMover::GetSpeedFactor
_TEXT	ENDS
PUBLIC	?HasActivatedEatPet@CMover@@QAEHXZ		; CMover::HasActivatedEatPet
; Function compile flags: /Ogty
;	COMDAT ?HasActivatedEatPet@CMover@@QAEHXZ
_TEXT	SEGMENT
?HasActivatedEatPet@CMover@@QAEHXZ PROC NEAR		; CMover::HasActivatedEatPet, COMDAT
; _this$ = ecx

; 827  : 	BOOL	HasActivatedEatPet( void )		{	return m_oiEatPet != NULL_ID;	}

  00000	8b 91 7c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1660]
  00006	33 c0		 xor	 eax, eax
  00008	83 fa ff	 cmp	 edx, -1
  0000b	0f 95 c0	 setne	 al
  0000e	c3		 ret	 0
?HasActivatedEatPet@CMover@@QAEHXZ ENDP			; CMover::HasActivatedEatPet
_TEXT	ENDS
PUBLIC	?IsPlayer@CMover@@QAEHXZ			; CMover::IsPlayer
; Function compile flags: /Ogty
;	COMDAT ?IsPlayer@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsPlayer@CMover@@QAEHXZ PROC NEAR			; CMover::IsPlayer, COMDAT
; _this$ = ecx

; 1042 : 	BOOL			IsPlayer()			{ return m_bPlayer; }

  00000	8b 81 34 02 00
	00		 mov	 eax, DWORD PTR [ecx+564]
  00006	c3		 ret	 0
?IsPlayer@CMover@@QAEHXZ ENDP				; CMover::IsPlayer
_TEXT	ENDS
PUBLIC	?GetPropA@CMover@@QAEPAUMoverProp@@XZ		; CMover::GetPropA
; Function compile flags: /Ogty
;	COMDAT ?GetPropA@CMover@@QAEPAUMoverProp@@XZ
_TEXT	SEGMENT
?GetPropA@CMover@@QAEPAUMoverProp@@XZ PROC NEAR		; CMover::GetPropA, COMDAT
; _this$ = ecx

; 1046 : 	MoverProp*		GetProp() { return prj.GetMoverProp( m_dwIndex ); }	//    	

  00000	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  00006	85 c0		 test	 eax, eax
  00008	8b 0d d0 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+464
  0000e	7c 13		 jl	 SHORT $L282988
  00010	3b c1		 cmp	 eax, ecx
  00012	7d 0f		 jge	 SHORT $L282988
  00014	8b 0d d4 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+468
  0001a	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  00020	03 c1		 add	 eax, ecx
  00022	c3		 ret	 0
$L282988:
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00031	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00036	83 c4 14	 add	 esp, 20			; 00000014H
  00039	33 c0		 xor	 eax, eax
  0003b	c3		 ret	 0
?GetPropA@CMover@@QAEPAUMoverProp@@XZ ENDP		; CMover::GetPropA
_TEXT	ENDS
PUBLIC	?ClearDestObj@CMover@@QAEXXZ			; CMover::ClearDestObj
; Function compile flags: /Ogty
;	COMDAT ?ClearDestObj@CMover@@QAEXXZ
_TEXT	SEGMENT
?ClearDestObj@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDestObj, COMDAT
; _this$ = ecx

; 1056 : 	void			ClearDestObj()     	{ m_idDest = NULL_ID; m_fArrivalRange = 0.0f; }

  00000	c7 81 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+604], -1
  0000a	c7 81 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+600], 0
  00014	c3		 ret	 0
?ClearDestObj@CMover@@QAEXXZ ENDP			; CMover::ClearDestObj
_TEXT	ENDS
PUBLIC	?ClearDestPos@CMover@@QAEXXZ			; CMover::ClearDestPos
; Function compile flags: /Ogty
;	COMDAT ?ClearDestPos@CMover@@QAEXXZ
_TEXT	SEGMENT
$T283001 = -12						; size = 12
?ClearDestPos@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDestPos, COMDAT
; _this$ = ecx

; 1057 : 	void			ClearDestPos()		{ m_vDestPos = D3DXVECTOR3( 0.0f, 0.0f, 0.0f ); }		

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	c7 04 24 00 00
	00 00		 mov	 DWORD PTR $T283001[esp+12], 0
  0000a	8b 04 24	 mov	 eax, DWORD PTR $T283001[esp+12]
  0000d	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  00013	89 01		 mov	 DWORD PTR [ecx], eax
  00015	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T283001[esp+16], 0
  0001d	8b 54 24 04	 mov	 edx, DWORD PTR $T283001[esp+16]
  00021	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T283001[esp+20], 0
  00029	8b 44 24 08	 mov	 eax, DWORD PTR $T283001[esp+20]
  0002d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00030	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	c3		 ret	 0
?ClearDestPos@CMover@@QAEXXZ ENDP			; CMover::ClearDestPos
_TEXT	ENDS
PUBLIC	?ClearDest@CMover@@QAEXXZ			; CMover::ClearDest
; Function compile flags: /Ogty
;	COMDAT ?ClearDest@CMover@@QAEXXZ
_TEXT	SEGMENT
$T283017 = -12						; size = 12
?ClearDest@CMover@@QAEXXZ PROC NEAR			; CMover::ClearDest, COMDAT
; _this$ = ecx

; 1058 : 	void			ClearDest()			{ ClearDestObj(); ClearDestPos(); }

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	c7 81 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+604], -1
  0000d	c7 81 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+600], 0
  00017	c7 04 24 00 00
	00 00		 mov	 DWORD PTR $T283017[esp+12], 0
  0001e	8b 04 24	 mov	 eax, DWORD PTR $T283017[esp+12]
  00021	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  00027	89 01		 mov	 DWORD PTR [ecx], eax
  00029	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T283017[esp+16], 0
  00031	8b 54 24 04	 mov	 edx, DWORD PTR $T283017[esp+16]
  00035	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T283017[esp+20], 0
  0003d	8b 44 24 08	 mov	 eax, DWORD PTR $T283017[esp+20]
  00041	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00044	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	c3		 ret	 0
?ClearDest@CMover@@QAEXXZ ENDP				; CMover::ClearDest
_TEXT	ENDS
PUBLIC	?ClearDestAngle@CMover@@QAEXXZ			; CMover::ClearDestAngle
; Function compile flags: /Ogty
;	COMDAT ?ClearDestAngle@CMover@@QAEXXZ
_TEXT	SEGMENT
?ClearDestAngle@CMover@@QAEXXZ PROC NEAR		; CMover::ClearDestAngle, COMDAT
; _this$ = ecx

; 1065 : 	void			ClearDestAngle()	{ m_fDestAngle	= -1.0f; }

  00000	c7 81 6c 02 00
	00 00 00 80 bf	 mov	 DWORD PTR [ecx+620], -1082130432 ; bf800000H
  0000a	c3		 ret	 0
?ClearDestAngle@CMover@@QAEXXZ ENDP			; CMover::ClearDestAngle
_TEXT	ENDS
PUBLIC	?GetLevel@CMover@@QAEHXZ			; CMover::GetLevel
; Function compile flags: /Ogty
;	COMDAT ?GetLevel@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetLevel@CMover@@QAEHXZ PROC NEAR			; CMover::GetLevel, COMDAT
; _this$ = ecx

; 1159 : 	int				GetLevel() { return m_nLevel; }

  00000	8b 81 e0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1504]
  00006	c3		 ret	 0
?GetLevel@CMover@@QAEHXZ ENDP				; CMover::GetLevel
_TEXT	ENDS
PUBLIC	?GetExp1@CMover@@QAE_JXZ			; CMover::GetExp1
; Function compile flags: /Ogty
;	COMDAT ?GetExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT
?GetExp1@CMover@@QAE_JXZ PROC NEAR			; CMover::GetExp1, COMDAT
; _this$ = ecx

; 1162 : 	EXPINTEGER		GetExp1()	{	return m_nExp1;	}

  00000	8b 81 e8 05 00
	00		 mov	 eax, DWORD PTR [ecx+1512]
  00006	8b 91 ec 05 00
	00		 mov	 edx, DWORD PTR [ecx+1516]
  0000c	c3		 ret	 0
?GetExp1@CMover@@QAE_JXZ ENDP				; CMover::GetExp1
_TEXT	ENDS
PUBLIC	?GetMaxExp1@CMover@@QAE_JXZ			; CMover::GetMaxExp1
; Function compile flags: /Ogty
;	COMDAT ?GetMaxExp1@CMover@@QAE_JXZ
_TEXT	SEGMENT
?GetMaxExp1@CMover@@QAE_JXZ PROC NEAR			; CMover::GetMaxExp1, COMDAT
; _this$ = ecx

; 1163 : 	EXPINTEGER		GetMaxExp1()	{	return prj.m_aExpCharacter[m_nLevel+1].nExp1;	}

  00000	8b 89 e0 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1504]
  00006	c1 e1 05	 shl	 ecx, 5
  00009	8b 81 10 50 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[ecx+20496]
  0000f	8b 91 14 50 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[ecx+20500]
  00015	c3		 ret	 0
?GetMaxExp1@CMover@@QAE_JXZ ENDP			; CMover::GetMaxExp1
_TEXT	ENDS
PUBLIC	?IsDie@CMover@@QAEHXZ				; CMover::IsDie
; Function compile flags: /Ogty
;	COMDAT ?IsDie@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsDie@CMover@@QAEHXZ PROC NEAR				; CMover::IsDie, COMDAT
; _this$ = ecx

; 1276 : 	BOOL			IsDie() { return m_pActMover->IsDie() || m_nHitPoint == 0; }

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  0000d	75 0d		 jne	 SHORT $L283036
  0000f	8b 81 00 06 00
	00		 mov	 eax, DWORD PTR [ecx+1536]
  00015	85 c0		 test	 eax, eax
  00017	74 03		 je	 SHORT $L283036
  00019	33 c0		 xor	 eax, eax
  0001b	c3		 ret	 0
$L283036:
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	c3		 ret	 0
?IsDie@CMover@@QAEHXZ ENDP				; CMover::IsDie
_TEXT	ENDS
PUBLIC	?IsChaotic@CMover@@QAEHXZ			; CMover::IsChaotic
; Function compile flags: /Ogty
;	COMDAT ?IsChaotic@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsChaotic@CMover@@QAEHXZ PROC NEAR			; CMover::IsChaotic, COMDAT
; _this$ = ecx

; 1283 : 	BOOL			IsChaotic( void ) { return m_dwPKPropensity > 0; }	/// 

  00000	8b 91 60 07 00
	00		 mov	 edx, DWORD PTR [ecx+1888]
  00006	33 c0		 xor	 eax, eax
  00008	3b c2		 cmp	 eax, edx
  0000a	1b c0		 sbb	 eax, eax
  0000c	f7 d8		 neg	 eax
  0000e	c3		 ret	 0
?IsChaotic@CMover@@QAEHXZ ENDP				; CMover::IsChaotic
_TEXT	ENDS
PUBLIC	?GetPKPropensity@CMover@@QAEKXZ			; CMover::GetPKPropensity
; Function compile flags: /Ogty
;	COMDAT ?GetPKPropensity@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetPKPropensity@CMover@@QAEKXZ PROC NEAR		; CMover::GetPKPropensity, COMDAT
; _this$ = ecx

; 1287 : 	DWORD			GetPKPropensity( void ) { return m_dwPKPropensity; }

  00000	8b 81 60 07 00
	00		 mov	 eax, DWORD PTR [ecx+1888]
  00006	c3		 ret	 0
?GetPKPropensity@CMover@@QAEKXZ ENDP			; CMover::GetPKPropensity
_TEXT	ENDS
PUBLIC	?IsSMMode@CMover@@QAEHH@Z			; CMover::IsSMMode
; Function compile flags: /Ogty
;	COMDAT ?IsSMMode@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nType$ = 8						; size = 4
?IsSMMode@CMover@@QAEHH@Z PROC NEAR			; CMover::IsSMMode, COMDAT
; _this$ = ecx

; 1483 : 	BOOL			IsSMMode( int nType ) { return ( m_dwSMTime[nType] > 0 ) ? TRUE : FALSE; }

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _nType$[esp-4]
  00004	56		 push	 esi
  00005	8b b4 91 04 03
	00 00		 mov	 esi, DWORD PTR [ecx+edx*4+772]
  0000c	33 c0		 xor	 eax, eax
  0000e	3b c6		 cmp	 eax, esi
  00010	1b c0		 sbb	 eax, eax
  00012	f7 d8		 neg	 eax
  00014	5e		 pop	 esi
  00015	c2 04 00	 ret	 4
?IsSMMode@CMover@@QAEHH@Z ENDP				; CMover::IsSMMode
_TEXT	ENDS
PUBLIC	?IsMode@CMover@@QAEHK@Z				; CMover::IsMode
; Function compile flags: /Ogty
;	COMDAT ?IsMode@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?IsMode@CMover@@QAEHK@Z PROC NEAR			; CMover::IsMode, COMDAT
; _this$ = ecx

; 1763 : #ifdef __HACK_0516
; 1764 : 	switch( dwMode )
; 1765 : 	{
; 1766 : 		case MATCHLESS_MODE:		//  
; 1767 : 		case ONEKILL_MODE:		//  
; 1768 : 		case MATCHLESS2_MODE:	//  2
; 1769 : 			if( m_dwAuthorization == AUTH_GENERAL )
; 1770 : 				return FALSE;
; 1771 : 			break;
; 1772 : 	}
; 1773 : #endif	// __HACK_0516
; 1774 : 	if( (dwMode & TRANSPARENT_MODE) )	//   

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _dwMode$[esp-4]
  00004	f6 c2 02	 test	 dl, 2
  00007	74 13		 je	 SHORT $L212480

; 1775 : 		if( GetAdjParam(DST_CHRSTATE) & CHS_INVISIBILITY )	//  ?

  00009	8b 81 b8 13 00
	00		 mov	 eax, DWORD PTR [ecx+5048]
  0000f	f6 c4 04	 test	 ah, 4
  00012	74 08		 je	 SHORT $L212480

; 1776 : 			return TRUE;

  00014	b8 01 00 00 00	 mov	 eax, 1

; 1778 : }	

  00019	c2 04 00	 ret	 4
$L212480:

; 1777 : 	return ( ( m_dwMode & dwMode ) == dwMode ) ? TRUE : FALSE; 

  0001c	8b 81 44 02 00
	00		 mov	 eax, DWORD PTR [ecx+580]
  00022	23 c2		 and	 eax, edx
  00024	2b c2		 sub	 eax, edx
  00026	f7 d8		 neg	 eax
  00028	1b c0		 sbb	 eax, eax
  0002a	40		 inc	 eax

; 1778 : }	

  0002b	c2 04 00	 ret	 4
?IsMode@CMover@@QAEHK@Z ENDP				; CMover::IsMode
_TEXT	ENDS
PUBLIC	?IsFly@CMover@@QAEHXZ				; CMover::IsFly
; Function compile flags: /Ogty
;	COMDAT ?IsFly@CMover@@QAEHXZ
_TEXT	SEGMENT
?IsFly@CMover@@QAEHXZ PROC NEAR				; CMover::IsFly, COMDAT
; _this$ = ecx

; 1787 : #ifdef _DEBUG
; 1788 : 	if( IsNPC() )
; 1789 : 	{
; 1790 : 		Error( _T( "CMover::IsFly : NPC IsFly()  . IsFlyingNPC() ! %s" ), m_szName );
; 1791 : 		return FALSE;
; 1792 : 	}
; 1793 : #endif
; 1794 : 	return m_pActMover->IsFly();

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00009	c1 e8 03	 shr	 eax, 3
  0000c	83 e0 01	 and	 eax, 1

; 1795 : }

  0000f	c3		 ret	 0
?IsFly@CMover@@QAEHXZ ENDP				; CMover::IsFly
_TEXT	ENDS
PUBLIC	?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z	; CMover::SendActMsg
; Function compile flags: /Ogty
;	COMDAT ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z
_TEXT	SEGMENT
_dwMsg$ = 8						; size = 4
_nParam1$ = 12						; size = 4
_nParam2$ = 16						; size = 4
_nParam3$ = 20						; size = 4
_nParam4$ = 24						; size = 4
?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z PROC NEAR	; CMover::SendActMsg, COMDAT
; _this$ = ecx

; 1820 : 	if( m_pActMover )	

  00000	8b 81 3c 02 00
	00		 mov	 eax, DWORD PTR [ecx+572]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $L212505

; 1821 : 		return m_pActMover->SendActMsg( dwMsg, nParam1, nParam2, nParam3, nParam4 );	

  0000a	8b 54 24 14	 mov	 edx, DWORD PTR _nParam4$[esp-4]
  0000e	6a 00		 push	 0
  00010	52		 push	 edx
  00011	8b 54 24 18	 mov	 edx, DWORD PTR _nParam3$[esp+4]
  00015	52		 push	 edx
  00016	8b 54 24 18	 mov	 edx, DWORD PTR _nParam2$[esp+8]
  0001a	52		 push	 edx
  0001b	8b 54 24 18	 mov	 edx, DWORD PTR _nParam1$[esp+12]
  0001f	52		 push	 edx
  00020	8b 54 24 18	 mov	 edx, DWORD PTR _dwMsg$[esp+16]
  00024	8b c8		 mov	 ecx, eax
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	52		 push	 edx
  00029	ff 50 04	 call	 DWORD PTR [eax+4]

; 1824 : }

  0002c	c2 14 00	 ret	 20			; 00000014H
$L212505:

; 1822 : 	else
; 1823 : 		return 0;

  0002f	33 c0		 xor	 eax, eax

; 1824 : }

  00031	c2 14 00	 ret	 20			; 00000014H
?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z ENDP		; CMover::SendActMsg
_TEXT	ENDS
PUBLIC	?GetGold@CMover@@QAEHXZ				; CMover::GetGold
; Function compile flags: /Ogty
;	COMDAT ?GetGold@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetGold@CMover@@QAEHXZ PROC NEAR			; CMover::GetGold, COMDAT
; _this$ = ecx

; 1829 : 	int nGold = m_dwGold;
; 1830 : //	nGold -= m_vtInfo.TradeGetGold();
; 1831 : 	ASSERT( nGold >= 0 );
; 1832 : 	return nGold;

  00000	8b 81 84 16 00
	00		 mov	 eax, DWORD PTR [ecx+5764]

; 1833 : }

  00006	c3		 ret	 0
?GetGold@CMover@@QAEHXZ ENDP				; CMover::GetGold
_TEXT	ENDS
PUBLIC	?SetGold@CMover@@QAEXH@Z			; CMover::SetGold
; Function compile flags: /Ogty
;	COMDAT ?SetGold@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nGold$ = 8						; size = 4
?SetGold@CMover@@QAEXH@Z PROC NEAR			; CMover::SetGold, COMDAT
; _this$ = ecx

; 1837 : 	ASSERT( nGold >= 0 );
; 1838 : 	m_dwGold = (DWORD)nGold;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nGold$[esp-4]
  00004	89 81 84 16 00
	00		 mov	 DWORD PTR [ecx+5764], eax

; 1839 : }

  0000a	c2 04 00	 ret	 4
?SetGold@CMover@@QAEXH@Z ENDP				; CMover::SetGold
_TEXT	ENDS
PUBLIC	?GetID@CWorld@@QAEKXZ				; CWorld::GetID
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\world.h
;	COMDAT ?GetID@CWorld@@QAEKXZ
_TEXT	SEGMENT
?GetID@CWorld@@QAEKXZ PROC NEAR				; CWorld::GetID, COMDAT
; _this$ = ecx

; 413  : 	DWORD			GetID()	{ return m_dwWorldID; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetID@CWorld@@QAEKXZ ENDP				; CWorld::GetID
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1109 : 		return (_Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1110 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ	; CFixedArray<ItemProp>::GetSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ
_TEXT	SEGMENT
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ PROC NEAR	; CFixedArray<ItemProp>::GetSize, COMDAT
; _this$ = ecx

; 221  : 	int  GetSize() { return m_nMaxIndex; }

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetSize@?$CFixedArray@UItemProp@@@@QAEHXZ ENDP		; CFixedArray<ItemProp>::GetSize
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L283085
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  00009	c3		 ret	 0
$L283085:

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1538 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	8b c1		 mov	 eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogty
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	8b c1		 mov	 eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC NEAR			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 139  : 		return (_Left < _Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 54 24 08	 mov	 edx, DWORD PTR __Right$[esp-4]
  0000a	56		 push	 esi
  0000b	8b 32		 mov	 esi, DWORD PTR [edx]
  0000d	33 c0		 xor	 eax, eax
  0000f	3b ce		 cmp	 ecx, esi
  00011	0f 9c c0	 setl	 al
  00014	5e		 pop	 esi

; 140  : 		}

  00015	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogty
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 284  : 			return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ; std::vector<long,std::allocator<long> >::size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ PROC NEAR ; std::vector<long,std::allocator<long> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L283105
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L283105:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ENDP	; std::vector<long,std::allocator<long> >::size
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 242  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L283122
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  00009	c3		 ret	 0
$L283122:

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1533 : 		}

  0000d	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Isnil
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Isnil, COMDAT

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00007	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Left
; Function compile flags: /Ogty
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Left, COMDAT

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]

; 148  : 		}

  00004	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Parent
; Function compile flags: /Ogty
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Right
; Function compile flags: /Ogty
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Right, COMDAT

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 08	 add	 eax, 8

; 158  : 		}

  00007	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHK@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHK@2@@Z ; std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0>::_Kfn
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHK@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHK@2@@Z PROC NEAR ; std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0>::_Kfn, COMDAT

; 64   : 		return (_Val.first);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 65   : 		}

  00004	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHK@2@@Z ENDP ; std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHK@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHK@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHK@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHK@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ; std::vector<long,std::allocator<long> >::capacity
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ PROC NEAR ; std::vector<long,std::allocator<long> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L283157
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L283157:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ENDP ; std::vector<long,std::allocator<long> >::capacity
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@J@std@@QAEXPAJI@Z	; std::allocator<long>::deallocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@J@std@@QAEXPAJI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@J@std@@QAEXPAJI@Z PROC NEAR	; std::allocator<long>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	59		 pop	 ecx

; 133  : 		}

  0000b	c2 08 00	 ret	 8
?deallocate@?$allocator@J@std@@QAEXPAJI@Z ENDP		; std::allocator<long>::deallocate
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent, COMDAT

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 04	 add	 eax, 4

; 153  : 		}

  00007	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval
; Function compile flags: /Ogty
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval, COMDAT

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00007	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBKPAVIBuff@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost
; Function compile flags: /Ogty
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1005 : 		return (_Left(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z ; std::vector<long,std::allocator<long> >::iterator::operator+=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<long,std::allocator<long> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@JV?$allocator@J@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<long,std::allocator<long> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	56		 push	 esi

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  00001	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  00004	83 fe 10	 cmp	 esi, 16			; 00000010H
  00007	57		 push	 edi
  00008	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0000b	72 04		 jb	 SHORT $L283189
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	eb 02		 jmp	 SHORT $L283190
$L283189:
  00011	8b d0		 mov	 edx, eax
$L283190:
  00013	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  00017	3b fa		 cmp	 edi, edx
  00019	72 17		 jb	 SHORT $L222788
  0001b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0001e	72 02		 jb	 SHORT $L283197
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L283197:
  00022	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00025	03 c8		 add	 ecx, eax
  00027	3b cf		 cmp	 ecx, edi
  00029	76 07		 jbe	 SHORT $L222788
  0002b	5f		 pop	 edi

; 1497 : 		else
; 1498 : 			return (true);

  0002c	b0 01		 mov	 al, 1
  0002e	5e		 pop	 esi

; 1499 : 		}

  0002f	c2 04 00	 ret	 4
$L222788:
  00032	5f		 pop	 edi

; 1496 : 			return (false);	// don't ask

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 1499 : 		}

  00036	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Root
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@J@std@@QBEIXZ		; std::allocator<long>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@J@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@J@std@@QBEIXZ PROC NEAR		; std::allocator<long>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@J@std@@QBEIXZ ENDP		; std::allocator<long>::max_size
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ; std::vector<long,std::allocator<long> >::const_iterator::const_iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ENDP ; std::vector<long,std::allocator<long> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ; std::vector<long,std::allocator<long> >::const_iterator::operator==
; Function compile flags: /Ogty
;	COMDAT ??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<long,std::allocator<long> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Right$[esp-4]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	40		 inc	 eax

; 156  : 			}

  0000d	c2 04 00	 ret	 4
??8const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<long,std::allocator<long> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 159  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ; CFixedArray<ItemProp>::GetAt
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
;	COMDAT ?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z PROC NEAR ; CFixedArray<ItemProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224299

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224299:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UItemProp@@@@QAEPAUItemProp@@K@Z ENDP ; CFixedArray<ItemProp>::GetAt
_TEXT	ENDS
PUBLIC	?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z ; CFixedArray<QuestProp>::GetAt
; Function compile flags: /Ogty
;	COMDAT ?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z PROC NEAR ; CFixedArray<QuestProp>::GetAt, COMDAT
; _this$ = ecx

; 270  : 	if( dwIndex >= (DWORD)m_nMaxIndex )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwIndex$[esp-4]
  00004	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00007	72 05		 jb	 SHORT $L224391

; 271  : 		return NULL;

  00009	33 c0		 xor	 eax, eax

; 273  : }

  0000b	c2 04 00	 ret	 4
$L224391:

; 272  : 	return (T*) m_apOffset[ dwIndex ];

  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 273  : }

  00014	c2 04 00	 ret	 4
?GetAt@?$CFixedArray@UQuestProp@@@@QAEPAUQuestProp@@K@Z ENDP ; CFixedArray<QuestProp>::GetAt
_TEXT	ENDS
PUBLIC	?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ; CItemContainer<CItemElem>::GetAtId
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z
_TEXT	SEGMENT
_dwId$ = 8						; size = 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z PROC NEAR ; CItemContainer<CItemElem>::GetAtId, COMDAT
; _this$ = ecx

; 518  : 	if( dwId >= (DWORD)( GetMax() ) ) return NULL;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwId$[esp-4]
  00004	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00007	72 05		 jb	 SHORT $L224421
  00009	33 c0		 xor	 eax, eax

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  0000b	c2 04 00	 ret	 4
$L224421:

; 519  : 	T* pItemElem = &m_apItem[ dwId ];

  0000e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00011	69 c0 b8 00 00
	00		 imul	 eax, 184		; 000000b8H
  00017	03 c2		 add	 eax, edx
  00019	8b c8		 mov	 ecx, eax

; 520  : 	if( pItemElem->IsEmpty() ) 

  0001b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001e	f7 d8		 neg	 eax
  00020	1b c0		 sbb	 eax, eax
  00022	23 c1		 and	 eax, ecx

; 521  : 		return NULL;
; 522  : 	return pItemElem;
; 523  : }

  00024	c2 04 00	 ret	 4
?GetAtId@?$CItemContainer@VCItemElem@@@@QAEPAVCItemElem@@K@Z ENDP ; CItemContainer<CItemElem>::GetAtId
_TEXT	ENDS
PUBLIC	??$copy@PAJPAJ@std@@YAPAJPAJ00@Z		; std::copy<long *,long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$copy@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy@PAJPAJ@std@@YAPAJPAJ00@Z PROC NEAR		; std::copy<long *,long *>, COMDAT

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1041 : 	}

  00027	c3		 ret	 0
??$copy@PAJPAJ@std@@YAPAJPAJ00@Z ENDP			; std::copy<long *,long *>
_TEXT	ENDS
PUBLIC	??$fill@PAJJ@std@@YAXPAJ0ABJ@Z			; std::fill<long *,long>
; Function compile flags: /Ogty
;	COMDAT ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAJJ@std@@YAXPAJ0ABJ@Z PROC NEAR		; std::fill<long *,long>, COMDAT

; 1135 : 	for (; _First != _Last; ++_First)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	3b c1		 cmp	 eax, ecx
  0000a	74 11		 je	 SHORT $L225012
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L225010:

; 1136 : 		*_First = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	3b c1		 cmp	 eax, ecx
  0001a	75 f5		 jne	 SHORT $L225010
  0001c	5e		 pop	 esi
$L225012:

; 1137 : 	}

  0001d	c3		 ret	 0
??$fill@PAJJ@std@@YAXPAJ0ABJ@Z ENDP			; std::fill<long *,long>
_TEXT	ENDS
PUBLIC	??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z	; std::copy_backward<long *,long *>
; Function compile flags: /Ogty
;	COMDAT ??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z PROC NEAR	; std::copy_backward<long *,long *>, COMDAT

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	c1 e0 02	 shl	 eax, 2
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR __Dest$[esp+4]
  00016	2b c8		 sub	 ecx, eax
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memmove
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1070 : 	}

  00021	c3		 ret	 0
??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z ENDP		; std::copy_backward<long *,long *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z ; std::_Destroy_range<long,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z PROC NEAR ; std::_Destroy_range<long,std::allocator<long> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@@Z ENDP ; std::_Destroy_range<long,std::allocator<long> >
_TEXT	ENDS
PUBLIC	??$_Allocate@J@std@@YAPAJIPAJ@Z			; std::_Allocate<long>
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@J@std@@YAPAJIPAJ@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@J@std@@YAPAJIPAJ@Z PROC NEAR		; std::_Allocate<long>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 35   : 	}

  00014	c3		 ret	 0
??$_Allocate@J@std@@YAPAJIPAJ@Z ENDP			; std::_Allocate<long>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogty
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
EXTRN	__time64:NEAR
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC NEAR		; ATL::CTime::GetTickCount, COMDAT

; 139  : 	return( CTime( ::_time64( NULL ) ) );

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	83 c4 04	 add	 esp, 4
  00010	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00013	8b c1		 mov	 eax, ecx

; 140  : }

  00015	c2 04 00	 ret	 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
_TEXT	ENDS
PUBLIC	?GetSummonState@CMover@@QAEHXZ			; CMover::GetSummonState
EXTRN	?IsAttackMode@CMover@@QAEHXZ:NEAR		; CMover::IsAttackMode
EXTRN	?GetOther@CVTInfo@@QAEPAVCMover@@XZ:NEAR	; CVTInfo::GetOther
EXTRN	?IsVendorOpen@CVTInfo@@QAEHXZ:NEAR		; CVTInfo::IsVendorOpen
EXTRN	?VendorIsVendor@CVTInfo@@QAEHXZ:NEAR		; CVTInfo::VendorIsVendor
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
;	COMDAT ?GetSummonState@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetSummonState@CMover@@QAEHXZ PROC NEAR		; CMover::GetSummonState, COMDAT
; _this$ = ecx

; 330  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 331  : 	// 
; 332  : 	if( m_vtInfo.GetOther() != NULL )

  00004	8d be 7c 0d 00
	00		 lea	 edi, DWORD PTR [esi+3452]
  0000a	8b cf		 mov	 ecx, edi
  0000c	e8 00 00 00 00	 call	 ?GetOther@CVTInfo@@QAEPAVCMover@@XZ ; CVTInfo::GetOther
  00011	85 c0		 test	 eax, eax

; 333  : 		return 1;

  00013	75 14		 jne	 SHORT $L283313

; 334  : 	  // 
; 335  : 	if( m_bBank )

  00015	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  0001b	85 c0		 test	 eax, eax

; 336  : 		return 1;

  0001d	75 0a		 jne	 SHORT $L283313

; 337  : 	  // 
; 338  : 	if( m_bGuildBank )

  0001f	8b 86 20 07 00
	00		 mov	 eax, DWORD PTR [esi+1824]
  00025	85 c0		 test	 eax, eax
  00027	74 08		 je	 SHORT $L275207
$L283313:
  00029	5f		 pop	 edi

; 339  : 		return 1;

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	5e		 pop	 esi

; 360  : 		return 6;
; 361  : #endif // __VER >= 8 // 8  061226 ma
; 362  : 
; 363  : 
; 364  : 	return 0;
; 365  : }

  00030	c3		 ret	 0
$L275207:

; 340  : 
; 341  : 	// 
; 342  : 	if( IsDie() )

  00031	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  00037	f7 40 04 00 00
	00 08		 test	 DWORD PTR [eax+4], 134217728 ; 08000000H
  0003e	75 0a		 jne	 SHORT $L283300
  00040	8b 86 00 06 00
	00		 mov	 eax, DWORD PTR [esi+1536]
  00046	85 c0		 test	 eax, eax
  00048	75 08		 jne	 SHORT $L275208
$L283300:
  0004a	5f		 pop	 edi

; 343  : 		return 2;

  0004b	b8 02 00 00 00	 mov	 eax, 2
  00050	5e		 pop	 esi

; 360  : 		return 6;
; 361  : #endif // __VER >= 8 // 8  061226 ma
; 362  : 
; 363  : 
; 364  : 	return 0;
; 365  : }

  00051	c3		 ret	 0
$L275208:

; 344  : 
; 345  : 	// 
; 346  : 	if( m_vtInfo.VendorIsVendor() || m_vtInfo.IsVendorOpen() )

  00052	8b cf		 mov	 ecx, edi
  00054	e8 00 00 00 00	 call	 ?VendorIsVendor@CVTInfo@@QAEHXZ ; CVTInfo::VendorIsVendor
  00059	85 c0		 test	 eax, eax
  0005b	75 42		 jne	 SHORT $L275210
  0005d	8b cf		 mov	 ecx, edi
  0005f	e8 00 00 00 00	 call	 ?IsVendorOpen@CVTInfo@@QAEHXZ ; CVTInfo::IsVendorOpen
  00064	85 c0		 test	 eax, eax
  00066	75 37		 jne	 SHORT $L275210

; 348  : 
; 349  : 	// 
; 350  : 	if( IsAttackMode() )

  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?IsAttackMode@CMover@@QAEHXZ ; CMover::IsAttackMode
  0006f	85 c0		 test	 eax, eax
  00071	74 08		 je	 SHORT $L275211
  00073	5f		 pop	 edi

; 351  : 		return 4;

  00074	b8 04 00 00 00	 mov	 eax, 4
  00079	5e		 pop	 esi

; 360  : 		return 6;
; 361  : #endif // __VER >= 8 // 8  061226 ma
; 362  : 
; 363  : 
; 364  : 	return 0;
; 365  : }

  0007a	c3		 ret	 0
$L275211:

; 352  : 	
; 353  : 	// 
; 354  : 	if( ( IsFly() ) )

  0007b	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00081	f6 41 08 08	 test	 BYTE PTR [ecx+8], 8
  00085	74 08		 je	 SHORT $L275212
  00087	5f		 pop	 edi

; 355  : 		return 5;

  00088	b8 05 00 00 00	 mov	 eax, 5
  0008d	5e		 pop	 esi

; 360  : 		return 6;
; 361  : #endif // __VER >= 8 // 8  061226 ma
; 362  : 
; 363  : 
; 364  : 	return 0;
; 365  : }

  0008e	c3		 ret	 0
$L275212:

; 356  : 
; 357  : 
; 358  : #if __VER >= 8 // 8  061226 ma
; 359  : 	if( m_nDuel )

  0008f	8b 86 44 07 00
	00		 mov	 eax, DWORD PTR [esi+1860]
  00095	f7 d8		 neg	 eax
  00097	1b c0		 sbb	 eax, eax
  00099	5f		 pop	 edi
  0009a	83 e0 06	 and	 eax, 6
  0009d	5e		 pop	 esi

; 360  : 		return 6;
; 361  : #endif // __VER >= 8 // 8  061226 ma
; 362  : 
; 363  : 
; 364  : 	return 0;
; 365  : }

  0009e	c3		 ret	 0
$L275210:
  0009f	5f		 pop	 edi

; 347  : 		return 3;

  000a0	b8 03 00 00 00	 mov	 eax, 3
  000a5	5e		 pop	 esi

; 360  : 		return 6;
; 361  : #endif // __VER >= 8 // 8  061226 ma
; 362  : 
; 363  : 
; 364  : 	return 0;
; 365  : }

  000a6	c3		 ret	 0
?GetSummonState@CMover@@QAEHXZ ENDP			; CMover::GetSummonState
_TEXT	ENDS
PUBLIC	?IsJobType@CMover@@QAEHK@Z			; CMover::IsJobType
; Function compile flags: /Ogty
;	COMDAT ?IsJobType@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwJobType$ = 8						; size = 4
?IsJobType@CMover@@QAEHK@Z PROC NEAR			; CMover::IsJobType, COMDAT
; _this$ = ecx

; 380  : 	if( IsExpert() )

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 0c c0	 lea	 ecx, DWORD PTR [eax+eax*8]
  00009	8b 14 cd e0 27
	00 00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[ecx*8+10208]

; 381  : 	{
; 382  : 		if( dwJobType == JTYPE_EXPERT ) 

  00010	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwJobType$[esp-4]
  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	3b d0		 cmp	 edx, eax
  0001b	75 0c		 jne	 SHORT $L275218
  0001d	33 d2		 xor	 edx, edx
  0001f	3b c8		 cmp	 ecx, eax
  00021	0f 94 c2	 sete	 dl
  00024	8b c2		 mov	 eax, edx

; 387  : }

  00026	c2 04 00	 ret	 4
$L275218:

; 383  : 			return TRUE;
; 384  : 		return FALSE;
; 385  : 	}
; 386  : 	return JTYPE_BASE == dwJobType;

  00029	33 c0		 xor	 eax, eax
  0002b	85 c9		 test	 ecx, ecx
  0002d	0f 94 c0	 sete	 al

; 387  : }

  00030	c2 04 00	 ret	 4
?IsJobType@CMover@@QAEHK@Z ENDP				; CMover::IsJobType
_TEXT	ENDS
PUBLIC	?GetLegendChar@CMover@@QAEEXZ			; CMover::GetLegendChar
; Function compile flags: /Ogty
;	COMDAT ?GetLegendChar@CMover@@QAEEXZ
_TEXT	SEGMENT
?GetLegendChar@CMover@@QAEEXZ PROC NEAR			; CMover::GetLegendChar, COMDAT
; _this$ = ecx

; 404  : 	if(IsMaster())

  00000	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00006	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00009	8b 04 c5 e0 27
	00 00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00010	83 f8 05	 cmp	 eax, 5
  00013	75 03		 jne	 SHORT $L275232

; 405  : 		return LEGEND_CLASS_MASTER;

  00015	b0 01		 mov	 al, 1

; 410  : 		return LEGEND_CLASS_LEGENDHERO;
; 411  : #endif //  __3RD_LEGEND16
; 412  : 	else
; 413  : 		return LEGEND_CLASS_NORMAL;
; 414  : }

  00017	c3		 ret	 0
$L275232:

; 406  : 	else if(IsHero())

  00018	83 f8 06	 cmp	 eax, 6
  0001b	75 03		 jne	 SHORT $L275234

; 407  : 		return	LEGEND_CLASS_HERO;

  0001d	b0 02		 mov	 al, 2

; 410  : 		return LEGEND_CLASS_LEGENDHERO;
; 411  : #endif //  __3RD_LEGEND16
; 412  : 	else
; 413  : 		return LEGEND_CLASS_NORMAL;
; 414  : }

  0001f	c3		 ret	 0
$L275234:

; 408  : #ifdef __3RD_LEGEND16
; 409  : 	else if(IsLegendHero())

  00020	83 f8 07	 cmp	 eax, 7
  00023	0f 95 c0	 setne	 al
  00026	fe c8		 dec	 al
  00028	83 e0 03	 and	 eax, 3

; 410  : 		return LEGEND_CLASS_LEGENDHERO;
; 411  : #endif //  __3RD_LEGEND16
; 412  : 	else
; 413  : 		return LEGEND_CLASS_NORMAL;
; 414  : }

  0002b	c3		 ret	 0
?GetLegendChar@CMover@@QAEEXZ ENDP			; CMover::GetLegendChar
_TEXT	ENDS
PUBLIC	?GetExpPercent@CMover@@QAEHXZ			; CMover::GetExpPercent
EXTRN	__alldiv:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetExpPercent@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetExpPercent@CMover@@QAEHXZ PROC NEAR			; CMover::GetExpPercent, COMDAT
; _this$ = ecx

; 535  : 	int nExpPercent = 0;
; 536  : 
; 537  : 	nExpPercent = (int)( GetExp1() * 10000 / GetMaxExp1() );

  00000	8b 81 ec 05 00
	00		 mov	 eax, DWORD PTR [ecx+1516]
  00006	56		 push	 esi
  00007	8b b1 e0 05 00
	00		 mov	 esi, DWORD PTR [ecx+1504]
  0000d	8b 89 e8 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1512]
  00013	6a 00		 push	 0
  00015	68 10 27 00 00	 push	 10000			; 00002710H
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	c1 e6 05	 shl	 esi, 5
  0001f	e8 00 00 00 00	 call	 __allmul
  00024	8b 8e 14 50 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[esi+20500]
  0002a	51		 push	 ecx
  0002b	8b 8e 10 50 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[esi+20496]
  00031	51		 push	 ecx
  00032	52		 push	 edx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 __alldiv
  00039	5e		 pop	 esi

; 538  : 
; 539  : 	return nExpPercent; 
; 540  : }

  0003a	c3		 ret	 0
?GetExpPercent@CMover@@QAEHXZ ENDP			; CMover::GetExpPercent
_TEXT	ENDS
PUBLIC	?GetAdjHitRate@CMover@@QAEHXZ			; CMover::GetAdjHitRate
; Function compile flags: /Ogty
;	COMDAT ?GetAdjHitRate@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetAdjHitRate@CMover@@QAEHXZ PROC NEAR			; CMover::GetAdjHitRate, COMDAT
; _this$ = ecx

; 551  : 	return GetParam( DST_ADJ_HITRATE, m_nAdjHitRate );

  00000	8b 81 48 15 00
	00		 mov	 eax, DWORD PTR [ecx+5448]
  00006	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000b	8b 91 18 06 00
	00		 mov	 edx, DWORD PTR [ecx+1560]
  00011	75 0f		 jne	 SHORT $L283361
  00013	8b 89 74 13 00
	00		 mov	 ecx, DWORD PTR [ecx+4980]
  00019	85 c9		 test	 ecx, ecx
  0001b	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0001e	75 02		 jne	 SHORT $L283361
  00020	8b c2		 mov	 eax, edx
$L283361:

; 552  : }

  00022	c3		 ret	 0
?GetAdjHitRate@CMover@@QAEHXZ ENDP			; CMover::GetAdjHitRate
_TEXT	ENDS
PUBLIC	?GetParrying@CMover@@QAEHXZ			; CMover::GetParrying
PUBLIC	__real@3f000000
EXTRN	__ftol2:NEAR
;	COMDAT __real@3f000000
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	ENDS
;	COMDAT ?GetParrying@CMover@@QAEHXZ
_TEXT	SEGMENT
$T283442 = -8						; size = 4
_nResult$283417 = -4					; size = 4
?GetParrying@CMover@@QAEHXZ PROC NEAR			; CMover::GetParrying, COMDAT
; _this$ = ecx

; 557  : 	if( IsPlayer() )

  00000	8b 81 34 02 00
	00		 mov	 eax, DWORD PTR [ecx+564]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 94 00 00
	00		 je	 $L275318

; 558  : 		return	( (int)( (GetDex() * 0.5f) + GetParam( DST_PARRY, m_nAdjParry ) ) );

  00011	8b 91 94 14 00
	00		 mov	 edx, DWORD PTR [ecx+5268]
  00017	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  0001d	75 06		 jne	 SHORT $L283407
  0001f	8b 91 c0 12 00
	00		 mov	 edx, DWORD PTR [ecx+4800]
$L283407:
  00025	8b 81 d8 05 00
	00		 mov	 eax, DWORD PTR [ecx+1496]
  0002b	03 c2		 add	 eax, edx
  0002d	83 f8 01	 cmp	 eax, 1
  00030	89 44 24 04	 mov	 DWORD PTR _nResult$283417[esp+8], eax
  00034	7d 08		 jge	 SHORT $L283418
  00036	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR _nResult$283417[esp+8], 1
$L283418:
  0003e	8b 81 90 15 00
	00		 mov	 eax, DWORD PTR [ecx+5520]
  00044	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00049	8b 91 1c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1564]
  0004f	74 18		 je	 SHORT $L283430
  00051	db 44 24 04	 fild	 DWORD PTR _nResult$283417[esp+8]
  00055	89 04 24	 mov	 DWORD PTR $T283442[esp+8], eax
  00058	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0005e	da 04 24	 fiadd	 DWORD PTR $T283442[esp+8]

; 561  : }

  00061	83 c4 08	 add	 esp, 8

; 558  : 		return	( (int)( (GetDex() * 0.5f) + GetParam( DST_PARRY, m_nAdjParry ) ) );

  00064	e9 00 00 00 00	 jmp	 __ftol2
$L283430:
  00069	8b 89 bc 13 00
	00		 mov	 ecx, DWORD PTR [ecx+5052]
  0006f	85 c9		 test	 ecx, ecx
  00071	74 1a		 je	 SHORT $L283432
  00073	db 44 24 04	 fild	 DWORD PTR _nResult$283417[esp+8]
  00077	03 ca		 add	 ecx, edx
  00079	89 0c 24	 mov	 DWORD PTR $T283442[esp+8], ecx
  0007c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00082	da 04 24	 fiadd	 DWORD PTR $T283442[esp+8]

; 561  : }

  00085	83 c4 08	 add	 esp, 8

; 558  : 		return	( (int)( (GetDex() * 0.5f) + GetParam( DST_PARRY, m_nAdjParry ) ) );

  00088	e9 00 00 00 00	 jmp	 __ftol2
$L283432:
  0008d	db 44 24 04	 fild	 DWORD PTR _nResult$283417[esp+8]
  00091	89 14 24	 mov	 DWORD PTR $T283442[esp+8], edx
  00094	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  0009a	da 04 24	 fiadd	 DWORD PTR $T283442[esp+8]

; 561  : }

  0009d	83 c4 08	 add	 esp, 8

; 558  : 		return	( (int)( (GetDex() * 0.5f) + GetParam( DST_PARRY, m_nAdjParry ) ) );

  000a0	e9 00 00 00 00	 jmp	 __ftol2
$L275318:

; 559  : 	else
; 560  : 		return GetProp()->dwER;

  000a5	8b 89 74 01 00
	00		 mov	 ecx, DWORD PTR [ecx+372]
  000ab	85 c9		 test	 ecx, ecx
  000ad	a1 d0 01 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+464
  000b2	7c 18		 jl	 SHORT $L283469
  000b4	3b c8		 cmp	 ecx, eax
  000b6	7d 14		 jge	 SHORT $L283469
  000b8	a1 d4 01 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+468
  000bd	69 c9 d8 06 00
	00		 imul	 ecx, 1752		; 000006d8H
  000c3	03 c8		 add	 ecx, eax
  000c5	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]

; 561  : }

  000c8	83 c4 08	 add	 esp, 8
  000cb	c3		 ret	 0

; 559  : 	else
; 560  : 		return GetProp()->dwER;

$L283469:
  000cc	51		 push	 ecx
  000cd	50		 push	 eax
  000ce	6a 00		 push	 0
  000d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  000d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000da	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000df	83 c4 14	 add	 esp, 20			; 00000014H
  000e2	33 c9		 xor	 ecx, ecx
  000e4	8b 41 78	 mov	 eax, DWORD PTR [ecx+120]

; 561  : }

  000e7	83 c4 08	 add	 esp, 8
  000ea	c3		 ret	 0
?GetParrying@CMover@@QAEHXZ ENDP			; CMover::GetParrying
_TEXT	ENDS
PUBLIC	?ChangeFame@CMover@@QAEXPAV1@@Z			; CMover::ChangeFame
PUBLIC	__real@3c23d70a
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
EXTRN	?AddDefinedText@CUser@@QAAXHPBDZZ:NEAR		; CUser::AddDefinedText
EXTRN	?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z:NEAR	; CUserMng::AddSetFame
EXTRN	?SendLogPkPvp@CDPDatabaseClient@@QAEXPAVCMover@@0HD@Z:NEAR ; CDPDatabaseClient::SendLogPkPvp
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_aiinterface\action.h
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	ENDS
;	COMDAT ?ChangeFame@CMover@@QAEXPAV1@@Z
_TEXT	SEGMENT
_fVal$ = 8						; size = 4
_pLose$ = 8						; size = 4
?ChangeFame@CMover@@QAEXPAV1@@Z PROC NEAR		; CMover::ChangeFame, COMDAT
; _this$ = ecx

; 775  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 776  : 	int nVal = 0;
; 777  : 	float fVal = 0;
; 778  : 	int nGap = 0;
; 779  : 
; 780  : 	nGap = pLose->GetLevel() - GetLevel();		//   

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _pLose$[esp+4]
  00006	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	2b 87 e0 05 00
	00		 sub	 eax, DWORD PTR [edi+1504]

; 781  : 
; 782  : 	if( nGap >= 80 )	    { nVal = 100; fVal = 15.0f; }	//    .

  00015	83 f8 50	 cmp	 eax, 80			; 00000050H
  00018	7c 12		 jl	 SHORT $L275367
  0001a	bb 64 00 00 00	 mov	 ebx, 100		; 00000064H
  0001f	c7 44 24 10 00
	00 70 41	 mov	 DWORD PTR _fVal$[esp+8], 1097859072 ; 41700000H

; 783  : 	else if( nGap >= 30 )	{ nVal = 50;  fVal = 10.0f; }

  00027	e9 9c 00 00 00	 jmp	 $L283505
$L275367:
  0002c	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0002f	7c 12		 jl	 SHORT $L275369
  00031	bb 32 00 00 00	 mov	 ebx, 50			; 00000032H
  00036	c7 44 24 10 00
	00 20 41	 mov	 DWORD PTR _fVal$[esp+8], 1092616192 ; 41200000H

; 784  : 	else if( nGap >= 20 )	{ nVal = 30;  fVal = 8.0f;  }

  0003e	e9 85 00 00 00	 jmp	 $L283505
$L275369:
  00043	83 f8 14	 cmp	 eax, 20			; 00000014H
  00046	7c 0f		 jl	 SHORT $L275371
  00048	bb 1e 00 00 00	 mov	 ebx, 30			; 0000001eH
  0004d	c7 44 24 10 00
	00 00 41	 mov	 DWORD PTR _fVal$[esp+8], 1090519040 ; 41000000H

; 785  : 	else if( nGap >= 10 )	{ nVal = 10;  fVal = 6.0f;  }

  00055	eb 71		 jmp	 SHORT $L283505
$L275371:
  00057	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0005a	7c 0f		 jl	 SHORT $L275373
  0005c	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  00061	c7 44 24 10 00
	00 c0 40	 mov	 DWORD PTR _fVal$[esp+8], 1086324736 ; 40c00000H

; 786  : 	else if( nGap <= -80 )	{ nVal = 1;   fVal = 1.0f;  }	//    .

  00069	eb 5d		 jmp	 SHORT $L283505
$L275373:
  0006b	83 f8 b0	 cmp	 eax, -80		; ffffffb0H
  0006e	7f 0f		 jg	 SHORT $L275375
  00070	bb 01 00 00 00	 mov	 ebx, 1
  00075	c7 44 24 10 00
	00 80 3f	 mov	 DWORD PTR _fVal$[esp+8], 1065353216 ; 3f800000H

; 787  : 	else if( nGap <= -30 )	{ nVal = 2;   fVal = 2.0f;  }

  0007d	eb 49		 jmp	 SHORT $L283505
$L275375:
  0007f	83 f8 e2	 cmp	 eax, -30		; ffffffe2H
  00082	7f 0f		 jg	 SHORT $L275377
  00084	bb 02 00 00 00	 mov	 ebx, 2
  00089	c7 44 24 10 00
	00 00 40	 mov	 DWORD PTR _fVal$[esp+8], 1073741824 ; 40000000H

; 788  : 	else if( nGap <= -20 )	{ nVal = 3;   fVal = 3.0f;  }

  00091	eb 35		 jmp	 SHORT $L283505
$L275377:
  00093	83 f8 ec	 cmp	 eax, -20		; ffffffecH
  00096	7f 0f		 jg	 SHORT $L275379
  00098	bb 03 00 00 00	 mov	 ebx, 3
  0009d	c7 44 24 10 00
	00 40 40	 mov	 DWORD PTR _fVal$[esp+8], 1077936128 ; 40400000H

; 789  : 	else if( nGap <= -10 )	{ nVal = 4;   fVal = 4.0f;  }

  000a5	eb 21		 jmp	 SHORT $L283505
$L275379:
  000a7	83 f8 f6	 cmp	 eax, -10		; fffffff6H
  000aa	7f 0f		 jg	 SHORT $L275381
  000ac	bb 04 00 00 00	 mov	 ebx, 4
  000b1	c7 44 24 10 00
	00 80 40	 mov	 DWORD PTR _fVal$[esp+8], 1082130432 ; 40800000H

; 790  : 	else                    { nVal = 5;   fVal = 5.0f;  }	// 9 ~ -9

  000b9	eb 0d		 jmp	 SHORT $L283505
$L275381:
  000bb	bb 05 00 00 00	 mov	 ebx, 5
  000c0	c7 44 24 10 00
	00 a0 40	 mov	 DWORD PTR _fVal$[esp+8], 1084227584 ; 40a00000H
$L283505:

; 791  : 
; 792  : 
; 793  : 	if( nVal )		//   
; 794  : 	{	
; 795  : 		if( this->IsFly() && pLose->IsFly() )	//        ,       2 

  000c8	8b 8f 3c 02 00
	00		 mov	 ecx, DWORD PTR [edi+572]
  000ce	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  000d1	b0 08		 mov	 al, 8
  000d3	84 d0		 test	 dl, al
  000d5	74 0d		 je	 SHORT $L275384
  000d7	8b 96 3c 02 00
	00		 mov	 edx, DWORD PTR [esi+572]
  000dd	84 42 08	 test	 BYTE PTR [edx+8], al
  000e0	74 02		 je	 SHORT $L275384

; 796  : 			nVal *= 2;

  000e2	03 db		 add	 ebx, ebx
$L275384:

; 797  : 			
; 798  : 		m_nFame += nVal;	

  000e4	8b 97 50 07 00
	00		 mov	 edx, DWORD PTR [edi+1872]
  000ea	03 d3		 add	 edx, ebx
  000ec	8b c2		 mov	 eax, edx

; 799  : 		g_UserMng.AddSetFame( this, m_nFame );

  000ee	50		 push	 eax
  000ef	57		 push	 edi
  000f0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000f5	89 97 50 07 00
	00		 mov	 DWORD PTR [edi+1872], edx
  000fb	e8 00 00 00 00	 call	 ?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddSetFame

; 800  : 		((CUser*)this)->AddDefinedText( TID_GAME_GETFAMEPOINT, "%d", nVal );	// xxx   

  00100	53		 push	 ebx
  00101	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00106	68 9c 03 00 00	 push	 924			; 0000039cH
  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  00111	83 c4 10	 add	 esp, 16			; 00000010H

; 801  : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 802  : 		((CUser*)this)->CheckHonorStat();

  00114	8b cf		 mov	 ecx, edi
  00116	e8 00 00 00 00	 call	 ?CheckHonorStat@CMover@@QAEXXZ ; CMover::CheckHonorStat

; 803  : 		((CUser*)this)->AddHonorListAck();

  0011b	8b cf		 mov	 ecx, edi
  0011d	e8 00 00 00 00	 call	 ?AddHonorListAck@CUser@@QAEXXZ ; CUser::AddHonorListAck

; 804  : 		g_UserMng.AddHonorTitleChange( this, m_nHonor);

  00122	8b 87 04 09 00
	00		 mov	 eax, DWORD PTR [edi+2308]
  00128	50		 push	 eax
  00129	57		 push	 edi
  0012a	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0012f	e8 00 00 00 00	 call	 ?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddHonorTitleChange

; 805  : #endif	// __HONORABLE_TITLE			// 
; 806  : 	}
; 807  : 	
; 808  : 	if( fVal )	//  () .

  00134	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  0013a	d9 44 24 10	 fld	 DWORD PTR _fVal$[esp+8]
  0013e	da e9		 fucompp
  00140	df e0		 fnstsw	 ax
  00142	f6 c4 44	 test	 ah, 68			; 00000044H
  00145	0f 8b 89 00 00
	00		 jnp	 $L275389

; 809  : 	{
; 810  : 		int		nDecVal;
; 811  : 		fVal = fVal / 100.0f;	//  .

  0014b	d9 44 24 10	 fld	 DWORD PTR _fVal$[esp+8]
  0014f	55		 push	 ebp
  00150	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a

; 812  : 		nDecVal = (int)(pLose->m_nFame * fVal);

  00156	da 8e 50 07 00
	00		 fimul	 DWORD PTR [esi+1872]
  0015c	e8 00 00 00 00	 call	 __ftol2
  00161	8b e8		 mov	 ebp, eax

; 813  : 		if( nDecVal <= 0 )	nDecVal = 1;

  00163	85 ed		 test	 ebp, ebp
  00165	7f 05		 jg	 SHORT $L275392
  00167	bd 01 00 00 00	 mov	 ebp, 1
$L275392:

; 814  : 		pLose->m_nFame -= nDecVal;

  0016c	29 ae 50 07 00
	00		 sub	 DWORD PTR [esi+1872], ebp

; 815  : 		if( pLose->m_nFame < 0 )

  00172	79 0a		 jns	 SHORT $L275393

; 816  : 			pLose->m_nFame = 0;

  00174	c7 86 50 07 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1872], 0
$L275393:

; 817  : 
; 818  : 		g_UserMng.AddSetFame( pLose, pLose->m_nFame );

  0017e	8b 8e 50 07 00
	00		 mov	 ecx, DWORD PTR [esi+1872]
  00184	51		 push	 ecx
  00185	56		 push	 esi
  00186	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0018b	e8 00 00 00 00	 call	 ?AddSetFame@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddSetFame

; 819  : 		((CUser*)pLose)->AddDefinedText( TID_GAME_DECFAMEPOINT, "%d", nDecVal );	// xxx   .

  00190	55		 push	 ebp
  00191	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00196	68 9d 03 00 00	 push	 925			; 0000039dH
  0019b	56		 push	 esi
  0019c	e8 00 00 00 00	 call	 ?AddDefinedText@CUser@@QAAXHPBDZZ ; CUser::AddDefinedText
  001a1	83 c4 10	 add	 esp, 16			; 00000010H

; 820  : 		g_dpDBClient.SendLogPkPvp( this, pLose, nVal, 'D' );

  001a4	6a 44		 push	 68			; 00000044H
  001a6	53		 push	 ebx
  001a7	56		 push	 esi
  001a8	57		 push	 edi
  001a9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  001ae	e8 00 00 00 00	 call	 ?SendLogPkPvp@CDPDatabaseClient@@QAEXPAVCMover@@0HD@Z ; CDPDatabaseClient::SendLogPkPvp

; 821  : #if __VER >= 13 // __HONORABLE_TITLE			// 
; 822  : 		((CUser*)pLose)->CheckHonorStat();

  001b3	8b ce		 mov	 ecx, esi
  001b5	e8 00 00 00 00	 call	 ?CheckHonorStat@CMover@@QAEXXZ ; CMover::CheckHonorStat

; 823  : 		((CUser*)pLose)->AddHonorListAck();

  001ba	8b ce		 mov	 ecx, esi
  001bc	e8 00 00 00 00	 call	 ?AddHonorListAck@CUser@@QAEXXZ ; CUser::AddHonorListAck

; 824  : 		g_UserMng.AddHonorTitleChange( pLose, pLose->m_nHonor);

  001c1	8b 96 04 09 00
	00		 mov	 edx, DWORD PTR [esi+2308]
  001c7	52		 push	 edx
  001c8	56		 push	 esi
  001c9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  001ce	e8 00 00 00 00	 call	 ?AddHonorTitleChange@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddHonorTitleChange
  001d3	5d		 pop	 ebp
$L275389:
  001d4	5f		 pop	 edi
  001d5	5e		 pop	 esi
  001d6	5b		 pop	 ebx

; 825  : #endif	// __HONORABLE_TITLE			// 
; 826  : 	}
; 827  : }

  001d7	c2 04 00	 ret	 4
?ChangeFame@CMover@@QAEXPAV1@@Z ENDP			; CMover::ChangeFame
_TEXT	ENDS
PUBLIC	?DuelResult@CMover@@QAEHPAV1@@Z			; CMover::DuelResult
EXTRN	?g_PartyMng@@3VCPartyMng@@A:BYTE		; g_PartyMng
EXTRN	?RemoveAttackerBuffs@CMover@@QAEXK@Z:NEAR	; CMover::RemoveAttackerBuffs
EXTRN	?SendSetPartyDuel@CDPCoreClient@@QAEXKKH@Z:NEAR	; CDPCoreClient::SendSetPartyDuel
EXTRN	?GetLeader@CParty@@QAEPAVCMover@@XZ:NEAR	; CParty::GetLeader
EXTRN	?DoDuelResult@CParty@@QAEXPAV1@HHM@Z:NEAR	; CParty::DoDuelResult
EXTRN	?g_DPCoreClient@@3VCDPCoreClient@@A:BYTE	; g_DPCoreClient
EXTRN	?GetParty@CPartyMng@@QAEPAVCParty@@K@Z:NEAR	; CPartyMng::GetParty
; Function compile flags: /Ogty
;	COMDAT ?DuelResult@CMover@@QAEHPAV1@@Z
_TEXT	SEGMENT
_pLeader$275414 = 8					; size = 4
_fVal$275407 = 8					; size = 4
_pLose$ = 8						; size = 4
?DuelResult@CMover@@QAEHPAV1@@Z PROC NEAR		; CMover::DuelResult, COMDAT
; _this$ = ecx

; 831  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 832  : #ifdef __WORLDSERVER
; 833  : 	if( pLose->m_nDuel == 1 )

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pLose$[esp+4]
  00006	8b 87 44 07 00
	00		 mov	 eax, DWORD PTR [edi+1860]
  0000c	83 f8 01	 cmp	 eax, 1
  0000f	8b f1		 mov	 esi, ecx
  00011	75 15		 jne	 SHORT $L275402

; 834  : 	{
; 835  : 		if( pLose->GetId() != m_idDuelOther )

  00013	8b 8f bc 01 00
	00		 mov	 ecx, DWORD PTR [edi+444]
  00019	3b 8e 48 07 00
	00		 cmp	 ecx, DWORD PTR [esi+1864]
  0001f	74 07		 je	 SHORT $L275402
  00021	5f		 pop	 edi

; 836  : 			return 0;

  00022	33 c0		 xor	 eax, eax
  00024	5e		 pop	 esi

; 895  : }

  00025	c2 04 00	 ret	 4
$L275402:

; 837  : 	}
; 838  : 
; 839  : 	//    
; 840  : 	//   % 
; 841  : 	if( pLose->m_nDuel == 1 )	//  PvP

  00028	83 f8 01	 cmp	 eax, 1
  0002b	53		 push	 ebx
  0002c	55		 push	 ebp
  0002d	75 41		 jne	 SHORT $L275403

; 842  : 	{
; 843  : 		ChangeFame( pLose );

  0002f	57		 push	 edi
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?ChangeFame@CMover@@QAEXPAV1@@Z ; CMover::ChangeFame

; 844  : 		
; 845  : #ifdef __PVPDEBUFSKILL
; 846  : 		//pLose->m_SkillState.SetMover( pLose );
; 847  : 		pLose->m_nDead = PROCESS_COUNT * 2;		//   2 
; 848  : 		pLose->RemoveAttackerBuffs( pLose->m_idDuelOther );

  00037	8b 97 48 07 00
	00		 mov	 edx, DWORD PTR [edi+1864]
  0003d	bb 1e 00 00 00	 mov	 ebx, 30			; 0000001eH
  00042	52		 push	 edx
  00043	8b cf		 mov	 ecx, edi
  00045	89 9f 94 0e 00
	00		 mov	 DWORD PTR [edi+3732], ebx
  0004b	e8 00 00 00 00	 call	 ?RemoveAttackerBuffs@CMover@@QAEXK@Z ; CMover::RemoveAttackerBuffs

; 849  : 		//m_SkillState.SetMover( this );
; 850  : 		m_nDead = PROCESS_COUNT * 2;		//   2 
; 851  : 		RemoveAttackerBuffs( m_idDuelOther );

  00050	8b 86 48 07 00
	00		 mov	 eax, DWORD PTR [esi+1864]
  00056	50		 push	 eax
  00057	8b ce		 mov	 ecx, esi
  00059	89 9e 94 0e 00
	00		 mov	 DWORD PTR [esi+3732], ebx
  0005f	e8 00 00 00 00	 call	 ?RemoveAttackerBuffs@CMover@@QAEXK@Z ; CMover::RemoveAttackerBuffs
$L275405:
  00064	5d		 pop	 ebp
  00065	5b		 pop	 ebx
  00066	5f		 pop	 edi

; 891  : 	}
; 892  : #endif	// __WORLDSERVER
; 893  : 
; 894  : 	return 1;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	5e		 pop	 esi

; 895  : }

  0006d	c2 04 00	 ret	 4
$L275403:

; 852  : #endif // __PVPDEBUFSKILL
; 853  : 	}
; 854  : 	else
; 855  : 	//  .
; 856  : 	if( pLose->m_nDuel == 2 )		//     .

  00070	83 f8 02	 cmp	 eax, 2
  00073	75 ef		 jne	 SHORT $L275405

; 857  : 	{
; 858  : 		int nVal = 0;
; 859  : 		float fVal = 0;
; 860  : 		int nGap = 0;
; 861  : 
; 862  : 		CParty *pLoseParty = g_PartyMng.GetParty( pLose->m_idparty );

  00075	8b 8f 18 07 00
	00		 mov	 ecx, DWORD PTR [edi+1816]
  0007b	51		 push	 ecx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_PartyMng@@3VCPartyMng@@A
  00081	e8 00 00 00 00	 call	 ?GetParty@CPartyMng@@QAEPAVCParty@@K@Z ; CPartyMng::GetParty
  00086	8b e8		 mov	 ebp, eax

; 863  : 		if( pLoseParty == NULL || pLoseParty->IsLeader( pLose->m_idPlayer ) == FALSE )		//       .

  00088	85 ed		 test	 ebp, ebp
  0008a	0f 84 52 01 00
	00		 je	 $L275411
  00090	8b 55 28	 mov	 edx, DWORD PTR [ebp+40]
  00093	3b 97 38 02 00
	00		 cmp	 edx, DWORD PTR [edi+568]
  00099	0f 85 43 01 00
	00		 jne	 $L275411

; 865  : 		
; 866  : 		CParty *pParty = g_PartyMng.GetParty( m_idparty );		//  .

  0009f	8b 86 18 07 00
	00		 mov	 eax, DWORD PTR [esi+1816]
  000a5	50		 push	 eax
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_PartyMng@@3VCPartyMng@@A
  000ab	e8 00 00 00 00	 call	 ?GetParty@CPartyMng@@QAEPAVCParty@@K@Z ; CPartyMng::GetParty
  000b0	8b d8		 mov	 ebx, eax

; 867  : 		if( pParty == NULL )

  000b2	85 db		 test	 ebx, ebx

; 868  : 			return 0;

  000b4	0f 84 28 01 00
	00		 je	 $L275411

; 869  : 
; 870  : 		CMover* pLeader	= pParty->GetLeader();

  000ba	8b cb		 mov	 ecx, ebx
  000bc	e8 00 00 00 00	 call	 ?GetLeader@CParty@@QAEPAVCMover@@XZ ; CParty::GetLeader

; 871  : 		if( IsValidObj( pLeader ) )

  000c1	50		 push	 eax
  000c2	89 44 24 18	 mov	 DWORD PTR _pLeader$275414[esp+16], eax
  000c6	e8 00 00 00 00	 call	 ?IsValidObj@@YAHPAVCObj@@@Z ; IsValidObj
  000cb	83 c4 04	 add	 esp, 4
  000ce	85 c0		 test	 eax, eax

; 872  : 			nGap	= pLose->GetLevel() - pLeader->GetLevel();

  000d0	8b 87 e0 05 00
	00		 mov	 eax, DWORD PTR [edi+1504]
  000d6	74 0c		 je	 SHORT $L275415
  000d8	8b 4c 24 14	 mov	 ecx, DWORD PTR _pLeader$275414[esp+12]
  000dc	2b 81 e0 05 00
	00		 sub	 eax, DWORD PTR [ecx+1504]

; 873  : 		else

  000e2	eb 06		 jmp	 SHORT $L275416
$L275415:

; 874  : 			nGap	= pLose->GetLevel() - GetLevel();

  000e4	2b 86 e0 05 00
	00		 sub	 eax, DWORD PTR [esi+1504]
$L275416:

; 875  : 		
; 876  : 		if( nGap >= 80 )	{ nVal = 100; fVal = 15.0f; }		//    .

  000ea	83 f8 50	 cmp	 eax, 80			; 00000050H
  000ed	7c 12		 jl	 SHORT $L275417
  000ef	be 64 00 00 00	 mov	 esi, 100		; 00000064H
  000f4	c7 44 24 14 00
	00 70 41	 mov	 DWORD PTR _fVal$275407[esp+12], 1097859072 ; 41700000H

; 877  : 		else if( nGap >= 50 )	{ nVal = 50; fVal = 10.0f; }

  000fc	e9 9c 00 00 00	 jmp	 $L275432
$L275417:
  00101	83 f8 32	 cmp	 eax, 50			; 00000032H
  00104	7c 12		 jl	 SHORT $L275419
  00106	be 32 00 00 00	 mov	 esi, 50			; 00000032H
  0010b	c7 44 24 14 00
	00 20 41	 mov	 DWORD PTR _fVal$275407[esp+12], 1092616192 ; 41200000H

; 878  : 		else if( nGap >= 20 )	{ nVal = 30; fVal = 8.0f; }

  00113	e9 85 00 00 00	 jmp	 $L275432
$L275419:
  00118	83 f8 14	 cmp	 eax, 20			; 00000014H
  0011b	7c 0f		 jl	 SHORT $L275421
  0011d	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH
  00122	c7 44 24 14 00
	00 00 41	 mov	 DWORD PTR _fVal$275407[esp+12], 1090519040 ; 41000000H

; 879  : 		else if( nGap >= 10 )	{ nVal = 10; fVal = 6.0f; }

  0012a	eb 71		 jmp	 SHORT $L275432
$L275421:
  0012c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0012f	7c 0f		 jl	 SHORT $L275423
  00131	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  00136	c7 44 24 14 00
	00 c0 40	 mov	 DWORD PTR _fVal$275407[esp+12], 1086324736 ; 40c00000H

; 880  : 		else if( nGap <= -80 )	{ nVal = 1; fVal = 1.0f; }		//    .

  0013e	eb 5d		 jmp	 SHORT $L275432
$L275423:
  00140	83 f8 b0	 cmp	 eax, -80		; ffffffb0H
  00143	7f 0f		 jg	 SHORT $L275425
  00145	be 01 00 00 00	 mov	 esi, 1
  0014a	c7 44 24 14 00
	00 80 3f	 mov	 DWORD PTR _fVal$275407[esp+12], 1065353216 ; 3f800000H

; 881  : 		else if( nGap <= -50 )	{ nVal = 2; fVal = 2.0f; }

  00152	eb 49		 jmp	 SHORT $L275432
$L275425:
  00154	83 f8 ce	 cmp	 eax, -50		; ffffffceH
  00157	7f 0f		 jg	 SHORT $L275427
  00159	be 02 00 00 00	 mov	 esi, 2
  0015e	c7 44 24 14 00
	00 00 40	 mov	 DWORD PTR _fVal$275407[esp+12], 1073741824 ; 40000000H

; 882  : 		else if( nGap <= -20 )	{ nVal = 3; fVal = 3.0f; }

  00166	eb 35		 jmp	 SHORT $L275432
$L275427:
  00168	83 f8 ec	 cmp	 eax, -20		; ffffffecH
  0016b	7f 0f		 jg	 SHORT $L275429
  0016d	be 03 00 00 00	 mov	 esi, 3
  00172	c7 44 24 14 00
	00 40 40	 mov	 DWORD PTR _fVal$275407[esp+12], 1077936128 ; 40400000H

; 883  : 		else if( nGap <= -10 )	{ nVal = 4; fVal = 4.0f; }

  0017a	eb 21		 jmp	 SHORT $L275432
$L275429:
  0017c	83 f8 f6	 cmp	 eax, -10		; fffffff6H
  0017f	7f 0f		 jg	 SHORT $L275431
  00181	be 04 00 00 00	 mov	 esi, 4
  00186	c7 44 24 14 00
	00 80 40	 mov	 DWORD PTR _fVal$275407[esp+12], 1082130432 ; 40800000H

; 884  : 		else { nVal = 5; fVal = 5.0f; }	// 9 ~ -9

  0018e	eb 0d		 jmp	 SHORT $L275432
$L275431:
  00190	be 05 00 00 00	 mov	 esi, 5
  00195	c7 44 24 14 00
	00 a0 40	 mov	 DWORD PTR _fVal$275407[esp+12], 1084227584 ; 40a00000H
$L275432:

; 885  : 
; 886  : 		g_DPCoreClient.SendSetPartyDuel( pParty->m_uPartyId, pLoseParty->m_uPartyId, FALSE );

  0019d	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  001a0	8b 03		 mov	 eax, DWORD PTR [ebx]
  001a2	6a 00		 push	 0
  001a4	52		 push	 edx
  001a5	50		 push	 eax
  001a6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPCoreClient@@3VCDPCoreClient@@A
  001ab	e8 00 00 00 00	 call	 ?SendSetPartyDuel@CDPCoreClient@@QAEXKKH@Z ; CDPCoreClient::SendSetPartyDuel

; 887  : 
; 888  : 		pLose->m_bLastDuelParty = TRUE;

  001b0	c7 87 dc 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+3804], 1

; 889  : 		pLoseParty->DoDuelResult( pParty, 0, nVal, fVal );		//     .

  001ba	8b 7c 24 14	 mov	 edi, DWORD PTR _fVal$275407[esp+12]
  001be	57		 push	 edi
  001bf	56		 push	 esi
  001c0	6a 00		 push	 0
  001c2	53		 push	 ebx
  001c3	8b cd		 mov	 ecx, ebp
  001c5	e8 00 00 00 00	 call	 ?DoDuelResult@CParty@@QAEXPAV1@HHM@Z ; CParty::DoDuelResult

; 890  : 		pParty->DoDuelResult( pLoseParty, 1, nVal, fVal );		//   .

  001ca	57		 push	 edi
  001cb	56		 push	 esi
  001cc	6a 01		 push	 1
  001ce	55		 push	 ebp
  001cf	8b cb		 mov	 ecx, ebx
  001d1	e8 00 00 00 00	 call	 ?DoDuelResult@CParty@@QAEXPAV1@HHM@Z ; CParty::DoDuelResult
  001d6	5d		 pop	 ebp
  001d7	5b		 pop	 ebx
  001d8	5f		 pop	 edi

; 891  : 	}
; 892  : #endif	// __WORLDSERVER
; 893  : 
; 894  : 	return 1;

  001d9	b8 01 00 00 00	 mov	 eax, 1
  001de	5e		 pop	 esi

; 895  : }

  001df	c2 04 00	 ret	 4
$L275411:
  001e2	5d		 pop	 ebp
  001e3	5b		 pop	 ebx
  001e4	5f		 pop	 edi

; 864  : 			return 0;

  001e5	33 c0		 xor	 eax, eax
  001e7	5e		 pop	 esi

; 895  : }

  001e8	c2 04 00	 ret	 4
?DuelResult@CMover@@QAEHPAV1@@Z ENDP			; CMover::DuelResult
_TEXT	ENDS
PUBLIC	?GetPointParam@CMover@@QAEHH@Z			; CMover::GetPointParam
; Function compile flags: /Ogty
;	COMDAT ?GetPointParam@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nDestParameter$ = 8					; size = 4
?GetPointParam@CMover@@QAEHH@Z PROC NEAR		; CMover::GetPointParam, COMDAT
; _this$ = ecx

; 928  : 	switch( nDestParameter )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nDestParameter$[esp-4]
  00004	83 f8 28	 cmp	 eax, 40			; 00000028H
  00007	7f 3f		 jg	 SHORT $L283555
  00009	74 18		 je	 SHORT $L275461
  0000b	83 e8 26	 sub	 eax, 38			; 00000026H
  0000e	74 0b		 je	 SHORT $L275459
  00010	48		 dec	 eax
  00011	75 3c		 jne	 SHORT $L275456

; 931  : 		case DST_MP:	return( GetManaPoint() );

  00013	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint

; 936  : }

  00018	c2 04 00	 ret	 4
$L275459:

; 929  : 	{
; 930  : 		case DST_HP:	return( GetHitPoint() );

  0001b	e8 00 00 00 00	 call	 ?GetHitPoint@CMover@@QAEHXZ ; CMover::GetHitPoint

; 936  : }

  00020	c2 04 00	 ret	 4
$L275461:

; 932  : 		case DST_FP:	return( GetFatiguePoint() );

  00023	8b 81 2c 15 00
	00		 mov	 eax, DWORD PTR [ecx+5420]
  00029	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0002e	8b 91 08 06 00
	00		 mov	 edx, DWORD PTR [ecx+1544]
  00034	75 24		 jne	 SHORT $L275454
  00036	8b 89 58 13 00
	00		 mov	 ecx, DWORD PTR [ecx+4952]
  0003c	85 c9		 test	 ecx, ecx
  0003e	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00041	75 17		 jne	 SHORT $L275454
  00043	8b c2		 mov	 eax, edx

; 936  : }

  00045	c2 04 00	 ret	 4
$L283555:

; 928  : 	switch( nDestParameter )

  00048	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  0004d	74 05		 je	 SHORT $L275462
$L275456:

; 934  : 	}
; 935  : 	return( 0 );

  0004f	33 c0		 xor	 eax, eax

; 936  : }

  00051	c2 04 00	 ret	 4
$L275462:

; 933  : 		case DST_GOLD:	return( GetGold() );

  00054	8b 81 84 16 00
	00		 mov	 eax, DWORD PTR [ecx+5764]
$L275454:

; 936  : }

  0005a	c2 04 00	 ret	 4
?GetPointParam@CMover@@QAEHH@Z ENDP			; CMover::GetPointParam
_TEXT	ENDS
PUBLIC	??_C@_0EF@ODCCKCNB@CMover?3?3DecExperiencePercent?5?3?5?$CF@ ; `string'
PUBLIC	??_C@_0FO@OOMNFAPD@1?5CMover?3?3DecExperiencePercent?5?3@ ; `string'
PUBLIC	??_C@_0GG@EIMKDIB@0?5CMover?3?3DecExperiencePercent?5?3@ ; `string'
PUBLIC	?DecExperiencePercent@CMover@@QAEHMHH@Z		; CMover::DecExperiencePercent
PUBLIC	__real@3faeb851e0000000
;	COMDAT ??_C@_0EF@ODCCKCNB@CMover?3?3DecExperiencePercent?5?3?5?$CF@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_0EF@ODCCKCNB@CMover?3?3DecExperiencePercent?5?3?5?$CF@ DB 'CMover::'
	DB	'DecExperiencePercent : %s ', 0b7H, 0b9H, 0baH, 0a7H, 0b4H, 0d9H
	DB	0bfH, 0eeH, ' ', 0c0H, 0ccH, 0bbH, 0f3H, '. %d -> %d  %I64d(%f'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@OOMNFAPD@1?5CMover?3?3DecExperiencePercent?5?3@
CONST	SEGMENT
??_C@_0FO@OOMNFAPD@1?5CMover?3?3DecExperiencePercent?5?3@ DB '1 CMover::D'
	DB	'ecExperiencePercent : %s(Lv%d) ', 0b0H, 0e6H, 0c7H, 0e8H, 0c4H
	DB	0a1H, 0b0H, 0a1H, ' ', 0c0H, 0ccH, 0bbH, 0f3H, 0c7H, 0cfH, 0b0H
	DB	0d4H, ' ', 0b1H, 0f0H, 0c0H, 0d3H, '. %I64d %I64d(%f) %I64d %I'
	DB	'64d', 00H					; `string'
CONST	ENDS
;	COMDAT __real@3faeb851e0000000
CONST	SEGMENT
__real@3faeb851e0000000 DQ 03faeb851e0000000r	; 0.06
CONST	ENDS
;	COMDAT ??_C@_0GG@EIMKDIB@0?5CMover?3?3DecExperiencePercent?5?3@
CONST	SEGMENT
??_C@_0GG@EIMKDIB@0?5CMover?3?3DecExperiencePercent?5?3@ DB '0 CMover::De'
	DB	'cExperiencePercent : %s(Lv%d) ', 0b0H, 0e6H, 0c7H, 0e8H, 0c4H
	DB	0a1H, 0b0H, 0a1H, ' ', 0c0H, 0ccH, 0bbH, 0f3H, 0c7H, 0cfH, 0b0H
	DB	0d4H, ' ', 0b1H, 0f0H, 0c0H, 0d3H, '. %I64d %I64d(%f) %I64d(%f'
	DB	') %I64d(%f)', 00H				; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	ENDS
;	COMDAT ?DecExperiencePercent@CMover@@QAEHMHH@Z
_TEXT	SEGMENT
tv229 = -32						; size = 4
_fOldPercent$275654 = -32				; size = 8
_nExpOld$ = -24						; size = 8
_nMaxExp$ = -16						; size = 8
tv226 = -8						; size = 8
_nDecExp$ = -8						; size = 8
_fPercent$ = 8						; size = 4
_bExp2Clear$ = 12					; size = 4
_bLvDown$ = 16						; size = 4
?DecExperiencePercent@CMover@@QAEHMHH@Z PROC NEAR	; CMover::DecExperiencePercent, COMDAT
; _this$ = ecx

; 1647 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 24	 sub	 esp, 36			; 00000024H

; 1648 : 	EXPINTEGER	nExpOld		= m_nExp1;		//  exp
; 1649 : 	EXPINTEGER	nMaxExp		= prj.m_aExpCharacter[m_nLevel+1].nExp1;	//   .
; 1650 : 	int	nOldLv	= m_nLevel;		//  .
; 1651 : 
; 1652 : 	if( fPercent == 0.0f )	

  00009	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  0000f	53		 push	 ebx
  00010	d9 45 08	 fld	 DWORD PTR _fPercent$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	da e9		 fucompp
  00018	8b 86 e8 05 00
	00		 mov	 eax, DWORD PTR [esi+1512]
  0001e	8b 8e ec 05 00
	00		 mov	 ecx, DWORD PTR [esi+1516]
  00024	89 44 24 14	 mov	 DWORD PTR _nExpOld$[esp+44], eax
  00028	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  0002e	89 44 24 0c	 mov	 DWORD PTR tv229[esp+44], eax
  00032	c1 e0 05	 shl	 eax, 5
  00035	8b 90 10 50 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[eax+20496]
  0003b	8b 80 14 50 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[eax+20500]
  00041	89 44 24 20	 mov	 DWORD PTR _nMaxExp$[esp+48], eax
  00045	df e0		 fnstsw	 ax
  00047	57		 push	 edi
  00048	f6 c4 44	 test	 ah, 68			; 00000044H
  0004b	89 4c 24 1c	 mov	 DWORD PTR _nExpOld$[esp+52], ecx
  0004f	89 54 24 20	 mov	 DWORD PTR _nMaxExp$[esp+48], edx
  00053	7a 0b		 jp	 SHORT $L275644

; 1653 : 		return FALSE;	// 0%     .

  00055	33 c0		 xor	 eax, eax

; 1680 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$L275644:

; 1654 : 
; 1655 : 	EXPINTEGER	nDecExp = (EXPINTEGER)(prj.m_aExpCharacter[m_nLevel+1].nExp1 * fPercent );	//   * 

  00060	8b 8e e0 05 00
	00		 mov	 ecx, DWORD PTR [esi+1504]
  00066	c1 e1 05	 shl	 ecx, 5
  00069	df a9 10 50 00
	00		 fild	 QWORD PTR ?prj@@3VCProject@@A[ecx+20496]
  0006f	d8 4d 08	 fmul	 DWORD PTR _fPercent$[ebp]
  00072	e8 00 00 00 00	 call	 __ftol2
  00077	8b fa		 mov	 edi, edx

; 1656 : 	bLvDown		= DecExperience( nDecExp, bExp2Clear, bLvDown );

  00079	8b 55 10	 mov	 edx, DWORD PTR _bLvDown$[ebp]
  0007c	8b d8		 mov	 ebx, eax
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _bExp2Clear$[ebp]
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	57		 push	 edi
  00084	53		 push	 ebx
  00085	8b ce		 mov	 ecx, esi
  00087	89 5c 24 38	 mov	 DWORD PTR _nDecExp$[esp+64], ebx
  0008b	e8 00 00 00 00	 call	 ?DecExperience@CMover@@QAEH_JHH@Z ; CMover::DecExperience

; 1657 : 
; 1658 : 	if( bLvDown )	//   .

  00090	85 c0		 test	 eax, eax
  00092	89 45 10	 mov	 DWORD PTR _bLvDown$[ebp], eax
  00095	0f 84 c5 00 00
	00		 je	 $L275647

; 1659 : 	{
; 1660 : 		if( m_nLevel - nOldLv < -1 )	//       .

  0009b	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  000a1	8b 4c 24 10	 mov	 ecx, DWORD PTR tv229[esp+48]
  000a5	8b d0		 mov	 edx, eax
  000a7	2b d1		 sub	 edx, ecx
  000a9	83 fa ff	 cmp	 edx, -1
  000ac	7d 21		 jge	 SHORT $L275648

; 1661 : 			Error( "CMover::DecExperiencePercent : %s  . %d -> %d  %I64d(%f)"
; 1662 : 			, m_szName, nOldLv, m_nLevel, nDecExp, fPercent );

  000ae	d9 45 08	 fld	 DWORD PTR _fPercent$[ebp]
  000b1	83 ec 08	 sub	 esp, 8
  000b4	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b7	57		 push	 edi
  000b8	53		 push	 ebx
  000b9	50		 push	 eax
  000ba	51		 push	 ecx
  000bb	8d 86 90 16 00
	00		 lea	 eax, DWORD PTR [esi+5776]
  000c1	50		 push	 eax
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EF@ODCCKCNB@CMover?3?3DecExperiencePercent?5?3?5?$CF@
  000c7	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000cc	83 c4 20	 add	 esp, 32			; 00000020H
$L275648:

; 1663 : 
; 1664 : 		EXPINTEGER	nDecExp2	= ( prj.m_aExpCharacter[m_nLevel+1].nExp1 - m_nExp1 ) + nExpOld;	//   .

  000cf	8b 96 e0 05 00
	00		 mov	 edx, DWORD PTR [esi+1504]
  000d5	8b 86 e8 05 00
	00		 mov	 eax, DWORD PTR [esi+1512]
  000db	8b da		 mov	 ebx, edx
  000dd	c1 e3 05	 shl	 ebx, 5

; 1665 : 		if( nDecExp2 > nDecExp )	//        .

  000e0	8b 8b 10 50 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[ebx+20496]
  000e6	2b c8		 sub	 ecx, eax
  000e8	8b 83 14 50 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[ebx+20500]
  000ee	1b 86 ec 05 00
	00		 sbb	 eax, DWORD PTR [esi+1516]
  000f4	03 4c 24 18	 add	 ecx, DWORD PTR _nExpOld$[esp+48]
  000f8	8b 5c 24 1c	 mov	 ebx, DWORD PTR _nExpOld$[esp+52]
  000fc	13 c3		 adc	 eax, ebx
  000fe	3b c7		 cmp	 eax, edi
  00100	0f 8c ef 00 00
	00		 jl	 $L275660
  00106	7f 0a		 jg	 SHORT $L283611
  00108	3b 4c 24 28	 cmp	 ecx, DWORD PTR _nDecExp$[esp+48]
  0010c	0f 86 e3 00 00
	00		 jbe	 $L275660
$L283611:

; 1666 : 			Error( "1 CMover::DecExperiencePercent : %s(Lv%d)   . %I64d %I64d(%f) %I64d %I64d"
; 1667 : 			, m_szName, GetLevel(), nMaxExp, nDecExp, fPercent, nExpOld, m_nExp1 );

  00112	8b 86 ec 05 00
	00		 mov	 eax, DWORD PTR [esi+1516]
  00118	d9 45 08	 fld	 DWORD PTR _fPercent$[ebp]
  0011b	8b 4c 24 18	 mov	 ecx, DWORD PTR _nExpOld$[esp+48]
  0011f	50		 push	 eax
  00120	8b 86 e8 05 00
	00		 mov	 eax, DWORD PTR [esi+1512]
  00126	50		 push	 eax
  00127	8b 44 24 30	 mov	 eax, DWORD PTR _nDecExp$[esp+56]
  0012b	53		 push	 ebx
  0012c	51		 push	 ecx
  0012d	8b 4c 24 34	 mov	 ecx, DWORD PTR _nMaxExp$[esp+68]
  00131	83 ec 08	 sub	 esp, 8
  00134	dd 1c 24	 fstp	 QWORD PTR [esp]
  00137	57		 push	 edi
  00138	50		 push	 eax
  00139	8b 44 24 40	 mov	 eax, DWORD PTR _nMaxExp$[esp+80]
  0013d	51		 push	 ecx
  0013e	50		 push	 eax
  0013f	52		 push	 edx
  00140	81 c6 90 16 00
	00		 add	 esi, 5776		; 00001690H
  00146	56		 push	 esi
  00147	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FO@OOMNFAPD@1?5CMover?3?3DecExperiencePercent?5?3@
  0014c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 1677 : 	}
; 1678 : 
; 1679 : 	return bLvDown;

  00151	8b 45 10	 mov	 eax, DWORD PTR _bLvDown$[ebp]
  00154	83 c4 34	 add	 esp, 52			; 00000034H

; 1680 : }

  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	5b		 pop	 ebx
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 0c 00	 ret	 12			; 0000000cH
$L275647:

; 1668 : 	}
; 1669 : 	else
; 1670 : 	{
; 1671 : 		EXPFLOAT fOldPercent = static_cast<EXPFLOAT>( nExpOld ) / static_cast<EXPFLOAT>( nMaxExp );		//  .

  00160	df 6c 24 20	 fild	 QWORD PTR _nMaxExp$[esp+48]

; 1672 : 		EXPFLOAT fCurPercent = static_cast<EXPFLOAT>( m_nExp1 ) / static_cast<EXPFLOAT>( nMaxExp );		//  .

  00164	8b 8e e8 05 00
	00		 mov	 ecx, DWORD PTR [esi+1512]
  0016a	df 6c 24 18	 fild	 QWORD PTR _nExpOld$[esp+48]
  0016e	8b 96 ec 05 00
	00		 mov	 edx, DWORD PTR [esi+1516]
  00174	89 4c 24 28	 mov	 DWORD PTR tv226[esp+48], ecx
  00178	89 54 24 2c	 mov	 DWORD PTR tv226[esp+52], edx
  0017c	d8 f1		 fdiv	 ST(0), ST(1)
  0017e	dd 5c 24 10	 fstp	 QWORD PTR _fOldPercent$275654[esp+48]
  00182	df 6c 24 28	 fild	 QWORD PTR tv226[esp+48]
  00186	de f1		 fdivrp	 ST(1), ST(0)

; 1673 : 
; 1674 : 		if( fOldPercent - fCurPercent > 0.060f )

  00188	dd 44 24 10	 fld	 QWORD PTR _fOldPercent$275654[esp+48]
  0018c	d8 e1		 fsub	 ST(0), ST(1)
  0018e	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3faeb851e0000000
  00194	df e0		 fnstsw	 ax
  00196	f6 c4 41	 test	 ah, 65			; 00000041H
  00199	75 58		 jne	 SHORT $L283614

; 1675 : 			Error( "0 CMover::DecExperiencePercent : %s(Lv%d)   . %I64d %I64d(%f) %I64d(%f) %I64d(%f)"
; 1676 : 			, m_szName, GetLevel(), nMaxExp, nDecExp, fPercent, nExpOld, fOldPercent, m_nExp1, fCurPercent );

  0019b	8b 44 24 24	 mov	 eax, DWORD PTR _nMaxExp$[esp+52]
  0019f	83 ec 08	 sub	 esp, 8
  001a2	dd 1c 24	 fstp	 QWORD PTR [esp]
  001a5	52		 push	 edx
  001a6	dd 44 24 1c	 fld	 QWORD PTR _fOldPercent$275654[esp+60]
  001aa	8b 54 24 24	 mov	 edx, DWORD PTR _nExpOld$[esp+60]
  001ae	51		 push	 ecx
  001af	8b 4c 24 2c	 mov	 ecx, DWORD PTR _nExpOld$[esp+68]
  001b3	83 ec 08	 sub	 esp, 8
  001b6	dd 1c 24	 fstp	 QWORD PTR [esp]
  001b9	51		 push	 ecx
  001ba	d9 45 08	 fld	 DWORD PTR _fPercent$[ebp]
  001bd	8b 4c 24 3c	 mov	 ecx, DWORD PTR _nMaxExp$[esp+76]
  001c1	52		 push	 edx
  001c2	8b 96 e0 05 00
	00		 mov	 edx, DWORD PTR [esi+1504]
  001c8	83 ec 08	 sub	 esp, 8
  001cb	dd 1c 24	 fstp	 QWORD PTR [esp]
  001ce	57		 push	 edi
  001cf	53		 push	 ebx
  001d0	50		 push	 eax
  001d1	51		 push	 ecx
  001d2	52		 push	 edx
  001d3	81 c6 90 16 00
	00		 add	 esi, 5776		; 00001690H
  001d9	56		 push	 esi
  001da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GG@EIMKDIB@0?5CMover?3?3DecExperiencePercent?5?3@
  001df	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 1677 : 	}
; 1678 : 
; 1679 : 	return bLvDown;

  001e4	8b 45 10	 mov	 eax, DWORD PTR _bLvDown$[ebp]
  001e7	83 c4 44	 add	 esp, 68			; 00000044H

; 1680 : }

  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	5b		 pop	 ebx
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c2 0c 00	 ret	 12			; 0000000cH
$L283614:

; 1675 : 			Error( "0 CMover::DecExperiencePercent : %s(Lv%d)   . %I64d %I64d(%f) %I64d(%f) %I64d(%f)"
; 1676 : 			, m_szName, GetLevel(), nMaxExp, nDecExp, fPercent, nExpOld, fOldPercent, m_nExp1, fCurPercent );

  001f3	dd d8		 fstp	 ST(0)
$L275660:

; 1677 : 	}
; 1678 : 
; 1679 : 	return bLvDown;

  001f5	8b 45 10	 mov	 eax, DWORD PTR _bLvDown$[ebp]

; 1680 : }

  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	5b		 pop	 ebx
  001fb	8b e5		 mov	 esp, ebp
  001fd	5d		 pop	 ebp
  001fe	c2 0c 00	 ret	 12			; 0000000cH
?DecExperiencePercent@CMover@@QAEHMHH@Z ENDP		; CMover::DecExperiencePercent
_TEXT	ENDS
PUBLIC	__real@3e800000
PUBLIC	__real@3ca3d70a
PUBLIC	__real@42a00000
PUBLIC	__real@4f800000
PUBLIC	?GetMaxOriginHitPoint@CMover@@QAEHH@Z		; CMover::GetMaxOriginHitPoint
PUBLIC	__real@41200000
EXTRN	?GetJobProp@CProject@@QAEPAUJobProp@@H@Z:NEAR	; CProject::GetJobProp
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMaxOriginHitPoint@CMover@@QAEHH@Z
_TEXT	SEGMENT
tv263 = 8						; size = 4
_nSta$276158 = 8					; size = 4
_bOriginal$ = 8						; size = 4
?GetMaxOriginHitPoint@CMover@@QAEHH@Z PROC NEAR		; CMover::GetMaxOriginHitPoint, COMDAT
; _this$ = ecx

; 3012 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3013 : 	if( IsInvalidObj(this) )	

  00003	85 f6		 test	 esi, esi
  00005	74 06		 je	 SHORT $L283636
  00007	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0000b	74 06		 je	 SHORT $L276156
$L283636:

; 3014 : 		return 0;

  0000d	33 c0		 xor	 eax, eax
  0000f	5e		 pop	 esi

; 3036 : #else // __S1108_BACK_END_SYSTEM
; 3037 : 		return pMoverProp->dwAddHp; 
; 3038 : #endif // __S1108_BACK_END_SYSTEM
; 3039 : 	}
; 3040 : 
; 3041 : 	return 0;
; 3042 : }

  00010	c2 04 00	 ret	 4
$L276156:

; 3015 : 
; 3016 : 	if( IsPlayer() )

  00013	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 97 00 00
	00		 je	 $L276157

; 3017 : 	{
; 3018 : 		int nSta;
; 3019 : 		if( bOriginal )

  00021	8b 44 24 08	 mov	 eax, DWORD PTR _bOriginal$[esp]
  00025	85 c0		 test	 eax, eax
  00027	74 08		 je	 SHORT $L276159

; 3020 : 			nSta = m_nSta;

  00029	8b 86 d4 05 00
	00		 mov	 eax, DWORD PTR [esi+1492]

; 3021 : 		else

  0002f	eb 26		 jmp	 SHORT $L283683
$L276159:

; 3022 : 			nSta = GetSta();

  00031	8b 8e 9c 14 00
	00		 mov	 ecx, DWORD PTR [esi+5276]
  00037	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0003d	75 06		 jne	 SHORT $L283677
  0003f	8b 8e c8 12 00
	00		 mov	 ecx, DWORD PTR [esi+4808]
$L283677:
  00045	8b 86 d4 05 00
	00		 mov	 eax, DWORD PTR [esi+1492]
  0004b	03 c1		 add	 eax, ecx
  0004d	83 f8 01	 cmp	 eax, 1
  00050	7d 05		 jge	 SHORT $L283683
  00052	b8 01 00 00 00	 mov	 eax, 1
$L283683:
  00057	89 44 24 08	 mov	 DWORD PTR _nSta$276158[esp], eax

; 3023 : 
; 3024 : 		JobProp* pProperty = prj.GetJobProp( GetJob() ); 

  0005b	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00067	e8 00 00 00 00	 call	 ?GetJobProp@CProject@@QAEPAUJobProp@@H@Z ; CProject::GetJobProp

; 3034 : #ifdef __S1108_BACK_END_SYSTEM
; 3035 : 		return int( pMoverProp->dwAddHp * prj.m_fMonsterHitpointRate * pMoverProp->m_fHitPoint_Rate ); 

  0006c	db 86 e0 05 00
	00		 fild	 DWORD PTR [esi+1504]
  00072	db 44 24 08	 fild	 DWORD PTR _nSta$276158[esp]
  00076	d9 c1		 fld	 ST(1)
  00078	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0007b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f000000
  00081	d9 ca		 fxch	 ST(2)
  00083	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00089	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e800000
  0008f	de ca		 fmulp	 ST(2), ST(0)
  00091	d9 c0		 fld	 ST(0)
  00093	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3ca3d70a
  00099	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  0009f	de ca		 fmulp	 ST(2), ST(0)
  000a1	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41200000
  000a7	de c1		 faddp	 ST(1), ST(0)
  000a9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@42a00000
  000af	e8 00 00 00 00	 call	 __ftol2
  000b4	5e		 pop	 esi

; 3036 : #else // __S1108_BACK_END_SYSTEM
; 3037 : 		return pMoverProp->dwAddHp; 
; 3038 : #endif // __S1108_BACK_END_SYSTEM
; 3039 : 	}
; 3040 : 
; 3041 : 	return 0;
; 3042 : }

  000b5	c2 04 00	 ret	 4
$L276157:

; 3025 : 
; 3026 : 		float a = (pProperty->fFactorMaxHP*m_nLevel)/2.0f;
; 3027 : 		float b = a * ((m_nLevel+1.0f)/4.0f) * (1.0f + nSta/50.0f) + (nSta*10.0f) ;
; 3028 : 		float maxHP = b + 80.f; 
; 3029 : 		return (int)maxHP;
; 3030 : 	}
; 3031 : 	else
; 3032 : 	{
; 3033 : 		MoverProp *pMoverProp = GetProp();

  000b8	8b ce		 mov	 ecx, esi
  000ba	e8 00 00 00 00	 call	 ?GetPropA@CMover@@QAEPAUMoverProp@@XZ ; CMover::GetPropA

; 3034 : #ifdef __S1108_BACK_END_SYSTEM
; 3035 : 		return int( pMoverProp->dwAddHp * prj.m_fMonsterHitpointRate * pMoverProp->m_fHitPoint_Rate ); 

  000bf	db 80 e4 00 00
	00		 fild	 DWORD PTR [eax+228]
  000c5	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  000cb	85 c9		 test	 ecx, ecx
  000cd	7d 06		 jge	 SHORT $L283696
  000cf	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L283696:
  000d5	d8 88 50 02 00
	00		 fmul	 DWORD PTR [eax+592]
  000db	d8 0d b8 46 0f
	00		 fmul	 DWORD PTR ?prj@@3VCProject@@A+1001144
  000e1	e8 00 00 00 00	 call	 __ftol2
  000e6	5e		 pop	 esi

; 3036 : #else // __S1108_BACK_END_SYSTEM
; 3037 : 		return pMoverProp->dwAddHp; 
; 3038 : #endif // __S1108_BACK_END_SYSTEM
; 3039 : 	}
; 3040 : 
; 3041 : 	return 0;
; 3042 : }

  000e7	c2 04 00	 ret	 4
?GetMaxOriginHitPoint@CMover@@QAEHH@Z ENDP		; CMover::GetMaxOriginHitPoint
_TEXT	ENDS
PUBLIC	__real@41b00000
PUBLIC	?GetMaxOriginManaPoint@CMover@@QAEHH@Z		; CMover::GetMaxOriginManaPoint
PUBLIC	__real@41000000
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMaxOriginManaPoint@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nInt$ = 8						; size = 4
_bOriginal$ = 8						; size = 4
?GetMaxOriginManaPoint@CMover@@QAEHH@Z PROC NEAR	; CMover::GetMaxOriginManaPoint, COMDAT
; _this$ = ecx

; 3046 : 	int nInt = 0;
; 3047 : 	if( bOriginal )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bOriginal$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	74 08		 je	 SHORT $L276173

; 3048 : 		nInt = m_nInt;

  0000b	8b 86 dc 05 00
	00		 mov	 eax, DWORD PTR [esi+1500]

; 3049 : 	else

  00011	eb 26		 jmp	 SHORT $L283743
$L276173:

; 3050 : 		nInt = GetInt();

  00013	8b 8e 98 14 00
	00		 mov	 ecx, DWORD PTR [esi+5272]
  00019	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0001f	75 06		 jne	 SHORT $L283739
  00021	8b 8e c4 12 00
	00		 mov	 ecx, DWORD PTR [esi+4804]
$L283739:
  00027	8b 86 dc 05 00
	00		 mov	 eax, DWORD PTR [esi+1500]
  0002d	03 c1		 add	 eax, ecx
  0002f	83 f8 01	 cmp	 eax, 1
  00032	7d 05		 jge	 SHORT $L283743
  00034	b8 01 00 00 00	 mov	 eax, 1
$L283743:

; 3051 : 
; 3052 : 	if( IsPlayer() )

  00039	8b 8e 34 02 00
	00		 mov	 ecx, DWORD PTR [esi+564]
  0003f	85 c9		 test	 ecx, ecx
  00041	89 44 24 08	 mov	 DWORD PTR _nInt$[esp], eax
  00045	74 43		 je	 SHORT $L276175

; 3053 : 	{
; 3054 : 		// INT((((BaseLv*2) + (INT*8))*Job) + 22)+(INT*Job)) +   
; 3055 : 		//  :    (%) TDDO
; 3056 : 		JobProp* pProperty = prj.GetJobProp( GetJob() ); 

  00047	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  0004d	50		 push	 eax
  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00053	e8 00 00 00 00	 call	 ?GetJobProp@CProject@@QAEPAUJobProp@@H@Z ; CProject::GetJobProp

; 3057 : 		float factor = pProperty->fFactorMaxMP;

  00058	d9 40 08	 fld	 DWORD PTR [eax+8]

; 3058 : 		
; 3059 : 		int nMaxMP = (int)( ((((m_nLevel*2.0f) + ( nInt*8.0f))*factor) + 22.0f)+( nInt*factor) );
; 3060 : 		return nMaxMP;
; 3061 : 	}
; 3062 : 	return 	( ( m_nLevel * 2 ) + ( nInt * 8 ) + 22 );

  0005b	db 44 24 08	 fild	 DWORD PTR _nInt$[esp]
  0005f	db 86 e0 05 00
	00		 fild	 DWORD PTR [esi+1504]
  00065	dc c0		 fadd	 ST(0), ST(0)
  00067	d9 c1		 fld	 ST(1)
  00069	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41000000
  0006f	de c1		 faddp	 ST(1), ST(0)
  00071	d8 ca		 fmul	 ST(0), ST(2)
  00073	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@41b00000
  00079	d9 c9		 fxch	 ST(1)
  0007b	d8 ca		 fmul	 ST(0), ST(2)
  0007d	de c1		 faddp	 ST(1), ST(0)
  0007f	e8 00 00 00 00	 call	 __ftol2
  00084	dd d8		 fstp	 ST(0)
  00086	5e		 pop	 esi

; 3063 : }

  00087	c2 04 00	 ret	 4
$L276175:

; 3058 : 		
; 3059 : 		int nMaxMP = (int)( ((((m_nLevel*2.0f) + ( nInt*8.0f))*factor) + 22.0f)+( nInt*factor) );
; 3060 : 		return nMaxMP;
; 3061 : 	}
; 3062 : 	return 	( ( m_nLevel * 2 ) + ( nInt * 8 ) + 22 );

  0008a	8b 8e e0 05 00
	00		 mov	 ecx, DWORD PTR [esi+1504]
  00090	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00093	8d 44 00 16	 lea	 eax, DWORD PTR [eax+eax+22]
  00097	5e		 pop	 esi

; 3063 : }

  00098	c2 04 00	 ret	 4
?GetMaxOriginManaPoint@CMover@@QAEHH@Z ENDP		; CMover::GetMaxOriginManaPoint
_TEXT	ENDS
PUBLIC	?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z	; CMover::GetMaxOriginFatiguePoint
PUBLIC	__real@40c00000
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nSta$ = 8						; size = 4
_bOriginal$ = 8						; size = 4
?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z PROC NEAR	; CMover::GetMaxOriginFatiguePoint, COMDAT
; _this$ = ecx

; 3067 : 	int nSta, nStr, nDex;
; 3068 : 	if( bOriginal )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bOriginal$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 18		 je	 SHORT $L276187

; 3069 : 	{
; 3070 : 		nSta = m_nSta;

  0000c	8b be d4 05 00
	00		 mov	 edi, DWORD PTR [esi+1492]

; 3071 : 		nStr = m_nStr;

  00012	8b 86 d0 05 00
	00		 mov	 eax, DWORD PTR [esi+1488]

; 3072 : 		nDex = m_nDex;

  00018	8b 8e d8 05 00
	00		 mov	 ecx, DWORD PTR [esi+1496]
  0001e	89 7c 24 0c	 mov	 DWORD PTR _nSta$[esp+4], edi

; 3073 : 	}
; 3074 : 	else

  00022	eb 7b		 jmp	 SHORT $L276188
$L276187:

; 3075 : 	{
; 3076 : 		nSta = GetSta();

  00024	8b 8e 9c 14 00
	00		 mov	 ecx, DWORD PTR [esi+5276]
  0002a	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00030	75 06		 jne	 SHORT $L283793
  00032	8b 8e c8 12 00
	00		 mov	 ecx, DWORD PTR [esi+4808]
$L283793:
  00038	8b 86 d4 05 00
	00		 mov	 eax, DWORD PTR [esi+1492]
  0003e	03 c1		 add	 eax, ecx
  00040	83 f8 01	 cmp	 eax, 1
  00043	7d 05		 jge	 SHORT $L283797
  00045	b8 01 00 00 00	 mov	 eax, 1
$L283797:
  0004a	8b f8		 mov	 edi, eax

; 3077 : 		nStr = GetStr();

  0004c	8b 86 90 14 00
	00		 mov	 eax, DWORD PTR [esi+5264]
  00052	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00057	89 7c 24 0c	 mov	 DWORD PTR _nSta$[esp+4], edi
  0005b	8b c8		 mov	 ecx, eax
  0005d	75 06		 jne	 SHORT $L283834
  0005f	8b 8e bc 12 00
	00		 mov	 ecx, DWORD PTR [esi+4796]
$L283834:
  00065	8b 86 d0 05 00
	00		 mov	 eax, DWORD PTR [esi+1488]
  0006b	03 c1		 add	 eax, ecx
  0006d	83 f8 01	 cmp	 eax, 1
  00070	7d 05		 jge	 SHORT $L283838
  00072	b8 01 00 00 00	 mov	 eax, 1
$L283838:

; 3078 : 		nDex = GetDex();

  00077	8b 8e 94 14 00
	00		 mov	 ecx, DWORD PTR [esi+5268]
  0007d	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00083	8b d1		 mov	 edx, ecx
  00085	75 06		 jne	 SHORT $L283875
  00087	8b 96 c0 12 00
	00		 mov	 edx, DWORD PTR [esi+4800]
$L283875:
  0008d	8b 8e d8 05 00
	00		 mov	 ecx, DWORD PTR [esi+1496]
  00093	03 ca		 add	 ecx, edx
  00095	83 f9 01	 cmp	 ecx, 1
  00098	7d 05		 jge	 SHORT $L276188
  0009a	b9 01 00 00 00	 mov	 ecx, 1
$L276188:

; 3079 : 	}
; 3080 : 
; 3081 : 	if( IsPlayer() )

  0009f	8b 96 34 02 00
	00		 mov	 edx, DWORD PTR [esi+564]
  000a5	85 d2		 test	 edx, edx
  000a7	74 3e		 je	 SHORT $L276189

; 3082 : 	{
; 3083 : 		// (((BaseLv*2) + (STA*6))*Job) +(STA*Job) +  + 
; 3084 : 		JobProp* pProperty = prj.GetJobProp( GetJob() ); 

  000a9	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  000af	50		 push	 eax
  000b0	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000b5	e8 00 00 00 00	 call	 ?GetJobProp@CProject@@QAEPAUJobProp@@H@Z ; CProject::GetJobProp

; 3085 : 		float factor = pProperty->fFactorMaxFP;

  000ba	d9 40 0c	 fld	 DWORD PTR [eax+12]

; 3086 : 
; 3087 : 		int nMaxFP = (int)( (((m_nLevel*2.0f) + (nSta*6.0f))*factor) +(nSta*factor) );
; 3088 : 		return nMaxFP;
; 3089 : 	}
; 3090 : 	
; 3091 : 	return ( ( m_nLevel * 2 ) + ( nStr * 7 ) + ( nSta *2 ) + ( nDex * 4 ) );

  000bd	db 44 24 0c	 fild	 DWORD PTR _nSta$[esp+4]
  000c1	db 86 e0 05 00
	00		 fild	 DWORD PTR [esi+1504]
  000c7	dc c0		 fadd	 ST(0), ST(0)
  000c9	d9 c1		 fld	 ST(1)
  000cb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c00000
  000d1	de c1		 faddp	 ST(1), ST(0)
  000d3	d8 ca		 fmul	 ST(0), ST(2)
  000d5	d9 c9		 fxch	 ST(1)
  000d7	d8 ca		 fmul	 ST(0), ST(2)
  000d9	de c1		 faddp	 ST(1), ST(0)
  000db	e8 00 00 00 00	 call	 __ftol2
  000e0	dd d8		 fstp	 ST(0)
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 3092 : }

  000e4	c2 04 00	 ret	 4
$L276189:

; 3086 : 
; 3087 : 		int nMaxFP = (int)( (((m_nLevel*2.0f) + (nSta*6.0f))*factor) +(nSta*factor) );
; 3088 : 		return nMaxFP;
; 3089 : 	}
; 3090 : 	
; 3091 : 	return ( ( m_nLevel * 2 ) + ( nStr * 7 ) + ( nSta *2 ) + ( nDex * 4 ) );

  000e7	8b 96 e0 05 00
	00		 mov	 edx, DWORD PTR [esi+1504]
  000ed	6b c0 07	 imul	 eax, 7
  000f0	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  000f3	03 cf		 add	 ecx, edi
  000f5	5f		 pop	 edi
  000f6	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  000f9	5e		 pop	 esi

; 3092 : }

  000fa	c2 04 00	 ret	 4
?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ENDP		; CMover::GetMaxOriginFatiguePoint
_TEXT	ENDS
PUBLIC	?GetResistSpell@CMover@@QAEHH@Z			; CMover::GetResistSpell
PUBLIC	??_C@_0CO@GBNLCJJD@CMover?3?3GetReistSpell?5?3?5?$CFd?5?G?A?$LH?N?F@ ; `string'
PUBLIC	??_C@_0CP@LCMNFNMN@CMover?3?3GetResistSpell?5?3?5?$CFs?5?F?D?$LG?s@ ; `string'
EXTRN	?GetName@CMover@@QAEPBDH@Z:NEAR			; CMover::GetName
;	COMDAT ??_C@_0CO@GBNLCJJD@CMover?3?3GetReistSpell?5?3?5?$CFd?5?G?A?$LH?N?F@
CONST	SEGMENT
??_C@_0CO@GBNLCJJD@CMover?3?3GetReistSpell?5?3?5?$CFd?5?G?A?$LH?N?F@ DB 'C'
	DB	'Mover::GetReistSpell : %d ', 0c7H, 0c1H, 0b7H, 0ceH, 0c6H, 0dbH
	DB	0c6H, 0bcH, ' ', 0c0H, 0d0H, 0b1H, 0e2H, ' ', 0bdH, 0c7H, 0c6H
	DB	0d0H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LCMNFNMN@CMover?3?3GetResistSpell?5?3?5?$CFs?5?F?D?$LG?s@
CONST	SEGMENT
??_C@_0CP@LCMNFNMN@CMover?3?3GetResistSpell?5?3?5?$CFs?5?F?D?$LG?s@ DB 'C'
	DB	'Mover::GetResistSpell : %s ', 0c6H, 0c4H, 0b6H, 0f3H, 0b8H, 0deH
	DB	0c5H, 0cdH, ' ', 0c0H, 0dfH, 0b8H, 0f8H, 0b5H, 0caH, ' %d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetResistSpell@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nDestParam$ = 8					; size = 4
?GetResistSpell@CMover@@QAEHH@Z PROC NEAR		; CMover::GetResistSpell, COMDAT
; _this$ = ecx

; 3292 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b e9		 mov	 ebp, ecx

; 3293 : 	MoverProp *pProp = GetProp();

  00004	8b 85 74 01 00
	00		 mov	 eax, DWORD PTR [ebp+372]
  0000a	85 c0		 test	 eax, eax
  0000c	8b 0d d0 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+464
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	7c 44		 jl	 SHORT $L283920
  00016	3b c1		 cmp	 eax, ecx
  00018	7d 40		 jge	 SHORT $L283920
  0001a	8b 0d d4 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+468
  00020	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  00026	03 c1		 add	 eax, ecx
  00028	8b f0		 mov	 esi, eax

; 3294 : 	if( pProp == NULL )

  0002a	85 f6		 test	 esi, esi
  0002c	75 17		 jne	 SHORT $L276247
$L283945:

; 3295 : 		Error( "CMover::GetReistSpell : %d   ", GetName() );

  0002e	6a 00		 push	 0
  00030	8b cd		 mov	 ecx, ebp
  00032	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00037	50		 push	 eax
  00038	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@GBNLCJJD@CMover?3?3GetReistSpell?5?3?5?$CFd?5?G?A?$LH?N?F@
  0003d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00042	83 c4 08	 add	 esp, 8
$L276247:

; 3296 : 
; 3297 : 	int		nResist = 0;
; 3298 : 
; 3299 : 	switch( nDestParam )

  00045	8b 5c 24 14	 mov	 ebx, DWORD PTR _nDestParam$[esp+12]
  00049	8d 43 e4	 lea	 eax, DWORD PTR [ebx-28]
  0004c	33 ff		 xor	 edi, edi
  0004e	83 f8 05	 cmp	 eax, 5
  00051	77 49		 ja	 SHORT $L276259
  00053	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L283946[eax*4]

; 3293 : 	MoverProp *pProp = GetProp();

$L283920:
  0005a	50		 push	 eax
  0005b	51		 push	 ecx
  0005c	6a 00		 push	 0
  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  00063	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00068	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
  00070	33 f6		 xor	 esi, esi

; 3294 : 	if( pProp == NULL )

  00072	eb ba		 jmp	 SHORT $L283945
$L276254:

; 3300 : 	{
; 3301 : 	case DST_RESIST_ELECTRICITY:	nResist = pProp->nResistElecricity;		break;

  00074	8b be 24 01 00
	00		 mov	 edi, DWORD PTR [esi+292]
  0007a	eb 38		 jmp	 SHORT $L276251
$L276255:

; 3302 : 	case DST_RESIST_FIRE:			nResist = pProp->nResistFire;		break;

  0007c	8b be 2c 01 00
	00		 mov	 edi, DWORD PTR [esi+300]
  00082	eb 30		 jmp	 SHORT $L276251
$L276256:

; 3303 : 	case DST_RESIST_WATER:			nResist = pProp->nResistWater;		break;

  00084	8b be 34 01 00
	00		 mov	 edi, DWORD PTR [esi+308]
  0008a	eb 28		 jmp	 SHORT $L276251
$L276257:

; 3304 : 	case DST_RESIST_EARTH:			nResist = pProp->nResistEarth;		break;

  0008c	8b be 38 01 00
	00		 mov	 edi, DWORD PTR [esi+312]
  00092	eb 20		 jmp	 SHORT $L276251
$L276258:

; 3305 : 	case DST_RESIST_WIND:			nResist = pProp->nResistWind;		break;

  00094	8b be 30 01 00
	00		 mov	 edi, DWORD PTR [esi+304]
  0009a	eb 18		 jmp	 SHORT $L276251
$L276259:

; 3306 : 	default:
; 3307 : 		Error( "CMover::GetResistSpell : %s   %d", GetName(), nDestParam );

  0009c	53		 push	 ebx
  0009d	6a 00		 push	 0
  0009f	8b cd		 mov	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@LCMNFNMN@CMover?3?3GetResistSpell?5?3?5?$CFs?5?F?D?$LG?s@
  000ac	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L276251:

; 3308 : 		break;
; 3309 : 	}
; 3310 : 	return GetParam( nDestParam, nResist );

  000b4	83 fb 75	 cmp	 ebx, 117		; 00000075H
  000b7	7d 22		 jge	 SHORT $L283942
  000b9	8b 84 9d 8c 14
	00 00		 mov	 eax, DWORD PTR [ebp+ebx*4+5260]
  000c0	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000c5	75 16		 jne	 SHORT $L283943
  000c7	8b 84 9d b8 12
	00 00		 mov	 eax, DWORD PTR [ebp+ebx*4+4792]
  000ce	85 c0		 test	 eax, eax
  000d0	74 09		 je	 SHORT $L283942
  000d2	03 c7		 add	 eax, edi
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp
  000d7	5b		 pop	 ebx

; 3311 : }

  000d8	c2 04 00	 ret	 4

; 3308 : 		break;
; 3309 : 	}
; 3310 : 	return GetParam( nDestParam, nResist );

$L283942:
  000db	8b c7		 mov	 eax, edi
$L283943:
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5d		 pop	 ebp
  000e0	5b		 pop	 ebx

; 3311 : }

  000e1	c2 04 00	 ret	 4
$L283946:
  000e4	00 00 00 00	 DD	 $L276254
  000e8	00 00 00 00	 DD	 $L276259
  000ec	00 00 00 00	 DD	 $L276255
  000f0	00 00 00 00	 DD	 $L276258
  000f4	00 00 00 00	 DD	 $L276256
  000f8	00 00 00 00	 DD	 $L276257
?GetResistSpell@CMover@@QAEHH@Z ENDP			; CMover::GetResistSpell
_TEXT	ENDS
PUBLIC	?GetNaturalArmor@CMover@@QAEHXZ			; CMover::GetNaturalArmor
; Function compile flags: /Ogty
;	COMDAT ?GetNaturalArmor@CMover@@QAEHXZ
_TEXT	SEGMENT
?GetNaturalArmor@CMover@@QAEHXZ PROC NEAR		; CMover::GetNaturalArmor, COMDAT
; _this$ = ecx

; 3315 : 	return GetProp()->dwNaturalArmor;//GetParam(DST_NATURAL_ARMOR,GetProp()->m_dwNaturalArmor);

  00000	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  00006	85 c0		 test	 eax, eax
  00008	8b 0d d0 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+464
  0000e	7c 19		 jl	 SHORT $L283978
  00010	3b c1		 cmp	 eax, ecx
  00012	7d 15		 jge	 SHORT $L283978
  00014	8b 0d d4 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+468
  0001a	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  00020	03 c1		 add	 eax, ecx
  00022	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]

; 3316 : }

  00028	c3		 ret	 0

; 3315 : 	return GetProp()->dwNaturalArmor;//GetParam(DST_NATURAL_ARMOR,GetProp()->m_dwNaturalArmor);

$L283978:
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	6a 00		 push	 0
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00037	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003c	33 c0		 xor	 eax, eax
  0003e	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  00044	83 c4 14	 add	 esp, 20			; 00000014H

; 3316 : }

  00047	c3		 ret	 0
?GetNaturalArmor@CMover@@QAEHXZ ENDP			; CMover::GetNaturalArmor
_TEXT	ENDS
PUBLIC	?GetSpeed@CMover@@QAEMM@Z			; CMover::GetSpeed
; Function compile flags: /Ogty
;	COMDAT ?GetSpeed@CMover@@QAEMM@Z
_TEXT	SEGMENT
_nAdjValue$ = 8						; size = 4
_fSrcSpeed$ = 8						; size = 4
?GetSpeed@CMover@@QAEMM@Z PROC NEAR			; CMover::GetSpeed, COMDAT
; _this$ = ecx

; 3405 : #if __VER >= 9	// __PET_0410
; 3406 : #ifdef __CLIENT
; 3407 : 	if( m_dwAIInterface == AII_EGG && m_pAIInterface )
; 3408 : 	{
; 3409 : 		CAIEgg* pAI	= (CAIEgg*)m_pAIInterface;
; 3410 : 		CMover* pOwner	= prj.GetMover( pAI->GetOwnerId() );
; 3411 : 		if( IsValidObj( pOwner ) )
; 3412 : 			return pOwner->GetSpeed( pOwner->m_pActMover->m_fSpeed );
; 3413 : 	}
; 3414 : #endif	// __CLIENT
; 3415 : #endif	// __PET_0410
; 3416 : 
; 3417 : #if __VER >= 9	//__AI_0509
; 3418 : 	fSrcSpeed	*= GetSpeedFactor();

  00000	d9 44 24 04	 fld	 DWORD PTR _fSrcSpeed$[esp-4]
  00004	d8 89 10 07 00
	00		 fmul	 DWORD PTR [ecx+1808]

; 3419 : #endif	// __AI_0509
; 3420 : 
; 3421 : 	if( m_fCrrSpd != 0.0f )

  0000a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
  00010	d9 81 50 02 00
	00		 fld	 DWORD PTR [ecx+592]
  00016	da e9		 fucompp
  00018	df e0		 fnstsw	 ax
  0001a	f6 c4 44	 test	 ah, 68			; 00000044H
  0001d	7b 0b		 jnp	 SHORT $L276288
  0001f	dd d8		 fstp	 ST(0)

; 3422 : 		return m_fCrrSpd;

  00021	d9 81 50 02 00
	00		 fld	 DWORD PTR [ecx+592]

; 3444 : #endif	// __JEFF_11
; 3445 : 
; 3446 : 	return fSrcSpeed;
; 3447 : }

  00027	c2 04 00	 ret	 4
$L276288:

; 3423 : 	int nChgValue	= GetChgParam( DST_SPEED );
; 3424 : //	if( nChgValue != 0x7FFFFFFF )
; 3425 : //		return fSrcSpeed * (nChgValue / 100.0f);		// ex) fSrcSpeed * 0.5f
; 3426 : 
; 3427 : 	// 
; 3428 : 	if( nChgValue != 0x7FFFFFFF )

  0002a	81 b9 b8 14 00
	00 ff ff ff 7f	 cmp	 DWORD PTR [ecx+5304], 2147483647 ; 7fffffffH
  00034	74 0b		 je	 SHORT $L276290

; 3419 : #endif	// __AI_0509
; 3420 : 
; 3421 : 	if( m_fCrrSpd != 0.0f )

  00036	dd d8		 fstp	 ST(0)

; 3429 : 		return 0;

  00038	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000

; 3444 : #endif	// __JEFF_11
; 3445 : 
; 3446 : 	return fSrcSpeed;
; 3447 : }

  0003e	c2 04 00	 ret	 4
$L276290:

; 3430 : 
; 3431 : 	int nAdjValue	= GetAdjParam( DST_SPEED );

  00041	8b 89 e4 12 00
	00		 mov	 ecx, DWORD PTR [ecx+4836]

; 3432 : 	if( nAdjValue != 0 )

  00047	85 c9		 test	 ecx, ecx
  00049	89 4c 24 04	 mov	 DWORD PTR _nAdjValue$[esp-4], ecx
  0004d	74 0e		 je	 SHORT $L276292

; 3433 : 	{
; 3434 : #ifdef __JEFF_11
; 3435 : 		fSrcSpeed = fSrcSpeed + ( fSrcSpeed * (nAdjValue / 100.0f) );

  0004f	db 44 24 04	 fild	 DWORD PTR _nAdjValue$[esp-4]
  00053	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00059	d8 c9		 fmul	 ST(0), ST(1)
  0005b	de c1		 faddp	 ST(1), ST(0)
$L276292:

; 3436 : 		if( fSrcSpeed < 0.0F )
; 3437 : 			fSrcSpeed	= 0.0F;
; 3438 : #endif	// __JEFF_11
; 3439 : 		return fSrcSpeed;
; 3440 : 	}
; 3441 : #ifdef __JEFF_11
; 3442 : 	if( fSrcSpeed < 0.0F )

  0005d	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  00063	df e0		 fnstsw	 ax
  00065	f6 c4 05	 test	 ah, 5
  00068	7a 08		 jp	 SHORT $L276287
  0006a	dd d8		 fstp	 ST(0)

; 3443 : 		fSrcSpeed	= 0.0F;

  0006c	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00000000
$L276287:

; 3444 : #endif	// __JEFF_11
; 3445 : 
; 3446 : 	return fSrcSpeed;
; 3447 : }

  00072	c2 04 00	 ret	 4
?GetSpeed@CMover@@QAEMM@Z ENDP				; CMover::GetSpeed
_TEXT	ENDS
PUBLIC	?ActionForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MKKHHHK@Z ; CMover::ActionForceSet
EXTRN	?ForcedSet@CActionMover@@QAEXAAUD3DXVECTOR3@@KKH@Z:NEAR ; CActionMover::ForcedSet
EXTRN	?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z:NEAR	; CObj::SetPos
EXTRN	?SetAngle@CObj@@QAEXM@Z:NEAR			; CObj::SetAngle
EXTRN	?SetMotionBlending@CModelObject@@QAEXH@Z:NEAR	; CModelObject::SetMotionBlending
; Function compile flags: /Ogty
;	COMDAT ?ActionForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MKKHHHK@Z
_TEXT	SEGMENT
$T284007 = -12						; size = 12
_vPos$ = 8						; size = 4
_vDelta$ = 12						; size = 4
_fAngle$ = 16						; size = 4
_dwState$ = 20						; size = 4
_dwStateFlag$ = 24					; size = 4
_nMotion$ = 28						; size = 4
_nMotionEx$ = 32					; size = 4
_nLoop$ = 36						; size = 4
_dwMotionOption$ = 40					; size = 4
?ActionForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MKKHHHK@Z PROC NEAR ; CMover::ActionForceSet, COMDAT
; _this$ = ecx

; 3478 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3479 : 	m_uRemnantCorrFrm	= 0;
; 3480 : 	if( m_pActMover == NULL )	return;

  00006	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0000c	85 c0		 test	 eax, eax
  0000e	c7 86 7c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+636], 0
  00018	0f 84 a4 00 00
	00		 je	 $L276314

; 3481 : 	CModelObject* pModel = (CModelObject*)m_pModel;
; 3482 : #ifdef __SYNC_1217
; 3483 : 	ClearDestPos();

  0001e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T284007[esp+16], 0
  00026	8b 4c 24 04	 mov	 ecx, DWORD PTR $T284007[esp+16]
  0002a	8d 86 60 02 00
	00		 lea	 eax, DWORD PTR [esi+608]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T284007[esp+20], 0
  0003a	8b 54 24 08	 mov	 edx, DWORD PTR $T284007[esp+20]
  0003e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3484 : #else	// __SYNC_1217
; 3485 : 	ClearDest();
; 3486 : #endif	// __SYNC_1217
; 3487 : 	ClearDestAngle();
; 3488 : 	SetPos( vPos );

  00041	8b 54 24 14	 mov	 edx, DWORD PTR _vPos$[esp+12]
  00045	57		 push	 edi
  00046	8b be 78 01 00
	00		 mov	 edi, DWORD PTR [esi+376]
  0004c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR $T284007[esp+28], 0
  00054	8b 4c 24 10	 mov	 ecx, DWORD PTR $T284007[esp+28]
  00058	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0005b	52		 push	 edx
  0005c	8b ce		 mov	 ecx, esi
  0005e	c7 86 6c 02 00
	00 00 00 80 bf	 mov	 DWORD PTR [esi+620], -1082130432 ; bf800000H
  00068	e8 00 00 00 00	 call	 ?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z ; CObj::SetPos

; 3489 : 	SetAngle( fAngle );

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR _fAngle$[esp+16]
  00071	50		 push	 eax
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle

; 3490 : 	m_pActMover->ForcedSet( vDelta, dwState, dwStateFlag, nMotionEx );

  00079	8b 4c 24 30	 mov	 ecx, DWORD PTR _nMotionEx$[esp+16]
  0007d	8b 54 24 28	 mov	 edx, DWORD PTR _dwStateFlag$[esp+16]
  00081	8b 44 24 24	 mov	 eax, DWORD PTR _dwState$[esp+16]
  00085	51		 push	 ecx
  00086	8b 4c 24 20	 mov	 ecx, DWORD PTR _vDelta$[esp+20]
  0008a	52		 push	 edx
  0008b	50		 push	 eax
  0008c	51		 push	 ecx
  0008d	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00093	e8 00 00 00 00	 call	 ?ForcedSet@CActionMover@@QAEXAAUD3DXVECTOR3@@KKH@Z ; CActionMover::ForcedSet

; 3491 : 	m_dwMotion = -1;
; 3492 : 	SetMotion( nMotion, nLoop, dwMotionOption );

  00098	8b 44 24 38	 mov	 eax, DWORD PTR _dwMotionOption$[esp+16]
  0009c	8b 4c 24 34	 mov	 ecx, DWORD PTR _nLoop$[esp+16]
  000a0	8b 16		 mov	 edx, DWORD PTR [esi]
  000a2	50		 push	 eax
  000a3	8b 44 24 30	 mov	 eax, DWORD PTR _nMotion$[esp+20]
  000a7	51		 push	 ecx
  000a8	50		 push	 eax
  000a9	8b ce		 mov	 ecx, esi
  000ab	c7 86 dc 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+732], -1
  000b5	ff 52 04	 call	 DWORD PTR [edx+4]

; 3493 : 	pModel->SetMotionBlending( FALSE );

  000b8	6a 00		 push	 0
  000ba	8b cf		 mov	 ecx, edi
  000bc	e8 00 00 00 00	 call	 ?SetMotionBlending@CModelObject@@QAEXH@Z ; CModelObject::SetMotionBlending
  000c1	5f		 pop	 edi
$L276314:
  000c2	5e		 pop	 esi

; 3494 : }

  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	c2 24 00	 ret	 36			; 00000024H
?ActionForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MKKHHHK@Z ENDP ; CMover::ActionForceSet
_TEXT	ENDS
PUBLIC	?ActionForceSet2@CMover@@QAEXAAUD3DXVECTOR3@@0MMMMKKHHHK@Z ; CMover::ActionForceSet2
EXTRN	?ForcedSet2@CActionMover@@QAEXAAUD3DXVECTOR3@@MMKKH@Z:NEAR ; CActionMover::ForcedSet2
EXTRN	?SetAngleX@CObj@@QAEXM@Z:NEAR			; CObj::SetAngleX
; Function compile flags: /Ogty
;	COMDAT ?ActionForceSet2@CMover@@QAEXAAUD3DXVECTOR3@@0MMMMKKHHHK@Z
_TEXT	SEGMENT
$T284035 = -12						; size = 12
_vPos$ = 8						; size = 4
_vDelta$ = 12						; size = 4
_fAngle$ = 16						; size = 4
_fAngleX$ = 20						; size = 4
_fAccPower$ = 24					; size = 4
_fTurnAngle$ = 28					; size = 4
_dwState$ = 32						; size = 4
_dwStateFlag$ = 36					; size = 4
_nMotion$ = 40						; size = 4
_nMotionEx$ = 44					; size = 4
_nLoop$ = 48						; size = 4
_dwMotionOption$ = 52					; size = 4
?ActionForceSet2@CMover@@QAEXAAUD3DXVECTOR3@@0MMMMKKHHHK@Z PROC NEAR ; CMover::ActionForceSet2, COMDAT
; _this$ = ecx

; 3499 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3500 : 	m_uRemnantCorrFrm	= 0;
; 3501 : 	if( m_pActMover == NULL )	return;

  00006	8b 86 3c 02 00
	00		 mov	 eax, DWORD PTR [esi+572]
  0000c	85 c0		 test	 eax, eax
  0000e	c7 86 7c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+636], 0
  00018	0f 84 da 00 00
	00		 je	 $L276332

; 3502 : 	CModelObject* pModel = (CModelObject*)m_pModel;
; 3503 : 	ClearDest();

  0001e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T284035[esp+16], 0
  00026	8b 4c 24 04	 mov	 ecx, DWORD PTR $T284035[esp+16]
  0002a	8d 86 60 02 00
	00		 lea	 eax, DWORD PTR [esi+608]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T284035[esp+20], 0
  0003a	8b 54 24 08	 mov	 edx, DWORD PTR $T284035[esp+20]
  0003e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3504 : 	ClearDestAngle();
; 3505 : 	SetPos( vPos );

  00041	8b 54 24 14	 mov	 edx, DWORD PTR _vPos$[esp+12]
  00045	57		 push	 edi
  00046	8b be 78 01 00
	00		 mov	 edi, DWORD PTR [esi+376]
  0004c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR $T284035[esp+28], 0
  00054	8b 4c 24 10	 mov	 ecx, DWORD PTR $T284035[esp+28]
  00058	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0005b	52		 push	 edx
  0005c	8b ce		 mov	 ecx, esi
  0005e	c7 86 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+604], -1
  00068	c7 86 58 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+600], 0
  00072	c7 86 6c 02 00
	00 00 00 80 bf	 mov	 DWORD PTR [esi+620], -1082130432 ; bf800000H
  0007c	e8 00 00 00 00	 call	 ?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z ; CObj::SetPos

; 3506 : 	SetAngle( fAngle );

  00081	8b 44 24 20	 mov	 eax, DWORD PTR _fAngle$[esp+16]
  00085	50		 push	 eax
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle

; 3507 : 	SetAngleX( fAngleX );

  0008d	8b 4c 24 24	 mov	 ecx, DWORD PTR _fAngleX$[esp+16]
  00091	51		 push	 ecx
  00092	8b ce		 mov	 ecx, esi
  00094	e8 00 00 00 00	 call	 ?SetAngleX@CObj@@QAEXM@Z ; CObj::SetAngleX

; 3508 : 	m_pActMover->ForcedSet2( vDelta, fAccPower, fTurnAngle, dwState, dwStateFlag, nMotionEx );

  00099	8b 54 24 3c	 mov	 edx, DWORD PTR _nMotionEx$[esp+16]
  0009d	8b 44 24 34	 mov	 eax, DWORD PTR _dwStateFlag$[esp+16]
  000a1	8b 4c 24 30	 mov	 ecx, DWORD PTR _dwState$[esp+16]
  000a5	52		 push	 edx
  000a6	8b 54 24 30	 mov	 edx, DWORD PTR _fTurnAngle$[esp+20]
  000aa	50		 push	 eax
  000ab	8b 44 24 30	 mov	 eax, DWORD PTR _fAccPower$[esp+24]
  000af	51		 push	 ecx
  000b0	8b 4c 24 28	 mov	 ecx, DWORD PTR _vDelta$[esp+28]
  000b4	52		 push	 edx
  000b5	50		 push	 eax
  000b6	51		 push	 ecx
  000b7	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  000bd	e8 00 00 00 00	 call	 ?ForcedSet2@CActionMover@@QAEXAAUD3DXVECTOR3@@MMKKH@Z ; CActionMover::ForcedSet2

; 3509 : 	m_dwMotion = -1;
; 3510 : #ifdef __WORLDSERVER	
; 3511 : 	if( nMotion == 31 && (dwMotionOption & MOP_FIXED) == 0 )

  000c2	8b 4c 24 38	 mov	 ecx, DWORD PTR _nMotion$[esp+16]
  000c6	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  000c9	8b 44 24 44	 mov	 eax, DWORD PTR _dwMotionOption$[esp+16]
  000cd	c7 86 dc 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+732], -1
  000d7	75 07		 jne	 SHORT $L276336
  000d9	a8 02		 test	 al, 2
  000db	75 03		 jne	 SHORT $L276336

; 3512 : 		dwMotionOption |= MOP_FIXED;	

  000dd	83 c8 02	 or	 eax, 2
$L276336:

; 3513 : #endif
; 3514 : 
; 3515 : 	SetMotion( nMotion, nLoop, dwMotionOption );

  000e0	8b 16		 mov	 edx, DWORD PTR [esi]
  000e2	50		 push	 eax
  000e3	8b 44 24 44	 mov	 eax, DWORD PTR _nLoop$[esp+20]
  000e7	50		 push	 eax
  000e8	51		 push	 ecx
  000e9	8b ce		 mov	 ecx, esi
  000eb	ff 52 04	 call	 DWORD PTR [edx+4]

; 3516 : 	pModel->SetMotionBlending( FALSE );

  000ee	6a 00		 push	 0
  000f0	8b cf		 mov	 ecx, edi
  000f2	e8 00 00 00 00	 call	 ?SetMotionBlending@CModelObject@@QAEXH@Z ; CModelObject::SetMotionBlending
  000f7	5f		 pop	 edi
$L276332:
  000f8	5e		 pop	 esi

; 3517 : }

  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	c2 30 00	 ret	 48			; 00000030H
?ActionForceSet2@CMover@@QAEXAAUD3DXVECTOR3@@0MMMMKKHHHK@Z ENDP ; CMover::ActionForceSet2
_TEXT	ENDS
PUBLIC	?HalfForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MMMM@Z ; CMover::HalfForceSet
EXTRN	?HalfForcedSet@CActionMover@@QAEXAAUD3DXVECTOR3@@MM@Z:NEAR ; CActionMover::HalfForcedSet
; Function compile flags: /Ogty
;	COMDAT ?HalfForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MMMM@Z
_TEXT	SEGMENT
$T284066 = -12						; size = 12
_vPos$ = 8						; size = 4
_vd$ = 12						; size = 4
_fAngle$ = 16						; size = 4
_fAngleX$ = 20						; size = 4
_fAccPower$ = 24					; size = 4
_fTurnAngle$ = 28					; size = 4
?HalfForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MMMM@Z PROC NEAR ; CMover::HalfForceSet, COMDAT
; _this$ = ecx

; 3520 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3521 : 	m_uRemnantCorrFrm	= 0;
; 3522 : 	if( m_pActMover == NULL )	return;

  00006	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  0000c	33 c0		 xor	 eax, eax
  0000e	3b c8		 cmp	 ecx, eax
  00010	89 86 7c 02 00
	00		 mov	 DWORD PTR [esi+636], eax
  00016	74 7e		 je	 SHORT $L276345

; 3523 : 	ClearDest();

  00018	89 44 24 04	 mov	 DWORD PTR $T284066[esp+16], eax
  0001c	8b 4c 24 04	 mov	 ecx, DWORD PTR $T284066[esp+16]
  00020	89 44 24 08	 mov	 DWORD PTR $T284066[esp+20], eax
  00024	8b 54 24 08	 mov	 edx, DWORD PTR $T284066[esp+20]
  00028	89 44 24 0c	 mov	 DWORD PTR $T284066[esp+24], eax
  0002c	89 86 58 02 00
	00		 mov	 DWORD PTR [esi+600], eax
  00032	8d 86 60 02 00
	00		 lea	 eax, DWORD PTR [esi+608]
  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	8b 4c 24 0c	 mov	 ecx, DWORD PTR $T284066[esp+24]
  0003e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3524 : 	ClearDestAngle();
; 3525 : 	SetPos( vPos );

  00041	8b 54 24 14	 mov	 edx, DWORD PTR _vPos$[esp+12]
  00045	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00048	52		 push	 edx
  00049	8b ce		 mov	 ecx, esi
  0004b	c7 86 5c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+604], -1
  00055	c7 86 6c 02 00
	00 00 00 80 bf	 mov	 DWORD PTR [esi+620], -1082130432 ; bf800000H
  0005f	e8 00 00 00 00	 call	 ?SetPos@CObj@@QAEXABUD3DXVECTOR3@@@Z ; CObj::SetPos

; 3526 : 	SetAngle( fAngle );

  00064	8b 44 24 1c	 mov	 eax, DWORD PTR _fAngle$[esp+12]
  00068	50		 push	 eax
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?SetAngle@CObj@@QAEXM@Z	; CObj::SetAngle

; 3527 : 	SetAngleX( fAngleX );

  00070	8b 4c 24 20	 mov	 ecx, DWORD PTR _fAngleX$[esp+12]
  00074	51		 push	 ecx
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?SetAngleX@CObj@@QAEXM@Z ; CObj::SetAngleX

; 3528 : 	m_pActMover->HalfForcedSet( vd, fAccPower, fTurnAngle );

  0007c	8b 54 24 28	 mov	 edx, DWORD PTR _fTurnAngle$[esp+12]
  00080	8b 44 24 24	 mov	 eax, DWORD PTR _fAccPower$[esp+12]
  00084	8b 4c 24 18	 mov	 ecx, DWORD PTR _vd$[esp+12]
  00088	52		 push	 edx
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	8b 8e 3c 02 00
	00		 mov	 ecx, DWORD PTR [esi+572]
  00091	e8 00 00 00 00	 call	 ?HalfForcedSet@CActionMover@@QAEXAAUD3DXVECTOR3@@MM@Z ; CActionMover::HalfForcedSet
$L276345:
  00096	5e		 pop	 esi

; 3529 : }

  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	c2 18 00	 ret	 24			; 00000018H
?HalfForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MMMM@Z ENDP	; CMover::HalfForceSet
_TEXT	ENDS
PUBLIC	?RemoveQuest@CMover@@QAEHH@Z			; CMover::RemoveQuest
; Function compile flags: /Ogty
;	COMDAT ?RemoveQuest@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nQuestId$ = 8						; size = 4
?RemoveQuest@CMover@@QAEHH@Z PROC NEAR			; CMover::RemoveQuest, COMDAT
; _this$ = ecx

; 3584 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 3585 : 	QuestProp* pProp = prj.m_aPropQuest.GetAt( nQuestId );
; 3586 : 
; 3587 : 	for( int i = 0; i < m_nQuestSize; i++ )

  00002	0f b6 b1 7e 0e
	00 00		 movzx	 esi, BYTE PTR [ecx+3710]
  00009	33 d2		 xor	 edx, edx
  0000b	85 f6		 test	 esi, esi
  0000d	57		 push	 edi
  0000e	8b 7c 24 10	 mov	 edi, DWORD PTR _nQuestId$[esp+8]
  00012	7e 69		 jle	 SHORT $L276390
  00014	8b 81 80 0e 00
	00		 mov	 eax, DWORD PTR [ecx+3712]
  0001a	83 c0 04	 add	 eax, 4
  0001d	8d 49 00	 npad	 3
$L276388:

; 3588 : 	{
; 3589 : 		if( m_aQuest[ i ].m_wId == nQuestId )

  00020	0f b7 18	 movzx	 ebx, WORD PTR [eax]
  00023	3b df		 cmp	 ebx, edi
  00025	74 11		 je	 SHORT $L284086
  00027	0f b6 99 7e 0e
	00 00		 movzx	 ebx, BYTE PTR [ecx+3710]
  0002e	42		 inc	 edx
  0002f	83 c0 0e	 add	 eax, 14			; 0000000eH
  00032	3b d3		 cmp	 edx, ebx
  00034	7c ea		 jl	 SHORT $L276388

; 3613 : 	{
; 3614 : 		if( m_aCheckedQuest[ i ] == nQuestId )

  00036	eb 45		 jmp	 SHORT $L276390
$L284086:

; 3590 : 		{
; 3591 : 			for( ; i < m_nQuestSize - 1; i++ )

  00038	4e		 dec	 esi
  00039	3b d6		 cmp	 edx, esi
  0003b	7d 3a		 jge	 SHORT $L276394
  0003d	8b f2		 mov	 esi, edx
  0003f	6b f6 0e	 imul	 esi, 14			; 0000000eH
  00042	55		 push	 ebp
$L276392:

; 3592 : 			{
; 3593 : 				m_aQuest[ i ] = m_aQuest[ i + 1 ];

  00043	8b 81 80 0e 00
	00		 mov	 eax, DWORD PTR [ecx+3712]
  00049	03 c6		 add	 eax, esi
  0004b	8d 58 0e	 lea	 ebx, DWORD PTR [eax+14]
  0004e	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  00050	89 28		 mov	 DWORD PTR [eax], ebp
  00052	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00055	89 68 04	 mov	 DWORD PTR [eax+4], ebp
  00058	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]
  0005b	89 68 08	 mov	 DWORD PTR [eax+8], ebp
  0005e	66 8b 5b 0c	 mov	 bx, WORD PTR [ebx+12]
  00062	66 89 58 0c	 mov	 WORD PTR [eax+12], bx
  00066	0f b6 81 7e 0e
	00 00		 movzx	 eax, BYTE PTR [ecx+3710]
  0006d	42		 inc	 edx
  0006e	83 c6 0e	 add	 esi, 14			; 0000000eH
  00071	48		 dec	 eax
  00072	3b d0		 cmp	 edx, eax
  00074	7c cd		 jl	 SHORT $L276392
  00076	5d		 pop	 ebp
$L276394:

; 3594 : 			}
; 3595 : 			m_nQuestSize--;

  00077	fe 89 7e 0e 00
	00		 dec	 BYTE PTR [ecx+3710]
$L276390:

; 3596 : 			break;
; 3597 : 		}
; 3598 : 	}
; 3599 : 	for( i = 0; i < m_nCompleteQuestSize; i++ )

  0007d	0f b6 b1 84 0e
	00 00		 movzx	 esi, BYTE PTR [ecx+3716]
  00084	33 c0		 xor	 eax, eax
  00086	85 f6		 test	 esi, esi
  00088	7e 4a		 jle	 SHORT $L276397
  0008a	8b 91 88 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3720]
$L276395:

; 3600 : 	{
; 3601 : 		if( m_aCompleteQuest[ i ] == nQuestId )

  00090	0f b7 1a	 movzx	 ebx, WORD PTR [edx]
  00093	3b df		 cmp	 ebx, edi
  00095	74 11		 je	 SHORT $L284087
  00097	0f b6 99 84 0e
	00 00		 movzx	 ebx, BYTE PTR [ecx+3716]
  0009e	40		 inc	 eax
  0009f	83 c2 02	 add	 edx, 2
  000a2	3b c3		 cmp	 eax, ebx
  000a4	7c ea		 jl	 SHORT $L276395

; 3613 : 	{
; 3614 : 		if( m_aCheckedQuest[ i ] == nQuestId )

  000a6	eb 2c		 jmp	 SHORT $L276397
$L284087:

; 3602 : 		{
; 3603 : 			for( ; i < m_nCompleteQuestSize - 1; i++ )

  000a8	4e		 dec	 esi
  000a9	3b c6		 cmp	 eax, esi
  000ab	7d 21		 jge	 SHORT $L276401
  000ad	8d 49 00	 npad	 3
$L276399:
  000b0	8b 91 88 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3720]

; 3604 : 			{
; 3605 : 				m_aCompleteQuest[ i ] = m_aCompleteQuest[ i + 1 ];

  000b6	66 8b 74 42 02	 mov	 si, WORD PTR [edx+eax*2+2]
  000bb	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  000be	66 89 32	 mov	 WORD PTR [edx], si
  000c1	0f b6 91 84 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3716]
  000c8	40		 inc	 eax
  000c9	4a		 dec	 edx
  000ca	3b c2		 cmp	 eax, edx
  000cc	7c e2		 jl	 SHORT $L276399
$L276401:

; 3606 : 			}
; 3607 : 			m_nCompleteQuestSize--;

  000ce	fe 89 84 0e 00
	00		 dec	 BYTE PTR [ecx+3716]
$L276397:

; 3608 : 			break;
; 3609 : 		}
; 3610 : 	}
; 3611 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 3612 : 	for( i = 0; i < m_nCheckedQuestSize; ++i )

  000d4	0f b6 b1 8c 0e
	00 00		 movzx	 esi, BYTE PTR [ecx+3724]
  000db	33 c0		 xor	 eax, eax
  000dd	85 f6		 test	 esi, esi
  000df	7e 6a		 jle	 SHORT $L284095
  000e1	8b 91 90 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3728]
$L276402:

; 3613 : 	{
; 3614 : 		if( m_aCheckedQuest[ i ] == nQuestId )

  000e7	0f b7 1a	 movzx	 ebx, WORD PTR [edx]
  000ea	3b df		 cmp	 ebx, edi
  000ec	74 1a		 je	 SHORT $L284088
  000ee	0f b6 99 8c 0e
	00 00		 movzx	 ebx, BYTE PTR [ecx+3724]
  000f5	40		 inc	 eax
  000f6	83 c2 02	 add	 edx, 2
  000f9	3b c3		 cmp	 eax, ebx
  000fb	7c ea		 jl	 SHORT $L276402
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi

; 3619 : 			break;
; 3620 : 		}
; 3621 : 	}
; 3622 : #endif // __IMPROVE_QUEST_INTERFACE
; 3623 : 
; 3624 : #ifdef __CLIENT
; 3625 : 	PlayMusic( BGM_EV_END );
; 3626 : #endif
; 3627 : 	return TRUE;

  000ff	b8 01 00 00 00	 mov	 eax, 1
  00104	5b		 pop	 ebx

; 3628 : }

  00105	c2 04 00	 ret	 4
$L284088:

; 3615 : 		{
; 3616 : 			for( ; i < m_nCheckedQuestSize -1; ++i )

  00108	4e		 dec	 esi
  00109	3b c6		 cmp	 eax, esi
  0010b	7d 21		 jge	 SHORT $L276408
  0010d	8d 49 00	 npad	 3
$L276406:
  00110	8b 91 90 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3728]

; 3617 : 				m_aCheckedQuest[ i ] = m_aCheckedQuest[ i + 1 ];

  00116	66 8b 74 42 02	 mov	 si, WORD PTR [edx+eax*2+2]
  0011b	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  0011e	66 89 32	 mov	 WORD PTR [edx], si
  00121	0f b6 91 8c 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3724]
  00128	40		 inc	 eax
  00129	4a		 dec	 edx
  0012a	3b c2		 cmp	 eax, edx
  0012c	7c e2		 jl	 SHORT $L276406
$L276408:

; 3618 : 			m_aCheckedQuest[ --m_nCheckedQuestSize ] = 0;

  0012e	8a 81 8c 0e 00
	00		 mov	 al, BYTE PTR [ecx+3724]
  00134	fe c8		 dec	 al
  00136	88 81 8c 0e 00
	00		 mov	 BYTE PTR [ecx+3724], al
  0013c	8b 89 90 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3728]
  00142	0f b6 c0	 movzx	 eax, al
  00145	66 c7 04 41 00
	00		 mov	 WORD PTR [ecx+eax*2], 0
$L284095:
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi

; 3619 : 			break;
; 3620 : 		}
; 3621 : 	}
; 3622 : #endif // __IMPROVE_QUEST_INTERFACE
; 3623 : 
; 3624 : #ifdef __CLIENT
; 3625 : 	PlayMusic( BGM_EV_END );
; 3626 : #endif
; 3627 : 	return TRUE;

  0014d	b8 01 00 00 00	 mov	 eax, 1
  00152	5b		 pop	 ebx

; 3628 : }

  00153	c2 04 00	 ret	 4
?RemoveQuest@CMover@@QAEHH@Z ENDP			; CMover::RemoveQuest
_TEXT	ENDS
PUBLIC	?__SetQuest@CMover@@AAEHPAUtagQuest@@0@Z	; CMover::__SetQuest
PUBLIC	??_C@_0BK@GLCNDIKD@SetQuestCnt?5?3?5?D?y?$LN?$LK?F?$KO?5?C?J?$LA?z?$AA@ ; `string'
;	COMDAT ??_C@_0BK@GLCNDIKD@SetQuestCnt?5?3?5?D?y?$LN?$LK?F?$KO?5?C?J?$LA?z?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BK@GLCNDIKD@SetQuestCnt?5?3?5?D?y?$LN?$LK?F?$KO?5?C?J?$LA?z?$AA@ DB 'S'
	DB	'etQuestCnt : ', 0c4H, 0f9H, 0bdH, 0baH, 0c6H, 0aeH, ' ', 0c3H
	DB	0caH, 0b0H, 0faH, 00H			; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	ENDS
;	COMDAT ?__SetQuest@CMover@@AAEHPAUtagQuest@@0@Z
_TEXT	SEGMENT
_lpQuest$ = 8						; size = 4
_lpNewQuest$ = 12					; size = 4
?__SetQuest@CMover@@AAEHPAUtagQuest@@0@Z PROC NEAR	; CMover::__SetQuest, COMDAT
; _this$ = ecx

; 3654 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 3655 : 	//     .
; 3656 : 	if( lpQuest == NULL )

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _lpQuest$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	0f 85 a6 00 00
	00		 jne	 $L276432

; 3657 : 	{
; 3658 : 		if( m_nQuestSize >= MAX_QUEST )

  0000e	8a 81 7e 0e 00
	00		 mov	 al, BYTE PTR [ecx+3710]
  00014	3c 64		 cmp	 al, 100			; 00000064H
  00016	72 14		 jb	 SHORT $L276433

; 3659 : 		{
; 3660 : 			Error("SetQuestCnt :  ");

  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@GLCNDIKD@SetQuestCnt?5?3?5?D?y?$LN?$LK?F?$KO?5?C?J?$LA?z?$AA@
  0001d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00022	83 c4 04	 add	 esp, 4
$L276441:
  00025	5e		 pop	 esi

; 3661 : 			return FALSE;

  00026	33 c0		 xor	 eax, eax
  00028	5b		 pop	 ebx

; 3733 : }

  00029	c2 08 00	 ret	 8
$L276433:

; 3662 : 		}
; 3663 : #ifdef __CLIENT
; 3664 : 		PlayMusic( BGM_EV_START );
; 3665 : #endif
; 3666 : 		if( m_nCompleteQuestSize < MAX_COMPLETE_QUEST ) 

  0002c	0f b6 91 84 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3716]
  00033	81 fa 2c 01 00
	00		 cmp	 edx, 300		; 0000012cH
  00039	7d ea		 jge	 SHORT $L276441

; 3667 : 			lpQuest = &m_aQuest[ m_nQuestSize++ ];

  0003b	8b 99 80 0e 00
	00		 mov	 ebx, DWORD PTR [ecx+3712]
  00041	0f b6 f0	 movzx	 esi, al
  00044	6b f6 0e	 imul	 esi, 14			; 0000000eH
  00047	03 f3		 add	 esi, ebx

; 3668 : 		else
; 3669 : 			return FALSE;
; 3670 : 
; 3671 : 		QuestProp* pQuestProp = prj.m_aPropQuest.GetAt( lpNewQuest->m_wId );

  00049	8b 5c 24 10	 mov	 ebx, DWORD PTR _lpNewQuest$[esp+4]
  0004d	fe c0		 inc	 al
  0004f	88 81 7e 0e 00
	00		 mov	 BYTE PTR [ecx+3710], al
  00055	0f b7 43 04	 movzx	 eax, WORD PTR [ebx+4]
  00059	3b 05 10 03 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A+784
  0005f	73 1e		 jae	 SHORT $L276438
  00061	8b 15 00 03 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+768
  00067	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]

; 3672 : 		if( pQuestProp && pQuestProp->m_nEndCondLimitTime  )

  0006a	85 c0		 test	 eax, eax
  0006c	74 11		 je	 SHORT $L276438
  0006e	8b 90 14 01 00
	00		 mov	 edx, DWORD PTR [eax+276]
  00074	85 d2		 test	 edx, edx
  00076	74 07		 je	 SHORT $L276438

; 3673 : 			lpNewQuest->m_wTime = pQuestProp->m_nEndCondLimitTime;

  00078	66 8b c2	 mov	 ax, dx
  0007b	66 89 43 02	 mov	 WORD PTR [ebx+2], ax
$L276438:

; 3674 : #ifdef __WORLDSERVER
; 3675 : 		//   
; 3676 : 		m_timerQuestLimitTime.Reset();

  0007f	8b 91 b0 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3760]
  00085	81 c1 b0 0e 00
	00		 add	 ecx, 3760		; 00000eb0H
  0008b	ff 52 04	 call	 DWORD PTR [edx+4]
$L276459:

; 3715 : 			lpQuest = NULL;
; 3716 : #if __VER >= 15 /* __IMPROVE_QUEST_INTERFACE */  && defined( __CLIENT )
; 3717 : 			g_QuestTreeInfoManager.DeleteTreeInformation( lpNewQuest->m_wId );
; 3718 : 			D3DXVECTOR3& rDestinationArrow = g_WndMng.m_pWndWorld->m_vDestinationArrow;
; 3719 : 			rDestinationArrow = D3DXVECTOR3( -1.0F, 0.0F, -1.0F );
; 3720 : #endif // defined( __IMPROVE_QUEST_INTERFACE ) && defined( __CLIENT )
; 3721 : 		}
; 3722 : 		else
; 3723 : 			return FALSE;
; 3724 : 	}
; 3725 : 	if( lpQuest )

  0008e	85 f6		 test	 esi, esi
  00090	74 18		 je	 SHORT $L276460

; 3726 : 		memcpy( lpQuest, lpNewQuest, sizeof( QUEST ) );

  00092	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00094	89 0e		 mov	 DWORD PTR [esi], ecx
  00096	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00099	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0009c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0009f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a2	66 8b 4b 0c	 mov	 cx, WORD PTR [ebx+12]
  000a6	66 89 4e 0c	 mov	 WORD PTR [esi+12], cx
$L276460:
  000aa	5e		 pop	 esi

; 3727 : 
; 3728 : #ifdef __CLIENT
; 3729 : 	if( lpNewQuest->m_nState == QS_END )
; 3730 : 		PlayMusic( BGM_EV_END );
; 3731 : #endif
; 3732 : 	return TRUE;

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	5b		 pop	 ebx

; 3733 : }

  000b1	c2 08 00	 ret	 8
$L276432:

; 3677 : #endif
; 3678 : 	}
; 3679 : 	else
; 3680 : 	//  .     
; 3681 : 	if( lpNewQuest->m_nState == QS_END )

  000b4	8b 5c 24 10	 mov	 ebx, DWORD PTR _lpNewQuest$[esp+4]
  000b8	80 3b 0e	 cmp	 BYTE PTR [ebx], 14	; 0000000eH
  000bb	75 d1		 jne	 SHORT $L276459

; 3682 : 	{
; 3683 : 		// ,     .
; 3684 : 		if( m_nCompleteQuestSize < MAX_COMPLETE_QUEST ) 

  000bd	0f b6 81 84 0e
	00 00		 movzx	 eax, BYTE PTR [ecx+3716]
  000c4	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  000c9	0f 8d 56 ff ff
	ff		 jge	 $L276441
  000cf	55		 push	 ebp
  000d0	57		 push	 edi

; 3685 : 		{
; 3686 : 			for( int i = 0; i < m_nQuestSize; i++ )

  000d1	0f b6 b9 7e 0e
	00 00		 movzx	 edi, BYTE PTR [ecx+3710]
  000d8	33 d2		 xor	 edx, edx
  000da	85 ff		 test	 edi, edi
  000dc	7e 6b		 jle	 SHORT $L276445
  000de	8b 81 80 0e 00
	00		 mov	 eax, DWORD PTR [ecx+3712]
  000e4	66 8b 73 04	 mov	 si, WORD PTR [ebx+4]
  000e8	83 c0 04	 add	 eax, 4
  000eb	eb 03 8d 49 00	 npad	 5
$L284119:

; 3687 : 			{
; 3688 : 				if( m_aQuest[ i ].m_wId == lpNewQuest->m_wId )

  000f0	66 39 30	 cmp	 WORD PTR [eax], si
  000f3	74 11		 je	 SHORT $L284113
  000f5	0f b6 a9 7e 0e
	00 00		 movzx	 ebp, BYTE PTR [ecx+3710]
  000fc	42		 inc	 edx
  000fd	83 c0 0e	 add	 eax, 14			; 0000000eH
  00100	3b d5		 cmp	 edx, ebp
  00102	7c ec		 jl	 SHORT $L284119

; 3700 : 			{
; 3701 : 				if( m_aCheckedQuest[ i ] == lpNewQuest->m_wId )

  00104	eb 43		 jmp	 SHORT $L276445
$L284113:

; 3689 : 				{
; 3690 : 					for( ; i < m_nQuestSize - 1; i++ )

  00106	4f		 dec	 edi
  00107	3b d7		 cmp	 edx, edi
  00109	7d 38		 jge	 SHORT $L276449
  0010b	8b f2		 mov	 esi, edx
  0010d	6b f6 0e	 imul	 esi, 14			; 0000000eH
$L276447:

; 3691 : 					{
; 3692 : 						m_aQuest[ i ] = m_aQuest[ i + 1 ];

  00110	8b 81 80 0e 00
	00		 mov	 eax, DWORD PTR [ecx+3712]
  00116	03 c6		 add	 eax, esi
  00118	8d 78 0e	 lea	 edi, DWORD PTR [eax+14]
  0011b	8b 2f		 mov	 ebp, DWORD PTR [edi]
  0011d	89 28		 mov	 DWORD PTR [eax], ebp
  0011f	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00122	89 68 04	 mov	 DWORD PTR [eax+4], ebp
  00125	8b 6f 08	 mov	 ebp, DWORD PTR [edi+8]
  00128	89 68 08	 mov	 DWORD PTR [eax+8], ebp
  0012b	66 8b 7f 0c	 mov	 di, WORD PTR [edi+12]
  0012f	66 89 78 0c	 mov	 WORD PTR [eax+12], di
  00133	0f b6 81 7e 0e
	00 00		 movzx	 eax, BYTE PTR [ecx+3710]
  0013a	42		 inc	 edx
  0013b	83 c6 0e	 add	 esi, 14			; 0000000eH
  0013e	48		 dec	 eax
  0013f	3b d0		 cmp	 edx, eax
  00141	7c cd		 jl	 SHORT $L276447
$L276449:

; 3693 : 					}
; 3694 : 					m_nQuestSize--;

  00143	fe 89 7e 0e 00
	00		 dec	 BYTE PTR [ecx+3710]
$L276445:

; 3695 : 					break;
; 3696 : 				}
; 3697 : 			}
; 3698 : #if __VER >= 15 // __IMPROVE_QUEST_INTERFACE
; 3699 : 			for( i = 0; i < m_nCheckedQuestSize; ++i )

  00149	0f b6 b9 8c 0e
	00 00		 movzx	 edi, BYTE PTR [ecx+3724]
  00150	33 c0		 xor	 eax, eax
  00152	85 ff		 test	 edi, edi
  00154	7e 65		 jle	 SHORT $L276452
  00156	66 8b 73 04	 mov	 si, WORD PTR [ebx+4]
  0015a	8b 91 90 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3728]
$L284120:

; 3700 : 			{
; 3701 : 				if( m_aCheckedQuest[ i ] == lpNewQuest->m_wId )

  00160	66 39 32	 cmp	 WORD PTR [edx], si
  00163	74 11		 je	 SHORT $L284114
  00165	0f b6 a9 8c 0e
	00 00		 movzx	 ebp, BYTE PTR [ecx+3724]
  0016c	40		 inc	 eax
  0016d	83 c2 02	 add	 edx, 2
  00170	3b c5		 cmp	 eax, ebp
  00172	7c ec		 jl	 SHORT $L284120
  00174	eb 45		 jmp	 SHORT $L276452
$L284114:

; 3702 : 				{
; 3703 : 					for( ; i < m_nCheckedQuestSize - 1; ++i )

  00176	4f		 dec	 edi
  00177	3b c7		 cmp	 eax, edi
  00179	7d 23		 jge	 SHORT $L276456
  0017b	eb 03 8d 49 00	 npad	 5
$L276454:
  00180	8b 91 90 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3728]

; 3704 : 						m_aCheckedQuest[ i ] = m_aCheckedQuest[ i + 1 ];

  00186	66 8b 74 42 02	 mov	 si, WORD PTR [edx+eax*2+2]
  0018b	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  0018e	66 89 32	 mov	 WORD PTR [edx], si
  00191	0f b6 91 8c 0e
	00 00		 movzx	 edx, BYTE PTR [ecx+3724]
  00198	40		 inc	 eax
  00199	4a		 dec	 edx
  0019a	3b c2		 cmp	 eax, edx
  0019c	7c e2		 jl	 SHORT $L276454
$L276456:

; 3705 : 					m_aCheckedQuest[--m_nCheckedQuestSize] = 0;

  0019e	8a 81 8c 0e 00
	00		 mov	 al, BYTE PTR [ecx+3724]
  001a4	8b 91 90 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3728]
  001aa	fe c8		 dec	 al
  001ac	88 81 8c 0e 00
	00		 mov	 BYTE PTR [ecx+3724], al
  001b2	0f b6 c0	 movzx	 eax, al
  001b5	66 c7 04 42 00
	00		 mov	 WORD PTR [edx+eax*2], 0
$L276452:

; 3706 : 					break;
; 3707 : 				}
; 3708 : 			}
; 3709 : #endif // __IMPROVE_QUEST_INTERFACE
; 3710 : 			QuestProp* pProp = prj.m_aPropQuest.GetAt( lpNewQuest->m_wId );

  001bb	66 8b 53 04	 mov	 dx, WORD PTR [ebx+4]
  001bf	8b 35 10 03 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+784
  001c5	0f b7 c2	 movzx	 eax, dx
  001c8	3b c6		 cmp	 eax, esi
  001ca	5f		 pop	 edi
  001cb	5d		 pop	 ebp
  001cc	0f 83 d8 fe ff
	ff		 jae	 $L276460
  001d2	8b 35 00 03 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+768
  001d8	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]

; 3711 : 			//       . 
; 3712 : 			//if( pProp->m_nQuestType != QT_REQUEST && pProp->m_bRepeat == FALSE )
; 3713 : 			if( pProp && pProp->m_bRepeat == FALSE )

  001db	85 c0		 test	 eax, eax
  001dd	0f 84 c7 fe ff
	ff		 je	 $L276460
  001e3	8a 98 d1 03 00
	00		 mov	 bl, BYTE PTR [eax+977]
  001e9	84 db		 test	 bl, bl
  001eb	0f 85 b9 fe ff
	ff		 jne	 $L276460

; 3714 : 				m_aCompleteQuest[ m_nCompleteQuestSize++ ] = lpNewQuest->m_wId; 

  001f1	0f b6 81 84 0e
	00 00		 movzx	 eax, BYTE PTR [ecx+3716]
  001f8	8b b1 88 0e 00
	00		 mov	 esi, DWORD PTR [ecx+3720]
  001fe	66 89 14 46	 mov	 WORD PTR [esi+eax*2], dx
  00202	8a 81 84 0e 00
	00		 mov	 al, BYTE PTR [ecx+3716]
  00208	fe c0		 inc	 al
  0020a	5e		 pop	 esi
  0020b	88 81 84 0e 00
	00		 mov	 BYTE PTR [ecx+3716], al

; 3727 : 
; 3728 : #ifdef __CLIENT
; 3729 : 	if( lpNewQuest->m_nState == QS_END )
; 3730 : 		PlayMusic( BGM_EV_END );
; 3731 : #endif
; 3732 : 	return TRUE;

  00211	b8 01 00 00 00	 mov	 eax, 1
  00216	5b		 pop	 ebx

; 3733 : }

  00217	c2 08 00	 ret	 8
?__SetQuest@CMover@@AAEHPAUtagQuest@@0@Z ENDP		; CMover::__SetQuest
_TEXT	ENDS
PUBLIC	?GetItemNum@CMover@@QAEHK@Z			; CMover::GetItemNum
EXTRN	?IsUsableItem@@YAHPAVCItemBase@@@Z:NEAR		; IsUsableItem
; Function compile flags: /Ogty
;	COMDAT ?GetItemNum@CMover@@QAEHK@Z
_TEXT	SEGMENT
_nNum$ = -8						; size = 4
_nSize$ = -4						; size = 4
_dwItemId$ = 8						; size = 4
?GetItemNum@CMover@@QAEHK@Z PROC NEAR			; CMover::GetItemNum, COMDAT
; _this$ = ecx

; 3741 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx

; 3742 : 	int nNum	= 0;
; 3743 : 	int nSize	= m_Inventory.GetMax();

  00008	8b 83 9c 0b 00
	00		 mov	 eax, DWORD PTR [ebx+2972]
  0000e	33 ed		 xor	 ebp, ebp
  00010	57		 push	 edi

; 3744 : 	CItemElem* pItemElem;
; 3745 : 	for( int i = 0 ; i < nSize; i++ )

  00011	33 ff		 xor	 edi, edi
  00013	3b c5		 cmp	 eax, ebp
  00015	89 6c 24 10	 mov	 DWORD PTR _nNum$[esp+24], ebp
  00019	89 44 24 14	 mov	 DWORD PTR _nSize$[esp+24], eax
  0001d	7e 49		 jle	 SHORT $L276476
  0001f	90		 npad	 1
$L284149:

; 3746 : 	{
; 3747 : 		pItemElem	= m_Inventory.GetAtId( i );

  00020	3b bb 9c 0b 00
	00		 cmp	 edi, DWORD PTR [ebx+2972]
  00026	73 31		 jae	 SHORT $L276475
  00028	8b b3 a0 0b 00
	00		 mov	 esi, DWORD PTR [ebx+2976]
  0002e	8b 44 2e 0c	 mov	 eax, DWORD PTR [esi+ebp+12]
  00032	03 f5		 add	 esi, ebp
  00034	85 c0		 test	 eax, eax
  00036	74 21		 je	 SHORT $L276475

; 3748 : 		if( pItemElem )
; 3749 : 		{
; 3750 : 			//raiders.06.05.02 (prevent abuse quest ending condition : trade & quest )
; 3751 : 			if( IsUsableItem( pItemElem ) == FALSE )

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ?IsUsableItem@@YAHPAVCItemBase@@@Z ; IsUsableItem
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	74 31		 je	 SHORT $L284146

; 3753 : 			if( pItemElem->m_dwItemId == dwItemId )

  00045	8b 44 24 1c	 mov	 eax, DWORD PTR _dwItemId$[esp+20]
  00049	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  0004c	75 0b		 jne	 SHORT $L276475

; 3754 : 				nNum	+= pItemElem->m_nItemNum;

  0004e	0f bf 8e 80 00
	00 00		 movsx	 ecx, WORD PTR [esi+128]
  00055	01 4c 24 10	 add	 DWORD PTR _nNum$[esp+24], ecx
$L276475:
  00059	8b 44 24 14	 mov	 eax, DWORD PTR _nSize$[esp+24]
  0005d	47		 inc	 edi
  0005e	81 c5 b8 00 00
	00		 add	 ebp, 184		; 000000b8H
  00064	3b f8		 cmp	 edi, eax
  00066	7c b8		 jl	 SHORT $L284149
$L276476:

; 3755 : 		}
; 3756 : 	}
; 3757 : 	return nNum;

  00068	8b 44 24 10	 mov	 eax, DWORD PTR _nNum$[esp+24]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	5b		 pop	 ebx

; 3758 : }

  00070	83 c4 08	 add	 esp, 8
  00073	c2 04 00	 ret	 4
$L284146:
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5d		 pop	 ebp

; 3752 : 				return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	5b		 pop	 ebx

; 3758 : }

  0007c	83 c4 08	 add	 esp, 8
  0007f	c2 04 00	 ret	 4
?GetItemNum@CMover@@QAEHK@Z ENDP			; CMover::GetItemNum
_TEXT	ENDS
PUBLIC	?OnTradeRemoveUser@CMover@@QAEXXZ		; CMover::OnTradeRemoveUser
EXTRN	?TradeClear@CVTInfo@@QAEXXZ:NEAR		; CVTInfo::TradeClear
; Function compile flags: /Ogty
;	COMDAT ?OnTradeRemoveUser@CMover@@QAEXXZ
_TEXT	SEGMENT
?OnTradeRemoveUser@CMover@@QAEXXZ PROC NEAR		; CMover::OnTradeRemoveUser, COMDAT
; _this$ = ecx

; 3833 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3834 : 	if( IsPlayer() )

  00003	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00009	85 c0		 test	 eax, eax
  0000b	74 45		 je	 SHORT $L276511
  0000d	53		 push	 ebx

; 3835 : 	{
; 3836 : 		CMover* pOther = m_vtInfo.GetOther();

  0000e	8d 9e 7c 0d 00
	00		 lea	 ebx, DWORD PTR [esi+3452]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?GetOther@CVTInfo@@QAEPAVCMover@@XZ ; CVTInfo::GetOther

; 3837 : 		if( IsValidObj( pOther ) && pOther->IsPlayer() )

  0001b	85 c0		 test	 eax, eax
  0001d	74 2a		 je	 SHORT $L276514
  0001f	f6 40 04 01	 test	 BYTE PTR [eax+4], 1
  00023	75 24		 jne	 SHORT $L276514
  00025	8b 88 34 02 00
	00		 mov	 ecx, DWORD PTR [eax+564]
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 1a		 je	 SHORT $L276514
  0002f	57		 push	 edi

; 3838 : 		{	
; 3839 : 			if( pOther->m_vtInfo.GetOther() == this )

  00030	8d b8 7c 0d 00
	00		 lea	 edi, DWORD PTR [eax+3452]
  00036	8b cf		 mov	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?GetOther@CVTInfo@@QAEPAVCMover@@XZ ; CVTInfo::GetOther
  0003d	3b c6		 cmp	 eax, esi
  0003f	75 07		 jne	 SHORT $L284174

; 3840 : 			{
; 3841 : 				pOther->m_vtInfo.TradeClear();

  00041	8b cf		 mov	 ecx, edi
  00043	e8 00 00 00 00	 call	 ?TradeClear@CVTInfo@@QAEXXZ ; CVTInfo::TradeClear
$L284174:
  00048	5f		 pop	 edi
$L276514:

; 3842 : 			}
; 3843 : 		}
; 3844 : 		m_vtInfo.TradeClear();

  00049	8b cb		 mov	 ecx, ebx
  0004b	5b		 pop	 ebx
  0004c	5e		 pop	 esi
  0004d	e9 00 00 00 00	 jmp	 ?TradeClear@CVTInfo@@QAEXXZ ; CVTInfo::TradeClear
$L276511:
  00052	5e		 pop	 esi

; 3845 : 	}
; 3846 : }

  00053	c3		 ret	 0
?OnTradeRemoveUser@CMover@@QAEXXZ ENDP			; CMover::OnTradeRemoveUser
_TEXT	ENDS
PUBLIC	?GetRandomPartsAbraded@CMover@@QAEKXZ		; CMover::GetRandomPartsAbraded
; Function compile flags: /Ogty
;	COMDAT ?GetRandomPartsAbraded@CMover@@QAEKXZ
_TEXT	SEGMENT
?GetRandomPartsAbraded@CMover@@QAEKXZ PROC NEAR		; CMover::GetRandomPartsAbraded, COMDAT
; _this$ = ecx

; 3922 : //	 50%
; 3923 : 	int nRand	= xRand();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00005	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0000b	05 39 30 00 00	 add	 eax, 12345		; 00003039H

; 3924 : 	if( nRand % 2 )

  00010	8b c8		 mov	 ecx, eax
  00012	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  0001d	79 05		 jns	 SHORT $L284182
  0001f	49		 dec	 ecx
  00020	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00023	41		 inc	 ecx
$L284182:
  00024	74 06		 je	 SHORT $L276525

; 3925 : 		return PARTS_SHIELD;

  00026	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 3932 : 		return PARTS_HAND;
; 3933 : 	else	// 15%
; 3934 : 		return PARTS_FOOT;
; 3935 : }

  0002b	c3		 ret	 0
$L276525:

; 3926 : 	nRand	= nRand % 100;

  0002c	99		 cdq
  0002d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00032	f7 f9		 idiv	 ecx

; 3927 : 	if( nRand < 20 )	// 20%

  00034	83 fa 14	 cmp	 edx, 20			; 00000014H
  00037	7d 06		 jge	 SHORT $L276526

; 3928 : 		return PARTS_CAP;

  00039	b8 06 00 00 00	 mov	 eax, 6

; 3932 : 		return PARTS_HAND;
; 3933 : 	else	// 15%
; 3934 : 		return PARTS_FOOT;
; 3935 : }

  0003e	c3		 ret	 0
$L276526:

; 3929 : 	else if( nRand < 60 )	// 40%

  0003f	83 fa 3c	 cmp	 edx, 60			; 0000003cH
  00042	7d 06		 jge	 SHORT $L276528

; 3930 : 		return PARTS_UPPER_BODY;

  00044	b8 02 00 00 00	 mov	 eax, 2

; 3932 : 		return PARTS_HAND;
; 3933 : 	else	// 15%
; 3934 : 		return PARTS_FOOT;
; 3935 : }

  00049	c3		 ret	 0
$L276528:

; 3931 : 	else if( nRand < 85 )	// 25%

  0004a	33 c0		 xor	 eax, eax
  0004c	83 fa 55	 cmp	 edx, 85			; 00000055H
  0004f	0f 9d c0	 setge	 al
  00052	83 c0 04	 add	 eax, 4

; 3932 : 		return PARTS_HAND;
; 3933 : 	else	// 15%
; 3934 : 		return PARTS_FOOT;
; 3935 : }

  00055	c3		 ret	 0
?GetRandomPartsAbraded@CMover@@QAEKXZ ENDP		; CMover::GetRandomPartsAbraded
_TEXT	ENDS
PUBLIC	?UpdateItemEx@CMover@@QAEXED_J@Z		; CMover::UpdateItemEx
EXTRN	?AddUpdateItemEx@CUser@@QAEXED_J@Z:NEAR		; CUser::AddUpdateItemEx
EXTRN	?GetItemId@CMover@@QAEPAVCItemBase@@K@Z:NEAR	; CMover::GetItemId
; Function compile flags: /Ogty
;	COMDAT ?UpdateItemEx@CMover@@QAEXED_J@Z
_TEXT	SEGMENT
_id$ = 8						; size = 1
_cParam$ = 12						; size = 1
_iValue$ = 16						; size = 8
?UpdateItemEx@CMover@@QAEXED_J@Z PROC NEAR		; CMover::UpdateItemEx, COMDAT
; _this$ = ecx

; 3963 : {

  00000	53		 push	 ebx

; 3964 : 	CItemElem* pItemElem	= (CItemElem*)GetItemId( id );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _id$[esp]
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	0f b6 c3	 movzx	 eax, bl
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	8b f1		 mov	 esi, ecx
  0000e	e8 00 00 00 00	 call	 ?GetItemId@CMover@@QAEPAVCItemBase@@K@Z ; CMover::GetItemId

; 3965 : 
; 3966 : 	if( pItemElem )

  00013	85 c0		 test	 eax, eax
  00015	8b 7c 24 20	 mov	 edi, DWORD PTR _iValue$[esp+16]
  00019	8b 6c 24 1c	 mov	 ebp, DWORD PTR _iValue$[esp+12]
  0001d	8b 4c 24 18	 mov	 ecx, DWORD PTR _cParam$[esp+12]
  00021	74 11		 je	 SHORT $L284188

; 3967 : 	{
; 3968 : 		switch( cParam )

  00023	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00026	75 0c		 jne	 SHORT $L284188

; 3969 : 		{
; 3970 : 			case UI_RANDOMOPTITEMID:
; 3971 : 				{
; 3972 : 					pItemElem->SetRandomOptItemId( iValue );

  00028	89 a8 98 00 00
	00		 mov	 DWORD PTR [eax+152], ebp
  0002e	89 b8 9c 00 00
	00		 mov	 DWORD PTR [eax+156], edi
$L284188:

; 3973 : 					break;
; 3974 : 				}
; 3975 : 			default:
; 3976 : 				break;
; 3977 : 		}
; 3978 : #ifdef __CLIENT
; 3979 : 		CWndInventory* pWnd		= (CWndInventory*)g_WndMng.GetWndBase( APP_INVENTORY );
; 3980 : 		if( pWnd )
; 3981 : 			pWnd->UpdateTooltip();
; 3982 : #endif	// __CLIENT
; 3983 : 	}
; 3984 : #ifdef __WORLDSERVER
; 3985 : 	if( IsPlayer() )

  00034	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0003a	85 c0		 test	 eax, eax
  0003c	74 0b		 je	 SHORT $L276555

; 3986 : 		( (CUser*)this )->AddUpdateItemEx( id, cParam, iValue );

  0003e	57		 push	 edi
  0003f	55		 push	 ebp
  00040	51		 push	 ecx
  00041	53		 push	 ebx
  00042	8b ce		 mov	 ecx, esi
  00044	e8 00 00 00 00	 call	 ?AddUpdateItemEx@CUser@@QAEXED_J@Z ; CUser::AddUpdateItemEx
$L276555:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5d		 pop	 ebp
  0004c	5b		 pop	 ebx

; 3987 : #endif
; 3988 : }

  0004d	c2 10 00	 ret	 16			; 00000010H
?UpdateItemEx@CMover@@QAEXED_J@Z ENDP			; CMover::UpdateItemEx
_TEXT	ENDS
PUBLIC	?GetItemDropRateFactor@CMover@@QAEMPAV1@@Z	; CMover::GetItemDropRateFactor
EXTRN	?GetItemDropRateFactor@CEventGeneric@@QAEMXZ:NEAR ; CEventGeneric::GetItemDropRateFactor
EXTRN	?GetInstance@CEventGeneric@@SAPAV1@XZ:NEAR	; CEventGeneric::GetInstance
EXTRN	?m_fItemDropRate@CProject@@2MA:DWORD		; CProject::m_fItemDropRate
EXTRN	?GetItemDropRate@CEventLua@@QAEMH@Z:NEAR	; CEventLua::GetItemDropRate
; Function compile flags: /Ogty
;	COMDAT ?GetItemDropRateFactor@CMover@@QAEMPAV1@@Z
_TEXT	SEGMENT
_fFactor$ = -4						; size = 4
_pAttacker$ = 8						; size = 4
?GetItemDropRateFactor@CMover@@QAEMPAV1@@Z PROC NEAR	; CMover::GetItemDropRateFactor, COMDAT
; _this$ = ecx

; 4234 : {

  00000	51		 push	 ecx

; 4235 : 	float fFactor	= 1.0F;
; 4236 : #ifdef __WORLDSERVER
; 4237 : 	fFactor		*= prj.m_fItemDropRate;

  00001	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_fItemDropRate@CProject@@2MA
  00006	89 04 24	 mov	 DWORD PTR _fFactor$[esp+4], eax

; 4238 : #ifdef __S1108_BACK_END_SYSTEM
; 4239 : 	fFactor		*= GetProp()->m_fItemDrop_Rate;

  00009	8b 81 74 01 00
	00		 mov	 eax, DWORD PTR [ecx+372]
  0000f	85 c0		 test	 eax, eax
  00011	8b 0d d0 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+464
  00017	7c 14		 jl	 SHORT $L284222
  00019	3b c1		 cmp	 eax, ecx
  0001b	7d 10		 jge	 SHORT $L284222
  0001d	8b 0d d4 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+468
  00023	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  00029	03 c1		 add	 eax, ecx
  0002b	eb 18		 jmp	 SHORT $L284217
$L284222:
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	6a 00		 push	 0
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  00036	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0003b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00040	83 c4 14	 add	 esp, 20			; 00000014H
  00043	33 c0		 xor	 eax, eax
$L284217:
  00045	d9 04 24	 fld	 DWORD PTR _fFactor$[esp+4]
  00048	d8 88 60 02 00
	00		 fmul	 DWORD PTR [eax+608]
  0004e	d9 1c 24	 fstp	 DWORD PTR _fFactor$[esp+4]

; 4240 : #endif // __S1108_BACK_END_SYSTEM
; 4241 : #ifdef __ITEMDROPRATE
; 4242 : 	fFactor		*= CEventGeneric::GetInstance()->GetItemDropRateFactor();

  00051	e8 00 00 00 00	 call	 ?GetInstance@CEventGeneric@@SAPAV1@XZ ; CEventGeneric::GetInstance
  00056	8b c8		 mov	 ecx, eax
  00058	e8 00 00 00 00	 call	 ?GetItemDropRateFactor@CEventGeneric@@QAEMXZ ; CEventGeneric::GetItemDropRateFactor
  0005d	d8 0c 24	 fmul	 DWORD PTR _fFactor$[esp+4]

; 4243 : #endif // __ITEMDROPRATE
; 4244 : #if __VER >= 9 // __EVENTLUA
; 4245 : 	fFactor		*= prj.m_EventLua.GetItemDropRate();

  00060	6a 01		 push	 1
  00062	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00067	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+8]
  0006b	e8 00 00 00 00	 call	 ?GetItemDropRate@CEventLua@@QAEMH@Z ; CEventLua::GetItemDropRate
  00070	d8 0c 24	 fmul	 DWORD PTR _fFactor$[esp+4]

; 4246 : #endif // __EVENTLUA
; 4247 : #endif	// __WORLDSERVER
; 4248 : 	return fFactor;


; 4249 : }

  00073	59		 pop	 ecx
  00074	c2 04 00	 ret	 4
?GetItemDropRateFactor@CMover@@QAEMPAV1@@Z ENDP		; CMover::GetItemDropRateFactor
_TEXT	ENDS
PUBLIC	?GetPieceItemDropRateFactor@CMover@@QAEMPAV1@@Z	; CMover::GetPieceItemDropRateFactor
PUBLIC	__real@3f8ccccd
PUBLIC	__real@3f866666
EXTRN	?GetIFactor@ILordEvent@@QAEMXZ:NEAR		; ILordEvent::GetIFactor
EXTRN	?HasBuff@CMover@@QAEHGG@Z:NEAR			; CMover::HasBuff
EXTRN	?GetInstance@CPCBang@@SAPAV1@XZ:NEAR		; CPCBang::GetInstance
EXTRN	?GetPieceItemDropFactor@CPCBang@@QAEMPAVCUser@@@Z:NEAR ; CPCBang::GetPieceItemDropFactor
EXTRN	?Instance@CSLord@@SAPAV1@XZ:NEAR		; CSLord::Instance
EXTRN	?GetPieceItemDropRate@CEventLua@@QAEMH@Z:NEAR	; CEventLua::GetPieceItemDropRate
;	COMDAT __real@3f8ccccd
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
CONST	ENDS
;	COMDAT __real@3f866666
CONST	SEGMENT
__real@3f866666 DD 03f866666r			; 1.05
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	ENDS
;	COMDAT ?GetPieceItemDropRateFactor@CMover@@QAEMPAV1@@Z
_TEXT	SEGMENT
_fFactor$ = -4						; size = 4
_pAttacker$ = 8						; size = 4
?GetPieceItemDropRateFactor@CMover@@QAEMPAV1@@Z PROC NEAR ; CMover::GetPieceItemDropRateFactor, COMDAT
; _this$ = ecx

; 4252 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 4253 : 	float fFactor	= 1.0F;
; 4254 : #ifdef __WORLDSERVER
; 4255 : #if __VER >= 9 // __EVENTLUA
; 4256 : 	fFactor		*= prj.m_EventLua.GetPieceItemDropRate();

  00002	6a 01		 push	 1
  00004	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00009	e8 00 00 00 00	 call	 ?GetPieceItemDropRate@CEventLua@@QAEMH@Z ; CEventLua::GetPieceItemDropRate
  0000e	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+8]

; 4257 : #endif // __EVENTLUA
; 4258 : #if __VER >= 12 // __LORD
; 4259 : 	ILordEvent* pEvent		= CSLord::Instance()->GetEvent();

  00012	e8 00 00 00 00	 call	 ?Instance@CSLord@@SAPAV1@XZ ; CSLord::Instance

; 4260 : 	fFactor		*= pEvent->GetIFactor();

  00017	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001a	e8 00 00 00 00	 call	 ?GetIFactor@ILordEvent@@QAEMXZ ; ILordEvent::GetIFactor
  0001f	d8 4c 24 04	 fmul	 DWORD PTR _fFactor$[esp+8]

; 4261 : 	if( pAttacker->HasBuff( BUFF_ITEM, II_SYS_SYS_LS_CHEERING ) )

  00023	8b 74 24 0c	 mov	 esi, DWORD PTR _pAttacker$[esp+4]
  00027	68 33 4e 00 00	 push	 20019			; 00004e33H
  0002c	6a 00		 push	 0
  0002e	d9 5c 24 0c	 fstp	 DWORD PTR _fFactor$[esp+16]
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00039	85 c0		 test	 eax, eax
  0003b	74 0e		 je	 SHORT $L276682

; 4262 : 		fFactor		*=	1.1F;

  0003d	d9 44 24 04	 fld	 DWORD PTR _fFactor$[esp+8]
  00041	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f8ccccd
  00047	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+8]
$L276682:

; 4263 : 	if( pAttacker->HasBuff( BUFF_ITEM, II_SYS_SYS_VOTE_THANKS ) )

  0004b	68 44 4e 00 00	 push	 20036			; 00004e44H
  00050	6a 00		 push	 0
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00059	85 c0		 test	 eax, eax
  0005b	74 0e		 je	 SHORT $L276683

; 4264 : 		fFactor		*= 1.05F;

  0005d	d9 44 24 04	 fld	 DWORD PTR _fFactor$[esp+8]
  00061	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f866666
  00067	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+8]
$L276683:

; 4265 : #endif	// __LORD
; 4266 : #if __VER >= 13 // __COUPLE_1202
; 4267 : 	if( pAttacker->HasBuff( BUFF_ITEM, II_COUPLE_BUFF_MIRACLE_01 ) )

  0006b	68 74 68 00 00	 push	 26740			; 00006874H
  00070	6a 00		 push	 0
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  00079	85 c0		 test	 eax, eax
  0007b	74 0e		 je	 SHORT $L284243

; 4268 : 		fFactor	*= 1.05F;

  0007d	d9 44 24 04	 fld	 DWORD PTR _fFactor$[esp+8]
  00081	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f866666
  00087	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+8]
$L284243:

; 4269 : #endif	// __COUPLE_1202
; 4270 : #if __VER >= 14 // __PCBANG
; 4271 : 	if( pAttacker->IsPlayer() )

  0008b	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00091	85 c0		 test	 eax, eax
  00093	74 16		 je	 SHORT $L284242

; 4272 : 		fFactor *= CPCBang::GetInstance()->GetPieceItemDropFactor( static_cast<CUser*>( pAttacker ) );

  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 ?GetInstance@CPCBang@@SAPAV1@XZ ; CPCBang::GetInstance
  0009b	8b c8		 mov	 ecx, eax
  0009d	e8 00 00 00 00	 call	 ?GetPieceItemDropFactor@CPCBang@@QAEMPAVCUser@@@Z ; CPCBang::GetPieceItemDropFactor
  000a2	d8 4c 24 04	 fmul	 DWORD PTR _fFactor$[esp+8]
  000a6	5e		 pop	 esi

; 4276 : }

  000a7	59		 pop	 ecx
  000a8	c2 04 00	 ret	 4
$L284242:

; 4273 : #endif // __PCBANG
; 4274 : #endif // __WORLDSERVER
; 4275 : 	return fFactor;

  000ab	d9 44 24 04	 fld	 DWORD PTR _fFactor$[esp+8]
  000af	5e		 pop	 esi

; 4276 : }

  000b0	59		 pop	 ecx
  000b1	c2 04 00	 ret	 4
?GetPieceItemDropRateFactor@CMover@@QAEMPAV1@@Z ENDP	; CMover::GetPieceItemDropRateFactor
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 205  : 			return (_Myval(_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBKPAVIBuff@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Min
; Function compile flags: /Ogty
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Min, COMDAT

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 0e		 jne	 SHORT $L278938
  0000d	8d 49 00	 npad	 3
$L278937:

; 1043 : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00017	84 d2		 test	 dl, dl
  00019	74 f5		 je	 SHORT $L278937
$L278938:

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0001b	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z ; std::_Uninitialized_copy<long *,long *,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z PROC NEAR ; std::_Uninitialized_copy<long *,long *,std::allocator<long> >, COMDAT

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Dest$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 129  : 	}

  00027	c3		 ret	 0
??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z ENDP ; std::_Uninitialized_copy<long *,long *,std::allocator<long> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<long,unsigned int,long>
; Function compile flags: /Ogty
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<long,unsigned int,long>, COMDAT

; 237  : 	fill_n(_First, _Count, _Val);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L284290
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L284288:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L284288
  0001b	5e		 pop	 esi
$L284290:

; 238  : 	}

  0001c	c3		 ret	 0
??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<long,unsigned int,long>
_TEXT	ENDS
PUBLIC	??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ ; `string'
PUBLIC	?GetItemProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetItemProp
;	COMDAT ??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@ DB 'GetItemProp range_er'
	DB	'ror', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetItemProp, COMDAT
; _this$ = ecx

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 1a		 jl	 SHORT $L197914
  00008	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 10		 jge	 SHORT $L197914

; 1365 : 	return m_aPropItem.GetAt( nIndex ); 

  00012	3b c2		 cmp	 eax, edx
  00014	73 28		 jae	 SHORT $L284320
  00016	8b 89 4c 02 00
	00		 mov	 ecx, DWORD PTR [ecx+588]
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1366 : }

  0001f	c2 04 00	 ret	 4
$L197914:

; 1364 : 	VERIFY_RANGE_ASSERT( nIndex, 0, m_aPropItem.GetSize(), "GetItemProp range_error", NULL );

  00022	8b 91 5c 02 00
	00		 mov	 edx, DWORD PTR [ecx+604]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00036	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$L284320:
  0003e	33 c0		 xor	 eax, eax

; 1366 : }

  00040	c2 04 00	 ret	 4
?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ENDP		; CProject::GetItemProp
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@ ; `string'
PUBLIC	?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z	; CProject::GetSkillProp
;	COMDAT ??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\data.h
CONST	SEGMENT
??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@ DB 'GetSkillProp range_'
	DB	'error', 00H					; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
CONST	ENDS
;	COMDAT ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z PROC NEAR	; CProject::GetSkillProp, COMDAT
; _this$ = ecx

; 1370 : 	VERIFY_RANGE( nIndex, 0, m_aPropSkill.GetSize(), "GetSkillProp range_error", NULL );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nIndex$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 1a		 jl	 SHORT $L197924
  00008	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  0000e	3b c2		 cmp	 eax, edx
  00010	7d 10		 jge	 SHORT $L197924

; 1371 : 	return m_aPropSkill.GetAt( nIndex ); 

  00012	3b c2		 cmp	 eax, edx
  00014	73 28		 jae	 SHORT $L284342
  00016	8b 89 70 02 00
	00		 mov	 ecx, DWORD PTR [ecx+624]
  0001c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1372 : }

  0001f	c2 04 00	 ret	 4
$L197924:

; 1370 : 	VERIFY_RANGE( nIndex, 0, m_aPropSkill.GetSize(), "GetSkillProp range_error", NULL );

  00022	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00036	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$L284342:
  0003e	33 c0		 xor	 eax, eax

; 1372 : }

  00040	c2 04 00	 ret	 4
?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z ENDP	; CProject::GetSkillProp
_TEXT	ENDS
PUBLIC	?GetPropA@CItemElem@@QAEPAUItemProp@@XZ		; CItemElem::GetPropA
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?GetPropA@CItemElem@@QAEPAUItemProp@@XZ
_TEXT	SEGMENT
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ PROC NEAR	; CItemElem::GetPropA, COMDAT
; _this$ = ecx

; 229  : 	ItemProp*	GetProp()	{	return prj.GetItemProp( m_dwItemId );	}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000b	7c 10		 jl	 SHORT $L284373
  0000d	3b c1		 cmp	 eax, ecx
  0000f	7d 0c		 jge	 SHORT $L284373
  00011	73 20		 jae	 SHORT $L284389
  00013	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00019	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0001c	c3		 ret	 0
$L284373:
  0001d	50		 push	 eax
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0002b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$L284389:
  00033	33 c0		 xor	 eax, eax
  00035	c3		 ret	 0
?GetPropA@CItemElem@@QAEPAUItemProp@@XZ ENDP		; CItemElem::GetPropA
_TEXT	ENDS
PUBLIC	?GetFlightLv@CMover@@QAEJXZ			; CMover::GetFlightLv
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
;	COMDAT ?GetFlightLv@CMover@@QAEJXZ
_TEXT	SEGMENT
?GetFlightLv@CMover@@QAEJXZ PROC NEAR			; CMover::GetFlightLv, COMDAT
; _this$ = ecx

; 557  : 	LONG	GetFlightLv( void )	{	return ( GetLevel() >= 20? 1: 0 );		}

  00000	8b 91 e0 05 00
	00		 mov	 edx, DWORD PTR [ecx+1504]
  00006	33 c0		 xor	 eax, eax
  00008	83 fa 14	 cmp	 edx, 20			; 00000014H
  0000b	0f 9d c0	 setge	 al
  0000e	c3		 ret	 0
?GetFlightLv@CMover@@QAEJXZ ENDP			; CMover::GetFlightLv
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 246  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 247  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 35   : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Key
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Key, COMDAT

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Pnode$[esp-4]
  00004	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00007	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHK@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHK@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHK@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHK@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pnode$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z ; std::vector<long,std::allocator<long> >::iterator::operator+
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<long,std::allocator<long> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@JV?$allocator@J@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<long,std::allocator<long> >::iterator::operator+
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
  00008	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0000b	72 0a		 jb	 SHORT $L284456
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1476 : 		}

  00014	c2 04 00	 ret	 4

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$L284456:
  00017	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 1476 : 		}

  0001c	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Lbound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	8a 51 15	 mov	 dl, BYTE PTR [ecx+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L222368
  0000d	8b 54 24 04	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L222367:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	7d 05		 jge	 SHORT $L222369

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  0001c	eb 04		 jmp	 SHORT $L222370
$L222369:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L222370:
  00022	8a 59 15	 mov	 bl, BYTE PTR [ecx+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L222367
  00029	5b		 pop	 ebx
$L222368:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ; std::vector<long,std::allocator<long> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ PROC NEAR ; std::vector<long,std::allocator<long> >::max_size, COMDAT
; _this$ = ecx

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@JV?$allocator@J@std@@@std@@QBEIXZ ENDP ; std::vector<long,std::allocator<long> >::max_size
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z ; std::vector<long,std::allocator<long> >::_Destroy
; Function compile flags: /Ogty
;	COMDAT ?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Destroy, COMDAT
; _this$ = ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@JV?$allocator@J@std@@@std@@IAEXPAJ0@Z ENDP ; std::vector<long,std::allocator<long> >::_Destroy
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@J@std@@QAEPAJI@Z		; std::allocator<long>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@J@std@@QAEPAJI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@J@std@@QAEPAJI@Z PROC NEAR	; std::allocator<long>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 138  : 		}

  00014	c2 04 00	 ret	 4
?allocate@?$allocator@J@std@@QAEPAJI@Z ENDP		; std::allocator<long>::allocate
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ; std::vector<long,std::allocator<long> >::iterator::iterator
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@JV?$allocator@J@std@@@std@@QAE@PAJ@Z ENDP ; std::vector<long,std::allocator<long> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ; std::vector<long,std::allocator<long> >::const_iterator::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<long,std::allocator<long> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 160  : 			return (!(*this == _Right));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Right$[esp-4]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b c6		 cmp	 eax, esi
  0000d	0f 95 c1	 setne	 cl
  00010	8a c1		 mov	 al, cl
  00012	5e		 pop	 esi

; 161  : 			}

  00013	c2 04 00	 ret	 4
??9const_iterator@?$vector@JV?$allocator@J@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<long,std::allocator<long> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1116 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	50		 push	 eax
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 138  : 		}

  0000d	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ; std::vector<long,std::allocator<long> >::_Ucopy<long *>
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Ucopy<long *>, COMDAT
; _this$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx
  0000a	56		 push	 esi
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Ptr$[esp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 805  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ENDP ; std::vector<long,std::allocator<long> >::_Ucopy<long *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z ; std::_Uninitialized_fill_n<long *,unsigned int,long,std::allocator<long> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<long *,unsigned int,long,std::allocator<long> >, COMDAT

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Count$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  0000a	76 10		 jbe	 SHORT $L284594
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR __Val$[esp-4]
  00010	56		 push	 esi
$L284592:
  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f6		 jne	 SHORT $L284592
  0001b	5e		 pop	 esi
$L284594:

; 258  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_fill_n@PAJIJV?$allocator@J@std@@@std@@YAXPAJIABJAAV?$allocator@J@0@@Z ENDP ; std::_Uninitialized_fill_n<long *,unsigned int,long,std::allocator<long> >
_TEXT	ENDS
PUBLIC	?CheckSkill@CMover@@QAEHK@Z			; CMover::CheckSkill
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
;	COMDAT ?CheckSkill@CMover@@QAEHK@Z
_TEXT	SEGMENT
_dwSkill$ = 8						; size = 4
?CheckSkill@CMover@@QAEHK@Z PROC NEAR			; CMover::CheckSkill, COMDAT
; _this$ = ecx

; 119  : 	ItemProp* pSkillProp = prj.GetSkillProp( dwSkill );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwSkill$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	8b 15 80 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+640
  0000c	56		 push	 esi
  0000d	0f 8c a2 00 00
	00		 jl	 $L284625
  00013	3b c2		 cmp	 eax, edx
  00015	0f 8d 9a 00 00
	00		 jge	 $L284625
  0001b	0f 83 aa 00 00
	00		 jae	 $L275146
  00021	8b 15 70 02 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+624
  00027	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]

; 120  : 	
; 121  : 	if( pSkillProp == NULL || pSkillProp->nLog == 1 )

  0002a	85 f6		 test	 esi, esi
  0002c	0f 84 99 00 00
	00		 je	 $L275146
  00032	83 be 94 00 00
	00 01		 cmp	 DWORD PTR [esi+148], 1
  00039	0f 84 8c 00 00
	00		 je	 $L275146

; 123  : #if __VER >= 10 // __LEGEND	//	9 	Neuz, World, Trans
; 124  : #ifdef __3RD_LEGEND16
; 125  : 	if( !IsMaster() && !IsHero() && !IsLegendHero() && GetLevel() < (int)( pSkillProp->dwReqDisLV ) )

  0003f	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  00045	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00048	8b 04 c5 e0 27
	00 00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  0004f	83 f8 05	 cmp	 eax, 5
  00052	74 18		 je	 SHORT $L275148
  00054	83 f8 06	 cmp	 eax, 6
  00057	74 13		 je	 SHORT $L275148
  00059	83 f8 07	 cmp	 eax, 7
  0005c	74 0e		 je	 SHORT $L275148
  0005e	8b 91 e0 05 00
	00		 mov	 edx, DWORD PTR [ecx+1504]
  00064	3b 96 b0 01 00
	00		 cmp	 edx, DWORD PTR [esi+432]

; 126  : #else // __3RD_LEGEND16
; 127  : 	if( !IsMaster() && !IsHero() && GetLevel() < (int)( pSkillProp->dwReqDisLV ) )
; 128  : #endif // __3RD_LEGEND16
; 129  : 		return FALSE;

  0006a	7c 5f		 jl	 SHORT $L275146
$L275148:

; 130  : #else //__LEGEND	//	9 	Neuz, World, Trans
; 131  : 	if( GetLevel() < pSkillProp->dwReqDisLV )
; 132  : 		return FALSE;
; 133  : #endif	//__LEGEND	//	9 	Neuz, World, Trans
; 134  : 				
; 135  : 	if( pSkillProp->dwReSkill1 != 0xffffffff )

  0006c	8b 86 b4 01 00
	00		 mov	 eax, DWORD PTR [esi+436]
  00072	83 f8 ff	 cmp	 eax, -1
  00075	74 15		 je	 SHORT $L275152

; 136  : 	{
; 137  : 		LPSKILL pSkillBuf = GetSkill( pSkillProp->dwReSkill1 );

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z ; CMover::GetSkill

; 138  : 		if( pSkillBuf )

  0007d	85 c0		 test	 eax, eax
  0007f	74 0b		 je	 SHORT $L275152

; 139  : 		{
; 140  : 			if( pSkillBuf->dwLevel < pSkillProp->dwReSkillLevel1 )

  00081	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00084	3b 86 b8 01 00
	00		 cmp	 eax, DWORD PTR [esi+440]

; 141  : 			{
; 142  : 				return FALSE;

  0008a	72 3f		 jb	 SHORT $L275146
$L275152:

; 143  : 			}
; 144  : 		}
; 145  : 	}
; 146  : 	
; 147  : 	if( pSkillProp->dwReSkill2 != 0xffffffff )

  0008c	8b 86 bc 01 00
	00		 mov	 eax, DWORD PTR [esi+444]
  00092	83 f8 ff	 cmp	 eax, -1
  00095	74 15		 je	 SHORT $L275156

; 148  : 	{
; 149  : 		LPSKILL pSkillBuf = GetSkill( pSkillProp->dwReSkill2 );

  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z ; CMover::GetSkill

; 150  : 		if( pSkillBuf )

  0009d	85 c0		 test	 eax, eax
  0009f	74 0b		 je	 SHORT $L275156

; 151  : 		{
; 152  : 			if( pSkillBuf->dwLevel < pSkillProp->dwReSkillLevel2 )

  000a1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a4	3b 8e c0 01 00
	00		 cmp	 ecx, DWORD PTR [esi+448]

; 153  : 			{
; 154  : 				return FALSE;

  000aa	72 1f		 jb	 SHORT $L275146
$L275156:

; 155  : 			}				
; 156  : 		}
; 157  : 	}	
; 158  : 	
; 159  : 	return TRUE;

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	5e		 pop	 esi

; 160  : }

  000b2	c2 04 00	 ret	 4

; 119  : 	ItemProp* pSkillProp = prj.GetSkillProp( dwSkill );

$L284625:
  000b5	50		 push	 eax
  000b6	52		 push	 edx
  000b7	6a 00		 push	 0
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000c3	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000c8	83 c4 14	 add	 esp, 20			; 00000014H
$L275146:

; 122  : 		return FALSE;

  000cb	33 c0		 xor	 eax, eax
  000cd	5e		 pop	 esi

; 160  : }

  000ce	c2 04 00	 ret	 4
?CheckSkill@CMover@@QAEHK@Z ENDP			; CMover::CheckSkill
_TEXT	ENDS
PUBLIC	?IsSkillParent@@YAHPAVCMover@@KK@Z		; IsSkillParent
; Function compile flags: /Ogty
;	COMDAT ?IsSkillParent@@YAHPAVCMover@@KK@Z
_TEXT	SEGMENT
_pMover$ = 8						; size = 4
_dwSkill$ = 12						; size = 4
_dwChildSkill$ = 16					; size = 4
?IsSkillParent@@YAHPAVCMover@@KK@Z PROC NEAR		; IsSkillParent, COMDAT

; 201  : 	LPSKILL pSkill = pMover->GetSkill( dwSkill );

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _dwSkill$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _pMover$[esp]
  00009	33 c0		 xor	 eax, eax
  0000b	8d 8e 6c 03 00
	00		 lea	 ecx, DWORD PTR [esi+876]
$L284656:
  00011	39 11		 cmp	 DWORD PTR [ecx], edx
  00013	74 0d		 je	 SHORT $L284698
  00015	40		 inc	 eax
  00016	83 c1 08	 add	 ecx, 8
  00019	83 f8 33	 cmp	 eax, 51			; 00000033H
  0001c	7c f3		 jl	 SHORT $L284656

; 211  : 
; 212  : 	return FALSE;

  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 213  : }

  00021	c3		 ret	 0
$L284698:

; 201  : 	LPSKILL pSkill = pMover->GetSkill( dwSkill );

  00022	8d 84 c6 6c 03
	00 00		 lea	 eax, DWORD PTR [esi+eax*8+876]

; 202  : 	if( pSkill == NULL )

  00029	85 c0		 test	 eax, eax

; 203  : 		return FALSE;

  0002b	74 2f		 je	 SHORT $L284701

; 204  : 
; 205  : 	ItemProp* pSkillProp = prj.GetSkillProp( dwSkill );

  0002d	85 d2		 test	 edx, edx
  0002f	a1 80 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+640
  00034	7c 2a		 jl	 SHORT $L284690
  00036	3b d0		 cmp	 edx, eax
  00038	7d 26		 jge	 SHORT $L284690
  0003a	73 20		 jae	 SHORT $L284701
  0003c	a1 70 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+624
  00041	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]

; 206  : 	if( pSkillProp == NULL )

  00044	85 d2		 test	 edx, edx

; 207  : 		return FALSE;

  00046	74 14		 je	 SHORT $L284701

; 208  : 
; 209  : 	if( pSkillProp->dwReSkill1 == dwChildSkill || pSkillProp->dwReSkill2 == dwChildSkill )

  00048	8b 44 24 10	 mov	 eax, DWORD PTR _dwChildSkill$[esp]
  0004c	39 82 b4 01 00
	00		 cmp	 DWORD PTR [edx+436], eax
  00052	74 26		 je	 SHORT $L275171
  00054	39 82 bc 01 00
	00		 cmp	 DWORD PTR [edx+444], eax
  0005a	74 1e		 je	 SHORT $L275171
$L284701:

; 211  : 
; 212  : 	return FALSE;

  0005c	33 c0		 xor	 eax, eax
  0005e	5e		 pop	 esi

; 213  : }

  0005f	c3		 ret	 0

; 204  : 
; 205  : 	ItemProp* pSkillProp = prj.GetSkillProp( dwSkill );

$L284690:
  00060	52		 push	 edx
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  00069	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0006e	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00073	83 c4 14	 add	 esp, 20			; 00000014H

; 211  : 
; 212  : 	return FALSE;

  00076	33 c0		 xor	 eax, eax
  00078	5e		 pop	 esi

; 213  : }

  00079	c3		 ret	 0
$L275171:

; 210  : 		return TRUE;

  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	5e		 pop	 esi

; 213  : }

  00080	c3		 ret	 0
?IsSkillParent@@YAHPAVCMover@@KK@Z ENDP			; IsSkillParent
_TEXT	ENDS
PUBLIC	?IsActive@@YAHPAVCMover@@K@Z			; IsActive
; Function compile flags: /Ogty
;	COMDAT ?IsActive@@YAHPAVCMover@@K@Z
_TEXT	SEGMENT
_pMover$ = 8						; size = 4
_dwSkill$ = 12						; size = 4
?IsActive@@YAHPAVCMover@@K@Z PROC NEAR			; IsActive, COMDAT

; 217  : 	LPSKILL pSkill = pMover->GetSkill( dwSkill );

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _dwSkill$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 7c 24 0c	 mov	 edi, DWORD PTR _pMover$[esp+4]
  0000a	33 c0		 xor	 eax, eax
  0000c	8d 8f 6c 03 00
	00		 lea	 ecx, DWORD PTR [edi+876]
$L284709:
  00012	39 11		 cmp	 DWORD PTR [ecx], edx
  00014	74 0e		 je	 SHORT $L284765
  00016	40		 inc	 eax
  00017	83 c1 08	 add	 ecx, 8
  0001a	83 f8 33	 cmp	 eax, 51			; 00000033H
  0001d	7c f3		 jl	 SHORT $L284709
  0001f	5f		 pop	 edi

; 219  : 		return FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 294  : }

  00023	c3		 ret	 0
$L284765:

; 217  : 	LPSKILL pSkill = pMover->GetSkill( dwSkill );

  00024	8d 84 c7 6c 03
	00 00		 lea	 eax, DWORD PTR [edi+eax*8+876]

; 218  : 	if( pSkill == NULL )

  0002b	85 c0		 test	 eax, eax
  0002d	75 03		 jne	 SHORT $L284744
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 294  : }

  00031	c3		 ret	 0

; 220  : 
; 221  : 	ItemProp* pSkillProp = prj.GetSkillProp( dwSkill );

$L284744:
  00032	85 d2		 test	 edx, edx
  00034	a1 80 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+640
  00039	53		 push	 ebx
  0003a	7c 18		 jl	 SHORT $L284748
  0003c	3b d0		 cmp	 edx, eax
  0003e	7d 14		 jge	 SHORT $L284748
  00040	73 0c		 jae	 SHORT $L284768
  00042	a1 70 02 00 00	 mov	 eax, DWORD PTR ?prj@@3VCProject@@A+624
  00047	8b 1c 90	 mov	 ebx, DWORD PTR [eax+edx*4]

; 222  : 	if( pSkillProp == NULL )

  0004a	85 db		 test	 ebx, ebx
  0004c	75 22		 jne	 SHORT $L275179
$L284768:
  0004e	5b		 pop	 ebx
  0004f	5f		 pop	 edi

; 223  : 		return FALSE;

  00050	33 c0		 xor	 eax, eax
  00052	5e		 pop	 esi

; 294  : }

  00053	c3		 ret	 0

; 220  : 
; 221  : 	ItemProp* pSkillProp = prj.GetSkillProp( dwSkill );

$L284748:
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	6a 00		 push	 0
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GPNGCFMK@GetSkillProp?5range_error?$AA@
  0005d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00062	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00067	83 c4 14	 add	 esp, 20			; 00000014H
  0006a	5b		 pop	 ebx
  0006b	5f		 pop	 edi

; 223  : 		return FALSE;

  0006c	33 c0		 xor	 eax, eax
  0006e	5e		 pop	 esi

; 294  : }

  0006f	c3		 ret	 0
$L275179:

; 224  : 
; 225  : 	if( pSkillProp->dwReSkill1 != NULL_ID )

  00070	8b 83 b4 01 00
	00		 mov	 eax, DWORD PTR [ebx+436]
  00076	83 f8 ff	 cmp	 eax, -1
  00079	74 5d		 je	 SHORT $L275187

; 226  : 	{
; 227  : 		LPSKILL pSkill1;
; 228  : 		ItemProp* pSkillProp1;
; 229  : 
; 230  : 		pSkill1		= pMover->GetSkill( pSkillProp->dwReSkill1 );

  0007b	50		 push	 eax
  0007c	8b cf		 mov	 ecx, edi
  0007e	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z ; CMover::GetSkill
  00083	8b f0		 mov	 esi, eax

; 231  : 		if( pSkill1 == NULL )

  00085	85 f6		 test	 esi, esi

; 232  : 			return FALSE;

  00087	74 c5		 je	 SHORT $L284768

; 233  : 
; 234  : 		pSkillProp1 = prj.GetSkillProp( pSkill1->dwSkill );

  00089	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008b	51		 push	 ecx
  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00091	e8 00 00 00 00	 call	 ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetSkillProp

; 235  : 		if( pSkillProp1 == NULL )

  00096	85 c0		 test	 eax, eax

; 236  : 			return FALSE;

  00098	74 b4		 je	 SHORT $L284768

; 237  : 
; 238  : #if __VER >= 10 // __LEGEND	//	9 	Neuz, World, Trans
; 239  : #ifdef __3RD_LEGEND16
; 240  : 		if( (int)( pSkillProp1->dwReqDisLV ) > pMover->GetLevel() && !pMover->IsMaster() && !pMover->IsHero() && !pMover->IsLegendHero() )

  0009a	8b 90 b0 01 00
	00		 mov	 edx, DWORD PTR [eax+432]
  000a0	3b 97 e0 05 00
	00		 cmp	 edx, DWORD PTR [edi+1504]
  000a6	7e 21		 jle	 SHORT $L275186
  000a8	8b cf		 mov	 ecx, edi
  000aa	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  000af	85 c0		 test	 eax, eax
  000b1	75 16		 jne	 SHORT $L275186
  000b3	8b cf		 mov	 ecx, edi
  000b5	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  000ba	85 c0		 test	 eax, eax
  000bc	75 0b		 jne	 SHORT $L275186
  000be	8b cf		 mov	 ecx, edi
  000c0	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  000c5	85 c0		 test	 eax, eax

; 241  : #else // __3RD_LEGEND16
; 242  : 		if( (int)( pSkillProp1->dwReqDisLV ) > pMover->GetLevel() && !pMover->IsMaster() && !pMover->IsHero() )
; 243  : #endif // __3RD_LEGEND16
; 244  : 			return FALSE;

  000c7	74 85		 je	 SHORT $L284768
$L275186:

; 245  : #else //__LEGEND	//	9 	Neuz, World, Trans
; 246  : 		if( pSkillProp1->dwReqDisLV > pMover->GetLevel() )
; 247  : 			return FALSE;
; 248  : #endif	//__LEGEND	//	9 	Neuz, World, Trans
; 249  : 		
; 250  : 		if( pSkillProp->dwReSkillLevel1 != pSkill1->dwLevel )

  000c9	8b 83 b8 01 00
	00		 mov	 eax, DWORD PTR [ebx+440]
  000cf	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]

; 251  : 			return FALSE;

  000d2	0f 85 76 ff ff
	ff		 jne	 $L284768
$L275187:

; 252  : 	}
; 253  : 
; 254  : 	if( pSkillProp->dwReSkill2 != NULL_ID )

  000d8	8b 83 bc 01 00
	00		 mov	 eax, DWORD PTR [ebx+444]
  000de	83 f8 ff	 cmp	 eax, -1
  000e1	74 69		 je	 SHORT $L275195

; 255  : 	{
; 256  : 		LPSKILL pSkill1;
; 257  : 		ItemProp* pSkillProp1;
; 258  : 		
; 259  : 		pSkill1		= pMover->GetSkill( pSkillProp->dwReSkill2 );

  000e3	50		 push	 eax
  000e4	8b cf		 mov	 ecx, edi
  000e6	e8 00 00 00 00	 call	 ?GetSkill@CMover@@QAEPAUtagSkill@@K@Z ; CMover::GetSkill
  000eb	8b f0		 mov	 esi, eax

; 260  : 		if( pSkill1 == NULL )

  000ed	85 f6		 test	 esi, esi

; 261  : 			return FALSE;

  000ef	0f 84 59 ff ff
	ff		 je	 $L284768

; 262  : 	
; 263  : 		pSkillProp1 = prj.GetSkillProp( pSkill1->dwSkill );

  000f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f7	51		 push	 ecx
  000f8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  000fd	e8 00 00 00 00	 call	 ?GetSkillProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetSkillProp

; 264  : 		if( pSkillProp1 == NULL )

  00102	85 c0		 test	 eax, eax

; 265  : 			return FALSE;

  00104	0f 84 44 ff ff
	ff		 je	 $L284768

; 266  : #if __VER >= 10 // __LEGEND	//	9 	Neuz, World, Trans
; 267  : #ifdef __3RD_LEGEND16
; 268  : 		if( (int)( pSkillProp1->dwReqDisLV ) > pMover->GetLevel() && !pMover->IsMaster() && !pMover->IsHero() && !pMover->IsLegendHero() )

  0010a	8b 90 b0 01 00
	00		 mov	 edx, DWORD PTR [eax+432]
  00110	3b 97 e0 05 00
	00		 cmp	 edx, DWORD PTR [edi+1504]
  00116	7e 25		 jle	 SHORT $L275194
  00118	8b cf		 mov	 ecx, edi
  0011a	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  0011f	85 c0		 test	 eax, eax
  00121	75 1a		 jne	 SHORT $L275194
  00123	8b cf		 mov	 ecx, edi
  00125	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  0012a	85 c0		 test	 eax, eax
  0012c	75 0f		 jne	 SHORT $L275194
  0012e	8b cf		 mov	 ecx, edi
  00130	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  00135	85 c0		 test	 eax, eax

; 269  : #else // __3RD_LEGEND16
; 270  : 		if( (int)( pSkillProp1->dwReqDisLV ) > pMover->GetLevel() && !pMover->IsMaster() && !pMover->IsHero() )
; 271  : #endif // __3RD_LEGEND16
; 272  : 			return FALSE;

  00137	0f 84 11 ff ff
	ff		 je	 $L284768
$L275194:

; 273  : #else //__LEGEND	//	9 	Neuz, World, Trans
; 274  : 		if( pSkillProp1->dwReqDisLV > pMover->GetLevel() )
; 275  : 			return FALSE;
; 276  : #endif	//__LEGEND	//	9 	Neuz, World, Trans
; 277  : 		
; 278  : 		if( pSkillProp->dwReSkillLevel2 != pSkill1->dwLevel )

  0013d	8b 83 c0 01 00
	00		 mov	 eax, DWORD PTR [ebx+448]
  00143	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]

; 279  : 			return FALSE;		

  00146	0f 85 02 ff ff
	ff		 jne	 $L284768
$L275195:

; 280  : 	}
; 281  : #if __VER >= 10 // __LEGEND	//	9 	Neuz, World, Trans
; 282  : #ifdef __3RD_LEGEND16
; 283  : 		if( (int)( pSkillProp->dwReqDisLV ) > pMover->GetLevel() && !pMover->IsMaster() && !pMover->IsHero() && !pMover->IsLegendHero() )

  0014c	8b 8b b0 01 00
	00		 mov	 ecx, DWORD PTR [ebx+432]
  00152	3b 8f e0 05 00
	00		 cmp	 ecx, DWORD PTR [edi+1504]
  00158	7e 2d		 jle	 SHORT $L275197
  0015a	8b 87 44 06 00
	00		 mov	 eax, DWORD PTR [edi+1604]
  00160	8d 14 c0	 lea	 edx, DWORD PTR [eax+eax*8]
  00163	83 3c d5 e0 27
	00 00 05	 cmp	 DWORD PTR ?prj@@3VCProject@@A[edx*8+10208], 5
  0016b	74 1a		 je	 SHORT $L275197
  0016d	8b cf		 mov	 ecx, edi
  0016f	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  00174	85 c0		 test	 eax, eax
  00176	75 0f		 jne	 SHORT $L275197
  00178	8b cf		 mov	 ecx, edi
  0017a	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  0017f	85 c0		 test	 eax, eax

; 284  : #else // __3RD_LEGEND16
; 285  : 		if( (int)( pSkillProp->dwReqDisLV ) > pMover->GetLevel() && !pMover->IsMaster() && !pMover->IsHero() )
; 286  : #endif // __3RD_LEGEND16
; 287  : 			return FALSE;

  00181	0f 84 c7 fe ff
	ff		 je	 $L284768
$L275197:
  00187	5b		 pop	 ebx
  00188	5f		 pop	 edi

; 288  : #else //__LEGEND	//	9 	Neuz, World, Trans
; 289  : 	if( pSkillProp->dwReqDisLV > pMover->GetLevel() )
; 290  : 		return FALSE;
; 291  : #endif	//__LEGEND	//	9 	Neuz, World, Trans
; 292  : 
; 293  : 	return TRUE;

  00189	b8 01 00 00 00	 mov	 eax, 1
  0018e	5e		 pop	 esi

; 294  : }

  0018f	c3		 ret	 0
?IsActive@@YAHPAVCMover@@K@Z ENDP			; IsActive
_TEXT	ENDS
PUBLIC	?GetItemAbility@CMover@@QAEHH@Z			; CMover::GetItemAbility
; Function compile flags: /Ogty
;	COMDAT ?GetItemAbility@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nItem$ = 8						; size = 4
?GetItemAbility@CMover@@QAEHH@Z PROC NEAR		; CMover::GetItemAbility, COMDAT
; _this$ = ecx

; 581  : 	ItemProp* pItemProp = prj.GetItemProp( nItem );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nItem$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000f	57		 push	 edi
  00010	7c 19		 jl	 SHORT $L284813
  00012	3b c1		 cmp	 eax, ecx
  00014	7d 15		 jge	 SHORT $L284813
  00016	72 06		 jb	 SHORT $L284806
  00018	33 c0		 xor	 eax, eax
  0001a	8b c8		 mov	 ecx, eax
  0001c	eb 25		 jmp	 SHORT $L284808
$L284806:
  0001e	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00024	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00027	8b c8		 mov	 ecx, eax
  00029	eb 18		 jmp	 SHORT $L284808
$L284813:
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00034	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00039	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003e	83 c4 14	 add	 esp, 20			; 00000014H
  00041	33 c9		 xor	 ecx, ecx
$L284808:

; 582  : 	int nAbilityMin = GetParam( DST_ABILITY_MIN, pItemProp->dwAbilityMin );

  00043	8b 86 bc 14 00
	00		 mov	 eax, DWORD PTR [esi+5308]
  00049	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0004e	8b b9 e4 00 00
	00		 mov	 edi, DWORD PTR [ecx+228]
  00054	74 04		 je	 SHORT $L284832
  00056	8b f8		 mov	 edi, eax
  00058	eb 0c		 jmp	 SHORT $L284835
$L284832:
  0005a	8b 86 e8 12 00
	00		 mov	 eax, DWORD PTR [esi+4840]
  00060	85 c0		 test	 eax, eax
  00062	74 02		 je	 SHORT $L284835
  00064	03 f8		 add	 edi, eax
$L284835:

; 583  : 	int nAbilityMax = GetParam( DST_ABILITY_MAX, pItemProp->dwAbilityMax );

  00066	8b 86 c0 14 00
	00		 mov	 eax, DWORD PTR [esi+5312]
  0006c	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00071	8b 89 e8 00 00
	00		 mov	 ecx, DWORD PTR [ecx+232]
  00077	74 04		 je	 SHORT $L284855
  00079	8b c8		 mov	 ecx, eax
  0007b	eb 0c		 jmp	 SHORT $L284858
$L284855:
  0007d	8b b6 ec 12 00
	00		 mov	 esi, DWORD PTR [esi+4844]
  00083	85 f6		 test	 esi, esi
  00085	74 02		 je	 SHORT $L284858
  00087	03 ce		 add	 ecx, esi
$L284858:

; 584  : 	if( nAbilityMax == nAbilityMin )

  00089	3b cf		 cmp	 ecx, edi
  0008b	75 07		 jne	 SHORT $L275333

; 585  : 		return nAbilityMin;

  0008d	8b c7		 mov	 eax, edi
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi

; 587  : }

  00091	c2 04 00	 ret	 4
$L275333:

; 586  : 	return nAbilityMin + ( xRand() % (nAbilityMax - nAbilityMin ) );

  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_next@@3KA ; g_next
  00099	69 c0 6d 4e c6
	41		 imul	 eax, 1103515245		; 41c64e6dH
  0009f	05 39 30 00 00	 add	 eax, 12345		; 00003039H
  000a4	a3 00 00 00 00	 mov	 DWORD PTR ?g_next@@3KA, eax ; g_next
  000a9	2b cf		 sub	 ecx, edi
  000ab	33 d2		 xor	 edx, edx
  000ad	f7 f1		 div	 ecx
  000af	8b c2		 mov	 eax, edx
  000b1	03 c7		 add	 eax, edi
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi

; 587  : }

  000b5	c2 04 00	 ret	 4
?GetItemAbility@CMover@@QAEHH@Z ENDP			; CMover::GetItemAbility
_TEXT	ENDS
PUBLIC	?GetItemAbilityMin@CMover@@QAEHH@Z		; CMover::GetItemAbilityMin
; Function compile flags: /Ogty
;	COMDAT ?GetItemAbilityMin@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nItem$ = 8						; size = 4
?GetItemAbilityMin@CMover@@QAEHH@Z PROC NEAR		; CMover::GetItemAbilityMin, COMDAT
; _this$ = ecx

; 591  : 	ItemProp* pItemProp = prj.GetItemProp( nItem );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nItem$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000f	7c 11		 jl	 SHORT $L284906
  00011	3b c1		 cmp	 eax, ecx
  00013	7d 0d		 jge	 SHORT $L284906
  00015	73 21		 jae	 SHORT $L284930
  00017	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0001d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00020	eb 18		 jmp	 SHORT $L284901
$L284906:
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00030	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00035	83 c4 14	 add	 esp, 20			; 00000014H
$L284930:
  00038	33 c0		 xor	 eax, eax
$L284901:

; 592  : 	int nAbilityMin = GetParam( DST_ABILITY_MIN, pItemProp->dwAbilityMin );

  0003a	8b 8e bc 14 00
	00		 mov	 ecx, DWORD PTR [esi+5308]
  00040	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00046	8b 80 e4 00 00
	00		 mov	 eax, DWORD PTR [eax+228]
  0004c	74 06		 je	 SHORT $L284925

; 593  : 	return nAbilityMin;

  0004e	8b c1		 mov	 eax, ecx
  00050	5e		 pop	 esi

; 594  : }

  00051	c2 04 00	 ret	 4

; 592  : 	int nAbilityMin = GetParam( DST_ABILITY_MIN, pItemProp->dwAbilityMin );

$L284925:
  00054	8b 8e e8 12 00
	00		 mov	 ecx, DWORD PTR [esi+4840]
  0005a	85 c9		 test	 ecx, ecx
  0005c	74 02		 je	 SHORT $L284928
  0005e	03 c1		 add	 eax, ecx
$L284928:
  00060	5e		 pop	 esi

; 594  : }

  00061	c2 04 00	 ret	 4
?GetItemAbilityMin@CMover@@QAEHH@Z ENDP			; CMover::GetItemAbilityMin
_TEXT	ENDS
PUBLIC	?GetItemAbilityMax@CMover@@QAEHH@Z		; CMover::GetItemAbilityMax
; Function compile flags: /Ogty
;	COMDAT ?GetItemAbilityMax@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nItem$ = 8						; size = 4
?GetItemAbilityMax@CMover@@QAEHH@Z PROC NEAR		; CMover::GetItemAbilityMax, COMDAT
; _this$ = ecx

; 598  : 	ItemProp* pItemProp = prj.GetItemProp( nItem );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nItem$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0000f	7c 11		 jl	 SHORT $L284974
  00011	3b c1		 cmp	 eax, ecx
  00013	7d 0d		 jge	 SHORT $L284974
  00015	73 21		 jae	 SHORT $L284998
  00017	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  0001d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00020	eb 18		 jmp	 SHORT $L284966
$L284974:
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	6a 00		 push	 0
  00026	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00030	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00035	83 c4 14	 add	 esp, 20			; 00000014H
$L284998:
  00038	33 c0		 xor	 eax, eax
$L284966:

; 599  : 	int nAbilityMax = GetParam( DST_ABILITY_MAX, pItemProp->dwAbilityMax );

  0003a	8b 8e c0 14 00
	00		 mov	 ecx, DWORD PTR [esi+5312]
  00040	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00046	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [eax+232]
  0004c	74 06		 je	 SHORT $L284993

; 600  : 	return nAbilityMax;

  0004e	8b c1		 mov	 eax, ecx
  00050	5e		 pop	 esi

; 601  : }

  00051	c2 04 00	 ret	 4

; 599  : 	int nAbilityMax = GetParam( DST_ABILITY_MAX, pItemProp->dwAbilityMax );

$L284993:
  00054	8b 8e ec 12 00
	00		 mov	 ecx, DWORD PTR [esi+4844]
  0005a	85 c9		 test	 ecx, ecx
  0005c	74 02		 je	 SHORT $L284996
  0005e	03 c1		 add	 eax, ecx
$L284996:
  00060	5e		 pop	 esi

; 601  : }

  00061	c2 04 00	 ret	 4
?GetItemAbilityMax@CMover@@QAEHH@Z ENDP			; CMover::GetItemAbilityMax
_TEXT	ENDS
PUBLIC	?AddFxp@CMover@@QAEHH@Z				; CMover::AddFxp
; Function compile flags: /Ogty
;	COMDAT ?AddFxp@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nFxp$ = 8						; size = 4
?AddFxp@CMover@@QAEHH@Z PROC NEAR			; CMover::AddFxp, COMDAT
; _this$ = ecx

; 1685 : 	if( nFxp <= 0 )		// nExp  0  .

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nFxp$[esp-4]
  00004	85 c0		 test	 eax, eax

; 1686 : 		return FALSE;

  00006	7e 4b		 jle	 SHORT $L275671

; 1687 : 
; 1688 : 	if( m_nHitPoint <= 0 )		//    .

  00008	8b 91 00 06 00
	00		 mov	 edx, DWORD PTR [ecx+1536]
  0000e	85 d2		 test	 edx, edx

; 1689 : 		return FALSE;

  00010	7e 41		 jle	 SHORT $L275671

; 1690 : 
; 1691 : 	if( GetFlightLv() == 0 )

  00012	83 b9 e0 05 00
	00 14		 cmp	 DWORD PTR [ecx+1504], 20 ; 00000014H

; 1692 : 		return FALSE;

  00019	7c 38		 jl	 SHORT $L275671

; 1693 : 
; 1694 : 	int nNextLevel = GetFlightLv() + 1;
; 1695 : 
; 1696 : 	m_nFxp += nFxp;		//   .

  0001b	8b 91 fc 05 00
	00		 mov	 edx, DWORD PTR [ecx+1532]
  00021	03 d0		 add	 edx, eax
  00023	8b c2		 mov	 eax, edx
  00025	89 91 fc 05 00
	00		 mov	 DWORD PTR [ecx+1532], edx

; 1697 : 	if( (DWORD)( m_nFxp ) >= prj.m_aFxpCharacter[nNextLevel].dwFxp ) //   .

  0002b	8b 15 00 69 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A+26880
  00031	3b c2		 cmp	 eax, edx
  00033	72 1e		 jb	 SHORT $L275671

; 1698 : 	{
; 1699 : 		int		FxpBuf;
; 1700 : 		FxpBuf = m_nFxp - prj.m_aFxpCharacter[ nNextLevel ].dwFxp;		//    ?

  00035	2b c2		 sub	 eax, edx

; 1701 : 		m_nFxp = 0;
; 1702 : 		SetFlightLv( nNextLevel );	//  .
; 1703 : 		
; 1704 : #ifdef __CLIENT
; 1705 : 		//  
; 1706 : 		CreateSfx(g_Neuz.m_pd3dDevice,XI_GEN_LEVEL_UP01,GetPos(),GetId());
; 1707 : 		PlayMusic( BGM_IN_LEVELUP );
; 1708 : #endif	// __CLIENT
; 1709 : 	
; 1710 : 		//     .
; 1711 : 		if( FxpBuf > 0)

  00037	85 c0		 test	 eax, eax
  00039	c7 81 fc 05 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1532], 0
  00043	7e 06		 jle	 SHORT $L275673

; 1712 : 		{
; 1713 : 			AddFxp( FxpBuf );

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?AddFxp@CMover@@QAEHH@Z	; CMover::AddFxp
$L275673:

; 1714 : 		}
; 1715 : 
; 1716 : 		return TRUE;

  0004b	b8 01 00 00 00	 mov	 eax, 1

; 1719 : }

  00050	c2 04 00	 ret	 4
$L275671:

; 1717 : 	}
; 1718 : 	return FALSE;

  00053	33 c0		 xor	 eax, eax

; 1719 : }

  00055	c2 04 00	 ret	 4
?AddFxp@CMover@@QAEHH@Z ENDP				; CMover::AddFxp
_TEXT	ENDS
PUBLIC	?SetFxp@CMover@@QAEHHH@Z			; CMover::SetFxp
; Function compile flags: /Ogty
;	COMDAT ?SetFxp@CMover@@QAEHHH@Z
_TEXT	SEGMENT
_nFxp$ = 8						; size = 4
_nFlightLv$ = 12					; size = 4
?SetFxp@CMover@@QAEHHH@Z PROC NEAR			; CMover::SetFxp, COMDAT
; _this$ = ecx

; 1818 : 	m_nFxp = nFxp;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nFxp$[esp-4]
  00004	89 81 fc 05 00
	00		 mov	 DWORD PTR [ecx+1532], eax

; 1819 : 
; 1820 : 	//  .
; 1821 : 	if( nFlightLv > GetFlightLv() )

  0000a	8b 81 e0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1504]
  00010	8b 4c 24 08	 mov	 ecx, DWORD PTR _nFlightLv$[esp-4]
  00014	33 d2		 xor	 edx, edx
  00016	83 f8 14	 cmp	 eax, 20			; 00000014H
  00019	0f 9d c2	 setge	 dl
  0001c	33 c0		 xor	 eax, eax
  0001e	3b ca		 cmp	 ecx, edx
  00020	0f 9f c0	 setg	 al

; 1822 : 	{
; 1823 : 		SetFlightLv( nFlightLv );
; 1824 : #ifdef __CLIENT
; 1825 : 		CreateSfx(g_Neuz.m_pd3dDevice,XI_GEN_LEVEL_UP01,GetPos(),GetId());
; 1826 : 		PlayMusic( BGM_IN_LEVELUP );
; 1827 : 		g_WndMng.PutString( prj.GetText( TID_GAME_FLYLVLUP ), NULL, prj.GetTextColor( TID_GAME_FLYLVLUP ) );
; 1828 : #endif // CLIENT
; 1829 : 		return TRUE;
; 1830 : 	}
; 1831 : 
; 1832 : 	return FALSE;
; 1833 : }

  00023	c2 08 00	 ret	 8
?SetFxp@CMover@@QAEHHH@Z ENDP				; CMover::SetFxp
_TEXT	ENDS
PUBLIC	?SumEquipDefenseAbility@CMover@@QAEHPAJ0@Z	; CMover::SumEquipDefenseAbility
PUBLIC	??_C@_0BI@JFCDNFPO@Parts?5Not?5Property?5?$DN?5?$CFd?$AA@ ; `string'
PUBLIC	__real@3ff8000000000000
EXTRN	?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z:NEAR	; CMover::GetEquipItem
EXTRN	?GetItemMultiplier@CMover@@QAEMPAVCItemElem@@@Z:NEAR ; CMover::GetItemMultiplier
;	COMDAT ??_C@_0BI@JFCDNFPO@Parts?5Not?5Property?5?$DN?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BI@JFCDNFPO@Parts?5Not?5Property?5?$DN?5?$CFd?$AA@ DB 'Parts Not P'
	DB	'roperty = %d', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SumEquipDefenseAbility@CMover@@QAEHPAJ0@Z
_TEXT	SEGMENT
_nMax$275755 = -16					; size = 4
_nMin$275754 = -12					; size = 4
_i$275758 = -8						; size = 4
tv397 = -4						; size = 4
tv393 = -4						; size = 4
_nOption$275768 = -4					; size = 4
_pnMin$ = 8						; size = 4
_pnMax$ = 12						; size = 4
?SumEquipDefenseAbility@CMover@@QAEHPAJ0@Z PROC NEAR	; CMover::SumEquipDefenseAbility, COMDAT
; _this$ = ecx

; 2067 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	55		 push	 ebp
  00004	8b e9		 mov	 ebp, ecx

; 2068 : 	if( IsPlayer() )

  00006	8b 85 34 02 00
	00		 mov	 eax, DWORD PTR [ebp+564]
  0000c	57		 push	 edi
  0000d	33 ff		 xor	 edi, edi
  0000f	3b c7		 cmp	 eax, edi
  00011	0f 84 99 01 00
	00		 je	 $L275753
  00017	53		 push	 ebx

; 2069 : 	{
; 2070 : 		int	nMin = 0, nMax = 0;

  00018	89 7c 24 10	 mov	 DWORD PTR _nMin$275754[esp+28], edi
  0001c	89 7c 24 0c	 mov	 DWORD PTR _nMax$275755[esp+28], edi

; 2071 : 		CItemElem* pItemElem;
; 2072 : 		ItemProp *pItemProp;
; 2073 : 
; 2074 : 		for( int i = 0; i < MAX_HUMAN_PARTS; i++ )

  00020	89 7c 24 14	 mov	 DWORD PTR _i$275758[esp+28], edi
  00024	56		 push	 esi
$L285174:

; 2075 : 		{
; 2076 : 			pItemElem = GetEquipItem( i ); //m_Inventory.GetAtId( m_adwEquipment[ i ] );

  00025	57		 push	 edi
  00026	8b cd		 mov	 ecx, ebp
  00028	e8 00 00 00 00	 call	 ?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetEquipItem
  0002d	8b d8		 mov	 ebx, eax

; 2077 : 			//if(pItem && !pItem->IsBreakableItem() && (pItem->m_nHitPoint == 1 || pItem->m_nHitPoint == 0))
; 2078 : 			//	continue; IK2_ARMOR
; 2079 : 			// IK_ARMOR         .
; 2080 : 			//     
; 2081 : 			//if( pItemElem && pItemElem->GetProp()->dwItemKind2 < IK2_WEAPON_DIRECT && pItemElem->GetProp()->dwItemKind2 > IK2_WEAPON_GUN )  //&& ( pItemElem->m_nHitPoint > 1 || pItemElem->m_nHitPoint == -1) )
; 2082 : 			if( pItemElem )

  0002f	85 db		 test	 ebx, ebx
  00031	0f 84 f4 00 00
	00		 je	 $L275760

; 2083 : 			{
; 2084 : 				pItemProp = pItemElem->GetProp();

  00037	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0003a	85 c0		 test	 eax, eax
  0003c	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00042	7c 2a		 jl	 SHORT $L285095
  00044	3b c1		 cmp	 eax, ecx
  00046	7d 26		 jge	 SHORT $L285095
  00048	72 19		 jb	 SHORT $L285107
  0004a	33 f6		 xor	 esi, esi
$L285090:

; 2085 : 
; 2086 : 				if( pItemProp == NULL )

  0004c	85 f6		 test	 esi, esi
  0004e	75 47		 jne	 SHORT $L285167

; 2087 : 				{
; 2088 : 					Error( "Parts Not Property = %d", i );

  00050	57		 push	 edi
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JFCDNFPO@Parts?5Not?5Property?5?$DN?5?$CFd?$AA@
  00056	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0005b	83 c4 08	 add	 esp, 8

; 2089 : 				}
; 2090 : 
; 2091 : 				if( pItemProp )

  0005e	e9 c8 00 00 00	 jmp	 $L275760

; 2083 : 			{
; 2084 : 				pItemProp = pItemElem->GetProp();

$L285107:
  00063	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00069	8b 34 81	 mov	 esi, DWORD PTR [ecx+eax*4]
  0006c	eb de		 jmp	 SHORT $L285090
$L285095:
  0006e	50		 push	 eax
  0006f	51		 push	 ecx
  00070	6a 00		 push	 0
  00072	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0007c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00081	83 c4 14	 add	 esp, 20			; 00000014H

; 2087 : 				{
; 2088 : 					Error( "Parts Not Property = %d", i );

  00084	57		 push	 edi
  00085	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@JFCDNFPO@Parts?5Not?5Property?5?$DN?5?$CFd?$AA@
  0008a	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0008f	83 c4 08	 add	 esp, 8

; 2089 : 				}
; 2090 : 
; 2091 : 				if( pItemProp )

  00092	e9 94 00 00 00	 jmp	 $L275760
$L285167:

; 2092 : 				{
; 2093 : 					if( pItemProp->dwItemKind2 == IK2_ARMOR || pItemProp->dwItemKind2 == IK2_ARMORETC )

  00097	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0009a	83 f8 07	 cmp	 eax, 7
  0009d	74 09		 je	 SHORT $L275767
  0009f	83 f8 08	 cmp	 eax, 8
  000a2	0f 85 83 00 00
	00		 jne	 $L275760
$L275767:

; 2094 : 					{
; 2095 : 						int nOption = pItemElem->GetAbilityOption();

  000a8	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]

; 2096 : 						int nOptionVal = 0;

  000ab	33 ff		 xor	 edi, edi

; 2097 : 						if( nOption > 0 ) 

  000ad	85 c0		 test	 eax, eax
  000af	89 44 24 1c	 mov	 DWORD PTR _nOption$275768[esp+32], eax
  000b3	7e 16		 jle	 SHORT $L275770

; 2098 : 							nOptionVal = (int)( pow( (float)( nOption ), 1.5f ) );

  000b5	db 44 24 1c	 fild	 DWORD PTR _nOption$275768[esp+32]
  000b9	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3ff8000000000000
  000bf	e8 00 00 00 00	 call	 __CIpow
  000c4	e8 00 00 00 00	 call	 __ftol2
  000c9	8b f8		 mov	 edi, eax
$L275770:

; 2099 : 							
; 2100 : 				#if __VER < 11 // __REMOVE_ENDURANCE
; 2101 : 						if( pItemElem->m_nRepairNumber >= 100 )
; 2102 : 							nOptionVal	+= prj.GetExpUpItem( pItemProp->dwItemKind3, 1 );
; 2103 : 				#endif // __REMOVE_ENDURANCE						
; 2104 : 						float f		= GetItemMultiplier( pItemElem );

  000cb	53		 push	 ebx
  000cc	8b cd		 mov	 ecx, ebp
  000ce	e8 00 00 00 00	 call	 ?GetItemMultiplier@CMover@@QAEMPAVCItemElem@@@Z ; CMover::GetItemMultiplier

; 2105 : 						nMin	+= (int)( pItemProp->dwAbilityMin * f ) + nOptionVal;

  000d3	db 86 e4 00 00
	00		 fild	 DWORD PTR [esi+228]
  000d9	8b 96 e4 00 00
	00		 mov	 edx, DWORD PTR [esi+228]
  000df	85 d2		 test	 edx, edx
  000e1	7d 06		 jge	 SHORT $L285175
  000e3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L285175:
  000e9	d8 c9		 fmul	 ST(0), ST(1)
  000eb	e8 00 00 00 00	 call	 __ftol2

; 2106 : 						nMax	+= (int)( pItemProp->dwAbilityMax * f ) + nOptionVal;

  000f0	db 86 e8 00 00
	00		 fild	 DWORD PTR [esi+232]
  000f6	8b 5c 24 14	 mov	 ebx, DWORD PTR _nMin$275754[esp+32]
  000fa	03 c7		 add	 eax, edi
  000fc	03 d8		 add	 ebx, eax
  000fe	8b 86 e8 00 00
	00		 mov	 eax, DWORD PTR [esi+232]
  00104	85 c0		 test	 eax, eax
  00106	89 5c 24 14	 mov	 DWORD PTR _nMin$275754[esp+32], ebx
  0010a	7d 06		 jge	 SHORT $L285176
  0010c	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L285176:
  00112	d8 c9		 fmul	 ST(0), ST(1)
  00114	e8 00 00 00 00	 call	 __ftol2
  00119	dd d8		 fstp	 ST(0)
  0011b	8b 4c 24 10	 mov	 ecx, DWORD PTR _nMax$275755[esp+32]
  0011f	03 c7		 add	 eax, edi
  00121	8b 7c 24 18	 mov	 edi, DWORD PTR _i$275758[esp+32]
  00125	03 c8		 add	 ecx, eax
  00127	89 4c 24 10	 mov	 DWORD PTR _nMax$275755[esp+32], ecx
$L275760:
  0012b	47		 inc	 edi
  0012c	83 ff 1f	 cmp	 edi, 31			; 0000001fH
  0012f	89 7c 24 18	 mov	 DWORD PTR _i$275758[esp+32], edi
  00133	0f 8c ec fe ff
	ff		 jl	 $L285174

; 2107 : 					}
; 2108 : 				}
; 2109 : 			}
; 2110 : 		}
; 2111 : 		//       .
; 2112 : 		nMin = GetParam( DST_ABILITY_MIN, nMin );

  00139	8b 85 bc 14 00
	00		 mov	 eax, DWORD PTR [ebp+5308]
  0013f	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	74 06		 je	 SHORT $L285139
  00148	89 44 24 0c	 mov	 DWORD PTR _nMin$275754[esp+24], eax
  0014c	eb 0e		 jmp	 SHORT $L285141
$L285139:
  0014e	8b 85 e8 12 00
	00		 mov	 eax, DWORD PTR [ebp+4840]
  00154	85 c0		 test	 eax, eax
  00156	74 04		 je	 SHORT $L285141
  00158	01 44 24 0c	 add	 DWORD PTR _nMin$275754[esp+24], eax
$L285141:

; 2113 : 		nMax = GetParam( DST_ABILITY_MAX, nMax );

  0015c	8b 85 c0 14 00
	00		 mov	 eax, DWORD PTR [ebp+5312]
  00162	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00167	74 06		 je	 SHORT $L285161
  00169	89 44 24 08	 mov	 DWORD PTR _nMax$275755[esp+24], eax
  0016d	eb 0e		 jmp	 SHORT $L285163
$L285161:
  0016f	8b 85 ec 12 00
	00		 mov	 eax, DWORD PTR [ebp+4844]
  00175	85 c0		 test	 eax, eax
  00177	74 04		 je	 SHORT $L285163
  00179	01 44 24 08	 add	 DWORD PTR _nMax$275755[esp+24], eax
$L285163:

; 2114 : 		if( pnMin ) *pnMin = nMin;

  0017d	8b 44 24 1c	 mov	 eax, DWORD PTR _pnMin$[esp+20]
  00181	85 c0		 test	 eax, eax
  00183	74 06		 je	 SHORT $L285172
  00185	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMin$275754[esp+24]
  00189	89 08		 mov	 DWORD PTR [eax], ecx
$L285172:

; 2115 : 		if( pnMax ) *pnMax = nMax;

  0018b	8b 44 24 20	 mov	 eax, DWORD PTR _pnMax$[esp+20]
  0018f	85 c0		 test	 eax, eax
  00191	74 06		 je	 SHORT $L285173
  00193	8b 54 24 08	 mov	 edx, DWORD PTR _nMax$275755[esp+24]
  00197	89 10		 mov	 DWORD PTR [eax], edx
$L285173:

; 2116 : 		return ( ( nMin + nMax ) / 2 ); //    .   .    .

  00199	8b 44 24 08	 mov	 eax, DWORD PTR _nMax$275755[esp+24]
  0019d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nMin$275754[esp+24]
  001a1	03 c1		 add	 eax, ecx
  001a3	99		 cdq
  001a4	2b c2		 sub	 eax, edx
  001a6	5f		 pop	 edi
  001a7	d1 f8		 sar	 eax, 1
  001a9	5d		 pop	 ebp

; 2123 : }

  001aa	83 c4 10	 add	 esp, 16			; 00000010H
  001ad	c2 08 00	 ret	 8
$L275753:
  001b0	5f		 pop	 edi

; 2117 : 	}
; 2118 : 	else
; 2119 : 	{
; 2120 : 	}
; 2121 : 	
; 2122 : 	return 0;

  001b1	33 c0		 xor	 eax, eax
  001b3	5d		 pop	 ebp

; 2123 : }

  001b4	83 c4 10	 add	 esp, 16			; 00000010H
  001b7	c2 08 00	 ret	 8
?SumEquipDefenseAbility@CMover@@QAEHPAJ0@Z ENDP		; CMover::SumEquipDefenseAbility
_TEXT	ENDS
PUBLIC	?SumEquipAdjValue@CMover@@QAEXPAH0@Z		; CMover::SumEquipAdjValue
; Function compile flags: /Ogty
;	COMDAT ?SumEquipAdjValue@CMover@@QAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pnAdjHitRate$ = 8					; size = 4
_pnAdjParray$ = 12					; size = 4
?SumEquipAdjValue@CMover@@QAEXPAH0@Z PROC NEAR		; CMover::SumEquipAdjValue, COMDAT
; _this$ = ecx

; 2126 : {

  00000	51		 push	 ecx

; 2127 : 	*pnAdjHitRate = 0;
; 2128 : 	*pnAdjParray = 0;

  00001	8b 44 24 0c	 mov	 eax, DWORD PTR _pnAdjParray$[esp]
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	8b 6c 24 10	 mov	 ebp, DWORD PTR _pnAdjHitRate$[esp+8]
  0000b	56		 push	 esi
  0000c	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  00013	57		 push	 edi
  00014	89 4c 24 10	 mov	 DWORD PTR _this$[esp+20], ecx
  00018	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2129 : 
; 2130 : 	CItemElem* pItemElem;
; 2131 : 	for( int i = 0; i < MAX_HUMAN_PARTS; i++ )

  0001e	33 db		 xor	 ebx, ebx
$L285508:

; 2132 : 	{
; 2133 : 		pItemElem = GetEquipItem( i );

  00020	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 ?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetEquipItem
  0002a	8b f8		 mov	 edi, eax

; 2134 : 		if( pItemElem )  

  0002c	85 ff		 test	 edi, edi
  0002e	0f 84 34 01 00
	00		 je	 $L275787

; 2135 : 		{
; 2136 : 			if( pItemElem->GetProp() )

  00034	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00037	85 c0		 test	 eax, eax
  00039	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  0003f	7c 29		 jl	 SHORT $L285230
  00041	3b c1		 cmp	 eax, ecx
  00043	7d 25		 jge	 SHORT $L285230
  00045	0f 83 1d 01 00
	00		 jae	 $L275787
  0004b	8b 35 4c 02 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+588
  00051	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]
  00054	85 d2		 test	 edx, edx
  00056	0f 84 0c 01 00
	00		 je	 $L275787

; 2137 : 			{
; 2138 : 				if( (int)pItemElem->GetProp()->nAdjHitRate > 0 )

  0005c	85 c0		 test	 eax, eax
  0005e	7c 25		 jl	 SHORT $L285295
  00060	3b c1		 cmp	 eax, ecx
  00062	7d 21		 jge	 SHORT $L285295
  00064	73 41		 jae	 SHORT $L285509
  00066	8b c2		 mov	 eax, edx
  00068	eb 3f		 jmp	 SHORT $L285290

; 2135 : 		{
; 2136 : 			if( pItemElem->GetProp() )

$L285230:
  0006a	50		 push	 eax
  0006b	51		 push	 ecx
  0006c	6a 00		 push	 0
  0006e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00073	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00078	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0007d	83 c4 14	 add	 esp, 20			; 00000014H
  00080	e9 e3 00 00 00	 jmp	 $L275787

; 2137 : 			{
; 2138 : 				if( (int)pItemElem->GetProp()->nAdjHitRate > 0 )

$L285295:
  00085	50		 push	 eax
  00086	51		 push	 ecx
  00087	6a 00		 push	 0
  00089	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0008e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00093	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00098	8b 35 4c 02 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+588
  0009e	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  000a4	83 c4 14	 add	 esp, 20			; 00000014H
$L285509:
  000a7	33 c0		 xor	 eax, eax
$L285290:
  000a9	8b 90 2c 01 00
	00		 mov	 edx, DWORD PTR [eax+300]
  000af	85 d2		 test	 edx, edx
  000b1	7e 3f		 jle	 SHORT $L275792

; 2139 : 					*pnAdjHitRate += pItemElem->GetProp()->nAdjHitRate;

  000b3	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000b6	85 c0		 test	 eax, eax
  000b8	7c 0b		 jl	 SHORT $L285360
  000ba	3b c1		 cmp	 eax, ecx
  000bc	7d 07		 jge	 SHORT $L285360
  000be	73 1b		 jae	 SHORT $L285510
  000c0	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000c3	eb 18		 jmp	 SHORT $L285355
$L285360:
  000c5	50		 push	 eax
  000c6	51		 push	 ecx
  000c7	6a 00		 push	 0
  000c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000d3	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000d8	83 c4 14	 add	 esp, 20			; 00000014H
$L285510:
  000db	33 c0		 xor	 eax, eax
$L285355:
  000dd	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  000e3	01 4d 00	 add	 DWORD PTR [ebp], ecx
  000e6	8b 35 4c 02 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+588
  000ec	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
$L275792:

; 2140 : 				if( (int)pItemElem->GetProp()->dwParry > 0 )

  000f2	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000f5	85 c0		 test	 eax, eax
  000f7	7c 0b		 jl	 SHORT $L285425
  000f9	3b c1		 cmp	 eax, ecx
  000fb	7d 07		 jge	 SHORT $L285425
  000fd	73 27		 jae	 SHORT $L285511
  000ff	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00102	eb 24		 jmp	 SHORT $L285420
$L285425:
  00104	50		 push	 eax
  00105	51		 push	 ecx
  00106	6a 00		 push	 0
  00108	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0010d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00112	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00117	8b 35 4c 02 00
	00		 mov	 esi, DWORD PTR ?prj@@3VCProject@@A+588
  0011d	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00123	83 c4 14	 add	 esp, 20			; 00000014H
$L285511:
  00126	33 c0		 xor	 eax, eax
$L285420:
  00128	8b 90 f8 00 00
	00		 mov	 edx, DWORD PTR [eax+248]
  0012e	85 d2		 test	 edx, edx
  00130	7e 36		 jle	 SHORT $L275787

; 2141 : 					*pnAdjParray += pItemElem->GetProp()->dwParry;

  00132	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00135	85 c0		 test	 eax, eax
  00137	7c 0b		 jl	 SHORT $L285490
  00139	3b c1		 cmp	 eax, ecx
  0013b	7d 07		 jge	 SHORT $L285490
  0013d	73 1b		 jae	 SHORT $L285512
  0013f	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00142	eb 18		 jmp	 SHORT $L285485
$L285490:
  00144	50		 push	 eax
  00145	51		 push	 ecx
  00146	6a 00		 push	 0
  00148	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  0014d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00152	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00157	83 c4 14	 add	 esp, 20			; 00000014H
$L285512:
  0015a	33 c0		 xor	 eax, eax
$L285485:
  0015c	8b 90 f8 00 00
	00		 mov	 edx, DWORD PTR [eax+248]
  00162	8b 44 24 1c	 mov	 eax, DWORD PTR _pnAdjParray$[esp+16]
  00166	01 10		 add	 DWORD PTR [eax], edx
$L275787:
  00168	43		 inc	 ebx
  00169	83 fb 1f	 cmp	 ebx, 31			; 0000001fH
  0016c	0f 8c ae fe ff
	ff		 jl	 $L285508
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5d		 pop	 ebp
  00175	5b		 pop	 ebx

; 2142 : 			}
; 2143 : 		}
; 2144 : 	}
; 2145 : }

  00176	59		 pop	 ecx
  00177	c2 08 00	 ret	 8
?SumEquipAdjValue@CMover@@QAEXPAH0@Z ENDP		; CMover::SumEquipAdjValue
_TEXT	ENDS
PUBLIC	?GetMaxHitPoint@CMover@@QAEHXZ			; CMover::GetMaxHitPoint
; Function compile flags: /Ogty
;	COMDAT ?GetMaxHitPoint@CMover@@QAEHXZ
_TEXT	SEGMENT
_nResult$ = -8						; size = 4
_nFactor$ = -4						; size = 4
?GetMaxHitPoint@CMover@@QAEHXZ PROC NEAR		; CMover::GetMaxHitPoint, COMDAT
; _this$ = ecx

; 2944 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2945 : 	if( IsInvalidObj(this) )	

  00006	85 f6		 test	 esi, esi
  00008	74 06		 je	 SHORT $L285533
  0000a	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  0000e	74 07		 je	 SHORT $L276113
$L285533:

; 2946 : 		return 0;

  00010	33 c0		 xor	 eax, eax
  00012	5e		 pop	 esi

; 2958 : #endif	// __JEFF_11
; 2959 : 	return nResult; 
; 2960 : }

  00013	83 c4 08	 add	 esp, 8
  00016	c3		 ret	 0
$L276113:

; 2947 : 
; 2948 : 	float factor = 1.0f;
; 2949 : 	int nResult = GetParam( DST_HP_MAX, GetMaxOriginHitPoint( FALSE ) );

  00017	6a 00		 push	 0
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  00020	8b 8e 18 15 00
	00		 mov	 ecx, DWORD PTR [esi+5400]
  00026	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0002c	74 06		 je	 SHORT $L285548
  0002e	89 4c 24 04	 mov	 DWORD PTR _nResult$[esp+12], ecx
  00032	eb 16		 jmp	 SHORT $L285551
$L285548:
  00034	8b 8e 44 13 00
	00		 mov	 ecx, DWORD PTR [esi+4932]
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 08		 je	 SHORT $L285550
  0003e	03 c8		 add	 ecx, eax
  00040	89 4c 24 04	 mov	 DWORD PTR _nResult$[esp+12], ecx
  00044	eb 04		 jmp	 SHORT $L285551
$L285550:
  00046	89 44 24 04	 mov	 DWORD PTR _nResult$[esp+12], eax
$L285551:

; 2950 : 	int nFactor = GetParam( DST_HP_MAX_RATE, 0 );

  0004a	8b 86 5c 15 00
	00		 mov	 eax, DWORD PTR [esi+5468]
  00050	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00055	74 06		 je	 SHORT $L285571
  00057	89 44 24 08	 mov	 DWORD PTR _nFactor$[esp+12], eax
  0005b	eb 0a		 jmp	 SHORT $L285573
$L285571:
  0005d	8b b6 88 13 00
	00		 mov	 esi, DWORD PTR [esi+5000]
  00063	89 74 24 08	 mov	 DWORD PTR _nFactor$[esp+12], esi
$L285573:

; 2951 : 
; 2952 : 	factor += (float)nFactor/(float)100;
; 2953 : 	nResult	= (int)( nResult * factor );

  00067	db 44 24 08	 fild	 DWORD PTR _nFactor$[esp+12]
  0006b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00071	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00077	da 4c 24 04	 fimul	 DWORD PTR _nResult$[esp+12]
  0007b	e8 00 00 00 00	 call	 __ftol2

; 2954 : 
; 2955 : #ifdef __JEFF_11
; 2956 : 	if( nResult < 1 )

  00080	83 f8 01	 cmp	 eax, 1
  00083	7d 05		 jge	 SHORT $L276112

; 2957 : 		nResult		= 1;

  00085	b8 01 00 00 00	 mov	 eax, 1
$L276112:
  0008a	5e		 pop	 esi

; 2958 : #endif	// __JEFF_11
; 2959 : 	return nResult; 
; 2960 : }

  0008b	83 c4 08	 add	 esp, 8
  0008e	c3		 ret	 0
?GetMaxHitPoint@CMover@@QAEHXZ ENDP			; CMover::GetMaxHitPoint
_TEXT	ENDS
PUBLIC	?GetMaxManaPoint@CMover@@QAEHXZ			; CMover::GetMaxManaPoint
; Function compile flags: /Ogty
;	COMDAT ?GetMaxManaPoint@CMover@@QAEHXZ
_TEXT	SEGMENT
_nResult$ = -8						; size = 4
_nFactor$ = -4						; size = 4
?GetMaxManaPoint@CMover@@QAEHXZ PROC NEAR		; CMover::GetMaxManaPoint, COMDAT
; _this$ = ecx

; 2964 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi

; 2965 : 	float factor = 1.0f;
; 2966 : 	int nResult = GetParam( DST_MP_MAX, GetMaxOriginManaPoint( FALSE ) );

  00004	6a 00		 push	 0
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint
  0000d	8b 8e 1c 15 00
	00		 mov	 ecx, DWORD PTR [esi+5404]
  00013	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00019	74 06		 je	 SHORT $L285597
  0001b	89 4c 24 04	 mov	 DWORD PTR _nResult$[esp+12], ecx
  0001f	eb 16		 jmp	 SHORT $L285600
$L285597:
  00021	8b 8e 48 13 00
	00		 mov	 ecx, DWORD PTR [esi+4936]
  00027	85 c9		 test	 ecx, ecx
  00029	74 08		 je	 SHORT $L285599
  0002b	03 c8		 add	 ecx, eax
  0002d	89 4c 24 04	 mov	 DWORD PTR _nResult$[esp+12], ecx
  00031	eb 04		 jmp	 SHORT $L285600
$L285599:
  00033	89 44 24 04	 mov	 DWORD PTR _nResult$[esp+12], eax
$L285600:

; 2967 : 	int nFactor = GetParam( DST_MP_MAX_RATE, 0 );

  00037	8b 86 60 15 00
	00		 mov	 eax, DWORD PTR [esi+5472]
  0003d	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00042	74 06		 je	 SHORT $L285620
  00044	89 44 24 08	 mov	 DWORD PTR _nFactor$[esp+12], eax
  00048	eb 0a		 jmp	 SHORT $L285622
$L285620:
  0004a	8b b6 8c 13 00
	00		 mov	 esi, DWORD PTR [esi+5004]
  00050	89 74 24 08	 mov	 DWORD PTR _nFactor$[esp+12], esi
$L285622:

; 2968 : 	
; 2969 : 	factor += (float)nFactor/(float)100;
; 2970 : 	nResult	= (int)( nResult * factor );

  00054	db 44 24 08	 fild	 DWORD PTR _nFactor$[esp+12]
  00058	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0005e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00064	da 4c 24 04	 fimul	 DWORD PTR _nResult$[esp+12]
  00068	e8 00 00 00 00	 call	 __ftol2

; 2971 : 
; 2972 : #ifdef __JEFF_11
; 2973 : 	if( nResult < 1 )

  0006d	83 f8 01	 cmp	 eax, 1
  00070	5e		 pop	 esi
  00071	7d 05		 jge	 SHORT $L276130

; 2974 : 		nResult		= 1;

  00073	b8 01 00 00 00	 mov	 eax, 1
$L276130:

; 2975 : #endif	// __JEFF_11
; 2976 : 	return nResult; 
; 2977 : }

  00078	83 c4 08	 add	 esp, 8
  0007b	c3		 ret	 0
?GetMaxManaPoint@CMover@@QAEHXZ ENDP			; CMover::GetMaxManaPoint
_TEXT	ENDS
PUBLIC	?GetMaxFatiguePoint@CMover@@QAEHXZ		; CMover::GetMaxFatiguePoint
; Function compile flags: /Ogty
;	COMDAT ?GetMaxFatiguePoint@CMover@@QAEHXZ
_TEXT	SEGMENT
_nResult$ = -8						; size = 4
_nFactor$ = -4						; size = 4
?GetMaxFatiguePoint@CMover@@QAEHXZ PROC NEAR		; CMover::GetMaxFatiguePoint, COMDAT
; _this$ = ecx

; 2981 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi

; 2982 : 	float factor = 1.0f;
; 2983 : 	int nResult = GetParam( DST_FP_MAX, GetMaxOriginFatiguePoint( FALSE ) );

  00004	6a 00		 push	 0
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  0000d	8b 8e 20 15 00
	00		 mov	 ecx, DWORD PTR [esi+5408]
  00013	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00019	74 06		 je	 SHORT $L285646
  0001b	89 4c 24 04	 mov	 DWORD PTR _nResult$[esp+12], ecx
  0001f	eb 16		 jmp	 SHORT $L285649
$L285646:
  00021	8b 8e 4c 13 00
	00		 mov	 ecx, DWORD PTR [esi+4940]
  00027	85 c9		 test	 ecx, ecx
  00029	74 08		 je	 SHORT $L285648
  0002b	03 c8		 add	 ecx, eax
  0002d	89 4c 24 04	 mov	 DWORD PTR _nResult$[esp+12], ecx
  00031	eb 04		 jmp	 SHORT $L285649
$L285648:
  00033	89 44 24 04	 mov	 DWORD PTR _nResult$[esp+12], eax
$L285649:

; 2984 : 	int nFactor = GetParam( DST_FP_MAX_RATE, 0 );

  00037	8b 86 64 15 00
	00		 mov	 eax, DWORD PTR [esi+5476]
  0003d	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00042	74 06		 je	 SHORT $L285669
  00044	89 44 24 08	 mov	 DWORD PTR _nFactor$[esp+12], eax
  00048	eb 0a		 jmp	 SHORT $L285671
$L285669:
  0004a	8b b6 90 13 00
	00		 mov	 esi, DWORD PTR [esi+5008]
  00050	89 74 24 08	 mov	 DWORD PTR _nFactor$[esp+12], esi
$L285671:

; 2985 : 	
; 2986 : 	factor += (float)nFactor/(float)100;
; 2987 : 	nResult	= (int)( nResult * factor );

  00054	db 44 24 08	 fild	 DWORD PTR _nFactor$[esp+12]
  00058	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0005e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00064	da 4c 24 04	 fimul	 DWORD PTR _nResult$[esp+12]
  00068	e8 00 00 00 00	 call	 __ftol2

; 2988 : 
; 2989 : #ifdef __JEFF_11
; 2990 : 	if( nResult < 1 )

  0006d	83 f8 01	 cmp	 eax, 1
  00070	5e		 pop	 esi
  00071	7d 05		 jge	 SHORT $L276140

; 2991 : 		nResult		= 1;

  00073	b8 01 00 00 00	 mov	 eax, 1
$L276140:

; 2992 : #endif	// __JEFF_11
; 2993 : 	return nResult; 
; 2994 : }

  00078	83 c4 08	 add	 esp, 8
  0007b	c3		 ret	 0
?GetMaxFatiguePoint@CMover@@QAEHXZ ENDP			; CMover::GetMaxFatiguePoint
_TEXT	ENDS
PUBLIC	?GetMaxPoint@CMover@@QAEHH@Z			; CMover::GetMaxPoint
; Function compile flags: /Ogty
;	COMDAT ?GetMaxPoint@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nDest$ = 8						; size = 4
?GetMaxPoint@CMover@@QAEHH@Z PROC NEAR			; CMover::GetMaxPoint, COMDAT
; _this$ = ecx

; 2998 : 	switch( nDest )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nDest$[esp-4]
  00004	83 e8 26	 sub	 eax, 38			; 00000026H
  00007	74 1b		 je	 SHORT $L276149
  00009	48		 dec	 eax
  0000a	74 10		 je	 SHORT $L276150
  0000c	48		 dec	 eax
  0000d	74 05		 je	 SHORT $L276151

; 3006 : 	}
; 3007 : 	
; 3008 : 	return 0;

  0000f	33 c0		 xor	 eax, eax

; 3009 : }

  00011	c2 04 00	 ret	 4
$L276151:

; 3004 : 		case DST_FP:
; 3005 : 			return GetMaxFatiguePoint();

  00014	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint

; 3009 : }

  00019	c2 04 00	 ret	 4
$L276150:

; 3002 : 		case DST_MP:
; 3003 : 			return GetMaxManaPoint();

  0001c	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint

; 3009 : }

  00021	c2 04 00	 ret	 4
$L276149:

; 2999 : 	{
; 3000 : 		case DST_HP:
; 3001 : 			return GetMaxHitPoint();

  00024	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint

; 3009 : }

  00029	c2 04 00	 ret	 4
?GetMaxPoint@CMover@@QAEHH@Z ENDP			; CMover::GetMaxPoint
_TEXT	ENDS
PUBLIC	?GetHitPointPercent@CMover@@QAEHH@Z		; CMover::GetHitPointPercent
EXTRN	__imp__MulDiv@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetHitPointPercent@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nPercent$ = 8						; size = 4
?GetHitPointPercent@CMover@@QAEHH@Z PROC NEAR		; CMover::GetHitPointPercent, COMDAT
; _this$ = ecx

; 3095 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3096 : 	int nMax = GetMaxHitPoint();

  00003	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint

; 3097 : 	if( nMax == 0 ) return 0;

  00008	85 c0		 test	 eax, eax
  0000a	75 04		 jne	 SHORT $L276199
  0000c	5e		 pop	 esi

; 3100 : }

  0000d	c2 04 00	 ret	 4
$L276199:

; 3098 : //	return GetHitPoint() * nPercent / nMax;
; 3099 : 	return MulDiv( GetHitPoint(), nPercent, nMax );

  00010	8b 8e 24 15 00
	00		 mov	 ecx, DWORD PTR [esi+5412]
  00016	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0001c	8b 96 00 06 00
	00		 mov	 edx, DWORD PTR [esi+1536]
  00022	75 0f		 jne	 SHORT $L285718
  00024	8b b6 50 13 00
	00		 mov	 esi, DWORD PTR [esi+4944]
  0002a	85 f6		 test	 esi, esi
  0002c	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  0002f	75 02		 jne	 SHORT $L285718
  00031	8b ca		 mov	 ecx, edx
$L285718:
  00033	50		 push	 eax
  00034	8b 44 24 0c	 mov	 eax, DWORD PTR _nPercent$[esp+4]
  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00040	5e		 pop	 esi

; 3100 : }

  00041	c2 04 00	 ret	 4
?GetHitPointPercent@CMover@@QAEHH@Z ENDP		; CMover::GetHitPointPercent
_TEXT	ENDS
PUBLIC	?GetManaPointPercent@CMover@@QAEHH@Z		; CMover::GetManaPointPercent
; Function compile flags: /Ogty
;	COMDAT ?GetManaPointPercent@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nPercent$ = 8						; size = 4
?GetManaPointPercent@CMover@@QAEHH@Z PROC NEAR		; CMover::GetManaPointPercent, COMDAT
; _this$ = ecx

; 3102 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3103 : 	int nMax = GetMaxManaPoint();

  00003	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint

; 3104 : 	if( nMax == 0 ) return 0;

  00008	85 c0		 test	 eax, eax
  0000a	75 04		 jne	 SHORT $L276205
  0000c	5e		 pop	 esi

; 3107 : }

  0000d	c2 04 00	 ret	 4
$L276205:

; 3105 : //	return GetManaPoint() * nPercent / GetMaxManaPoint();
; 3106 : 	return MulDiv( GetManaPoint(), nPercent, nMax );

  00010	8b 8e 28 15 00
	00		 mov	 ecx, DWORD PTR [esi+5416]
  00016	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0001c	8b 96 04 06 00
	00		 mov	 edx, DWORD PTR [esi+1540]
  00022	75 0f		 jne	 SHORT $L285768
  00024	8b b6 54 13 00
	00		 mov	 esi, DWORD PTR [esi+4948]
  0002a	85 f6		 test	 esi, esi
  0002c	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  0002f	75 02		 jne	 SHORT $L285768
  00031	8b ca		 mov	 ecx, edx
$L285768:
  00033	50		 push	 eax
  00034	8b 44 24 0c	 mov	 eax, DWORD PTR _nPercent$[esp+4]
  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00040	5e		 pop	 esi

; 3107 : }

  00041	c2 04 00	 ret	 4
?GetManaPointPercent@CMover@@QAEHH@Z ENDP		; CMover::GetManaPointPercent
_TEXT	ENDS
PUBLIC	?GetFatiguePointPercent@CMover@@QAEHH@Z		; CMover::GetFatiguePointPercent
; Function compile flags: /Ogty
;	COMDAT ?GetFatiguePointPercent@CMover@@QAEHH@Z
_TEXT	SEGMENT
_nPercent$ = 8						; size = 4
?GetFatiguePointPercent@CMover@@QAEHH@Z PROC NEAR	; CMover::GetFatiguePointPercent, COMDAT
; _this$ = ecx

; 3109 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3110 : 	int nMax = GetMaxFatiguePoint();

  00003	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint

; 3111 : 	if( nMax == 0 ) return 0;

  00008	85 c0		 test	 eax, eax
  0000a	75 04		 jne	 SHORT $L276211
  0000c	5e		 pop	 esi

; 3114 : }

  0000d	c2 04 00	 ret	 4
$L276211:

; 3112 : //	return GetFatiguePoint() * nPercent / GetMaxFatiguePoint();
; 3113 : 	return MulDiv( GetFatiguePoint(),  nPercent, nMax );

  00010	8b 8e 2c 15 00
	00		 mov	 ecx, DWORD PTR [esi+5420]
  00016	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0001c	8b 96 08 06 00
	00		 mov	 edx, DWORD PTR [esi+1544]
  00022	75 0f		 jne	 SHORT $L285811
  00024	8b b6 58 13 00
	00		 mov	 esi, DWORD PTR [esi+4952]
  0002a	85 f6		 test	 esi, esi
  0002c	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  0002f	75 02		 jne	 SHORT $L285811
  00031	8b ca		 mov	 ecx, edx
$L285811:
  00033	50		 push	 eax
  00034	8b 44 24 0c	 mov	 eax, DWORD PTR _nPercent$[esp+4]
  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00040	5e		 pop	 esi

; 3114 : }

  00041	c2 04 00	 ret	 4
?GetFatiguePointPercent@CMover@@QAEHH@Z ENDP		; CMover::GetFatiguePointPercent
_TEXT	ENDS
PUBLIC	__real@43fa0000
PUBLIC	__real@3eaaaaab
PUBLIC	__real@3dcccccd
PUBLIC	?GetHPRecovery@CMover@@QAEHXZ			; CMover::GetHPRecovery
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@3eaaaaab
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetHPRecovery@CMover@@QAEHXZ
_TEXT	SEGMENT
_nResult$285871 = -20					; size = 4
_fFactor$ = -16						; size = 4
tv269 = -12						; size = 4
$T285831 = -8						; size = 4
$T285827 = -4						; size = 4
_nValue$ = -4						; size = 4
?GetHPRecovery@CMover@@QAEHXZ PROC NEAR			; CMover::GetHPRecovery, COMDAT
; _this$ = ecx

; 3128 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3129 : 	float fFactor = 1.0f;
; 3130 : 	if( IsPlayer() )

  00006	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0000c	85 c0		 test	 eax, eax
  0000e	c7 44 24 08 00
	00 80 3f	 mov	 DWORD PTR _fFactor$[esp+24], 1065353216 ; 3f800000H
  00016	74 18		 je	 SHORT $L276216

; 3131 : 	{
; 3132 : 		JobProp* pProperty = prj.GetJobProp( GetJob() ); 

  00018	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  0001e	50		 push	 eax
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00024	e8 00 00 00 00	 call	 ?GetJobProp@CProject@@QAEPAUJobProp@@H@Z ; CProject::GetJobProp

; 3133 : 		fFactor = pProperty->fFactorHPRecovery;

  00029	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0002c	89 44 24 08	 mov	 DWORD PTR _fFactor$[esp+24], eax
$L276216:

; 3134 : 	}
; 3135 : 
; 3136 : 	//(/3)+ (MaxHP/ (500* ))+(STA*Job)
; 3137 : 	int nValue = (int)( (GetLevel() / 3.0f) + (GetMaxHitPoint() / (500.f * GetLevel())) + (GetSta() * fFactor) );

  00030	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  00036	89 44 24 14	 mov	 DWORD PTR $T285827[esp+24], eax
  0003a	89 44 24 10	 mov	 DWORD PTR $T285831[esp+24], eax
  0003e	8b 86 9c 14 00
	00		 mov	 eax, DWORD PTR [esi+5276]
  00044	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00049	8b c8		 mov	 ecx, eax
  0004b	75 06		 jne	 SHORT $L285868
  0004d	8b 8e c8 12 00
	00		 mov	 ecx, DWORD PTR [esi+4808]
$L285868:
  00053	8b 86 d4 05 00
	00		 mov	 eax, DWORD PTR [esi+1492]
  00059	03 c1		 add	 eax, ecx
  0005b	83 f8 01	 cmp	 eax, 1
  0005e	89 44 24 04	 mov	 DWORD PTR _nResult$285871[esp+24], eax
  00062	7d 08		 jge	 SHORT $L285872
  00064	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR _nResult$285871[esp+24], 1
$L285872:
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  00073	89 44 24 0c	 mov	 DWORD PTR tv269[esp+24], eax
  00077	db 44 24 0c	 fild	 DWORD PTR tv269[esp+24]
  0007b	db 44 24 10	 fild	 DWORD PTR $T285831[esp+24]
  0007f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@43fa0000
  00085	de f9		 fdivp	 ST(1), ST(0)
  00087	db 44 24 04	 fild	 DWORD PTR _nResult$285871[esp+24]
  0008b	d8 4c 24 08	 fmul	 DWORD PTR _fFactor$[esp+24]
  0008f	de c1		 faddp	 ST(1), ST(0)
  00091	db 44 24 14	 fild	 DWORD PTR $T285827[esp+24]
  00095	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3eaaaaab
  0009b	de c1		 faddp	 ST(1), ST(0)
  0009d	e8 00 00 00 00	 call	 __ftol2
  000a2	89 44 24 14	 mov	 DWORD PTR _nValue$[esp+24], eax

; 3138 : #if __VER >= 9 // __RECOVERY10
; 3139 : 	nValue	= (int)( nValue - ( nValue * 0.1f ) ); //  10% 

  000a6	db 44 24 14	 fild	 DWORD PTR _nValue$[esp+24]
  000aa	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3dcccccd
  000b0	d8 c9		 fmul	 ST(0), ST(1)
  000b2	d8 e9		 fsubr	 ST(0), ST(1)
  000b4	e8 00 00 00 00	 call	 __ftol2
  000b9	dd d8		 fstp	 ST(0)

; 3140 : #endif //__RECOVERY10
; 3141 : 	return GetParam( DST_HP_RECOVERY, nValue );

  000bb	8b 8e 30 15 00
	00		 mov	 ecx, DWORD PTR [esi+5424]
  000c1	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  000c7	74 07		 je	 SHORT $L285891
  000c9	8b c1		 mov	 eax, ecx
  000cb	5e		 pop	 esi

; 3142 : }

  000cc	83 c4 14	 add	 esp, 20			; 00000014H
  000cf	c3		 ret	 0

; 3140 : #endif //__RECOVERY10
; 3141 : 	return GetParam( DST_HP_RECOVERY, nValue );

$L285891:
  000d0	8b b6 5c 13 00
	00		 mov	 esi, DWORD PTR [esi+4956]
  000d6	85 f6		 test	 esi, esi
  000d8	74 02		 je	 SHORT $L285894
  000da	03 c6		 add	 eax, esi
$L285894:
  000dc	5e		 pop	 esi

; 3142 : }

  000dd	83 c4 14	 add	 esp, 20			; 00000014H
  000e0	c3		 ret	 0
?GetHPRecovery@CMover@@QAEHXZ ENDP			; CMover::GetHPRecovery
_TEXT	ENDS
PUBLIC	__real@3fc00000
PUBLIC	__real@3e4ccccd
PUBLIC	?GetMPRecovery@CMover@@QAEHXZ			; CMover::GetMPRecovery
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetMPRecovery@CMover@@QAEHXZ
_TEXT	SEGMENT
_nResult$285960 = -20					; size = 4
_fFactor$ = -16						; size = 4
tv271 = -12						; size = 4
$T285920 = -8						; size = 4
$T285916 = -4						; size = 4
_nValue$ = -4						; size = 4
?GetMPRecovery@CMover@@QAEHXZ PROC NEAR			; CMover::GetMPRecovery, COMDAT
; _this$ = ecx

; 3145 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3146 : 	float fFactor = 1.0f;
; 3147 : 	if( IsPlayer() )

  00006	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0000c	85 c0		 test	 eax, eax
  0000e	c7 44 24 08 00
	00 80 3f	 mov	 DWORD PTR _fFactor$[esp+24], 1065353216 ; 3f800000H
  00016	74 18		 je	 SHORT $L276225

; 3148 : 	{
; 3149 : 		JobProp* pProperty = prj.GetJobProp( GetJob() ); 

  00018	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  0001e	50		 push	 eax
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00024	e8 00 00 00 00	 call	 ?GetJobProp@CProject@@QAEPAUJobProp@@H@Z ; CProject::GetJobProp

; 3150 : 		fFactor = pProperty->fFactorMPRecovery;

  00029	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0002c	89 44 24 08	 mov	 DWORD PTR _fFactor$[esp+24], eax
$L276225:

; 3151 : 	}
; 3152 : 
; 3153 : 	// ((*1.5)+(MaxMP/(500*))+(INT*Job))*0.2
; 3154 : 	int nValue = (int)( ((GetLevel() * 1.5f) + (GetMaxManaPoint() / (500.f * GetLevel())) + (GetInt() * fFactor)) * 0.2f );

  00030	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  00036	89 44 24 14	 mov	 DWORD PTR $T285916[esp+24], eax
  0003a	89 44 24 10	 mov	 DWORD PTR $T285920[esp+24], eax
  0003e	8b 86 98 14 00
	00		 mov	 eax, DWORD PTR [esi+5272]
  00044	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00049	8b c8		 mov	 ecx, eax
  0004b	75 06		 jne	 SHORT $L285957
  0004d	8b 8e c4 12 00
	00		 mov	 ecx, DWORD PTR [esi+4804]
$L285957:
  00053	8b 86 dc 05 00
	00		 mov	 eax, DWORD PTR [esi+1500]
  00059	03 c1		 add	 eax, ecx
  0005b	83 f8 01	 cmp	 eax, 1
  0005e	89 44 24 04	 mov	 DWORD PTR _nResult$285960[esp+24], eax
  00062	7d 08		 jge	 SHORT $L285961
  00064	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR _nResult$285960[esp+24], 1
$L285961:
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  00073	89 44 24 0c	 mov	 DWORD PTR tv271[esp+24], eax
  00077	db 44 24 0c	 fild	 DWORD PTR tv271[esp+24]
  0007b	db 44 24 10	 fild	 DWORD PTR $T285920[esp+24]
  0007f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@43fa0000
  00085	de f9		 fdivp	 ST(1), ST(0)
  00087	db 44 24 04	 fild	 DWORD PTR _nResult$285960[esp+24]
  0008b	d8 4c 24 08	 fmul	 DWORD PTR _fFactor$[esp+24]
  0008f	de c1		 faddp	 ST(1), ST(0)
  00091	db 44 24 14	 fild	 DWORD PTR $T285916[esp+24]
  00095	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3fc00000
  0009b	de c1		 faddp	 ST(1), ST(0)
  0009d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e4ccccd
  000a3	e8 00 00 00 00	 call	 __ftol2
  000a8	89 44 24 14	 mov	 DWORD PTR _nValue$[esp+24], eax

; 3155 : #if __VER >= 9 // __RECOVERY10
; 3156 : 	nValue	= (int)( nValue - ( nValue * 0.1f ) ); //  10% 

  000ac	db 44 24 14	 fild	 DWORD PTR _nValue$[esp+24]
  000b0	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3dcccccd
  000b6	d8 c9		 fmul	 ST(0), ST(1)
  000b8	d8 e9		 fsubr	 ST(0), ST(1)
  000ba	e8 00 00 00 00	 call	 __ftol2
  000bf	dd d8		 fstp	 ST(0)

; 3157 : #endif //__RECOVERY10
; 3158 : 	return GetParam( DST_MP_RECOVERY, nValue );

  000c1	8b 8e 34 15 00
	00		 mov	 ecx, DWORD PTR [esi+5428]
  000c7	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  000cd	74 07		 je	 SHORT $L285980
  000cf	8b c1		 mov	 eax, ecx
  000d1	5e		 pop	 esi

; 3159 : }

  000d2	83 c4 14	 add	 esp, 20			; 00000014H
  000d5	c3		 ret	 0

; 3157 : #endif //__RECOVERY10
; 3158 : 	return GetParam( DST_MP_RECOVERY, nValue );

$L285980:
  000d6	8b b6 60 13 00
	00		 mov	 esi, DWORD PTR [esi+4960]
  000dc	85 f6		 test	 esi, esi
  000de	74 02		 je	 SHORT $L285983
  000e0	03 c6		 add	 eax, esi
$L285983:
  000e2	5e		 pop	 esi

; 3159 : }

  000e3	83 c4 14	 add	 esp, 20			; 00000014H
  000e6	c3		 ret	 0
?GetMPRecovery@CMover@@QAEHXZ ENDP			; CMover::GetMPRecovery
_TEXT	ENDS
PUBLIC	?GetFPRecovery@CMover@@QAEHXZ			; CMover::GetFPRecovery
; Function compile flags: /Ogty
;	COMDAT ?GetFPRecovery@CMover@@QAEHXZ
_TEXT	SEGMENT
_nResult$286047 = -20					; size = 4
_fFactor$ = -16						; size = 4
tv271 = -12						; size = 4
$T286007 = -8						; size = 4
$T286003 = -4						; size = 4
_nValue$ = -4						; size = 4
?GetFPRecovery@CMover@@QAEHXZ PROC NEAR			; CMover::GetFPRecovery, COMDAT
; _this$ = ecx

; 3162 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3163 : 	float fFactor = 1.0f;
; 3164 : 	if( IsPlayer() )

  00006	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  0000c	85 c0		 test	 eax, eax
  0000e	c7 44 24 08 00
	00 80 3f	 mov	 DWORD PTR _fFactor$[esp+24], 1065353216 ; 3f800000H
  00016	74 18		 je	 SHORT $L276234

; 3165 : 	{
; 3166 : 		JobProp* pProperty = prj.GetJobProp( GetJob() ); 

  00018	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  0001e	50		 push	 eax
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00024	e8 00 00 00 00	 call	 ?GetJobProp@CProject@@QAEPAUJobProp@@H@Z ; CProject::GetJobProp

; 3167 : 		fFactor = pProperty->fFactorFPRecovery;

  00029	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0002c	89 44 24 08	 mov	 DWORD PTR _fFactor$[esp+24], eax
$L276234:

; 3168 : 	}
; 3169 : 	// ((*2)+(MaxFP/(500*))+(STA*Job))*0.2
; 3170 : 	int nValue = (int)( ((GetLevel() * 2.0f) + (GetMaxFatiguePoint() / (500.f * GetLevel())) + (GetSta() * fFactor)) * 0.2f );

  00030	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  00036	89 44 24 14	 mov	 DWORD PTR $T286003[esp+24], eax
  0003a	89 44 24 10	 mov	 DWORD PTR $T286007[esp+24], eax
  0003e	8b 86 9c 14 00
	00		 mov	 eax, DWORD PTR [esi+5276]
  00044	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00049	8b c8		 mov	 ecx, eax
  0004b	75 06		 jne	 SHORT $L286044
  0004d	8b 8e c8 12 00
	00		 mov	 ecx, DWORD PTR [esi+4808]
$L286044:
  00053	8b 86 d4 05 00
	00		 mov	 eax, DWORD PTR [esi+1492]
  00059	03 c1		 add	 eax, ecx
  0005b	83 f8 01	 cmp	 eax, 1
  0005e	89 44 24 04	 mov	 DWORD PTR _nResult$286047[esp+24], eax
  00062	7d 08		 jge	 SHORT $L286048
  00064	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR _nResult$286047[esp+24], 1
$L286048:
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  00073	89 44 24 0c	 mov	 DWORD PTR tv271[esp+24], eax
  00077	db 44 24 0c	 fild	 DWORD PTR tv271[esp+24]
  0007b	db 44 24 10	 fild	 DWORD PTR $T286007[esp+24]
  0007f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@43fa0000
  00085	de f9		 fdivp	 ST(1), ST(0)
  00087	db 44 24 04	 fild	 DWORD PTR _nResult$286047[esp+24]
  0008b	d8 4c 24 08	 fmul	 DWORD PTR _fFactor$[esp+24]
  0008f	de c1		 faddp	 ST(1), ST(0)
  00091	db 44 24 14	 fild	 DWORD PTR $T286003[esp+24]
  00095	dc c0		 fadd	 ST(0), ST(0)
  00097	de c1		 faddp	 ST(1), ST(0)
  00099	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3e4ccccd
  0009f	e8 00 00 00 00	 call	 __ftol2
  000a4	89 44 24 14	 mov	 DWORD PTR _nValue$[esp+24], eax

; 3171 : #if __VER >= 9 // __RECOVERY10
; 3172 : 	nValue	= (int)( nValue - ( nValue * 0.1f ) ); //  10% 

  000a8	db 44 24 14	 fild	 DWORD PTR _nValue$[esp+24]
  000ac	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3dcccccd
  000b2	d8 c9		 fmul	 ST(0), ST(1)
  000b4	d8 e9		 fsubr	 ST(0), ST(1)
  000b6	e8 00 00 00 00	 call	 __ftol2
  000bb	dd d8		 fstp	 ST(0)

; 3173 : #endif //__RECOVERY10
; 3174 : 	return GetParam( DST_FP_RECOVERY, nValue );

  000bd	8b 8e 38 15 00
	00		 mov	 ecx, DWORD PTR [esi+5432]
  000c3	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  000c9	74 07		 je	 SHORT $L286067
  000cb	8b c1		 mov	 eax, ecx
  000cd	5e		 pop	 esi

; 3175 : }

  000ce	83 c4 14	 add	 esp, 20			; 00000014H
  000d1	c3		 ret	 0

; 3173 : #endif //__RECOVERY10
; 3174 : 	return GetParam( DST_FP_RECOVERY, nValue );

$L286067:
  000d2	8b b6 64 13 00
	00		 mov	 esi, DWORD PTR [esi+4964]
  000d8	85 f6		 test	 esi, esi
  000da	74 02		 je	 SHORT $L286070
  000dc	03 c6		 add	 eax, esi
$L286070:
  000de	5e		 pop	 esi

; 3175 : }

  000df	83 c4 14	 add	 esp, 20			; 00000014H
  000e2	c3		 ret	 0
?GetFPRecovery@CMover@@QAEHXZ ENDP			; CMover::GetFPRecovery
_TEXT	ENDS
PUBLIC	?BehaviorActionForceSet@CMover@@QAEXXZ		; CMover::BehaviorActionForceSet
; Function compile flags: /Ogty
;	COMDAT ?BehaviorActionForceSet@CMover@@QAEXXZ
_TEXT	SEGMENT
?BehaviorActionForceSet@CMover@@QAEXXZ PROC NEAR	; CMover::BehaviorActionForceSet, COMDAT
; _this$ = ecx

; 3459 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3460 : 	if( m_CorrAction.fValid && m_CorrAction.fBehavior == TRUE ) {

  00003	8b 86 c4 02 00
	00		 mov	 eax, DWORD PTR [esi+708]
  00009	85 c0		 test	 eax, eax
  0000b	57		 push	 edi
  0000c	0f 84 9a 00 00
	00		 je	 $L276301
  00012	83 be c8 02 00
	00 01		 cmp	 DWORD PTR [esi+712], 1
  00019	0f 85 8d 00 00
	00		 jne	 $L276301

; 3461 : 		if( m_CorrAction.dwStateFlag & OBJSTAF_FLY ) {
; 3462 : 			ActionForceSet2( m_CorrAction.v, m_CorrAction.vd, m_CorrAction.f,
; 3463 : 								m_CorrAction.fAngleX, m_CorrAction.fAccPower, m_CorrAction.fTurnAngle,
; 3464 : 								m_CorrAction.dwState, m_CorrAction.dwStateFlag,
; 3465 : 								m_CorrAction.dwMotion, m_CorrAction.nMotionEx, m_CorrAction.nLoop, m_CorrAction.dwMotionOption );

  0001f	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  00025	8b 96 98 02 00
	00		 mov	 edx, DWORD PTR [esi+664]
  0002b	8b 86 8c 02 00
	00		 mov	 eax, DWORD PTR [esi+652]
  00031	51		 push	 ecx
  00032	8b 8e 94 02 00
	00		 mov	 ecx, DWORD PTR [esi+660]
  00038	52		 push	 edx
  00039	8b 96 90 02 00
	00		 mov	 edx, DWORD PTR [esi+656]
  0003f	51		 push	 ecx
  00040	52		 push	 edx
  00041	50		 push	 eax
  00042	a8 08		 test	 al, 8
  00044	8b 86 88 02 00
	00		 mov	 eax, DWORD PTR [esi+648]
  0004a	50		 push	 eax
  0004b	74 43		 je	 SHORT $L276300
  0004d	8b 8e c0 02 00
	00		 mov	 ecx, DWORD PTR [esi+704]
  00053	8b 96 bc 02 00
	00		 mov	 edx, DWORD PTR [esi+700]
  00059	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  0005f	51		 push	 ecx
  00060	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	8d 96 ac 02 00
	00		 lea	 edx, DWORD PTR [esi+684]
  0006f	52		 push	 edx
  00070	8d 86 a0 02 00
	00		 lea	 eax, DWORD PTR [esi+672]
  00076	50		 push	 eax
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?ActionForceSet2@CMover@@QAEXAAUD3DXVECTOR3@@0MMMMKKHHHK@Z ; CMover::ActionForceSet2

; 3471 : 		}
; 3472 : 	}
; 3473 : 	memset( &m_CorrAction, 0, sizeof(CORR_ACTION) );

  0007e	8d be 80 02 00
	00		 lea	 edi, DWORD PTR [esi+640]
  00084	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00089	33 c0		 xor	 eax, eax
  0008b	f3 ab		 rep stosd
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi

; 3474 : }

  0008f	c3		 ret	 0
$L276300:

; 3466 : 		}
; 3467 : 		else {
; 3468 : 			ActionForceSet( m_CorrAction.v, m_CorrAction.vd, m_CorrAction.f,
; 3469 : 								m_CorrAction.dwState, m_CorrAction.dwStateFlag,
; 3470 : 								m_CorrAction.dwMotion, m_CorrAction.nMotionEx, m_CorrAction.nLoop, m_CorrAction.dwMotionOption );

  00090	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  00096	51		 push	 ecx
  00097	8d 96 ac 02 00
	00		 lea	 edx, DWORD PTR [esi+684]
  0009d	52		 push	 edx
  0009e	8d 86 a0 02 00
	00		 lea	 eax, DWORD PTR [esi+672]
  000a4	50		 push	 eax
  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ?ActionForceSet@CMover@@QAEXAAUD3DXVECTOR3@@0MKKHHHK@Z ; CMover::ActionForceSet
$L276301:

; 3471 : 		}
; 3472 : 	}
; 3473 : 	memset( &m_CorrAction, 0, sizeof(CORR_ACTION) );

  000ac	8d be 80 02 00
	00		 lea	 edi, DWORD PTR [esi+640]
  000b2	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000b7	33 c0		 xor	 eax, eax
  000b9	f3 ab		 rep stosd
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi

; 3474 : }

  000bd	c3		 ret	 0
?BehaviorActionForceSet@CMover@@QAEXXZ ENDP		; CMover::BehaviorActionForceSet
_TEXT	ENDS
PUBLIC	?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z		; CMover::SetQuest
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z
_TEXT	SEGMENT
_lpQuest$ = -24						; size = 4
_newQuest$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_nQuestId$ = 8						; size = 4
_nState$ = 12						; size = 4
_lpReturnQuest$ = 16					; size = 4
?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z PROC NEAR	; CMover::SetQuest, COMDAT
; _this$ = ecx

; 3631 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	53		 push	 ebx

; 3632 : 	QUEST newQuest;
; 3633 : 	ZeroMemory( &newQuest, sizeof( QUEST ) );
; 3634 : 	newQuest.m_wId = nQuestId;

  0000b	8b 5c 24 20	 mov	 ebx, DWORD PTR _nQuestId$[esp+24]
  0000f	55		 push	 ebp
  00010	56		 push	 esi
  00011	33 f6		 xor	 esi, esi
  00013	57		 push	 edi
  00014	8b 7c 24 34	 mov	 edi, DWORD PTR _lpReturnQuest$[esp+36]
  00018	89 44 24 24	 mov	 DWORD PTR __$ArrayPad$[esp+40], eax

; 3635 : 	newQuest.m_nState = nState;

  0001c	8a 44 24 30	 mov	 al, BYTE PTR _nState$[esp+36]
  00020	89 74 24 14	 mov	 DWORD PTR _newQuest$[esp+40], esi
  00024	89 74 24 18	 mov	 DWORD PTR _newQuest$[esp+44], esi

; 3636 : 
; 3637 : 	LPQUEST lpQuest = FindQuest( nQuestId );

  00028	53		 push	 ebx
  00029	8b e9		 mov	 ebp, ecx
  0002b	66 89 74 24 24	 mov	 WORD PTR _newQuest$[esp+56], si
  00030	89 74 24 20	 mov	 DWORD PTR _newQuest$[esp+52], esi
  00034	66 89 5c 24 1c	 mov	 WORD PTR _newQuest$[esp+48], bx
  00039	88 44 24 18	 mov	 BYTE PTR _newQuest$[esp+44], al
  0003d	e8 00 00 00 00	 call	 ?FindQuest@CMover@@QAEPAUtagQuest@@H@Z ; CMover::FindQuest

; 3638 : 	//      
; 3639 : 	if( lpQuest == NULL && IsCompleteQuest( newQuest.m_wId ) )

  00042	85 c0		 test	 eax, eax
  00044	89 44 24 10	 mov	 DWORD PTR _lpQuest$[esp+40], eax
  00048	75 2a		 jne	 SHORT $L276418
  0004a	0f b7 cb	 movzx	 ecx, bx
  0004d	51		 push	 ecx
  0004e	8b cd		 mov	 ecx, ebp
  00050	e8 00 00 00 00	 call	 ?IsCompleteQuest@CMover@@QAEHH@Z ; CMover::IsCompleteQuest
  00055	85 c0		 test	 eax, eax
  00057	74 17		 je	 SHORT $L286081
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5d		 pop	 ebp

; 3640 : 		return FALSE;

  0005c	33 c0		 xor	 eax, eax
  0005e	5b		 pop	 ebx

; 3644 : }

  0005f	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  00063	33 cc		 xor	 ecx, esp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	83 c4 18	 add	 esp, 24			; 00000018H
  0006d	c2 0c 00	 ret	 12			; 0000000cH
$L286081:

; 3638 : 	//      
; 3639 : 	if( lpQuest == NULL && IsCompleteQuest( newQuest.m_wId ) )

  00070	8b 44 24 10	 mov	 eax, DWORD PTR _lpQuest$[esp+40]
$L276418:

; 3641 : 	if( lpReturnQuest )

  00074	85 ff		 test	 edi, edi
  00076	74 18		 je	 SHORT $L276419

; 3642 : 		memcpy( lpReturnQuest, &newQuest, sizeof( QUEST ) );

  00078	8b 54 24 14	 mov	 edx, DWORD PTR _newQuest$[esp+40]
  0007c	8b 4c 24 18	 mov	 ecx, DWORD PTR _newQuest$[esp+44]
  00080	89 17		 mov	 DWORD PTR [edi], edx
  00082	8b 54 24 1c	 mov	 edx, DWORD PTR _newQuest$[esp+48]
  00086	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00089	89 57 08	 mov	 DWORD PTR [edi+8], edx
  0008c	66 89 77 0c	 mov	 WORD PTR [edi+12], si
$L276419:

; 3643 : 	return __SetQuest( lpQuest, &newQuest );

  00090	8d 4c 24 14	 lea	 ecx, DWORD PTR _newQuest$[esp+40]
  00094	51		 push	 ecx
  00095	50		 push	 eax
  00096	8b cd		 mov	 ecx, ebp
  00098	e8 00 00 00 00	 call	 ?__SetQuest@CMover@@AAEHPAUtagQuest@@0@Z ; CMover::__SetQuest

; 3644 : }

  0009d	8b 4c 24 24	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+40]
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5d		 pop	 ebp
  000a4	5b		 pop	 ebx
  000a5	33 cc		 xor	 ecx, esp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	83 c4 18	 add	 esp, 24			; 00000018H
  000af	c2 0c 00	 ret	 12			; 0000000cH
?SetQuest@CMover@@QAEHHHPAUtagQuest@@@Z ENDP		; CMover::SetQuest
_TEXT	ENDS
PUBLIC	?SetQuest@CMover@@QAEHPAUtagQuest@@@Z		; CMover::SetQuest
; Function compile flags: /Ogty
;	COMDAT ?SetQuest@CMover@@QAEHPAUtagQuest@@@Z
_TEXT	SEGMENT
_lpNewQuest$ = 8					; size = 4
?SetQuest@CMover@@QAEHPAUtagQuest@@@Z PROC NEAR		; CMover::SetQuest, COMDAT
; _this$ = ecx

; 3646 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 3647 : 	LPQUEST lpQuest = FindQuest( lpNewQuest->m_wId );

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _lpNewQuest$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	0f b7 7d 04	 movzx	 edi, WORD PTR [ebp+4]
  0000c	57		 push	 edi
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 ?FindQuest@CMover@@QAEPAUtagQuest@@H@Z ; CMover::FindQuest
  00014	8b d8		 mov	 ebx, eax

; 3648 : 	//      
; 3649 : 	if( lpQuest == NULL && IsCompleteQuest( lpNewQuest->m_wId ) )

  00016	85 db		 test	 ebx, ebx
  00018	75 15		 jne	 SHORT $L276426
  0001a	57		 push	 edi
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?IsCompleteQuest@CMover@@QAEHH@Z ; CMover::IsCompleteQuest
  00022	85 c0		 test	 eax, eax
  00024	74 09		 je	 SHORT $L276426
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp

; 3650 : 		return FALSE;

  00029	33 c0		 xor	 eax, eax
  0002b	5b		 pop	 ebx

; 3652 : }

  0002c	c2 04 00	 ret	 4
$L276426:

; 3651 : 	return __SetQuest( lpQuest, lpNewQuest );

  0002f	55		 push	 ebp
  00030	53		 push	 ebx
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?__SetQuest@CMover@@AAEHPAUtagQuest@@0@Z ; CMover::__SetQuest
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5d		 pop	 ebp
  0003b	5b		 pop	 ebx

; 3652 : }

  0003c	c2 04 00	 ret	 4
?SetQuest@CMover@@QAEHPAUtagQuest@@@Z ENDP		; CMover::SetQuest
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::end
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBKPAVIBuff@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogty
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00005	84 d2		 test	 dl, dl
  00007	75 4d		 jne	 SHORT $L278240

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  00009	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000c	53		 push	 ebx
  0000d	8a 5a 15	 mov	 bl, BYTE PTR [edx+21]
  00010	84 db		 test	 bl, bl
  00012	75 1b		 jne	 SHORT $L286157

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00019	84 db		 test	 bl, bl
  0001b	75 0e		 jne	 SHORT $L286138
  0001d	8d 49 00	 npad	 3
$L286137:
  00020	8b d0		 mov	 edx, eax
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00027	84 db		 test	 bl, bl
  00029	74 f5		 je	 SHORT $L286137
$L286138:
  0002b	89 11		 mov	 DWORD PTR [ecx], edx
  0002d	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  0002e	c3		 ret	 0
$L286157:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00035	84 d2		 test	 dl, dl
  00037	75 1a		 jne	 SHORT $L278244
  00039	8d a4 24 00 00
	00 00		 npad	 7
$L278243:
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00045	75 0c		 jne	 SHORT $L278244

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00047	89 01		 mov	 DWORD PTR [ecx], eax
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  0004f	84 d2		 test	 dl, dl
  00051	74 ed		 je	 SHORT $L278243
$L278244:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	5b		 pop	 ebx
$L278240:

; 279  : 				}
; 280  : 			}

  00056	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::end, COMDAT
; _this$ = ecx

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00009	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::end
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHK@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::operator->
; Function compile flags: /Ogty
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHK@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHK@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QBEPAU?$pair@$$CBHK@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1510 : 		if (!_Built)

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Built$[esp-4]
  00004	84 c0		 test	 al, al
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Newsize$[esp+4]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	74 2f		 je	 SHORT $L286198

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00010	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00014	72 29		 jb	 SHORT $L286198

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;
; 1515 : 			if (0 < _Newsize)

  00016	85 ed		 test	 ebp, ebp
  00018	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001b	57		 push	 edi
  0001c	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  0001f	76 14		 jbe	 SHORT $L286195
  00021	56		 push	 esi

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  00022	8b cd		 mov	 ecx, ebp
  00024	8b d1		 mov	 edx, ecx
  00026	c1 e9 02	 shr	 ecx, 2
  00029	8b f0		 mov	 esi, eax
  0002b	f3 a5		 rep movsd
  0002d	8b ca		 mov	 ecx, edx
  0002f	83 e1 03	 and	 ecx, 3
  00032	f3 a4		 rep movsb
  00034	5e		 pop	 esi
$L286195:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
  0003e	5f		 pop	 edi
$L286198:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;
; 1520 : 		_Eos(_Newsize);

  0003f	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00042	c7 43 18 0f 00
	00 00		 mov	 DWORD PTR [ebx+24], 15	; 0000000fH
  00049	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0004e	5d		 pop	 ebp
  0004f	5b		 pop	 ebx

; 1521 : 		}

  00050	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::lower_bound
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8a 50 15	 mov	 dl, BYTE PTR [eax+21]
  00009	84 d2		 test	 dl, dl
  0000b	75 1d		 jne	 SHORT $L286294
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
  00013	53		 push	 ebx
$L286262:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	7d 05		 jge	 SHORT $L286264
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $L286265
$L286264:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$L286265:
  00022	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00025	84 db		 test	 bl, bl
  00027	74 eb		 je	 SHORT $L286262
  00029	5b		 pop	 ebx
$L286294:
  0002a	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 811  : 		}

  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ; std::vector<long,std::allocator<long> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<long,std::allocator<long> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<long,std::allocator<long> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ; std::vector<long,std::allocator<long> >::end
; Function compile flags: /Ogty
;	COMDAT ?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<long,std::allocator<long> >::end, COMDAT
; _this$ = ecx

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<long,std::allocator<long> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::vector<long,std::allocator<long> >::erase
; Function compile flags: /Ogty
;	COMDAT ?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::vector<long,std::allocator<long> >::erase, COMDAT
; _this$ = ecx

; 731  : 		{	// erase [_First, _Last)

  00000	53		 push	 ebx
  00001	57		 push	 edi

; 732  : 		if (_First != _Last)

  00002	8b 7c 24 10	 mov	 edi, DWORD PTR __First$[esp+4]
  00006	8b d9		 mov	 ebx, ecx
  00008	8b 4c 24 14	 mov	 ecx, DWORD PTR __Last$[esp+4]
  0000c	3b f9		 cmp	 edi, ecx
  0000e	74 21		 je	 SHORT $L286352

; 733  : 			{	// worth doing, copy down over hole
; 734  : 			pointer _Ptr = copy(_ITER_BASE(_Last), _Mylast,
; 735  : 				_ITER_BASE(_First));

  00010	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00013	2b c1		 sub	 eax, ecx
  00015	56		 push	 esi
  00016	c1 f8 02	 sar	 eax, 2
  00019	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00020	56		 push	 esi
  00021	51		 push	 ecx
  00022	57		 push	 edi
  00023	e8 00 00 00 00	 call	 _memmove
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	03 c6		 add	 eax, esi

; 736  : 			_Destroy(_Ptr, _Mylast);
; 737  : 			_Mylast = _Ptr;

  0002d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00030	5e		 pop	 esi
$L286352:

; 738  : 			}
; 739  : 		return (_First);

  00031	8b 44 24 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+4]
  00035	89 38		 mov	 DWORD PTR [eax], edi
  00037	5f		 pop	 edi
  00038	5b		 pop	 ebx

; 740  : 		}

  00039	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@JV?$allocator@J@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::vector<long,std::allocator<long> >::erase
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin, COMDAT
; _this$ = ecx

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  0000b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp

; 793  : 		if (_Mysize < _Off)

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Off$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	39 6e 14	 cmp	 DWORD PTR [esi+20], ebp
  0000b	57		 push	 edi
  0000c	73 05		 jae	 SHORT $L221371

; 794  : 			_String_base::_Xran();	// _Off off end

  0000e	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L221371:

; 795  : 		if (_Mysize - _Off < _Count)

  00013	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  0001a	2b c5		 sub	 eax, ebp
  0001c	3b c7		 cmp	 eax, edi
  0001e	73 02		 jae	 SHORT $L221372

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  00020	8b f8		 mov	 edi, eax
$L221372:

; 797  : 		if (0 < _Count)

  00022	85 ff		 test	 edi, edi
  00024	76 47		 jbe	 SHORT $L286416

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  00026	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00029	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002c	53		 push	 ebx
  0002d	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00030	72 04		 jb	 SHORT $L286382
  00032	8b 13		 mov	 edx, DWORD PTR [ebx]
  00034	eb 02		 jmp	 SHORT $L286383
$L286382:
  00036	8b d3		 mov	 edx, ebx
$L286383:
  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	72 04		 jb	 SHORT $L286389
  0003d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0003f	eb 02		 jmp	 SHORT $L286390
$L286389:
  00041	8b cb		 mov	 ecx, ebx
$L286390:
  00043	2b c7		 sub	 eax, edi

; 803  : 			}
; 804  : 		return (*this);

  00045	03 d5		 add	 edx, ebp
  00047	50		 push	 eax
  00048	03 d7		 add	 edx, edi
  0004a	52		 push	 edx
  0004b	03 cd		 add	 ecx, ebp
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _memmove
  00053	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00056	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00059	2b c7		 sub	 eax, edi
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00061	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00064	72 02		 jb	 SHORT $L286413

; 801  : 			size_type _Newsize = _Mysize - _Count;
; 802  : 			_Eos(_Newsize);

  00066	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$L286413:
  00068	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  0006c	5b		 pop	 ebx
$L286416:
  0006d	5f		 pop	 edi

; 803  : 			}
; 804  : 		return (*this);

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp

; 805  : 		}

  00072	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ; std::vector<long,std::allocator<long> >::_Ufill
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	56		 push	 esi

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR __Count$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b 7c 24 0c	 mov	 edi, DWORD PTR __Ptr$[esp+4]
  0000c	8b c7		 mov	 eax, edi
  0000e	76 12		 jbe	 SHORT $L286457
  00010	8b 54 24 14	 mov	 edx, DWORD PTR __Val$[esp+4]
  00014	8b ce		 mov	 ecx, esi
  00016	53		 push	 ebx
$L286451:
  00017	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00019	89 18		 mov	 DWORD PTR [eax], ebx
  0001b	83 c0 04	 add	 eax, 4
  0001e	49		 dec	 ecx
  0001f	75 f6		 jne	 SHORT $L286451
  00021	5b		 pop	 ebx
$L286457:

; 879  : 		return (_Ptr + _Count);

  00022	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 880  : 		}

  00027	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ENDP ; std::vector<long,std::allocator<long> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	__CxxThrowException@8:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T286665 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T286667 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L286465
$T286668 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L286463
$T286666 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T286667
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T286668
$T286659 DD	019930520H
	DD	04H
	DD	FLAT:$T286665
	DD	02H
	DD	FLAT:$T286666
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	8b d8		 mov	 ebx, eax
  00022	83 cb 0f	 or	 ebx, 15			; 0000000fH

; 1446 : 		if (max_size() < _Newres)

  00025	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00028	57		 push	 edi
  00029	8b f1		 mov	 esi, ecx
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00031	76 04		 jbe	 SHORT $L222778

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  00033	8b d8		 mov	 ebx, eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00035	eb 22		 jmp	 SHORT $L222780
$L222778:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00037	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  0003a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0003f	f7 e3		 mul	 ebx
  00041	8b cf		 mov	 ecx, edi
  00043	d1 e9		 shr	 ecx, 1
  00045	d1 ea		 shr	 edx, 1
  00047	3b d1		 cmp	 edx, ecx
  00049	73 0e		 jae	 SHORT $L222780
  0004b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00050	2b c1		 sub	 eax, ecx
  00052	3b f8		 cmp	 edi, eax
  00054	77 03		 ja	 SHORT $L222780

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00056	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]
$L222780:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN
; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00059	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0005c	51		 push	 ecx
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00064	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00069	8b d0		 mov	 edx, eax
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
  00071	eb 29		 jmp	 SHORT $L222782
$L286463:

; 1455 : 		_CATCH_ALL
; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN
; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  00079	40		 inc	 eax
  0007a	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0007d	50		 push	 eax
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00082	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00087	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0008a	83 c4 04	 add	 esp, 4

; 1462 : 			_CATCH_END
; 1463 : 		_CATCH_END

  0008d	b8 00 00 00 00	 mov	 eax, $L286660
  00092	c3		 ret	 0
$L286660:
  00093	8b 5d e8	 mov	 ebx, DWORD PTR __Newres$[ebp]
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$L222782:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  0009f	85 c9		 test	 ecx, ecx
  000a1	76 24		 jbe	 SHORT $L286582

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000a3	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000a7	72 05		 jb	 SHORT $L286579
  000a9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000ac	eb 03		 jmp	 SHORT $L286580
$L286579:
  000ae	83 c6 04	 add	 esi, 4
$L286580:
  000b1	8b c1		 mov	 eax, ecx
  000b3	c1 e9 02	 shr	 ecx, 2
  000b6	8b fa		 mov	 edi, edx
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb
  000c1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
$L286582:

; 1467 : 		_Tidy(true);

  000c7	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  000cb	72 12		 jb	 SHORT $L286618
  000cd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  000dc	83 c4 04	 add	 esp, 4
$L286618:

; 1468 : 		_Bx._Ptr = _Ptr;
; 1469 : 		_Myres = _Newres;
; 1470 : 		_Eos(_Oldlen);

  000df	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000e2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000e5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e8	89 10		 mov	 DWORD PTR [eax], edx
  000ea	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000ed	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000f0	72 02		 jb	 SHORT $L286653
  000f2	8b c2		 mov	 eax, edx
$L286653:

; 1471 : 		}

  000f4	5f		 pop	 edi
  000f5	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fc	5e		 pop	 esi
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 08 00	 ret	 8
$L286465:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  0010b	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0010e	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00112	72 0c		 jb	 SHORT $L286557
  00114	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011d	83 c4 04	 add	 esp, 4
$L286557:

; 1461 : 			_RERAISE;

  00120	6a 00		 push	 0
  00122	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00129	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00130	6a 00		 push	 0
  00132	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$L286670:
$L286664:
  0013b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T286659
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?UpdateParam@CMover@@QAEXXZ			; CMover::UpdateParam
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
;	COMDAT ?UpdateParam@CMover@@QAEXXZ
_TEXT	SEGMENT
?UpdateParam@CMover@@QAEXXZ PROC NEAR			; CMover::UpdateParam, COMDAT
; _this$ = ecx

; 565  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 566  : 	if( IsPlayer() ) 

  00003	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00009	85 c0		 test	 eax, eax
  0000b	74 2c		 je	 SHORT $L275324

; 567  : 	{
; 568  : 		SumEquipDefenseAbility( &m_nDefenseMin, &m_nDefenseMax ); 

  0000d	8d 86 14 06 00
	00		 lea	 eax, DWORD PTR [esi+1556]
  00013	50		 push	 eax
  00014	8d 8e 10 06 00
	00		 lea	 ecx, DWORD PTR [esi+1552]
  0001a	51		 push	 ecx
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?SumEquipDefenseAbility@CMover@@QAEHPAJ0@Z ; CMover::SumEquipDefenseAbility

; 569  : 		SumEquipAdjValue( &m_nAdjHitRate, &m_nAdjParry );

  00022	8d 96 1c 06 00
	00		 lea	 edx, DWORD PTR [esi+1564]
  00028	52		 push	 edx
  00029	8d 86 18 06 00
	00		 lea	 eax, DWORD PTR [esi+1560]
  0002f	50		 push	 eax
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?SumEquipAdjValue@CMover@@QAEXPAH0@Z ; CMover::SumEquipAdjValue
  00037	5e		 pop	 esi

; 576  : 	}
; 577  : }

  00038	c3		 ret	 0
$L275324:

; 570  : 	}
; 571  : 	else
; 572  : 	{
; 573  : 		m_nDefenseMin = m_nDefenseMax = GetNaturalArmor();

  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?GetNaturalArmor@CMover@@QAEHXZ ; CMover::GetNaturalArmor
  00040	89 86 14 06 00
	00		 mov	 DWORD PTR [esi+1556], eax
  00046	89 86 10 06 00
	00		 mov	 DWORD PTR [esi+1552], eax

; 574  : 		m_nAdjHitRate = 0;

  0004c	c7 86 18 06 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1560], 0

; 575  : 		m_nAdjParry = 0;

  00056	c7 86 1c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1564], 0
  00060	5e		 pop	 esi

; 576  : 	}
; 577  : }

  00061	c3		 ret	 0
?UpdateParam@CMover@@QAEXXZ ENDP			; CMover::UpdateParam
_TEXT	ENDS
PUBLIC	?SetHitPoint@CMover@@QAEXH@Z			; CMover::SetHitPoint
; Function compile flags: /Ogty
;	COMDAT ?SetHitPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nVal$ = 8						; size = 4
?SetHitPoint@CMover@@QAEXH@Z PROC NEAR			; CMover::SetHitPoint, COMDAT
; _this$ = ecx

; 900  : 	m_nHitPoint = nVal;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nVal$[esp-4]

; 901  : //	m_nHitPoint += nVal;
; 902  : 	if( m_nHitPoint < 0 )

  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 86 00 06 00
	00		 mov	 DWORD PTR [esi+1536], eax
  0000f	7d 0a		 jge	 SHORT $L275437

; 903  : 		m_nHitPoint = 0;

  00011	c7 86 00 06 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1536], 0
$L275437:

; 904  : 	if( m_nHitPoint > GetMaxHitPoint() )

  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  00022	39 86 00 06 00
	00		 cmp	 DWORD PTR [esi+1536], eax
  00028	7e 0d		 jle	 SHORT $L275438

; 905  : 		m_nHitPoint = GetMaxHitPoint(); 

  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  00031	89 86 00 06 00
	00		 mov	 DWORD PTR [esi+1536], eax
$L275438:
  00037	5e		 pop	 esi

; 906  : }

  00038	c2 04 00	 ret	 4
?SetHitPoint@CMover@@QAEXH@Z ENDP			; CMover::SetHitPoint
_TEXT	ENDS
PUBLIC	?SetManaPoint@CMover@@QAEXH@Z			; CMover::SetManaPoint
; Function compile flags: /Ogty
;	COMDAT ?SetManaPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nVal$ = 8						; size = 4
?SetManaPoint@CMover@@QAEXH@Z PROC NEAR			; CMover::SetManaPoint, COMDAT
; _this$ = ecx

; 910  : 	m_nManaPoint = nVal;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nVal$[esp-4]

; 911  : 	if( m_nManaPoint < 0 )

  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 86 04 06 00
	00		 mov	 DWORD PTR [esi+1540], eax
  0000f	7d 0a		 jge	 SHORT $L275443

; 912  : 		m_nManaPoint = 0;

  00011	c7 86 04 06 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1540], 0
$L275443:

; 913  : 	if( m_nManaPoint > GetMaxManaPoint() )

  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  00022	39 86 04 06 00
	00		 cmp	 DWORD PTR [esi+1540], eax
  00028	7e 0d		 jle	 SHORT $L275444

; 914  : 		m_nManaPoint = GetMaxManaPoint(); 

  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  00031	89 86 04 06 00
	00		 mov	 DWORD PTR [esi+1540], eax
$L275444:
  00037	5e		 pop	 esi

; 915  : }

  00038	c2 04 00	 ret	 4
?SetManaPoint@CMover@@QAEXH@Z ENDP			; CMover::SetManaPoint
_TEXT	ENDS
PUBLIC	?SetFatiguePoint@CMover@@QAEXH@Z		; CMover::SetFatiguePoint
; Function compile flags: /Ogty
;	COMDAT ?SetFatiguePoint@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nVal$ = 8						; size = 4
?SetFatiguePoint@CMover@@QAEXH@Z PROC NEAR		; CMover::SetFatiguePoint, COMDAT
; _this$ = ecx

; 919  : 	m_nFatiguePoint = nVal;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nVal$[esp-4]

; 920  : 	if( m_nFatiguePoint < 0 )

  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 86 08 06 00
	00		 mov	 DWORD PTR [esi+1544], eax
  0000f	7d 0a		 jge	 SHORT $L275449

; 921  : 		m_nFatiguePoint = 0;

  00011	c7 86 08 06 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1544], 0
$L275449:

; 922  : 	if( m_nFatiguePoint > GetMaxFatiguePoint() )

  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  00022	39 86 08 06 00
	00		 cmp	 DWORD PTR [esi+1544], eax
  00028	7e 0d		 jle	 SHORT $L275450

; 923  : 		m_nFatiguePoint = GetMaxFatiguePoint(); 

  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  00031	89 86 08 06 00
	00		 mov	 DWORD PTR [esi+1544], eax
$L275450:
  00037	5e		 pop	 esi

; 924  : }

  00038	c2 04 00	 ret	 4
?SetFatiguePoint@CMover@@QAEXH@Z ENDP			; CMover::SetFatiguePoint
_TEXT	ENDS
PUBLIC	??_C@_0DI@OAFIFIPO@SetPointParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUse@ ; `string'
PUBLIC	?SetPointParam@CMover@@QAEXHHH@Z		; CMover::SetPointParam
EXTRN	?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z:NEAR ; CUserMng::AddSetPointParam
;	COMDAT ??_C@_0DI@OAFIFIPO@SetPointParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUse@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_0DI@OAFIFIPO@SetPointParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUse@ DB 'Se'
	DB	'tPointParam( DST_GOLD ) - [User:%s(%07d)], [Value:%d]', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	ENDS
;	COMDAT ?SetPointParam@CMover@@QAEXHHH@Z
_TEXT	SEGMENT
_nDstParameter$ = 8					; size = 4
_nValue$ = 12						; size = 4
_bTrans$ = 16						; size = 4
?SetPointParam@CMover@@QAEXHHH@Z PROC NEAR		; CMover::SetPointParam, COMDAT
; _this$ = ecx

; 939  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 940  : #ifdef __WORLDSERVER
; 941  : 	int nMax = nValue;

  00003	8b 74 24 14	 mov	 esi, DWORD PTR _nValue$[esp+8]

; 942  : #endif // __WORLDSERVER
; 943  : 	if( nValue < 0 )	nValue	= 0;

  00007	85 f6		 test	 esi, esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8b de		 mov	 ebx, esi
  0000e	7d 02		 jge	 SHORT $L275470
  00010	33 f6		 xor	 esi, esi
$L275470:

; 944  : 	BOOL	bTransfer	= bTrans;
; 945  : 
; 946  : 	switch( nDstParameter )

  00012	8b 6c 24 14	 mov	 ebp, DWORD PTR _nDstParameter$[esp+12]
  00016	83 fd 28	 cmp	 ebp, 40			; 00000028H
  00019	0f 8f d2 00 00
	00		 jg	 $L286691
  0001f	0f 84 8e 00 00
	00		 je	 $L275484
  00025	8b c5		 mov	 eax, ebp
  00027	83 e8 26	 sub	 eax, 38			; 00000026H
  0002a	74 49		 je	 SHORT $L275476
  0002c	48		 dec	 eax
  0002d	0f 85 c6 00 00
	00		 jne	 $L286696

; 955  : 			{
; 956  : 				bTransfer	= TRUE;
; 957  : 				m_nHitPoint		= nValue;
; 958  : 			}
; 959  : 			break;
; 960  : 		case DST_MP:
; 961  : #ifdef __WORLDSERVER
; 962  : 			if( nValue > GetMaxManaPoint() || nMax == 999999999 )	nValue	= GetMaxManaPoint();

  00033	8b cf		 mov	 ecx, edi
  00035	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  0003a	3b f0		 cmp	 esi, eax
  0003c	7f 08		 jg	 SHORT $L275482
  0003e	81 fb ff c9 9a
	3b		 cmp	 ebx, 999999999		; 3b9ac9ffH
  00044	75 09		 jne	 SHORT $L275481
$L275482:
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  0004d	8b f0		 mov	 esi, eax
$L275481:

; 963  : #else // __WORLDSERVER
; 964  : 			if( nValue > GetMaxManaPoint() )	nValue	= GetMaxManaPoint();
; 965  : #endif // __WORLDSERVER
; 966  : 			if( m_nManaPoint != nValue )

  0004f	39 b7 04 06 00
	00		 cmp	 DWORD PTR [edi+1540], esi
  00055	0f 84 9e 00 00
	00		 je	 $L286696

; 1003 : 		g_UserMng.AddSetPointParam( this, nDstParameter, nValue );

  0005b	56		 push	 esi
  0005c	55		 push	 ebp
  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00063	89 b7 04 06 00
	00		 mov	 DWORD PTR [edi+1540], esi
  00069	e8 00 00 00 00	 call	 ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddSetPointParam
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5d		 pop	 ebp
  00071	5b		 pop	 ebx

; 1004 : #endif	// __WORLDSERVER
; 1005 : }

  00072	c2 0c 00	 ret	 12			; 0000000cH
$L275476:

; 947  : 	{
; 948  : 		case DST_HP:
; 949  : #ifdef __WORLDSERVER
; 950  : 			if( nValue > GetMaxHitPoint() || nMax == 999999999 )	nValue	= GetMaxHitPoint();

  00075	8b cf		 mov	 ecx, edi
  00077	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  0007c	3b f0		 cmp	 esi, eax
  0007e	7f 08		 jg	 SHORT $L275478
  00080	81 fb ff c9 9a
	3b		 cmp	 ebx, 999999999		; 3b9ac9ffH
  00086	75 09		 jne	 SHORT $L275477
$L275478:
  00088	8b cf		 mov	 ecx, edi
  0008a	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  0008f	8b f0		 mov	 esi, eax
$L275477:

; 951  : #else // __WORLDSERVER
; 952  : 			if( nValue > GetMaxHitPoint() )	nValue	= GetMaxHitPoint();
; 953  : #endif // __WORLDSERVER
; 954  : 			if( m_nHitPoint != nValue )

  00091	39 b7 00 06 00
	00		 cmp	 DWORD PTR [edi+1536], esi
  00097	74 60		 je	 SHORT $L286696

; 1003 : 		g_UserMng.AddSetPointParam( this, nDstParameter, nValue );

  00099	56		 push	 esi
  0009a	55		 push	 ebp
  0009b	57		 push	 edi
  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000a1	89 b7 00 06 00
	00		 mov	 DWORD PTR [edi+1536], esi
  000a7	e8 00 00 00 00	 call	 ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddSetPointParam
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5d		 pop	 ebp
  000af	5b		 pop	 ebx

; 1004 : #endif	// __WORLDSERVER
; 1005 : }

  000b0	c2 0c 00	 ret	 12			; 0000000cH
$L275484:

; 967  : 			{
; 968  : 				bTransfer	= TRUE;
; 969  : 				m_nManaPoint	= nValue;
; 970  : 			}
; 971  : 			break;
; 972  : 		case DST_FP:
; 973  : #ifdef __WORLDSERVER
; 974  : 			if( nValue > GetMaxFatiguePoint() || nMax == 999999999 )	nValue	= GetMaxFatiguePoint();

  000b3	8b cf		 mov	 ecx, edi
  000b5	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  000ba	3b f0		 cmp	 esi, eax
  000bc	7f 08		 jg	 SHORT $L275486
  000be	81 fb ff c9 9a
	3b		 cmp	 ebx, 999999999		; 3b9ac9ffH
  000c4	75 09		 jne	 SHORT $L275485
$L275486:
  000c6	8b cf		 mov	 ecx, edi
  000c8	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  000cd	8b f0		 mov	 esi, eax
$L275485:

; 975  : #else // __WORLDSERVER
; 976  : 			if( nValue > GetMaxFatiguePoint() )		nValue	= GetMaxFatiguePoint();
; 977  : #endif // __WORLDSERVER
; 978  : 			if( m_nFatiguePoint != nValue )

  000cf	39 b7 08 06 00
	00		 cmp	 DWORD PTR [edi+1544], esi
  000d5	74 22		 je	 SHORT $L286696

; 1003 : 		g_UserMng.AddSetPointParam( this, nDstParameter, nValue );

  000d7	56		 push	 esi
  000d8	55		 push	 ebp
  000d9	57		 push	 edi
  000da	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000df	89 b7 08 06 00
	00		 mov	 DWORD PTR [edi+1544], esi
  000e5	e8 00 00 00 00	 call	 ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddSetPointParam
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5d		 pop	 ebp
  000ed	5b		 pop	 ebx

; 1004 : #endif	// __WORLDSERVER
; 1005 : }

  000ee	c2 0c 00	 ret	 12			; 0000000cH
$L286691:

; 944  : 	BOOL	bTransfer	= bTrans;
; 945  : 
; 946  : 	switch( nDstParameter )

  000f1	81 fd 10 27 00
	00		 cmp	 ebp, 10000		; 00002710H
  000f7	74 1c		 je	 SHORT $L275488
$L286696:

; 989  : 			return;
; 990  : #endif // __WORLDSERVE
; 991  : #endif // __PERIN_BUY_BUG
; 992  : 
; 993  : 	#ifdef __CLIENT
; 994  : 			if( IsActiveMover() )
; 995  : 				PLAYSND(SND_INF_TRADE);
; 996  : 	#endif //__CLIENT
; 997  : 			bTransfer	= TRUE;
; 998  : 			SetGold( nValue );
; 999  : 			break;
; 1000 : 	}
; 1001 : #ifdef __WORLDSERVER
; 1002 : 	if( bTransfer )

  000f9	8b 44 24 1c	 mov	 eax, DWORD PTR _bTrans$[esp+12]
  000fd	85 c0		 test	 eax, eax
  000ff	74 33		 je	 SHORT $L275468

; 1003 : 		g_UserMng.AddSetPointParam( this, nDstParameter, nValue );

  00101	56		 push	 esi
  00102	55		 push	 ebp
  00103	57		 push	 edi
  00104	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00109	e8 00 00 00 00	 call	 ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddSetPointParam
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5d		 pop	 ebp
  00111	5b		 pop	 ebx

; 1004 : #endif	// __WORLDSERVER
; 1005 : }

  00112	c2 0c 00	 ret	 12			; 0000000cH
$L275488:

; 979  : 			{
; 980  : 				bTransfer	= TRUE;
; 981  : 				m_nFatiguePoint		= nValue;
; 982  : 			}
; 983  : 			break;
; 984  : 		case DST_GOLD:
; 985  : 			//m_dwGold	= (DWORD)nValue;
; 986  : #ifdef __PERIN_BUY_BUG	// chipi_091219 
; 987  : #ifdef __WORLDSERVER
; 988  : 			Error( "SetPointParam( DST_GOLD ) - [User:%s(%07d)], [Value:%d]", static_cast<CUser*>(this)->GetName(), static_cast<CUser*>(this)->m_idPlayer, nValue );

  00115	8b 87 38 02 00
	00		 mov	 eax, DWORD PTR [edi+568]
  0011b	56		 push	 esi
  0011c	50		 push	 eax
  0011d	6a 00		 push	 0
  0011f	8b cf		 mov	 ecx, edi
  00121	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00126	50		 push	 eax
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@OAFIFIPO@SetPointParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUse@
  0012c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00131	83 c4 10	 add	 esp, 16			; 00000010H
$L275468:
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5d		 pop	 ebp
  00137	5b		 pop	 ebx

; 1004 : #endif	// __WORLDSERVER
; 1005 : }

  00138	c2 0c 00	 ret	 12			; 0000000cH
?SetPointParam@CMover@@QAEXHHH@Z ENDP			; CMover::SetPointParam
_TEXT	ENDS
PUBLIC	?SetExperience@CMover@@QAEH_JH@Z		; CMover::SetExperience
EXTRN	?SetJobLevel@CMover@@QAEXHH@Z:NEAR		; CMover::SetJobLevel
; Function compile flags: /Ogty
;	COMDAT ?SetExperience@CMover@@QAEH_JH@Z
_TEXT	SEGMENT
_nExp1$ = 8						; size = 8
_nLevel$ = 16						; size = 4
?SetExperience@CMover@@QAEH_JH@Z PROC NEAR		; CMover::SetExperience, COMDAT
; _this$ = ecx

; 1837 : 	m_nExp1		= nExp1;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nExp1$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nExp1$[esp+4]
  0000b	89 86 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], eax

; 1838 : 
; 1839 : 	if( IsInvalidObj(this) )

  00011	f6 46 04 01	 test	 BYTE PTR [esi+4], 1
  00015	89 8e ec 05 00
	00		 mov	 DWORD PTR [esi+1516], ecx

; 1840 : 		return 0;

  0001b	75 5b		 jne	 SHORT $L286723

; 1841 : 
; 1842 : #ifdef __FASTJOBCHANGE
; 1843 : #ifdef __CLIENT
; 1844 : 	if( (GetLevel() == MAX_GENERAL_LEVEL /*|| GetLevel() == MAX_LEGEND_LEVEL*/) && GetExpPercent() == 9999 )
; 1845 : 	{
; 1846 : 		SAFE_DELETE( g_WndMng.m_pJobChangeEx );
; 1847 : 		g_WndMng.m_pJobChangeEx = new CWndJobChangeEx;
; 1848 : 		g_WndMng.m_pJobChangeEx->Initialize();
; 1849 : 	}
; 1850 : #endif
; 1851 : #endif//__FASTJOBCHANGE
; 1852 : 
; 1853 : 	if( nLevel > m_nLevel )

  0001d	8b 8e e0 05 00
	00		 mov	 ecx, DWORD PTR [esi+1504]
  00023	8b 44 24 10	 mov	 eax, DWORD PTR _nLevel$[esp]
  00027	3b c1		 cmp	 eax, ecx
  00029	7e 45		 jle	 SHORT $L286725

; 1854 : 	{
; 1855 : #ifdef __CLIENT
; 1856 :  		// 15       .
; 1857 : 		if( nLevel == 15 )		// 1 15  define   . -xuzhu-
; 1858 : 			g_Option.m_nInstantHelp = 0;
; 1859 :  		
; 1860 : 		PutLvUpSkillName_1(nLevel);
; 1861 : 
; 1862 : 		if( m_pActMover && ( m_pActMover->IsState( OBJSTA_STAND ) || m_pActMover->IsState( OBJSTA_STAND2 ) ) )
; 1863 : 			SetMotion( MTI_LEVELUP, ANILOOP_1PLAY, MOP_FIXED );
; 1864 : 		CreateSfx(g_Neuz.m_pd3dDevice,XI_GEN_LEVEL_UP01,GetPos(),GetId());
; 1865 : 		PlayMusic( BGM_IN_LEVELUP );
; 1866 : 		if( m_nDeathLevel < nLevel )
; 1867 : 			g_WndMng.PutString( prj.GetText( TID_GAME_LEVELUP ), NULL, prj.GetTextColor( TID_GAME_LEVELUP ) );
; 1868 : 		
; 1869 : 		if( g_WndMng.m_pWndWorld )
; 1870 : 		{
; 1871 : 			if( ::GetLanguage() != LANG_JAP )
; 1872 : 				g_Caption1.AddCaption(  prj.GetText( TID_GAME_LEVELUP_CAPTION ), g_WndMng.m_pWndWorld->m_pFontAPICaption );// CWndBase::m_Theme.m_pFontCaption );
; 1873 : 			else
; 1874 : 				g_Caption1.AddCaption(  prj.GetText( TID_GAME_LEVELUP_CAPTION ), NULL );// CWndBase::m_Theme.m_pFontCaption );
; 1875 : 		}
; 1876 : 		
; 1877 : 		// 2, 8, 12
; 1878 : 		static	int nPatLv[4]	= { 2, 8, 12, 0	};
; 1879 : 		for( int i = 0; i < 3; i++ ) {
; 1880 : 			if( m_nLevel < nPatLv[i] && nLevel >= nPatLv[i] ) {
; 1881 : 				g_WndMng.PutString( prj.GetText( TID_GAME_PATTERNUP ), NULL, prj.GetTextColor( TID_GAME_PATTERNUP ) );
; 1882 : 				break;
; 1883 : 			}
; 1884 : 			else if( m_nLevel >= nPatLv[2] )
; 1885 : 				break;
; 1886 : 		}
; 1887 : 
; 1888 : 		if( TRUE == IsJobType( JTYPE_BASE ) )
; 1889 : 		{
; 1890 : 			if( nLevel == 15 )
; 1891 : 				g_WndMng.PutString( prj.GetText( TID_EVE_LEVEL15 ), NULL, prj.GetTextColor( TID_EVE_LEVEL15 ) );
; 1892 : 
; 1893 : 			static	int nNum	= prj.m_aJobSkillNum[JOB_VAGRANT];
; 1894 : 		}
; 1895 : 		if( m_nLevel < 20 && nLevel >= 20 )
; 1896 : 		{
; 1897 : 			g_WndMng.PutString( prj.GetText( TID_GAME_FLYLVLUP ), NULL, prj.GetTextColor( TID_GAME_FLYLVLUP ) );
; 1898 : 			SetFlightLv( 1 );
; 1899 : 		}
; 1900 : 		else if( nLevel < 20 )
; 1901 : 			SetFlightLv( 0 );
; 1902 : #endif	// __CLIENT
; 1903 : 		m_nLevel	= nLevel;
; 1904 : 
; 1905 : 		SetJobLevel( m_nLevel, m_nJob );

  0002b	8b 96 44 06 00
	00		 mov	 edx, DWORD PTR [esi+1604]
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	8b ce		 mov	 ecx, esi
  00035	89 86 e0 05 00
	00		 mov	 DWORD PTR [esi+1504], eax
  0003b	e8 00 00 00 00	 call	 ?SetJobLevel@CMover@@QAEXHH@Z ; CMover::SetJobLevel

; 1906 : 
; 1907 : 		m_nHitPoint = GetMaxHitPoint();

  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint

; 1908 : 		m_nManaPoint = GetMaxManaPoint();

  00047	8b ce		 mov	 ecx, esi
  00049	89 86 00 06 00
	00		 mov	 DWORD PTR [esi+1536], eax
  0004f	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint

; 1909 : 		m_nFatiguePoint = GetMaxFatiguePoint();

  00054	8b ce		 mov	 ecx, esi
  00056	89 86 04 06 00
	00		 mov	 DWORD PTR [esi+1540], eax
  0005c	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  00061	89 86 08 06 00
	00		 mov	 DWORD PTR [esi+1544], eax

; 1910 : 
; 1911 : #ifdef __CLIENT
; 1912 : 		if( IsPlayer() )
; 1913 : 		{
; 1914 : 			CWndWorld* pWndWorld = (CWndWorld*)g_WndMng.GetWndBase( APP_WORLD );
; 1915 : 			
; 1916 : 			if( pWndWorld ) 
; 1917 : 			{
; 1918 : #if __VER >= 13 // __RENEW_CHARINFO
; 1919 : 				pWndWorld->GetAdvMgr()->AddAdvButton(APP_CHARACTER3);
; 1920 : #elif __VER >= 9 // __CSC_VER9_2
; 1921 : 				pWndWorld->GetAdvMgr()->AddAdvButton(APP_CHARACTER2);
; 1922 : #else //__CSC_VER9_2
; 1923 : 				pWndWorld->GetAdvMgr()->AddAdvButton(APP_CHARACTER);
; 1924 : #endif //__CSC_VER9_2
; 1925 : 			#if __VER < 12 // __MOD_TUTORIAL				
; 1926 : 				if( GetLevel() != 1 )
; 1927 : 					pWndWorld->m_pWndGuideSystem->GuideStart(FALSE);
; 1928 : 			#endif
; 1929 : 
; 1930 : #ifdef __FASTJOBCHANGE
; 1931 : if( GetLevel() == MAX_JOB_LEVEL || GetLevel() == (MAX_JOB_LEVEL+MAX_EXP_LEVEL) || GetLevel() == MAX_LEGEND_LEVEL )
; 1932 : {
; 1933 : 	SAFE_DELETE( g_WndMng.m_pJobChangeEx );
; 1934 : 	g_WndMng.m_pJobChangeEx = new CWndJobChangeEx;
; 1935 : 	g_WndMng.m_pJobChangeEx->Initialize();
; 1936 : }
; 1937 : #endif//__FASTJOBCHANGE
; 1938 : 
; 1939 : 				switch(GetLevel())
; 1940 : 				{
; 1941 : 			#if __VER >= 12 // __MOD_TUTORIAL
; 1942 : 				case 15:
; 1943 : 					pWndWorld->m_pWndGuideSystem->GuideStart(GUIDE_CHANGEJOB);
; 1944 : 					break;						
; 1945 : 				case 20:
; 1946 : 					pWndWorld->m_pWndGuideSystem->GuideStart(GUIDE_FLIGHT_METHOD);
; 1947 : 					break;
; 1948 : 				case 40:
; 1949 : 					pWndWorld->m_pWndGuideSystem->GuideStart(GUIDE_APP_GUILD);
; 1950 : 					break;
; 1951 : 			#else
; 1952 : 				case 2:
; 1953 : #if __VER >= 13 // __RENEW_CHARINFO
; 1954 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_CHARACTER3);
; 1955 : #else if __VER >= 9 // __CSC_VER9_2
; 1956 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_CHARACTER2);
; 1957 : #else //__CSC_VER9_2
; 1958 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_CHARACTER);
; 1959 : #endif //__CSC_VER9_2
; 1960 : 					break;
; 1961 : 				case 3:
; 1962 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_EVENT_BERSERKERMODE);
; 1963 : 					break;
; 1964 : 				case 4:
; 1965 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_SKILL_BEFOREJOB);
; 1966 : 					break;
; 1967 : 				case 8:
; 1968 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_ESSENSE);
; 1969 : 					break;
; 1970 : 				case 16:
; 1971 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_FLIGHT);
; 1972 : 					break;
; 1973 : 				case 15:
; 1974 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_CHANGEJOB);
; 1975 : 					break;						
; 1976 : 				case 20:
; 1977 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_FLIGHT_METHOD);
; 1978 : 					break;
; 1979 : 				case 49:
; 1980 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_APP_GUILD);
; 1981 : 					break;
; 1982 : 			#endif
; 1983 : 				}
; 1984 : 			}
; 1985 : 		}
; 1986 : #endif //__CLIENT		
; 1987 : 
; 1988 : 		return TRUE;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	5e		 pop	 esi

; 2047 : }

  0006d	c2 0c 00	 ret	 12			; 0000000cH
$L286725:

; 1989 : 	}
; 1990 : 	else if( nLevel < m_nLevel )	//   .

  00070	7d 06		 jge	 SHORT $L286723

; 1991 : 	{
; 1992 : 		m_nLevel	= nLevel;

  00072	89 86 e0 05 00
	00		 mov	 DWORD PTR [esi+1504], eax

; 1993 : 		if( nLevel < 20 )
; 1994 : 			SetFlightLv( 0 );

$L286723:

; 1995 : 
; 1996 : #ifdef __CLIENT
; 1997 : 		if( IsPlayer() )
; 1998 : 		{
; 1999 : 			CWndWorld* pWndWorld = (CWndWorld*)g_WndMng.GetWndBase( APP_WORLD );
; 2000 : 			
; 2001 : 			if( pWndWorld ) 
; 2002 : 			{
; 2003 : 			#if __VER < 12 // __MOD_TUTORIAL
; 2004 : 				if( GetLevel() != 1 )
; 2005 : 					pWndWorld->m_pWndGuideSystem->GuideStart(FALSE);
; 2006 : 			#endif
; 2007 : 				switch(GetLevel())
; 2008 : 				{
; 2009 : 				case 2:
; 2010 : #if __VER >= 13 // __RENEW_CHARINFO
; 2011 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_CHARACTER3);
; 2012 : #elif __VER >= 9 // __CSC_VER9_2
; 2013 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_CHARACTER2);
; 2014 : #else //__CSC_VER9_2
; 2015 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_CHARACTER);
; 2016 : #endif //__CSC_VER9_2
; 2017 : 					break;
; 2018 : 				case 3:
; 2019 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_EVENT_BERSERKERMODE);
; 2020 : 					break;
; 2021 : 				case 4:
; 2022 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(APP_SKILL_BEFOREJOB);
; 2023 : 					break;
; 2024 : 				case 8:
; 2025 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_ESSENSE);
; 2026 : 					break;
; 2027 : 				case 15:
; 2028 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_CHANGEJOB);
; 2029 : 					break;					
; 2030 : 				case 16:
; 2031 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_FLIGHT);
; 2032 : 					break;
; 2033 : 				case 20:
; 2034 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_FLIGHT_METHOD);
; 2035 : 					break;
; 2036 : 				case 40:
; 2037 : 					pWndWorld->m_pWndGuideSystem->SendGuideMessage(GUIDE_APP_GUILD);
; 2038 : 					break;
; 2039 : 				}
; 2040 : 			}
; 2041 : 		}
; 2042 : #endif	// __CLIENT
; 2043 : 	}
; 2044 : 
; 2045 : 
; 2046 : 	return FALSE;

  00078	33 c0		 xor	 eax, eax
  0007a	5e		 pop	 esi

; 2047 : }

  0007b	c2 0c 00	 ret	 12			; 0000000cH
?SetExperience@CMover@@QAEH_JH@Z ENDP			; CMover::SetExperience
_TEXT	ENDS
PUBLIC	?SetDestParam@CMover@@QAEXHHHH@Z		; CMover::SetDestParam
PUBLIC	?ResetDestParam@CMover@@QAEXHHH@Z		; CMover::ResetDestParam
PUBLIC	??_C@_0DH@LGNMPJME@SetDestParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUser@ ; `string'
EXTRN	?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z:NEAR ; CUserMng::AddSetDestParam
;	COMDAT ??_C@_0DH@LGNMPJME@SetDestParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUser@
CONST	SEGMENT
??_C@_0DH@LGNMPJME@SetDestParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUser@ DB 'Se'
	DB	'tDestParam( DST_GOLD ) - [User:%s(%07d)], [Value:%d]', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetDestParam@CMover@@QAEXHHHH@Z
_TEXT	SEGMENT
_fSuccess$ = -4						; size = 4
_nDstParameter$ = 8					; size = 4
tv972 = 12						; size = 4
_nAdjParameterValue$ = 12				; size = 4
_nChgParameterValue$ = 16				; size = 4
tv1165 = 20						; size = 4
tv1161 = 20						; size = 4
tv1157 = 20						; size = 4
tv1152 = 20						; size = 4
tv1148 = 20						; size = 4
tv1144 = 20						; size = 4
tv1140 = 20						; size = 4
tv1136 = 20						; size = 4
tv1132 = 20						; size = 4
tv1127 = 20						; size = 4
tv1123 = 20						; size = 4
tv1119 = 20						; size = 4
_bSend$ = 20						; size = 4
?SetDestParam@CMover@@QAEXHHHH@Z PROC NEAR		; CMover::SetDestParam, COMDAT
; _this$ = ecx

; 2393 : {

  00000	51		 push	 ecx

; 2394 : 	BOOL fSuccess	= FALSE;

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _nDstParameter$[esp]
  00005	53		 push	 ebx
  00006	8b 5c 24 14	 mov	 ebx, DWORD PTR _nChgParameterValue$[esp+4]
  0000a	55		 push	 ebp
  0000b	8b 6c 24 1c	 mov	 ebp, DWORD PTR _bSend$[esp+8]
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8b 7c 24 1c	 mov	 edi, DWORD PTR _nAdjParameterValue$[esp+16]
  00015	8b f1		 mov	 esi, ecx
  00017	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _fSuccess$[esp+20], 0
  0001f	90		 npad	 1
$L286739:

; 2395 : 
; 2396 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 2397 : 	if( (nDstParameter < 0 ) && ( nDstParameter != DST_ADJDEF_RATE && nDstParameter != DST_ADJDEF ) )

  00020	85 c0		 test	 eax, eax
  00022	7d 0e		 jge	 SHORT $L286745
  00024	83 f8 48	 cmp	 eax, 72			; 00000048H
  00027	74 09		 je	 SHORT $L286745
  00029	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0002c	0f 85 6c 05 00
	00		 jne	 $L276006
$L286745:

; 2398 : 		return;
; 2399 : #else
; 2400 : 	if( nDstParameter < 0 )
; 2401 : 		return;
; 2402 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 2403 : 	
; 2404 : 	// HP, MP SetPointParam .  SetDestParam    ?
; 2405 : 	switch( nDstParameter )

  00032	3d 19 27 00 00	 cmp	 eax, 10009		; 00002719H
  00037	0f 8f 82 01 00
	00		 jg	 $L286729
  0003d	0f 84 45 01 00
	00		 je	 $L275953
  00043	3d 13 27 00 00	 cmp	 eax, 10003		; 00002713H
  00048	0f 8f 8a 00 00
	00		 jg	 $L286730
  0004e	74 5a		 je	 SHORT $L275941
  00050	83 f8 28	 cmp	 eax, 40			; 00000028H
  00053	0f 8e dd 03 00
	00		 jle	 $L286747
  00059	8b c8		 mov	 ecx, eax
  0005b	81 e9 10 27 00
	00		 sub	 ecx, 10000		; 00002710H
  00061	0f 84 8e 04 00
	00		 je	 $L275935
  00067	83 e9 02	 sub	 ecx, 2
  0006a	0f 85 ac 04 00
	00		 jne	 $L275923

; 2441 : 		return;
; 2442 : #endif // __PERIN_BUY_BUG
; 2443 : 
; 2444 : 		if( AddGold( nAdjParameterValue ) == FALSE )	
; 2445 : 			SetGold( 0 );		// underflow 0 .   .   
; 2446 : 		return;
; 2447 : 
; 2448 : 	case DST_RESIST_ALL:
; 2449 : 		SetDestParam( DST_RESIST_ELECTRICITY,	nAdjParameterValue, nChgParameterValue, bSend );

  00070	55		 push	 ebp
  00071	53		 push	 ebx
  00072	57		 push	 edi
  00073	6a 1c		 push	 28			; 0000001cH
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2450 : 		SetDestParam( DST_RESIST_FIRE,			nAdjParameterValue, nChgParameterValue, bSend );

  0007c	55		 push	 ebp
  0007d	53		 push	 ebx
  0007e	57		 push	 edi
  0007f	6a 1e		 push	 30			; 0000001eH
  00081	8b ce		 mov	 ecx, esi
  00083	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2451 : 		SetDestParam( DST_RESIST_WIND,			nAdjParameterValue, nChgParameterValue, bSend );

  00088	55		 push	 ebp
  00089	53		 push	 ebx
  0008a	57		 push	 edi
  0008b	6a 1f		 push	 31			; 0000001fH
  0008d	8b ce		 mov	 ecx, esi
  0008f	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2452 : 		SetDestParam( DST_RESIST_WATER,			nAdjParameterValue, nChgParameterValue, bSend );

  00094	55		 push	 ebp
  00095	53		 push	 ebx
  00096	57		 push	 edi
  00097	6a 20		 push	 32			; 00000020H
  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2453 : 		SetDestParam( DST_RESIST_EARTH,			nAdjParameterValue, nChgParameterValue, bSend );

  000a0	b8 21 00 00 00	 mov	 eax, 33			; 00000021H
  000a5	e9 76 ff ff ff	 jmp	 $L286739
$L275941:

; 2454 : 		return;
; 2455 : 	case DST_STAT_ALLUP:
; 2456 : 		SetDestParam( DST_STR,	nAdjParameterValue, nChgParameterValue, bSend );

  000aa	55		 push	 ebp
  000ab	53		 push	 ebx
  000ac	57		 push	 edi
  000ad	6a 01		 push	 1
  000af	8b ce		 mov	 ecx, esi
  000b1	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2457 : 		SetDestParam( DST_DEX,	nAdjParameterValue, nChgParameterValue, bSend );

  000b6	55		 push	 ebp
  000b7	53		 push	 ebx
  000b8	57		 push	 edi
  000b9	6a 02		 push	 2
  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2458 : 		SetDestParam( DST_INT,	nAdjParameterValue, nChgParameterValue, bSend );

  000c2	55		 push	 ebp
  000c3	53		 push	 ebx
  000c4	57		 push	 edi
  000c5	6a 03		 push	 3
  000c7	8b ce		 mov	 ecx, esi
  000c9	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2459 : 		SetDestParam( DST_STA,	nAdjParameterValue, nChgParameterValue, bSend );

  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	e9 48 ff ff ff	 jmp	 $L286739
$L286730:

; 2398 : 		return;
; 2399 : #else
; 2400 : 	if( nDstParameter < 0 )
; 2401 : 		return;
; 2402 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 2403 : 	
; 2404 : 	// HP, MP SetPointParam .  SetDestParam    ?
; 2405 : 	switch( nDstParameter )

  000d8	8d 88 ec d8 ff
	ff		 lea	 ecx, DWORD PTR [eax-10004]
  000de	83 f9 04	 cmp	 ecx, 4
  000e1	0f 87 35 04 00
	00		 ja	 $L275923
  000e7	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L286748[ecx*4]
$L275942:

; 2460 : 		return;
; 2461 : 	case DST_HPDMG_UP:	// DST_HP_MAX + DST_CHR_DMG 
; 2462 : 		SetDestParam( DST_HP_MAX, nAdjParameterValue, nChgParameterValue, bSend );

  000ee	55		 push	 ebp
  000ef	53		 push	 ebx
  000f0	57		 push	 edi
  000f1	6a 23		 push	 35			; 00000023H
  000f3	8b ce		 mov	 ecx, esi
  000f5	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2463 : 		SetDestParam( DST_CHR_DMG, nAdjParameterValue, nChgParameterValue, bSend );

  000fa	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  000ff	e9 1c ff ff ff	 jmp	 $L286739
$L275943:

; 2464 : 		return;
; 2465 : 	case DST_DEFHITRATE_DOWN: // DST_ADJDEF + DST_ADJ_HITRATE
; 2466 : 		SetDestParam( DST_ADJDEF, nAdjParameterValue, nChgParameterValue, bSend );

  00104	55		 push	 ebp
  00105	53		 push	 ebx
  00106	57		 push	 edi
  00107	6a 1a		 push	 26			; 0000001aH
  00109	8b ce		 mov	 ecx, esi
  0010b	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2467 : 		SetDestParam( DST_ADJ_HITRATE, nAdjParameterValue, nChgParameterValue, bSend );

  00110	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH
  00115	e9 06 ff ff ff	 jmp	 $L286739
$L275945:

; 2472 : 		return;
; 2473 : #ifdef __NEWWPN1024
; 2474 : 	case DST_MASTRY_ALL:
; 2475 : 		SetDestParam( DST_MASTRY_EARTH,	nAdjParameterValue, nChgParameterValue, bSend );
; 2476 : 		SetDestParam( DST_MASTRY_FIRE,	nAdjParameterValue, nChgParameterValue, bSend );
; 2477 : 		SetDestParam( DST_MASTRY_WATER,	nAdjParameterValue, nChgParameterValue, bSend );
; 2478 : 		SetDestParam( DST_MASTRY_ELECTRICITY,	nAdjParameterValue, nChgParameterValue, bSend );
; 2479 : 		SetDestParam( DST_MASTRY_WIND,	nAdjParameterValue, nChgParameterValue, bSend );
; 2480 : 		return;
; 2481 : #endif	// __NEWWPN1024
; 2482 : 
; 2483 : 	case DST_HP_RECOVERY_RATE:
; 2484 : 		{
; 2485 : 			int nMax	= GetMaxOriginHitPoint();		//      

  0011a	6a 01		 push	 1
  0011c	8b ce		 mov	 ecx, esi

; 2486 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2487 : 			SetDestParam( DST_HP_RECOVERY, nRecv, NULL_CHGPARAM, bSend );

  0011e	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00123	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  00128	89 44 24 24	 mov	 DWORD PTR tv1165[esp+16], eax
  0012c	db 44 24 24	 fild	 DWORD PTR tv1165[esp+16]
  00130	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  00134	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0013a	de c9		 fmulp	 ST(1), ST(0)
  0013c	e8 00 00 00 00	 call	 __ftol2
  00141	8b f8		 mov	 edi, eax
  00143	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  00147	b8 29 00 00 00	 mov	 eax, 41			; 00000029H
  0014c	e9 cf fe ff ff	 jmp	 $L286739
$L275949:

; 2488 : 		}
; 2489 : 		return;
; 2490 : 	case DST_MP_RECOVERY_RATE:
; 2491 : 		{
; 2492 : 			int nMax	= GetMaxOriginManaPoint();		//      

  00151	6a 01		 push	 1
  00153	8b ce		 mov	 ecx, esi

; 2493 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2494 : 			SetDestParam( DST_MP_RECOVERY, nRecv, NULL_CHGPARAM, bSend );

  00155	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0015a	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint
  0015f	89 44 24 24	 mov	 DWORD PTR tv1161[esp+16], eax
  00163	db 44 24 24	 fild	 DWORD PTR tv1161[esp+16]
  00167	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  0016b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00171	de c9		 fmulp	 ST(1), ST(0)
  00173	e8 00 00 00 00	 call	 __ftol2
  00178	8b f8		 mov	 edi, eax
  0017a	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  0017e	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH
  00183	e9 98 fe ff ff	 jmp	 $L286739
$L275953:

; 2495 : 		}
; 2496 : 		return;
; 2497 : 	case DST_FP_RECOVERY_RATE:
; 2498 : 		{
; 2499 : 			int nMax	= GetMaxOriginFatiguePoint();		//      

  00188	6a 01		 push	 1
  0018a	8b ce		 mov	 ecx, esi

; 2500 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2501 : 			SetDestParam( DST_FP_RECOVERY, nRecv, NULL_CHGPARAM, bSend );

  0018c	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00191	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  00196	89 44 24 24	 mov	 DWORD PTR tv1157[esp+16], eax
  0019a	db 44 24 24	 fild	 DWORD PTR tv1157[esp+16]
  0019e	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  001a2	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  001a8	de c9		 fmulp	 ST(1), ST(0)
  001aa	e8 00 00 00 00	 call	 __ftol2
  001af	8b f8		 mov	 edi, eax
  001b1	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  001b5	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  001ba	e9 61 fe ff ff	 jmp	 $L286739
$L286729:

; 2398 : 		return;
; 2399 : #else
; 2400 : 	if( nDstParameter < 0 )
; 2401 : 		return;
; 2402 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 2403 : 	
; 2404 : 	// HP, MP SetPointParam .  SetDestParam    ?
; 2405 : 	switch( nDstParameter )

  001bf	8d 88 e6 d8 ff
	ff		 lea	 ecx, DWORD PTR [eax-10010]
  001c5	83 f9 09	 cmp	 ecx, 9
  001c8	0f 87 4e 03 00
	00		 ja	 $L275923
  001ce	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L286749[ecx*4]
$L275944:

; 2468 : 		return;
; 2469 : 	case DST_LOCOMOTION:
; 2470 : 		SetDestParam( DST_SPEED,	nAdjParameterValue, nChgParameterValue, bSend );

  001d5	55		 push	 ebp
  001d6	53		 push	 ebx
  001d7	57		 push	 edi
  001d8	6a 0b		 push	 11			; 0000000bH
  001da	8b ce		 mov	 ecx, esi
  001dc	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2471 : 		SetDestParam( DST_JUMPING,	( nAdjParameterValue * 3 ), nChgParameterValue, bSend );

  001e1	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  001e4	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  001e8	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  001ed	e9 2e fe ff ff	 jmp	 $L286739
$L275957:

; 2502 : 		}
; 2503 : 		return;
; 2504 : 	case DST_ALL_RECOVERY:
; 2505 : 		{
; 2506 : 			// HP
; 2507 : 			SetDestParam( DST_HP_RECOVERY, nAdjParameterValue, NULL_CHGPARAM, bSend );

  001f2	55		 push	 ebp
  001f3	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  001f8	57		 push	 edi
  001f9	6a 29		 push	 41			; 00000029H
  001fb	8b ce		 mov	 ecx, esi
  001fd	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2508 : 			// MP
; 2509 : 			SetDestParam( DST_MP_RECOVERY, nAdjParameterValue, NULL_CHGPARAM, bSend );

  00202	55		 push	 ebp
  00203	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00208	57		 push	 edi
  00209	6a 2a		 push	 42			; 0000002aH
  0020b	8b ce		 mov	 ecx, esi
  0020d	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2510 : 			// FP
; 2511 : 			SetDestParam( DST_FP_RECOVERY, nAdjParameterValue, NULL_CHGPARAM, bSend );

  00212	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00217	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  0021c	e9 ff fd ff ff	 jmp	 $L286739
$L275958:

; 2512 : 		}
; 2513 : 		return;
; 2514 : 	case DST_ALL_RECOVERY_RATE:
; 2515 : 		{
; 2516 : 			// HP
; 2517 : 			int nMax	= GetMaxOriginHitPoint();		//      
; 2518 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  00221	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  00225	6a 01		 push	 1
  00227	8b ce		 mov	 ecx, esi
  00229	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0022f	d9 5c 24 20	 fstp	 DWORD PTR tv972[esp+20]
  00233	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  00238	89 44 24 24	 mov	 DWORD PTR tv1152[esp+16], eax
  0023c	db 44 24 24	 fild	 DWORD PTR tv1152[esp+16]
  00240	d8 4c 24 1c	 fmul	 DWORD PTR tv972[esp+16]
  00244	e8 00 00 00 00	 call	 __ftol2

; 2519 : 			SetDestParam( DST_HP_RECOVERY, nRecv, NULL_CHGPARAM, bSend );

  00249	55		 push	 ebp
  0024a	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  0024f	50		 push	 eax
  00250	6a 29		 push	 41			; 00000029H
  00252	8b ce		 mov	 ecx, esi
  00254	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2520 : 
; 2521 : 			// MP
; 2522 : 			nMax	= GetMaxOriginManaPoint();		//      

  00259	6a 01		 push	 1
  0025b	8b ce		 mov	 ecx, esi
  0025d	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint

; 2523 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  00262	89 44 24 24	 mov	 DWORD PTR tv1148[esp+16], eax
  00266	db 44 24 24	 fild	 DWORD PTR tv1148[esp+16]
  0026a	d8 4c 24 1c	 fmul	 DWORD PTR tv972[esp+16]
  0026e	e8 00 00 00 00	 call	 __ftol2

; 2524 : 			SetDestParam( DST_MP_RECOVERY, nRecv, NULL_CHGPARAM, bSend );

  00273	55		 push	 ebp
  00274	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00279	50		 push	 eax
  0027a	6a 2a		 push	 42			; 0000002aH
  0027c	8b ce		 mov	 ecx, esi
  0027e	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2525 : 
; 2526 : 			// FP
; 2527 : 			nMax	= GetMaxOriginFatiguePoint();		//      

  00283	6a 01		 push	 1
  00285	8b ce		 mov	 ecx, esi

; 2528 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2529 : 			SetDestParam( DST_FP_RECOVERY, nRecv, NULL_CHGPARAM, bSend );

  00287	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0028c	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  00291	89 44 24 24	 mov	 DWORD PTR tv1144[esp+16], eax
  00295	db 44 24 24	 fild	 DWORD PTR tv1144[esp+16]
  00299	d8 4c 24 1c	 fmul	 DWORD PTR tv972[esp+16]
  0029d	e8 00 00 00 00	 call	 __ftol2
  002a2	8b f8		 mov	 edi, eax
  002a4	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  002a8	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  002ad	e9 6e fd ff ff	 jmp	 $L286739
$L275964:

; 2530 : 		}
; 2531 : 		return;
; 2532 : 	case DST_KILL_ALL:	
; 2533 : 		{
; 2534 : 			// HP
; 2535 : 			SetDestParam( DST_KILL_HP, nAdjParameterValue, NULL_CHGPARAM, bSend );

  002b2	55		 push	 ebp
  002b3	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  002b8	57		 push	 edi
  002b9	6a 2c		 push	 44			; 0000002cH
  002bb	8b ce		 mov	 ecx, esi
  002bd	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2536 : 			// MP
; 2537 : 			SetDestParam( DST_KILL_MP, nAdjParameterValue, NULL_CHGPARAM, bSend );

  002c2	55		 push	 ebp
  002c3	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  002c8	57		 push	 edi
  002c9	6a 2d		 push	 45			; 0000002dH
  002cb	8b ce		 mov	 ecx, esi
  002cd	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2538 : 			// FP
; 2539 : 			SetDestParam( DST_KILL_FP, nAdjParameterValue, NULL_CHGPARAM, bSend );

  002d2	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  002d7	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  002dc	e9 3f fd ff ff	 jmp	 $L286739
$L275965:

; 2540 : 		}
; 2541 : 		return;
; 2542 : 	case DST_KILL_HP_RATE:
; 2543 : 		{
; 2544 : 			int nMax	= GetMaxOriginHitPoint();		//      

  002e1	6a 01		 push	 1
  002e3	8b ce		 mov	 ecx, esi

; 2545 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2546 : 			SetDestParam( DST_KILL_HP, nRecv, NULL_CHGPARAM, bSend );

  002e5	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  002ea	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  002ef	89 44 24 24	 mov	 DWORD PTR tv1140[esp+16], eax
  002f3	db 44 24 24	 fild	 DWORD PTR tv1140[esp+16]
  002f7	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  002fb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00301	de c9		 fmulp	 ST(1), ST(0)
  00303	e8 00 00 00 00	 call	 __ftol2
  00308	8b f8		 mov	 edi, eax
  0030a	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  0030e	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  00313	e9 08 fd ff ff	 jmp	 $L286739
$L275969:

; 2547 : 		}
; 2548 : 		return;
; 2549 : 	case DST_KILL_MP_RATE:
; 2550 : 		{
; 2551 : 			int nMax	= GetMaxOriginManaPoint();		//      

  00318	6a 01		 push	 1
  0031a	8b ce		 mov	 ecx, esi

; 2552 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2553 : 			SetDestParam( DST_KILL_MP, nRecv, NULL_CHGPARAM, bSend );

  0031c	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00321	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint
  00326	89 44 24 24	 mov	 DWORD PTR tv1136[esp+16], eax
  0032a	db 44 24 24	 fild	 DWORD PTR tv1136[esp+16]
  0032e	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  00332	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00338	de c9		 fmulp	 ST(1), ST(0)
  0033a	e8 00 00 00 00	 call	 __ftol2
  0033f	8b f8		 mov	 edi, eax
  00341	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  00345	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  0034a	e9 d1 fc ff ff	 jmp	 $L286739
$L275973:

; 2554 : 		}
; 2555 : 		return;
; 2556 : 	case DST_KILL_FP_RATE:
; 2557 : 		{
; 2558 : 			int nMax	= GetMaxOriginFatiguePoint();		//      

  0034f	6a 01		 push	 1
  00351	8b ce		 mov	 ecx, esi

; 2559 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2560 : 			SetDestParam( DST_KILL_FP, nRecv, NULL_CHGPARAM, bSend );

  00353	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00358	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  0035d	89 44 24 24	 mov	 DWORD PTR tv1132[esp+16], eax
  00361	db 44 24 24	 fild	 DWORD PTR tv1132[esp+16]
  00365	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  00369	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0036f	de c9		 fmulp	 ST(1), ST(0)
  00371	e8 00 00 00 00	 call	 __ftol2
  00376	8b f8		 mov	 edi, eax
  00378	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  0037c	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  00381	e9 9a fc ff ff	 jmp	 $L286739
$L275977:

; 2561 : 		}
; 2562 : 		return;
; 2563 : 	case DST_KILL_ALL_RATE:
; 2564 : 		{
; 2565 : 			// HP
; 2566 : 			int nMax	= GetMaxOriginHitPoint();		//      
; 2567 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  00386	db 44 24 1c	 fild	 DWORD PTR _nAdjParameterValue$[esp+16]
  0038a	6a 01		 push	 1
  0038c	8b ce		 mov	 ecx, esi
  0038e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00394	d9 5c 24 20	 fstp	 DWORD PTR tv972[esp+20]
  00398	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  0039d	89 44 24 24	 mov	 DWORD PTR tv1127[esp+16], eax
  003a1	db 44 24 24	 fild	 DWORD PTR tv1127[esp+16]
  003a5	d8 4c 24 1c	 fmul	 DWORD PTR tv972[esp+16]
  003a9	e8 00 00 00 00	 call	 __ftol2

; 2568 : 			SetDestParam( DST_KILL_HP, nRecv, NULL_CHGPARAM, bSend );

  003ae	55		 push	 ebp
  003af	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  003b4	50		 push	 eax
  003b5	6a 2c		 push	 44			; 0000002cH
  003b7	8b ce		 mov	 ecx, esi
  003b9	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2569 : 			
; 2570 : 			// MP
; 2571 : 			nMax	= GetMaxOriginManaPoint();		//      

  003be	6a 01		 push	 1
  003c0	8b ce		 mov	 ecx, esi
  003c2	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint

; 2572 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  003c7	89 44 24 24	 mov	 DWORD PTR tv1123[esp+16], eax
  003cb	db 44 24 24	 fild	 DWORD PTR tv1123[esp+16]
  003cf	d8 4c 24 1c	 fmul	 DWORD PTR tv972[esp+16]
  003d3	e8 00 00 00 00	 call	 __ftol2

; 2573 : 			SetDestParam( DST_KILL_MP, nRecv, NULL_CHGPARAM, bSend );

  003d8	55		 push	 ebp
  003d9	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  003de	50		 push	 eax
  003df	6a 2d		 push	 45			; 0000002dH
  003e1	8b ce		 mov	 ecx, esi
  003e3	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2574 : 			
; 2575 : 			// FP
; 2576 : 			nMax	= GetMaxOriginFatiguePoint();		//      

  003e8	6a 01		 push	 1
  003ea	8b ce		 mov	 ecx, esi

; 2577 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2578 : 			SetDestParam( DST_KILL_FP, nRecv, NULL_CHGPARAM, bSend );

  003ec	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  003f1	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  003f6	89 44 24 24	 mov	 DWORD PTR tv1119[esp+16], eax
  003fa	db 44 24 24	 fild	 DWORD PTR tv1119[esp+16]
  003fe	d8 4c 24 1c	 fmul	 DWORD PTR tv972[esp+16]
  00402	e8 00 00 00 00	 call	 __ftol2
  00407	8b f8		 mov	 edi, eax
  00409	89 7c 24 1c	 mov	 DWORD PTR _nAdjParameterValue$[esp+16], edi
  0040d	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  00412	e9 09 fc ff ff	 jmp	 $L286739
$L275983:

; 2579 : 		}
; 2580 : 		return;
; 2581 : 	case DST_ALL_DEC_RATE:
; 2582 : 		{
; 2583 : 			SetDestParam( DST_MP_DEC_RATE, nAdjParameterValue, NULL_CHGPARAM, bSend );

  00417	55		 push	 ebp
  00418	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  0041d	57		 push	 edi
  0041e	6a 49		 push	 73			; 00000049H
  00420	8b ce		 mov	 ecx, esi
  00422	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam

; 2584 : 			SetDestParam( DST_FP_DEC_RATE, nAdjParameterValue, NULL_CHGPARAM, bSend );

  00427	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0042c	b8 4a 00 00 00	 mov	 eax, 74			; 0000004aH
  00431	e9 ea fb ff ff	 jmp	 $L286739
$L286747:

; 2398 : 		return;
; 2399 : #else
; 2400 : 	if( nDstParameter < 0 )
; 2401 : 		return;
; 2402 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 2403 : 	
; 2404 : 	// HP, MP SetPointParam .  SetDestParam    ?
; 2405 : 	switch( nDstParameter )

  00436	0f 84 80 00 00
	00		 je	 $L275932
  0043c	8b c8		 mov	 ecx, eax
  0043e	83 e9 26	 sub	 ecx, 38			; 00000026H
  00441	74 40		 je	 SHORT $L275926
  00443	49		 dec	 ecx
  00444	0f 85 d2 00 00
	00		 jne	 $L275923

; 2414 : 		}
; 2415 : 		return;
; 2416 : 	case DST_MP:
; 2417 : 		{
; 2418 : 			if( nAdjParameterValue == -1 )

  0044a	83 ff ff	 cmp	 edi, -1

; 2419 : 				SetPointParam( nDstParameter, GetMaxManaPoint() );

  0044d	8b ce		 mov	 ecx, esi
  0044f	6a 00		 push	 0
  00451	75 17		 jne	 SHORT $L275930
  00453	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  00458	50		 push	 eax
  00459	6a 27		 push	 39			; 00000027H
  0045b	8b ce		 mov	 ecx, esi
  0045d	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
  00462	5f		 pop	 edi
  00463	5e		 pop	 esi
  00464	5d		 pop	 ebp
  00465	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  00466	59		 pop	 ecx
  00467	c2 10 00	 ret	 16			; 00000010H
$L275930:

; 2420 : 			else
; 2421 : 				SetPointParam( nDstParameter, GetManaPoint() + nAdjParameterValue );

  0046a	e8 00 00 00 00	 call	 ?GetManaPoint@CMover@@QAEHXZ ; CMover::GetManaPoint
  0046f	03 c7		 add	 eax, edi
  00471	50		 push	 eax
  00472	6a 27		 push	 39			; 00000027H
  00474	8b ce		 mov	 ecx, esi
  00476	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
  0047b	5f		 pop	 edi
  0047c	5e		 pop	 esi
  0047d	5d		 pop	 ebp
  0047e	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  0047f	59		 pop	 ecx
  00480	c2 10 00	 ret	 16			; 00000010H
$L275926:

; 2406 : 	{
; 2407 : #ifdef __WORLDSERVER
; 2408 : 	case DST_HP:
; 2409 : 		{
; 2410 : 			if( nAdjParameterValue == -1 )

  00483	83 ff ff	 cmp	 edi, -1

; 2411 : 				SetPointParam( nDstParameter, GetMaxHitPoint() );

  00486	8b ce		 mov	 ecx, esi
  00488	6a 00		 push	 0
  0048a	75 17		 jne	 SHORT $L275927
  0048c	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  00491	50		 push	 eax
  00492	6a 26		 push	 38			; 00000026H
  00494	8b ce		 mov	 ecx, esi
  00496	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
  0049b	5f		 pop	 edi
  0049c	5e		 pop	 esi
  0049d	5d		 pop	 ebp
  0049e	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  0049f	59		 pop	 ecx
  004a0	c2 10 00	 ret	 16			; 00000010H
$L275927:

; 2412 : 			else
; 2413 : 				SetPointParam( nDstParameter, GetHitPoint() + nAdjParameterValue );

  004a3	e8 00 00 00 00	 call	 ?GetHitPoint@CMover@@QAEHXZ ; CMover::GetHitPoint
  004a8	03 c7		 add	 eax, edi
  004aa	50		 push	 eax
  004ab	6a 26		 push	 38			; 00000026H
  004ad	8b ce		 mov	 ecx, esi
  004af	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
  004b4	5f		 pop	 edi
  004b5	5e		 pop	 esi
  004b6	5d		 pop	 ebp
  004b7	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  004b8	59		 pop	 ecx
  004b9	c2 10 00	 ret	 16			; 00000010H
$L275932:

; 2422 : 			
; 2423 : 		}
; 2424 : 		return;
; 2425 : 	case DST_FP:
; 2426 : 		{
; 2427 : 			if( nAdjParameterValue == -1 )

  004bc	83 ff ff	 cmp	 edi, -1

; 2428 : 				SetPointParam( nDstParameter, GetMaxFatiguePoint() );

  004bf	8b ce		 mov	 ecx, esi
  004c1	6a 00		 push	 0
  004c3	75 17		 jne	 SHORT $L275933
  004c5	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  004ca	50		 push	 eax
  004cb	6a 28		 push	 40			; 00000028H
  004cd	8b ce		 mov	 ecx, esi
  004cf	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
  004d4	5f		 pop	 edi
  004d5	5e		 pop	 esi
  004d6	5d		 pop	 ebp
  004d7	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  004d8	59		 pop	 ecx
  004d9	c2 10 00	 ret	 16			; 00000010H
$L275933:

; 2429 : 			else
; 2430 : 				SetPointParam( nDstParameter, GetFatiguePoint() + nAdjParameterValue );

  004dc	e8 00 00 00 00	 call	 ?GetFatiguePoint@CMover@@QAEHXZ ; CMover::GetFatiguePoint
  004e1	03 c7		 add	 eax, edi
  004e3	50		 push	 eax
  004e4	6a 28		 push	 40			; 00000028H
  004e6	8b ce		 mov	 ecx, esi
  004e8	e8 00 00 00 00	 call	 ?SetPointParam@CMover@@QAEXHHH@Z ; CMover::SetPointParam
  004ed	5f		 pop	 edi
  004ee	5e		 pop	 esi
  004ef	5d		 pop	 ebp
  004f0	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  004f1	59		 pop	 ecx
  004f2	c2 10 00	 ret	 16			; 00000010H
$L275935:

; 2431 : 		}
; 2432 : 		return;
; 2433 : #else // __WORLDSERVER
; 2434 : 	case DST_HP:	SetPointParam( nDstParameter, GetHitPoint() + nAdjParameterValue );	return;
; 2435 : 	case DST_MP:	SetPointParam( nDstParameter, GetManaPoint() + nAdjParameterValue );	return;
; 2436 : 	case DST_FP:	SetPointParam( nDstParameter, GetFatiguePoint() + nAdjParameterValue );	return;
; 2437 : #endif // __WORLDSERVER
; 2438 : 	case DST_GOLD:	
; 2439 : #ifdef __PERIN_BUY_BUG	// chipi_091219 
; 2440 : 		Error( "SetDestParam( DST_GOLD ) - [User:%s(%07d)], [Value:%d]", static_cast<CUser*>(this)->GetName(), static_cast<CUser*>(this)->m_idPlayer, nAdjParameterValue );

  004f5	8b 86 38 02 00
	00		 mov	 eax, DWORD PTR [esi+568]
  004fb	57		 push	 edi
  004fc	50		 push	 eax
  004fd	6a 00		 push	 0
  004ff	8b ce		 mov	 ecx, esi
  00501	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00506	50		 push	 eax
  00507	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DH@LGNMPJME@SetDestParam?$CI?5DST_GOLD?5?$CJ?5?9?5?$FLUser@
  0050c	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00511	83 c4 10	 add	 esp, 16			; 00000010H
  00514	5f		 pop	 edi
  00515	5e		 pop	 esi
  00516	5d		 pop	 ebp
  00517	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  00518	59		 pop	 ecx
  00519	c2 10 00	 ret	 16			; 00000010H
$L275923:

; 2585 : 		}
; 2586 : 		return;
; 2587 : 	} // switch
; 2588 : 
; 2589 : 	//       
; 2590 : 	// DST_GOLD, PXP, RESIST_ALL MAX_ADJPARAMARY   . 
; 2591 : 	//      
; 2592 : 	//   .
; 2593 : 	if( nDstParameter >= MAX_ADJPARAMARY)

  0051c	83 f8 75	 cmp	 eax, 117		; 00000075H
  0051f	7d 7d		 jge	 SHORT $L276006

; 2594 : 		return;
; 2595 : 	
; 2596 : 	if( nAdjParameterValue != 0 )	// 0       .

  00521	85 ff		 test	 edi, edi
  00523	0f 84 b1 00 00
	00		 je	 $L275985

; 2597 : 	{
; 2598 : 		fSuccess	= TRUE;
; 2599 : 
; 2600 : 		switch( nDstParameter )

  00529	83 f8 40	 cmp	 eax, 64			; 00000040H
  0052c	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _fSuccess$[esp+20], 1
  00534	7f 30		 jg	 SHORT $L286732
  00536	74 16		 je	 SHORT $L275990
  00538	8d 48 e3	 lea	 ecx, DWORD PTR [eax-29]
  0053b	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0053e	77 7e		 ja	 SHORT $L276000
  00540	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $L286743[ecx]
  00547	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L286750[ecx*4]
$L275990:

; 2601 : 		{
; 2602 : 		case DST_CHRSTATE:		//  
; 2603 : 		case DST_IMMUNITY:
; 2604 : 			if( nAdjParameterValue != NULL_ID )

  0054e	83 ff ff	 cmp	 edi, -1
  00551	74 09		 je	 SHORT $L275991

; 2605 : 			{
; 2606 : 				if( nAdjParameterValue == 0xffffffff )
; 2607 : 				{
; 2608 : 					Error( "SetDestParam : Adj == -1, %s", GetName() );
; 2609 : 					return;
; 2610 : 				}
; 2611 : 				m_adjParamAry[nDstParameter] |= nAdjParameterValue;		//   .

  00553	09 bc 86 b8 12
	00 00		 or	 DWORD PTR [esi+eax*4+4792], edi

; 2612 : 			} else

  0055a	eb 29		 jmp	 SHORT $L286746
$L275991:

; 2613 : 				fSuccess = FALSE;

  0055c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _fSuccess$[esp+20], 0

; 2614 : 			break;

  00564	eb 1f		 jmp	 SHORT $L286746
$L286732:

; 2597 : 	{
; 2598 : 		fSuccess	= TRUE;
; 2599 : 
; 2600 : 		switch( nDstParameter )

  00566	83 f8 52	 cmp	 eax, 82			; 00000052H
  00569	7f 4c		 jg	 SHORT $L286733
  0056b	74 39		 je	 SHORT $L275998
  0056d	83 f8 45	 cmp	 eax, 69			; 00000045H
  00570	7c 4c		 jl	 SHORT $L276000
  00572	83 f8 46	 cmp	 eax, 70			; 00000046H
  00575	7f 47		 jg	 SHORT $L276000
$L275997:

; 2617 : 			return;
; 2618 : 		case DST_REFLECT_DAMAGE:
; 2619 : 			m_adjParamAry[nDstParameter] += nAdjParameterValue;		//  % ?
; 2620 : 			m_chgParamAry[nDstParameter] = nChgParameterValue;		// %  ?
; 2621 : 			break;
; 2622 : 		case DST_CHR_CHANCEBLEEDING:
; 2623 : 		case DST_CHR_CHANCESTEALHP:
; 2624 : 		case DST_CHR_CHANCEPOISON:
; 2625 : 		case DST_CHR_CHANCEDARK:
; 2626 : 		case DST_CHR_CHANCESTUN:
; 2627 : 		case DST_AUTOHP:
; 2628 : 			m_adjParamAry[nDstParameter] += nAdjParameterValue;		//  .	// %  .

  00577	01 bc 86 b8 12
	00 00		 add	 DWORD PTR [esi+eax*4+4792], edi
$L276003:

; 2655 : 		{
; 2656 : 			m_chgParamAry[nDstParameter] = nChgParameterValue;	//  .

  0057e	89 9c 86 8c 14
	00 00		 mov	 DWORD PTR [esi+eax*4+5260], ebx
$L286746:

; 2657 : 		}
; 2658 : 	}
; 2659 : #ifdef __WORLDSERVER
; 2660 : 	if( TRUE == ( fSuccess & bSend ) ) {

  00585	8b 4c 24 10	 mov	 ecx, DWORD PTR _fSuccess$[esp+20]
  00589	23 cd		 and	 ecx, ebp
  0058b	83 f9 01	 cmp	 ecx, 1
  0058e	75 0e		 jne	 SHORT $L276006

; 2661 : 		g_UserMng.AddSetDestParam( this, nDstParameter, nAdjParameterValue, nChgParameterValue );

  00590	53		 push	 ebx
  00591	57		 push	 edi
  00592	50		 push	 eax
  00593	56		 push	 esi
  00594	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00599	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam
$L276006:
  0059e	5f		 pop	 edi
  0059f	5e		 pop	 esi
  005a0	5d		 pop	 ebp
  005a1	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  005a2	59		 pop	 ecx
  005a3	c2 10 00	 ret	 16			; 00000010H
$L275998:

; 2629 : 			m_chgParamAry[nDstParameter] = nChgParameterValue;		//   		// %HP .
; 2630 : 			break;
; 2631 : #if __VER >= 9	// __PET_0410
; 2632 : 		case DST_HEAL:
; 2633 : 			m_nHealCnt	= (short)( PROCESS_COUNT * 6.0f );		//  6

  005a6	66 c7 86 dc 06
	00 00 5a 00	 mov	 WORD PTR [esi+1756], 90	; 0000005aH

; 2634 : 			m_adjParamAry[nDstParameter]	+= nAdjParameterValue;	

  005af	01 be 00 14 00
	00		 add	 DWORD PTR [esi+5120], edi

; 2635 : 			break;

  005b5	eb ce		 jmp	 SHORT $L286746
$L286733:

; 2597 : 	{
; 2598 : 		fSuccess	= TRUE;
; 2599 : 
; 2600 : 		switch( nDstParameter )

  005b7	3d 16 27 00 00	 cmp	 eax, 10006		; 00002716H
  005bc	74 09		 je	 SHORT $L275995
$L276000:

; 2636 : #endif	// __PET_0410
; 2637 : 		default:
; 2638 : 			m_adjParamAry[nDstParameter] += nAdjParameterValue;		// 

  005be	01 bc 86 b8 12
	00 00		 add	 DWORD PTR [esi+eax*4+4792], edi

; 2639 : 			break;
; 2640 : 		}
; 2641 : 	}
; 2642 : 
; 2643 : 	else if( nChgParameterValue != 0x7FFFFFFF ) 

  005c5	eb be		 jmp	 SHORT $L286746
$L275995:

; 2615 : 		case DST_CURECHR:		// 
; 2616 : 			ResetDestParam( DST_CHRSTATE, nAdjParameterValue, bSend );

  005c7	55		 push	 ebp
  005c8	57		 push	 edi
  005c9	6a 40		 push	 64			; 00000040H
  005cb	8b ce		 mov	 ecx, esi
  005cd	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
  005d2	5f		 pop	 edi
  005d3	5e		 pop	 esi
  005d4	5d		 pop	 ebp
  005d5	5b		 pop	 ebx

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  005d6	59		 pop	 ecx
  005d7	c2 10 00	 ret	 16			; 00000010H
$L275985:

; 2639 : 			break;
; 2640 : 		}
; 2641 : 	}
; 2642 : 
; 2643 : 	else if( nChgParameterValue != 0x7FFFFFFF ) 

  005da	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  005e0	74 a3		 je	 SHORT $L286746

; 2644 : 	{
; 2645 : 		fSuccess	= TRUE;
; 2646 : 
; 2647 : 		// 
; 2648 : 		if( nDstParameter == DST_SPEED )

  005e2	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  005e5	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _fSuccess$[esp+20], 1
  005ed	75 8f		 jne	 SHORT $L276003

; 2649 : 		{
; 2650 : 			if( m_chgParamAry[nDstParameter] == 0x7FFFFFFF )

  005ef	81 be b8 14 00
	00 ff ff ff 7f	 cmp	 DWORD PTR [esi+5304], 2147483647 ; 7fffffffH
  005f9	75 0a		 jne	 SHORT $L276004

; 2651 : 				m_chgParamAry[nDstParameter]	= 0;

  005fb	c7 86 b8 14 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5304], 0
$L276004:

; 2652 : 			m_chgParamAry[nDstParameter]++;

  00605	ff 86 b8 14 00
	00		 inc	 DWORD PTR [esi+5304]

; 2653 : 		}
; 2654 : 		else

  0060b	e9 75 ff ff ff	 jmp	 $L286746
$L286748:

; 2662 : 	}
; 2663 : #endif	// __WORLDSERVER
; 2664 : }

  00610	00 00 00 00	 DD	 $L275942
  00614	00 00 00 00	 DD	 $L275943
  00618	00 00 00 00	 DD	 $L275923
  0061c	00 00 00 00	 DD	 $L275945
  00620	00 00 00 00	 DD	 $L275949
$L286749:
  00624	00 00 00 00	 DD	 $L275944
  00628	00 00 00 00	 DD	 $L275923
  0062c	00 00 00 00	 DD	 $L275957
  00630	00 00 00 00	 DD	 $L275958
  00634	00 00 00 00	 DD	 $L275964
  00638	00 00 00 00	 DD	 $L275965
  0063c	00 00 00 00	 DD	 $L275969
  00640	00 00 00 00	 DD	 $L275973
  00644	00 00 00 00	 DD	 $L275977
  00648	00 00 00 00	 DD	 $L275983
$L286750:
  0064c	00 00 00 00	 DD	 $L275997
  00650	00 00 00 00	 DD	 $L275990
  00654	00 00 00 00	 DD	 $L276000
$L286743:
  00658	00		 DB	 0
  00659	02		 DB	 2
  0065a	02		 DB	 2
  0065b	02		 DB	 2
  0065c	02		 DB	 2
  0065d	02		 DB	 2
  0065e	02		 DB	 2
  0065f	02		 DB	 2
  00660	02		 DB	 2
  00661	02		 DB	 2
  00662	02		 DB	 2
  00663	02		 DB	 2
  00664	02		 DB	 2
  00665	02		 DB	 2
  00666	02		 DB	 2
  00667	02		 DB	 2
  00668	02		 DB	 2
  00669	02		 DB	 2
  0066a	02		 DB	 2
  0066b	02		 DB	 2
  0066c	02		 DB	 2
  0066d	02		 DB	 2
  0066e	02		 DB	 2
  0066f	02		 DB	 2
  00670	02		 DB	 2
  00671	02		 DB	 2
  00672	02		 DB	 2
  00673	02		 DB	 2
  00674	00		 DB	 0
  00675	00		 DB	 0
  00676	00		 DB	 0
  00677	00		 DB	 0
  00678	01		 DB	 1
?SetDestParam@CMover@@QAEXHHHH@Z ENDP			; CMover::SetDestParam
_TEXT	ENDS
EXTRN	?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z:NEAR ; CUserMng::AddResetDestParam
EXTRN	?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z:NEAR ; CUserMng::AddResetDestParamSync
; Function compile flags: /Ogty
;	COMDAT ?ResetDestParam@CMover@@QAEXHHH@Z
_TEXT	SEGMENT
_nDstParameter$ = 8					; size = 4
tv3749 = 12						; size = 4
_nAdjParameterValue$ = 12				; size = 4
tv5232 = 16						; size = 4
tv5228 = 16						; size = 4
tv5224 = 16						; size = 4
tv5219 = 16						; size = 4
tv5215 = 16						; size = 4
tv5211 = 16						; size = 4
tv5207 = 16						; size = 4
tv5203 = 16						; size = 4
tv5199 = 16						; size = 4
tv5194 = 16						; size = 4
tv5190 = 16						; size = 4
tv5186 = 16						; size = 4
_fSend$ = 16						; size = 4
?ResetDestParam@CMover@@QAEXHHH@Z PROC NEAR		; CMover::ResetDestParam, COMDAT
; _this$ = ecx

; 2670 : {

  00000	53		 push	 ebx

; 2671 : 	switch( nDstParameter )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _nDstParameter$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 14	 mov	 ebp, DWORD PTR _fSend$[esp+4]
  0000a	56		 push	 esi
  0000b	8d 83 ee d8 ff
	ff		 lea	 eax, DWORD PTR [ebx-10002]
  00011	83 f8 11	 cmp	 eax, 17			; 00000011H
  00014	57		 push	 edi
  00015	8b 7c 24 18	 mov	 edi, DWORD PTR _nAdjParameterValue$[esp+12]
  00019	8b f1		 mov	 esi, ecx
  0001b	0f 87 e1 03 00
	00		 ja	 $L288389
$L288390:
  00021	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L288422[eax*4]
$L276017:

; 2672 : 	{
; 2673 : 	case DST_RESIST_ALL:
; 2674 : 		ResetDestParam( DST_RESIST_ELECTRICITY,	nAdjParameterValue, TRUE );

  00028	6a 01		 push	 1
  0002a	57		 push	 edi
  0002b	6a 1c		 push	 28			; 0000001cH
  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2675 : 		ResetDestParam( DST_RESIST_FIRE,		nAdjParameterValue, TRUE );

  00034	6a 01		 push	 1
  00036	57		 push	 edi
  00037	6a 1e		 push	 30			; 0000001eH
  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2676 : 		ResetDestParam( DST_RESIST_WIND,		nAdjParameterValue, TRUE );

  00040	6a 01		 push	 1
  00042	57		 push	 edi
  00043	6a 1f		 push	 31			; 0000001fH
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2677 : 		ResetDestParam( DST_RESIST_WATER,		nAdjParameterValue, TRUE );

  0004c	6a 01		 push	 1
  0004e	57		 push	 edi
  0004f	6a 20		 push	 32			; 00000020H
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2678 : 		ResetDestParam( DST_RESIST_EARTH,		nAdjParameterValue, TRUE );

  00058	bd 01 00 00 00	 mov	 ebp, 1
  0005d	bb 21 00 00 00	 mov	 ebx, 33			; 00000021H
  00062	e9 c6 02 00 00	 jmp	 $L288395
$L276018:

; 2679 : 		return;
; 2680 : 	case DST_STAT_ALLUP:
; 2681 : 		ResetDestParam( DST_STR,	nAdjParameterValue, TRUE );

  00067	6a 01		 push	 1
  00069	57		 push	 edi
  0006a	6a 01		 push	 1
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2682 : 		ResetDestParam( DST_DEX,	nAdjParameterValue, TRUE );

  00073	6a 01		 push	 1
  00075	57		 push	 edi
  00076	6a 02		 push	 2
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2683 : 		ResetDestParam( DST_INT,	nAdjParameterValue, TRUE );

  0007f	6a 01		 push	 1
  00081	57		 push	 edi
  00082	6a 03		 push	 3
  00084	8b ce		 mov	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2684 : 		ResetDestParam( DST_STA,	nAdjParameterValue, TRUE );

  0008b	bd 01 00 00 00	 mov	 ebp, 1
  00090	bb 04 00 00 00	 mov	 ebx, 4
  00095	e9 93 02 00 00	 jmp	 $L288395
$L276019:

; 2685 : 		return;
; 2686 : 	case DST_HPDMG_UP:	// DST_HP_MAX + DST_CHR_DMG 
; 2687 : 		ResetDestParam( DST_HP_MAX, nAdjParameterValue, TRUE );

  0009a	6a 01		 push	 1
  0009c	57		 push	 edi
  0009d	6a 23		 push	 35			; 00000023H
  0009f	8b ce		 mov	 ecx, esi
  000a1	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2688 : 		ResetDestParam( DST_CHR_DMG, nAdjParameterValue, TRUE );

  000a6	bd 01 00 00 00	 mov	 ebp, 1
  000ab	bb 3f 00 00 00	 mov	 ebx, 63			; 0000003fH
  000b0	e9 78 02 00 00	 jmp	 $L288395
$L276020:

; 2689 : 		return;
; 2690 : 	case DST_DEFHITRATE_DOWN: // DST_ADJDEF + DST_ADJ_HITRATE
; 2691 : 		ResetDestParam( DST_ADJDEF, nAdjParameterValue, TRUE );

  000b5	6a 01		 push	 1
  000b7	57		 push	 edi
  000b8	6a 1a		 push	 26			; 0000001aH
  000ba	8b ce		 mov	 ecx, esi
  000bc	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2692 : 		ResetDestParam( DST_ADJ_HITRATE, nAdjParameterValue, TRUE );

  000c1	bd 01 00 00 00	 mov	 ebp, 1
  000c6	bb 2f 00 00 00	 mov	 ebx, 47			; 0000002fH
  000cb	e9 5d 02 00 00	 jmp	 $L288395
$L276021:

; 2693 : 		return;
; 2694 : 	case DST_LOCOMOTION:
; 2695 : 		ResetDestParam( DST_SPEED,	nAdjParameterValue, TRUE );

  000d0	6a 01		 push	 1
  000d2	57		 push	 edi
  000d3	6a 0b		 push	 11			; 0000000bH
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2696 : 		ResetDestParam( DST_JUMPING,	( nAdjParameterValue * 3 ), TRUE );

  000dc	bd 01 00 00 00	 mov	 ebp, 1
  000e1	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  000e4	bb 44 00 00 00	 mov	 ebx, 68			; 00000044H
  000e9	e9 3b 02 00 00	 jmp	 $L288419
$L276022:

; 2697 : 		return;
; 2698 : #ifdef __NEWWPN1024
; 2699 : 	case DST_MASTRY_ALL:
; 2700 : 		ResetDestParam( DST_MASTRY_EARTH,	nAdjParameterValue, TRUE );
; 2701 : 		ResetDestParam( DST_MASTRY_FIRE,	nAdjParameterValue, TRUE );
; 2702 : 		ResetDestParam( DST_MASTRY_WATER,	nAdjParameterValue, TRUE );
; 2703 : 		ResetDestParam( DST_MASTRY_ELECTRICITY,	nAdjParameterValue, TRUE );
; 2704 : 		ResetDestParam( DST_MASTRY_WIND,	nAdjParameterValue, TRUE );
; 2705 : 		return;
; 2706 : #endif	// __NEWWPN1024
; 2707 : 
; 2708 : 	case DST_HP_RECOVERY_RATE:
; 2709 : 		{
; 2710 : 			int nMax	= GetMaxOriginHitPoint();		//      
; 2711 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2712 : 			ResetDestParam( DST_HP_RECOVERY, nRecv, TRUE );

  000ee	bd 01 00 00 00	 mov	 ebp, 1
  000f3	55		 push	 ebp
  000f4	8b ce		 mov	 ecx, esi
  000f6	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  000fb	89 44 24 1c	 mov	 DWORD PTR tv5232[esp+12], eax
  000ff	db 44 24 1c	 fild	 DWORD PTR tv5232[esp+12]
  00103	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  00107	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0010d	de c9		 fmulp	 ST(1), ST(0)
  0010f	e8 00 00 00 00	 call	 __ftol2
  00114	bb 29 00 00 00	 mov	 ebx, 41			; 00000029H
  00119	e9 09 02 00 00	 jmp	 $L288420
$L276026:

; 2713 : 		}
; 2714 : 		return;
; 2715 : 	case DST_MP_RECOVERY_RATE:
; 2716 : 		{
; 2717 : 			int nMax	= GetMaxOriginManaPoint();		//      
; 2718 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2719 : 			ResetDestParam( DST_MP_RECOVERY, nRecv, TRUE );

  0011e	bd 01 00 00 00	 mov	 ebp, 1
  00123	55		 push	 ebp
  00124	8b ce		 mov	 ecx, esi
  00126	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint
  0012b	89 44 24 1c	 mov	 DWORD PTR tv5228[esp+12], eax
  0012f	db 44 24 1c	 fild	 DWORD PTR tv5228[esp+12]
  00133	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  00137	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0013d	de c9		 fmulp	 ST(1), ST(0)
  0013f	e8 00 00 00 00	 call	 __ftol2
  00144	bb 2a 00 00 00	 mov	 ebx, 42			; 0000002aH
  00149	e9 d9 01 00 00	 jmp	 $L288420
$L276030:

; 2720 : 		}
; 2721 : 		return;
; 2722 : 	case DST_FP_RECOVERY_RATE:
; 2723 : 		{
; 2724 : 			int nMax	= GetMaxOriginFatiguePoint();		//      
; 2725 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2726 : 			ResetDestParam( DST_FP_RECOVERY, nRecv, TRUE );

  0014e	bd 01 00 00 00	 mov	 ebp, 1
  00153	55		 push	 ebp
  00154	8b ce		 mov	 ecx, esi
  00156	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  0015b	89 44 24 1c	 mov	 DWORD PTR tv5224[esp+12], eax
  0015f	db 44 24 1c	 fild	 DWORD PTR tv5224[esp+12]
  00163	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  00167	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  0016d	de c9		 fmulp	 ST(1), ST(0)
  0016f	e8 00 00 00 00	 call	 __ftol2
  00174	bb 2b 00 00 00	 mov	 ebx, 43			; 0000002bH
  00179	e9 a9 01 00 00	 jmp	 $L288420
$L276034:

; 2727 : 		}
; 2728 : 		return;
; 2729 : 	case DST_ALL_RECOVERY:
; 2730 : 		{
; 2731 : 			// HP
; 2732 : 			ResetDestParam( DST_HP_RECOVERY, nAdjParameterValue, TRUE );

  0017e	6a 01		 push	 1
  00180	57		 push	 edi
  00181	6a 29		 push	 41			; 00000029H
  00183	8b ce		 mov	 ecx, esi
  00185	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2733 : 			// MP
; 2734 : 			ResetDestParam( DST_MP_RECOVERY, nAdjParameterValue, TRUE );

  0018a	6a 01		 push	 1
  0018c	57		 push	 edi
  0018d	6a 2a		 push	 42			; 0000002aH
  0018f	8b ce		 mov	 ecx, esi
  00191	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2735 : 			// FP
; 2736 : 			ResetDestParam( DST_FP_RECOVERY, nAdjParameterValue, TRUE );

  00196	bd 01 00 00 00	 mov	 ebp, 1
  0019b	bb 2b 00 00 00	 mov	 ebx, 43			; 0000002bH
  001a0	e9 88 01 00 00	 jmp	 $L288395
$L276035:

; 2737 : 		}
; 2738 : 		return;
; 2739 : 	case DST_ALL_RECOVERY_RATE:
; 2740 : 		{
; 2741 : 			// HP
; 2742 : 			int nMax	= GetMaxOriginHitPoint();		//      
; 2743 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  001a5	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  001a9	6a 01		 push	 1
  001ab	8b ce		 mov	 ecx, esi
  001ad	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  001b3	d9 5c 24 1c	 fstp	 DWORD PTR tv3749[esp+16]
  001b7	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  001bc	89 44 24 1c	 mov	 DWORD PTR tv5219[esp+12], eax
  001c0	db 44 24 1c	 fild	 DWORD PTR tv5219[esp+12]
  001c4	d8 4c 24 18	 fmul	 DWORD PTR tv3749[esp+12]
  001c8	e8 00 00 00 00	 call	 __ftol2

; 2744 : 			ResetDestParam( DST_HP_RECOVERY, nRecv, TRUE );

  001cd	6a 01		 push	 1
  001cf	50		 push	 eax
  001d0	6a 29		 push	 41			; 00000029H
  001d2	8b ce		 mov	 ecx, esi
  001d4	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2745 : 			
; 2746 : 			// MP
; 2747 : 			nMax	= GetMaxOriginManaPoint();		//      

  001d9	6a 01		 push	 1
  001db	8b ce		 mov	 ecx, esi
  001dd	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint

; 2748 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  001e2	89 44 24 1c	 mov	 DWORD PTR tv5215[esp+12], eax
  001e6	db 44 24 1c	 fild	 DWORD PTR tv5215[esp+12]
  001ea	d8 4c 24 18	 fmul	 DWORD PTR tv3749[esp+12]
  001ee	e8 00 00 00 00	 call	 __ftol2

; 2749 : 			ResetDestParam( DST_MP_RECOVERY, nRecv, TRUE );

  001f3	6a 01		 push	 1
  001f5	50		 push	 eax
  001f6	6a 2a		 push	 42			; 0000002aH
  001f8	8b ce		 mov	 ecx, esi
  001fa	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2750 : 			
; 2751 : 			// FP
; 2752 : 			nMax	= GetMaxOriginFatiguePoint();		//      
; 2753 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2754 : 			ResetDestParam( DST_FP_RECOVERY, nRecv, TRUE );

  001ff	bd 01 00 00 00	 mov	 ebp, 1
  00204	55		 push	 ebp
  00205	8b ce		 mov	 ecx, esi
  00207	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  0020c	89 44 24 1c	 mov	 DWORD PTR tv5211[esp+12], eax
  00210	db 44 24 1c	 fild	 DWORD PTR tv5211[esp+12]
  00214	d8 4c 24 18	 fmul	 DWORD PTR tv3749[esp+12]
  00218	e8 00 00 00 00	 call	 __ftol2
  0021d	bb 2b 00 00 00	 mov	 ebx, 43			; 0000002bH
  00222	e9 00 01 00 00	 jmp	 $L288420
$L276042:

; 2765 : 		}
; 2766 : 		return;
; 2767 : 	case DST_KILL_HP_RATE:
; 2768 : 		{
; 2769 : 			int nMax	= GetMaxOriginHitPoint();		//      
; 2770 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2771 : 			ResetDestParam( DST_KILL_HP, nRecv, TRUE );

  00227	bd 01 00 00 00	 mov	 ebp, 1
  0022c	55		 push	 ebp
  0022d	8b ce		 mov	 ecx, esi
  0022f	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  00234	89 44 24 1c	 mov	 DWORD PTR tv5207[esp+12], eax
  00238	db 44 24 1c	 fild	 DWORD PTR tv5207[esp+12]
  0023c	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  00240	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00246	de c9		 fmulp	 ST(1), ST(0)
  00248	e8 00 00 00 00	 call	 __ftol2
  0024d	bb 2c 00 00 00	 mov	 ebx, 44			; 0000002cH
  00252	e9 d0 00 00 00	 jmp	 $L288420
$L276046:

; 2772 : 		}
; 2773 : 		return;
; 2774 : 	case DST_KILL_MP_RATE:
; 2775 : 		{
; 2776 : 			int nMax	= GetMaxOriginManaPoint();		//      
; 2777 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2778 : 			ResetDestParam( DST_KILL_MP, nRecv, TRUE );

  00257	bd 01 00 00 00	 mov	 ebp, 1
  0025c	55		 push	 ebp
  0025d	8b ce		 mov	 ecx, esi
  0025f	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint
  00264	89 44 24 1c	 mov	 DWORD PTR tv5203[esp+12], eax
  00268	db 44 24 1c	 fild	 DWORD PTR tv5203[esp+12]
  0026c	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  00270	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00276	de c9		 fmulp	 ST(1), ST(0)
  00278	e8 00 00 00 00	 call	 __ftol2
  0027d	bb 2d 00 00 00	 mov	 ebx, 45			; 0000002dH
  00282	e9 a0 00 00 00	 jmp	 $L288420
$L276050:

; 2779 : 		}
; 2780 : 		return;
; 2781 : 	case DST_KILL_FP_RATE:
; 2782 : 		{
; 2783 : 			int nMax	= GetMaxOriginFatiguePoint();		//      
; 2784 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2785 : 			ResetDestParam( DST_KILL_FP, nRecv, TRUE );

  00287	bd 01 00 00 00	 mov	 ebp, 1
  0028c	55		 push	 ebp
  0028d	8b ce		 mov	 ecx, esi
  0028f	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  00294	89 44 24 1c	 mov	 DWORD PTR tv5199[esp+12], eax
  00298	db 44 24 1c	 fild	 DWORD PTR tv5199[esp+12]
  0029c	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  002a0	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  002a6	de c9		 fmulp	 ST(1), ST(0)
  002a8	eb 73		 jmp	 SHORT $L288421
$L276054:

; 2786 : 		}
; 2787 : 		return;
; 2788 : 	case DST_KILL_ALL_RATE:
; 2789 : 		{
; 2790 : 			// HP
; 2791 : 			int nMax	= GetMaxOriginHitPoint();		//      
; 2792 : 			int nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  002aa	db 44 24 18	 fild	 DWORD PTR _nAdjParameterValue$[esp+12]
  002ae	6a 01		 push	 1
  002b0	8b ce		 mov	 ecx, esi
  002b2	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  002b8	d9 5c 24 1c	 fstp	 DWORD PTR tv3749[esp+16]
  002bc	e8 00 00 00 00	 call	 ?GetMaxOriginHitPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginHitPoint
  002c1	89 44 24 1c	 mov	 DWORD PTR tv5194[esp+12], eax
  002c5	db 44 24 1c	 fild	 DWORD PTR tv5194[esp+12]
  002c9	d8 4c 24 18	 fmul	 DWORD PTR tv3749[esp+12]
  002cd	e8 00 00 00 00	 call	 __ftol2

; 2793 : 			ResetDestParam( DST_KILL_HP, nRecv, TRUE );

  002d2	6a 01		 push	 1
  002d4	50		 push	 eax
  002d5	6a 2c		 push	 44			; 0000002cH
  002d7	8b ce		 mov	 ecx, esi
  002d9	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2794 : 			// MP
; 2795 : 			nMax	= GetMaxOriginManaPoint();		//      

  002de	6a 01		 push	 1
  002e0	8b ce		 mov	 ecx, esi
  002e2	e8 00 00 00 00	 call	 ?GetMaxOriginManaPoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginManaPoint

; 2796 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );

  002e7	89 44 24 1c	 mov	 DWORD PTR tv5190[esp+12], eax
  002eb	db 44 24 1c	 fild	 DWORD PTR tv5190[esp+12]
  002ef	d8 4c 24 18	 fmul	 DWORD PTR tv3749[esp+12]
  002f3	e8 00 00 00 00	 call	 __ftol2

; 2797 : 			ResetDestParam( DST_KILL_MP, nRecv, TRUE );

  002f8	6a 01		 push	 1
  002fa	50		 push	 eax
  002fb	6a 2d		 push	 45			; 0000002dH
  002fd	8b ce		 mov	 ecx, esi
  002ff	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2798 : 			// FP
; 2799 : 			nMax	= GetMaxOriginFatiguePoint();		//      
; 2800 : 			nRecv	= (int)( (nMax * (nAdjParameterValue / 100.0f)) );
; 2801 : 			ResetDestParam( DST_KILL_FP, nRecv, TRUE );

  00304	bd 01 00 00 00	 mov	 ebp, 1
  00309	55		 push	 ebp
  0030a	8b ce		 mov	 ecx, esi
  0030c	e8 00 00 00 00	 call	 ?GetMaxOriginFatiguePoint@CMover@@QAEHH@Z ; CMover::GetMaxOriginFatiguePoint
  00311	89 44 24 1c	 mov	 DWORD PTR tv5186[esp+12], eax
  00315	db 44 24 1c	 fild	 DWORD PTR tv5186[esp+12]
  00319	d8 4c 24 18	 fmul	 DWORD PTR tv3749[esp+12]
$L288421:
  0031d	e8 00 00 00 00	 call	 __ftol2
  00322	bb 2e 00 00 00	 mov	 ebx, 46			; 0000002eH
$L288420:
  00327	8b f8		 mov	 edi, eax
$L288419:
  00329	89 7c 24 18	 mov	 DWORD PTR _nAdjParameterValue$[esp+12], edi
$L288395:

; 2671 : 	switch( nDstParameter )

  0032d	8d 83 ee d8 ff
	ff		 lea	 eax, DWORD PTR [ebx-10002]
  00333	83 f8 11	 cmp	 eax, 17			; 00000011H
  00336	0f 86 e5 fc ff
	ff		 jbe	 $L288390
  0033c	e9 c1 00 00 00	 jmp	 $L288389
$L276041:

; 2755 : 		}
; 2756 : 		return;
; 2757 : 	case DST_KILL_ALL:	
; 2758 : 		{
; 2759 : 			// HP
; 2760 : 			ResetDestParam( DST_KILL_HP, nAdjParameterValue, TRUE );

  00341	bb 01 00 00 00	 mov	 ebx, 1
  00346	53		 push	 ebx
  00347	57		 push	 edi
  00348	6a 2c		 push	 44			; 0000002cH
  0034a	8b ce		 mov	 ecx, esi
  0034c	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2761 : 			// MP
; 2762 : 			SetDestParam( DST_KILL_MP, nAdjParameterValue, TRUE );

  00351	85 ff		 test	 edi, edi
  00353	74 08		 je	 SHORT $L287145
  00355	01 be 6c 13 00
	00		 add	 DWORD PTR [esi+4972], edi
  0035b	eb 06		 jmp	 SHORT $L287161
$L287145:
  0035d	89 9e 40 15 00
	00		 mov	 DWORD PTR [esi+5440], ebx
$L287161:
  00363	53		 push	 ebx
  00364	57		 push	 edi
  00365	6a 2d		 push	 45			; 0000002dH
  00367	56		 push	 esi
  00368	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  0036d	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam

; 2763 : 			// FP
; 2764 : 			SetDestParam( DST_KILL_FP, nAdjParameterValue, TRUE );

  00372	85 ff		 test	 edi, edi
  00374	74 24		 je	 SHORT $L287472
  00376	8b 86 70 13 00
	00		 mov	 eax, DWORD PTR [esi+4976]
  0037c	53		 push	 ebx
  0037d	57		 push	 edi
  0037e	6a 2e		 push	 46			; 0000002eH
  00380	03 c7		 add	 eax, edi
  00382	56		 push	 esi
  00383	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00388	89 86 70 13 00
	00		 mov	 DWORD PTR [esi+4976], eax
  0038e	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam
  00393	5f		 pop	 edi
  00394	5e		 pop	 esi
  00395	5d		 pop	 ebp
  00396	5b		 pop	 ebx

; 2851 : 	#else	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2852 : 		g_UserMng.AddResetDestParam( this, nDstParameter, nAdjParameterValue );
; 2853 : 	#endif	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2854 : 	}
; 2855 : #endif	// __WORLDSERVER
; 2856 : }

  00397	c2 0c 00	 ret	 12			; 0000000cH

; 2763 : 			// FP
; 2764 : 			SetDestParam( DST_KILL_FP, nAdjParameterValue, TRUE );

$L287472:
  0039a	53		 push	 ebx
  0039b	57		 push	 edi
  0039c	6a 2e		 push	 46			; 0000002eH
  0039e	56		 push	 esi
  0039f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  003a4	89 9e 44 15 00
	00		 mov	 DWORD PTR [esi+5444], ebx
  003aa	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam
  003af	5f		 pop	 edi
  003b0	5e		 pop	 esi
  003b1	5d		 pop	 ebp
  003b2	5b		 pop	 ebx

; 2851 : 	#else	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2852 : 		g_UserMng.AddResetDestParam( this, nDstParameter, nAdjParameterValue );
; 2853 : 	#endif	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2854 : 	}
; 2855 : #endif	// __WORLDSERVER
; 2856 : }

  003b3	c2 0c 00	 ret	 12			; 0000000cH
$L276060:

; 2802 : 		}
; 2803 : 		return;
; 2804 : 	case DST_ALL_DEC_RATE:
; 2805 : 		{
; 2806 : 			SetDestParam( DST_MP_DEC_RATE, nAdjParameterValue, TRUE );

  003b6	85 ff		 test	 edi, edi
  003b8	74 08		 je	 SHORT $L287826
  003ba	01 be dc 13 00
	00		 add	 DWORD PTR [esi+5084], edi
  003c0	eb 0a		 jmp	 SHORT $L287842
$L287826:
  003c2	c7 86 b0 15 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+5552], 1
$L287842:
  003cc	6a 01		 push	 1
  003ce	57		 push	 edi
  003cf	6a 49		 push	 73			; 00000049H
  003d1	56		 push	 esi
  003d2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  003d7	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam

; 2807 : 			SetDestParam( DST_FP_DEC_RATE, nAdjParameterValue, TRUE );

  003dc	85 ff		 test	 edi, edi
  003de	74 08		 je	 SHORT $L288372
  003e0	01 be e0 13 00
	00		 add	 DWORD PTR [esi+5088], edi
  003e6	eb 0a		 jmp	 SHORT $L288388
$L288372:
  003e8	c7 86 b4 15 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+5556], 1
$L288388:
  003f2	6a 01		 push	 1
  003f4	57		 push	 edi
  003f5	6a 4a		 push	 74			; 0000004aH
  003f7	56		 push	 esi
  003f8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  003fd	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam
$L288389:

; 2808 : 		}
; 2809 : 	}
; 2810 : 
; 2811 : 
; 2812 : 	//       
; 2813 : 	// DST_GOLD, PXP, RESIST_ALL MAX_ADJPARAMARY   . 
; 2814 : 	//      
; 2815 : 	//   .
; 2816 : 	
; 2817 : 	if( nDstParameter >= MAX_ADJPARAMARY || nDstParameter < 0 )

  00402	83 fb 75	 cmp	 ebx, 117		; 00000075H
  00405	0f 8d 90 00 00
	00		 jge	 $L276073
  0040b	85 db		 test	 ebx, ebx
  0040d	0f 8c 88 00 00
	00		 jl	 $L276073

; 2818 : 	{
; 2819 : //		Error( "ResetDestParam %s :   nDstParam : %d", m_szName, nDstParameter );
; 2820 : 		return;
; 2821 : 	}
; 2822 : 	if( nAdjParameterValue != 0 ) 

  00413	85 ff		 test	 edi, edi
  00415	74 22		 je	 SHORT $L288396

; 2823 : 	{
; 2824 : 		if( nDstParameter == DST_CHRSTATE )

  00417	83 fb 40	 cmp	 ebx, 64			; 00000040H
  0041a	75 14		 jne	 SHORT $L276064

; 2825 : 			m_adjParamAry[nDstParameter] &= (~nAdjParameterValue);		//  .

  0041c	8b 8e b8 13 00
	00		 mov	 ecx, DWORD PTR [esi+5048]
  00422	8b c7		 mov	 eax, edi
  00424	f7 d0		 not	 eax
  00426	23 c8		 and	 ecx, eax
  00428	89 8e b8 13 00
	00		 mov	 DWORD PTR [esi+5048], ecx

; 2826 : 		else

  0042e	eb 39		 jmp	 SHORT $L276069
$L276064:

; 2827 : 			m_adjParamAry[nDstParameter] += (-nAdjParameterValue);

  00430	29 bc 9e b8 12
	00 00		 sub	 DWORD PTR [esi+ebx*4+4792], edi

; 2828 : 	}
; 2829 : 
; 2830 : 	// 
; 2831 : 	if( nAdjParameterValue == 0 )	//

  00437	eb 30		 jmp	 SHORT $L276069
$L288396:

; 2832 : 	{
; 2833 : 		if( nDstParameter == DST_SPEED && m_chgParamAry[nDstParameter] != 0x7FFFFFFF && m_chgParamAry[nDstParameter] > 0 )

  00439	83 fb 0b	 cmp	 ebx, 11			; 0000000bH
  0043c	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00441	75 1f		 jne	 SHORT $L276067
  00443	8b 86 b8 14 00
	00		 mov	 eax, DWORD PTR [esi+5304]
  00449	3b c1		 cmp	 eax, ecx
  0044b	74 15		 je	 SHORT $L276067
  0044d	85 c0		 test	 eax, eax
  0044f	7e 11		 jle	 SHORT $L276067

; 2834 : 		{
; 2835 : 			if( --m_chgParamAry[nDstParameter] == 0 )

  00451	48		 dec	 eax
  00452	89 86 b8 14 00
	00		 mov	 DWORD PTR [esi+5304], eax
  00458	75 0f		 jne	 SHORT $L276069

; 2836 : 				m_chgParamAry[nDstParameter]		= 0x7FFFFFFF;

  0045a	89 8e b8 14 00
	00		 mov	 DWORD PTR [esi+5304], ecx

; 2837 : 		}
; 2838 : 		else

  00460	eb 07		 jmp	 SHORT $L276069
$L276067:

; 2839 : 		{
; 2840 : 			m_chgParamAry[nDstParameter]		= 0x7FFFFFFF;

  00462	89 8c 9e 8c 14
	00 00		 mov	 DWORD PTR [esi+ebx*4+5260], ecx
$L276069:

; 2841 : 		}
; 2842 : 	}
; 2843 : #ifdef __WORLDSERVER
; 2844 : 	if( fSend == TRUE ) 

  00469	83 fd 01	 cmp	 ebp, 1
  0046c	75 2d		 jne	 SHORT $L276073

; 2845 : 	{
; 2846 : 	#ifdef	__SPEED_SYNC_0108 // ResetDestParam speed 
; 2847 : 		if( nDstParameter == DST_SPEED )

  0046e	83 fb 0b	 cmp	 ebx, 11			; 0000000bH
  00471	75 1b		 jne	 SHORT $L276071

; 2848 : 			g_UserMng.AddResetDestParamSync( this, nDstParameter, nAdjParameterValue, (int)m_adjParamAry[nDstParameter] );

  00473	8b 8e e4 12 00
	00		 mov	 ecx, DWORD PTR [esi+4836]
  00479	51		 push	 ecx
  0047a	57		 push	 edi
  0047b	53		 push	 ebx
  0047c	56		 push	 esi
  0047d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00482	e8 00 00 00 00	 call	 ?AddResetDestParamSync@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddResetDestParamSync
  00487	5f		 pop	 edi
  00488	5e		 pop	 esi
  00489	5d		 pop	 ebp
  0048a	5b		 pop	 ebx

; 2851 : 	#else	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2852 : 		g_UserMng.AddResetDestParam( this, nDstParameter, nAdjParameterValue );
; 2853 : 	#endif	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2854 : 	}
; 2855 : #endif	// __WORLDSERVER
; 2856 : }

  0048b	c2 0c 00	 ret	 12			; 0000000cH
$L276071:

; 2849 : 		else
; 2850 : 			g_UserMng.AddResetDestParam( this, nDstParameter, nAdjParameterValue );

  0048e	57		 push	 edi
  0048f	53		 push	 ebx
  00490	56		 push	 esi
  00491	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00496	e8 00 00 00 00	 call	 ?AddResetDestParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddResetDestParam
$L276073:
  0049b	5f		 pop	 edi
  0049c	5e		 pop	 esi
  0049d	5d		 pop	 ebp
  0049e	5b		 pop	 ebx

; 2851 : 	#else	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2852 : 		g_UserMng.AddResetDestParam( this, nDstParameter, nAdjParameterValue );
; 2853 : 	#endif	// 	__SPEED_SYNC_0108 ResetDestParam speed 
; 2854 : 	}
; 2855 : #endif	// __WORLDSERVER
; 2856 : }

  0049f	c2 0c 00	 ret	 12			; 0000000cH
  004a2	8b ff		 npad	 2
$L288422:
  004a4	00 00 00 00	 DD	 $L276017
  004a8	00 00 00 00	 DD	 $L276018
  004ac	00 00 00 00	 DD	 $L276019
  004b0	00 00 00 00	 DD	 $L276020
  004b4	00 00 00 00	 DD	 $L288389
  004b8	00 00 00 00	 DD	 $L276022
  004bc	00 00 00 00	 DD	 $L276026
  004c0	00 00 00 00	 DD	 $L276030
  004c4	00 00 00 00	 DD	 $L276021
  004c8	00 00 00 00	 DD	 $L288389
  004cc	00 00 00 00	 DD	 $L276034
  004d0	00 00 00 00	 DD	 $L276035
  004d4	00 00 00 00	 DD	 $L276041
  004d8	00 00 00 00	 DD	 $L276042
  004dc	00 00 00 00	 DD	 $L276046
  004e0	00 00 00 00	 DD	 $L276050
  004e4	00 00 00 00	 DD	 $L276054
  004e8	00 00 00 00	 DD	 $L276060
?ResetDestParam@CMover@@QAEXHHH@Z ENDP			; CMover::ResetDestParam
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator->
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 322  : 			return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBKPAVIBuff@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogty
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 214  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 215  : 			_Inc();

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 217  : 			}

  0000b	c3		 ret	 0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 457  : 		_Tidy(true);

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  00007	72 0c		 jb	 SHORT $L288480
  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$L288480:
  00015	33 c0		 xor	 eax, eax
  00017	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0001e	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00021	88 46 04	 mov	 BYTE PTR [esi+4], al
  00024	5e		 pop	 esi

; 458  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::find
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
$T288503 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::find, COMDAT
; _this$ = ecx

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

  00000	51		 push	 ecx

; 788  : 		iterator _Where = lower_bound(_Keyval);

  00001	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	53		 push	 ebx
  00008	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  0000b	84 db		 test	 bl, bl
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 18	 mov	 edi, DWORD PTR __Keyval$[esp+12]
  00013	75 17		 jne	 SHORT $L288580
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$L288579:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	7d 05		 jge	 SHORT $L288581
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $L288582
$L288581:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$L288582:
  00025	8a 58 15	 mov	 bl, BYTE PTR [eax+21]
  00028	84 db		 test	 bl, bl
  0002a	74 eb		 je	 SHORT $L288579
$L288580:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	3b d0		 cmp	 edx, eax
  00031	89 54 24 18	 mov	 DWORD PTR __Where$[esp+12], edx
  00035	74 1a		 je	 SHORT $L288502
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003c	7c 13		 jl	 SHORT $L288502
  0003e	8d 44 24 18	 lea	 eax, DWORD PTR __Where$[esp+12]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 10		 mov	 DWORD PTR [eax], edx
  0004c	5b		 pop	 ebx

; 791  : 		}

  0004d	59		 pop	 ecx
  0004e	c2 08 00	 ret	 8
$L288502:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

  00051	89 44 24 0c	 mov	 DWORD PTR $T288503[esp+16], eax
  00055	8d 44 24 0c	 lea	 eax, DWORD PTR $T288503[esp+16]
  00059	8b 10		 mov	 edx, DWORD PTR [eax]
  0005b	8b 44 24 14	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+12]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	89 10		 mov	 DWORD PTR [eax], edx
  00063	5b		 pop	 ebx

; 791  : 		}

  00064	59		 pop	 ecx
  00065	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::find
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 1481 : 		if (max_size() < _Newsize)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR __Newsize$[esp+4]
  00006	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00009	8b e9		 mov	 ebp, ecx
  0000b	76 05		 jbe	 SHORT $L221380

; 1482 : 			_String_base::_Xlen();	// result too long

  0000d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L221380:

; 1483 : 		if (_Myres < _Newsize)

  00012	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00015	3b c6		 cmp	 eax, esi
  00017	73 19		 jae	 SHORT $L221381

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  00019	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  0001c	50		 push	 eax
  0001d	56		 push	 esi
  0001e	8b cd		 mov	 ecx, ebp
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  00025	33 c0		 xor	 eax, eax
  00027	3b c6		 cmp	 eax, esi
  00029	1b c0		 sbb	 eax, eax
  0002b	5e		 pop	 esi
  0002c	f7 d8		 neg	 eax
  0002e	5d		 pop	 ebp

; 1491 : 		}

  0002f	c2 08 00	 ret	 8
$L221381:

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  00032	8a 4c 24 10	 mov	 cl, BYTE PTR __Trim$[esp+4]
  00036	84 c9		 test	 cl, cl
  00038	74 5c		 je	 SHORT $L221383
  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0003d	73 57		 jae	 SHORT $L221383
  0003f	53		 push	 ebx

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  00040	8b 5d 14	 mov	 ebx, DWORD PTR [ebp+20]
  00043	3b f3		 cmp	 esi, ebx
  00045	73 02		 jae	 SHORT $L288665
  00047	8b de		 mov	 ebx, esi
$L288665:
  00049	83 f8 10	 cmp	 eax, 16			; 00000010H
  0004c	72 2b		 jb	 SHORT $L288719
  0004e	85 db		 test	 ebx, ebx
  00050	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00053	57		 push	 edi
  00054	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  00057	76 16		 jbe	 SHORT $L288717
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b d1		 mov	 edx, ecx
  0005d	c1 e9 02	 shr	 ecx, 2
  00060	8b f0		 mov	 esi, eax
  00062	f3 a5		 rep movsd
  00064	8b ca		 mov	 ecx, edx
  00066	83 e1 03	 and	 ecx, 3
  00069	f3 a4		 rep movsb
  0006b	8b 74 24 14	 mov	 esi, DWORD PTR __Newsize$[esp+12]
$L288717:
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00075	83 c4 04	 add	 esp, 4
  00078	5f		 pop	 edi
$L288719:
  00079	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0007c	33 c0		 xor	 eax, eax
  0007e	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00085	c6 44 2b 04 00	 mov	 BYTE PTR [ebx+ebp+4], 0
  0008a	3b c6		 cmp	 eax, esi
  0008c	5b		 pop	 ebx
  0008d	1b c0		 sbb	 eax, eax
  0008f	5e		 pop	 esi
  00090	f7 d8		 neg	 eax
  00092	5d		 pop	 ebp

; 1491 : 		}

  00093	c2 08 00	 ret	 8
$L221383:

; 1488 : 		else if (_Newsize == 0)

  00096	85 f6		 test	 esi, esi
  00098	75 23		 jne	 SHORT $L288756

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  0009a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0009d	89 75 14	 mov	 DWORD PTR [ebp+20], esi
  000a0	72 14		 jb	 SHORT $L288754
  000a2	8b 6d 04	 mov	 ebp, DWORD PTR [ebp+4]

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000a5	33 c0		 xor	 eax, eax
  000a7	3b c6		 cmp	 eax, esi
  000a9	1b c0		 sbb	 eax, eax
  000ab	5e		 pop	 esi
  000ac	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  000b0	f7 d8		 neg	 eax
  000b2	5d		 pop	 ebp

; 1491 : 		}

  000b3	c2 08 00	 ret	 8

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

$L288754:
  000b6	83 c5 04	 add	 ebp, 4
  000b9	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
$L288756:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  000bd	33 c0		 xor	 eax, eax
  000bf	3b c6		 cmp	 eax, esi
  000c1	1b c0		 sbb	 eax, eax
  000c3	5e		 pop	 esi
  000c4	f7 d8		 neg	 eax
  000c6	5d		 pop	 ebp

; 1491 : 		}

  000c7	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?IncHitPoint@CMover@@QAEXH@Z			; CMover::IncHitPoint
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
;	COMDAT ?IncHitPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nVal$ = 8						; size = 4
?IncHitPoint@CMover@@QAEXH@Z PROC NEAR			; CMover::IncHitPoint, COMDAT
; _this$ = ecx

; 606  : 	SetPointParam( DST_HP, m_nHitPoint + nVal );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nVal$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b b7 00 06 00
	00		 mov	 esi, DWORD PTR [edi+1536]
  0000f	03 f0		 add	 esi, eax
  00011	8b de		 mov	 ebx, esi
  00013	79 02		 jns	 SHORT $L288769
  00015	33 f6		 xor	 esi, esi
$L288769:
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  0001e	3b f0		 cmp	 esi, eax
  00020	7f 08		 jg	 SHORT $L288775
  00022	81 fb ff c9 9a
	3b		 cmp	 ebx, 999999999		; 3b9ac9ffH
  00028	75 09		 jne	 SHORT $L288774
$L288775:
  0002a	8b cf		 mov	 ecx, edi
  0002c	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint
  00031	8b f0		 mov	 esi, eax
$L288774:
  00033	39 b7 00 06 00
	00		 cmp	 DWORD PTR [edi+1536], esi
  00039	74 14		 je	 SHORT $L288786
  0003b	56		 push	 esi
  0003c	6a 26		 push	 38			; 00000026H
  0003e	57		 push	 edi
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00044	89 b7 00 06 00
	00		 mov	 DWORD PTR [edi+1536], esi
  0004a	e8 00 00 00 00	 call	 ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddSetPointParam
$L288786:
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 607  : }

  00052	c2 04 00	 ret	 4
?IncHitPoint@CMover@@QAEXH@Z ENDP			; CMover::IncHitPoint
_TEXT	ENDS
PUBLIC	?IncManaPoint@CMover@@QAEXH@Z			; CMover::IncManaPoint
; Function compile flags: /Ogty
;	COMDAT ?IncManaPoint@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nVal$ = 8						; size = 4
?IncManaPoint@CMover@@QAEXH@Z PROC NEAR			; CMover::IncManaPoint, COMDAT
; _this$ = ecx

; 610  : { 

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 611  : #ifdef __WORLDSERVER 			
; 612  : 	if( IsSMMode( SM_MAINTAIN_MP ) && nVal < 0 )

  00003	8b 87 1c 03 00
	00		 mov	 eax, DWORD PTR [edi+796]
  00009	85 c0		 test	 eax, eax
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR _nVal$[esp]
  0000f	76 04		 jbe	 SHORT $L275354
  00011	85 c0		 test	 eax, eax
  00013	7c 4a		 jl	 SHORT $L288828
$L275354:
  00015	53		 push	 ebx
  00016	56		 push	 esi

; 613  : 		return;
; 614  : #ifdef __EVENT1206
; 615  : 	if( IsPlayer() && g_eLocal.GetState( EVE_EVENT1206 ) ) //  raiders_fix051217
; 616  : 		return;
; 617  : #endif	// __EVENT1206
; 618  : #endif // __WORLDSERVER
; 619  : 	SetPointParam( DST_MP, m_nManaPoint + nVal );

  00017	8b b7 04 06 00
	00		 mov	 esi, DWORD PTR [edi+1540]
  0001d	03 f0		 add	 esi, eax
  0001f	8b de		 mov	 ebx, esi
  00021	79 02		 jns	 SHORT $L288807
  00023	33 f6		 xor	 esi, esi
$L288807:
  00025	8b cf		 mov	 ecx, edi
  00027	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  0002c	3b f0		 cmp	 esi, eax
  0002e	7f 08		 jg	 SHORT $L288817
  00030	81 fb ff c9 9a
	3b		 cmp	 ebx, 999999999		; 3b9ac9ffH
  00036	75 09		 jne	 SHORT $L288816
$L288817:
  00038	8b cf		 mov	 ecx, edi
  0003a	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint
  0003f	8b f0		 mov	 esi, eax
$L288816:
  00041	39 b7 04 06 00
	00		 cmp	 DWORD PTR [edi+1540], esi
  00047	74 14		 je	 SHORT $L288832
  00049	56		 push	 esi
  0004a	6a 27		 push	 39			; 00000027H
  0004c	57		 push	 edi
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00052	89 b7 04 06 00
	00		 mov	 DWORD PTR [edi+1540], esi
  00058	e8 00 00 00 00	 call	 ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddSetPointParam
$L288832:
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
$L288828:
  0005f	5f		 pop	 edi

; 620  : }

  00060	c2 04 00	 ret	 4
?IncManaPoint@CMover@@QAEXH@Z ENDP			; CMover::IncManaPoint
_TEXT	ENDS
PUBLIC	?IncFatiguePoint@CMover@@QAEXH@Z		; CMover::IncFatiguePoint
; Function compile flags: /Ogty
;	COMDAT ?IncFatiguePoint@CMover@@QAEXH@Z
_TEXT	SEGMENT
_nVal$ = 8						; size = 4
?IncFatiguePoint@CMover@@QAEXH@Z PROC NEAR		; CMover::IncFatiguePoint, COMDAT
; _this$ = ecx

; 623  : { 

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 624  : #ifdef __WORLDSERVER
; 625  : 	if( IsSMMode( SM_MAINTAIN_FP ) && nVal < 0 )

  00003	8b 87 20 03 00
	00		 mov	 eax, DWORD PTR [edi+800]
  00009	85 c0		 test	 eax, eax
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR _nVal$[esp]
  0000f	76 04		 jbe	 SHORT $L275359
  00011	85 c0		 test	 eax, eax
  00013	7c 4a		 jl	 SHORT $L288863
$L275359:
  00015	53		 push	 ebx
  00016	56		 push	 esi

; 626  : 		return;
; 627  : #ifdef __EVENT1206
; 628  : 	if( IsPlayer() && g_eLocal.GetState( EVE_EVENT1206 ) )	// raiders_fix051217
; 629  : 		return;
; 630  : #endif	// __EVENT1206
; 631  : #endif // __WORLDSERVER
; 632  : 	SetPointParam( DST_FP, m_nFatiguePoint + nVal );

  00017	8b b7 08 06 00
	00		 mov	 esi, DWORD PTR [edi+1544]
  0001d	03 f0		 add	 esi, eax
  0001f	8b de		 mov	 ebx, esi
  00021	79 02		 jns	 SHORT $L288846
  00023	33 f6		 xor	 esi, esi
$L288846:
  00025	8b cf		 mov	 ecx, edi
  00027	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  0002c	3b f0		 cmp	 esi, eax
  0002e	7f 08		 jg	 SHORT $L288860
  00030	81 fb ff c9 9a
	3b		 cmp	 ebx, 999999999		; 3b9ac9ffH
  00036	75 09		 jne	 SHORT $L288859
$L288860:
  00038	8b cf		 mov	 ecx, edi
  0003a	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint
  0003f	8b f0		 mov	 esi, eax
$L288859:
  00041	39 b7 08 06 00
	00		 cmp	 DWORD PTR [edi+1544], esi
  00047	74 14		 je	 SHORT $L288870
  00049	56		 push	 esi
  0004a	6a 28		 push	 40			; 00000028H
  0004c	57		 push	 edi
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00052	89 b7 08 06 00
	00		 mov	 DWORD PTR [edi+1544], esi
  00058	e8 00 00 00 00	 call	 ?AddSetPointParam@CUserMng@@QAEXPAVCMover@@HH@Z ; CUserMng::AddSetPointParam
$L288870:
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
$L288863:
  0005f	5f		 pop	 edi

; 633  : }

  00060	c2 04 00	 ret	 4
?IncFatiguePoint@CMover@@QAEXH@Z ENDP			; CMover::IncFatiguePoint
_TEXT	ENDS
PUBLIC	?SetDarkCover@CMover@@QAEHHK@Z			; CMover::SetDarkCover
PUBLIC	__real@3a83126f
PUBLIC	__real@41700000
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetDarkCover@CMover@@QAEHHK@Z
_TEXT	SEGMENT
tv1310 = 8						; size = 4
_bApply$ = 8						; size = 4
_tmMaxTime$ = 12					; size = 4
?SetDarkCover@CMover@@QAEHHK@Z PROC NEAR		; CMover::SetDarkCover, COMDAT
; _this$ = ecx

; 2150 : 	if( bApply )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bApply$[esp-4]
  00004	56		 push	 esi
  00005	85 c0		 test	 eax, eax
  00007	8b f1		 mov	 esi, ecx

; 2151 : 	{
; 2152 : 		if( GetAdjParam( DST_IMMUNITY ) & CHS_INVISIBILITY )	//  .... ?

  00009	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  0000e	74 62		 je	 SHORT $L275800
  00010	85 86 ac 13 00
	00		 test	 DWORD PTR [esi+5036], eax
  00016	74 06		 je	 SHORT $L275801

; 2153 : 			return FALSE;	

  00018	33 c0		 xor	 eax, eax
  0001a	5e		 pop	 esi

; 2166 : }

  0001b	c2 08 00	 ret	 8
$L275801:

; 2154 : 		SetDestParam( DST_CHRSTATE, CHS_INVISIBILITY, NULL_CHGPARAM );

  0001e	8b 96 b8 13 00
	00		 mov	 edx, DWORD PTR [esi+5048]
  00024	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00029	50		 push	 eax
  0002a	6a 40		 push	 64			; 00000040H
  0002c	0b d0		 or	 edx, eax
  0002e	56		 push	 esi
  0002f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00034	89 96 b8 13 00
	00		 mov	 DWORD PTR [esi+5048], edx
  0003a	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam

; 2155 : 		m_wDarkCover =	(short)( (tmMaxTime / 1000.0f) * PROCESS_COUNT );

  0003f	db 44 24 0c	 fild	 DWORD PTR _tmMaxTime$[esp]
  00043	8b 44 24 0c	 mov	 eax, DWORD PTR _tmMaxTime$[esp]
  00047	85 c0		 test	 eax, eax
  00049	7d 06		 jge	 SHORT $L289301
  0004b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L289301:
  00051	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a83126f
  00057	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41700000
  0005d	e8 00 00 00 00	 call	 __ftol2
  00062	66 89 86 da 06
	00 00		 mov	 WORD PTR [esi+1754], ax

; 2163 : 	}
; 2164 : 
; 2165 : 	return TRUE;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	5e		 pop	 esi

; 2166 : }

  0006f	c2 08 00	 ret	 8
$L275800:

; 2156 : 	} else
; 2157 : 	{
; 2158 : 		if( GetAdjParam( DST_CHRSTATE) & CHS_INVISIBILITY )

  00072	85 86 b8 13 00
	00		 test	 DWORD PTR [esi+5048], eax
  00078	74 0c		 je	 SHORT $L275804

; 2159 : 		{
; 2160 : 			ResetDestParam( DST_CHRSTATE, CHS_INVISIBILITY, TRUE );		// 

  0007a	6a 01		 push	 1
  0007c	50		 push	 eax
  0007d	6a 40		 push	 64			; 00000040H
  0007f	8b ce		 mov	 ecx, esi
  00081	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L275804:

; 2161 : 		}
; 2162 : 		m_wDarkCover = 0;

  00086	66 c7 86 da 06
	00 00 00 00	 mov	 WORD PTR [esi+1754], 0

; 2163 : 	}
; 2164 : 
; 2165 : 	return TRUE;

  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	5e		 pop	 esi

; 2166 : }

  00095	c2 08 00	 ret	 8
?SetDarkCover@CMover@@QAEHHK@Z ENDP			; CMover::SetDarkCover
_TEXT	ENDS
PUBLIC	?SetStun@CMover@@QAEHHK@Z			; CMover::SetStun
EXTRN	?AddSetStun@CUserMng@@QAEXPAVCMover@@H@Z:NEAR	; CUserMng::AddSetStun
; Function compile flags: /Ogty
;	COMDAT ?SetStun@CMover@@QAEHHK@Z
_TEXT	SEGMENT
tv1369 = 8						; size = 4
_bApply$ = 8						; size = 4
_tmMaxTime$ = 12					; size = 4
?SetStun@CMover@@QAEHHK@Z PROC NEAR			; CMover::SetStun, COMDAT
; _this$ = ecx

; 2171 : 	if( bApply )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bApply$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7c 24 10	 mov	 edi, DWORD PTR _tmMaxTime$[esp+4]
  0000c	8b f1		 mov	 esi, ecx
  0000e	0f 84 ad 00 00
	00		 je	 $L275810

; 2172 : 	{
; 2173 : 		MoverProp *pMoverProp = GetProp();

  00014	8b 86 74 01 00
	00		 mov	 eax, DWORD PTR [esi+372]
  0001a	85 c0		 test	 eax, eax
  0001c	8b 0d d0 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+464
  00022	7c 14		 jl	 SHORT $L289331
  00024	3b c1		 cmp	 eax, ecx
  00026	7d 10		 jge	 SHORT $L289331
  00028	8b 0d d4 01 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+468
  0002e	69 c0 d8 06 00
	00		 imul	 eax, 1752		; 000006d8H
  00034	03 c1		 add	 eax, ecx
  00036	eb 18		 jmp	 SHORT $L289326
$L289331:
  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	6a 00		 push	 0
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GKPOBPPI@GetMoverProp?5range_error?$AA@
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  00046	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0004b	83 c4 14	 add	 esp, 20			; 00000014H
  0004e	33 c0		 xor	 eax, eax
$L289326:

; 2174 : 		if( pMoverProp->dwClass == RANK_SUPER || pMoverProp->dwClass == RANK_MIDBOSS )

  00050	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  00056	83 f8 07	 cmp	 eax, 7
  00059	74 14		 je	 SHORT $L275813
  0005b	83 f8 05	 cmp	 eax, 5
  0005e	74 0f		 je	 SHORT $L275813

; 2175 : 			return FALSE;			//   .       .
; 2176 : 
; 2177 : 		if( GetAdjParam( DST_IMMUNITY ) & CHS_STUN ) 

  00060	8a 8e ac 13 00
	00		 mov	 cl, BYTE PTR [esi+5036]
  00066	b8 08 00 00 00	 mov	 eax, 8
  0006b	84 c8		 test	 cl, al
  0006d	74 07		 je	 SHORT $L275814
$L275813:
  0006f	5f		 pop	 edi

; 2178 : 			return FALSE;		//  .

  00070	33 c0		 xor	 eax, eax
  00072	5e		 pop	 esi

; 2197 : }

  00073	c2 08 00	 ret	 8
$L275814:

; 2179 : 
; 2180 : 		SetDestParam( DST_CHRSTATE, CHS_STUN, NULL_CHGPARAM, FALSE );

  00076	8b 96 b8 13 00
	00		 mov	 edx, DWORD PTR [esi+5048]

; 2181 : 		SendActMsg( OBJMSG_STUN );		//   .

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	0b d0		 or	 edx, eax
  00086	6a 10		 push	 16			; 00000010H
  00088	8b ce		 mov	 ecx, esi
  0008a	89 96 b8 13 00
	00		 mov	 DWORD PTR [esi+5048], edx
  00090	e8 00 00 00 00	 call	 ?SendActMsg@CMover@@QAEHW4OBJMSG@@HHHH@Z ; CMover::SendActMsg

; 2182 : 		m_wStunCnt = (short)( (tmMaxTime / 1000.0f) * PROCESS_COUNT );		//   .

  00095	85 ff		 test	 edi, edi
  00097	89 7c 24 0c	 mov	 DWORD PTR tv1369[esp+4], edi
  0009b	db 44 24 0c	 fild	 DWORD PTR tv1369[esp+4]
  0009f	7d 06		 jge	 SHORT $L289761
  000a1	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L289761:
  000a7	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a83126f
  000ad	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41700000
  000b3	e8 00 00 00 00	 call	 __ftol2
  000b8	66 89 86 cc 06
	00 00		 mov	 WORD PTR [esi+1740], ax

; 2183 : 	}
; 2184 : 	else

  000bf	eb 35		 jmp	 SHORT $L275816
$L275810:

; 2185 : 	{
; 2186 : 		if( GetAdjParam( DST_CHRSTATE ) & CHS_STUN )	//     ResetDestParam .

  000c1	8a 8e b8 13 00
	00		 mov	 cl, BYTE PTR [esi+5048]
  000c7	b8 08 00 00 00	 mov	 eax, 8
  000cc	84 c8		 test	 cl, al
  000ce	74 0c		 je	 SHORT $L275817

; 2187 : 			ResetDestParam( DST_CHRSTATE, CHS_STUN, FALSE);	//   .

  000d0	6a 00		 push	 0
  000d2	50		 push	 eax
  000d3	6a 40		 push	 64			; 00000040H
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L275817:

; 2188 : 		m_wStunCnt = 0;
; 2189 : 		m_dwFlag &= (~MVRF_NOACTION);				//    .

  000dc	8b 86 48 02 00
	00		 mov	 eax, DWORD PTR [esi+584]
  000e2	25 ff f8 ff ff	 and	 eax, -1793		; fffff8ffH
  000e7	66 c7 86 cc 06
	00 00 00 00	 mov	 WORD PTR [esi+1740], 0
  000f0	89 86 48 02 00
	00		 mov	 DWORD PTR [esi+584], eax
$L275816:

; 2190 : 	}
; 2191 : 
; 2192 : #ifdef __WORLDSERVER
; 2193 : 	g_UserMng.AddSetStun( this, tmMaxTime );

  000f6	57		 push	 edi
  000f7	56		 push	 esi
  000f8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000fd	e8 00 00 00 00	 call	 ?AddSetStun@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddSetStun
  00102	5f		 pop	 edi

; 2194 : #endif // Worldserver
; 2195 : 
; 2196 : 	return TRUE;

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	5e		 pop	 esi

; 2197 : }

  00109	c2 08 00	 ret	 8
?SetStun@CMover@@QAEHHK@Z ENDP				; CMover::SetStun
_TEXT	ENDS
PUBLIC	?SetPoison@CMover@@QAEHHKKKF@Z			; CMover::SetPoison
PUBLIC	??_C@_0DB@PFHOFKCA@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S?$LN?C?$LA?$KD@ ; `string'
PUBLIC	??_C@_0DC@FNFHKMOG@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5tick?5?$LN?C?$LA@ ; `string'
PUBLIC	??_C@_0DE@BJJIDPPP@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g?5?$LF?$KF?$LJ@ ; `string'
;	COMDAT ??_C@_0DB@PFHOFKCA@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S?$LN?C?$LA?$KD@
CONST	SEGMENT
??_C@_0DB@PFHOFKCA@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S?$LN?C?$LA?$KD@ DB 'S'
	DB	'etPoison : %s ', 0b5H, 0b6H, 0c8H, 0bfH, 0b0H, 0faH, 0c0H, 0c7H
	DB	' ', 0c1H, 0f6H, 0bcH, 0d3H, 0bdH, 0c3H, 0b0H, 0a3H, 0c0H, 0ccH
	DB	' ', 0c1H, 0f6H, 0c1H, 0a4H, 0b5H, 0c7H, 0c1H, 0f6H, ' ', 0beH
	DB	0caH, 0c0H, 0bdH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FNFHKMOG@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5tick?5?$LN?C?$LA@
CONST	SEGMENT
??_C@_0DC@FNFHKMOG@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5tick?5?$LN?C?$LA@ DB 'S'
	DB	'etPoison : %s ', 0b5H, 0b6H, 0c8H, 0bfH, 0b0H, 0faH, 0c0H, 0c7H
	DB	' tick ', 0bdH, 0c3H, 0b0H, 0a3H, 0c0H, 0ccH, ' ', 0c1H, 0f6H, 0c1H
	DB	0a4H, 0b5H, 0c7H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0c0H, 0bdH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BJJIDPPP@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g?5?$LF?$KF?$LJ@
CONST	SEGMENT
??_C@_0DE@BJJIDPPP@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g?5?$LF?$KF?$LJ@ DB 'S'
	DB	'etPoison : %s ', 0b5H, 0b6H, 0c8H, 0bfH, 0b0H, 0faH, 0c0H, 0c7H
	DB	' ', 0c6H, 0bdH, 0b4H, 0e7H, ' ', 0b5H, 0a5H, 0b9H, 0ccH, 0c1H
	DB	0f6H, 0b0H, 0a1H, ' ', 0c1H, 0f6H, 0c1H, 0a4H, 0b5H, 0c7H, 0c1H
	DB	0f6H, ' ', 0beH, 0caH, 0c0H, 0bdH, 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetPoison@CMover@@QAEHHKKKF@Z
_TEXT	SEGMENT
_bApply$ = 8						; size = 4
_idAttacker$ = 12					; size = 4
_tmMaxTime$ = 16					; size = 4
_tmUnit$ = 20						; size = 4
tv1359 = 24						; size = 4
_wDamage$ = 24						; size = 2
?SetPoison@CMover@@QAEHHKKKF@Z PROC NEAR		; CMover::SetPoison, COMDAT
; _this$ = ecx

; 2207 : 	if( bApply )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bApply$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	3b c7		 cmp	 eax, edi
  0000a	8b f1		 mov	 esi, ecx

; 2208 : 	{
; 2209 : 		if( GetAdjParam( DST_IMMUNITY ) & CHS_POISON ) 

  0000c	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  00011	0f 84 df 00 00
	00		 je	 $L275826
  00017	85 86 ac 13 00
	00		 test	 DWORD PTR [esi+5036], eax
  0001d	74 07		 je	 SHORT $L275827
  0001f	5f		 pop	 edi

; 2210 : 			return FALSE;		//  .

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 2233 : }

  00023	c2 14 00	 ret	 20			; 00000014H
$L275827:

; 2211 : 		SetDestParam( DST_CHRSTATE, CHS_POISON, NULL_CHGPARAM );

  00026	8b 8e b8 13 00
	00		 mov	 ecx, DWORD PTR [esi+5048]
  0002c	53		 push	 ebx
  0002d	55		 push	 ebp
  0002e	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00033	50		 push	 eax
  00034	0b c8		 or	 ecx, eax
  00036	6a 40		 push	 64			; 00000040H
  00038	89 8e b8 13 00
	00		 mov	 DWORD PTR [esi+5048], ecx
  0003e	56		 push	 esi
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00044	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam

; 2212 : 		if( tmMaxTime == -1 )

  00049	8b 6c 24 1c	 mov	 ebp, DWORD PTR _tmMaxTime$[esp+12]
  0004d	83 fd ff	 cmp	 ebp, -1
  00050	75 16		 jne	 SHORT $L275828

; 2213 : 			Error( "SetPoison : %s    ", GetName() );

  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DB@PFHOFKCA@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S?$LN?C?$LA?$KD@
  00060	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00065	83 c4 08	 add	 esp, 8
$L275828:

; 2214 : 		if( tmUnit == -1 )

  00068	8b 5c 24 20	 mov	 ebx, DWORD PTR _tmUnit$[esp+12]
  0006c	83 fb ff	 cmp	 ebx, -1
  0006f	75 16		 jne	 SHORT $L275830

; 2215 : 			Error( "SetPoison : %s  tick   ", GetName() );

  00071	57		 push	 edi
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DC@FNFHKMOG@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5tick?5?$LN?C?$LA@
  0007f	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00084	83 c4 08	 add	 esp, 8
$L275830:

; 2216 : 		if( wDamage == -1 )

  00087	66 8b 7c 24 24	 mov	 di, WORD PTR _wDamage$[esp+12]
  0008c	66 83 ff ff	 cmp	 di, -1
  00090	75 17		 jne	 SHORT $L275832

; 2217 : 			Error( "SetPoison : %s     ", GetName() );

  00092	6a 00		 push	 0
  00094	8b ce		 mov	 ecx, esi
  00096	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0009b	50		 push	 eax
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DE@BJJIDPPP@SetPoison?5?3?5?$CFs?5?$LF?$LG?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g?5?$LF?$KF?$LJ@
  000a1	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000a6	83 c4 08	 add	 esp, 8
$L275832:

; 2218 : 		
; 2219 : 		m_wPoisonCnt = (short)( (tmMaxTime / 1000.0f) * PROCESS_COUNT );			// 1/1000

  000a9	85 ed		 test	 ebp, ebp
  000ab	89 6c 24 24	 mov	 DWORD PTR tv1359[esp+12], ebp
  000af	db 44 24 24	 fild	 DWORD PTR tv1359[esp+12]
  000b3	7d 06		 jge	 SHORT $L290191
  000b5	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L290191:
  000bb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a83126f
  000c1	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41700000
  000c7	e8 00 00 00 00	 call	 __ftol2
  000cc	5d		 pop	 ebp
  000cd	66 89 86 ce 06
	00 00		 mov	 WORD PTR [esi+1742], ax

; 2220 : 		m_wPoisonDamage = wDamage;
; 2221 : 		m_tmPoisonUnit = tmUnit;
; 2222 : 		m_idPoisonAttacker = idAttacker;

  000d4	8b 44 24 14	 mov	 eax, DWORD PTR _idAttacker$[esp+8]
  000d8	89 9e bc 06 00
	00		 mov	 DWORD PTR [esi+1724], ebx
  000de	5b		 pop	 ebx

; 2228 : 		m_wPoisonDamage = 0;

  000df	66 89 be d0 06
	00 00		 mov	 WORD PTR [esi+1744], di
  000e6	89 86 c4 06 00
	00		 mov	 DWORD PTR [esi+1732], eax
  000ec	5f		 pop	 edi

; 2230 : 	}
; 2231 : 
; 2232 : 	return TRUE;

  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	5e		 pop	 esi

; 2233 : }

  000f3	c2 14 00	 ret	 20			; 00000014H
$L275826:

; 2223 : 	} else
; 2224 : 	{
; 2225 : 		if( GetAdjParam( DST_CHRSTATE) & CHS_POISON )

  000f6	85 86 b8 13 00
	00		 test	 DWORD PTR [esi+5048], eax
  000fc	74 0c		 je	 SHORT $L290190

; 2226 : 			ResetDestParam( DST_CHRSTATE, CHS_POISON, TRUE );	//  

  000fe	6a 01		 push	 1
  00100	50		 push	 eax
  00101	6a 40		 push	 64			; 00000040H
  00103	8b ce		 mov	 ecx, esi
  00105	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L290190:

; 2227 : 		m_wPoisonCnt = 0;

  0010a	66 89 be ce 06
	00 00		 mov	 WORD PTR [esi+1742], di

; 2229 : 		m_tmPoisonUnit = 0;

  00111	89 be bc 06 00
	00		 mov	 DWORD PTR [esi+1724], edi
  00117	66 89 be d0 06
	00 00		 mov	 WORD PTR [esi+1744], di
  0011e	5f		 pop	 edi

; 2230 : 	}
; 2231 : 
; 2232 : 	return TRUE;

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	5e		 pop	 esi

; 2233 : }

  00125	c2 14 00	 ret	 20			; 00000014H
?SetPoison@CMover@@QAEHHKKKF@Z ENDP			; CMover::SetPoison
_TEXT	ENDS
PUBLIC	?SetDark@CMover@@QAEHHKH@Z			; CMover::SetDark
PUBLIC	??_C@_0DG@PECENGHI@SetDark?5?3?5?$CFs?5?$LO?n?$LF?R?H?$LP?$LA?z?$MA?G?5?$LI?m?A?$NP?$LH?$PM?5?$LM@ ; `string'
;	COMDAT ??_C@_0DG@PECENGHI@SetDark?5?3?5?$CFs?5?$LO?n?$LF?R?H?$LP?$LA?z?$MA?G?5?$LI?m?A?$NP?$LH?$PM?5?$LM@
CONST	SEGMENT
??_C@_0DG@PECENGHI@SetDark?5?3?5?$CFs?5?$LO?n?$LF?R?H?$LP?$LA?z?$MA?G?5?$LI?m?A?$NP?$LH?$PM?5?$LM@ DB 'S'
	DB	'etDark : %s ', 0beH, 0eeH, 0b5H, 0d2H, 0c8H, 0bfH, 0b0H, 0faH
	DB	0c0H, 0c7H, ' ', 0b8H, 0edH, 0c1H, 0dfH, 0b7H, 0fcH, ' ', 0bcH
	DB	0f6H, 0c1H, 0a4H, 0c4H, 0a1H, 0b0H, 0a1H, ' ', 0c1H, 0f6H, 0c1H
	DB	0a4H, 0b5H, 0c7H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0c0H, 0bdH, 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetDark@CMover@@QAEHHKH@Z
_TEXT	SEGMENT
tv2494 = 8						; size = 4
_bApply$ = 8						; size = 4
_tmMaxTime$ = 12					; size = 4
_nAdjHitRate$ = 16					; size = 4
?SetDark@CMover@@QAEHHKH@Z PROC NEAR			; CMover::SetDark, COMDAT
; _this$ = ecx

; 2241 : 	if( bApply )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bApply$[esp-4]
  00004	56		 push	 esi
  00005	85 c0		 test	 eax, eax
  00007	8b f1		 mov	 esi, ecx

; 2242 : 	{
; 2243 : 		if( GetAdjParam( DST_IMMUNITY ) & CHS_DARK ) 

  00009	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0000e	0f 84 be 00 00
	00		 je	 $L275843
  00014	85 86 ac 13 00
	00		 test	 DWORD PTR [esi+5036], eax
  0001a	74 06		 je	 SHORT $L275844

; 2244 : 			return FALSE;		//  .

  0001c	33 c0		 xor	 eax, eax
  0001e	5e		 pop	 esi

; 2264 : }

  0001f	c2 0c 00	 ret	 12			; 0000000cH
$L275844:
  00022	57		 push	 edi

; 2245 : 		SetDestParam( DST_CHRSTATE, CHS_DARK, NULL_CHGPARAM );

  00023	8b be b8 13 00
	00		 mov	 edi, DWORD PTR [esi+5048]
  00029	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  0002e	50		 push	 eax
  0002f	6a 40		 push	 64			; 00000040H
  00031	0b f8		 or	 edi, eax
  00033	56		 push	 esi
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00039	89 be b8 13 00
	00		 mov	 DWORD PTR [esi+5048], edi
  0003f	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam

; 2246 : 		SetDestParam( DST_ADJ_HITRATE, nAdjHitRate, NULL_CHGPARAM );

  00044	8b 7c 24 14	 mov	 edi, DWORD PTR _nAdjHitRate$[esp+4]
  00048	33 c0		 xor	 eax, eax
  0004a	85 ff		 test	 edi, edi
  0004c	74 13		 je	 SHORT $L291034
  0004e	8b 8e 74 13 00
	00		 mov	 ecx, DWORD PTR [esi+4980]
  00054	03 cf		 add	 ecx, edi
  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	89 8e 74 13 00
	00		 mov	 DWORD PTR [esi+4980], ecx
$L291034:
  00061	83 e0 01	 and	 eax, 1
  00064	3c 01		 cmp	 al, 1
  00066	75 13		 jne	 SHORT $L290867
  00068	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  0006d	57		 push	 edi
  0006e	6a 2f		 push	 47			; 0000002fH
  00070	56		 push	 esi
  00071	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00076	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam
$L290867:

; 2247 : 		m_wDarkCnt = (short)( (tmMaxTime / 1000.0f) * PROCESS_COUNT );

  0007b	8b 44 24 10	 mov	 eax, DWORD PTR _tmMaxTime$[esp+4]
  0007f	db 44 24 10	 fild	 DWORD PTR _tmMaxTime$[esp+4]
  00083	85 c0		 test	 eax, eax
  00085	7d 06		 jge	 SHORT $L291035
  00087	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L291035:
  0008d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a83126f
  00093	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41700000
  00099	e8 00 00 00 00	 call	 __ftol2

; 2248 : 		if( nAdjHitRate == -1 )

  0009e	83 ff ff	 cmp	 edi, -1
  000a1	66 89 86 d2 06
	00 00		 mov	 WORD PTR [esi+1746], ax
  000a8	75 17		 jne	 SHORT $L275846

; 2249 : 			Error( "SetDark : %s     ", GetName() );

  000aa	6a 00		 push	 0
  000ac	8b ce		 mov	 ecx, esi
  000ae	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  000b3	50		 push	 eax
  000b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@PECENGHI@SetDark?5?3?5?$CFs?5?$LO?n?$LF?R?H?$LP?$LA?z?$MA?G?5?$LI?m?A?$NP?$LH?$PM?5?$LM@
  000b9	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000be	83 c4 08	 add	 esp, 8
$L275846:

; 2250 : 		m_wDarkVal = nAdjHitRate;

  000c1	66 89 be d4 06
	00 00		 mov	 WORD PTR [esi+1748], di
  000c8	5f		 pop	 edi

; 2262 : 	}
; 2263 : 	return TRUE;

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	5e		 pop	 esi

; 2264 : }

  000cf	c2 0c 00	 ret	 12			; 0000000cH
$L275843:

; 2251 : 	} else
; 2252 : 	{
; 2253 : 		if( GetAdjParam( DST_CHRSTATE) & CHS_DARK )

  000d2	85 86 b8 13 00
	00		 test	 DWORD PTR [esi+5048], eax
  000d8	74 1f		 je	 SHORT $L275849

; 2254 : 		{
; 2255 : 			ResetDestParam( DST_CHRSTATE, CHS_DARK, TRUE );		// 

  000da	6a 01		 push	 1
  000dc	50		 push	 eax
  000dd	6a 40		 push	 64			; 00000040H
  000df	8b ce		 mov	 ecx, esi
  000e1	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam

; 2256 : 			ResetDestParam( DST_ADJ_HITRATE, m_wDarkVal, TRUE );	//    

  000e6	0f bf 8e d4 06
	00 00		 movsx	 ecx, WORD PTR [esi+1748]
  000ed	6a 01		 push	 1
  000ef	51		 push	 ecx
  000f0	6a 2f		 push	 47			; 0000002fH
  000f2	8b ce		 mov	 ecx, esi
  000f4	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L275849:

; 2257 : //			if( m_wDarkCnt >= 0 )
; 2258 : //				Error( "SetDark : %d", m_wDarkVal );
; 2259 : 		}
; 2260 : 		m_wDarkCnt = 0;

  000f9	66 c7 86 d2 06
	00 00 00 00	 mov	 WORD PTR [esi+1746], 0

; 2261 : 		m_wDarkVal = 0;

  00102	66 c7 86 d4 06
	00 00 00 00	 mov	 WORD PTR [esi+1748], 0

; 2262 : 	}
; 2263 : 	return TRUE;

  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	5e		 pop	 esi

; 2264 : }

  00111	c2 0c 00	 ret	 12			; 0000000cH
?SetDark@CMover@@QAEHHKH@Z ENDP				; CMover::SetDark
_TEXT	ENDS
PUBLIC	?SetBleeding@CMover@@QAEHHKKKF@Z		; CMover::SetBleeding
PUBLIC	??_C@_0DF@KMFJEAB@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S@ ; `string'
PUBLIC	??_C@_0DG@BBMBAHHG@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5tick@ ; `string'
PUBLIC	??_C@_0DI@CJNNIDBD@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g@ ; `string'
;	COMDAT ??_C@_0DF@KMFJEAB@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S@
CONST	SEGMENT
??_C@_0DF@KMFJEAB@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S@ DB 'S'
	DB	'etBleeding : %s ', 0c3H, 0e2H, 0c7H, 0f7H, 0c8H, 0bfH, 0b0H, 0faH
	DB	0c0H, 0c7H, ' ', 0c1H, 0f6H, 0bcH, 0d3H, 0bdH, 0c3H, 0b0H, 0a3H
	DB	0c0H, 0ccH, ' ', 0c1H, 0f6H, 0c1H, 0a4H, 0b5H, 0c7H, 0c1H, 0f6H
	DB	' ', 0beH, 0caH, 0c0H, 0bdH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BBMBAHHG@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5tick@
CONST	SEGMENT
??_C@_0DG@BBMBAHHG@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5tick@ DB 'S'
	DB	'etBleeding : %s ', 0c3H, 0e2H, 0c7H, 0f7H, 0c8H, 0bfH, 0b0H, 0faH
	DB	0c0H, 0c7H, ' tick ', 0bdH, 0c3H, 0b0H, 0a3H, 0c0H, 0ccH, ' ', 0c1H
	DB	0f6H, 0c1H, 0a4H, 0b5H, 0c7H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0c0H
	DB	0bdH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CJNNIDBD@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g@
CONST	SEGMENT
??_C@_0DI@CJNNIDBD@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g@ DB 'S'
	DB	'etBleeding : %s ', 0c3H, 0e2H, 0c7H, 0f7H, 0c8H, 0bfH, 0b0H, 0faH
	DB	0c0H, 0c7H, ' ', 0c6H, 0bdH, 0b4H, 0e7H, ' ', 0b5H, 0a5H, 0b9H
	DB	0ccH, 0c1H, 0f6H, 0b0H, 0a1H, ' ', 0c1H, 0f6H, 0c1H, 0a4H, 0b5H
	DB	0c7H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0c0H, 0bdH, 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?SetBleeding@CMover@@QAEHHKKKF@Z
_TEXT	SEGMENT
_bApply$ = 8						; size = 4
_idAttacker$ = 12					; size = 4
_tmMaxTime$ = 16					; size = 4
_tmUnit$ = 20						; size = 4
tv1359 = 24						; size = 4
_wDamage$ = 24						; size = 2
?SetBleeding@CMover@@QAEHHKKKF@Z PROC NEAR		; CMover::SetBleeding, COMDAT
; _this$ = ecx

; 2272 : 	if( bApply )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bApply$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	3b c7		 cmp	 eax, edi
  0000a	8b f1		 mov	 esi, ecx

; 2273 : 	{
; 2274 : 		if( GetAdjParam( DST_IMMUNITY ) & CHS_BLEEDING ) return FALSE;		//  .

  0000c	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00011	0f 84 df 00 00
	00		 je	 $L275858
  00017	85 86 ac 13 00
	00		 test	 DWORD PTR [esi+5036], eax
  0001d	74 07		 je	 SHORT $L275859
  0001f	5f		 pop	 edi
  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 2297 : }

  00023	c2 14 00	 ret	 20			; 00000014H
$L275859:

; 2275 : 		
; 2276 : 		SetDestParam( DST_CHRSTATE, CHS_BLEEDING, NULL_CHGPARAM );

  00026	8b 8e b8 13 00
	00		 mov	 ecx, DWORD PTR [esi+5048]
  0002c	53		 push	 ebx
  0002d	55		 push	 ebp
  0002e	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00033	50		 push	 eax
  00034	0b c8		 or	 ecx, eax
  00036	6a 40		 push	 64			; 00000040H
  00038	89 8e b8 13 00
	00		 mov	 DWORD PTR [esi+5048], ecx
  0003e	56		 push	 esi
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  00044	e8 00 00 00 00	 call	 ?AddSetDestParam@CUserMng@@QAEXPAVCMover@@HHH@Z ; CUserMng::AddSetDestParam

; 2277 : 		if( tmMaxTime == -1 )

  00049	8b 6c 24 1c	 mov	 ebp, DWORD PTR _tmMaxTime$[esp+12]
  0004d	83 fd ff	 cmp	 ebp, -1
  00050	75 16		 jne	 SHORT $L275860

; 2278 : 			Error( "SetBleeding : %s    ", GetName() );

  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DF@KMFJEAB@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?A?v?$LM?S@
  00060	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00065	83 c4 08	 add	 esp, 8
$L275860:

; 2279 : 		if( tmUnit == -1 )

  00068	8b 5c 24 20	 mov	 ebx, DWORD PTR _tmUnit$[esp+12]
  0006c	83 fb ff	 cmp	 ebx, -1
  0006f	75 16		 jne	 SHORT $L275862

; 2280 : 			Error( "SetBleeding : %s  tick   ", GetName() );

  00071	57		 push	 edi
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DG@BBMBAHHG@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5tick@
  0007f	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00084	83 c4 08	 add	 esp, 8
$L275862:

; 2281 : 		if( wDamage == -1 )

  00087	66 8b 7c 24 24	 mov	 di, WORD PTR _wDamage$[esp+12]
  0008c	66 83 ff ff	 cmp	 di, -1
  00090	75 17		 jne	 SHORT $L275864

; 2282 : 			Error( "SetBleeding : %s     ", GetName() );

  00092	6a 00		 push	 0
  00094	8b ce		 mov	 ecx, esi
  00096	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName
  0009b	50		 push	 eax
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@CJNNIDBD@SetBleeding?5?3?5?$CFs?5?C?b?G?w?H?$LP?$LA?z?$MA?G?5?F?$LN?$LE?g@
  000a1	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000a6	83 c4 08	 add	 esp, 8
$L275864:

; 2283 : 		
; 2284 : 		m_wBleedingCnt = (short)( (tmMaxTime / 1000.0f) * PROCESS_COUNT );			// 1/1000

  000a9	85 ed		 test	 ebp, ebp
  000ab	89 6c 24 24	 mov	 DWORD PTR tv1359[esp+12], ebp
  000af	db 44 24 24	 fild	 DWORD PTR tv1359[esp+12]
  000b3	7d 06		 jge	 SHORT $L291465
  000b5	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L291465:
  000bb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a83126f
  000c1	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@41700000
  000c7	e8 00 00 00 00	 call	 __ftol2
  000cc	5d		 pop	 ebp
  000cd	66 89 86 d6 06
	00 00		 mov	 WORD PTR [esi+1750], ax

; 2285 : 		m_wBleedingDamage = wDamage;
; 2286 : 		m_tmBleedingUnit = tmUnit;
; 2287 : 		m_idBleedingAttacker = idAttacker;

  000d4	8b 44 24 14	 mov	 eax, DWORD PTR _idAttacker$[esp+8]
  000d8	89 9e c0 06 00
	00		 mov	 DWORD PTR [esi+1728], ebx
  000de	5b		 pop	 ebx

; 2293 : 		m_wBleedingDamage = 0;

  000df	66 89 be d8 06
	00 00		 mov	 WORD PTR [esi+1752], di
  000e6	89 86 c8 06 00
	00		 mov	 DWORD PTR [esi+1736], eax
  000ec	5f		 pop	 edi

; 2295 : 	}
; 2296 : 	return TRUE;

  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	5e		 pop	 esi

; 2297 : }

  000f3	c2 14 00	 ret	 20			; 00000014H
$L275858:

; 2288 : 	} else
; 2289 : 	{
; 2290 : 		if( GetAdjParam( DST_CHRSTATE) & CHS_BLEEDING )

  000f6	85 86 b8 13 00
	00		 test	 DWORD PTR [esi+5048], eax
  000fc	74 0c		 je	 SHORT $L291464

; 2291 : 			ResetDestParam( DST_CHRSTATE, CHS_BLEEDING, TRUE );	//  

  000fe	6a 01		 push	 1
  00100	50		 push	 eax
  00101	6a 40		 push	 64			; 00000040H
  00103	8b ce		 mov	 ecx, esi
  00105	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L291464:

; 2292 : 		m_wBleedingCnt = 0;

  0010a	66 89 be d6 06
	00 00		 mov	 WORD PTR [esi+1750], di

; 2294 : 		m_tmBleedingUnit = 0;

  00111	89 be c0 06 00
	00		 mov	 DWORD PTR [esi+1728], edi
  00117	66 89 be d8 06
	00 00		 mov	 WORD PTR [esi+1752], di
  0011e	5f		 pop	 edi

; 2295 : 	}
; 2296 : 	return TRUE;

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	5e		 pop	 esi

; 2297 : }

  00125	c2 14 00	 ret	 20			; 00000014H
?SetBleeding@CMover@@QAEHHKKKF@Z ENDP			; CMover::SetBleeding
_TEXT	ENDS
PUBLIC	?RemoveDebuff@CMover@@QAEXK@Z			; CMover::RemoveDebuff
EXTRN	?RemoveChrStateBuffs@CMover@@QAEXK@Z:NEAR	; CMover::RemoveChrStateBuffs
EXTRN	?RemoveDstParamBuffs@CMover@@QAEXK@Z:NEAR	; CMover::RemoveDstParamBuffs
; Function compile flags: /Ogty
;	COMDAT ?RemoveDebuff@CMover@@QAEXK@Z
_TEXT	SEGMENT
_dwState$ = 8						; size = 4
?RemoveDebuff@CMover@@QAEXK@Z PROC NEAR			; CMover::RemoveDebuff, COMDAT
; _this$ = ecx

; 2302 : {

  00000	53		 push	 ebx

; 2303 : 	//    
; 2304 : 	RemoveChrStateBuffs( dwState );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _dwState$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	53		 push	 ebx
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?RemoveChrStateBuffs@CMover@@QAEXK@Z ; CMover::RemoveChrStateBuffs

; 2305 : 	//        .
; 2306 : 	if( dwState & CHS_DARK )

  0000f	33 ff		 xor	 edi, edi
  00011	f6 c7 01	 test	 bh, 1
  00014	74 3c		 je	 SHORT $L292506

; 2307 : 		SetDark( FALSE );

  00016	8b 86 b8 13 00
	00		 mov	 eax, DWORD PTR [esi+5048]
  0001c	f6 c4 01	 test	 ah, 1
  0001f	74 23		 je	 SHORT $L292508
  00021	6a 01		 push	 1
  00023	68 00 01 00 00	 push	 256			; 00000100H
  00028	6a 40		 push	 64			; 00000040H
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
  00031	0f bf 86 d4 06
	00 00		 movsx	 eax, WORD PTR [esi+1748]
  00038	6a 01		 push	 1
  0003a	50		 push	 eax
  0003b	6a 2f		 push	 47			; 0000002fH
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L292508:
  00044	66 89 be d2 06
	00 00		 mov	 WORD PTR [esi+1746], di
  0004b	66 89 be d4 06
	00 00		 mov	 WORD PTR [esi+1748], di
$L292506:

; 2308 : 	if( dwState & CHS_POISON )

  00052	f6 c7 08	 test	 bh, 8
  00055	74 2f		 je	 SHORT $L293401

; 2309 : 		SetPoison( FALSE );

  00057	8b 86 b8 13 00
	00		 mov	 eax, DWORD PTR [esi+5048]
  0005d	f6 c4 08	 test	 ah, 8
  00060	74 10		 je	 SHORT $L293402
  00062	6a 01		 push	 1
  00064	68 00 08 00 00	 push	 2048			; 00000800H
  00069	6a 40		 push	 64			; 00000040H
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L293402:
  00072	66 89 be ce 06
	00 00		 mov	 WORD PTR [esi+1742], di
  00079	66 89 be d0 06
	00 00		 mov	 WORD PTR [esi+1744], di
  00080	89 be bc 06 00
	00		 mov	 DWORD PTR [esi+1724], edi
$L293401:

; 2310 : 	if( dwState & CHS_STUN )

  00086	f6 c3 08	 test	 bl, 8
  00089	74 3a		 je	 SHORT $L293449

; 2311 : 		SetStun( FALSE );

  0008b	f6 86 b8 13 00
	00 08		 test	 BYTE PTR [esi+5048], 8
  00092	74 0c		 je	 SHORT $L293456
  00094	57		 push	 edi
  00095	6a 08		 push	 8
  00097	6a 40		 push	 64			; 00000040H
  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L293456:
  000a0	8b 96 48 02 00
	00		 mov	 edx, DWORD PTR [esi+584]
  000a6	57		 push	 edi
  000a7	81 e2 ff f8 ff
	ff		 and	 edx, -1793		; fffff8ffH
  000ad	56		 push	 esi
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  000b3	66 89 be cc 06
	00 00		 mov	 WORD PTR [esi+1740], di
  000ba	89 96 48 02 00
	00		 mov	 DWORD PTR [esi+584], edx
  000c0	e8 00 00 00 00	 call	 ?AddSetStun@CUserMng@@QAEXPAVCMover@@H@Z ; CUserMng::AddSetStun
$L293449:

; 2312 : #if __VER >= 10	// 
; 2313 : 	if( dwState & CHS_BLEEDING )

  000c5	84 ff		 test	 bh, bh
  000c7	79 2e		 jns	 SHORT $L293494

; 2314 : 		SetBleeding( FALSE );

  000c9	8b 86 b8 13 00
	00		 mov	 eax, DWORD PTR [esi+5048]
  000cf	84 e4		 test	 ah, ah
  000d1	79 10		 jns	 SHORT $L293495
  000d3	6a 01		 push	 1
  000d5	68 00 80 00 00	 push	 32768			; 00008000H
  000da	6a 40		 push	 64			; 00000040H
  000dc	8b ce		 mov	 ecx, esi
  000de	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
$L293495:
  000e3	66 89 be d6 06
	00 00		 mov	 WORD PTR [esi+1750], di
  000ea	66 89 be d8 06
	00 00		 mov	 WORD PTR [esi+1752], di
  000f1	89 be c0 06 00
	00		 mov	 DWORD PTR [esi+1728], edi
$L293494:

; 2315 : 	
; 2316 : 	#if __VER >= 11 // __MA_VER11_06				//   world,neuz
; 2317 : 	if( dwState & DST_CLEARBUFF )

  000f7	f6 c3 31	 test	 bl, 49			; 00000031H
  000fa	74 24		 je	 SHORT $L275877

; 2318 : 	{
; 2319 : 		RemoveDstParamBuffs( DST_SPEED );

  000fc	6a 0b		 push	 11			; 0000000bH
  000fe	8b ce		 mov	 ecx, esi
  00100	e8 00 00 00 00	 call	 ?RemoveDstParamBuffs@CMover@@QAEXK@Z ; CMover::RemoveDstParamBuffs

; 2320 : 		RemoveDstParamBuffs( DST_CHR_CHANCEPOISON );

  00105	6a 3c		 push	 60			; 0000003cH
  00107	8b ce		 mov	 ecx, esi
  00109	e8 00 00 00 00	 call	 ?RemoveDstParamBuffs@CMover@@QAEXK@Z ; CMover::RemoveDstParamBuffs

; 2321 : 		RemoveDstParamBuffs( DST_CHR_CHANCESTUN );

  0010e	6a 39		 push	 57			; 00000039H
  00110	8b ce		 mov	 ecx, esi
  00112	e8 00 00 00 00	 call	 ?RemoveDstParamBuffs@CMover@@QAEXK@Z ; CMover::RemoveDstParamBuffs

; 2322 : 		RemoveDstParamBuffs( DST_CHR_CHANCEBLEEDING );

  00117	6a 46		 push	 70			; 00000046H
  00119	8b ce		 mov	 ecx, esi
  0011b	e8 00 00 00 00	 call	 ?RemoveDstParamBuffs@CMover@@QAEXK@Z ; CMover::RemoveDstParamBuffs
$L275877:

; 2323 : 	}
; 2324 : 	#endif // __MA_VER11_06				//   world,neuz
; 2325 : 
; 2326 : #endif	//
; 2327 : 
; 2328 : 	//   Reset .
; 2329 : 	SetDestParam( DST_CURECHR, dwState, NULL_CHGPARAM );

  00120	6a 01		 push	 1
  00122	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00127	53		 push	 ebx
  00128	68 16 27 00 00	 push	 10006			; 00002716H
  0012d	8b ce		 mov	 ecx, esi
  0012f	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5b		 pop	 ebx

; 2330 : }

  00137	c2 04 00	 ret	 4
?RemoveDebuff@CMover@@QAEXK@Z ENDP			; CMover::RemoveDebuff
_TEXT	ENDS
PUBLIC	?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z	; CMover::SetDestParam
; Function compile flags: /Ogty
;	COMDAT ?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIdx$ = 8						; size = 4
_pProp$ = 12						; size = 4
_bSend$ = 16						; size = 4
?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z PROC NEAR	; CMover::SetDestParam, COMDAT
; _this$ = ecx

; 2359 : 	SetDestParam( pProp->dwDestParam[nIdx], pProp->nAdjParamVal[nIdx], pProp->dwChgParamVal[nIdx], bSend );

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _bSend$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _nIdx$[esp-4]
  00008	56		 push	 esi
  00009	50		 push	 eax
  0000a	8b 44 24 10	 mov	 eax, DWORD PTR _pProp$[esp+4]
  0000e	8b b4 90 70 01
	00 00		 mov	 esi, DWORD PTR [eax+edx*4+368]
  00015	56		 push	 esi
  00016	8b b4 90 58 01
	00 00		 mov	 esi, DWORD PTR [eax+edx*4+344]
  0001d	8b 94 90 40 01
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+320]
  00024	56		 push	 esi
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
  0002b	5e		 pop	 esi

; 2360 : }

  0002c	c2 0c 00	 ret	 12			; 0000000cH
?SetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ENDP	; CMover::SetDestParam
_TEXT	ENDS
PUBLIC	?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z	; CMover::ResetDestParam
; Function compile flags: /Ogty
;	COMDAT ?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z
_TEXT	SEGMENT
_nIdx$ = 8						; size = 4
_pProp$ = 12						; size = 4
_bSend$ = 16						; size = 4
?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z PROC NEAR	; CMover::ResetDestParam, COMDAT
; _this$ = ecx

; 2364 : 	ResetDestParam( pProp->dwDestParam[nIdx], pProp->nAdjParamVal[nIdx], bSend );

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _bSend$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _nIdx$[esp-4]
  00008	56		 push	 esi
  00009	50		 push	 eax
  0000a	8b 44 24 10	 mov	 eax, DWORD PTR _pProp$[esp+4]
  0000e	8b b4 90 58 01
	00 00		 mov	 esi, DWORD PTR [eax+edx*4+344]
  00015	8b 94 90 40 01
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+320]
  0001c	56		 push	 esi
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?ResetDestParam@CMover@@QAEXHHH@Z ; CMover::ResetDestParam
  00023	5e		 pop	 esi

; 2365 : }

  00024	c2 0c 00	 ret	 12			; 0000000cH
?ResetDestParam@CMover@@QAEXHPAUItemProp@@H@Z ENDP	; CMover::ResetDestParam
_TEXT	ENDS
PUBLIC	?SetDestParam@CMover@@QAEXHH@Z			; CMover::SetDestParam
; Function compile flags: /Ogty
;	COMDAT ?SetDestParam@CMover@@QAEXHH@Z
_TEXT	SEGMENT
_nItemIdx$ = 8						; size = 4
_bSend$ = 12						; size = 4
?SetDestParam@CMover@@QAEXHH@Z PROC NEAR		; CMover::SetDestParam, COMDAT
; _this$ = ecx

; 2370 : 	ItemProp* pItemProp = prj.GetItemProp( nItemIdx );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nItemIdx$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx
  0000a	8b 0d 5c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+604
  00010	57		 push	 edi
  00011	7c 19		 jl	 SHORT $L293539
  00013	3b c1		 cmp	 eax, ecx
  00015	7d 15		 jge	 SHORT $L293539
  00017	72 06		 jb	 SHORT $L293551
  00019	33 c0		 xor	 eax, eax
  0001b	8b f0		 mov	 esi, eax
  0001d	eb 25		 jmp	 SHORT $L293534
$L293551:
  0001f	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00025	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00028	8b f0		 mov	 esi, eax
  0002a	eb 18		 jmp	 SHORT $L293534
$L293539:
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	6a 00		 push	 0
  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  00035	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  0003a	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0003f	83 c4 14	 add	 esp, 20			; 00000014H
  00042	33 f6		 xor	 esi, esi
$L293534:

; 2371 : 	if( pItemProp->dwDestParam1 != -1 )

  00044	8b 86 40 01 00
	00		 mov	 eax, DWORD PTR [esi+320]
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	8b 7c 24 14	 mov	 edi, DWORD PTR _bSend$[esp+8]
  00051	74 17		 je	 SHORT $L275907

; 2372 : 		SetDestParam( pItemProp->dwDestParam1, pItemProp->nAdjParamVal1, pItemProp->dwChgParamVal1, bSend );

  00053	8b 96 70 01 00
	00		 mov	 edx, DWORD PTR [esi+368]
  00059	8b 8e 58 01 00
	00		 mov	 ecx, DWORD PTR [esi+344]
  0005f	57		 push	 edi
  00060	52		 push	 edx
  00061	51		 push	 ecx
  00062	50		 push	 eax
  00063	8b cb		 mov	 ecx, ebx
  00065	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275907:

; 2373 : 	if( pItemProp->dwDestParam2 != -1 )

  0006a	8b 86 44 01 00
	00		 mov	 eax, DWORD PTR [esi+324]
  00070	83 f8 ff	 cmp	 eax, -1
  00073	74 17		 je	 SHORT $L275908

; 2374 : 		SetDestParam( pItemProp->dwDestParam2, pItemProp->nAdjParamVal2, pItemProp->dwChgParamVal2, bSend );

  00075	8b 96 74 01 00
	00		 mov	 edx, DWORD PTR [esi+372]
  0007b	8b 8e 5c 01 00
	00		 mov	 ecx, DWORD PTR [esi+348]
  00081	57		 push	 edi
  00082	52		 push	 edx
  00083	51		 push	 ecx
  00084	50		 push	 eax
  00085	8b cb		 mov	 ecx, ebx
  00087	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275908:

; 2375 : #ifdef __PROP_0827
; 2376 : 	if( pItemProp->dwDestParam3 != -1 )

  0008c	8b 86 48 01 00
	00		 mov	 eax, DWORD PTR [esi+328]
  00092	83 f8 ff	 cmp	 eax, -1
  00095	74 17		 je	 SHORT $L275909

; 2377 : 		SetDestParam( pItemProp->dwDestParam3, pItemProp->nAdjParamVal3, pItemProp->dwChgParamVal3, bSend );

  00097	8b 96 78 01 00
	00		 mov	 edx, DWORD PTR [esi+376]
  0009d	8b 8e 60 01 00
	00		 mov	 ecx, DWORD PTR [esi+352]
  000a3	57		 push	 edi
  000a4	52		 push	 edx
  000a5	51		 push	 ecx
  000a6	50		 push	 eax
  000a7	8b cb		 mov	 ecx, ebx
  000a9	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275909:

; 2378 : #endif	// __PROP_0827
; 2379 : #if __VER >= 19
; 2380 : 	if( pItemProp->dwDestParam4 != -1 )

  000ae	8b 86 4c 01 00
	00		 mov	 eax, DWORD PTR [esi+332]
  000b4	83 f8 ff	 cmp	 eax, -1
  000b7	74 17		 je	 SHORT $L275910

; 2381 : 		SetDestParam( pItemProp->dwDestParam4, pItemProp->nAdjParamVal4, pItemProp->dwChgParamVal4, bSend );

  000b9	8b 96 7c 01 00
	00		 mov	 edx, DWORD PTR [esi+380]
  000bf	8b 8e 64 01 00
	00		 mov	 ecx, DWORD PTR [esi+356]
  000c5	57		 push	 edi
  000c6	52		 push	 edx
  000c7	51		 push	 ecx
  000c8	50		 push	 eax
  000c9	8b cb		 mov	 ecx, ebx
  000cb	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275910:

; 2382 : 	if( pItemProp->dwDestParam5 != -1 )

  000d0	8b 86 50 01 00
	00		 mov	 eax, DWORD PTR [esi+336]
  000d6	83 f8 ff	 cmp	 eax, -1
  000d9	74 17		 je	 SHORT $L275911

; 2383 : 		SetDestParam( pItemProp->dwDestParam5, pItemProp->nAdjParamVal5, pItemProp->dwChgParamVal5, bSend );

  000db	8b 96 80 01 00
	00		 mov	 edx, DWORD PTR [esi+384]
  000e1	8b 8e 68 01 00
	00		 mov	 ecx, DWORD PTR [esi+360]
  000e7	57		 push	 edi
  000e8	52		 push	 edx
  000e9	51		 push	 ecx
  000ea	50		 push	 eax
  000eb	8b cb		 mov	 ecx, ebx
  000ed	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275911:

; 2384 : 	if( pItemProp->dwDestParam6 != -1 )

  000f2	8b 86 54 01 00
	00		 mov	 eax, DWORD PTR [esi+340]
  000f8	83 f8 ff	 cmp	 eax, -1
  000fb	74 17		 je	 SHORT $L275912

; 2385 : 		SetDestParam( pItemProp->dwDestParam6, pItemProp->nAdjParamVal6, pItemProp->dwChgParamVal6, bSend );

  000fd	8b 96 84 01 00
	00		 mov	 edx, DWORD PTR [esi+388]
  00103	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00109	57		 push	 edi
  0010a	52		 push	 edx
  0010b	51		 push	 ecx
  0010c	50		 push	 eax
  0010d	8b cb		 mov	 ecx, ebx
  0010f	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHHHH@Z ; CMover::SetDestParam
$L275912:
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx

; 2386 : #endif//__VER >= 19
; 2387 : }

  00117	c2 08 00	 ret	 8
?SetDestParam@CMover@@QAEXHH@Z ENDP			; CMover::SetDestParam
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator++
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 326  : 			{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 327  : 			++(*(const_iterator *)this);

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 329  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L293620
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L293620:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 27   : 		return (_Str.c_str());

  00000	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
  00004	72 04		 jb	 SHORT $L293653
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  00009	c3		 ret	 0

; 27   : 		return (_Str.c_str());

$L293653:
  0000a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 28   : 		}

  0000d	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L293660
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L293660:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetLevelExp@CProject@@QAEKH@Z			; CProject::GetLevelExp
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\project.h
;	COMDAT ?GetLevelExp@CProject@@QAEKH@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_nLevel$ = 8						; size = 4
?GetLevelExp@CProject@@QAEKH@Z PROC NEAR		; CProject::GetLevelExp, COMDAT
; _this$ = ecx

; 1270 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1271 : 	map<int, DWORD>::iterator it = m_PKSetting.mapLevelExp.find( nLevel );

  00004	8d 44 24 0c	 lea	 eax, DWORD PTR _nLevel$[esp+4]
  00008	50		 push	 eax
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR _it$[esp+12]
  0000d	51		 push	 ecx
  0000e	8d 8e 9c 46 0f
	00		 lea	 ecx, DWORD PTR [esi+1001116]
  00014	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HKU?$less@H@std@@V?$allocator@U?$pair@$$CBHK@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned long,std::less<int>,std::allocator<std::pair<int const ,unsigned long> >,0> >::find

; 1272 : 	if( it != m_PKSetting.mapLevelExp.end() )

  00019	8b 8e a0 46 0f
	00		 mov	 ecx, DWORD PTR [esi+1001120]
  0001f	8b 44 24 04	 mov	 eax, DWORD PTR _it$[esp+8]
  00023	3b c1		 cmp	 eax, ecx
  00025	5e		 pop	 esi
  00026	74 07		 je	 SHORT $L197610

; 1273 : 		return it->second;

  00028	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1275 : }

  0002b	59		 pop	 ecx
  0002c	c2 04 00	 ret	 4
$L197610:

; 1274 : 	return 4400000;

  0002f	b8 80 23 43 00	 mov	 eax, 4400000		; 00432380H

; 1275 : }

  00034	59		 pop	 ecx
  00035	c2 04 00	 ret	 4
?GetLevelExp@CProject@@QAEKH@Z ENDP			; CProject::GetLevelExp
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 591  : 		if (_Right.size() < _Roff)

  00003	8b 74 24 14	 mov	 esi, DWORD PTR __Roff$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 14	 mov	 edi, DWORD PTR __Right$[esp+12]
  0000c	39 77 14	 cmp	 DWORD PTR [edi+20], esi
  0000f	8b d9		 mov	 ebx, ecx
  00011	73 05		 jae	 SHORT $L220001

; 592  : 			_String_base::_Xran();	// _Roff off end

  00013	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L220001:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00018	8b 6f 14	 mov	 ebp, DWORD PTR [edi+20]

; 594  : 		if (_Count < _Num)

  0001b	8b 44 24 1c	 mov	 eax, DWORD PTR __Count$[esp+12]
  0001f	2b ee		 sub	 ebp, esi
  00021	3b c5		 cmp	 eax, ebp
  00023	73 02		 jae	 SHORT $L220003

; 595  : 			_Num = _Count;	// trim _Num to size

  00025	8b e8		 mov	 ebp, eax
$L220003:

; 596  : 
; 597  : 		if (this == &_Right)

  00027	3b df		 cmp	 ebx, edi
  00029	75 1f		 jne	 SHORT $L220004

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002b	6a ff		 push	 -1
  0002d	03 ee		 add	 ebp, esi
  0002f	55		 push	 ebp
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00037	56		 push	 esi
  00038	6a 00		 push	 0
  0003a	8b cb		 mov	 ecx, ebx
  0003c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00044	8b c3		 mov	 eax, ebx
  00046	5b		 pop	 ebx

; 605  : 		}

  00047	c2 0c 00	 ret	 12			; 0000000cH
$L220004:

; 599  : 		else if (_Grow(_Num))

  0004a	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  0004d	76 07		 jbe	 SHORT $L293821
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L293821:
  00056	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00059	3b c5		 cmp	 eax, ebp
  0005b	73 21		 jae	 SHORT $L293822
  0005d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00060	50		 push	 eax
  00061	55		 push	 ebp
  00062	8b cb		 mov	 ecx, ebx
  00064	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00069	85 ed		 test	 ebp, ebp
$L293909:
  0006b	76 6d		 jbe	 SHORT $L293908

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0006d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00070	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00075	3b c8		 cmp	 ecx, eax
  00077	72 2f		 jb	 SHORT $L293874
  00079	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0007c	eb 2d		 jmp	 SHORT $L293875

; 599  : 		else if (_Grow(_Num))

$L293822:
  0007e	85 ed		 test	 ebp, ebp
  00080	75 e9		 jne	 SHORT $L293909
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  00088	72 0f		 jb	 SHORT $L293865
  0008a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  00093	8b c3		 mov	 eax, ebx
  00095	5b		 pop	 ebx

; 605  : 		}

  00096	c2 0c 00	 ret	 12			; 0000000cH

; 599  : 		else if (_Grow(_Num))

$L293865:
  00099	5f		 pop	 edi
  0009a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009d	5e		 pop	 esi
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a1	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000a2	8b c3		 mov	 eax, ebx
  000a4	5b		 pop	 ebx

; 605  : 		}

  000a5	c2 0c 00	 ret	 12			; 0000000cH

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$L293874:
  000a8	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
$L293875:
  000ab	39 43 18	 cmp	 DWORD PTR [ebx+24], eax
  000ae	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000b1	72 04		 jb	 SHORT $L293881
  000b3	8b 38		 mov	 edi, DWORD PTR [eax]
  000b5	eb 02		 jmp	 SHORT $L293882
$L293881:
  000b7	8b f8		 mov	 edi, eax
$L293882:
  000b9	03 f2		 add	 esi, edx
  000bb	8b cd		 mov	 ecx, ebp
  000bd	8b d1		 mov	 edx, ecx
  000bf	c1 e9 02	 shr	 ecx, 2
  000c2	f3 a5		 rep movsd
  000c4	8b ca		 mov	 ecx, edx
  000c6	83 e1 03	 and	 ecx, 3
  000c9	f3 a4		 rep movsb

; 602  : 			_Eos(_Num);

  000cb	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000cf	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000d2	72 02		 jb	 SHORT $L293902
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
$L293902:
  000d6	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L293908:
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5d		 pop	 ebp

; 603  : 			}
; 604  : 		return (*this);

  000dd	8b c3		 mov	 eax, ebx
  000df	5b		 pop	 ebx

; 605  : 		}

  000e0	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 609  : 		if (_Inside(_Ptr))

  00003	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00006	83 fa 10	 cmp	 edx, 16			; 00000010H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	72 05		 jb	 SHORT $L293930
  0000d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00010	eb 03		 jmp	 SHORT $L293931
$L293930:
  00012	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$L293931:
  00015	8b 74 24 10	 mov	 esi, DWORD PTR __Ptr$[esp+8]
  00019	3b f0		 cmp	 esi, eax
  0001b	72 34		 jb	 SHORT $L221367
  0001d	83 fa 10	 cmp	 edx, 16			; 00000010H
  00020	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00023	72 04		 jb	 SHORT $L293934
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $L293935
$L293934:
  00029	8b c8		 mov	 ecx, eax
$L293935:
  0002b	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  0002e	03 f9		 add	 edi, ecx
  00030	3b fe		 cmp	 edi, esi
  00032	76 1d		 jbe	 SHORT $L221367

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  00034	83 fa 10	 cmp	 edx, 16			; 00000010H
  00037	72 02		 jb	 SHORT $L293947
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
$L293947:
  0003b	8b 4c 24 14	 mov	 ecx, DWORD PTR __Num$[esp+8]
  0003f	51		 push	 ecx
  00040	2b f0		 sub	 esi, eax
  00042	56		 push	 esi
  00043	53		 push	 ebx
  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 618  : 		}

  0004e	c2 08 00	 ret	 8
$L221367:
  00051	55		 push	 ebp

; 611  : 
; 612  : 		if (_Grow(_Num))

  00052	8b 6c 24 18	 mov	 ebp, DWORD PTR __Num$[esp+12]
  00056	83 fd fe	 cmp	 ebp, -2			; fffffffeH
  00059	76 07		 jbe	 SHORT $L294088
  0005b	8b cb		 mov	 ecx, ebx
  0005d	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L294088:
  00062	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00065	3b c5		 cmp	 eax, ebp
  00067	73 1b		 jae	 SHORT $L294089
  00069	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  0006c	52		 push	 edx
  0006d	55		 push	 ebp
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00075	85 ed		 test	 ebp, ebp
$L294127:
  00077	76 68		 jbe	 SHORT $L294124

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00079	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  0007d	72 2f		 jb	 SHORT $L294099
  0007f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00082	eb 2d		 jmp	 SHORT $L294100

; 611  : 
; 612  : 		if (_Grow(_Num))

$L294089:
  00084	85 ed		 test	 ebp, ebp
  00086	75 ef		 jne	 SHORT $L294127
  00088	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008b	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  0008e	72 0f		 jb	 SHORT $L294081
  00090	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00093	5d		 pop	 ebp
  00094	5f		 pop	 edi
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0
  00098	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  00099	8b c3		 mov	 eax, ebx
  0009b	5b		 pop	 ebx

; 618  : 		}

  0009c	c2 08 00	 ret	 8

; 611  : 
; 612  : 		if (_Grow(_Num))

$L294081:
  0009f	5d		 pop	 ebp
  000a0	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000a3	5f		 pop	 edi
  000a4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a7	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx

; 618  : 		}

  000ab	c2 08 00	 ret	 8

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

$L294099:
  000ae	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
$L294100:
  000b1	8b cd		 mov	 ecx, ebp
  000b3	8b c1		 mov	 eax, ecx
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	f3 a5		 rep movsd
  000ba	8b c8		 mov	 ecx, eax
  000bc	83 e1 03	 and	 ecx, 3
  000bf	f3 a4		 rep movsb

; 615  : 			_Eos(_Num);

  000c1	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  000c5	89 6b 14	 mov	 DWORD PTR [ebx+20], ebp
  000c8	72 10		 jb	 SHORT $L294122
  000ca	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000cd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  000d1	5d		 pop	 ebp
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000d4	8b c3		 mov	 eax, ebx
  000d6	5b		 pop	 ebx

; 618  : 		}

  000d7	c2 08 00	 ret	 8

; 615  : 			_Eos(_Num);

$L294122:
  000da	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000dd	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
$L294124:
  000e1	5d		 pop	 ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 616  : 			}
; 617  : 		return (*this);

  000e4	8b c3		 mov	 eax, ebx
  000e6	5b		 pop	 ebx

; 618  : 		}

  000e7	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?SetEquipDstParam@CMover@@QAEXXZ		; CMover::SetEquipDstParam
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
;	COMDAT ?SetEquipDstParam@CMover@@QAEXXZ
_TEXT	SEGMENT
?SetEquipDstParam@CMover@@QAEXXZ PROC NEAR		; CMover::SetEquipDstParam, COMDAT
; _this$ = ecx

; 2051 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2052 : 	if( IsPlayer() ) 

  00003	8b 87 34 02 00
	00		 mov	 eax, DWORD PTR [edi+564]
  00009	85 c0		 test	 eax, eax
  0000b	74 23		 je	 SHORT $L275746
  0000d	56		 push	 esi

; 2053 : 	{
; 2054 : 		CItemElem* pItemElem;
; 2055 : 		for( int i = 0; i < MAX_HUMAN_PARTS; i++ )

  0000e	33 f6		 xor	 esi, esi
$L275744:

; 2056 : 		{
; 2057 : 			pItemElem = GetEquipItem( i ); //m_Inventory.GetAtId( m_adwEquipment[ i ] );

  00010	56		 push	 esi
  00011	8b cf		 mov	 ecx, edi
  00013	e8 00 00 00 00	 call	 ?GetEquipItem@CMover@@QAEPAVCItemElem@@H@Z ; CMover::GetEquipItem

; 2058 : 			if( pItemElem )

  00018	85 c0		 test	 eax, eax
  0001a	74 0d		 je	 SHORT $L275745

; 2059 : 				SetDestParam( pItemElem->m_dwItemId, FALSE );	//don't send

  0001c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?SetDestParam@CMover@@QAEXHH@Z ; CMover::SetDestParam
$L275745:
  00029	46		 inc	 esi
  0002a	83 fe 1f	 cmp	 esi, 31			; 0000001fH
  0002d	7c e1		 jl	 SHORT $L275744
  0002f	5e		 pop	 esi
$L275746:
  00030	5f		 pop	 edi

; 2060 : 		}
; 2061 : 	}
; 2062 : }

  00031	c3		 ret	 0
?SetEquipDstParam@CMover@@QAEXXZ ENDP			; CMover::SetEquipDstParam
_TEXT	ENDS
PUBLIC	?GetExpFactor@CMover@@QAEMXZ			; CMover::GetExpFactor
EXTRN	?GetEFactor@ILordEvent@@QAEMXZ:NEAR		; ILordEvent::GetEFactor
EXTRN	?GetExpFactor@CEventGeneric@@QAEMXZ:NEAR	; CEventGeneric::GetExpFactor
EXTRN	?GetInstance@CEnvironment@@SAPAV1@XZ:NEAR	; CEnvironment::GetInstance
EXTRN	?m_fMonsterExpRate@CProject@@2MA:DWORD		; CProject::m_fMonsterExpRate
EXTRN	?GetExpFactor@CEventLua@@QAEMH@Z:NEAR		; CEventLua::GetExpFactor
EXTRN	?GetCheerExpFactor@CEventLua@@QAEMH@Z:NEAR	; CEventLua::GetCheerExpFactor
EXTRN	?GetWeatherEventExpFactor@CEventLua@@QAEMH@Z:NEAR ; CEventLua::GetWeatherEventExpFactor
; Function compile flags: /Ogty
;	COMDAT ?GetExpFactor@CMover@@QAEMXZ
_TEXT	SEGMENT
_fFactor$ = -12						; size = 4
_i$276698 = -8						; size = 4
_nDstExp$ = -4						; size = 4
_nExtraEXP$ = -4					; size = 4
?GetExpFactor@CMover@@QAEMXZ PROC NEAR			; CMover::GetExpFactor, COMDAT
; _this$ = ecx

; 4279 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 4280 : 	float fFactor	= 1.0f;
; 4281 : 	if( IsMode( EVENT_OLDBOY_MODE ) )

  00006	f7 86 44 02 00
	00 00 00 01 00	 test	 DWORD PTR [esi+580], 65536 ; 00010000H
  00010	c7 44 24 04 00
	00 80 3f	 mov	 DWORD PTR _fFactor$[esp+16], 1065353216 ; 3f800000H
  00018	74 08		 je	 SHORT $L276693

; 4282 : 		fFactor	*= 1.1f;

  0001a	c7 44 24 04 cd
	cc 8c 3f	 mov	 DWORD PTR _fFactor$[esp+16], 1066192077 ; 3f8ccccdH
$L276693:

; 4283 : 
; 4284 : 	BOOL bGlvCheer	= FALSE;
; 4285 : 	BOOL bSpecial = FALSE;
; 4286 : #ifndef __NEW_STACKABLE_AMPS
; 4287 : 	int nCountBuf = 0;
; 4288 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA ) )
; 4289 : 		++nCountBuf;
; 4290 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA1 ) )
; 4291 : 		++nCountBuf;
; 4292 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESA2 ) )
; 4293 : 		++nCountBuf;
; 4294 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB ) )
; 4295 : 		++nCountBuf;
; 4296 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB1 ) )
; 4297 : 		++nCountBuf;
; 4298 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESB2 ) )
; 4299 : 		++nCountBuf;
; 4300 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC ) )
; 4301 : 		++nCountBuf;
; 4302 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC1 ) )
; 4303 : 		++nCountBuf;
; 4304 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESC2 ) )
; 4305 : 		++nCountBuf;
; 4306 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD ) )
; 4307 : 		++nCountBuf;
; 4308 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD1 ) )
; 4309 : 		++nCountBuf;
; 4310 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESD2 ) )
; 4311 : 		++nCountBuf;
; 4312 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESE ) )
; 4313 : 		++nCountBuf;
; 4314 : #ifdef __S_ADD_EXP
; 4315 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS ) )
; 4316 : 	{
; 4317 : 		++nCountBuf;	bSpecial = TRUE;
; 4318 : 	}
; 4319 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS1 ) )
; 4320 : 	{
; 4321 : 		++nCountBuf;	bSpecial = TRUE;
; 4322 : 	}
; 4323 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPESS2 ) )
; 4324 : 	{
; 4325 : 		++nCountBuf;	bSpecial = TRUE;
; 4326 : 	}
; 4327 : #endif // __S_ADD_EXP
; 4328 : 
; 4329 : 	int nLevel = GetLevel();
; 4330 : 	if( nCountBuf == 1 )
; 4331 : 	{
; 4332 : 		fFactor *= 1.5f;
; 4333 : 	}
; 4334 : 	else if( nCountBuf == 2 )
; 4335 : 	{
; 4336 : 		if( bSpecial || nLevel < 61 )
; 4337 : 			fFactor *= 2.0f;
; 4338 : 		else
; 4339 : 			fFactor *= 1.5f;
; 4340 : 	}
; 4341 : 	else if( 3 <= nCountBuf )
; 4342 : 	{
; 4343 : 		if( bSpecial || nLevel < 41 )
; 4344 : 			fFactor *= 2.5f;
; 4345 : 		else if( nLevel < 61 )
; 4346 : 			fFactor *= 2.0f;
; 4347 : 		else
; 4348 : 			fFactor *= 1.5f;
; 4349 : 	}
; 4350 : 
; 4351 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPES ) )
; 4352 : 		fFactor	*= 1.5f;
; 4353 : 	
; 4354 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_AMPEM ) )
; 4355 : 		fFactor	*= 2.0f;
; 4356 : #else // __NEW_STACKABLE_AMPS
; 4357 : 
; 4358 : 	int nLevel = GetLevel();
; 4359 : 	int nExtraEXP = 0;
; 4360 : 
; 4361 : 	for( MAPBUFF::iterator i = m_buffs.m_mapBuffs.begin(); i != m_buffs.m_mapBuffs.end(); ++i )

  00022	8b 8e f8 02 00
	00		 mov	 ecx, DWORD PTR [esi+760]
  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	53		 push	 ebx
  0002b	8b 9e e0 05 00
	00		 mov	 ebx, DWORD PTR [esi+1504]
  00031	55		 push	 ebp
  00032	33 ed		 xor	 ebp, ebp
  00034	3b c1		 cmp	 eax, ecx
  00036	89 6c 24 14	 mov	 DWORD PTR _nExtraEXP$[esp+24], ebp
  0003a	89 44 24 10	 mov	 DWORD PTR _i$276698[esp+24], eax
  0003e	74 66		 je	 SHORT $L276703
  00040	57		 push	 edi
  00041	8b 3d 5c 02 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+604
$L294191:

; 4362 : 	{
; 4363 : 		ItemProp* pItemProp = prj.GetItemProp( i->second->GetId());

  00047	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0004a	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  0004e	85 c0		 test	 eax, eax
  00050	0f 8c 88 00 00
	00		 jl	 $L294275
  00056	3b c7		 cmp	 eax, edi
  00058	0f 8d 80 00 00
	00		 jge	 $L294275
  0005e	73 2c		 jae	 SHORT $L276702
  00060	8b 0d 4c 02 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A+588
  00066	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 4364 : 
; 4365 : 		if( pItemProp )

  00069	85 c0		 test	 eax, eax
  0006b	74 1f		 je	 SHORT $L276702

; 4366 : 		{
; 4367 : 			if( pItemProp->dwItemKind3 == IK3_EXP_RATE )

  0006d	81 78 78 a4 00
	00 00		 cmp	 DWORD PTR [eax+120], 164 ; 000000a4H
  00074	75 16		 jne	 SHORT $L276702

; 4368 : 			{
; 4369 : 				if( nLevel >= pItemProp->nMinLimitLevel && nLevel <= pItemProp->nMaxLimitLevel )

  00076	3b 98 bc 02 00
	00		 cmp	 ebx, DWORD PTR [eax+700]
  0007c	7c 0e		 jl	 SHORT $L276702
  0007e	3b 98 c0 02 00
	00		 cmp	 ebx, DWORD PTR [eax+704]
  00084	7f 06		 jg	 SHORT $L276702

; 4370 : 				{
; 4371 : 					nExtraEXP += pItemProp->nEffectValue;

  00086	03 a8 d0 02 00
	00		 add	 ebp, DWORD PTR [eax+720]
$L276702:
  0008c	8d 4c 24 14	 lea	 ecx, DWORD PTR _i$276698[esp+28]
  00090	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVIBuff@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVIBuff@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,IBuff *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,IBuff *> >,0> >::const_iterator::_Inc
  00095	8b 44 24 14	 mov	 eax, DWORD PTR _i$276698[esp+28]
  00099	3b 86 f8 02 00
	00		 cmp	 eax, DWORD PTR [esi+760]
  0009f	75 a6		 jne	 SHORT $L294191
  000a1	89 6c 24 18	 mov	 DWORD PTR _nExtraEXP$[esp+28], ebp
  000a5	5f		 pop	 edi
$L276703:

; 4372 : 				}
; 4373 : 			}
; 4374 : 		}
; 4375 : 	}
; 4376 : 	fFactor *= 1.0f + ((float)nExtraEXP / 100 );

  000a6	db 44 24 14	 fild	 DWORD PTR _nExtraEXP$[esp+24]

; 4377 : 
; 4378 : #endif // __NEW_STACKABLE_AMPS
; 4379 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_SCR_GLVCHEER ) )

  000aa	68 e3 28 00 00	 push	 10467			; 000028e3H
  000af	6a 00		 push	 0
  000b1	8b ce		 mov	 ecx, esi
  000b3	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  000b9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  000bf	d8 4c 24 14	 fmul	 DWORD PTR _fFactor$[esp+32]
  000c3	d9 5c 24 14	 fstp	 DWORD PTR _fFactor$[esp+32]
  000c7	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  000cc	85 c0		 test	 eax, eax
  000ce	5d		 pop	 ebp
  000cf	5b		 pop	 ebx
  000d0	74 2a		 je	 SHORT $L294322

; 4380 : 	{
; 4381 : 		bGlvCheer	= TRUE;
; 4382 : 		fFactor	*= 1.10f;

  000d2	d9 44 24 04	 fld	 DWORD PTR _fFactor$[esp+16]
  000d6	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f8ccccd

; 4383 : 	}
; 4384 : 
; 4385 : 	if( !bGlvCheer && HasBuff( BUFF_ITEM, II_CHEERUP ) )

  000dc	eb 65		 jmp	 SHORT $L294324

; 4362 : 	{
; 4363 : 		ItemProp* pItemProp = prj.GetItemProp( i->second->GetId());

$L294275:
  000de	50		 push	 eax
  000df	57		 push	 edi
  000e0	6a 00		 push	 0
  000e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@BEIFNGEL@GetItemProp?5range_error?$AA@
  000e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@HMFGHCP@?$CFs?5min?3?$CFd?0?5max?3?$CFd?0?5index?3?$CFd?$AA@
  000ec	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error

; 4364 : 
; 4365 : 		if( pItemProp )

  000f1	8b 3d 5c 02 00
	00		 mov	 edi, DWORD PTR ?prj@@3VCProject@@A+604
  000f7	83 c4 14	 add	 esp, 20			; 00000014H
  000fa	eb 90		 jmp	 SHORT $L276702
$L294322:

; 4383 : 	}
; 4384 : 
; 4385 : 	if( !bGlvCheer && HasBuff( BUFF_ITEM, II_CHEERUP ) )

  000fc	68 cd 28 00 00	 push	 10445			; 000028cdH
  00101	6a 00		 push	 0
  00103	8b ce		 mov	 ecx, esi
  00105	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  0010a	85 c0		 test	 eax, eax
  0010c	74 39		 je	 SHORT $L276712

; 4386 : 	{
; 4387 : #ifdef __EVENTLUA_CHEEREXP
; 4388 : 		if( prj.m_EventLua.GetCheerExpFactor() > 1.05f )

  0010e	6a 01		 push	 1
  00110	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00115	e8 00 00 00 00	 call	 ?GetCheerExpFactor@CEventLua@@QAEMH@Z ; CEventLua::GetCheerExpFactor
  0011a	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@3f866666
  00120	df e0		 fnstsw	 ax
  00122	f6 c4 41	 test	 ah, 65			; 00000041H
  00125	75 12		 jne	 SHORT $L276711

; 4389 : 			fFactor *= prj.m_EventLua.GetCheerExpFactor();

  00127	6a 01		 push	 1
  00129	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  0012e	e8 00 00 00 00	 call	 ?GetCheerExpFactor@CEventLua@@QAEMH@Z ; CEventLua::GetCheerExpFactor
  00133	d8 4c 24 04	 fmul	 DWORD PTR _fFactor$[esp+16]

; 4390 : 		else

  00137	eb 0a		 jmp	 SHORT $L294324
$L276711:

; 4391 : #endif // __EVENTLUA_CHEEREXP
; 4392 : 			fFactor	*= 1.05f;

  00139	d9 44 24 04	 fld	 DWORD PTR _fFactor$[esp+16]
  0013d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f866666
$L294324:
  00143	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+16]
$L276712:

; 4393 : 	}
; 4394 : 
; 4395 : #ifdef __WORLDSERVER
; 4396 : 
; 4397 : 	fFactor	*= CEventGeneric::GetInstance()->GetExpFactor();

  00147	e8 00 00 00 00	 call	 ?GetInstance@CEventGeneric@@SAPAV1@XZ ; CEventGeneric::GetInstance
  0014c	8b c8		 mov	 ecx, eax
  0014e	e8 00 00 00 00	 call	 ?GetExpFactor@CEventGeneric@@QAEMXZ ; CEventGeneric::GetExpFactor
  00153	d8 4c 24 04	 fmul	 DWORD PTR _fFactor$[esp+16]

; 4398 : #if __VER >= 9 // __EVENTLUA
; 4399 : 	fFactor	*= prj.m_EventLua.GetExpFactor();

  00157	6a 01		 push	 1
  00159	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  0015e	d9 5c 24 08	 fstp	 DWORD PTR _fFactor$[esp+20]
  00162	e8 00 00 00 00	 call	 ?GetExpFactor@CEventLua@@QAEMH@Z ; CEventLua::GetExpFactor
  00167	d8 4c 24 04	 fmul	 DWORD PTR _fFactor$[esp+16]

; 4400 : #endif // __EVENTLUA
; 4401 : 	fFactor		*= prj.m_fMonsterExpRate;
; 4402 : #if __VER >= 9 // __ULTIMATE
; 4403 : 	int nDstExp = GetParam( DST_EXPERIENCE, 0 );

  0016b	8b 86 98 15 00
	00		 mov	 eax, DWORD PTR [esi+5528]
  00171	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00176	d9 05 00 00 00
	00		 fld	 DWORD PTR ?m_fMonsterExpRate@CProject@@2MA ; CProject::m_fMonsterExpRate
  0017c	d8 c9		 fmul	 ST(0), ST(1)
  0017e	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+16]
  00182	dd d8		 fstp	 ST(0)
  00184	75 0a		 jne	 SHORT $L294325
  00186	8b 86 c4 13 00
	00		 mov	 eax, DWORD PTR [esi+5060]
  0018c	85 c0		 test	 eax, eax
  0018e	74 20		 je	 SHORT $L276714
$L294325:

; 4404 : 	if( 0 < nDstExp )

  00190	85 c0		 test	 eax, eax
  00192	89 44 24 0c	 mov	 DWORD PTR _nDstExp$[esp+16], eax
  00196	7e 18		 jle	 SHORT $L276714

; 4405 : 		fFactor *= ( 1.0f + ( nDstExp / 100.0f ) );

  00198	db 44 24 0c	 fild	 DWORD PTR _nDstExp$[esp+16]
  0019c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  001a2	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  001a8	d8 4c 24 04	 fmul	 DWORD PTR _fFactor$[esp+16]
  001ac	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+16]
$L276714:

; 4406 : #endif // __ULTIMATE
; 4407 : 
; 4408 : #if __VER >= 12 // __LORD
; 4409 : 	ILordEvent* pEvent		= CSLord::Instance()->GetEvent();

  001b0	e8 00 00 00 00	 call	 ?Instance@CSLord@@SAPAV1@XZ ; CSLord::Instance

; 4410 : 	fFactor		*= pEvent->GetEFactor();

  001b5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001b8	e8 00 00 00 00	 call	 ?GetEFactor@ILordEvent@@QAEMXZ ; ILordEvent::GetEFactor
  001bd	d8 4c 24 04	 fmul	 DWORD PTR _fFactor$[esp+16]

; 4411 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_LS_CHEERING ) )

  001c1	68 33 4e 00 00	 push	 20019			; 00004e33H
  001c6	6a 00		 push	 0
  001c8	8b ce		 mov	 ecx, esi
  001ca	d9 5c 24 0c	 fstp	 DWORD PTR _fFactor$[esp+24]
  001ce	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001d3	85 c0		 test	 eax, eax
  001d5	74 0e		 je	 SHORT $L276716

; 4412 : 		fFactor		*=	1.1F;

  001d7	d9 44 24 04	 fld	 DWORD PTR _fFactor$[esp+16]
  001db	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f8ccccd
  001e1	d9 5c 24 04	 fstp	 DWORD PTR _fFactor$[esp+16]
$L276716:

; 4413 : 	if( HasBuff( BUFF_ITEM, II_SYS_SYS_VOTE_THANKS ) )

  001e5	68 44 4e 00 00	 push	 20036			; 00004e44H
  001ea	6a 00		 push	 0
  001ec	8b ce		 mov	 ecx, esi
  001ee	e8 00 00 00 00	 call	 ?HasBuff@CMover@@QAEHGG@Z ; CMover::HasBuff
  001f3	85 c0		 test	 eax, eax
  001f5	5e		 pop	 esi
  001f6	74 0c		 je	 SHORT $L276717

; 4414 : 		fFactor		*=	1.05F;

  001f8	d9 04 24	 fld	 DWORD PTR _fFactor$[esp+12]
  001fb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3f866666
  00201	d9 1c 24	 fstp	 DWORD PTR _fFactor$[esp+12]
$L276717:

; 4415 : #endif	// __LORD
; 4416 : 
; 4417 : #ifdef __ENVIRONMENT_EFFECT
; 4418 : 
; 4419 : 	if( CEnvironment::GetInstance()->GetEnvironmentEffect() == TRUE )

  00204	e8 00 00 00 00	 call	 ?GetInstance@CEnvironment@@SAPAV1@XZ ; CEnvironment::GetInstance
  00209	83 b8 d0 02 00
	00 01		 cmp	 DWORD PTR [eax+720], 1
  00210	75 13		 jne	 SHORT $L294323

; 4420 : 	{
; 4421 : 		fFactor *= prj.m_EventLua.GetWeatherEventExpFactor();

  00212	6a 01		 push	 1
  00214	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  00219	e8 00 00 00 00	 call	 ?GetWeatherEventExpFactor@CEventLua@@QAEMH@Z ; CEventLua::GetWeatherEventExpFactor
  0021e	d8 0c 24	 fmul	 DWORD PTR _fFactor$[esp+12]

; 4445 : }

  00221	83 c4 0c	 add	 esp, 12			; 0000000cH
  00224	c3		 ret	 0
$L294323:

; 4422 : 	}
; 4423 : 
; 4424 : #else // __ENVIRONMENT_EFFECT
; 4425 : 
; 4426 : #ifdef __EVENTLUA_RAIN
; 4427 : 	if( g_Environment.m_bRain )
; 4428 : 		fFactor *= prj.m_EventLua.GetRainEventExpFactor();
; 4429 : #else // __EVENTLUA_RAIN
; 4430 : #ifdef __RAIN_EVENT
; 4431 : 	if( g_Environment.m_bRain )
; 4432 : 		fFactor *= 2.0f;
; 4433 : #endif // __RAIN_EVENT
; 4434 : #endif // __EVENTLUA_RAIN
; 4435 : #ifdef __EVENTLUA_SNOW
; 4436 : 	if( g_Environment.m_bSnow )
; 4437 : 		fFactor *= prj.m_EventLua.GetSnowEventExpFactor();
; 4438 : #endif // __EVENTLUA_SNOW
; 4439 : 
; 4440 : #endif // __ENVIRONMENT_EFFECT
; 4441 : 
; 4442 : #endif	// __WORLDSERVER
; 4443 : 
; 4444 : 	return fFactor;

  00225	d9 04 24	 fld	 DWORD PTR _fFactor$[esp+12]

; 4445 : }

  00228	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022b	c3		 ret	 0
?GetExpFactor@CMover@@QAEMXZ ENDP			; CMover::GetExpFactor
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

  00000	56		 push	 esi

; 324  : 		_Tidy();

  00001	33 c0		 xor	 eax, eax
  00003	8b f1		 mov	 esi, ecx

; 325  : 		assign(_Right, 0, npos);

  00005	6a ff		 push	 -1
  00007	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	50		 push	 eax
  00012	88 46 04	 mov	 BYTE PTR [esi+4], al
  00015	8b 44 24 10	 mov	 eax, DWORD PTR __Right$[esp+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogty
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	56		 push	 esi

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Ptr$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	57		 push	 edi
  00008	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$L294399:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $L294399
  00017	2b c7		 sub	 eax, edi
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 623  : 		}

  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??_C@_01HNPIGOCE@?$CG?$AA@			; `string'
PUBLIC	??_C@_0O@KNKGEAPB@ANGEL_EXP_LOG?$AA@		; `string'
PUBLIC	?AddExperience@CMover@@QAEH_JHHH@Z		; CMover::AddExperience
EXTRN	?GetAddExpAfterApplyRestPoint@CUser@@QAE_J_J@Z:NEAR ; CUser::GetAddExpAfterApplyRestPoint
EXTRN	?AddSkillPoint@CMover@@QAEXH@Z:NEAR		; CMover::AddSkillPoint
EXTRN	?SetMasterSkillPointUp@CMover@@QAEXXZ:NEAR	; CMover::SetMasterSkillPointUp
EXTRN	?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z:NEAR ; CDPSrvr::OnLogItem
EXTRN	?HasBuffByIk3@CMover@@QAEHK@Z:NEAR		; CMover::HasBuffByIk3
EXTRN	_sprintf:NEAR
EXTRN	?GetBuffByIk3@CBuffMgr@@QAEPAVIBuff@@K@Z:NEAR	; CBuffMgr::GetBuffByIk3
EXTRN	?GetInstance@CCampusHelper@@SAPAV1@XZ:NEAR	; CCampusHelper::GetInstance
EXTRN	?SetPKPropensity@CMover@@QAEXK@Z:NEAR		; CMover::SetPKPropensity
EXTRN	?SetLevelUpReward@CCampusHelper@@QAEXPAVCUser@@@Z:NEAR ; CCampusHelper::SetLevelUpReward
EXTRN	?g_DPSrvr@@3VCDPSrvr@@A:BYTE			; g_DPSrvr
EXTRN	?GetState@CFlyffEvent@@QAEEH@Z:NEAR		; CFlyffEvent::GetState
EXTRN	?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z:NEAR ; CUserMng::AddPKPropensity
EXTRN	?g_eLocal@@3VCFlyffEvent@@A:BYTE		; g_eLocal
EXTRN	?AddAngelInfo@CUser@@QAEXH@Z:NEAR		; CUser::AddAngelInfo
EXTRN	?SetLevelUpGift@CEventLua@@QAEXPAVCUser@@H@Z:NEAR ; CEventLua::SetLevelUpGift
EXTRN	?SendRecommend@CDPDatabaseClient@@QAEXPAVCUser@@H@Z:NEAR ; CDPDatabaseClient::SendRecommend
EXTRN	?SendLogSkillPoint@CDPDatabaseClient@@QAEXHHPAVCMover@@PAUtagSkill@@@Z:NEAR ; CDPDatabaseClient::SendLogSkillPoint
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\mover.h
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG?$AA@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KNKGEAPB@ANGEL_EXP_LOG?$AA@
CONST	SEGMENT
??_C@_0O@KNKGEAPB@ANGEL_EXP_LOG?$AA@ DB 'ANGEL_EXP_LOG', 00H ; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
CONST	ENDS
;	COMDAT ?AddExperience@CMover@@QAEH_JHHH@Z
_TEXT	SEGMENT
tv904 = -216						; size = 4
tv739 = -216						; size = 4
_wId$275527 = -216					; size = 2
tv856 = -212						; size = 4
tv734 = -212						; size = 8
_nExptmp$275588 = -212					; size = 8
_nMaxAngelExp$275535 = -212				; size = 8
_aLogItem$275546 = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_nExp$ = 8						; size = 8
_bFirstCall$ = 16					; size = 4
_bMultiPly$ = 20					; size = 4
_bMonster$ = 24						; size = 4
?AddExperience@CMover@@QAEH_JHHH@Z PROC NEAR		; CMover::AddExperience, COMDAT
; _this$ = ecx

; 1104 : {

  00000	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 1105 : #ifdef __VTN_TIMELIMIT
; 1106 : 	//	mulcom	BEGIN100315	  
; 1107 : 	if( ::GetLanguage() == LANG_VTN )
; 1108 : 	{
; 1109 : 		if( IsPlayer() && m_nAccountPlayTime != -1 )
; 1110 : 		{
; 1111 : 			if( m_nAccountPlayTime < 0 || m_nAccountPlayTime > MIN( 300 ) )
; 1112 : 			{
; 1113 : 				nExp	= 0;
; 1114 : 			}
; 1115 : 			else if( m_nAccountPlayTime >= MIN( 180 ) && m_nAccountPlayTime <= MIN( 300 ) )
; 1116 : 			{
; 1117 : 				nExp	= (EXPINTEGER)( nExp * 0.5f );
; 1118 : 			}
; 1119 : 		}
; 1120 : 	}
; 1121 : 	//	mulcom	END100315	  
; 1122 : #endif // __VTN_TIMELIMIT
; 1123 : 
; 1124 : 	if( nExp <= 0 )		// nExp  0  .

  0000b	8b 94 24 dc 00
	00 00		 mov	 edx, DWORD PTR _nExp$[esp+212]
  00012	33 c4		 xor	 eax, esp
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR _nExp$[esp+220]
  0001e	85 c9		 test	 ecx, ecx
  00020	89 84 24 d8 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+220], eax
  00027	7f 06		 jg	 SHORT $L275516
  00029	7c 0e		 jl	 SHORT $L294484
  0002b	85 d2		 test	 edx, edx

; 1125 : 		return FALSE;

  0002d	76 0a		 jbe	 SHORT $L294484
$L275516:

; 1126 : 
; 1127 : 	if( m_nHitPoint <= 0 )

  0002f	8b 86 00 06 00
	00		 mov	 eax, DWORD PTR [esi+1536]
  00035	85 c0		 test	 eax, eax
  00037	7f 1a		 jg	 SHORT $L275517
$L294484:

; 1128 : 		return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	5e		 pop	 esi

; 1603 : }

  0003c	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+216]
  00043	33 cc		 xor	 ecx, esp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00050	c2 14 00	 ret	 20			; 00000014H
$L275517:

; 1129 : 
; 1130 : #if __VER < 15 // __GUILD_HOUSE
; 1131 : 	if( bFirstCall && bMultiPly )
; 1132 : 	{
; 1133 : 		nExp	*= GetExpFactor();
; 1134 : 	}
; 1135 : #endif // __GUILD_HOUSE
; 1136 : #ifdef __INTERNALSERVER
; 1137 : 	TRACE( "EXP = %I64d\n", nExp );
; 1138 : #endif	// __INTERNALSERVER
; 1139 : 
; 1140 : #if __VER >= 14 // __ANGEL_EXPERIENCE
; 1141 : #ifdef __3RD_LEGEND16
; 1142 : 	if( IsMaster() || IsHero() || IsLegendHero())

  00053	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  00059	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  0005c	8b 04 c5 e0 27
	00 00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  00063	83 f8 05	 cmp	 eax, 5
  00066	74 0a		 je	 SHORT $L275519
  00068	83 f8 06	 cmp	 eax, 6
  0006b	74 05		 je	 SHORT $L275519
  0006d	83 f8 07	 cmp	 eax, 7
  00070	75 19		 jne	 SHORT $L275518
$L275519:

; 1143 : #else // __3RD_LEGEND16
; 1144 : 	if( IsMaster() || IsHero() )
; 1145 : #endif // __3RD_LEGEND16
; 1146 : 		nExp /= 2;

  00072	6a 00		 push	 0
  00074	6a 02		 push	 2
  00076	51		 push	 ecx
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 __alldiv
  0007d	89 84 24 e0 00
	00 00		 mov	 DWORD PTR _nExp$[esp+216], eax
  00084	89 94 24 e4 00
	00 00		 mov	 DWORD PTR _nExp$[esp+220], edx
$L275518:

; 1147 : #if __VER >= 15 // __GUILD_HOUSE
; 1148 : 	if( bFirstCall && bMultiPly )

  0008b	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _bFirstCall$[esp+216]
  00092	85 c0		 test	 eax, eax
  00094	53		 push	 ebx
  00095	55		 push	 ebp
  00096	57		 push	 edi
  00097	0f 84 57 02 00
	00		 je	 $L275536
  0009d	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _bMultiPly$[esp+228]
  000a4	85 c0		 test	 eax, eax
  000a6	74 42		 je	 SHORT $L275520

; 1149 : 	{
; 1150 : #ifdef __WORLDSERVER
; 1151 : 		EXPINTEGER nAddExp = static_cast<CUser*>( this )->GetAddExpAfterApplyRestPoint( nExp );

  000a8	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR _nExp$[esp+232]
  000af	8b 94 24 ec 00
	00 00		 mov	 edx, DWORD PTR _nExp$[esp+228]
  000b6	51		 push	 ecx
  000b7	52		 push	 edx
  000b8	8b ce		 mov	 ecx, esi
  000ba	e8 00 00 00 00	 call	 ?GetAddExpAfterApplyRestPoint@CUser@@QAE_J_J@Z ; CUser::GetAddExpAfterApplyRestPoint

; 1152 : 		nExp	= (EXPINTEGER)( nExp * GetExpFactor() );

  000bf	8b ce		 mov	 ecx, esi
  000c1	8b f8		 mov	 edi, eax
  000c3	8b da		 mov	 ebx, edx
  000c5	e8 00 00 00 00	 call	 ?GetExpFactor@CMover@@QAEMXZ ; CMover::GetExpFactor

; 1153 : 		nExp += nAddExp;

  000ca	df ac 24 ec 00
	00 00		 fild	 QWORD PTR _nExp$[esp+228]
  000d1	de c9		 fmulp	 ST(1), ST(0)
  000d3	e8 00 00 00 00	 call	 __ftol2
  000d8	03 c7		 add	 eax, edi
  000da	13 d3		 adc	 edx, ebx
  000dc	89 84 24 ec 00
	00 00		 mov	 DWORD PTR _nExp$[esp+228], eax
  000e3	89 94 24 f0 00
	00 00		 mov	 DWORD PTR _nExp$[esp+232], edx
$L275520:

; 1154 : #endif // __WORLDSERVER
; 1155 : 	}
; 1156 : #endif // __GUILD_HOUSE
; 1157 : 
; 1158 : #if __VER >= 8 //__CSC_VER8_5
; 1159 : 	if( bFirstCall && HasBuffByIk3( IK3_ANGEL_BUFF ) )

  000ea	6a 5f		 push	 95			; 0000005fH
  000ec	8b ce		 mov	 ecx, esi
  000ee	e8 00 00 00 00	 call	 ?HasBuffByIk3@CMover@@QAEHK@Z ; CMover::HasBuffByIk3
  000f3	85 c0		 test	 eax, eax
  000f5	0f 84 f9 01 00
	00		 je	 $L275536

; 1160 : 	{
; 1161 : 		int nAngel = 100;
; 1162 : #ifdef __BUFF_1107
; 1163 : 		IBuff* pBuff	= m_buffs.GetBuffByIk3( IK3_ANGEL_BUFF );

  000fb	6a 5f		 push	 95			; 0000005fH
  000fd	8d 8e f0 02 00
	00		 lea	 ecx, DWORD PTR [esi+752]
  00103	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
  00108	e8 00 00 00 00	 call	 ?GetBuffByIk3@CBuffMgr@@QAEPAVIBuff@@K@Z ; CBuffMgr::GetBuffByIk3

; 1164 : 		WORD wId	= ( pBuff? pBuff->GetId(): 0 );

  0010d	85 c0		 test	 eax, eax
  0010f	0f 84 27 02 00
	00		 je	 $L294404
  00115	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]

; 1165 : #else	// __BUFF_1107
; 1166 : 		LPSKILLINFLUENCE lpSkillIn = m_SkillState.GetItemBuf( IK3_ANGEL_BUFF );
; 1167 : 		WORD wId	= ( lpSkillIn? lpSkillIn->wID: 0 );
; 1168 : #endif	// __BUFF_1107
; 1169 : 		if( wId > 0 )

  00119	66 85 c0	 test	 ax, ax
  0011c	89 44 24 10	 mov	 DWORD PTR _wId$275527[esp+232], eax
  00120	76 3d		 jbe	 SHORT $L275533

; 1170 : 		{
; 1171 : 			ItemProp* pItemProp = prj.GetItemProp( wId );

  00122	0f b7 c0	 movzx	 eax, ax
  00125	50		 push	 eax
  00126	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  0012b	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp

; 1172 : 			if( pItemProp )

  00130	85 c0		 test	 eax, eax
  00132	74 2b		 je	 SHORT $L275533

; 1173 : 				nAngel = (int)( (float)pItemProp->nAdjParamVal1 );

  00134	8b 88 58 01 00
	00		 mov	 ecx, DWORD PTR [eax+344]
  0013a	db 80 58 01 00
	00		 fild	 DWORD PTR [eax+344]
  00140	85 c9		 test	 ecx, ecx
  00142	7d 06		 jge	 SHORT $L294502
  00144	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L294502:
  0014a	e8 00 00 00 00	 call	 __ftol2
  0014f	8b f8		 mov	 edi, eax

; 1174 : 		}
; 1175 : 		if( nAngel <= 0 || 100 < nAngel  )

  00151	85 ff		 test	 edi, edi
  00153	7e 05		 jle	 SHORT $L275534
  00155	83 ff 64	 cmp	 edi, 100		; 00000064H
  00158	7e 05		 jle	 SHORT $L275533
$L275534:

; 1176 : 			nAngel = 100;

  0015a	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
$L275533:

; 1177 : 		// :        ,    .
; 1178 : 		EXPINTEGER nMaxAngelExp = prj.m_aExpCharacter[m_nAngelLevel].nExp1 / 100 * nAngel;

  0015f	8b 96 70 07 00
	00		 mov	 edx, DWORD PTR [esi+1904]
  00165	6a 00		 push	 0
  00167	c1 e2 05	 shl	 edx, 5
  0016a	8b 82 f4 4f 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[edx+20468]
  00170	8b 8a f0 4f 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[edx+20464]
  00176	6a 64		 push	 100			; 00000064H
  00178	50		 push	 eax
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 __alldiv
  0017f	8b c8		 mov	 ecx, eax
  00181	8b da		 mov	 ebx, edx
  00183	8b c7		 mov	 eax, edi
  00185	99		 cdq
  00186	52		 push	 edx
  00187	50		 push	 eax
  00188	53		 push	 ebx
  00189	51		 push	 ecx
  0018a	e8 00 00 00 00	 call	 __allmul

; 1179 : 		if( m_nAngelExp < nMaxAngelExp )

  0018f	8b be 6c 07 00
	00		 mov	 edi, DWORD PTR [esi+1900]
  00195	8b 9e 68 07 00
	00		 mov	 ebx, DWORD PTR [esi+1896]
  0019b	8b ea		 mov	 ebp, edx
  0019d	3b fd		 cmp	 edi, ebp
  0019f	89 44 24 14	 mov	 DWORD PTR _nMaxAngelExp$275535[esp+232], eax
  001a3	0f 8f 4b 01 00
	00		 jg	 $L275536
  001a9	7c 08		 jl	 SHORT $L294485
  001ab	3b d8		 cmp	 ebx, eax
  001ad	0f 83 41 01 00
	00		 jae	 $L275536
$L294485:

; 1180 : 		{
; 1181 : 			nExp /= 2;

  001b3	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _nExp$[esp+232]
  001ba	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR _nExp$[esp+228]
  001c1	6a 00		 push	 0
  001c3	6a 02		 push	 2
  001c5	52		 push	 edx
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 __alldiv

; 1182 : 			m_nAngelExp += nExp;

  001cc	03 d8		 add	 ebx, eax
  001ce	13 fa		 adc	 edi, edx

; 1183 : #ifdef __WORLDSERVER
; 1184 : #ifdef __ANGEL_LOG
; 1185 : #ifdef __EXP_ANGELEXP_LOG
; 1186 : 			int nAngelExpPercent = (int)( m_nAngelExp * 100 / nMaxAngelExp );

  001d0	6a 00		 push	 0
  001d2	6a 64		 push	 100			; 00000064H
  001d4	8b cf		 mov	 ecx, edi
  001d6	89 94 24 f8 00
	00 00		 mov	 DWORD PTR _nExp$[esp+240], edx
  001dd	51		 push	 ecx
  001de	8b d3		 mov	 edx, ebx
  001e0	52		 push	 edx
  001e1	89 84 24 fc 00
	00 00		 mov	 DWORD PTR _nExp$[esp+244], eax
  001e8	89 9e 68 07 00
	00		 mov	 DWORD PTR [esi+1896], ebx
  001ee	89 be 6c 07 00
	00		 mov	 DWORD PTR [esi+1900], edi
  001f4	e8 00 00 00 00	 call	 __allmul
  001f9	8b 4c 24 14	 mov	 ecx, DWORD PTR _nMaxAngelExp$275535[esp+232]
  001fd	55		 push	 ebp
  001fe	51		 push	 ecx
  001ff	52		 push	 edx
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 __alldiv

; 1187 : 			int nNextAngelExpLog = (int)(((CUser*)this)->m_nAngelExpLog / 20 + 1) * 20;

  00206	8b 96 20 96 00
	00		 mov	 edx, DWORD PTR [esi+38432]
  0020c	8b c8		 mov	 ecx, eax
  0020e	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00213	f7 ea		 imul	 edx
  00215	c1 fa 03	 sar	 edx, 3
  00218	8b c2		 mov	 eax, edx
  0021a	c1 e8 1f	 shr	 eax, 31			; 0000001fH

; 1188 : 			
; 1189 : 			if( nAngelExpPercent >= nNextAngelExpLog )

  0021d	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]
  00221	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00224	c1 e2 02	 shl	 edx, 2
  00227	3b ca		 cmp	 ecx, edx
  00229	0f 8c 8e 00 00
	00		 jl	 $L294489

; 1190 : 			{
; 1191 : 				((CUser*)this)->m_nAngelExpLog = nAngelExpPercent;
; 1192 : 				ItemProp* pItemProp = prj.GetItemProp( wId );

  0022f	0f b7 44 24 10	 movzx	 eax, WORD PTR _wId$275527[esp+232]
  00234	89 8e 20 96 00
	00		 mov	 DWORD PTR [esi+38432], ecx
  0023a	50		 push	 eax
  0023b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00240	e8 00 00 00 00	 call	 ?GetItemProp@CProject@@QAEPAUItemProp@@H@Z ; CProject::GetItemProp
  00245	8b f8		 mov	 edi, eax

; 1193 : 				
; 1194 : 				if( pItemProp )

  00247	85 ff		 test	 edi, edi
  00249	74 72		 je	 SHORT $L294489

; 1195 : 				{
; 1196 : 					LogItemInfo aLogItem;

  0024b	8d 4c 24 1c	 lea	 ecx, DWORD PTR _aLogItem$275546[esp+232]
  0024f	e8 00 00 00 00	 call	 ??0_LogItemInfo@@QAE@XZ	; _LogItemInfo::_LogItemInfo

; 1197 : 					aLogItem.Action		= "&";
; 1198 : 					aLogItem.SendName	= ((CUser*)this)->GetName();

  00254	6a 00		 push	 0
  00256	8b ce		 mov	 ecx, esi
  00258	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _aLogItem$275546[esp+236], OFFSET FLAT:??_C@_01HNPIGOCE@?$CG?$AA@
  00260	e8 00 00 00 00	 call	 ?GetName@CMover@@QAEPBDH@Z ; CMover::GetName

; 1199 : 					aLogItem.RecvName	= "ANGEL_EXP_LOG";
; 1200 : 					aLogItem.WorldId	= ((CUser*)this)->GetWorld()->GetID();

  00265	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  0026b	89 44 24 20	 mov	 DWORD PTR _aLogItem$275546[esp+236], eax

; 1201 : 					aLogItem.Gold		= aLogItem.Gold2 = ((CUser*)this)->GetGold();

  0026f	8b 86 84 16 00
	00		 mov	 eax, DWORD PTR [esi+5764]
  00275	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _aLogItem$275546[esp+240], OFFSET FLAT:??_C@_0O@KNKGEAPB@ANGEL_EXP_LOG?$AA@
  0027d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027f	89 44 24 30	 mov	 DWORD PTR _aLogItem$275546[esp+252], eax
  00283	89 44 24 2c	 mov	 DWORD PTR _aLogItem$275546[esp+248], eax

; 1202 : 					//aLogItem.ItemName	= pItemProp->szName;
; 1203 : 					_stprintf( aLogItem.szItemName, "%d", pItemProp->dwID );

  00287	8b 07		 mov	 eax, DWORD PTR [edi]
  00289	50		 push	 eax
  0028a	8d 4c 24 44	 lea	 ecx, DWORD PTR _aLogItem$275546[esp+272]
  0028e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00293	51		 push	 ecx
  00294	89 54 24 34	 mov	 DWORD PTR _aLogItem$275546[esp+256], edx
  00298	e8 00 00 00 00	 call	 _sprintf

; 1204 : 					aLogItem.Gold_1		= (DWORD)( m_nAngelExp );

  0029d	8b 96 68 07 00
	00		 mov	 edx, DWORD PTR [esi+1896]
  002a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1205 : 					g_DPSrvr.OnLogItem( aLogItem );

  002a6	6a 00		 push	 0
  002a8	6a 00		 push	 0
  002aa	8d 44 24 24	 lea	 eax, DWORD PTR _aLogItem$275546[esp+240]
  002ae	50		 push	 eax
  002af	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_DPSrvr@@3VCDPSrvr@@A
  002b4	89 54 24 74	 mov	 DWORD PTR _aLogItem$275546[esp+320], edx
  002b8	e8 00 00 00 00	 call	 ?OnLogItem@CDPSrvr@@QAEXAAU_LogItemInfo@@PAVCItemElem@@H@Z ; CDPSrvr::OnLogItem
$L294489:

; 1206 : 				}
; 1207 : 			}
; 1208 : #endif //  __EXP_ANGELEXP_LOG
; 1209 : #endif // __ANGEL_LOG
; 1210 : 			
; 1211 : 			BOOL bAngelComplete = FALSE;
; 1212 : 			if( m_nAngelExp > nMaxAngelExp )

  002bd	8b 8e 6c 07 00
	00		 mov	 ecx, DWORD PTR [esi+1900]
  002c3	33 c0		 xor	 eax, eax
  002c5	3b cd		 cmp	 ecx, ebp
  002c7	7c 23		 jl	 SHORT $L275554
  002c9	7f 0c		 jg	 SHORT $L294490
  002cb	8b 96 68 07 00
	00		 mov	 edx, DWORD PTR [esi+1896]
  002d1	3b 54 24 14	 cmp	 edx, DWORD PTR _nMaxAngelExp$275535[esp+232]
  002d5	76 15		 jbe	 SHORT $L275554
$L294490:

; 1213 : 			{
; 1214 : 				m_nAngelExp = nMaxAngelExp;

  002d7	8b 44 24 14	 mov	 eax, DWORD PTR _nMaxAngelExp$275535[esp+232]
  002db	89 86 68 07 00
	00		 mov	 DWORD PTR [esi+1896], eax
  002e1	89 ae 6c 07 00
	00		 mov	 DWORD PTR [esi+1900], ebp

; 1215 : 				bAngelComplete = TRUE;

  002e7	b8 01 00 00 00	 mov	 eax, 1
$L275554:

; 1216 : 			}
; 1217 : 			((CUser*)this)->AddAngelInfo( bAngelComplete );

  002ec	50		 push	 eax
  002ed	8b ce		 mov	 ecx, esi
  002ef	e8 00 00 00 00	 call	 ?AddAngelInfo@CUser@@QAEXH@Z ; CUser::AddAngelInfo
$L275536:

; 1218 : #endif // __WORLDSERVER
; 1219 : 		}
; 1220 : 	}
; 1221 : #endif // __CSC_VER8_5
; 1222 : #endif // __ANGEL_EXPERIENCE
; 1223 : 
; 1224 : 	if( IsBaseJob() )

  002f4	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  002fa	8d 0c c0	 lea	 ecx, DWORD PTR [eax+eax*8]
  002fd	8b 04 cd e0 27
	00 00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[ecx*8+10208]
  00304	85 c0		 test	 eax, eax
  00306	bf 78 00 00 00	 mov	 edi, 120		; 00000078H
  0030b	bb 82 00 00 00	 mov	 ebx, 130		; 00000082H
  00310	bd 96 00 00 00	 mov	 ebp, 150		; 00000096H
  00315	75 32		 jne	 SHORT $L275556

; 1225 : 	{
; 1226 : 		if( m_nLevel >= MAX_JOB_LEVEL )

  00317	83 be e0 05 00
	00 0f		 cmp	 DWORD PTR [esi+1504], 15 ; 0000000fH
  0031e	0f 8c bd 00 00
	00		 jl	 $L275572

; 1227 : 		{
; 1228 : 			m_nExp1		= 0;

  00324	33 c0		 xor	 eax, eax
  00326	89 86 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], eax
  0032c	89 86 ec 05 00
	00		 mov	 DWORD PTR [esi+1516], eax

; 1229 : 			return TRUE;

  00332	b8 01 00 00 00	 mov	 eax, 1
  00337	e9 33 03 00 00	 jmp	 $L294499
$L294404:

; 1164 : 		WORD wId	= ( pBuff? pBuff->GetId(): 0 );

  0033c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _wId$275527[esp+232], 0

; 1165 : #else	// __BUFF_1107
; 1166 : 		LPSKILLINFLUENCE lpSkillIn = m_SkillState.GetItemBuf( IK3_ANGEL_BUFF );
; 1167 : 		WORD wId	= ( lpSkillIn? lpSkillIn->wID: 0 );
; 1168 : #endif	// __BUFF_1107
; 1169 : 		if( wId > 0 )

  00344	e9 16 fe ff ff	 jmp	 $L275533
$L275556:

; 1230 : 		}
; 1231 : 	}
; 1232 : 	else if( IsExpert() )

  00349	83 f8 01	 cmp	 eax, 1
  0034c	75 25		 jne	 SHORT $L275559

; 1233 : 	{
; 1234 : 		if( m_nLevel >= MAX_JOB_LEVEL + MAX_EXP_LEVEL )

  0034e	83 be e0 05 00
	00 3c		 cmp	 DWORD PTR [esi+1504], 60 ; 0000003cH
  00355	0f 8c 86 00 00
	00		 jl	 $L275572

; 1235 : 		{
; 1236 : 			m_nExp1		= 0;

  0035b	33 c0		 xor	 eax, eax
  0035d	89 86 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], eax
  00363	89 86 ec 05 00
	00		 mov	 DWORD PTR [esi+1516], eax

; 1237 : 			return TRUE;

  00369	b8 01 00 00 00	 mov	 eax, 1
  0036e	e9 fc 02 00 00	 jmp	 $L294499
$L275559:

; 1238 : 		}
; 1239 : 	}
; 1240 : 	else if( IsPro() )

  00373	83 f8 02	 cmp	 eax, 2
  00376	75 18		 jne	 SHORT $L275562
$L294507:

; 1241 : 	{
; 1242 : 		if( m_nLevel > MAX_GENERAL_LEVEL )

  00378	39 be e0 05 00
	00		 cmp	 DWORD PTR [esi+1504], edi
  0037e	7e 61		 jle	 SHORT $L275572

; 1243 : 		{
; 1244 : 			m_nLevel = MAX_GENERAL_LEVEL;

  00380	89 be e0 05 00
	00		 mov	 DWORD PTR [esi+1504], edi

; 1245 : 			return TRUE;

  00386	b8 01 00 00 00	 mov	 eax, 1
  0038b	e9 df 02 00 00	 jmp	 $L294499
$L275562:

; 1246 : 		}		
; 1247 : 	}
; 1248 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1249 : 	else if(IsMaster())

  00390	8b ce		 mov	 ecx, esi
  00392	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  00397	85 c0		 test	 eax, eax

; 1250 : 	{
; 1251 : 		if( m_nLevel > MAX_GENERAL_LEVEL )
; 1252 : 		{
; 1253 : 			m_nLevel = MAX_GENERAL_LEVEL;
; 1254 : 			return TRUE;

  00399	75 dd		 jne	 SHORT $L294507

; 1255 : 		}
; 1256 : #if __VER < 14 // __ANGEL_EXPERIENCE
; 1257 : 		else
; 1258 : 		{
; 1259 : 			nExp /= 2;
; 1260 : 		}
; 1261 : #endif // __ANGEL_EXPERIENCE
; 1262 : 	}
; 1263 : 	else if(IsHero())

  0039b	8b ce		 mov	 ecx, esi
  0039d	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  003a2	85 c0		 test	 eax, eax
  003a4	74 18		 je	 SHORT $L275568

; 1264 : 	{
; 1265 : #ifdef __3RD_LEGEND16
; 1266 : 		if( m_nLevel >= MAX_LEGEND_LEVEL  )

  003a6	39 9e e0 05 00
	00		 cmp	 DWORD PTR [esi+1504], ebx
  003ac	7c 33		 jl	 SHORT $L275572

; 1267 : #else // __3RD_LEGEND16
; 1268 : 		if( m_nLevel >  MAX_LEGEND_LEVEL  )
; 1269 : #endif // __3RD_LEGEND16
; 1270 : 		{
; 1271 : 			m_nLevel = MAX_LEGEND_LEVEL;

  003ae	89 9e e0 05 00
	00		 mov	 DWORD PTR [esi+1504], ebx

; 1272 : 			return TRUE;

  003b4	b8 01 00 00 00	 mov	 eax, 1
  003b9	e9 b1 02 00 00	 jmp	 $L294499
$L275568:

; 1273 : 		}
; 1274 : #if __VER < 14 // __ANGEL_EXPERIENCE
; 1275 : 		else
; 1276 : 		{
; 1277 : 			nExp /= 2;
; 1278 : 		}
; 1279 : #endif // __ANGEL_EXPERIENCE
; 1280 : 	}
; 1281 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1282 : #ifdef __3RD_LEGEND16
; 1283 : 	else if( IsLegendHero() )

  003be	8b ce		 mov	 ecx, esi
  003c0	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  003c5	85 c0		 test	 eax, eax
  003c7	74 18		 je	 SHORT $L275572

; 1284 : 	{
; 1285 : 		if( m_nLevel > MAX_3RD_LEGEND_LEVEL )

  003c9	39 ae e0 05 00
	00		 cmp	 DWORD PTR [esi+1504], ebp
  003cf	7e 10		 jle	 SHORT $L275572

; 1286 : 		{
; 1287 : 			m_nLevel = MAX_3RD_LEGEND_LEVEL;

  003d1	89 ae e0 05 00
	00		 mov	 DWORD PTR [esi+1504], ebp

; 1288 : 			return TRUE;

  003d7	b8 01 00 00 00	 mov	 eax, 1
  003dc	e9 8e 02 00 00	 jmp	 $L294499
$L275572:

; 1289 : 		}
; 1290 : 	}
; 1291 : #endif // __3RD_LEGEND16
; 1292 : 
; 1293 : 	int nLevelbuf = m_nLevel;
; 1294 : 	int nNextLevel = m_nLevel + 1;

  003e1	8b 9e e0 05 00
	00		 mov	 ebx, DWORD PTR [esi+1504]

; 1295 : 
; 1296 : #if __VER < 14 // __ANGEL_EXPERIENCE
; 1297 : #if __VER >= 8 //__CSC_VER8_5
; 1298 : 	if( bFirstCall && HasBuffByIk3( IK3_ANGEL_BUFF ) )
; 1299 : 	{
; 1300 : 		int nAngel = 100;
; 1301 : #ifdef __BUFF_1107
; 1302 : 		IBuff* pBuff	= m_buffs.GetBuffByIk3( IK3_ANGEL_BUFF );
; 1303 : 		WORD wId	= ( pBuff? pBuff->GetId(): 0 );
; 1304 : #else	// __BUFF_1107
; 1305 : 		LPSKILLINFLUENCE lpSkillIn = m_SkillState.GetItemBuf( IK3_ANGEL_BUFF );
; 1306 : 		WORD wId	= ( lpSkillIn? lpSkillIn->wID: 0 );
; 1307 : #endif	// __BUFF_1107
; 1308 : 		if( wId > 0 )
; 1309 : 		{
; 1310 : 			ItemProp* pItemProp = prj.GetItemProp( wId );
; 1311 : 			if( pItemProp )
; 1312 : 				nAngel = (float)pItemProp->nAdjParamVal1;
; 1313 : 		}
; 1314 : 		if( nAngel <= 0 || 100 < nAngel  )
; 1315 : 			nAngel = 100;
; 1316 : 		// :        ,    .
; 1317 : 		EXPINTEGER nMaxAngelExp = prj.m_aExpCharacter[m_nAngelLevel].nExp1 / 100 * nAngel;
; 1318 : 		if( m_nAngelExp < nMaxAngelExp )
; 1319 : 		{
; 1320 : 			nExp /= 2;
; 1321 : 			m_nAngelExp += nExp;
; 1322 : #ifdef __WORLDSERVER
; 1323 : #ifdef __ANGEL_LOG
; 1324 : #ifdef __EXP_ANGELEXP_LOG
; 1325 : 			int nAngelExpPercent = m_nAngelExp * 100 / nMaxAngelExp;
; 1326 : 			int nNextAngelExpLog = (int)(((CUser*)this)->m_nAngelExpLog / 20 + 1) * 20;
; 1327 : 	
; 1328 : 			if( nAngelExpPercent >= nNextAngelExpLog )
; 1329 : 			{
; 1330 : 				((CUser*)this)->m_nAngelExpLog = nAngelExpPercent;
; 1331 : 				ItemProp* pItemProp = prj.GetItemProp( wId );
; 1332 : 
; 1333 : 				if( pItemProp )
; 1334 : 				{
; 1335 : 					LogItemInfo aLogItem;
; 1336 : 					aLogItem.Action = "&";
; 1337 : 					aLogItem.SendName = ((CUser*)this)->GetName();
; 1338 : 					aLogItem.RecvName = "ANGEL_EXP_LOG";
; 1339 : 					aLogItem.WorldId = ((CUser*)this)->GetWorld()->GetID();
; 1340 : 					aLogItem.Gold = aLogItem.Gold2 = ((CUser*)this)->GetGold();
; 1341 : 					//aLogItem.ItemName = pItemProp->szName;
; 1342 : 					_stprintf( aLogItem.szItemName, "%d", pItemProp->dwID );
; 1343 : 					aLogItem.Gold_1 = m_nAngelExp;
; 1344 : 					g_DPSrvr.OnLogItem( aLogItem );
; 1345 : 				}
; 1346 : 			}
; 1347 : #endif //  __EXP_ANGELEXP_LOG
; 1348 : #endif // __ANGEL_LOG
; 1349 : 
; 1350 : 			BOOL bAngelComplete = FALSE;
; 1351 : 			if( m_nAngelExp > nMaxAngelExp )
; 1352 : 			{
; 1353 : 				m_nAngelExp = nMaxAngelExp;
; 1354 : 				bAngelComplete = TRUE;
; 1355 : 			}
; 1356 : 			((CUser*)this)->AddAngelInfo( bAngelComplete );
; 1357 : #endif // __WORLDSERVER
; 1358 : 		}
; 1359 : 	}
; 1360 : #endif // __CSC_VER8_5
; 1361 : #endif // __ANGEL_EXPERIENCE
; 1362 : 
; 1363 : 	m_nExp1 += nExp;									// pxp  exp . !

  003e7	8b ae e8 05 00
	00		 mov	 ebp, DWORD PTR [esi+1512]
  003ed	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR _nExp$[esp+228]
  003f4	8b be ec 05 00
	00		 mov	 edi, DWORD PTR [esi+1516]
  003fa	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _nExp$[esp+232]

; 1364 : 	
; 1365 : 	if( bFirstCall )

  00401	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR _bFirstCall$[esp+228]
  00408	43		 inc	 ebx
  00409	03 e8		 add	 ebp, eax
  0040b	13 fa		 adc	 edi, edx
  0040d	85 c9		 test	 ecx, ecx
  0040f	89 ae e8 05 00
	00		 mov	 DWORD PTR [esi+1512], ebp
  00415	89 be ec 05 00
	00		 mov	 DWORD PTR [esi+1516], edi
  0041b	0f 84 9b 00 00
	00		 je	 $L275582

; 1366 : 	{
; 1367 : #if __VER >= 8 // __S8_PK
; 1368 : #ifdef __WORLDSERVER
; 1369 : 		if( bMonster && IsChaotic() )

  00421	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _bMonster$[esp+228]
  00428	85 c9		 test	 ecx, ecx
  0042a	0f 84 8c 00 00
	00		 je	 $L275582
  00430	8b 8e 60 07 00
	00		 mov	 ecx, DWORD PTR [esi+1888]
  00436	85 c9		 test	 ecx, ecx
  00438	89 4c 24 10	 mov	 DWORD PTR tv739[esp+232], ecx
  0043c	76 7e		 jbe	 SHORT $L275582

; 1370 : 		{
; 1371 : 			m_dwPKExp	= (DWORD)( m_dwPKExp + nExp );

  0043e	8b 96 64 07 00
	00		 mov	 edx, DWORD PTR [esi+1892]
  00444	03 d0		 add	 edx, eax

; 1372 : 			DWORD dwPropensity = GetPKPropensity(); // undorflow
; 1373 : 			int nLevelPKExp = prj.GetLevelExp( GetLevel() ); // Level  

  00446	8b 86 e0 05 00
	00		 mov	 eax, DWORD PTR [esi+1504]
  0044c	50		 push	 eax
  0044d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A
  00452	89 96 64 07 00
	00		 mov	 DWORD PTR [esi+1892], edx
  00458	8b ea		 mov	 ebp, edx
  0045a	e8 00 00 00 00	 call	 ?GetLevelExp@CProject@@QAEKH@Z ; CProject::GetLevelExp
  0045f	8b f8		 mov	 edi, eax

; 1374 : 			if( nLevelPKExp != 0 )

  00461	85 ff		 test	 edi, edi
  00463	74 57		 je	 SHORT $L275582

; 1375 : 			{
; 1376 : 				int nSubExp = m_dwPKExp / nLevelPKExp;

  00465	33 d2		 xor	 edx, edx
  00467	8b c5		 mov	 eax, ebp
  00469	f7 f7		 div	 edi

; 1377 : 				if( nSubExp )

  0046b	85 c0		 test	 eax, eax
  0046d	74 4d		 je	 SHORT $L275582

; 1378 : 				{
; 1379 : 					SetPKPropensity( GetPKPropensity() - ( m_dwPKExp / nLevelPKExp ) );

  0046f	8b 6c 24 10	 mov	 ebp, DWORD PTR tv739[esp+232]
  00473	8b cd		 mov	 ecx, ebp
  00475	2b c8		 sub	 ecx, eax
  00477	51		 push	 ecx
  00478	8b ce		 mov	 ecx, esi
  0047a	e8 00 00 00 00	 call	 ?SetPKPropensity@CMover@@QAEXK@Z ; CMover::SetPKPropensity

; 1380 : 					if( dwPropensity <= GetPKPropensity() )

  0047f	3b ae 60 07 00
	00		 cmp	 ebp, DWORD PTR [esi+1888]
  00485	77 09		 ja	 SHORT $L294496

; 1381 : 						SetPKPropensity( 0 );

  00487	6a 00		 push	 0
  00489	8b ce		 mov	 ecx, esi
  0048b	e8 00 00 00 00	 call	 ?SetPKPropensity@CMover@@QAEXK@Z ; CMover::SetPKPropensity
$L294496:

; 1382 : 					m_dwPKExp %= nLevelPKExp;

  00490	8b 86 64 07 00
	00		 mov	 eax, DWORD PTR [esi+1892]
  00496	33 d2		 xor	 edx, edx
  00498	f7 f7		 div	 edi

; 1383 : 					
; 1384 : 					g_UserMng.AddPKPropensity( this );

  0049a	56		 push	 esi
  0049b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_UserMng@@3VCUserMng@@A
  004a0	89 96 64 07 00
	00		 mov	 DWORD PTR [esi+1892], edx
  004a6	e8 00 00 00 00	 call	 ?AddPKPropensity@CUserMng@@QAEXPAVCMover@@@Z ; CUserMng::AddPKPropensity

; 1385 : 					g_dpDBClient.SendLogPkPvp( this, NULL, 0, 'P' );

  004ab	6a 50		 push	 80			; 00000050H
  004ad	6a 00		 push	 0
  004af	6a 00		 push	 0
  004b1	56		 push	 esi
  004b2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  004b7	e8 00 00 00 00	 call	 ?SendLogPkPvp@CDPDatabaseClient@@QAEXPAVCMover@@0HD@Z ; CDPDatabaseClient::SendLogPkPvp
$L275582:

; 1386 : 				}
; 1387 : 			}
; 1388 : 		}
; 1389 : #endif // __WORLDSERVER
; 1390 : #endif // __VER >= 8 // __S8_PK
; 1391 : 	}
; 1392 : 
; 1393 : 	if( m_nExp1 >= prj.m_aExpCharacter[nNextLevel].nExp1 )	// 

  004bc	8b ae ec 05 00
	00		 mov	 ebp, DWORD PTR [esi+1516]
  004c2	8b 86 e8 05 00
	00		 mov	 eax, DWORD PTR [esi+1512]
  004c8	8b fb		 mov	 edi, ebx
  004ca	c1 e7 05	 shl	 edi, 5
  004cd	3b af f4 4f 00
	00		 cmp	 ebp, DWORD PTR ?prj@@3VCProject@@A[edi+20468]
  004d3	89 44 24 14	 mov	 DWORD PTR tv734[esp+232], eax
  004d7	0f 8c 90 01 00
	00		 jl	 $L275584
  004dd	7f 0c		 jg	 SHORT $L294487
  004df	3b 87 f0 4f 00
	00		 cmp	 eax, DWORD PTR ?prj@@3VCProject@@A[edi+20464]
  004e5	0f 82 82 01 00
	00		 jb	 $L275584
$L294487:

; 1394 : 	{
; 1395 : #ifdef __3RD_LEGEND16
; 1396 : 		if( IsLegendHero() && ( nNextLevel > MAX_3RD_LEGEND_LEVEL ) )

  004eb	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  004f1	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  004f4	89 44 24 10	 mov	 DWORD PTR tv904[esp+232], eax
  004f8	8b 04 c5 e0 27
	00 00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[eax*8+10208]
  004ff	83 f8 07	 cmp	 eax, 7
  00502	75 17		 jne	 SHORT $L275585
  00504	81 fb 96 00 00
	00		 cmp	 ebx, 150		; 00000096H
  0050a	7e 0f		 jle	 SHORT $L275585

; 1397 : 		{
; 1398 : 			m_nLevel = MAX_3RD_LEGEND_LEVEL;

  0050c	c7 86 e0 05 00
	00 96 00 00 00	 mov	 DWORD PTR [esi+1504], 150 ; 00000096H

; 1399 : 
; 1400 : 			m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);
; 1401 : 			return FALSE;

  00516	e9 84 01 00 00	 jmp	 $L294506
$L275585:

; 1402 : 		}
; 1403 : 		else if( !IsHero() && !IsLegendHero() && nNextLevel > MAX_GENERAL_LEVEL )

  0051b	83 f8 06	 cmp	 eax, 6
  0051e	74 1f		 je	 SHORT $L275587
  00520	8b ce		 mov	 ecx, esi
  00522	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  00527	85 c0		 test	 eax, eax
  00529	75 14		 jne	 SHORT $L275587
  0052b	83 fb 78	 cmp	 ebx, 120		; 00000078H
  0052e	7e 0f		 jle	 SHORT $L275587

; 1404 : 		{
; 1405 : 			m_nLevel = MAX_GENERAL_LEVEL;

  00530	c7 86 e0 05 00
	00 78 00 00 00	 mov	 DWORD PTR [esi+1504], 120 ; 00000078H

; 1406 : 
; 1407 : 			m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);
; 1408 : 			return FALSE;

  0053a	e9 bb 01 00 00	 jmp	 $L294505
$L275587:

; 1409 : 		}
; 1410 : #else // __3RD_LEGEND16
; 1411 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1412 : 		if( IsHero() && ( nNextLevel > MAX_LEGEND_LEVEL ) )
; 1413 : 		{
; 1414 : 			m_nLevel = MAX_LEGEND_LEVEL;
; 1415 : 
; 1416 : 			m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);
; 1417 : 			return FALSE;
; 1418 : 		}
; 1419 : 		else if( !IsHero() && nNextLevel > MAX_GENERAL_LEVEL )
; 1420 : 		{
; 1421 : 			m_nLevel = MAX_GENERAL_LEVEL;
; 1422 : 
; 1423 : 			m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);
; 1424 : 			return FALSE;
; 1425 : 		}
; 1426 : #else //__LEGEND	//	10 	Neuz, World, Trans
; 1427 : 		if( nNextLevel > MAX_GENERAL_LEVEL )
; 1428 : 		{
; 1429 : 			m_nLevel = MAX_GENERAL_LEVEL;
; 1430 : 
; 1431 : 			m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);
; 1432 : 			return FALSE;
; 1433 : 		}
; 1434 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1435 : #endif // __3RD_LEGEND16
; 1436 : 		EXPINTEGER nExptmp;
; 1437 : //		BOOL f	= FALSE;
; 1438 : 
; 1439 : 		{
; 1440 : 			m_nRemainGP += prj.m_aExpCharacter[ nNextLevel ].dwLPPoint;

  0053f	8b 87 00 50 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[edi+20480]
  00545	01 86 0c 06 00
	00		 add	 DWORD PTR [esi+1548], eax

; 1441 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1442 : #ifdef __3RD_LEGEND16
; 1443 : 			if( IsMaster() || IsHero() || IsLegendHero() )

  0054b	8b 4c 24 10	 mov	 ecx, DWORD PTR tv904[esp+232]
  0054f	83 3c cd e0 27
	00 00 05	 cmp	 DWORD PTR ?prj@@3VCProject@@A[ecx*8+10208], 5
  00557	74 16		 je	 SHORT $L294492
  00559	8b ce		 mov	 ecx, esi
  0055b	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  00560	85 c0		 test	 eax, eax
  00562	75 0b		 jne	 SHORT $L294492
  00564	8b ce		 mov	 ecx, esi
  00566	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  0056b	85 c0		 test	 eax, eax
  0056d	74 0d		 je	 SHORT $L294493
$L294492:

; 1444 : #else // __3RD_LEGEND16
; 1445 : 			if( IsMaster() || IsHero() )
; 1446 : #endif // __3RD_LEGEND16
; 1447 : 				m_nRemainGP++;

  0056f	8b 86 0c 06 00
	00		 mov	 eax, DWORD PTR [esi+1548]
  00575	40		 inc	 eax
  00576	89 86 0c 06 00
	00		 mov	 DWORD PTR [esi+1548], eax
$L294493:

; 1448 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1449 : 
; 1450 : 			nExptmp		= m_nExp1 - prj.m_aExpCharacter[nNextLevel].nExp1;

  0057c	8b 8f f0 4f 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[edi+20464]
  00582	8b 97 f4 4f 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[edi+20468]
  00588	8b 44 24 14	 mov	 eax, DWORD PTR tv734[esp+232]
  0058c	2b c1		 sub	 eax, ecx
  0058e	1b ea		 sbb	 ebp, edx

; 1451 : #if __VER >= 8  
; 1452 : 			m_nExp1		= 0;
; 1453 : #else //  __VER >= 8  
; 1454 : 			m_nExp1		= m_nDeathExp		= 0;
; 1455 : #endif //  __VER >= 8  
; 1456 : 			m_nLevel	= nNextLevel;
; 1457 : 
; 1458 : //			if( m_nLevel > m_nDeathLevel )
; 1459 : //				f	= TRUE;
; 1460 : 
; 1461 : 			BOOL bLevelUp = TRUE;
; 1462 : 			if( IsBaseJob() && m_nLevel > MAX_JOB_LEVEL ) 

  00590	8b 54 24 10	 mov	 edx, DWORD PTR tv904[esp+232]
  00594	89 44 24 14	 mov	 DWORD PTR _nExptmp$275588[esp+232], eax
  00598	33 c0		 xor	 eax, eax
  0059a	89 86 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], eax
  005a0	89 86 ec 05 00
	00		 mov	 DWORD PTR [esi+1516], eax
  005a6	89 9e e0 05 00
	00		 mov	 DWORD PTR [esi+1504], ebx
  005ac	39 04 d5 e0 27
	00 00		 cmp	 DWORD PTR ?prj@@3VCProject@@A[edx*8+10208], eax
  005b3	89 6c 24 18	 mov	 DWORD PTR _nExptmp$275588[esp+236], ebp
  005b7	75 60		 jne	 SHORT $L275592
  005b9	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  005bc	7e 5b		 jle	 SHORT $L275592

; 1463 : 			{
; 1464 : 				m_nLevel = MAX_JOB_LEVEL;

  005be	c7 86 e0 05 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+1504], 15 ; 0000000fH
$L275603:

; 1567 : #endif // __CAMPUS
; 1568 : 				}
; 1569 : #endif // __WORLDSERVER
; 1570 : 			}
; 1571 : 			else
; 1572 : 			{
; 1573 : 				m_nRemainGP -= prj.m_aExpCharacter[ nNextLevel ].dwLPPoint;

  005c8	8b 97 00 50 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[edi+20480]
  005ce	8b be 0c 06 00
	00		 mov	 edi, DWORD PTR [esi+1548]
  005d4	2b fa		 sub	 edi, edx

; 1574 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1575 : #ifdef __3RD_LEGEND16
; 1576 : 				if( IsMaster() || IsHero() || IsLegendHero() )

  005d6	8b ce		 mov	 ecx, esi
  005d8	89 be 0c 06 00
	00		 mov	 DWORD PTR [esi+1548], edi
  005de	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  005e3	85 c0		 test	 eax, eax
  005e5	75 16		 jne	 SHORT $L275619
  005e7	8b ce		 mov	 ecx, esi
  005e9	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  005ee	85 c0		 test	 eax, eax
  005f0	75 0b		 jne	 SHORT $L275619
  005f2	8b ce		 mov	 ecx, esi
  005f4	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  005f9	85 c0		 test	 eax, eax
  005fb	74 07		 je	 SHORT $L275618
$L275619:

; 1577 : #else // __3RD_LEGEND16
; 1578 : 				if( IsMaster() || IsHero() )
; 1579 : #endif // __3RD_LEGEND16
; 1580 : 					m_nRemainGP--;

  005fd	4f		 dec	 edi
  005fe	89 be 0c 06 00
	00		 mov	 DWORD PTR [esi+1548], edi
$L275618:

; 1581 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1582 : 				nExptmp	= m_nExp1	= 0;

  00604	33 c0		 xor	 eax, eax
  00606	89 86 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], eax
  0060c	89 86 ec 05 00
	00		 mov	 DWORD PTR [esi+1516], eax

; 1599 : 		return TRUE;

  00612	b8 01 00 00 00	 mov	 eax, 1
  00617	eb 56		 jmp	 SHORT $L294499
$L275592:

; 1465 : 				bLevelUp = FALSE;
; 1466 : 			}
; 1467 : 			else if( IsExpert() && m_nLevel > MAX_JOB_LEVEL + MAX_EXP_LEVEL )

  00619	8b ce		 mov	 ecx, esi
  0061b	e8 00 00 00 00	 call	 ?IsExpert@CMover@@QAEHXZ ; CMover::IsExpert
  00620	85 c0		 test	 eax, eax
  00622	74 11		 je	 SHORT $L275594
  00624	83 fb 3c	 cmp	 ebx, 60			; 0000003cH
  00627	7e 0c		 jle	 SHORT $L275594

; 1468 : 			{
; 1469 : 				m_nLevel = MAX_JOB_LEVEL + MAX_EXP_LEVEL;

  00629	c7 86 e0 05 00
	00 3c 00 00 00	 mov	 DWORD PTR [esi+1504], 60 ; 0000003cH

; 1470 : 				bLevelUp = FALSE;
; 1471 : 			}
; 1472 : 			else if( IsPro() && m_nLevel > MAX_GENERAL_LEVEL )

  00633	eb 93		 jmp	 SHORT $L275603
$L275594:
  00635	8b ce		 mov	 ecx, esi
  00637	e8 00 00 00 00	 call	 ?IsPro@CMover@@QAEHXZ	; CMover::IsPro
  0063c	85 c0		 test	 eax, eax
  0063e	bd 78 00 00 00	 mov	 ebp, 120		; 00000078H
  00643	74 45		 je	 SHORT $L275596
  00645	3b dd		 cmp	 ebx, ebp
  00647	7e 41		 jle	 SHORT $L275596

; 1473 : 			{
; 1474 : 				m_nLevel = MAX_GENERAL_LEVEL;

  00649	89 ae e0 05 00
	00		 mov	 DWORD PTR [esi+1504], ebp

; 1475 : 				bLevelUp = FALSE;
; 1476 : 
; 1477 : 				m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);

  0064f	8b 87 f0 4f 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[edi+20464]
  00655	8b 8f f4 4f 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[edi+20468]
  0065b	83 e8 01	 sub	 eax, 1
  0065e	83 d9 00	 sbb	 ecx, 0
  00661	89 86 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], eax
  00667	89 8e ec 05 00
	00		 mov	 DWORD PTR [esi+1516], ecx
$L275584:

; 1600 : 	}
; 1601 : 
; 1602 : 	return FALSE;

  0066d	33 c0		 xor	 eax, eax
$L294499:

; 1603 : }

  0066f	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+232]
  00676	5f		 pop	 edi
  00677	5d		 pop	 ebp
  00678	5b		 pop	 ebx
  00679	5e		 pop	 esi
  0067a	33 cc		 xor	 ecx, esp
  0067c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00681	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00687	c2 14 00	 ret	 20			; 00000014H
$L275596:

; 1478 : 				nExptmp  = 0;
; 1479 : 				return FALSE;
; 1480 : 			}
; 1481 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1482 : 			else if( IsMaster() && m_nLevel > MAX_GENERAL_LEVEL )

  0068a	8b ce		 mov	 ecx, esi
  0068c	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  00691	85 c0		 test	 eax, eax
  00693	74 2a		 je	 SHORT $L275598
  00695	3b dd		 cmp	 ebx, ebp
  00697	7e 26		 jle	 SHORT $L275598

; 1483 : 			{
; 1484 : 				m_nLevel = MAX_GENERAL_LEVEL;

  00699	89 ae e0 05 00
	00		 mov	 DWORD PTR [esi+1504], ebp
$L294506:

; 1485 : 				bLevelUp = FALSE;
; 1486 : 				m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);

  0069f	8b 97 f0 4f 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[edi+20464]
  006a5	8b 87 f4 4f 00
	00		 mov	 eax, DWORD PTR ?prj@@3VCProject@@A[edi+20468]
  006ab	83 ea 01	 sub	 edx, 1
  006ae	83 d8 00	 sbb	 eax, 0
  006b1	89 96 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], edx
  006b7	89 86 ec 05 00
	00		 mov	 DWORD PTR [esi+1516], eax

; 1487 : 				nExptmp  = 0;
; 1488 : 				return FALSE;

  006bd	eb ae		 jmp	 SHORT $L275584
$L275598:

; 1489 : 			}
; 1490 : #ifdef __3RD_LEGEND16
; 1491 : 			else if( IsHero() && (m_nLevel > MAX_LEGEND_LEVEL ) )

  006bf	8b ce		 mov	 ecx, esi
  006c1	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  006c6	85 c0		 test	 eax, eax
  006c8	74 17		 je	 SHORT $L275600
  006ca	81 fb 82 00 00
	00		 cmp	 ebx, 130		; 00000082H
  006d0	7e 0f		 jle	 SHORT $L275600

; 1492 : 			{
; 1493 : 				m_nLevel = MAX_LEGEND_LEVEL;

  006d2	c7 86 e0 05 00
	00 82 00 00 00	 mov	 DWORD PTR [esi+1504], 130 ; 00000082H

; 1494 : 				bLevelUp = FALSE;
; 1495 : 			}
; 1496 : 			else if( IsLegendHero() && m_nLevel > MAX_3RD_LEGEND_LEVEL )

  006dc	e9 e7 fe ff ff	 jmp	 $L275603
$L275600:
  006e1	8b ce		 mov	 ecx, esi
  006e3	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  006e8	85 c0		 test	 eax, eax
  006ea	74 31		 je	 SHORT $L294483
  006ec	81 fb 96 00 00
	00		 cmp	 ebx, 150		; 00000096H
  006f2	7e 29		 jle	 SHORT $L294483

; 1497 : 			{
; 1498 : 				m_nLevel = MAX_GENERAL_LEVEL;

  006f4	89 ae e0 05 00
	00		 mov	 DWORD PTR [esi+1504], ebp
$L294505:

; 1499 : 				bLevelUp = FALSE;
; 1500 : 				m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);

  006fa	8b 8f f0 4f 00
	00		 mov	 ecx, DWORD PTR ?prj@@3VCProject@@A[edi+20464]
  00700	8b 97 f4 4f 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[edi+20468]
  00706	83 e9 01	 sub	 ecx, 1
  00709	83 da 00	 sbb	 edx, 0
  0070c	89 8e e8 05 00
	00		 mov	 DWORD PTR [esi+1512], ecx
  00712	89 96 ec 05 00
	00		 mov	 DWORD PTR [esi+1516], edx

; 1501 : 				nExptmp  = 0;
; 1502 : 				return FALSE;

  00718	e9 50 ff ff ff	 jmp	 $L275584
$L294483:

; 1503 : 			}			
; 1504 : #else // __3RD_LEGEND16
; 1505 : 			else if( IsHero() && (m_nLevel > MAX_LEGEND_LEVEL ) )
; 1506 : 			{
; 1507 : 				m_nLevel = MAX_LEGEND_LEVEL;
; 1508 : 				bLevelUp = FALSE;
; 1509 : 				m_nExp1  = (prj.m_aExpCharacter[nNextLevel].nExp1 - 1);
; 1510 : 				nExptmp  = 0;
; 1511 : 				return FALSE;
; 1512 : 			}
; 1513 : #endif // __3RD_LEGEND16
; 1514 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1515 : 
; 1516 : 			if( bLevelUp )
; 1517 : 			{
; 1518 : 				m_nHitPoint = GetMaxHitPoint();

  0071d	8b ce		 mov	 ecx, esi
  0071f	e8 00 00 00 00	 call	 ?GetMaxHitPoint@CMover@@QAEHXZ ; CMover::GetMaxHitPoint

; 1519 : 				m_nManaPoint = GetMaxManaPoint();

  00724	8b ce		 mov	 ecx, esi
  00726	89 86 00 06 00
	00		 mov	 DWORD PTR [esi+1536], eax
  0072c	e8 00 00 00 00	 call	 ?GetMaxManaPoint@CMover@@QAEHXZ ; CMover::GetMaxManaPoint

; 1520 : 				m_nFatiguePoint = GetMaxFatiguePoint();

  00731	8b ce		 mov	 ecx, esi
  00733	89 86 04 06 00
	00		 mov	 DWORD PTR [esi+1540], eax
  00739	e8 00 00 00 00	 call	 ?GetMaxFatiguePoint@CMover@@QAEHXZ ; CMover::GetMaxFatiguePoint

; 1521 : 				SetJobLevel( m_nLevel, m_nJob );

  0073e	8b 8e e0 05 00
	00		 mov	 ecx, DWORD PTR [esi+1504]
  00744	89 86 08 06 00
	00		 mov	 DWORD PTR [esi+1544], eax
  0074a	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  00750	50		 push	 eax
  00751	51		 push	 ecx
  00752	8b ce		 mov	 ecx, esi
  00754	e8 00 00 00 00	 call	 ?SetJobLevel@CMover@@QAEXHH@Z ; CMover::SetJobLevel

; 1522 : #if __VER >= 8  
; 1523 : 				if( m_nDeathLevel >= m_nLevel )

  00759	8b ae e4 05 00
	00		 mov	 ebp, DWORD PTR [esi+1508]
  0075f	8b 9e e0 05 00
	00		 mov	 ebx, DWORD PTR [esi+1504]
  00765	3b eb		 cmp	 ebp, ebx
  00767	7c 44		 jl	 SHORT $L294504

; 1524 : 				{
; 1525 : 					m_nRemainGP -= prj.m_aExpCharacter[ nNextLevel ].dwLPPoint;

  00769	8b 97 00 50 00
	00		 mov	 edx, DWORD PTR ?prj@@3VCProject@@A[edi+20480]
  0076f	8b be 0c 06 00
	00		 mov	 edi, DWORD PTR [esi+1548]
  00775	2b fa		 sub	 edi, edx

; 1526 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1527 : #ifdef __3RD_LEGEND16
; 1528 : 					if( IsMaster() || IsHero() || IsLegendHero() )

  00777	8b ce		 mov	 ecx, esi
  00779	89 be 0c 06 00
	00		 mov	 DWORD PTR [esi+1548], edi
  0077f	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  00784	85 c0		 test	 eax, eax
  00786	75 16		 jne	 SHORT $L275606
  00788	8b ce		 mov	 ecx, esi
  0078a	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  0078f	85 c0		 test	 eax, eax
  00791	75 0b		 jne	 SHORT $L275606
  00793	8b ce		 mov	 ecx, esi
  00795	e8 00 00 00 00	 call	 ?IsLegendHero@CMover@@QAEHXZ ; CMover::IsLegendHero
  0079a	85 c0		 test	 eax, eax
  0079c	74 07		 je	 SHORT $L275605
$L275606:

; 1529 : #else // __3RD_LEGEND16
; 1530 : 					if( IsMaster() || IsHero() )
; 1531 : #endif // __3RD_LEGEND16
; 1532 : 						m_nRemainGP--;

  0079e	4f		 dec	 edi
  0079f	89 be 0c 06 00
	00		 mov	 DWORD PTR [esi+1548], edi
$L275605:

; 1533 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1534 : 				}
; 1535 : #endif //  __VER >= 8  
; 1536 : 
; 1537 : #ifdef __WORLDSERVER
; 1538 : 				if( m_nDeathLevel < m_nLevel )

  007a5	3b eb		 cmp	 ebp, ebx
  007a7	0f 8d 9d 00 00
	00		 jge	 $L294491
$L294504:

; 1539 : 				{
; 1540 : 					int nGetPoint = ((GetLevel() - 1) / 20) + 2;

  007ad	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  007b0	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  007b5	f7 e9		 imul	 ecx
  007b7	c1 fa 03	 sar	 edx, 3
  007ba	8b c2		 mov	 eax, edx
  007bc	c1 e8 1f	 shr	 eax, 31			; 0000001fH

; 1541 : #if __VER >= 10 // __LEGEND	//	10 	Neuz, World, Trans
; 1542 : 					if( IsMaster() || IsHero() )

  007bf	8b ce		 mov	 ecx, esi
  007c1	8d 7c 02 02	 lea	 edi, DWORD PTR [edx+eax+2]
  007c5	e8 00 00 00 00	 call	 ?IsMaster@CMover@@QAEHXZ ; CMover::IsMaster
  007ca	85 c0		 test	 eax, eax
  007cc	75 25		 jne	 SHORT $L275610
  007ce	8b ce		 mov	 ecx, esi
  007d0	e8 00 00 00 00	 call	 ?IsHero@CMover@@QAEHXZ	; CMover::IsHero
  007d5	85 c0		 test	 eax, eax
  007d7	75 1a		 jne	 SHORT $L275610

; 1544 : 					else
; 1545 : #endif	//__LEGEND	//	10 	Neuz, World, Trans
; 1546 : 					{
; 1547 : 						AddSkillPoint( nGetPoint );

  007d9	57		 push	 edi
  007da	8b ce		 mov	 ecx, esi
  007dc	e8 00 00 00 00	 call	 ?AddSkillPoint@CMover@@QAEXH@Z ; CMover::AddSkillPoint

; 1548 : 						g_dpDBClient.SendLogSkillPoint( LOG_SKILLPOINT_GET_HUNT, nGetPoint, this, NULL );

  007e1	6a 00		 push	 0
  007e3	56		 push	 esi
  007e4	57		 push	 edi
  007e5	6a 01		 push	 1
  007e7	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  007ec	e8 00 00 00 00	 call	 ?SendLogSkillPoint@CDPDatabaseClient@@QAEXHHPAVCMover@@PAUtagSkill@@@Z ; CDPDatabaseClient::SendLogSkillPoint
  007f1	eb 07		 jmp	 SHORT $L275611
$L275610:

; 1543 : 						SetMasterSkillPointUp();

  007f3	8b ce		 mov	 ecx, esi
  007f5	e8 00 00 00 00	 call	 ?SetMasterSkillPointUp@CMover@@QAEXXZ ; CMover::SetMasterSkillPointUp
$L275611:

; 1549 : #ifdef __S_NEW_SKILL_2
; 1550 : 						g_dpDBClient.SaveSkill( (CUser*)this );
; 1551 : #endif // __S_NEW_SKILL_2
; 1552 : 					}
; 1553 : #ifdef __S_RECOMMEND_EVE
; 1554 : 				    if( g_eLocal.GetState( EVE_RECOMMEND ) && IsPlayer() )

  007fa	6a 15		 push	 21			; 00000015H
  007fc	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_eLocal@@3VCFlyffEvent@@A
  00801	e8 00 00 00 00	 call	 ?GetState@CFlyffEvent@@QAEEH@Z ; CFlyffEvent::GetState
  00806	84 c0		 test	 al, al
  00808	74 17		 je	 SHORT $L294497
  0080a	8b 86 34 02 00
	00		 mov	 eax, DWORD PTR [esi+564]
  00810	85 c0		 test	 eax, eax
  00812	74 0d		 je	 SHORT $L294497

; 1555 : 					{
; 1556 : 						g_dpDBClient.SendRecommend( (CUser*)this );

  00814	6a 00		 push	 0
  00816	56		 push	 esi
  00817	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?g_dpDBClient@@3VCDPDatabaseClient@@A
  0081c	e8 00 00 00 00	 call	 ?SendRecommend@CDPDatabaseClient@@QAEXPAVCUser@@H@Z ; CDPDatabaseClient::SendRecommend
$L294497:

; 1557 : 					}					
; 1558 : #endif // __S_RECOMMEND_EVE
; 1559 : #ifdef __EXP_ANGELEXP_LOG
; 1560 : 					((CUser*)this)->m_nExpLog = 0;
; 1561 : #endif // __EXP_ANGELEXP_LOG
; 1562 : #ifdef __EVENTLUA_GIFT
; 1563 : 					prj.m_EventLua.SetLevelUpGift( (CUser*)this, m_nLevel );

  00821	8b 8e e0 05 00
	00		 mov	 ecx, DWORD PTR [esi+1504]
  00827	51		 push	 ecx
  00828	56		 push	 esi
  00829	b9 f8 91 11 00	 mov	 ecx, OFFSET FLAT:?prj@@3VCProject@@A+1151480
  0082e	c7 86 1c 96 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+38428], 0
  00838	e8 00 00 00 00	 call	 ?SetLevelUpGift@CEventLua@@QAEXPAVCUser@@H@Z ; CEventLua::SetLevelUpGift

; 1564 : #endif // __EVENTLUA_GIFT
; 1565 : #if __VER >= 15 // __CAMPUS
; 1566 : 					CCampusHelper::GetInstance()->SetLevelUpReward( (CUser*)this );

  0083d	56		 push	 esi
  0083e	e8 00 00 00 00	 call	 ?GetInstance@CCampusHelper@@SAPAV1@XZ ; CCampusHelper::GetInstance
  00843	8b c8		 mov	 ecx, eax
  00845	e8 00 00 00 00	 call	 ?SetLevelUpReward@CCampusHelper@@QAEXPAVCUser@@@Z ; CCampusHelper::SetLevelUpReward
$L294491:

; 1583 : 			}
; 1584 : 
; 1585 : 			//  20   1.
; 1586 : 			if( m_nLevel == 20 )
; 1587 : 				SetFlightLv( 1 );
; 1588 : 			
; 1589 : #ifdef __CLIENT
; 1590 : 			if( m_pActMover && ( m_pActMover->IsState( OBJSTA_STAND ) || m_pActMover->IsState( OBJSTA_STAND2 )) )
; 1591 : 				SetMotion( MTI_LEVELUP, ANILOOP_1PLAY, MOP_FIXED );
; 1592 : 			CreateSfx(g_Neuz.m_pd3dDevice,XI_GEN_LEVEL_UP01,GetPos(),GetId());
; 1593 : 			PlayMusic( BGM_IN_LEVELUP );
; 1594 : #endif	// __CLIENT
; 1595 : 		}
; 1596 : 
; 1597 : 		if( nExptmp > 0 )

  0084a	8b 44 24 18	 mov	 eax, DWORD PTR _nExptmp$275588[esp+236]
  0084e	85 c0		 test	 eax, eax
  00850	7c 23		 jl	 SHORT $L275621
  00852	7f 08		 jg	 SHORT $L294495
  00854	8b 4c 24 14	 mov	 ecx, DWORD PTR _nExptmp$275588[esp+232]
  00858	85 c9		 test	 ecx, ecx
  0085a	76 19		 jbe	 SHORT $L275621
$L294495:

; 1598 : 			AddExperience( nExptmp, FALSE, bMultiPly );

  0085c	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR _bMultiPly$[esp+228]
  00863	8b 54 24 14	 mov	 edx, DWORD PTR _nExptmp$275588[esp+232]
  00867	6a 00		 push	 0
  00869	51		 push	 ecx
  0086a	6a 00		 push	 0
  0086c	50		 push	 eax
  0086d	52		 push	 edx
  0086e	8b ce		 mov	 ecx, esi
  00870	e8 00 00 00 00	 call	 ?AddExperience@CMover@@QAEH_JHHH@Z ; CMover::AddExperience
$L275621:

; 1599 : 		return TRUE;

  00875	b8 01 00 00 00	 mov	 eax, 1
  0087a	e9 f0 fd ff ff	 jmp	 $L294499
?AddExperience@CMover@@QAEH_JHHH@Z ENDP			; CMover::AddExperience
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T294611 DD	0ffffffffH
	DD	FLAT:$L294511
$T294609 DD	019930520H
	DD	01H
	DD	FLAT:$T294611
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	e8 00 00 00 00	 call	 ??0exception@@QAE@XZ	; exception::exception
  00022	33 c0		 xor	 eax, eax
  00024	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	6a ff		 push	 -1
  0002f	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00032	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00039	50		 push	 eax
  0003a	89 44 24 18	 mov	 DWORD PTR __$EHRec$[esp+36], eax
  0003e	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00041	8b 44 24 20	 mov	 eax, DWORD PTR __Message$[esp+24]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 20   : 		}

  0004b	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L294511:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T294609
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Message$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogty
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L294621
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L294621:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00009	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000d	72 0c		 jb	 SHORT $L294709
  0000f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$L294709:
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH
  00024	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00027	88 46 10	 mov	 BYTE PTR [esi+16], al
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 361  : 		_Tidy();
; 362  : 		assign(_Ptr);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b c2		 mov	 eax, edx
  00009	57		 push	 edi
  0000a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00011	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00018	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$L294803:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L294803
  00027	2b c7		 sub	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00032	5f		 pop	 edi

; 363  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ ; std::vector<long,std::allocator<long> >::_Xlen
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	SEGMENT
$T294924 DD	0ffffffffH
	DD	FLAT:$L294809
$T294921 DD	019930520H
	DD	01H
	DD	FLAT:$T294924
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Ogty
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T294808 = -80						; size = 28
$T294807 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ PROC NEAR ; std::vector<long,std::allocator<long> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  00018	6a 12		 push	 18			; 00000012H
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4c 24 08	 lea	 ecx, DWORD PTR $T294808[esp+88]
  00023	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T294808[esp+112], 15 ; 0000000fH
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T294808[esp+108], 0
  00033	c6 44 24 0c 00	 mov	 BYTE PTR $T294808[esp+92], 0
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8d 04 24	 lea	 eax, DWORD PTR $T294808[esp+80]
  00040	50		 push	 eax
  00041	8d 4c 24 20	 lea	 ecx, DWORD PTR $T294807[esp+84]
  00045	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0004d	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00052	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00057	8d 4c 24 20	 lea	 ecx, DWORD PTR $T294807[esp+84]
  0005b	51		 push	 ecx
  0005c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T294807[esp+88], OFFSET FLAT:??_7length_error@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L294925:
$L294923:
  00069	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L294809:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T294808[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T294921
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ ENDP	; std::vector<long,std::allocator<long> >::_Xlen
;	COMDAT xdata$x
xdata$x	SEGMENT
$T295031 DD	0ffffffffH
	DD	FLAT:$L294931
$T295029 DD	019930520H
	DD	01H
	DD	FLAT:$T295031
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	e8 00 00 00 00	 call	 ??0exception@@QAE@ABV0@@Z ; exception::exception
  00028	33 c0		 xor	 eax, eax
  0002a	6a ff		 push	 -1
  0002c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
  00035	50		 push	 eax
  00036	83 c7 0c	 add	 edi, 12			; 0000000cH
  00039	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00040	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00043	57		 push	 edi
  00044	89 44 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], eax
  00048	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00050	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00054	5f		 pop	 edi
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L294931:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T295029
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogty
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___that$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@
  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z ; std::vector<long,std::allocator<long> >::_Insert_n
; Function compile flags: /Ogty
;	COMDAT ?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z
_TEXT	SEGMENT
__Newvec$221171 = -4					; size = 4
tv393 = 8						; size = 4
__Where$ = 8						; size = 4
tv382 = 12						; size = 4
__Count$ = 12						; size = 4
__Tmp$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00001	8b 44 24 10	 mov	 eax, DWORD PTR __Val$[esp]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 811  : 		size_type _Capacity = capacity();

  00008	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000b	85 d2		 test	 edx, edx
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	57		 push	 edi
  00010	89 4c 24 18	 mov	 DWORD PTR __Tmp$[esp+8], ecx
  00014	75 04		 jne	 SHORT $L295051
  00016	33 c0		 xor	 eax, eax
  00018	eb 08		 jmp	 SHORT $L295052
$L295051:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	2b c2		 sub	 eax, edx
  0001f	c1 f8 02	 sar	 eax, 2
$L295052:

; 812  : 
; 813  : 		if (_Count == 0)

  00022	8b 7c 24 14	 mov	 edi, DWORD PTR __Count$[esp+8]
  00026	85 ff		 test	 edi, edi
  00028	0f 84 ac 01 00
	00		 je	 $L221191

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0002e	85 d2		 test	 edx, edx
  00030	75 04		 jne	 SHORT $L295074
  00032	33 c9		 xor	 ecx, ecx
  00034	eb 08		 jmp	 SHORT $L295075
$L295074:
  00036	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00039	2b ca		 sub	 ecx, edx
  0003b	c1 f9 02	 sar	 ecx, 2
$L295075:
  0003e	53		 push	 ebx
  0003f	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00044	2b d9		 sub	 ebx, ecx
  00046	3b df		 cmp	 ebx, edi
  00048	73 07		 jae	 SHORT $L221167

; 816  : 			_Xlen();	// result too long

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?_Xlen@?$vector@JV?$allocator@J@std@@@std@@IBEXXZ ; std::vector<long,std::allocator<long> >::_Xlen
$L295206:
$L221167:

; 817  : 		else if (_Capacity < size() + _Count)

  00051	85 d2		 test	 edx, edx
  00053	75 04		 jne	 SHORT $L295081
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 08		 jmp	 SHORT $L295082
$L295081:
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2
$L295082:
  00061	03 cf		 add	 ecx, edi
  00063	3b c1		 cmp	 eax, ecx
  00065	55		 push	 ebp
  00066	0f 83 d6 00 00
	00		 jae	 $L221169

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006c	8b c8		 mov	 ecx, eax
  0006e	d1 e9		 shr	 ecx, 1
  00070	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00075	2b d9		 sub	 ebx, ecx
  00077	3b d8		 cmp	 ebx, eax
  00079	73 04		 jae	 SHORT $L295041
  0007b	33 c0		 xor	 eax, eax
  0007d	eb 02		 jmp	 SHORT $L295042
$L295041:
  0007f	03 c1		 add	 eax, ecx
$L295042:

; 821  : 			if (_Capacity < size() + _Count)

  00081	85 d2		 test	 edx, edx
  00083	75 04		 jne	 SHORT $L295104
  00085	33 c9		 xor	 ecx, ecx
  00087	eb 08		 jmp	 SHORT $L295105
$L295104:
  00089	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0008c	2b ca		 sub	 ecx, edx
  0008e	c1 f9 02	 sar	 ecx, 2
$L295105:
  00091	03 cf		 add	 ecx, edi
  00093	3b c1		 cmp	 eax, ecx
  00095	73 12		 jae	 SHORT $L221170

; 822  : 				_Capacity = size() + _Count;

  00097	85 d2		 test	 edx, edx
  00099	75 04		 jne	 SHORT $L295111
  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $L295112
$L295111:
  0009f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a2	2b c2		 sub	 eax, edx
  000a4	c1 f8 02	 sar	 eax, 2
$L295112:
  000a7	03 c7		 add	 eax, edi
$L221170:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000a9	c1 e0 02	 shl	 eax, 2
  000ac	50		 push	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR tv382[esp+20], eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b9	8b 5c 24 1c	 mov	 ebx, DWORD PTR __Where$[esp+20]
  000bd	8b d0		 mov	 edx, eax
  000bf	8b c3		 mov	 eax, ebx
  000c1	2b c1		 sub	 eax, ecx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	8d 2c 85 00 00
	00 00		 lea	 ebp, DWORD PTR [eax*4]
  000cd	55		 push	 ebp
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	89 54 24 20	 mov	 DWORD PTR __Newvec$221171[esp+36], edx
  000d4	e8 00 00 00 00	 call	 _memmove
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  000dc	8d 54 24 20	 lea	 edx, DWORD PTR __Tmp$[esp+16]
  000e0	52		 push	 edx
  000e1	03 c5		 add	 eax, ebp
  000e3	57		 push	 edi
  000e4	50		 push	 eax
  000e5	8b ce		 mov	 ecx, esi
  000e7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ; std::vector<long,std::allocator<long> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000ec	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ef	2b cb		 sub	 ecx, ebx
  000f1	c1 f9 02	 sar	 ecx, 2
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	51		 push	 ecx
  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $L295193
  00109	33 c9		 xor	 ecx, ecx
  0010b	eb 08		 jmp	 SHORT $L295194
$L295193:
  0010d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00110	2b c8		 sub	 ecx, eax
  00112	c1 f9 02	 sar	 ecx, 2
$L295194:
  00115	03 f9		 add	 edi, ecx

; 838  : 			if (_Myfirst != 0)

  00117	85 c0		 test	 eax, eax
  00119	74 09		 je	 SHORT $L295198

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00121	83 c4 04	 add	 esp, 4
$L295198:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  00124	8b 44 24 10	 mov	 eax, DWORD PTR __Newvec$221171[esp+20]
  00128	8b 54 24 1c	 mov	 edx, DWORD PTR tv382[esp+16]
  0012c	5d		 pop	 ebp
  0012d	5b		 pop	 ebx

; 844  : 			_Mylast = _Newvec + _Count;

  0012e	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00131	03 d0		 add	 edx, eax
  00133	5f		 pop	 edi
  00134	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00137	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 845  : 			_Myfirst = _Newvec;

  0013a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0013d	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  0013e	59		 pop	 ecx
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$L221169:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  00142	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00145	8b 5c 24 18	 mov	 ebx, DWORD PTR __Where$[esp+16]
  00149	8b d5		 mov	 edx, ebp
  0014b	2b d3		 sub	 edx, ebx
  0014d	c1 fa 02	 sar	 edx, 2
  00150	3b d7		 cmp	 edx, edi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  00152	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00159	8b ce		 mov	 ecx, esi
  0015b	89 44 24 18	 mov	 DWORD PTR tv393[esp+16], eax
  0015f	73 4b		 jae	 SHORT $L221182
  00161	03 c3		 add	 eax, ebx
  00163	50		 push	 eax
  00164	55		 push	 ebp
  00165	53		 push	 ebx
  00166	e8 00 00 00 00	 call	 ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ; std::vector<long,std::allocator<long> >::_Ucopy<long *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0016b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0016e	8b d0		 mov	 edx, eax
  00170	2b d3		 sub	 edx, ebx
  00172	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00176	51		 push	 ecx
  00177	c1 fa 02	 sar	 edx, 2
  0017a	2b fa		 sub	 edi, edx
  0017c	57		 push	 edi
  0017d	50		 push	 eax
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?_Ufill@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJIABJ@Z ; std::vector<long,std::allocator<long> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  00185	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00188	8b 44 24 18	 mov	 eax, DWORD PTR tv393[esp+16]
  0018c	03 c8		 add	 ecx, eax
  0018e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00191	8b f1		 mov	 esi, ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00193	8d 4c 24 20	 lea	 ecx, DWORD PTR __Tmp$[esp+16]
  00197	51		 push	 ecx
  00198	2b f0		 sub	 esi, eax
  0019a	56		 push	 esi
  0019b	53		 push	 ebx
  0019c	e8 00 00 00 00	 call	 ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z ; std::fill<long *,long>
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5d		 pop	 ebp
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001a8	59		 pop	 ecx
  001a9	c2 0c 00	 ret	 12			; 0000000cH
$L221182:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  001ac	55		 push	 ebp
  001ad	8b fd		 mov	 edi, ebp
  001af	2b f8		 sub	 edi, eax
  001b1	55		 push	 ebp
  001b2	57		 push	 edi
  001b3	e8 00 00 00 00	 call	 ??$_Ucopy@PAJ@?$vector@JV?$allocator@J@std@@@std@@IAEPAJPAJ00@Z ; std::vector<long,std::allocator<long> >::_Ucopy<long *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  001b8	55		 push	 ebp
  001b9	57		 push	 edi
  001ba	53		 push	 ebx
  001bb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001be	e8 00 00 00 00	 call	 ??$copy_backward@PAJPAJ@std@@YAPAJPAJ00@Z ; std::copy_backward<long *,long *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  001c3	8b 44 24 24	 mov	 eax, DWORD PTR tv393[esp+28]
  001c7	8d 54 24 2c	 lea	 edx, DWORD PTR __Tmp$[esp+28]
  001cb	52		 push	 edx
  001cc	03 c3		 add	 eax, ebx
  001ce	50		 push	 eax
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 ??$fill@PAJJ@std@@YAXPAJ0ABJ@Z ; std::fill<long *,long>
  001d5	83 c4 18	 add	 esp, 24			; 00000018H
  001d8	5d		 pop	 ebp
  001d9	5b		 pop	 ebx
$L221191:
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi

; 873  : 			}
; 874  : 		}

  001dc	59		 pop	 ecx
  001dd	c2 0c 00	 ret	 12			; 0000000cH
$L295205:
?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z ENDP ; std::vector<long,std::allocator<long> >::_Insert_n
_TEXT	ENDS
PUBLIC	?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ; std::vector<long,std::allocator<long> >::resize
; Function compile flags: /Ogty
;	COMDAT ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z PROC NEAR ; std::vector<long,std::allocator<long> >::resize, COMDAT
; _this$ = ecx

; 507  : 		{	// determine new length, padding with _Val elements as needed

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 508  : 		if (size() < _Newsize)

  00003	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00006	85 d2		 test	 edx, edx
  00008	57		 push	 edi
  00009	75 04		 jne	 SHORT $L295219
  0000b	33 c0		 xor	 eax, eax
  0000d	eb 08		 jmp	 SHORT $L295220
$L295219:
  0000f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00012	2b c2		 sub	 eax, edx
  00014	c1 f8 02	 sar	 eax, 2
$L295220:
  00017	8b 7c 24 0c	 mov	 edi, DWORD PTR __Newsize$[esp+4]
  0001b	3b c7		 cmp	 eax, edi
  0001d	73 28		 jae	 SHORT $L219677

; 509  : 			_Insert_n(end(), _Newsize - size(), _Val);

  0001f	85 d2		 test	 edx, edx
  00021	75 04		 jne	 SHORT $L295226
  00023	33 c0		 xor	 eax, eax
  00025	eb 08		 jmp	 SHORT $L295227
$L295226:
  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	2b c2		 sub	 eax, edx
  0002c	c1 f8 02	 sar	 eax, 2
$L295227:
  0002f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00032	8d 54 24 10	 lea	 edx, DWORD PTR __Val$[esp+4]
  00036	52		 push	 edx
  00037	2b f8		 sub	 edi, eax
  00039	57		 push	 edi
  0003a	51		 push	 ecx
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@JV?$allocator@J@std@@@std@@IAEXViterator@12@IABJ@Z ; std::vector<long,std::allocator<long> >::_Insert_n
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 512  : 		}

  00044	c2 08 00	 ret	 8
$L219677:

; 510  : 		else if (_Newsize < size())

  00047	85 d2		 test	 edx, edx
  00049	74 33		 je	 SHORT $L295339
  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	8b c8		 mov	 ecx, eax
  00050	2b ca		 sub	 ecx, edx
  00052	c1 f9 02	 sar	 ecx, 2
  00055	3b f9		 cmp	 edi, ecx
  00057	73 25		 jae	 SHORT $L295339

; 511  : 			erase(begin() + _Newsize, end());

  00059	8d 14 ba	 lea	 edx, DWORD PTR [edx+edi*4]
  0005c	3b d0		 cmp	 edx, eax
  0005e	74 1e		 je	 SHORT $L295339
  00060	8b c8		 mov	 ecx, eax
  00062	2b c8		 sub	 ecx, eax
  00064	c1 f9 02	 sar	 ecx, 2
  00067	8d 3c 8d 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*4]
  0006e	57		 push	 edi
  0006f	50		 push	 eax
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _memmove
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	03 c7		 add	 eax, edi
  0007b	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L295339:
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 512  : 		}

  00080	c2 08 00	 ret	 8
?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ENDP ; std::vector<long,std::allocator<long> >::resize
_TEXT	ENDS
PUBLIC	?SetVisKeepTimeSize@CPiercing@@QAEXH@Z		; CPiercing::SetVisKeepTimeSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\piercing.h
;	COMDAT ?SetVisKeepTimeSize@CPiercing@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetVisKeepTimeSize@CPiercing@@QAEXH@Z PROC NEAR	; CPiercing::SetVisKeepTimeSize, COMDAT
; _this$ = ecx

; 40   : 	void	SetVisKeepTimeSize( int nSize )	{ m_vtmPetVis.resize( min( nSize, MAX_VIS ), 0 ); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nSize$[esp-4]
  00004	83 f8 09	 cmp	 eax, 9
  00007	7c 05		 jl	 SHORT $L295347
  00009	b8 09 00 00 00	 mov	 eax, 9
$L295347:
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	83 c1 24	 add	 ecx, 36			; 00000024H
  00014	e8 00 00 00 00	 call	 ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ; std::vector<long,std::allocator<long> >::resize
  00019	c2 04 00	 ret	 4
?SetVisKeepTimeSize@CPiercing@@QAEXH@Z ENDP		; CPiercing::SetVisKeepTimeSize
_TEXT	ENDS
PUBLIC	?SetVisKeepTimeSize@CItemElem@@QAEXH@Z		; CItemElem::SetVisKeepTimeSize
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\item.h
;	COMDAT ?SetVisKeepTimeSize@CItemElem@@QAEXH@Z
_TEXT	SEGMENT
_nSize$ = 8						; size = 4
?SetVisKeepTimeSize@CItemElem@@QAEXH@Z PROC NEAR	; CItemElem::SetVisKeepTimeSize, COMDAT
; _this$ = ecx

; 276  : 	void	SetVisKeepTimeSize( int nSize )				{ m_piercing.SetVisKeepTimeSize( nSize ); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nSize$[esp-4]
  00004	83 f8 09	 cmp	 eax, 9
  00007	7c 05		 jl	 SHORT $L295356
  00009	b8 09 00 00 00	 mov	 eax, 9
$L295356:
  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	83 c1 60	 add	 ecx, 96			; 00000060H
  00014	e8 00 00 00 00	 call	 ?resize@?$vector@JV?$allocator@J@std@@@std@@QAEXIJ@Z ; std::vector<long,std::allocator<long> >::resize
  00019	c2 04 00	 ret	 4
?SetVisKeepTimeSize@CItemElem@@QAEXH@Z ENDP		; CItemElem::SetVisKeepTimeSize
_TEXT	ENDS
PUBLIC	?UpdateItem@CMover@@QAEXEDKK@Z			; CMover::UpdateItem
EXTRN	?AddUpdateItem@CUser@@QAEXDEDKK@Z:NEAR		; CUser::AddUpdateItem
EXTRN	?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z:NEAR ; CMover::ActivateEatPet
EXTRN	?InactivateEatPet@CMover@@QAEXXZ:NEAR		; CMover::InactivateEatPet
EXTRN	?RemoveItemId@CMover@@QAEXK@Z:NEAR		; CMover::RemoveItemId
EXTRN	?SetSwapVisItem@CItemElem@@QAEXHH@Z:NEAR	; CItemElem::SetSwapVisItem
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_common\moverparam.cpp
;	COMDAT ?UpdateItem@CMover@@QAEXEDKK@Z
_TEXT	SEGMENT
$T295362 = -16						; size = 8
$T295418 = -8						; size = 8
$T295361 = -8						; size = 8
_nId$ = 8						; size = 1
_cParam$ = 12						; size = 1
_dwValue$ = 16						; size = 4
_dwTime$ = 20						; size = 4
?UpdateItem@CMover@@QAEXEDKK@Z PROC NEAR		; CMover::UpdateItem, COMDAT
; _this$ = ecx

; 3996 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 3997 : 	CItemBase* pItemBase = GetItemId( nId );

  00005	0f b6 6c 24 1c	 movzx	 ebp, BYTE PTR _nId$[esp+20]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	55		 push	 ebp
  0000d	8b f9		 mov	 edi, ecx
  0000f	e8 00 00 00 00	 call	 ?GetItemId@CMover@@QAEPAVCItemBase@@K@Z ; CMover::GetItemId
  00014	8b f0		 mov	 esi, eax

; 3998 : 
; 3999 : 	if( pItemBase )

  00016	85 f6		 test	 esi, esi
  00018	0f 84 19 02 00
	00		 je	 $L295432

; 4000 : 	{
; 4001 : 		switch( cParam )

  0001e	0f be 44 24 28	 movsx	 eax, BYTE PTR _cParam$[esp+28]
  00023	83 f8 12	 cmp	 eax, 18			; 00000012H
  00026	0f 87 0b 02 00
	00		 ja	 $L295432
  0002c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L295433[eax*4]
$L276570:

; 4002 : 		{
; 4003 : 			case UI_COOLTIME:
; 4004 : 			case UI_NUM:
; 4005 : 				{
; 4006 : 					if( (int)dwValue <= 0 ) 

  00033	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  00037	85 db		 test	 ebx, ebx
  00039	7f 0d		 jg	 SHORT $L276572

; 4007 : 					{
; 4008 : 						RemoveItemId( nId );

  0003b	55		 push	 ebp
  0003c	8b cf		 mov	 ecx, edi
  0003e	e8 00 00 00 00	 call	 ?RemoveItemId@CMover@@QAEXK@Z ; CMover::RemoveItemId

; 4009 : 					}
; 4010 : 					else 

  00043	e9 f3 01 00 00	 jmp	 $L276659
$L276572:

; 4011 : 					{
; 4012 : 						( (CItemElem*)pItemBase )->m_nItemNum	= (short)( dwValue );

  00048	66 89 9e 80 00
	00 00		 mov	 WORD PTR [esi+128], bx

; 4013 : 					}
; 4014 : 					break;

  0004f	e9 e7 01 00 00	 jmp	 $L276659
$L276576:

; 4015 : 				}
; 4016 : 			case UI_HP:
; 4017 : 				{
; 4018 : 					( (CItemElem*)pItemBase )->m_nHitPoint	= dwValue;

  00054	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]

; 4019 : 					UpdateParam();

  00058	8b cf		 mov	 ecx, edi
  0005a	89 5e 7c	 mov	 DWORD PTR [esi+124], ebx
  0005d	e8 00 00 00 00	 call	 ?UpdateParam@CMover@@QAEXXZ ; CMover::UpdateParam

; 4020 : 					break;

  00062	e9 d4 01 00 00	 jmp	 $L276659
$L276578:

; 4021 : 				}
; 4022 : 			case UI_REPAIR_NUM:
; 4023 : 				{
; 4024 : 					( (CItemElem*)pItemBase )->m_nRepair	= dwValue;

  00067	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  0006b	89 5e 74	 mov	 DWORD PTR [esi+116], ebx

; 4025 : 					break;

  0006e	e9 c8 01 00 00	 jmp	 $L276659
$L276580:

; 4026 : 				}
; 4027 : 			case UI_RN:
; 4028 : 				{
; 4029 : 					if( ( (CItemElem*)pItemBase )->m_nRepairNumber >= 100 )

  00073	80 7e 78 64	 cmp	 BYTE PTR [esi+120], 100	; 00000064H
  00077	0f 83 04 02 00
	00		 jae	 $L276669

; 4030 : 						return;
; 4031 : 					if( dwValue > 100 )

  0007d	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  00081	83 fb 64	 cmp	 ebx, 100		; 00000064H
  00084	76 05		 jbe	 SHORT $L276583

; 4032 : 						dwValue		= 100;

  00086	bb 64 00 00 00	 mov	 ebx, 100		; 00000064H
$L276583:

; 4033 : 					( (CItemElem*)pItemBase )->m_nRepairNumber	= (BYTE)( dwValue );
; 4034 : 					UpdateParam();

  0008b	8b cf		 mov	 ecx, edi
  0008d	88 5e 78	 mov	 BYTE PTR [esi+120], bl
  00090	e8 00 00 00 00	 call	 ?UpdateParam@CMover@@QAEXXZ ; CMover::UpdateParam

; 4035 : 				}
; 4036 : 				break;

  00095	e9 a1 01 00 00	 jmp	 $L276659
$L276586:

; 4037 : 				
; 4038 : 			case UI_AO: //  + ...
; 4039 : 				{
; 4040 : #if __VER >= 13 // __EXT_ENCHANT
; 4041 : 					DWORD dwMax = 20;
; 4042 : #else // __EXT_ENCHANT
; 4043 : 					DWORD dwMax	= 10;
; 4044 : #endif // __EXT_ENCHANT
; 4045 : #if __VER >= 11 // __SYS_COLLECTING
; 4046 : 					if( ( (CItemElem*)pItemBase )->IsAccessory() )

  0009a	8b ce		 mov	 ecx, esi
  0009c	bd 14 00 00 00	 mov	 ebp, 20			; 00000014H
  000a1	e8 00 00 00 00	 call	 ?IsAccessory@CItemElem@@QAEHXZ ; CItemElem::IsAccessory
  000a6	85 c0		 test	 eax, eax
  000a8	74 00		 je	 SHORT $L276589
$L276589:

; 4047 : 						dwMax	= 20;
; 4048 : #endif	// __SYS_COLLECTING
; 4049 : #if __VER >= 11 // __SYS_IDENTIFY
; 4050 : 					if( ( (CItemElem*)pItemBase )->IsCollector( TRUE ) )

  000aa	81 7e 0c 54 67
	00 00		 cmp	 DWORD PTR [esi+12], 26452 ; 00006754H
  000b1	75 05		 jne	 SHORT $L276591

; 4051 : 						dwMax	= 5;

  000b3	bd 05 00 00 00	 mov	 ebp, 5
$L276591:

; 4052 : #endif	// __SYS_IDENTIFY
; 4053 : 					if( ( (CItemElem*)pItemBase )->GetAbilityOption() > (int)( dwMax ) )

  000b8	39 6e 70	 cmp	 DWORD PTR [esi+112], ebp
  000bb	0f 8f c0 01 00
	00		 jg	 $L276669

; 4054 : 						return;
; 4055 : 					if( dwValue > dwMax )

  000c1	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  000c5	3b dd		 cmp	 ebx, ebp
  000c7	76 02		 jbe	 SHORT $L276595

; 4056 : 						dwValue		= dwMax;

  000c9	8b dd		 mov	 ebx, ebp
$L276595:

; 4057 : 
; 4058 : 					( (CItemElem*)pItemBase )->SetAbilityOption( dwValue );
; 4059 : 					UpdateParam();

  000cb	8b cf		 mov	 ecx, edi
  000cd	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  000d0	e8 00 00 00 00	 call	 ?UpdateParam@CMover@@QAEXXZ ; CMover::UpdateParam

; 4060 : 				}
; 4061 : 				break;

  000d5	e9 61 01 00 00	 jmp	 $L276659
$L276597:

; 4062 : 			case UI_RAO: //   + ...
; 4063 : 				{
; 4064 : #if __VER >= 13 // __EXT_ENCHANT
; 4065 : 					if( ( (CItemElem*)pItemBase )->m_nResistAbilityOption > 20 )

  000da	83 be 8c 00 00
	00 14		 cmp	 DWORD PTR [esi+140], 20	; 00000014H
  000e1	0f 8f 9a 01 00
	00		 jg	 $L276669

; 4066 : #else // __EXT_ENCHANT
; 4067 : 					if( ( (CItemElem*)pItemBase )->m_nResistAbilityOption > 10 ) 
; 4068 : #endif // __EXT_ENCHANT
; 4069 : 						return;
; 4070 : #if __VER >= 13 // __EXT_ENCHANT
; 4071 : 					if( dwValue > 20 )

  000e7	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  000eb	83 fb 14	 cmp	 ebx, 20			; 00000014H
  000ee	76 05		 jbe	 SHORT $L276600

; 4072 : 						dwValue		= 20;

  000f0	bb 14 00 00 00	 mov	 ebx, 20			; 00000014H
$L276600:

; 4073 : #else // __EXT_ENCHANT
; 4074 : 					if( dwValue > 10 )
; 4075 : 						dwValue		= 10;
; 4076 : #endif // __EXT_ENCHANT
; 4077 : 					( (CItemElem*)pItemBase )->m_nResistAbilityOption	= dwValue;
; 4078 : 					UpdateParam();

  000f5	8b cf		 mov	 ecx, edi
  000f7	89 9e 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ebx
  000fd	e8 00 00 00 00	 call	 ?UpdateParam@CMover@@QAEXXZ ; CMover::UpdateParam

; 4079 : 				}
; 4080 : 				break;

  00102	e9 34 01 00 00	 jmp	 $L276659
$L276602:

; 4081 : 			case UI_IR:  //   
; 4082 : 				{
; 4083 : 					( (CItemElem*)pItemBase )->m_bItemResist	= (BYTE)( dwValue );

  00107	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]

; 4084 : 					UpdateParam();

  0010b	8b cf		 mov	 ecx, edi
  0010d	88 9e 88 00 00
	00		 mov	 BYTE PTR [esi+136], bl
  00113	e8 00 00 00 00	 call	 ?UpdateParam@CMover@@QAEXXZ ; CMover::UpdateParam

; 4085 : 				}
; 4086 : 				break;

  00118	e9 1e 01 00 00	 jmp	 $L276659
$L276605:

; 4087 : 
; 4088 : 			case UI_PIERCING_SIZE:
; 4089 : 				( (CItemElem*)pItemBase )->SetPiercingSize( dwValue );

  0011d	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  00121	53		 push	 ebx
  00122	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  00125	e8 00 00 00 00	 call	 ?SetPiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetPiercingSize

; 4090 : 				break;

  0012a	e9 0c 01 00 00	 jmp	 $L276659
$L276607:

; 4091 : 			case UI_PIERCING:
; 4092 : 				{
; 4093 : 					WORD wIndex	= LOWORD( dwValue ), wItemId	= HIWORD( dwValue );

  0012f	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  00133	8b c3		 mov	 eax, ebx
  00135	c1 e8 10	 shr	 eax, 16			; 00000010H

; 4094 : 					( (CItemElem*)pItemBase )->SetPiercingItem( wIndex, wItemId );

  00138	0f b7 cb	 movzx	 ecx, bx
  0013b	50		 push	 eax
  0013c	51		 push	 ecx
  0013d	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  00140	e8 00 00 00 00	 call	 ?SetPiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetPiercingItem

; 4095 : 				}
; 4096 : 				break;

  00145	e9 f1 00 00 00	 jmp	 $L276659
$L276615:

; 4097 : 
; 4098 : #if __VER >= 12 // __EXT_PIERCING
; 4099 : 			case UI_ULTIMATE_PIERCING_SIZE:
; 4100 : 				( (CItemElem*)pItemBase )->SetUltimatePiercingSize( dwValue );

  0014a	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  0014e	53		 push	 ebx
  0014f	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  00152	e8 00 00 00 00	 call	 ?SetUltimatePiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetUltimatePiercingSize

; 4101 : 				break;

  00157	e9 df 00 00 00	 jmp	 $L276659
$L276617:

; 4102 : 			case UI_ULTIMATE_PIERCING:
; 4103 : 				{
; 4104 : 					WORD wIndex	= LOWORD( dwValue ), wItemId	= HIWORD( dwValue );

  0015c	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  00160	8b d3		 mov	 edx, ebx
  00162	c1 ea 10	 shr	 edx, 16			; 00000010H

; 4105 : 					( (CItemElem*)pItemBase )->SetUltimatePiercingItem( wIndex, wItemId );

  00165	0f b7 c3	 movzx	 eax, bx
  00168	52		 push	 edx
  00169	50		 push	 eax
  0016a	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  0016d	e8 00 00 00 00	 call	 ?SetUltimatePiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetUltimatePiercingItem

; 4106 : 				}
; 4107 : 				break;

  00172	e9 c4 00 00 00	 jmp	 $L276659
$L276625:

; 4108 : #endif // __EXT_PIERCING
; 4109 : 
; 4110 : #if __VER >= 15 // __PETVIS
; 4111 : 			case UI_PETVIS_SIZE:	
; 4112 : 				{
; 4113 : 					static_cast<CItemElem*>(pItemBase)->SetPiercingSize( dwValue );

  00177	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  0017b	53		 push	 ebx
  0017c	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  0017f	e8 00 00 00 00	 call	 ?SetPiercingSize@CPiercing@@QAEXH@Z ; CPiercing::SetPiercingSize

; 4114 : 					static_cast<CItemElem*>(pItemBase)->SetVisKeepTimeSize( dwValue );

  00184	53		 push	 ebx
  00185	8b ce		 mov	 ecx, esi
  00187	e8 00 00 00 00	 call	 ?SetVisKeepTimeSize@CItemElem@@QAEXH@Z ; CItemElem::SetVisKeepTimeSize

; 4115 : 
; 4116 : #ifdef __CLIENT	//sun :   (     )   
; 4117 : 					PLAYSND(SND_INF_EQUIPACCESSORY, &g_pPlayer->GetPos());
; 4118 : #endif // __CLIENT
; 4119 : 				}
; 4120 : 				break;

  0018c	e9 aa 00 00 00	 jmp	 $L276659
$L276628:

; 4224 : 			ActivateEatPet( static_cast<CItemElem*>( pItemBase ) );

  00191	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  00195	8b d3		 mov	 edx, ebx
  00197	c1 ea 10	 shr	 edx, 16			; 00000010H
  0019a	0f b7 eb	 movzx	 ebp, bx
  0019d	52		 push	 edx
  0019e	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  001a1	55		 push	 ebp
  001a2	e8 00 00 00 00	 call	 ?SetPiercingItem@CPiercing@@QAEXHK@Z ; CPiercing::SetPiercingItem
  001a7	8b 44 24 30	 mov	 eax, DWORD PTR _dwTime$[esp+28]
  001ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_tCurrent@@3JA ; g_tCurrent
  001b1	6b c0 3c	 imul	 eax, 60			; 0000003cH
  001b4	03 c2		 add	 eax, edx
  001b6	50		 push	 eax
  001b7	55		 push	 ebp
  001b8	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  001bb	e8 00 00 00 00	 call	 ?SetVisKeepTime@CPiercing@@QAEXHJ@Z ; CPiercing::SetVisKeepTime
  001c0	eb 79		 jmp	 SHORT $L276659
$L276637:

; 4121 : 			case UI_PETVIS_ITEM:
; 4122 : 				{
; 4123 : 					WORD wIndex	= LOWORD( dwValue ), wItemId	= HIWORD( dwValue );
; 4124 : 					static_cast<CItemElem*>(pItemBase)->SetPiercingItem( wIndex, wItemId );
; 4125 : 					static_cast<CItemElem*>(pItemBase)->SetVisKeepTime( wIndex, ( dwTime * 60 ) + time_null() ); //    
; 4126 : 
; 4127 : #ifdef __CLIENT
; 4128 : 					PLAYSND(SND_INF_EQUIPACCESSORY, &g_pPlayer->GetPos());
; 4129 : #endif // __CLIENT
; 4130 : 				}
; 4131 : 				break;
; 4132 : 
; 4133 : 			case UI_PETVIS_ITEMSWAP:
; 4134 : 				{
; 4135 : 					WORD wPos1	= LOWORD( dwValue ), wPos2	= HIWORD( dwValue );

  001c2	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  001c6	8b cb		 mov	 ecx, ebx
  001c8	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 4136 : 					static_cast<CItemElem*>(pItemBase)->SetSwapVisItem( wPos1, wPos2 );

  001cb	0f b7 d3	 movzx	 edx, bx
  001ce	51		 push	 ecx
  001cf	52		 push	 edx
  001d0	8b ce		 mov	 ecx, esi
  001d2	e8 00 00 00 00	 call	 ?SetSwapVisItem@CItemElem@@QAEXHH@Z ; CItemElem::SetSwapVisItem

; 4137 : 
; 4138 : #ifdef __CLIENT
; 4139 : 					PLAYSND(SND_INF_EQUIPACCESSORY, &g_pPlayer->GetPos());
; 4140 : #endif // __CLIENT
; 4141 : 				}
; 4142 : 				break;

  001d7	eb 62		 jmp	 SHORT $L276659
$L276645:

; 4143 : 
; 4144 : 			case UI_TRANSFORM_VISPET:
; 4145 : 				{
; 4146 : 					static_cast<CItemElem*>(pItemBase)->m_bTranformVisPet = static_cast<BOOL>( dwValue );

  001d9	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  001dd	89 9e b4 00 00
	00		 mov	 DWORD PTR [esi+180], ebx

; 4147 : 					static_cast<CItemElem*>(pItemBase)->m_bCharged = TRUE;

  001e3	c7 86 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+172], 1

; 4148 : 				}
; 4149 : 				break;

  001ed	eb 4c		 jmp	 SHORT $L276659
$L276649:

; 4150 : #endif // __PETVIS
; 4151 : 
; 4152 : 			case UI_RANDOMOPTITEMID:
; 4153 : 				{
; 4154 : 					( (CItemElem*)pItemBase )->SetRandomOpt( dwValue );

  001ef	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  001f3	53		 push	 ebx
  001f4	8b ce		 mov	 ecx, esi
  001f6	e8 00 00 00 00	 call	 ?SetRandomOpt@CItemElem@@QAEXH@Z ; CItemElem::SetRandomOpt

; 4155 : 					break;

  001fb	eb 3e		 jmp	 SHORT $L276659
$L276651:

; 4156 : 				}
; 4157 : 			case UI_KEEPTIME:	// offset
; 4158 : 				{
; 4159 : 					CTime tm	= CTime::GetCurrentTime() + CTimeSpan( 0, 0, dwValue, 0 );

  001fd	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
  00201	6a 00		 push	 0
  00203	53		 push	 ebx
  00204	6a 00		 push	 0
  00206	6a 00		 push	 0
  00208	8d 4c 24 20	 lea	 ecx, DWORD PTR $T295362[esp+48]
  0020c	e8 00 00 00 00	 call	 ??0CTimeSpan@ATL@@QAE@JHHH@Z ; ATL::CTimeSpan::CTimeSpan
  00211	8b 28		 mov	 ebp, DWORD PTR [eax]
  00213	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00216	8d 4c 24 18	 lea	 ecx, DWORD PTR $T295361[esp+32]
  0021a	51		 push	 ecx
  0021b	89 44 24 20	 mov	 DWORD PTR $T295418[esp+40], eax
  0021f	e8 00 00 00 00	 call	 ?GetTickCount@CTime@ATL@@SG?AV12@XZ ; ATL::CTime::GetTickCount
  00224	8b 10		 mov	 edx, DWORD PTR [eax]
  00226	03 d5		 add	 edx, ebp

; 4160 : 					( (CItemElem*)pItemBase )->m_dwKeepTime	= (DWORD)( tm.GetTime() );

  00228	89 96 b0 00 00
	00		 mov	 DWORD PTR [esi+176], edx

; 4161 : 					break;

  0022e	eb 0b		 jmp	 SHORT $L276659
$L276658:

; 4162 : 				}
; 4163 : 
; 4164 : 			case UI_FLAG:
; 4165 : 				{
; 4166 : #ifdef __CLIENT
; 4167 : 					DWORD dwObjIndex	= (DWORD)(short)LOWORD( dwValue );
; 4168 : 					BYTE byFlag		= (BYTE)HIWORD( dwValue );
; 4169 : 					int nParts	= dwObjIndex - m_Inventory.GetSize();
; 4170 : 					if( nParts >= 0 && nParts < MAX_HUMAN_PARTS )
; 4171 : 						m_aEquipInfo[nParts].byFlag	= byFlag;
; 4172 : 					( (CItemElem*)pItemBase )->m_byFlag		= byFlag;
; 4173 : 					UpdateParts( FALSE );
; 4174 : #endif	// __CLIENT
; 4175 : 					UpdateParam();

  00230	8b cf		 mov	 ecx, edi
  00232	e8 00 00 00 00	 call	 ?UpdateParam@CMover@@QAEXXZ ; CMover::UpdateParam
$L295432:
  00237	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dwValue$[esp+28]
$L276659:

; 4176 : 					break;
; 4177 : 				}
; 4178 : 
; 4179 : 			default:
; 4180 : 				break;
; 4181 : 		}
; 4182 : #if __VER >= 9 // __CSC_VER9_1
; 4183 : #ifdef __CLIENT
; 4184 : 		CWndInventory* pWnd	= (CWndInventory*)g_WndMng.GetWndBase( APP_INVENTORY );
; 4185 : 		if( pWnd )
; 4186 : 			pWnd->UpdateTooltip();
; 4187 : 
; 4188 : // 		CWndInventory* pWnd	= (CWndInventory*)g_WndMng.GetWndBase( );		
; 4189 : // 		if( pWnd )
; 4190 : // 			pWnd->UpdateTooltip();
; 4191 : #endif	// __CLIENT
; 4192 : #endif	// __CSC_VER9_1
; 4193 : 	}
; 4194 : 	else
; 4195 : 	{
; 4196 : 		switch( cParam )
; 4197 : 		{
; 4198 : 			case UI_FLAG:
; 4199 : 				{
; 4200 : #ifdef __CLIENT
; 4201 : 					DWORD dwObjIndex	= (DWORD)(short)LOWORD( dwValue );
; 4202 : 					BYTE byFlag		= (BYTE)HIWORD( dwValue );
; 4203 : 					int nParts	= dwObjIndex - m_Inventory.GetSize();
; 4204 : 					if( nParts >= 0 && nParts < MAX_HUMAN_PARTS )
; 4205 : 					{
; 4206 : 						m_aEquipInfo[nParts].byFlag	= byFlag;
; 4207 : 						UpdateParts( TRUE );
; 4208 : 					}
; 4209 : #endif	// __CLIENT
; 4210 : 					break;
; 4211 : 				}
; 4212 : 			default:
; 4213 : 				break;
; 4214 : 		}
; 4215 : 	}
; 4216 : #ifdef __WORLDSERVER
; 4217 : 	if( IsPlayer() )

  0023b	8b 87 34 02 00
	00		 mov	 eax, DWORD PTR [edi+564]
  00241	85 c0		 test	 eax, eax
  00243	74 3c		 je	 SHORT $L276669

; 4218 : #if __VER >= 15 // __PETVIS
; 4219 : 	{
; 4220 : 		static_cast<CUser*>( this )->AddUpdateItem( 0, nId, cParam, dwValue, dwTime );

  00245	8b 44 24 30	 mov	 eax, DWORD PTR _dwTime$[esp+28]
  00249	8b 4c 24 28	 mov	 ecx, DWORD PTR _cParam$[esp+28]
  0024d	8b 54 24 24	 mov	 edx, DWORD PTR _nId$[esp+28]
  00251	50		 push	 eax
  00252	53		 push	 ebx
  00253	51		 push	 ecx
  00254	52		 push	 edx
  00255	6a 00		 push	 0
  00257	8b cf		 mov	 ecx, edi
  00259	e8 00 00 00 00	 call	 ?AddUpdateItem@CUser@@QAEXDEDKK@Z ; CUser::AddUpdateItem

; 4221 : 		if( pItemBase && cParam == UI_TRANSFORM_VISPET && HasActivatedEatPet() )

  0025e	85 f6		 test	 esi, esi
  00260	74 1f		 je	 SHORT $L276669
  00262	80 7c 24 28 12	 cmp	 BYTE PTR _cParam$[esp+28], 18 ; 00000012H
  00267	75 18		 jne	 SHORT $L276669
  00269	83 bf 7c 06 00
	00 ff		 cmp	 DWORD PTR [edi+1660], -1
  00270	74 0f		 je	 SHORT $L276669

; 4222 : 		{
; 4223 : 			InactivateEatPet();

  00272	8b cf		 mov	 ecx, edi
  00274	e8 00 00 00 00	 call	 ?InactivateEatPet@CMover@@QAEXXZ ; CMover::InactivateEatPet

; 4224 : 			ActivateEatPet( static_cast<CItemElem*>( pItemBase ) );

  00279	56		 push	 esi
  0027a	8b cf		 mov	 ecx, edi
  0027c	e8 00 00 00 00	 call	 ?ActivateEatPet@CMover@@QAEXPAVCItemElem@@@Z ; CMover::ActivateEatPet
$L276669:
  00281	5f		 pop	 edi
  00282	5e		 pop	 esi
  00283	5d		 pop	 ebp
  00284	5b		 pop	 ebx

; 4225 : 		}
; 4226 : 	}
; 4227 : #else // __PETVIS
; 4228 : 		( (CUser*)this )->AddUpdateItem( 0, nId, cParam, dwValue );
; 4229 : #endif // __PETVIS
; 4230 : #endif // __WORLDSERVER
; 4231 : }

  00285	83 c4 10	 add	 esp, 16			; 00000010H
  00288	c2 10 00	 ret	 16			; 00000010H
  0028b	90		 npad	 1
$L295433:
  0028c	00 00 00 00	 DD	 $L276570
  00290	00 00 00 00	 DD	 $L276576
  00294	00 00 00 00	 DD	 $L276580
  00298	00 00 00 00	 DD	 $L276586
  0029c	00 00 00 00	 DD	 $L276597
  002a0	00 00 00 00	 DD	 $L276602
  002a4	00 00 00 00	 DD	 $L276605
  002a8	00 00 00 00	 DD	 $L276607
  002ac	00 00 00 00	 DD	 $L276570
  002b0	00 00 00 00	 DD	 $L276658
  002b4	00 00 00 00	 DD	 $L276649
  002b8	00 00 00 00	 DD	 $L276651
  002bc	00 00 00 00	 DD	 $L276578
  002c0	00 00 00 00	 DD	 $L276615
  002c4	00 00 00 00	 DD	 $L276617
  002c8	00 00 00 00	 DD	 $L276625
  002cc	00 00 00 00	 DD	 $L276628
  002d0	00 00 00 00	 DD	 $L276637
  002d4	00 00 00 00	 DD	 $L276645
?UpdateItem@CMover@@QAEXEDKK@Z ENDP			; CMover::UpdateItem
_TEXT	ENDS
PUBLIC	?RemoveAllItem@CMover@@QAEHK@Z			; CMover::RemoveAllItem
; Function compile flags: /Ogty
;	COMDAT ?RemoveAllItem@CMover@@QAEHK@Z
_TEXT	SEGMENT
_nSize$ = -4						; size = 4
_dwItemId$ = 8						; size = 4
?RemoveAllItem@CMover@@QAEHK@Z PROC NEAR		; CMover::RemoveAllItem, COMDAT
; _this$ = ecx

; 3816 : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 3817 : 	int nNum = 0;
; 3818 : 	int	nSize	= m_Inventory.GetMax();

  00006	8b 87 9c 0b 00
	00		 mov	 eax, DWORD PTR [edi+2972]
  0000c	33 ed		 xor	 ebp, ebp

; 3819 : 
; 3820 : 	for( int i = 0 ; i < nSize; ++i )

  0000e	33 f6		 xor	 esi, esi
  00010	85 c0		 test	 eax, eax
  00012	89 44 24 0c	 mov	 DWORD PTR _nSize$[esp+16], eax
  00016	7e 4d		 jle	 SHORT $L295460
  00018	53		 push	 ebx
  00019	33 db		 xor	 ebx, ebx
  0001b	eb 03 8d 49 00	 npad	 5
$L295462:

; 3821 : 	{
; 3822 : 		CItemElem* pItemElem = m_Inventory.GetAtId( i );

  00020	3b b7 9c 0b 00
	00		 cmp	 esi, DWORD PTR [edi+2972]
  00026	73 2d		 jae	 SHORT $L276504
  00028	8b 87 a0 0b 00
	00		 mov	 eax, DWORD PTR [edi+2976]
  0002e	8b 4c 18 0c	 mov	 ecx, DWORD PTR [eax+ebx+12]
  00032	03 c3		 add	 eax, ebx
  00034	85 c9		 test	 ecx, ecx
  00036	74 1d		 je	 SHORT $L276504

; 3823 : 		if( pItemElem && pItemElem->m_dwItemId == dwItemId )

  00038	3b 4c 24 18	 cmp	 ecx, DWORD PTR _dwItemId$[esp+16]
  0003c	75 17		 jne	 SHORT $L276504

; 3824 : 		{
; 3825 : 			nNum += pItemElem->m_nItemNum;

  0003e	0f bf 80 80 00
	00 00		 movsx	 eax, WORD PTR [eax+128]

; 3826 : 			UpdateItem( i, UI_NUM, 0 );		// remove

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	56		 push	 esi
  0004c	8b cf		 mov	 ecx, edi
  0004e	03 e8		 add	 ebp, eax
  00050	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem
$L276504:
  00055	8b 44 24 10	 mov	 eax, DWORD PTR _nSize$[esp+20]
  00059	46		 inc	 esi
  0005a	81 c3 b8 00 00
	00		 add	 ebx, 184		; 000000b8H
  00060	3b f0		 cmp	 esi, eax
  00062	7c bc		 jl	 SHORT $L295462
  00064	5b		 pop	 ebx
$L295460:
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 3827 : 		}
; 3828 : 	}
; 3829 : 	return nNum;

  00067	8b c5		 mov	 eax, ebp
  00069	5d		 pop	 ebp

; 3830 : }

  0006a	59		 pop	 ecx
  0006b	c2 04 00	 ret	 4
?RemoveAllItem@CMover@@QAEHK@Z ENDP			; CMover::RemoveAllItem
_TEXT	ENDS
PUBLIC	?RemoveItemA@CMover@@QAEHKF@Z			; CMover::RemoveItemA
; Function compile flags: /Ogty
;	COMDAT ?RemoveItemA@CMover@@QAEHKF@Z
_TEXT	SEGMENT
_nRemnant$ = -12					; size = 2
tv278 = -8						; size = 4
_nSize$ = -4						; size = 4
_dwItemId$ = 8						; size = 4
_nNum$ = 12						; size = 2
?RemoveItemA@CMover@@QAEHKF@Z PROC NEAR			; CMover::RemoveItemA, COMDAT
; _this$ = ecx

; 3783 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	55		 push	 ebp
  00004	8b e9		 mov	 ebp, ecx

; 3784 : 	if( nNum == -1 )

  00006	8b 4c 24 18	 mov	 ecx, DWORD PTR _nNum$[esp+12]
  0000a	66 83 f9 ff	 cmp	 cx, -1
  0000e	75 13		 jne	 SHORT $L276485

; 3785 : 	{
; 3786 : 		return RemoveAllItem( dwItemId );

  00010	8b 44 24 14	 mov	 eax, DWORD PTR _dwItemId$[esp+12]
  00014	50		 push	 eax
  00015	8b cd		 mov	 ecx, ebp
  00017	e8 00 00 00 00	 call	 ?RemoveAllItem@CMover@@QAEHK@Z ; CMover::RemoveAllItem
  0001c	5d		 pop	 ebp

; 3811 : }

  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	c2 08 00	 ret	 8
$L276485:

; 3787 : 	}
; 3788 : 
; 3789 : 	int	nSize	= m_Inventory.GetMax();

  00023	8b 85 9c 0b 00
	00		 mov	 eax, DWORD PTR [ebp+2972]
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi

; 3790 : 	CItemElem* pItemElem;
; 3791 : 	short nRemnant	= nNum;
; 3792 : 
; 3793 : 	for( int i = 0 ; i < nSize && nRemnant > 0; i++ )

  0002c	33 ff		 xor	 edi, edi
  0002e	3b c7		 cmp	 eax, edi
  00030	89 44 24 18	 mov	 DWORD PTR _nSize$[esp+28], eax
  00034	89 4c 24 10	 mov	 DWORD PTR _nRemnant$[esp+28], ecx
  00038	66 8b d9	 mov	 bx, cx
  0003b	0f 8e 8d 00 00
	00		 jle	 $L295491

; 3787 : 	}
; 3788 : 
; 3789 : 	int	nSize	= m_Inventory.GetMax();

  00041	89 7c 24 14	 mov	 DWORD PTR tv278[esp+28], edi
$L295490:

; 3790 : 	CItemElem* pItemElem;
; 3791 : 	short nRemnant	= nNum;
; 3792 : 
; 3793 : 	for( int i = 0 ; i < nSize && nRemnant > 0; i++ )

  00045	66 85 db	 test	 bx, bx
  00048	0f 8e 80 00 00
	00		 jle	 $L295491

; 3794 : 	{
; 3795 : 		pItemElem	= m_Inventory.GetAtId( i );

  0004e	3b bd 9c 0b 00
	00		 cmp	 edi, DWORD PTR [ebp+2972]
  00054	73 5d		 jae	 SHORT $L276491
  00056	8b b5 a0 0b 00
	00		 mov	 esi, DWORD PTR [ebp+2976]
  0005c	8b 54 24 14	 mov	 edx, DWORD PTR tv278[esp+28]
  00060	8b 44 16 0c	 mov	 eax, DWORD PTR [esi+edx+12]
  00064	03 f2		 add	 esi, edx
  00066	85 c0		 test	 eax, eax
  00068	74 49		 je	 SHORT $L276491

; 3796 : 		if( pItemElem && pItemElem->m_dwItemId == dwItemId )

  0006a	3b 44 24 20	 cmp	 eax, DWORD PTR _dwItemId$[esp+24]
  0006e	75 43		 jne	 SHORT $L276491

; 3797 : 		{
; 3798 : 			if( nRemnant > pItemElem->m_nItemNum )

  00070	66 8b 86 80 00
	00 00		 mov	 ax, WORD PTR [esi+128]
  00077	66 3b d8	 cmp	 bx, ax

; 3799 : 			{
; 3800 : 				UpdateItem( i, UI_NUM, 0 );	// remove

  0007a	6a 00		 push	 0
  0007c	7e 15		 jle	 SHORT $L276494
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	57		 push	 edi
  00083	8b cd		 mov	 ecx, ebp
  00085	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 3801 : 				nRemnant	-= pItemElem->m_nItemNum;

  0008a	66 2b 9e 80 00
	00 00		 sub	 bx, WORD PTR [esi+128]

; 3802 : 			}
; 3803 : 			else

  00091	eb 20		 jmp	 SHORT $L276491
$L276494:

; 3804 : 			{
; 3805 : 				UpdateItem( i, UI_NUM, pItemElem->m_nItemNum - nRemnant );

  00093	0f bf c8	 movsx	 ecx, ax
  00096	0f bf d3	 movsx	 edx, bx
  00099	2b ca		 sub	 ecx, edx
  0009b	51		 push	 ecx
  0009c	6a 00		 push	 0
  0009e	57		 push	 edi
  0009f	8b cd		 mov	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 ?UpdateItem@CMover@@QAEXEDKK@Z ; CMover::UpdateItem

; 3806 : 				nRemnant	= 0;

  000a6	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _nRemnant$[esp+28], 0
  000ae	66 8b 5c 24 10	 mov	 bx, WORD PTR _nRemnant$[esp+28]
$L276491:
  000b3	8b 4c 24 14	 mov	 ecx, DWORD PTR tv278[esp+28]
  000b7	8b 44 24 18	 mov	 eax, DWORD PTR _nSize$[esp+28]
  000bb	47		 inc	 edi
  000bc	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  000c2	3b f8		 cmp	 edi, eax
  000c4	89 4c 24 14	 mov	 DWORD PTR tv278[esp+28], ecx
  000c8	0f 8c 77 ff ff
	ff		 jl	 $L295490
$L295491:

; 3807 : 			}
; 3808 : 		}
; 3809 : 	}
; 3810 : 	return ( nNum - nRemnant );

  000ce	0f bf 44 24 24	 movsx	 eax, WORD PTR _nNum$[esp+24]
  000d3	5f		 pop	 edi
  000d4	0f bf cb	 movsx	 ecx, bx
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	2b c1		 sub	 eax, ecx
  000db	5d		 pop	 ebp

; 3811 : }

  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	c2 08 00	 ret	 8
?RemoveItemA@CMover@@QAEHKF@Z ENDP			; CMover::RemoveItemA
_TEXT	ENDS
END
